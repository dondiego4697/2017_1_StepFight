/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 186);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * String of the current PIXI version.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name VERSION
 * @type {string}
 */
var VERSION = exports.VERSION = '4.4.3';

/**
 * Two Pi.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {number}
 */
var PI_2 = exports.PI_2 = Math.PI * 2;

/**
 * Conversion factor for converting radians to degrees.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {number}
 */
var RAD_TO_DEG = exports.RAD_TO_DEG = 180 / Math.PI;

/**
 * Conversion factor for converting degrees to radians.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {number}
 */
var DEG_TO_RAD = exports.DEG_TO_RAD = Math.PI / 180;

/**
 * Constant to identify the Renderer Type.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name RENDERER_TYPE
 * @type {object}
 * @property {number} UNKNOWN - Unknown render type.
 * @property {number} WEBGL - WebGL render type.
 * @property {number} CANVAS - Canvas render type.
 */
var RENDERER_TYPE = exports.RENDERER_TYPE = {
  UNKNOWN: 0,
  WEBGL: 1,
  CANVAS: 2
};

/**
 * Various blend modes supported by PIXI.
 *
 * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
 * Anything else will silently act like NORMAL.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name BLEND_MODES
 * @type {object}
 * @property {number} NORMAL
 * @property {number} ADD
 * @property {number} MULTIPLY
 * @property {number} SCREEN
 * @property {number} OVERLAY
 * @property {number} DARKEN
 * @property {number} LIGHTEN
 * @property {number} COLOR_DODGE
 * @property {number} COLOR_BURN
 * @property {number} HARD_LIGHT
 * @property {number} SOFT_LIGHT
 * @property {number} DIFFERENCE
 * @property {number} EXCLUSION
 * @property {number} HUE
 * @property {number} SATURATION
 * @property {number} COLOR
 * @property {number} LUMINOSITY
 */
var BLEND_MODES = exports.BLEND_MODES = {
  NORMAL: 0,
  ADD: 1,
  MULTIPLY: 2,
  SCREEN: 3,
  OVERLAY: 4,
  DARKEN: 5,
  LIGHTEN: 6,
  COLOR_DODGE: 7,
  COLOR_BURN: 8,
  HARD_LIGHT: 9,
  SOFT_LIGHT: 10,
  DIFFERENCE: 11,
  EXCLUSION: 12,
  HUE: 13,
  SATURATION: 14,
  COLOR: 15,
  LUMINOSITY: 16
};

/**
 * Various webgl draw modes. These can be used to specify which GL drawMode to use
 * under certain situations and renderers.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name DRAW_MODES
 * @type {object}
 * @property {number} POINTS
 * @property {number} LINES
 * @property {number} LINE_LOOP
 * @property {number} LINE_STRIP
 * @property {number} TRIANGLES
 * @property {number} TRIANGLE_STRIP
 * @property {number} TRIANGLE_FAN
 */
var DRAW_MODES = exports.DRAW_MODES = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};

/**
 * The scale modes that are supported by pixi.
 *
 * The {@link PIXI.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.
 * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name SCALE_MODES
 * @type {object}
 * @property {number} LINEAR Smooth scaling
 * @property {number} NEAREST Pixelating scaling
 */
var SCALE_MODES = exports.SCALE_MODES = {
  LINEAR: 0,
  NEAREST: 1
};

/**
 * The wrap modes that are supported by pixi.
 *
 * The {@link PIXI.settings.WRAP_MODE} wrap mode affects the default wraping mode of future operations.
 * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.
 * If the texture is non power of two then clamp will be used regardless as webGL can
 * only use REPEAT if the texture is po2.
 *
 * This property only affects WebGL.
 *
 * @static
 * @constant
 * @name WRAP_MODES
 * @memberof PIXI
 * @type {object}
 * @property {number} CLAMP - The textures uvs are clamped
 * @property {number} REPEAT - The texture uvs tile and repeat
 * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring
 */
var WRAP_MODES = exports.WRAP_MODES = {
  CLAMP: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};

/**
 * The gc modes that are supported by pixi.
 *
 * The {@link PIXI.settings.GC_MODE} Garbage Collection mode for pixi textures is AUTO
 * If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
 * used for a specified period of time they will be removed from the GPU. They will of course
 * be uploaded again when they are required. This is a silent behind the scenes process that
 * should ensure that the GPU does not  get filled up.
 *
 * Handy for mobile devices!
 * This property only affects WebGL.
 *
 * @static
 * @constant
 * @name GC_MODES
 * @memberof PIXI
 * @type {object}
 * @property {number} AUTO - Garbage collection will happen periodically automatically
 * @property {number} MANUAL - Garbage collection will need to be called manually
 */
var GC_MODES = exports.GC_MODES = {
  AUTO: 0,
  MANUAL: 1
};

/**
 * Regexp for image type by extension.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @type {RegExp|string}
 * @example `image.png`
 */
var URL_FILE_EXTENSION = exports.URL_FILE_EXTENSION = /\.(\w{3,4})(?:$|\?|#)/i;

/**
 * Regexp for data URI.
 * Based on: {@link https://github.com/ragingwind/data-uri-regex}
 *
 * @static
 * @constant
 * @name DATA_URI
 * @memberof PIXI
 * @type {RegExp|string}
 * @example data:image/png;base64
 */
var DATA_URI = exports.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;(charset=[\w-]+|base64))?,(.*)/i;

/**
 * Regexp for SVG size.
 *
 * @static
 * @constant
 * @name SVG_SIZE
 * @memberof PIXI
 * @type {RegExp|string}
 * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
 */
var SVG_SIZE = exports.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len

/**
 * Constants that identify shapes, mainly to prevent `instanceof` calls.
 *
 * @static
 * @constant
 * @name SHAPES
 * @memberof PIXI
 * @type {object}
 * @property {number} POLY Polygon
 * @property {number} RECT Rectangle
 * @property {number} CIRC Circle
 * @property {number} ELIP Ellipse
 * @property {number} RREC Rounded Rectangle
 */
var SHAPES = exports.SHAPES = {
  POLY: 0,
  RECT: 1,
  CIRC: 2,
  ELIP: 3,
  RREC: 4
};

/**
 * Constants that specify float precision in shaders.
 *
 * @static
 * @constant
 * @name PRECISION
 * @memberof PIXI
 * @type {object}
 * @property {string} LOW='lowp'
 * @property {string} MEDIUM='mediump'
 * @property {string} HIGH='highp'
 */
var PRECISION = exports.PRECISION = {
  LOW: 'lowp',
  MEDIUM: 'mediump',
  HIGH: 'highp'
};

/**
 * Constants that specify the transform type.
 *
 * @static
 * @constant
 * @name TRANSFORM_MODE
 * @memberof PIXI
 * @type {object}
 * @property {number} STATIC
 * @property {number} DYNAMIC
 */
var TRANSFORM_MODE = exports.TRANSFORM_MODE = {
  STATIC: 0,
  DYNAMIC: 1
};

/**
 * Constants that define the type of gradient on text.
 *
 * @static
 * @constant
 * @name TEXT_GRADIENT
 * @memberof PIXI
 * @type {object}
 * @property {number} LINEAR_VERTICAL Vertical gradient
 * @property {number} LINEAR_HORIZONTAL Linear gradient
 */
var TEXT_GRADIENT = exports.TEXT_GRADIENT = {
  LINEAR_VERTICAL: 0,
  LINEAR_HORIZONTAL: 1
};
//# sourceMappingURL=const.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.BaseTextureCache = exports.TextureCache = exports.mixins = exports.pluginTarget = exports.EventEmitter = exports.isMobile = undefined;
exports.uid = uid;
exports.hex2rgb = hex2rgb;
exports.hex2string = hex2string;
exports.rgb2hex = rgb2hex;
exports.getResolutionOfUrl = getResolutionOfUrl;
exports.decomposeDataUri = decomposeDataUri;
exports.getUrlFileExtension = getUrlFileExtension;
exports.getSvgSize = getSvgSize;
exports.skipHello = skipHello;
exports.sayHello = sayHello;
exports.isWebGLSupported = isWebGLSupported;
exports.sign = sign;
exports.removeItems = removeItems;
exports.destroyTextureCache = destroyTextureCache;
exports.clearTextureCache = clearTextureCache;

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _eventemitter = __webpack_require__(9);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _pluginTarget = __webpack_require__(158);

var _pluginTarget2 = _interopRequireDefault(_pluginTarget);

var _mixin = __webpack_require__(157);

var mixins = _interopRequireWildcard(_mixin);

var _ismobilejs = __webpack_require__(46);

var isMobile = _interopRequireWildcard(_ismobilejs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nextUid = 0;
var saidHello = false;

/**
 * @namespace PIXI.utils
 */
exports.isMobile = isMobile;
exports.EventEmitter = _eventemitter2.default;
exports.pluginTarget = _pluginTarget2.default;
exports.mixins = mixins;

/**
 * Gets the next unique identifier
 *
 * @memberof PIXI.utils
 * @function uid
 * @return {number} The next unique identifier to use.
 */

function uid() {
    return ++nextUid;
}

/**
 * Converts a hex color number to an [R, G, B] array
 *
 * @memberof PIXI.utils
 * @function hex2rgb
 * @param {number} hex - The number to convert
 * @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
 * @return {number[]} An array representing the [R, G, B] of the color.
 */
function hex2rgb(hex, out) {
    out = out || [];

    out[0] = (hex >> 16 & 0xFF) / 255;
    out[1] = (hex >> 8 & 0xFF) / 255;
    out[2] = (hex & 0xFF) / 255;

    return out;
}

/**
 * Converts a hex color number to a string.
 *
 * @memberof PIXI.utils
 * @function hex2string
 * @param {number} hex - Number in hex
 * @return {string} The string color.
 */
function hex2string(hex) {
    hex = hex.toString(16);
    hex = '000000'.substr(0, 6 - hex.length) + hex;

    return '#' + hex;
}

/**
 * Converts a color as an [R, G, B] array to a hex number
 *
 * @memberof PIXI.utils
 * @function rgb2hex
 * @param {number[]} rgb - rgb array
 * @return {number} The color number
 */
function rgb2hex(rgb) {
    return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);
}

/**
 * get the resolution / device pixel ratio of an asset by looking for the prefix
 * used by spritesheets and image urls
 *
 * @memberof PIXI.utils
 * @function getResolutionOfUrl
 * @param {string} url - the image path
 * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.
 * @return {number} resolution / device pixel ratio of an asset
 */
function getResolutionOfUrl(url, defaultValue) {
    var resolution = _settings2.default.RETINA_PREFIX.exec(url);

    if (resolution) {
        return parseFloat(resolution[1]);
    }

    return defaultValue !== undefined ? defaultValue : 1;
}

/**
 * Typedef for decomposeDataUri return object.
 *
 * @typedef {object} DecomposedDataUri
 * @property {mediaType} Media type, eg. `image`
 * @property {subType} Sub type, eg. `png`
 * @property {encoding} Data encoding, eg. `base64`
 * @property {data} The actual data
 */

/**
 * Split a data URI into components. Returns undefined if
 * parameter `dataUri` is not a valid data URI.
 *
 * @memberof PIXI.utils
 * @function decomposeDataUri
 * @param {string} dataUri - the data URI to check
 * @return {DecomposedDataUri|undefined} The decomposed data uri or undefined
 */
function decomposeDataUri(dataUri) {
    var dataUriMatch = _const.DATA_URI.exec(dataUri);

    if (dataUriMatch) {
        return {
            mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
            subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
            encoding: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
            data: dataUriMatch[4]
        };
    }

    return undefined;
}

/**
 * Get type of the image by regexp for extension. Returns undefined for unknown extensions.
 *
 * @memberof PIXI.utils
 * @function getUrlFileExtension
 * @param {string} url - the image path
 * @return {string|undefined} image extension
 */
function getUrlFileExtension(url) {
    var extension = _const.URL_FILE_EXTENSION.exec(url);

    if (extension) {
        return extension[1].toLowerCase();
    }

    return undefined;
}

/**
 * Typedef for Size object.
 *
 * @typedef {object} Size
 * @property {width} Width component
 * @property {height} Height component
 */

/**
 * Get size from an svg string using regexp.
 *
 * @memberof PIXI.utils
 * @function getSvgSize
 * @param {string} svgString - a serialized svg element
 * @return {Size|undefined} image extension
 */
function getSvgSize(svgString) {
    var sizeMatch = _const.SVG_SIZE.exec(svgString);
    var size = {};

    if (sizeMatch) {
        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }

    return size;
}

/**
 * Skips the hello message of renderers that are created after this is run.
 *
 * @function skipHello
 * @memberof PIXI.utils
 */
function skipHello() {
    saidHello = true;
}

/**
 * Logs out the version and renderer information for this running instance of PIXI.
 * If you don't want to see this message you can run `PIXI.utils.skipHello()` before
 * creating your renderer. Keep in mind that doing that will forever makes you a jerk face.
 *
 * @static
 * @function sayHello
 * @memberof PIXI.utils
 * @param {string} type - The string renderer type to log.
 */
function sayHello(type) {
    if (saidHello) {
        return;
    }

    if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var args = ['\n %c %c %c Pixi.js ' + _const.VERSION + ' - \u2730 ' + type + ' \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n', 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];

        window.console.log.apply(console, args);
    } else if (window.console) {
        window.console.log('Pixi.js ' + _const.VERSION + ' - ' + type + ' - http://www.pixijs.com/');
    }

    saidHello = true;
}

/**
 * Helper for checking for webgl support
 *
 * @memberof PIXI.utils
 * @function isWebGLSupported
 * @return {boolean} is webgl supported
 */
function isWebGLSupported() {
    var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };

    try {
        if (!window.WebGLRenderingContext) {
            return false;
        }

        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);

        var success = !!(gl && gl.getContextAttributes().stencil);

        if (gl) {
            var loseContext = gl.getExtension('WEBGL_lose_context');

            if (loseContext) {
                loseContext.loseContext();
            }
        }

        gl = null;

        return success;
    } catch (e) {
        return false;
    }
}

/**
 * Returns sign of number
 *
 * @memberof PIXI.utils
 * @function sign
 * @param {number} n - the number to check the sign of
 * @returns {number} 0 if `n` is 0, -1 if `n` is negative, 1 if `n` is positive
 */
function sign(n) {
    if (n === 0) return 0;

    return n < 0 ? -1 : 1;
}

/**
 * Remove a range of items from an array
 *
 * @memberof PIXI.utils
 * @function removeItems
 * @param {Array<*>} arr The target array
 * @param {number} startIdx The index to begin removing from (inclusive)
 * @param {number} removeCount How many items to remove
 */
function removeItems(arr, startIdx, removeCount) {
    var length = arr.length;

    if (startIdx >= length || removeCount === 0) {
        return;
    }

    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;

    var len = length - removeCount;

    for (var i = startIdx; i < len; ++i) {
        arr[i] = arr[i + removeCount];
    }

    arr.length = len;
}

/**
 * @todo Describe property usage
 *
 * @memberof PIXI.utils
 * @private
 */
var TextureCache = exports.TextureCache = {};

/**
 * @todo Describe property usage
 *
 * @memberof PIXI.utils
 * @private
 */
var BaseTextureCache = exports.BaseTextureCache = {};

/**
 * Destroys all texture in the cache
 *
 * @memberof PIXI.utils
 * @function destroyTextureCache
 */
function destroyTextureCache() {
    var key = void 0;

    for (key in TextureCache) {
        TextureCache[key].destroy();
    }
    for (key in BaseTextureCache) {
        BaseTextureCache[key].destroy();
    }
}

/**
 * Removes all textures from cache, but does not destroy them
 *
 * @memberof PIXI.utils
 * @function clearTextureCache
 */
function clearTextureCache() {
    var key = void 0;

    for (key in TextureCache) {
        delete TextureCache[key];
    }
    for (key in BaseTextureCache) {
        delete BaseTextureCache[key];
    }
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Point = __webpack_require__(29);

Object.defineProperty(exports, 'Point', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Point).default;
  }
});

var _ObservablePoint = __webpack_require__(128);

Object.defineProperty(exports, 'ObservablePoint', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ObservablePoint).default;
  }
});

var _Matrix = __webpack_require__(64);

Object.defineProperty(exports, 'Matrix', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Matrix).default;
  }
});

var _GroupD = __webpack_require__(63);

Object.defineProperty(exports, 'GroupD8', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_GroupD).default;
  }
});

var _Circle = __webpack_require__(129);

Object.defineProperty(exports, 'Circle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Circle).default;
  }
});

var _Ellipse = __webpack_require__(130);

Object.defineProperty(exports, 'Ellipse', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Ellipse).default;
  }
});

var _Polygon = __webpack_require__(131);

Object.defineProperty(exports, 'Polygon', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Polygon).default;
  }
});

var _Rectangle = __webpack_require__(30);

Object.defineProperty(exports, 'Rectangle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Rectangle).default;
  }
});

var _RoundedRectangle = __webpack_require__(132);

Object.defineProperty(exports, 'RoundedRectangle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RoundedRectangle).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _maxRecommendedTextures = __webpack_require__(156);

var _maxRecommendedTextures2 = _interopRequireDefault(_maxRecommendedTextures);

var _canUploadSameBuffer = __webpack_require__(154);

var _canUploadSameBuffer2 = _interopRequireDefault(_canUploadSameBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace PIXI.settings
 */
exports.default = {

  /**
   * Target frames per millisecond.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 0.06
   */
  TARGET_FPMS: 0.06,

  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   *
   * @static
   * @memberof PIXI.settings
   * @type {boolean}
   * @default true
   */
  MIPMAP_TEXTURES: true,

  /**
   * Default resolution / device pixel ratio of the renderer.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,

  /**
   * Default filter resolution.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,

  /**
   * The maximum textures that this device supports.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: (0, _maxRecommendedTextures2.default)(32),

  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000

  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,

  /**
   * The prefix that denotes a URL is for a retina asset.
   *
   * @static
   * @memberof PIXI.settings
   * @type {RegExp}
   * @example `@2x`
   * @default /@([0-9\.]+)x/
   */
  RETINA_PREFIX: /@([0-9\.]+)x/,

  /**
   * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
   * or {@link PIXI.CanvasRenderer}.
   *
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} view=null
   * @property {number} resolution=1
   * @property {boolean} antialias=false
   * @property {boolean} forceFXAA=false
   * @property {boolean} autoResize=false
   * @property {boolean} transparent=false
   * @property {number} backgroundColor=0x000000
   * @property {boolean} clearBeforeRender=true
   * @property {boolean} preserveDrawingBuffer=false
   * @property {boolean} roundPixels=false
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    forceFXAA: false,
    autoResize: false,
    transparent: false,
    backgroundColor: 0x000000,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    roundPixels: false
  },

  /**
   * Default transform type.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.TRANSFORM_MODE}
   * @default PIXI.TRANSFORM_MODE.STATIC
   */
  TRANSFORM_MODE: 0,

  /**
   * Default Garbage Collection mode.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: 0,

  /**
   * Default Garbage Collection max idle.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,

  /**
   * Default Garbage Collection maximum check count.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,

  /**
   * Default wrap modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: 0,

  /**
   * The scale modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: 0,

  /**
   * Default specify float precision in vertex shader.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: 'highp',

  /**
   * Default specify float precision in fragment shader.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: 'mediump',

  /**
   * Can we upload the same buffer in a single frame?
   *
   * @static
   * @constant
   * @memberof PIXI
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: (0, _canUploadSameBuffer2.default)()

};
//# sourceMappingURL=settings.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var gl = {
    createContext:          __webpack_require__(115),
    setVertexAttribArrays:  __webpack_require__(49),
    GLBuffer:               __webpack_require__(111),
    GLFramebuffer:          __webpack_require__(112),
    GLShader:               __webpack_require__(113),
    GLTexture:              __webpack_require__(48),
    VertexArrayObject:      __webpack_require__(114),
    shader:                 __webpack_require__(116)
};

// Export for Node-compatible environments
if (typeof module !== 'undefined' && module.exports)
{
    // Export the module
    module.exports = gl;
}

// Add to the browser window pixi.gl
if (typeof window !== 'undefined')
{
    // add the window object
    window.PIXI = window.PIXI || {};
    window.PIXI.glCore = gl;
}


/***/ }),
/* 5 */,
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__http_Http__ = __webpack_require__(36);
/**
 * Created by Denis on 05.03.2017.
 */

class UserService {
    constructor() {
        this.http = new __WEBPACK_IMPORTED_MODULE_0__http_Http__["a" /* default */]();
        this.url = this.http.BaseUrl;
    }

    getUser() {
        const address = `${this.url}/user/get`;
        return new Promise((resolve, reject) => {
            this._createRequest(address, null, 'GET', null).then(response => {
                resolve(response.user);
            }).catch(e => {
                reject(e);
            });
        });
    }

    login(body) {
        const address = `${this.url}/user/login`;
        let headers = {'Content-Type': 'application/json'};
        return new Promise((resolve, reject) => {
            this._createRequest(address, headers, 'POST', body).then(response => {
                resolve(response.user);
            }).catch(e => {
                reject(e);
            });
        });
    }

    signup(body) {
        const address = `${this.url}/user/signup`;
        let headers = {'Content-Type': 'application/json'};
        return new Promise((resolve, reject) => {
            this._createRequest(address, headers, 'POST', body).then(response => {
                resolve({result: 'success'});
            }).catch(e => {
                if(!e){
                    reject({result: 'no-conn'});
                } else {
                    reject({result: 'error'});
                }
            });
        });
    }

    getLeaders() {
        const address = `${this.url}/user/leaders`;
        return new Promise((resolve, reject) => {
            this._createRequest(address, null, 'GET', null).then(response => {
                resolve(response);
            }).catch(e => {
                reject(e);
            });
        });
    }

    logOutUser() {
        const address = `${this.url}/user/logout`;
        return new Promise((resolve, reject) => {
            this._createRequest(address, null, 'GET', null).then(response => {
                resolve(response);
            }).catch(e => {
                reject(e);
            });
        });
    }

    _createRequest(address, headers = {}, type = 'GET', body = {}) {
        const http = this.http;
        return new Promise(function (resolve, reject) {
            http.request(address, headers, type, body).then(response => {
                if (response.status === '200 OK') {
                    resolve(response);
                } else {
                    console.log(response.status);
                    reject(response);
                }
            }).catch(e => {
                console.error(e.status);
                reject({});
            });
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UserService;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 17.03.2017.
 */
class BaseView {

    constructor(node) {
        this.node = node;
    }

    /**
     * Метод показывает или прячет View
     */
    toggleView() {
        this.node.classList.toggle('hidden');
    }

    destroyView(){

    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BaseView;


/***/ }),
/* 8 */,
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @api private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {Mixed} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Boolean} exists Only check if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Remove the listeners of a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {Mixed} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
         listeners.fn === fn
      && (!once || listeners.once)
      && (!context || listeners.context === context)
    ) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
           listeners[i].fn !== fn
        || (once && !listeners[i].once)
        || (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {String|Symbol} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 24.03.2017.
 */
class RouterUrls{
    constructor(){
        window.MAIN = '/';
        window.LOGIN = '/login';
        window.SIGNUP = '/signup';
        window.LEADERBOARD = '/leaderboard';
        window.ABOUT = '/about';
        window.PROFILE = '/profile';

        window.SINGLEPLAYER = '/sgame';
        window.MULTIPLAYER = '/mgame';
        window.GAMERESULT = '/gameresult';

        window.SINGLEPLAYER_STRATEGY='SINGLEPLAYERSTRATEGY';
        window.MULTIPLAYER_STRATEGY='MULTIPLAYERSTRATEGY';

        window.STATEWAIT = 'STATEWAIT';
        window.STATEGAME = 'STATEGAME';
        window.STATERESULT = 'STATERESULT';
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RouterUrls;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(1);

var _DisplayObject2 = __webpack_require__(58);

var _DisplayObject3 = _interopRequireDefault(_DisplayObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Container represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 *```js
 * let container = new PIXI.Container();
 * container.addChild(sprite);
 * ```
 *
 * @class
 * @extends PIXI.DisplayObject
 * @memberof PIXI
 */
var Container = function (_DisplayObject) {
    _inherits(Container, _DisplayObject);

    /**
     *
     */
    function Container() {
        _classCallCheck(this, Container);

        /**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */
        var _this = _possibleConstructorReturn(this, _DisplayObject.call(this));

        _this.children = [];
        return _this;
    }

    /**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @private
     */


    Container.prototype.onChildrenChange = function onChildrenChange() {}
    /* empty */


    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */
    ;

    Container.prototype.addChild = function addChild(child) {
        var argumentsLength = arguments.length;

        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.addChild(arguments[i]);
            }
        } else {
            // if the child has a parent then lets remove it as Pixi objects can only exist in one place
            if (child.parent) {
                child.parent.removeChild(child);
            }

            child.parent = this;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;

            this.children.push(child);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            child.emit('added', this);
        }

        return child;
    };

    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */


    Container.prototype.addChildAt = function addChildAt(child, index) {
        if (index < 0 || index > this.children.length) {
            throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);
        }

        if (child.parent) {
            child.parent.removeChild(child);
        }

        child.parent = this;
        // ensure child transform will be recalculated
        child.transform._parentID = -1;

        this.children.splice(index, 0, child);

        // ensure bounds will be recalculated
        this._boundsID++;

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('added', this);

        return child;
    };

    /**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */


    Container.prototype.swapChildren = function swapChildren(child, child2) {
        if (child === child2) {
            return;
        }

        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);

        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
    };

    /**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */


    Container.prototype.getChildIndex = function getChildIndex(child) {
        var index = this.children.indexOf(child);

        if (index === -1) {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }

        return index;
    };

    /**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */


    Container.prototype.setChildIndex = function setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error('The supplied index is out of bounds');
        }

        var currentIndex = this.getChildIndex(child);

        (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position
        this.children.splice(index, 0, child); // add at new position

        this.onChildrenChange(index);
    };

    /**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */


    Container.prototype.getChildAt = function getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error('getChildAt: Index (' + index + ') does not exist.');
        }

        return this.children[index];
    };

    /**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */


    Container.prototype.removeChild = function removeChild(child) {
        var argumentsLength = arguments.length;

        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.removeChild(arguments[i]);
            }
        } else {
            var index = this.children.indexOf(child);

            if (index === -1) return null;

            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            (0, _utils.removeItems)(this.children, index, 1);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            child.emit('removed', this);
        }

        return child;
    };

    /**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */


    Container.prototype.removeChildAt = function removeChildAt(index) {
        var child = this.getChildAt(index);

        // ensure child transform will be recalculated..
        child.parent = null;
        child.transform._parentID = -1;
        (0, _utils.removeItems)(this.children, index, 1);

        // ensure bounds will be recalculated
        this._boundsID++;

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('removed', this);

        return child;
    };

    /**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {DisplayObject[]} List of removed children
     */


    Container.prototype.removeChildren = function removeChildren() {
        var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var endIndex = arguments[1];

        var begin = beginIndex;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        var removed = void 0;

        if (range > 0 && range <= end) {
            removed = this.children.splice(begin, range);

            for (var i = 0; i < removed.length; ++i) {
                removed[i].parent = null;
                if (removed[i].transform) {
                    removed[i].transform._parentID = -1;
                }
            }

            this._boundsID++;

            this.onChildrenChange(beginIndex);

            for (var _i = 0; _i < removed.length; ++_i) {
                removed[_i].emit('removed', this);
            }

            return removed;
        } else if (range === 0 && this.children.length === 0) {
            return [];
        }

        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    };

    /**
     * Updates the transform on all children of this container for rendering
     */


    Container.prototype.updateTransform = function updateTransform() {
        this._boundsID++;

        this.transform.updateTransform(this.parent.transform);

        // TODO: check render flags, how to process stuff here
        this.worldAlpha = this.alpha * this.parent.worldAlpha;

        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];

            if (child.visible) {
                child.updateTransform();
            }
        }
    };

    /**
     * Recalculates the bounds of the container.
     *
     */


    Container.prototype.calculateBounds = function calculateBounds() {
        this._bounds.clear();

        this._calculateBounds();

        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];

            if (!child.visible || !child.renderable) {
                continue;
            }

            child.calculateBounds();

            // TODO: filter+mask, need to mask both somehow
            if (child._mask) {
                child._mask.calculateBounds();
                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            } else if (child.filterArea) {
                this._bounds.addBoundsArea(child._bounds, child.filterArea);
            } else {
                this._bounds.addBounds(child._bounds);
            }
        }

        this._lastBoundsID = this._boundsID;
    };

    /**
     * Recalculates the bounds of the object. Override this to
     * calculate the bounds of the specific object (not including children).
     *
     */


    Container.prototype._calculateBounds = function _calculateBounds() {}
    // FILL IN//


    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */
    ;

    Container.prototype.renderWebGL = function renderWebGL(renderer) {
        // if the object is not visible or the alpha is 0 then no need to render this element
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }

        // do a quick check to see if this element has a mask or a filter.
        if (this._mask || this._filters) {
            this.renderAdvancedWebGL(renderer);
        } else {
            this._renderWebGL(renderer);

            // simple render children!
            for (var i = 0, j = this.children.length; i < j; ++i) {
                this.children[i].renderWebGL(renderer);
            }
        }
    };

    /**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {
        renderer.flush();

        var filters = this._filters;
        var mask = this._mask;

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (filters) {
            if (!this._enabledFilters) {
                this._enabledFilters = [];
            }

            this._enabledFilters.length = 0;

            for (var i = 0; i < filters.length; i++) {
                if (filters[i].enabled) {
                    this._enabledFilters.push(filters[i]);
                }
            }

            if (this._enabledFilters.length) {
                renderer.filterManager.pushFilter(this, this._enabledFilters);
            }
        }

        if (mask) {
            renderer.maskManager.pushMask(this, this._mask);
        }

        // add this object to the batch, only rendered if it has a texture.
        this._renderWebGL(renderer);

        // now loop through the children and make sure they get rendered
        for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) {
            this.children[_i2].renderWebGL(renderer);
        }

        renderer.flush();

        if (mask) {
            renderer.maskManager.popMask(this, this._mask);
        }

        if (filters && this._enabledFilters && this._enabledFilters.length) {
            renderer.filterManager.popFilter();
        }
    };

    /**
     * To be overridden by the subclasses.
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Container.prototype._renderWebGL = function _renderWebGL(renderer) // eslint-disable-line no-unused-vars
    {}
    // this is where content itself gets rendered...


    /**
     * To be overridden by the subclass
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    ;

    Container.prototype._renderCanvas = function _renderCanvas(renderer) // eslint-disable-line no-unused-vars
    {}
    // this is where content itself gets rendered...


    /**
     * Renders the object using the Canvas renderer
     *
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    ;

    Container.prototype.renderCanvas = function renderCanvas(renderer) {
        // if not visible or the alpha is 0 then no need to render this
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }

        if (this._mask) {
            renderer.maskManager.pushMask(this._mask);
        }

        this._renderCanvas(renderer);
        for (var i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].renderCanvas(renderer);
        }

        if (this._mask) {
            renderer.maskManager.popMask(renderer);
        }
    };

    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */


    Container.prototype.destroy = function destroy(options) {
        _DisplayObject.prototype.destroy.call(this);

        var destroyChildren = typeof options === 'boolean' ? options : options && options.children;

        var oldChildren = this.removeChildren(0, this.children.length);

        if (destroyChildren) {
            for (var i = 0; i < oldChildren.length; ++i) {
                oldChildren[i].destroy(options);
            }
        }
    };

    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */


    _createClass(Container, [{
        key: 'width',
        get: function get() {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var width = this.getLocalBounds().width;

            if (width !== 0) {
                this.scale.x = value / width;
            } else {
                this.scale.x = 1;
            }

            this._width = value;
        }

        /**
         * The height of the Container, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return this.scale.y * this.getLocalBounds().height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var height = this.getLocalBounds().height;

            if (height !== 0) {
                this.scale.y = value / height;
            } else {
                this.scale.y = 1;
            }

            this._height = value;
        }
    }]);

    return Container;
}(_DisplayObject3.default);

// performance increase to avoid using call.. (10x faster)


exports.default = Container;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
//# sourceMappingURL=Container.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _SystemRenderer2 = __webpack_require__(65);

var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

var _CanvasMaskManager = __webpack_require__(133);

var _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);

var _CanvasRenderTarget = __webpack_require__(66);

var _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);

var _mapCanvasBlendModesToPixi = __webpack_require__(134);

var _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);

var _utils = __webpack_require__(1);

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should
 * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to
 * your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 */
var CanvasRenderer = function (_SystemRenderer) {
    _inherits(CanvasRenderer, _SystemRenderer);

    /**
     * @param {number} [screenWidth=800] - the width of the screen
     * @param {number} [screenHeight=600] - the height of the screen
     * @param {object} [options] - The optional renderer parameters
     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
     *  resolution of the renderer retina would be 2.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear the canvas or
     *      not before the new render pass.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when rendering,
     *  stopping pixel interpolation.
     */
    function CanvasRenderer(screenWidth, screenHeight) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, CanvasRenderer);

        var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'Canvas', screenWidth, screenHeight, options));

        _this.type = _const.RENDERER_TYPE.CANVAS;

        /**
         * The canvas 2d context that everything is drawn with.
         *
         * @member {CanvasRenderingContext2D}
         */
        _this.rootContext = _this.view.getContext('2d', { alpha: _this.transparent });

        /**
         * Boolean flag controlling canvas refresh.
         *
         * @member {boolean}
         */
        _this.refresh = true;

        /**
         * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
         *
         * @member {PIXI.CanvasMaskManager}
         */
        _this.maskManager = new _CanvasMaskManager2.default(_this);

        /**
         * The canvas property used to set the canvas smoothing property.
         *
         * @member {string}
         */
        _this.smoothProperty = 'imageSmoothingEnabled';

        if (!_this.rootContext.imageSmoothingEnabled) {
            if (_this.rootContext.webkitImageSmoothingEnabled) {
                _this.smoothProperty = 'webkitImageSmoothingEnabled';
            } else if (_this.rootContext.mozImageSmoothingEnabled) {
                _this.smoothProperty = 'mozImageSmoothingEnabled';
            } else if (_this.rootContext.oImageSmoothingEnabled) {
                _this.smoothProperty = 'oImageSmoothingEnabled';
            } else if (_this.rootContext.msImageSmoothingEnabled) {
                _this.smoothProperty = 'msImageSmoothingEnabled';
            }
        }

        _this.initPlugins();

        _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();
        _this._activeBlendMode = null;

        _this.context = null;
        _this.renderingToScreen = false;

        _this.resize(screenWidth, screenHeight);
        return _this;
    }

    /**
     * Renders the object to this canvas view
     *
     * @param {PIXI.DisplayObject} displayObject - The object to be rendered
     * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.
     *  If unset, it will render to the root context.
     * @param {boolean} [clear=false] - Whether to clear the canvas before drawing
     * @param {PIXI.Transform} [transform] - A transformation to be applied
     * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform
     */


    CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
        if (!this.view) {
            return;
        }

        // can be handy to know!
        this.renderingToScreen = !renderTexture;

        this.emit('prerender');

        var rootResolution = this.resolution;

        if (renderTexture) {
            renderTexture = renderTexture.baseTexture || renderTexture;

            if (!renderTexture._canvasRenderTarget) {
                renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);
                renderTexture.source = renderTexture._canvasRenderTarget.canvas;
                renderTexture.valid = true;
            }

            this.context = renderTexture._canvasRenderTarget.context;
            this.resolution = renderTexture._canvasRenderTarget.resolution;
        } else {
            this.context = this.rootContext;
        }

        var context = this.context;

        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }

        if (!skipUpdateTransform) {
            // update the scene graph
            var cacheParent = displayObject.parent;
            var tempWt = this._tempDisplayObjectParent.transform.worldTransform;

            if (transform) {
                transform.copy(tempWt);

                // lets not forget to flag the parent transform as dirty...
                this._tempDisplayObjectParent.transform._worldID = -1;
            } else {
                tempWt.identity();
            }

            displayObject.parent = this._tempDisplayObjectParent;

            displayObject.updateTransform();
            displayObject.parent = cacheParent;
            // displayObject.hitArea = //TODO add a temp hit area
        }

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.globalAlpha = 1;
        context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];

        if (navigator.isCocoonJS && this.view.screencanvas) {
            context.fillStyle = 'black';
            context.clear();
        }

        if (clear !== undefined ? clear : this.clearBeforeRender) {
            if (this.renderingToScreen) {
                if (this.transparent) {
                    context.clearRect(0, 0, this.width, this.height);
                } else {
                    context.fillStyle = this._backgroundColorString;
                    context.fillRect(0, 0, this.width, this.height);
                }
            } // else {
            // TODO: implement background for CanvasRenderTarget or RenderTexture?
            // }
        }

        // TODO RENDER TARGET STUFF HERE..
        var tempContext = this.context;

        this.context = context;
        displayObject.renderCanvas(this);
        this.context = tempContext;

        this.resolution = rootResolution;

        this.emit('postrender');
    };

    /**
     * Clear the canvas of renderer.
     *
     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.
     */


    CanvasRenderer.prototype.clear = function clear(clearColor) {
        var context = this.context;

        clearColor = clearColor || this._backgroundColorString;

        if (!this.transparent && clearColor) {
            context.fillStyle = clearColor;
            context.fillRect(0, 0, this.width, this.height);
        } else {
            context.clearRect(0, 0, this.width, this.height);
        }
    };

    /**
     * Sets the blend mode of the renderer.
     *
     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.
     */


    CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
        if (this._activeBlendMode === blendMode) {
            return;
        }

        this._activeBlendMode = blendMode;
        this.context.globalCompositeOperation = this.blendModes[blendMode];
    };

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */


    CanvasRenderer.prototype.destroy = function destroy(removeView) {
        this.destroyPlugins();

        // call the base destroy
        _SystemRenderer.prototype.destroy.call(this, removeView);

        this.context = null;

        this.refresh = true;

        this.maskManager.destroy();
        this.maskManager = null;

        this.smoothProperty = null;
    };

    /**
     * Resizes the canvas view to the specified width and height.
     *
     * @extends PIXI.SystemRenderer#resize
     *
     * @param {number} screenWidth - the new width of the screen
     * @param {number} screenHeight - the new height of the screen
     */


    CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
        _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);

        // reset the scale mode.. oddly this seems to be reset when the canvas is resized.
        // surely a browser bug?? Let pixi fix that for you..
        if (this.smoothProperty) {
            this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;
        }
    };

    return CanvasRenderer;
}(_SystemRenderer3.default);

exports.default = CanvasRenderer;


_utils.pluginTarget.mixin(CanvasRenderer);
//# sourceMappingURL=CanvasRenderer.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var WebGLManager = function () {
  /**
   * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
   */
  function WebGLManager(renderer) {
    _classCallCheck(this, WebGLManager);

    /**
     * The renderer this manager works for.
     *
     * @member {PIXI.WebGLRenderer}
     */
    this.renderer = renderer;

    this.renderer.on('context', this.onContextChange, this);
  }

  /**
   * Generic method called when there is a WebGL context change.
   *
   */


  WebGLManager.prototype.onContextChange = function onContextChange() {}
  // do some codes init!


  /**
   * Generic destroy methods to be overridden by the subclass
   *
   */
  ;

  WebGLManager.prototype.destroy = function destroy() {
    this.renderer.off('context', this.onContextChange, this);

    this.renderer = null;
  };

  return WebGLManager;
}();

exports.default = WebGLManager;
//# sourceMappingURL=WebGLManager.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(1);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _eventemitter = __webpack_require__(9);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _determineCrossOrigin = __webpack_require__(155);

var _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);

var _bitTwiddle = __webpack_require__(24);

var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A texture stores the information that represents an image. All textures have a base texture.
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */
var BaseTexture = function (_EventEmitter) {
    _inherits(BaseTexture, _EventEmitter);

    /**
     * @param {HTMLImageElement|HTMLCanvasElement} [source] - the source object of the texture.
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture
     */
    function BaseTexture(source, scaleMode, resolution) {
        _classCallCheck(this, BaseTexture);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.uid = (0, _utils.uid)();

        _this.touched = 0;

        /**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default 1
         */
        _this.resolution = resolution || _settings2.default.RESOLUTION;

        /**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        _this.width = 100;

        /**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        _this.height = 100;

        // TODO docs
        // used to store the actual dimensions of the source
        /**
         * Used to store the actual width of the source of this texture
         *
         * @readonly
         * @member {number}
         */
        _this.realWidth = 100;
        /**
         * Used to store the actual height of the source of this texture
         *
         * @readonly
         * @member {number}
         */
        _this.realHeight = 100;

        /**
         * The scale mode to apply when scaling this texture
         *
         * @member {number}
         * @default PIXI.settings.SCALE_MODE
         * @see PIXI.SCALE_MODES
         */
        _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;

        /**
         * Set to true once the base texture has successfully loaded.
         *
         * This is never true if the underlying source fails to load or has no texture data.
         *
         * @readonly
         * @member {boolean}
         */
        _this.hasLoaded = false;

        /**
         * Set to true if the source is currently loading.
         *
         * If an Image source is loading the 'loaded' or 'error' event will be
         * dispatched when the operation ends. An underyling source that is
         * immediately-available bypasses loading entirely.
         *
         * @readonly
         * @member {boolean}
         */
        _this.isLoading = false;

        /**
         * The image source that is used to create the texture.
         *
         * TODO: Make this a setter that calls loadSource();
         *
         * @readonly
         * @member {HTMLImageElement|HTMLCanvasElement}
         */
        _this.source = null; // set in loadSource, if at all

        /**
         * The image source that is used to create the texture. This is used to
         * store the original Svg source when it is replaced with a canvas element.
         *
         * TODO: Currently not in use but could be used when re-scaling svg.
         *
         * @readonly
         * @member {Image}
         */
        _this.origSource = null; // set in loadSvg, if at all

        /**
         * Type of image defined in source, eg. `png` or `svg`
         *
         * @readonly
         * @member {string}
         */
        _this.imageType = null; // set in updateImageType

        /**
         * Scale for source image. Used with Svg images to scale them before rasterization.
         *
         * @readonly
         * @member {number}
         */
        _this.sourceScale = 1.0;

        /**
         * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
         * All blend modes, and shaders written for default value. Change it on your own risk.
         *
         * @member {boolean}
         * @default true
         */
        _this.premultipliedAlpha = true;

        /**
         * The image url of the texture
         *
         * @member {string}
         */
        _this.imageUrl = null;

        /**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @private
         * @member {boolean}
         */
        _this.isPowerOfTwo = false;

        // used for webGL

        /**
         *
         * Set this to true if a mipmap of this texture needs to be generated. This value needs
         * to be set before the texture is used
         * Also the texture must be a power of two size to work
         *
         * @member {boolean}
         * @see PIXI.MIPMAP_TEXTURES
         */
        _this.mipmap = _settings2.default.MIPMAP_TEXTURES;

        /**
         *
         * WebGL Texture wrap mode
         *
         * @member {number}
         * @see PIXI.WRAP_MODES
         */
        _this.wrapMode = _settings2.default.WRAP_MODE;

        /**
         * A map of renderer IDs to webgl textures
         *
         * @private
         * @member {object<number, WebGLTexture>}
         */
        _this._glTextures = {};

        _this._enabled = 0;
        _this._virtalBoundId = -1;

        // if no source passed don't try to load
        if (source) {
            _this.loadSource(source);
        }

        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @private
         * @readonly
         */
        _this._destroyed = false;

        /**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event loaded
         * @memberof PIXI.BaseTexture#
         */

        /**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event error
         * @memberof PIXI.BaseTexture#
         */
        return _this;
    }

    /**
     * Updates the texture on all the webgl renderers, this also assumes the src has changed.
     *
     * @fires update
     */


    BaseTexture.prototype.update = function update() {
        // Svg size is handled during load
        if (this.imageType !== 'svg') {
            this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width;
            this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height;

            this._updateDimensions();
        }

        this.emit('update', this);
    };

    /**
     * Update dimensions from real values
     */


    BaseTexture.prototype._updateDimensions = function _updateDimensions() {
        this.width = this.realWidth / this.resolution;
        this.height = this.realHeight / this.resolution;

        this.isPowerOfTwo = _bitTwiddle2.default.isPow2(this.realWidth) && _bitTwiddle2.default.isPow2(this.realHeight);
    };

    /**
     * Load a source.
     *
     * If the source is not-immediately-available, such as an image that needs to be
     * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
     * and `hasLoaded` will remain false after this call.
     *
     * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
     *
     *     if (texture.hasLoaded) {
     *        // texture ready for use
     *     } else if (texture.isLoading) {
     *        // listen to 'loaded' and/or 'error' events on texture
     *     } else {
     *        // not loading, not going to load UNLESS the source is reloaded
     *        // (it may still make sense to listen to the events)
     *     }
     *
     * @protected
     * @param {HTMLImageElement|HTMLCanvasElement} source - the source object of the texture.
     */


    BaseTexture.prototype.loadSource = function loadSource(source) {
        var wasLoading = this.isLoading;

        this.hasLoaded = false;
        this.isLoading = false;

        if (wasLoading && this.source) {
            this.source.onload = null;
            this.source.onerror = null;
        }

        var firstSourceLoaded = !this.source;

        this.source = source;

        // Apply source if loaded. Otherwise setup appropriate loading monitors.
        if ((source.src && source.complete || source.getContext) && source.width && source.height) {
            this._updateImageType();

            if (this.imageType === 'svg') {
                this._loadSvgSource();
            } else {
                this._sourceLoaded();
            }

            if (firstSourceLoaded) {
                // send loaded event if previous source was null and we have been passed a pre-loaded IMG element
                this.emit('loaded', this);
            }
        } else if (!source.getContext) {
            // Image fail / not ready
            this.isLoading = true;

            var scope = this;

            source.onload = function () {
                scope._updateImageType();
                source.onload = null;
                source.onerror = null;

                if (!scope.isLoading) {
                    return;
                }

                scope.isLoading = false;
                scope._sourceLoaded();

                if (scope.imageType === 'svg') {
                    scope._loadSvgSource();

                    return;
                }

                scope.emit('loaded', scope);
            };

            source.onerror = function () {
                source.onload = null;
                source.onerror = null;

                if (!scope.isLoading) {
                    return;
                }

                scope.isLoading = false;
                scope.emit('error', scope);
            };

            // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
            //   "The value of `complete` can thus change while a script is executing."
            // So complete needs to be re-checked after the callbacks have been added..
            // NOTE: complete will be true if the image has no src so best to check if the src is set.
            if (source.complete && source.src) {
                // ..and if we're complete now, no need for callbacks
                source.onload = null;
                source.onerror = null;

                if (scope.imageType === 'svg') {
                    scope._loadSvgSource();

                    return;
                }

                this.isLoading = false;

                if (source.width && source.height) {
                    this._sourceLoaded();

                    // If any previous subscribers possible
                    if (wasLoading) {
                        this.emit('loaded', this);
                    }
                }
                // If any previous subscribers possible
                else if (wasLoading) {
                        this.emit('error', this);
                    }
            }
        }
    };

    /**
     * Updates type of the source image.
     */


    BaseTexture.prototype._updateImageType = function _updateImageType() {
        if (!this.imageUrl) {
            return;
        }

        var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
        var imageType = void 0;

        if (dataUri && dataUri.mediaType === 'image') {
            // Check for subType validity
            var firstSubType = dataUri.subType.split('+')[0];

            imageType = (0, _utils.getUrlFileExtension)('.' + firstSubType);

            if (!imageType) {
                throw new Error('Invalid image type in data URI.');
            }
        } else {
            imageType = (0, _utils.getUrlFileExtension)(this.imageUrl);

            if (!imageType) {
                imageType = 'png';
            }
        }

        this.imageType = imageType;
    };

    /**
     * Checks if `source` is an SVG image and whether it's loaded via a URL or a data URI. Then calls
     * `_loadSvgSourceUsingDataUri` or `_loadSvgSourceUsingXhr`.
     */


    BaseTexture.prototype._loadSvgSource = function _loadSvgSource() {
        if (this.imageType !== 'svg') {
            // Do nothing if source is not svg
            return;
        }

        var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);

        if (dataUri) {
            this._loadSvgSourceUsingDataUri(dataUri);
        } else {
            // We got an URL, so we need to do an XHR to check the svg size
            this._loadSvgSourceUsingXhr();
        }
    };

    /**
     * Reads an SVG string from data URI and then calls `_loadSvgSourceUsingString`.
     *
     * @param {string} dataUri - The data uri to load from.
     */


    BaseTexture.prototype._loadSvgSourceUsingDataUri = function _loadSvgSourceUsingDataUri(dataUri) {
        var svgString = void 0;

        if (dataUri.encoding === 'base64') {
            if (!atob) {
                throw new Error('Your browser doesn\'t support base64 conversions.');
            }
            svgString = atob(dataUri.data);
        } else {
            svgString = dataUri.data;
        }

        this._loadSvgSourceUsingString(svgString);
    };

    /**
     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadSvgSourceUsingString`.
     */


    BaseTexture.prototype._loadSvgSourceUsingXhr = function _loadSvgSourceUsingXhr() {
        var _this2 = this;

        var svgXhr = new XMLHttpRequest();

        // This throws error on IE, so SVG Document can't be used
        // svgXhr.responseType = 'document';

        // This is not needed since we load the svg as string (breaks IE too)
        // but overrideMimeType() can be used to force the response to be parsed as XML
        // svgXhr.overrideMimeType('image/svg+xml');

        svgXhr.onload = function () {
            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
                throw new Error('Failed to load SVG using XHR.');
            }

            _this2._loadSvgSourceUsingString(svgXhr.response);
        };

        svgXhr.onerror = function () {
            return _this2.emit('error', _this2);
        };

        svgXhr.open('GET', this.imageUrl, true);
        svgXhr.send();
    };

    /**
     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
     * `_loadSvgSourceUsingXhr` or `_loadSvgSourceUsingDataUri`.
     *
     * @param  {string} svgString SVG source as string
     *
     * @fires loaded
     */


    BaseTexture.prototype._loadSvgSourceUsingString = function _loadSvgSourceUsingString(svgString) {
        var svgSize = (0, _utils.getSvgSize)(svgString);

        var svgWidth = svgSize.width;
        var svgHeight = svgSize.height;

        if (!svgWidth || !svgHeight) {
            throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
        }

        // Scale realWidth and realHeight
        this.realWidth = Math.round(svgWidth * this.sourceScale);
        this.realHeight = Math.round(svgHeight * this.sourceScale);

        this._updateDimensions();

        // Create a canvas element
        var canvas = document.createElement('canvas');

        canvas.width = this.realWidth;
        canvas.height = this.realHeight;
        canvas._pixiId = 'canvas_' + (0, _utils.uid)();

        // Draw the Svg to the canvas
        canvas.getContext('2d').drawImage(this.source, 0, 0, svgWidth, svgHeight, 0, 0, this.realWidth, this.realHeight);

        // Replace the original source image with the canvas
        this.origSource = this.source;
        this.source = canvas;

        // Add also the canvas in cache (destroy clears by `imageUrl` and `source._pixiId`)
        _utils.BaseTextureCache[canvas._pixiId] = this;

        this.isLoading = false;
        this._sourceLoaded();
        this.emit('loaded', this);
    };

    /**
     * Used internally to update the width, height, and some other tracking vars once
     * a source has successfully loaded.
     *
     * @private
     */


    BaseTexture.prototype._sourceLoaded = function _sourceLoaded() {
        this.hasLoaded = true;
        this.update();
    };

    /**
     * Destroys this base texture
     *
     */


    BaseTexture.prototype.destroy = function destroy() {
        if (this.imageUrl) {
            delete _utils.BaseTextureCache[this.imageUrl];
            delete _utils.TextureCache[this.imageUrl];

            this.imageUrl = null;

            if (!navigator.isCocoonJS) {
                this.source.src = '';
            }
        }
        // An svg source has both `imageUrl` and `__pixiId`, so no `else if` here
        if (this.source && this.source._pixiId) {
            delete _utils.BaseTextureCache[this.source._pixiId];
        }

        this.source = null;

        this.dispose();

        this._destroyed = true;
    };

    /**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     */


    BaseTexture.prototype.dispose = function dispose() {
        this.emit('dispose', this);
    };

    /**
     * Changes the source image of the texture.
     * The original source must be an Image element.
     *
     * @param {string} newSrc - the path of the image
     */


    BaseTexture.prototype.updateSourceImage = function updateSourceImage(newSrc) {
        this.source.src = newSrc;

        this.loadSource(this.source);
    };

    /**
     * Helper function that creates a base texture from the given image url.
     * If the image is not in the base texture cache it will be created and loaded.
     *
     * @static
     * @param {string} imageUrl - The image url of the texture
     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
     * @return {PIXI.BaseTexture} The new base texture.
     */


    BaseTexture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
        var baseTexture = _utils.BaseTextureCache[imageUrl];

        if (!baseTexture) {
            // new Image() breaks tex loading in some versions of Chrome.
            // See https://code.google.com/p/chromium/issues/detail?id=238071
            var image = new Image(); // document.createElement('img');

            if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) {
                image.crossOrigin = (0, _determineCrossOrigin2.default)(imageUrl);
            }

            baseTexture = new BaseTexture(image, scaleMode);
            baseTexture.imageUrl = imageUrl;

            if (sourceScale) {
                baseTexture.sourceScale = sourceScale;
            }

            // if there is an @2x at the end of the url we are going to assume its a highres image
            baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);

            image.src = imageUrl; // Setting this triggers load

            _utils.BaseTextureCache[imageUrl] = baseTexture;
        }

        return baseTexture;
    };

    /**
     * Helper function that creates a base texture from the given canvas element.
     *
     * @static
     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.BaseTexture} The new base texture.
     */


    BaseTexture.fromCanvas = function fromCanvas(canvas, scaleMode) {
        if (!canvas._pixiId) {
            canvas._pixiId = 'canvas_' + (0, _utils.uid)();
        }

        var baseTexture = _utils.BaseTextureCache[canvas._pixiId];

        if (!baseTexture) {
            baseTexture = new BaseTexture(canvas, scaleMode);
            _utils.BaseTextureCache[canvas._pixiId] = baseTexture;
        }

        return baseTexture;
    };

    /**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement} source - The source to create base texture from.
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
     * @return {PIXI.BaseTexture} The new base texture.
     */


    BaseTexture.from = function from(source, scaleMode, sourceScale) {
        if (typeof source === 'string') {
            return BaseTexture.fromImage(source, undefined, scaleMode, sourceScale);
        } else if (source instanceof HTMLImageElement) {
            var imageUrl = source.src;
            var baseTexture = _utils.BaseTextureCache[imageUrl];

            if (!baseTexture) {
                baseTexture = new BaseTexture(source, scaleMode);
                baseTexture.imageUrl = imageUrl;

                if (sourceScale) {
                    baseTexture.sourceScale = sourceScale;
                }

                // if there is an @2x at the end of the url we are going to assume its a highres image
                baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);

                _utils.BaseTextureCache[imageUrl] = baseTexture;
            }

            return baseTexture;
        } else if (source instanceof HTMLCanvasElement) {
            return BaseTexture.fromCanvas(source, scaleMode);
        }

        // lets assume its a base texture!
        return source;
    };

    return BaseTexture;
}(_eventemitter2.default);

exports.default = BaseTexture;
//# sourceMappingURL=BaseTexture.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseTexture = __webpack_require__(14);

var _BaseTexture2 = _interopRequireDefault(_BaseTexture);

var _VideoBaseTexture = __webpack_require__(75);

var _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);

var _TextureUvs = __webpack_require__(74);

var _TextureUvs2 = _interopRequireDefault(_TextureUvs);

var _eventemitter = __webpack_require__(9);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _math = __webpack_require__(2);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided
 * then the whole image is used.
 *
 * You can directly create a texture from an image and then reuse it multiple times like this :
 *
 * ```js
 * let texture = PIXI.Texture.fromImage('assets/image.png');
 * let sprite1 = new PIXI.Sprite(texture);
 * let sprite2 = new PIXI.Sprite(texture);
 * ```
 *
 * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.
 * You can check for this by checking the sprite's _textureID property.
 * ```js
 * var texture = PIXI.Texture.fromImage('assets/image.svg');
 * var sprite1 = new PIXI.Sprite(texture);
 * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file
 * ```
 * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */
var Texture = function (_EventEmitter) {
    _inherits(Texture, _EventEmitter);

    /**
     * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     * @param {PIXI.Rectangle} [orig] - The area of original texture
     * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture
     * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}
     */
    function Texture(baseTexture, frame, orig, trim, rotate) {
        _classCallCheck(this, Texture);

        /**
         * Does this Texture have any frame data assigned to it?
         *
         * @member {boolean}
         */
        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.noFrame = false;

        if (!frame) {
            _this.noFrame = true;
            frame = new _math.Rectangle(0, 0, 1, 1);
        }

        if (baseTexture instanceof Texture) {
            baseTexture = baseTexture.baseTexture;
        }

        /**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */
        _this.baseTexture = baseTexture;

        /**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */
        _this._frame = frame;

        /**
         * This is the trimmed area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        _this.trim = trim;

        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        _this.valid = false;

        /**
         * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
         *
         * @member {boolean}
         */
        _this.requiresUpdate = false;

        /**
         * The WebGL UV data cache.
         *
         * @member {PIXI.TextureUvs}
         * @private
         */
        _this._uvs = null;

        /**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        _this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);

        _this._rotate = Number(rotate || 0);

        if (rotate === true) {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            _this._rotate = 2;
        } else if (_this._rotate % 2 !== 0) {
            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
        }

        if (baseTexture.hasLoaded) {
            if (_this.noFrame) {
                frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);

                // if there is no frame we should monitor for any base texture changes..
                baseTexture.on('update', _this.onBaseTextureUpdated, _this);
            }
            _this.frame = frame;
        } else {
            baseTexture.once('loaded', _this.onBaseTextureLoaded, _this);
        }

        /**
         * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
         *
         * @event update
         * @memberof PIXI.Texture#
         * @protected
         */

        _this._updateID = 0;

        /**
         * Extra field for extra plugins. May contain clamp settings and some matrices
         * @type {Object}
         */
        _this.transform = null;
        return _this;
    }

    /**
     * Updates this texture on the gpu.
     *
     */


    Texture.prototype.update = function update() {
        this.baseTexture.update();
    };

    /**
     * Called when the base texture is loaded
     *
     * @private
     * @param {PIXI.BaseTexture} baseTexture - The base texture.
     */


    Texture.prototype.onBaseTextureLoaded = function onBaseTextureLoaded(baseTexture) {
        this._updateID++;

        // TODO this code looks confusing.. boo to abusing getters and setters!
        if (this.noFrame) {
            this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        } else {
            this.frame = this._frame;
        }

        this.baseTexture.on('update', this.onBaseTextureUpdated, this);
        this.emit('update', this);
    };

    /**
     * Called when the base texture is updated
     *
     * @private
     * @param {PIXI.BaseTexture} baseTexture - The base texture.
     */


    Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated(baseTexture) {
        this._updateID++;

        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;

        this.emit('update', this);
    };

    /**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */


    Texture.prototype.destroy = function destroy(destroyBase) {
        if (this.baseTexture) {
            if (destroyBase) {
                // delete the texture if it exists in the texture cache..
                // this only needs to be removed if the base texture is actually destroyed too..
                if (_utils.TextureCache[this.baseTexture.imageUrl]) {
                    delete _utils.TextureCache[this.baseTexture.imageUrl];
                }

                this.baseTexture.destroy();
            }

            this.baseTexture.off('update', this.onBaseTextureUpdated, this);
            this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);

            this.baseTexture = null;
        }

        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;

        this.valid = false;

        this.off('dispose', this.dispose, this);
        this.off('update', this.update, this);
    };

    /**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */


    Texture.prototype.clone = function clone() {
        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate);
    };

    /**
     * Updates the internal WebGL UV cache.
     *
     * @protected
     */


    Texture.prototype._updateUvs = function _updateUvs() {
        if (!this._uvs) {
            this._uvs = new _TextureUvs2.default();
        }

        this._uvs.set(this._frame, this.baseTexture, this.rotate);

        this._updateID++;
    };

    /**
     * Helper function that creates a Texture object from the given image url.
     * If the image is not in the texture cache it will be  created and loaded.
     *
     * @static
     * @param {string} imageUrl - The image url of the texture
     * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
        var texture = _utils.TextureCache[imageUrl];

        if (!texture) {
            texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));
            _utils.TextureCache[imageUrl] = texture;
        }

        return texture;
    };

    /**
     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
     * The frame ids are created when a Texture packer file has been loaded
     *
     * @static
     * @param {string} frameId - The frame Id of the texture in the cache
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromFrame = function fromFrame(frameId) {
        var texture = _utils.TextureCache[frameId];

        if (!texture) {
            throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
        }

        return texture;
    };

    /**
     * Helper function that creates a new Texture based on the given canvas element.
     *
     * @static
     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromCanvas = function fromCanvas(canvas, scaleMode) {
        return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode));
    };

    /**
     * Helper function that creates a new Texture based on the given video element.
     *
     * @static
     * @param {HTMLVideoElement|string} video - The URL or actual element of the video
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromVideo = function fromVideo(video, scaleMode) {
        if (typeof video === 'string') {
            return Texture.fromVideoUrl(video, scaleMode);
        }

        return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode));
    };

    /**
     * Helper function that creates a new Texture based on the video url.
     *
     * @static
     * @param {string} videoUrl - URL of the video
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.fromVideoUrl = function fromVideoUrl(videoUrl, scaleMode) {
        return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode));
    };

    /**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}
     *        source - Source to create texture from
     * @return {PIXI.Texture} The newly created texture
     */


    Texture.from = function from(source) {
        // TODO auto detect cross origin..
        // TODO pass in scale mode?
        if (typeof source === 'string') {
            var texture = _utils.TextureCache[source];

            if (!texture) {
                // check if its a video..
                var isVideo = source.match(/\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;

                if (isVideo) {
                    return Texture.fromVideoUrl(source);
                }

                return Texture.fromImage(source);
            }

            return texture;
        } else if (source instanceof HTMLImageElement) {
            return new Texture(_BaseTexture2.default.from(source));
        } else if (source instanceof HTMLCanvasElement) {
            return Texture.fromCanvas(source);
        } else if (source instanceof HTMLVideoElement) {
            return Texture.fromVideo(source);
        } else if (source instanceof _BaseTexture2.default) {
            return new Texture(source);
        }

        // lets assume its a texture!
        return source;
    };

    /**
     * Create a texture from a source and add to the cache.
     *
     * @static
     * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
     * @param {String} [name] - Human readible name for the texture cache. If no name is
     *        specified, only `imageUrl` will be used as the cache ID.
     * @return {PIXI.Texture} Output texture
     */


    Texture.fromLoader = function fromLoader(source, imageUrl, name) {
        var baseTexture = new _BaseTexture2.default(source, undefined, (0, _utils.getResolutionOfUrl)(imageUrl));
        var texture = new Texture(baseTexture);

        baseTexture.imageUrl = imageUrl;

        // No name, use imageUrl instead
        if (!name) {
            name = imageUrl;
        }

        // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
        _utils.BaseTextureCache[name] = baseTexture;
        _utils.TextureCache[name] = texture;

        // also add references by url if they are different.
        if (name !== imageUrl) {
            _utils.BaseTextureCache[imageUrl] = baseTexture;
            _utils.TextureCache[imageUrl] = texture;
        }

        return texture;
    };

    /**
     * Adds a texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the texture will be stored against.
     */


    Texture.addTextureToCache = function addTextureToCache(texture, id) {
        _utils.TextureCache[id] = texture;
    };

    /**
     * Remove a texture from the global TextureCache.
     *
     * @static
     * @param {string} id - The id of the texture to be removed
     * @return {PIXI.Texture} The texture that was removed
     */


    Texture.removeTextureFromCache = function removeTextureFromCache(id) {
        var texture = _utils.TextureCache[id];

        delete _utils.TextureCache[id];
        delete _utils.BaseTextureCache[id];

        return texture;
    };

    /**
     * The frame specifies the region of the base texture that this texture uses.
     *
     * @member {PIXI.Rectangle}
     */


    _createClass(Texture, [{
        key: 'frame',
        get: function get() {
            return this._frame;
        },
        set: function set(frame) // eslint-disable-line require-jsdoc
        {
            this._frame = frame;

            this.noFrame = false;

            if (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height) {
                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: ' + ('X: ' + frame.x + ' + ' + frame.width + ' > ' + this.baseTexture.width + ' ') + ('Y: ' + frame.y + ' + ' + frame.height + ' > ' + this.baseTexture.height));
            }

            // this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;

            if (!this.trim && !this.rotate) {
                this.orig = frame;
            }

            if (this.valid) {
                this._updateUvs();
            }
        }

        /**
         * Indicates whether the texture is rotated inside the atlas
         * set to 2 to compensate for texture packer rotation
         * set to 6 to compensate for spine packer rotation
         * can be used to rotate or mirror sprites
         * See {@link PIXI.GroupD8} for explanation
         *
         * @member {number}
         */

    }, {
        key: 'rotate',
        get: function get() {
            return this._rotate;
        },
        set: function set(rotate) // eslint-disable-line require-jsdoc
        {
            this._rotate = rotate;
            if (this.valid) {
                this._updateUvs();
            }
        }

        /**
         * The width of the Texture in pixels.
         *
         * @member {number}
         */

    }, {
        key: 'width',
        get: function get() {
            return this.orig.width;
        }

        /**
         * The height of the Texture in pixels.
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return this.orig.height;
        }
    }]);

    return Texture;
}(_eventemitter2.default);

exports.default = Texture;


function createWhiteTexture() {
    var canvas = document.createElement('canvas');

    canvas.width = 10;
    canvas.height = 10;

    var context = canvas.getContext('2d');

    context.fillStyle = 'white';
    context.fillRect(0, 0, 10, 10);

    return new Texture(new _BaseTexture2.default(canvas));
}

function removeAllHandlers(tex) {
    tex.destroy = function _emptyDestroy() {/* empty */};
    tex.on = function _emptyOn() {/* empty */};
    tex.once = function _emptyOnce() {/* empty */};
    tex.emit = function _emptyEmit() {/* empty */};
}

/**
 * An empty texture, used often to not have to create multiple empty textures.
 * Can not be destroyed.
 *
 * @static
 * @constant
 */
Texture.EMPTY = new Texture(new _BaseTexture2.default());
removeAllHandlers(Texture.EMPTY);

/**
 * A white texture of 10x10 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 */
Texture.WHITE = createWhiteTexture();
removeAllHandlers(Texture.WHITE);
//# sourceMappingURL=Texture.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports) {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pixiGlCore = __webpack_require__(4);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function checkPrecision(src, def) {
    if (src instanceof Array) {
        if (src[0].substring(0, 9) !== 'precision') {
            var copy = src.slice(0);

            copy.unshift('precision ' + def + ' float;');

            return copy;
        }
    } else if (src.substring(0, 9) !== 'precision') {
        return 'precision ' + def + ' float;\n' + src;
    }

    return src;
}

/**
 * Wrapper class, webGL Shader for Pixi.
 * Adds precision string if vertexSrc or fragmentSrc have no mention of it.
 *
 * @class
 * @extends GLShader
 * @memberof PIXI
 */

var Shader = function (_GLShader) {
    _inherits(Shader, _GLShader);

    /**
     *
     * @param {WebGLRenderingContext} gl - The current WebGL rendering context
     * @param {string|string[]} vertexSrc - The vertex shader source as an array of strings.
     * @param {string|string[]} fragmentSrc - The fragment shader source as an array of strings.
     */
    function Shader(gl, vertexSrc, fragmentSrc) {
        _classCallCheck(this, Shader);

        return _possibleConstructorReturn(this, _GLShader.call(this, gl, checkPrecision(vertexSrc, _settings2.default.PRECISION_VERTEX), checkPrecision(fragmentSrc, _settings2.default.PRECISION_FRAGMENT)));
    }

    return Shader;
}(_pixiGlCore.GLShader);

exports.default = Shader;
//# sourceMappingURL=Shader.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (graphicsData, webGLData) {
    if (graphicsData.nativeLines) {
        buildNativeLine(graphicsData, webGLData);
    } else {
        buildLine(graphicsData, webGLData);
    }
};

var _math = __webpack_require__(2);

var _utils = __webpack_require__(1);

/**
 * Builds a line to draw using the poligon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildLine(graphicsData, webGLData) {
    // TODO OPTIMISE!
    var points = graphicsData.points;

    if (points.length === 0) {
        return;
    }
    // if the line width is an odd number add 0.5 to align to a whole pixel
    // commenting this out fixes #711 and #1620
    // if (graphicsData.lineWidth%2)
    // {
    //     for (i = 0; i < points.length; i++)
    //     {
    //         points[i] += 0.5;
    //     }
    // }

    // get first and last point.. figure out the middle!
    var firstPoint = new _math.Point(points[0], points[1]);
    var lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

    // if the first point is the last point - gonna have issues :)
    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length / 6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var p1x = points[0];
    var p1y = points[1];
    var p2x = points[2];
    var p2y = points[3];
    var p3x = 0;
    var p3y = 0;

    var perpx = -(p1y - p2y);
    var perpy = p1x - p2x;
    var perp2x = 0;
    var perp2y = 0;
    var perp3x = 0;
    var perp3y = 0;

    var dist = Math.sqrt(perpx * perpx + perpy * perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);

    verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);

    for (var i = 1; i < length - 1; ++i) {
        p1x = points[(i - 1) * 2];
        p1y = points[(i - 1) * 2 + 1];

        p2x = points[i * 2];
        p2y = points[i * 2 + 1];

        p3x = points[(i + 1) * 2];
        p3y = points[(i + 1) * 2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        var a1 = -perpy + p1y - (-perpy + p2y);
        var b1 = -perpx + p2x - (-perpx + p1x);
        var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        var a2 = -perp2y + p3y - (-perp2y + p2y);
        var b2 = -perp2x + p2x - (-perp2x + p3x);
        var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        var denom = a1 * b2 - a2 * b1;

        if (Math.abs(denom) < 0.1) {
            denom += 10.1;
            verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);

            verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);

            continue;
        }

        var px = (b1 * c2 - b2 * c1) / denom;
        var py = (a2 * c1 - a1 * c2) / denom;
        var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);

        if (pdist > 196 * width * width) {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y + perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        } else {
            verts.push(px, py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px - p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length - 2) * 2];
    p1y = points[(length - 2) * 2 + 1];

    p2x = points[(length - 1) * 2];
    p2y = points[(length - 1) * 2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx, p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx, p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (var _i = 0; _i < indexCount; ++_i) {
        indices.push(indexStart++);
    }

    indices.push(indexStart - 1);
}

/**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */


/**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildNativeLine(graphicsData, webGLData) {
    var i = 0;
    var points = graphicsData.points;

    if (points.length === 0) return;

    var verts = webGLData.points;
    var length = points.length / 2;

    // sort color
    var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    for (i = 1; i < length; i++) {
        var p1x = points[(i - 1) * 2];
        var p1y = points[(i - 1) * 2 + 1];

        var p2x = points[i * 2];
        var p2y = points[i * 2 + 1];

        verts.push(p1x, p1y);
        verts.push(r, g, b, alpha);

        verts.push(p2x, p2y);
        verts.push(r, g, b, alpha);
    }
}
//# sourceMappingURL=buildLine.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _SystemRenderer2 = __webpack_require__(65);

var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

var _MaskManager = __webpack_require__(141);

var _MaskManager2 = _interopRequireDefault(_MaskManager);

var _StencilManager = __webpack_require__(142);

var _StencilManager2 = _interopRequireDefault(_StencilManager);

var _FilterManager = __webpack_require__(140);

var _FilterManager2 = _interopRequireDefault(_FilterManager);

var _RenderTarget = __webpack_require__(21);

var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

var _ObjectRenderer = __webpack_require__(20);

var _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);

var _TextureManager = __webpack_require__(136);

var _TextureManager2 = _interopRequireDefault(_TextureManager);

var _BaseTexture = __webpack_require__(14);

var _BaseTexture2 = _interopRequireDefault(_BaseTexture);

var _TextureGarbageCollector = __webpack_require__(135);

var _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);

var _WebGLState = __webpack_require__(137);

var _WebGLState2 = _interopRequireDefault(_WebGLState);

var _mapWebGLDrawModesToPixi = __webpack_require__(145);

var _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);

var _validateContext = __webpack_require__(146);

var _validateContext2 = _interopRequireDefault(_validateContext);

var _utils = __webpack_require__(1);

var _pixiGlCore = __webpack_require__(4);

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _const = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CONTEXT_UID = 0;

/**
 * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
 * So no need for Sprite Batches or Sprite Clouds.
 * Don't forget to add the view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 */

var WebGLRenderer = function (_SystemRenderer) {
    _inherits(WebGLRenderer, _SystemRenderer);

    /**
     *
     * @param {number} [screenWidth=800] - the width of the screen
     * @param {number} [screenHeight=600] - the height of the screen
     * @param {object} [options] - The optional renderer parameters
     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
     * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA
     *  antialiasing is used
     * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
     *  FXAA is faster, but may not always look as great
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.
     *  The resolution of the renderer retina would be 2.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear
     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set
     *  preserveDrawingBuffer to `true`.
     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
     *  enable this if you need to call toDataUrl on the webgl context.
     * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when
     *  rendering, stopping pixel interpolation.
     * @param {boolean} [options.legacy=false] - If true Pixi will aim to ensure compatibility
     * with older / less advanced devices. If you experiance unexplained flickering try setting this to true.
     */
    function WebGLRenderer(screenWidth, screenHeight) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, WebGLRenderer);

        var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'WebGL', screenWidth, screenHeight, options));

        _this.legacy = !!options.legacy;

        if (_this.legacy) {
            _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true;
        }

        /**
         * The type of this renderer as a standardised const
         *
         * @member {number}
         * @see PIXI.RENDERER_TYPE
         */
        _this.type = _const.RENDERER_TYPE.WEBGL;

        _this.handleContextLost = _this.handleContextLost.bind(_this);
        _this.handleContextRestored = _this.handleContextRestored.bind(_this);

        _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);
        _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);

        /**
         * The options passed in to create a new webgl context.
         *
         * @member {object}
         * @private
         */
        _this._contextOptions = {
            alpha: _this.transparent,
            antialias: options.antialias,
            premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied',
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer
        };

        _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;

        /**
         * Manages the masks using the stencil buffer.
         *
         * @member {PIXI.MaskManager}
         */
        _this.maskManager = new _MaskManager2.default(_this);

        /**
         * Manages the stencil buffer.
         *
         * @member {PIXI.StencilManager}
         */
        _this.stencilManager = new _StencilManager2.default(_this);

        /**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        _this.emptyRenderer = new _ObjectRenderer2.default(_this);

        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        _this.currentRenderer = _this.emptyRenderer;

        _this.initPlugins();

        /**
         * The current WebGL rendering context, it is created here
         *
         * @member {WebGLRenderingContext}
         */
        // initialize the context so it is ready for the managers.
        if (options.context) {
            // checks to see if a context is valid..
            (0, _validateContext2.default)(options.context);
        }

        _this.gl = options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);

        _this.CONTEXT_UID = CONTEXT_UID++;

        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.WebGLState}
         */
        _this.state = new _WebGLState2.default(_this.gl);

        _this.renderingToScreen = true;

        /**
         * Holds the current state of textures bound to the GPU.
         * @type {Array}
         */
        _this.boundTextures = null;

        /**
         * Holds the current shader
         *
         * @member {PIXI.Shader}
         */
        _this._activeShader = null;

        _this._activeVao = null;

        /**
         * Holds the current render target
         *
         * @member {PIXI.RenderTarget}
         */
        _this._activeRenderTarget = null;

        _this._initContext();

        /**
         * Manages the filters.
         *
         * @member {PIXI.FilterManager}
         */
        _this.filterManager = new _FilterManager2.default(_this);
        // map some webGL blend and drawmodes..
        _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);

        _this._nextTextureLocation = 0;

        _this.setBlendMode(0);
        return _this;
    }

    /**
     * Creates the WebGL context
     *
     * @private
     */


    WebGLRenderer.prototype._initContext = function _initContext() {
        var gl = this.gl;

        // restore a context if it was previously lost
        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').restoreContext();
        }

        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

        this.boundTextures = new Array(maxTextures);
        this.emptyTextures = new Array(maxTextures);

        // create a texture manager...
        this.textureManager = new _TextureManager2.default(this);
        this.textureGC = new _TextureGarbageCollector2.default(this);

        this.state.resetToDefault();

        this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);
        this.rootRenderTarget.clearColor = this._backgroundColorRgba;

        this.bindRenderTarget(this.rootRenderTarget);

        // now lets fill up the textures with empty ones!
        var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);

        var tempObj = { _glTextures: {} };

        tempObj._glTextures[this.CONTEXT_UID] = {};

        for (var i = 0; i < maxTextures; i++) {
            var empty = new _BaseTexture2.default();

            empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;

            this.boundTextures[i] = tempObj;
            this.emptyTextures[i] = empty;
            this.bindTexture(null, i);
        }

        this.emit('context', gl);

        // setup the width/height properties and gl viewport
        this.resize(this.screen.width, this.screen.height);
    };

    /**
     * Renders the object to its webGL view
     *
     * @param {PIXI.DisplayObject} displayObject - the object to be rendered
     * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.
     * @param {boolean} [clear] - Should the canvas be cleared before the new render
     * @param {PIXI.Transform} [transform] - A transform to apply to the render texture before rendering.
     * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?
     */


    WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
        // can be handy to know!
        this.renderingToScreen = !renderTexture;

        this.emit('prerender');

        // no point rendering if our context has been blown up!
        if (!this.gl || this.gl.isContextLost()) {
            return;
        }

        this._nextTextureLocation = 0;

        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }

        if (!skipUpdateTransform) {
            // update the scene graph
            var cacheParent = displayObject.parent;

            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
            // displayObject.hitArea = //TODO add a temp hit area
        }

        this.bindRenderTexture(renderTexture, transform);

        this.currentRenderer.start();

        if (clear !== undefined ? clear : this.clearBeforeRender) {
            this._activeRenderTarget.clear();
        }

        displayObject.renderWebGL(this);

        // apply transform..
        this.currentRenderer.flush();

        // this.setObjectRenderer(this.emptyRenderer);

        this.textureGC.update();

        this.emit('postrender');
    };

    /**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */


    WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
            return;
        }

        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
    };

    /**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     *
     */


    WebGLRenderer.prototype.flush = function flush() {
        this.setObjectRenderer(this.emptyRenderer);
    };

    /**
     * Resizes the webGL view to the specified width and height.
     *
     * @param {number} screenWidth - the new width of the screen
     * @param {number} screenHeight - the new height of the screen
     */


    WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
        //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;

        _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);

        this.rootRenderTarget.resize(screenWidth, screenHeight);

        if (this._activeRenderTarget === this.rootRenderTarget) {
            this.rootRenderTarget.activate();

            if (this._activeShader) {
                this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);
            }
        }
    };

    /**
     * Resizes the webGL view to the specified width and height.
     *
     * @param {number} blendMode - the desired blend mode
     */


    WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
        this.state.setBlendMode(blendMode);
    };

    /**
     * Erases the active render target and fills the drawing area with a colour
     *
     * @param {number} [clearColor] - The colour
     */


    WebGLRenderer.prototype.clear = function clear(clearColor) {
        this._activeRenderTarget.clear(clearColor);
    };

    /**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */


    WebGLRenderer.prototype.setTransform = function setTransform(matrix) {
        this._activeRenderTarget.transform = matrix;
    };

    /**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {PIXI.RenderTexture} renderTexture - The render texture to clear
     * @param {number} [clearColor] - The colour
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {
        var baseTexture = renderTexture.baseTexture;
        var renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];

        if (renderTarget) {
            renderTarget.clear(clearColor);
        }

        return this;
    };

    /**
     * Binds a render texture for rendering
     *
     * @param {PIXI.RenderTexture} renderTexture - The render texture to render
     * @param {PIXI.Transform} transform - The transform to be applied to the render texture
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {
        var renderTarget = void 0;

        if (renderTexture) {
            var baseTexture = renderTexture.baseTexture;

            if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {
                // bind the current texture
                this.textureManager.updateTexture(baseTexture, 0);
            }

            this.unbindTexture(baseTexture);

            renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
            renderTarget.setFrame(renderTexture.frame);
        } else {
            renderTarget = this.rootRenderTarget;
        }

        renderTarget.transform = transform;
        this.bindRenderTarget(renderTarget);

        return this;
    };

    /**
     * Changes the current render target to the one given in parameter
     *
     * @param {PIXI.RenderTarget} renderTarget - the new render target
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {
        if (renderTarget !== this._activeRenderTarget) {
            this._activeRenderTarget = renderTarget;
            renderTarget.activate();

            if (this._activeShader) {
                this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);
            }

            this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);
        }

        return this;
    };

    /**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {
        // TODO cache
        if (this._activeShader !== shader) {
            this._activeShader = shader;
            shader.bind();

            // `autoProject` normally would be a default parameter set to true
            // but because of how Babel transpiles default parameters
            // it hinders the performance of this method.
            if (autoProject !== false) {
                // automatically set the projection matrix
                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);
            }
        }

        return this;
    };

    /**
     * Binds the texture. This will return the location of the bound texture.
     * It may not be the same as the one you pass in. This is due to optimisation that prevents
     * needless binding of textures. For example if the texture is already bound it will return the
     * current location of the texture instead of the one provided. To bypass this use force location
     *
     * @param {PIXI.Texture} texture - the new texture
     * @param {number} location - the suggested texture location
     * @param {boolean} forceLocation - force the location
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {
        texture = texture || this.emptyTextures[location];
        texture = texture.baseTexture || texture;
        texture.touched = this.textureGC.count;

        if (!forceLocation) {
            // TODO - maybe look into adding boundIds.. save us the loop?
            for (var i = 0; i < this.boundTextures.length; i++) {
                if (this.boundTextures[i] === texture) {
                    return i;
                }
            }

            if (location === undefined) {
                this._nextTextureLocation++;
                this._nextTextureLocation %= this.boundTextures.length;
                location = this.boundTextures.length - this._nextTextureLocation - 1;
            }
        } else {
            location = location || 0;
        }

        var gl = this.gl;
        var glTexture = texture._glTextures[this.CONTEXT_UID];

        if (!glTexture) {
            // this will also bind the texture..
            this.textureManager.updateTexture(texture, location);
        } else {
            // bind the current texture
            this.boundTextures[location] = texture;
            gl.activeTexture(gl.TEXTURE0 + location);
            gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        }

        return location;
    };

    /**
    * unbinds the texture ...
    *
    * @param {PIXI.Texture} texture - the texture to unbind
    * @return {PIXI.WebGLRenderer} Returns itself.
    */


    WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {
        var gl = this.gl;

        texture = texture.baseTexture || texture;

        for (var i = 0; i < this.boundTextures.length; i++) {
            if (this.boundTextures[i] === texture) {
                this.boundTextures[i] = this.emptyTextures[i];

                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);
            }
        }

        return this;
    };

    /**
     * Creates a new VAO from this renderer's context and state.
     *
     * @return {VertexArrayObject} The new VAO.
     */


    WebGLRenderer.prototype.createVao = function createVao() {
        return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);
    };

    /**
     * Changes the current Vao to the one given in parameter
     *
     * @param {PIXI.VertexArrayObject} vao - the new Vao
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.bindVao = function bindVao(vao) {
        if (this._activeVao === vao) {
            return this;
        }

        if (vao) {
            vao.bind();
        } else if (this._activeVao) {
            // TODO this should always be true i think?
            this._activeVao.unbind();
        }

        this._activeVao = vao;

        return this;
    };

    /**
     * Resets the WebGL state so you can render things however you fancy!
     *
     * @return {PIXI.WebGLRenderer} Returns itself.
     */


    WebGLRenderer.prototype.reset = function reset() {
        this.setObjectRenderer(this.emptyRenderer);

        this._activeShader = null;
        this._activeRenderTarget = this.rootRenderTarget;

        // bind the main frame buffer (the screen);
        this.rootRenderTarget.activate();

        this.state.resetToDefault();

        return this;
    };

    /**
     * Handles a lost webgl context
     *
     * @private
     * @param {WebGLContextEvent} event - The context lost event.
     */


    WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) {
        event.preventDefault();
    };

    /**
     * Handles a restored webgl context
     *
     * @private
     */


    WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() {
        this._initContext();
        this.textureManager.removeAll();
    };

    /**
     * Removes everything from the renderer (event listeners, spritebatch, etc...)
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     *  See: https://github.com/pixijs/pixi.js/issues/2233
     */


    WebGLRenderer.prototype.destroy = function destroy(removeView) {
        this.destroyPlugins();

        // remove listeners
        this.view.removeEventListener('webglcontextlost', this.handleContextLost);
        this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);

        this.textureManager.destroy();

        // call base destroy
        _SystemRenderer.prototype.destroy.call(this, removeView);

        this.uid = 0;

        // destroy the managers
        this.maskManager.destroy();
        this.stencilManager.destroy();
        this.filterManager.destroy();

        this.maskManager = null;
        this.filterManager = null;
        this.textureManager = null;
        this.currentRenderer = null;

        this.handleContextLost = null;
        this.handleContextRestored = null;

        this._contextOptions = null;
        this.gl.useProgram(null);

        if (this.gl.getExtension('WEBGL_lose_context')) {
            this.gl.getExtension('WEBGL_lose_context').loseContext();
        }

        this.gl = null;

        // this = null;
    };

    return WebGLRenderer;
}(_SystemRenderer3.default);

exports.default = WebGLRenderer;


_utils.pluginTarget.mixin(WebGLRenderer);
//# sourceMappingURL=WebGLRenderer.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _WebGLManager2 = __webpack_require__(13);

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Base for a common object renderer that can be used as a system renderer plugin.
 *
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 */
var ObjectRenderer = function (_WebGLManager) {
  _inherits(ObjectRenderer, _WebGLManager);

  function ObjectRenderer() {
    _classCallCheck(this, ObjectRenderer);

    return _possibleConstructorReturn(this, _WebGLManager.apply(this, arguments));
  }

  /**
   * Starts the renderer and sets the shader
   *
   */
  ObjectRenderer.prototype.start = function start() {}
  // set the shader..


  /**
   * Stops the renderer
   *
   */
  ;

  ObjectRenderer.prototype.stop = function stop() {
    this.flush();
  };

  /**
   * Stub method for rendering content and emptying the current batch.
   *
   */


  ObjectRenderer.prototype.flush = function flush() {}
  // flush!


  /**
   * Renders an object
   *
   * @param {PIXI.DisplayObject} object - The object to render.
   */
  ;

  ObjectRenderer.prototype.render = function render(object) // eslint-disable-line no-unused-vars
  {
    // render the object
  };

  return ObjectRenderer;
}(_WebGLManager3.default);

exports.default = ObjectRenderer;
//# sourceMappingURL=ObjectRenderer.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _math = __webpack_require__(2);

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _pixiGlCore = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var RenderTarget = function () {
  /**
   * @param {WebGLRenderingContext} gl - The current WebGL drawing context
   * @param {number} [width=0] - the horizontal range of the filter
   * @param {number} [height=0] - the vertical range of the filter
   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
   * @param {number} [resolution=1] - The current resolution / device pixel ratio
   * @param {boolean} [root=false] - Whether this object is the root element or not
   */
  function RenderTarget(gl, width, height, scaleMode, resolution, root) {
    _classCallCheck(this, RenderTarget);

    // TODO Resolution could go here ( eg low res blurs )

    /**
     * The current WebGL drawing context.
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // next time to create a frame buffer and texture

    /**
     * A frame buffer
     *
     * @member {PIXI.glCore.GLFramebuffer}
     */
    this.frameBuffer = null;

    /**
     * The texture
     *
     * @member {PIXI.glCore.GLTexture}
     */
    this.texture = null;

    /**
     * The background colour of this render target, as an array of [r,g,b,a] values
     *
     * @member {number[]}
     */
    this.clearColor = [0, 0, 0, 0];

    /**
     * The size of the object as a rectangle
     *
     * @member {PIXI.Rectangle}
     */
    this.size = new _math.Rectangle(0, 0, 1, 1);

    /**
     * The current resolution / device pixel ratio
     *
     * @member {number}
     * @default 1
     */
    this.resolution = resolution || _settings2.default.RESOLUTION;

    /**
     * The projection matrix
     *
     * @member {PIXI.Matrix}
     */
    this.projectionMatrix = new _math.Matrix();

    /**
     * The object's transform
     *
     * @member {PIXI.Matrix}
     */
    this.transform = null;

    /**
     * The frame.
     *
     * @member {PIXI.Rectangle}
     */
    this.frame = null;

    /**
     * The stencil buffer stores masking data for the render target
     *
     * @member {glCore.GLBuffer}
     */
    this.defaultFrame = new _math.Rectangle();
    this.destinationFrame = null;
    this.sourceFrame = null;

    /**
     * The stencil buffer stores masking data for the render target
     *
     * @member {glCore.GLBuffer}
     */
    this.stencilBuffer = null;

    /**
     * The data structure for the stencil masks
     *
     * @member {PIXI.Graphics[]}
     */
    this.stencilMaskStack = [];

    /**
     * Stores filter data for the render target
     *
     * @member {object[]}
     */
    this.filterData = null;

    /**
     * The scale mode.
     *
     * @member {number}
     * @default PIXI.settings.SCALE_MODE
     * @see PIXI.SCALE_MODES
     */
    this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;

    /**
     * Whether this object is the root element or not
     *
     * @member {boolean}
     */
    this.root = root;

    if (!this.root) {
      this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);

      if (this.scaleMode === _const.SCALE_MODES.NEAREST) {
        this.frameBuffer.texture.enableNearestScaling();
      } else {
        this.frameBuffer.texture.enableLinearScaling();
      }
      /*
          A frame buffer needs a target to render to..
          create a texture and bind it attach it to the framebuffer..
       */

      // this is used by the base texture
      this.texture = this.frameBuffer.texture;
    } else {
      // make it a null framebuffer..
      this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);
      this.frameBuffer.framebuffer = null;
    }

    this.setFrame();

    this.resize(width, height);
  }

  /**
   * Clears the filter texture.
   *
   * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer
   */


  RenderTarget.prototype.clear = function clear(clearColor) {
    var cc = clearColor || this.clearColor;

    this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);
  };

  /**
   * Binds the stencil buffer.
   *
   */


  RenderTarget.prototype.attachStencilBuffer = function attachStencilBuffer() {
    // TODO check if stencil is done?
    /**
     * The stencil buffer is used for masking in pixi
     * lets create one and then add attach it to the framebuffer..
     */
    if (!this.root) {
      this.frameBuffer.enableStencil();
    }
  };

  /**
   * Sets the frame of the render target.
   *
   * @param {Rectangle} destinationFrame - The destination frame.
   * @param {Rectangle} sourceFrame - The source frame.
   */


  RenderTarget.prototype.setFrame = function setFrame(destinationFrame, sourceFrame) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
  };

  /**
   * Binds the buffers and initialises the viewport.
   *
   */


  RenderTarget.prototype.activate = function activate() {
    // TOOD refactor usage of frame..
    var gl = this.gl;

    // make sure the texture is unbound!
    this.frameBuffer.bind();

    this.calculateProjection(this.destinationFrame, this.sourceFrame);

    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }

    // TODO add a check as them may be the same!
    if (this.destinationFrame !== this.sourceFrame) {
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }

    // TODO - does not need to be updated all the time??
    gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
  };

  /**
   * Updates the projection matrix based on a projection frame (which is a rectangle)
   *
   * @param {Rectangle} destinationFrame - The destination frame.
   * @param {Rectangle} sourceFrame - The source frame.
   */


  RenderTarget.prototype.calculateProjection = function calculateProjection(destinationFrame, sourceFrame) {
    var pm = this.projectionMatrix;

    sourceFrame = sourceFrame || destinationFrame;

    pm.identity();

    // TODO: make dest scale source
    if (!this.root) {
      pm.a = 1 / destinationFrame.width * 2;
      pm.d = 1 / destinationFrame.height * 2;

      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -1 - sourceFrame.y * pm.d;
    } else {
      pm.a = 1 / destinationFrame.width * 2;
      pm.d = -1 / destinationFrame.height * 2;

      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = 1 - sourceFrame.y * pm.d;
    }
  };

  /**
   * Resizes the texture to the specified width and height
   *
   * @param {number} width - the new width of the texture
   * @param {number} height - the new height of the texture
   */


  RenderTarget.prototype.resize = function resize(width, height) {
    width = width | 0;
    height = height | 0;

    if (this.size.width === width && this.size.height === height) {
      return;
    }

    this.size.width = width;
    this.size.height = height;

    this.defaultFrame.width = width;
    this.defaultFrame.height = height;

    this.frameBuffer.resize(width * this.resolution, height * this.resolution);

    var projectionFrame = this.frame || this.size;

    this.calculateProjection(projectionFrame);
  };

  /**
   * Destroys the render target.
   *
   */


  RenderTarget.prototype.destroy = function destroy() {
    this.frameBuffer.destroy();

    this.frameBuffer = null;
    this.texture = null;
  };

  return RenderTarget;
}();

exports.default = RenderTarget;
//# sourceMappingURL=RenderTarget.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 07.03.2017.
 */

class ProgressBar {
    constructor() {
        this.el = document.createElement('div');
    }

    getElem() {
        this.el.setAttribute('class', 'loader');
        return this.el;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ProgressBar;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

 "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}



/***/ }),
/* 25 */,
/* 26 */
/***/ (function(module, exports) {



var mapSize = function(gl, type) 
{
    if(!GL_TABLE) 
    {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);

        GL_TABLE = {};

        for(var i = 0; i < typeNames.length; ++i) 
        {
            var tn = typeNames[i];
            GL_TABLE[ gl[tn] ] = GL_TO_GLSL_TYPES[tn];
        }
    }

  return GL_TABLE[type];
};

var GL_TABLE = null;

var GL_TO_GLSL_TYPES = {
  'FLOAT':       'float',
  'FLOAT_VEC2':  'vec2',
  'FLOAT_VEC3':  'vec3',
  'FLOAT_VEC4':  'vec4',

  'INT':         'int',
  'INT_VEC2':    'ivec2',
  'INT_VEC3':    'ivec3',
  'INT_VEC4':    'ivec4',
  
  'BOOL':        'bool',
  'BOOL_VEC2':   'bvec2',
  'BOOL_VEC3':   'bvec3',
  'BOOL_VEC4':   'bvec4',
  
  'FLOAT_MAT2':  'mat2',
  'FLOAT_MAT3':  'mat3',
  'FLOAT_MAT4':  'mat4',
  
  'SAMPLER_2D':  'sampler2D'  
};

module.exports = mapSize;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _math = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 'Builder' pattern for bounds rectangles
 * Axis-Aligned Bounding Box
 * It is not a shape! Its mutable thing, no 'EMPTY' or that kind of problems
 *
 * @class
 * @memberof PIXI
 */
var Bounds = function () {
    /**
     *
     */
    function Bounds() {
        _classCallCheck(this, Bounds);

        /**
         * @member {number}
         * @default 0
         */
        this.minX = Infinity;

        /**
         * @member {number}
         * @default 0
         */
        this.minY = Infinity;

        /**
         * @member {number}
         * @default 0
         */
        this.maxX = -Infinity;

        /**
         * @member {number}
         * @default 0
         */
        this.maxY = -Infinity;

        this.rect = null;
    }

    /**
     * Checks if bounds are empty.
     *
     * @return {boolean} True if empty.
     */


    Bounds.prototype.isEmpty = function isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    };

    /**
     * Clears the bounds and resets.
     *
     */


    Bounds.prototype.clear = function clear() {
        this.updateID++;

        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
    };

    /**
     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
     * It is not guaranteed that it will return tempRect
     *
     * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
     * @returns {PIXI.Rectangle} A rectangle of the bounds
     */


    Bounds.prototype.getRectangle = function getRectangle(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
            return _math.Rectangle.EMPTY;
        }

        rect = rect || new _math.Rectangle(0, 0, 1, 1);

        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;

        return rect;
    };

    /**
     * This function should be inlined when its possible.
     *
     * @param {PIXI.Point} point - The point to add.
     */


    Bounds.prototype.addPoint = function addPoint(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
    };

    /**
     * Adds a quad, not transformed
     *
     * @param {Float32Array} vertices - The verts to add.
     */


    Bounds.prototype.addQuad = function addQuad(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        var x = vertices[0];
        var y = vertices[1];

        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    };

    /**
     * Adds sprite frame, transformed.
     *
     * @param {PIXI.TransformBase} transform - TODO
     * @param {number} x0 - TODO
     * @param {number} y0 - TODO
     * @param {number} x1 - TODO
     * @param {number} y1 - TODO
     */


    Bounds.prototype.addFrame = function addFrame(transform, x0, y0, x1, y1) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;

        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        var x = a * x0 + c * y0 + tx;
        var y = b * x0 + d * y0 + ty;

        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = a * x1 + c * y0 + tx;
        y = b * x1 + d * y0 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = a * x0 + c * y1 + tx;
        y = b * x0 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        x = a * x1 + c * y1 + tx;
        y = b * x1 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;

        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    };

    /**
     * Add an array of vertices
     *
     * @param {PIXI.TransformBase} transform - TODO
     * @param {Float32Array} vertices - TODO
     * @param {number} beginOffset - TODO
     * @param {number} endOffset - TODO
     */


    Bounds.prototype.addVertices = function addVertices(transform, vertices, beginOffset, endOffset) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;

        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        for (var i = beginOffset; i < endOffset; i += 2) {
            var rawX = vertices[i];
            var rawY = vertices[i + 1];
            var x = a * rawX + c * rawY + tx;
            var y = d * rawY + b * rawX + ty;

            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }

        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    };

    /**
     * Adds other Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     */


    Bounds.prototype.addBounds = function addBounds(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    };

    /**
     * Adds other Bounds, masked with Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Bounds} mask - TODO
     */


    Bounds.prototype.addBoundsMask = function addBoundsMask(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;

        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;

            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    };

    /**
     * Adds other Bounds, masked with Rectangle
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Rectangle} area - TODO
     */


    Bounds.prototype.addBoundsArea = function addBoundsArea(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;

        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;

            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    };

    return Bounds;
}();

exports.default = Bounds;
//# sourceMappingURL=Bounds.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _math = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generic class to deal with traditional 2D matrix transforms
 *
 * @class
 * @memberof PIXI
 */
var TransformBase = function () {
  /**
   *
   */
  function TransformBase() {
    _classCallCheck(this, TransformBase);

    /**
     * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
     *
     * @member {PIXI.Matrix}
     */
    this.worldTransform = new _math.Matrix();

    /**
     * The local matrix transform
     *
     * @member {PIXI.Matrix}
     */
    this.localTransform = new _math.Matrix();

    this._worldID = 0;
    this._parentID = 0;
  }

  /**
   * TransformBase does not have decomposition, so this function wont do anything
   */


  TransformBase.prototype.updateLocalTransform = function updateLocalTransform() {}
  // empty


  /**
   * Updates the values of the object and applies the parent's transform.
   *
   * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object
   */
  ;

  TransformBase.prototype.updateTransform = function updateTransform(parentTransform) {
    var pt = parentTransform.worldTransform;
    var wt = this.worldTransform;
    var lt = this.localTransform;

    // concat the parent matrix with the objects transform.
    wt.a = lt.a * pt.a + lt.b * pt.c;
    wt.b = lt.a * pt.b + lt.b * pt.d;
    wt.c = lt.c * pt.a + lt.d * pt.c;
    wt.d = lt.c * pt.b + lt.d * pt.d;
    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

    this._worldID++;
  };

  return TransformBase;
}();

/**
 * Updates the values of the object and applies the parent's transform.
 * @param  parentTransform {PIXI.Transform} The transform of the parent of this object
 *
 */


exports.default = TransformBase;
TransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;

TransformBase.IDENTITY = new TransformBase();
//# sourceMappingURL=TransformBase.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 */
var Point = function () {
  /**
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  function Point() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Point);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;
  }

  /**
   * Creates a clone of this point
   *
   * @return {PIXI.Point} a copy of the point
   */


  Point.prototype.clone = function clone() {
    return new Point(this.x, this.y);
  };

  /**
   * Copies x and y from the given point
   *
   * @param {PIXI.Point} p - The point to copy.
   */


  Point.prototype.copy = function copy(p) {
    this.set(p.x, p.y);
  };

  /**
   * Returns true if the given point is equal to this point
   *
   * @param {PIXI.Point} p - The point to check
   * @returns {boolean} Whether the given point equal to this point
   */


  Point.prototype.equals = function equals(p) {
    return p.x === this.x && p.y === this.y;
  };

  /**
   * Sets the point to a new x and y position.
   * If y is omitted, both x and y will be set to x.
   *
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */


  Point.prototype.set = function set(x, y) {
    this.x = x || 0;
    this.y = y || (y !== 0 ? this.x : 0);
  };

  return Point;
}();

exports.default = Point;
//# sourceMappingURL=Point.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _const = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 */
var Rectangle = function () {
    /**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
     * @param {number} [width=0] - The overall width of this rectangle
     * @param {number} [height=0] - The overall height of this rectangle
     */
    function Rectangle() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        _classCallCheck(this, Rectangle);

        /**
         * @member {number}
         * @default 0
         */
        this.x = x;

        /**
         * @member {number}
         * @default 0
         */
        this.y = y;

        /**
         * @member {number}
         * @default 0
         */
        this.width = width;

        /**
         * @member {number}
         * @default 0
         */
        this.height = height;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */
        this.type = _const.SHAPES.RECT;
    }

    /**
     * returns the left edge of the rectangle
     *
     * @member {number}
     */


    /**
     * Creates a clone of this Rectangle
     *
     * @return {PIXI.Rectangle} a copy of the rectangle
     */
    Rectangle.prototype.clone = function clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };

    /**
     * Copies another rectangle to this one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy.
     * @return {PIXI.Rectangle} Returns itself.
     */


    Rectangle.prototype.copy = function copy(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;

        return this;
    };

    /**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rectangle
     */


    Rectangle.prototype.contains = function contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }

        if (x >= this.x && x < this.x + this.width) {
            if (y >= this.y && y < this.y + this.height) {
                return true;
            }
        }

        return false;
    };

    /**
     * Pads the rectangle making it grow in all directions.
     *
     * @param {number} paddingX - The horizontal padding amount.
     * @param {number} paddingY - The vertical padding amount.
     */


    Rectangle.prototype.pad = function pad(paddingX, paddingY) {
        paddingX = paddingX || 0;
        paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);

        this.x -= paddingX;
        this.y -= paddingY;

        this.width += paddingX * 2;
        this.height += paddingY * 2;
    };

    /**
     * Fits this rectangle around the passed one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
     */


    Rectangle.prototype.fit = function fit(rectangle) {
        if (this.x < rectangle.x) {
            this.width += this.x;
            if (this.width < 0) {
                this.width = 0;
            }

            this.x = rectangle.x;
        }

        if (this.y < rectangle.y) {
            this.height += this.y;
            if (this.height < 0) {
                this.height = 0;
            }
            this.y = rectangle.y;
        }

        if (this.x + this.width > rectangle.x + rectangle.width) {
            this.width = rectangle.width - this.x;
            if (this.width < 0) {
                this.width = 0;
            }
        }

        if (this.y + this.height > rectangle.y + rectangle.height) {
            this.height = rectangle.height - this.y;
            if (this.height < 0) {
                this.height = 0;
            }
        }
    };

    /**
     * Enlarges this rectangle to include the passed rectangle.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to include.
     */


    Rectangle.prototype.enlarge = function enlarge(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);

        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
    };

    _createClass(Rectangle, [{
        key: 'left',
        get: function get() {
            return this.x;
        }

        /**
         * returns the right edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'right',
        get: function get() {
            return this.x + this.width;
        }

        /**
         * returns the top edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'top',
        get: function get() {
            return this.y;
        }

        /**
         * returns the bottom edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'bottom',
        get: function get() {
            return this.y + this.height;
        }

        /**
         * A constant empty rectangle.
         *
         * @static
         * @constant
         */

    }], [{
        key: 'EMPTY',
        get: function get() {
            return new Rectangle(0, 0, 0, 0);
        }
    }]);

    return Rectangle;
}();

exports.default = Rectangle;
//# sourceMappingURL=Rectangle.js.map

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(2);

var _utils = __webpack_require__(1);

var _const = __webpack_require__(0);

var _Texture = __webpack_require__(15);

var _Texture2 = _interopRequireDefault(_Texture);

var _Container2 = __webpack_require__(11);

var _Container3 = _interopRequireDefault(_Container2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var tempPoint = new _math.Point();

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * A sprite can be created directly from an image like this:
 *
 * ```js
 * let sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * ```
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */

var Sprite = function (_Container) {
    _inherits(Sprite, _Container);

    /**
     * @param {PIXI.Texture} texture - The texture for this sprite
     */
    function Sprite(texture) {
        _classCallCheck(this, Sprite);

        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 this means the texture's origin is the top left
         * Setting the anchor to 0.5,0.5 means the texture's origin is centered
         * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */
        var _this = _possibleConstructorReturn(this, _Container.call(this));

        _this._anchor = new _math.ObservablePoint(_this._onAnchorUpdate, _this);

        /**
         * The texture that the sprite is using
         *
         * @private
         * @member {PIXI.Texture}
         */
        _this._texture = null;

        /**
         * The width of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        _this._width = 0;

        /**
         * The height of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        _this._height = 0;

        /**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        _this._tint = null;
        _this._tintRGB = null;
        _this.tint = 0xFFFFFF;

        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        _this.blendMode = _const.BLEND_MODES.NORMAL;

        /**
         * The shader that will be used to render the sprite. Set to null to remove a current shader.
         *
         * @member {PIXI.Filter|PIXI.Shader}
         */
        _this.shader = null;

        /**
         * An internal cached value of the tint.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        _this.cachedTint = 0xFFFFFF;

        // call texture setter
        _this.texture = texture || _Texture2.default.EMPTY;

        /**
         * this is used to store the vertex data of the sprite (basically a quad)
         *
         * @private
         * @member {Float32Array}
         */
        _this.vertexData = new Float32Array(8);

        /**
         * This is used to calculate the bounds of the object IF it is a trimmed sprite
         *
         * @private
         * @member {Float32Array}
         */
        _this.vertexTrimmedData = null;

        _this._transformID = -1;
        _this._textureID = -1;

        _this._transformTrimmedID = -1;
        _this._textureTrimmedID = -1;

        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
         *
         * @member {string}
         * @default 'sprite'
         */
        _this.pluginName = 'sprite';
        return _this;
    }

    /**
     * When the texture is updated, this event will fire to update the scale and frame
     *
     * @private
     */


    Sprite.prototype._onTextureUpdate = function _onTextureUpdate() {
        this._textureID = -1;
        this._textureTrimmedID = -1;

        // so if _width is 0 then width was not set..
        if (this._width) {
            this.scale.x = (0, _utils.sign)(this.scale.x) * this._width / this.texture.orig.width;
        }

        if (this._height) {
            this.scale.y = (0, _utils.sign)(this.scale.y) * this._height / this.texture.orig.height;
        }
    };

    /**
     * Called when the anchor position updates.
     *
     * @private
     */


    Sprite.prototype._onAnchorUpdate = function _onAnchorUpdate() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
    };

    /**
     * calculates worldTransform * vertices, store it in vertexData
     */


    Sprite.prototype.calculateVertices = function calculateVertices() {
        if (this._transformID === this.transform._worldID && this._textureID === this._texture._updateID) {
            return;
        }

        this._transformID = this.transform._worldID;
        this._textureID = this._texture._updateID;

        // set the vertex data

        var texture = this._texture;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;

        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;

        if (trim) {
            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
            // space before transforming the sprite coords.
            w1 = trim.x - anchor._x * orig.width;
            w0 = w1 + trim.width;

            h1 = trim.y - anchor._y * orig.height;
            h0 = h1 + trim.height;
        } else {
            w1 = -anchor._x * orig.width;
            w0 = w1 + orig.width;

            h1 = -anchor._y * orig.height;
            h0 = h1 + orig.height;
        }

        // xy
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;

        // xy
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;

        // xy
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;

        // xy
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
    };

    /**
     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
     * This is used to ensure that the true width and height of a trimmed texture is respected
     */


    Sprite.prototype.calculateTrimmedVertices = function calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) {
            this.vertexTrimmedData = new Float32Array(8);
        } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
            return;
        }

        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;

        // lets do some special trim code!
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;

        // lets calculate the new untrimmed bounds..
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;

        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;

        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;

        // xy
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;

        // xy
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;

        // xy
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;

        // xy
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
    };

    /**
    *
    * Renders the object using the WebGL renderer
    *
    * @private
    * @param {PIXI.WebGLRenderer} renderer - The webgl renderer to use.
    */


    Sprite.prototype._renderWebGL = function _renderWebGL(renderer) {
        this.calculateVertices();

        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    };

    /**
    * Renders the object using the Canvas renderer
    *
    * @private
    * @param {PIXI.CanvasRenderer} renderer - The renderer
    */


    Sprite.prototype._renderCanvas = function _renderCanvas(renderer) {
        renderer.plugins[this.pluginName].render(this);
    };

    /**
     * Updates the bounds of the sprite.
     *
     * @private
     */


    Sprite.prototype._calculateBounds = function _calculateBounds() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;

        // First lets check to see if the current texture has a trim..
        if (!trim || trim.width === orig.width && trim.height === orig.height) {
            // no trim! lets use the usual calculations..
            this.calculateVertices();
            this._bounds.addQuad(this.vertexData);
        } else {
            // lets calculate a special trimmed bounds...
            this.calculateTrimmedVertices();
            this._bounds.addQuad(this.vertexTrimmedData);
        }
    };

    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */


    Sprite.prototype.getLocalBounds = function getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._texture.orig.width * -this._anchor._x;
            this._bounds.minY = this._texture.orig.height * -this._anchor._y;
            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._x);

            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new _math.Rectangle();
                }

                rect = this._localBoundsRect;
            }

            return this._bounds.getRectangle(rect);
        }

        return _Container.prototype.getLocalBounds.call(this, rect);
    };

    /**
     * Tests if a point is inside this sprite
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */


    Sprite.prototype.containsPoint = function containsPoint(point) {
        this.worldTransform.applyInverse(point, tempPoint);

        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;

        if (tempPoint.x > x1 && tempPoint.x < x1 + width) {
            y1 = -height * this.anchor.y;

            if (tempPoint.y > y1 && tempPoint.y < y1 + height) {
                return true;
            }
        }

        return false;
    };

    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */


    Sprite.prototype.destroy = function destroy(options) {
        _Container.prototype.destroy.call(this, options);

        this._anchor = null;

        var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;

        if (destroyTexture) {
            var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;

            this._texture.destroy(!!destroyBaseTexture);
        }

        this._texture = null;
        this.shader = null;
    };

    // some helper functions..

    /**
     * Helper function that creates a new sprite based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
     * @return {PIXI.Sprite} The newly created sprite
     */


    Sprite.from = function from(source) {
        return new Sprite(_Texture2.default.from(source));
    };

    /**
     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
     * The frame ids are created when a Texture packer file has been loaded
     *
     * @static
     * @param {string} frameId - The frame Id of the texture in the cache
     * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
     */


    Sprite.fromFrame = function fromFrame(frameId) {
        var texture = _utils.TextureCache[frameId];

        if (!texture) {
            throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
        }

        return new Sprite(texture);
    };

    /**
     * Helper function that creates a sprite that will contain a texture based on an image url
     * If the image is not in the texture cache it will be loaded
     *
     * @static
     * @param {string} imageId - The image url of the texture
     * @param {boolean} [crossorigin=(auto)] - if you want to specify the cross-origin parameter
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,
     *  see {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
     */


    Sprite.fromImage = function fromImage(imageId, crossorigin, scaleMode) {
        return new Sprite(_Texture2.default.fromImage(imageId, crossorigin, scaleMode));
    };

    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */


    _createClass(Sprite, [{
        key: 'width',
        get: function get() {
            return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var s = (0, _utils.sign)(this.scale.x) || 1;

            this.scale.x = s * value / this._texture.orig.width;
            this._width = value;
        }

        /**
         * The height of the sprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            var s = (0, _utils.sign)(this.scale.y) || 1;

            this.scale.y = s * value / this._texture.orig.height;
            this._height = value;
        }

        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 this means the texture's origin is the top left
         * Setting the anchor to 0.5,0.5 means the texture's origin is centered
         * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
         *
         * @member {PIXI.ObservablePoint}
         */

    }, {
        key: 'anchor',
        get: function get() {
            return this._anchor;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._anchor.copy(value);
        }

        /**
         * The tint applied to the sprite. This is a hex value.
         * A value of 0xFFFFFF will remove any tint effect.
         *
         * @member {number}
         * @default 0xFFFFFF
         */

    }, {
        key: 'tint',
        get: function get() {
            return this._tint;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._tint = value;
            this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
        }

        /**
         * The texture that the sprite is using
         *
         * @member {PIXI.Texture}
         */

    }, {
        key: 'texture',
        get: function get() {
            return this._texture;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._texture === value) {
                return;
            }

            this._texture = value;
            this.cachedTint = 0xFFFFFF;

            this._textureID = -1;
            this._textureTrimmedID = -1;

            if (value) {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded) {
                    this._onTextureUpdate();
                } else {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }]);

    return Sprite;
}(_Container3.default);

exports.default = Sprite;
//# sourceMappingURL=Sprite.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _BaseRenderTexture = __webpack_require__(73);

var _BaseRenderTexture2 = _interopRequireDefault(_BaseRenderTexture);

var _Texture2 = __webpack_require__(15);

var _Texture3 = _interopRequireDefault(_Texture2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
 * let renderTexture = PIXI.RenderTexture.create(800, 600);
 * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderer.render(sprite, renderTexture);
 * ```
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let renderTexture = new PIXI.RenderTexture.create(100, 100);
 *
 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.Texture
 * @memberof PIXI
 */
var RenderTexture = function (_Texture) {
    _inherits(RenderTexture, _Texture);

    /**
     * @param {PIXI.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     */
    function RenderTexture(baseRenderTexture, frame) {
        _classCallCheck(this, RenderTexture);

        // support for legacy..
        var _legacyRenderer = null;

        if (!(baseRenderTexture instanceof _BaseRenderTexture2.default)) {
            /* eslint-disable prefer-rest-params, no-console */
            var width = arguments[1];
            var height = arguments[2];
            var scaleMode = arguments[3];
            var resolution = arguments[4];

            // we have an old render texture..
            console.warn('Please use RenderTexture.create(' + width + ', ' + height + ') instead of the ctor directly.');
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */

            frame = null;
            baseRenderTexture = new _BaseRenderTexture2.default(width, height, scaleMode, resolution);
        }

        /**
         * The base texture object that this texture uses
         *
         * @member {BaseTexture}
         */

        var _this = _possibleConstructorReturn(this, _Texture.call(this, baseRenderTexture, frame));

        _this.legacyRenderer = _legacyRenderer;

        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        _this.valid = true;

        _this._updateUvs();
        return _this;
    }

    /**
     * Resizes the RenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?
     */


    RenderTexture.prototype.resize = function resize(width, height, doNotResizeBaseTexture) {
        // TODO - could be not required..
        this.valid = width > 0 && height > 0;

        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;

        if (!doNotResizeBaseTexture) {
            this.baseTexture.resize(width, height);
        }

        this._updateUvs();
    };

    /**
     * A short hand way of creating a render texture.
     *
     * @param {number} [width=100] - The width of the render texture
     * @param {number} [height=100] - The height of the render texture
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */


    RenderTexture.create = function create(width, height, scaleMode, resolution) {
        return new RenderTexture(new _BaseRenderTexture2.default(width, height, scaleMode, resolution));
    };

    return RenderTexture;
}(_Texture3.default);

exports.default = RenderTexture;
//# sourceMappingURL=RenderTexture.js.map

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Ticker = exports.shared = undefined;

var _Ticker = __webpack_require__(153);

var _Ticker2 = _interopRequireDefault(_Ticker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The shared ticker instance used by {@link PIXI.extras.AnimatedSprite}.
 * and by {@link PIXI.interaction.InteractionManager}.
 * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`
 * for this instance. Please follow the examples for usage, including
 * how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * let ticker = PIXI.ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * let renderer = PIXI.autoDetectRenderer(800, 600);
 * let stage = new PIXI.Container();
 * let interactionManager = PIXI.interaction.InteractionManager(renderer);
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 *     renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 *     ticker.update(time);
 *     renderer.render(stage);
 *     requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @type {PIXI.ticker.Ticker}
 * @memberof PIXI.ticker
 */
var shared = new _Ticker2.default();

shared.autoStart = true;

/**
 * @namespace PIXI.ticker
 */
exports.shared = shared;
exports.Ticker = _Ticker2.default;
//# sourceMappingURL=index.js.map

/***/ }),
/* 34 */,
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 06.03.2017.
 */

class User {
    constructor() {
        if (User.__instance) {
            return User.__instance;
        }
        User.__instance = this;
    }

    set obj(user) {
        this._user = user;
    }
}
/* unused harmony export default */




/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 05.03.2017.
 */

class Http {
    constructor() {
        if (Http.instance) {
            return Http.instance;
        }

        this._baseUrl = 'http://localhost:8000/api';
        //this._baseUrl = 'https://tp-server-java.herokuapp.com/api';

        Http.instance = this;
    }

    get BaseUrl() {
        return this._baseUrl;
    }

    set BaseUrl(value) {
        this._baseUrl = value;
    }

    request(address = '', headers = {}, type = 'GET', body = {}) {
        let fetchObj = {
            method: type,
            mode: 'cors',
            headers: headers,
            credentials: 'include'
        };
        if (body) {
            fetchObj.body = JSON.stringify(body);
        }

        return new Promise(function (resolve, reject) {
            fetch(address, fetchObj).then(response => {
                return response.json();
            }).then(json => {
                resolve(json);
            }).catch(err => {
                reject({});
                console.error(err || err.statusText);
            });
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Http;



/***/ }),
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * isMobile.js v0.4.1
 *
 * A simple library to detect Apple phones and tablets,
 * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
 * and any kind of seven inch device, via user agent sniffing.
 *
 * @author: Kai Mallea (kmallea@gmail.com)
 *
 * @license: http://creativecommons.org/publicdomain/zero/1.0/
 */
(function (global) {

    var apple_phone         = /iPhone/i,
        apple_ipod          = /iPod/i,
        apple_tablet        = /iPad/i,
        android_phone       = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i, // Match 'Android' AND 'Mobile'
        android_tablet      = /Android/i,
        amazon_phone        = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
        amazon_tablet       = /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
        windows_phone       = /Windows Phone/i,
        windows_tablet      = /(?=.*\bWindows\b)(?=.*\bARM\b)/i, // Match 'Windows' AND 'ARM'
        other_blackberry    = /BlackBerry/i,
        other_blackberry_10 = /BB10/i,
        other_opera         = /Opera Mini/i,
        other_chrome        = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
        other_firefox       = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i, // Match 'Firefox' AND 'Mobile'
        seven_inch = new RegExp(
            '(?:' +         // Non-capturing group

            'Nexus 7' +     // Nexus 7

            '|' +           // OR

            'BNTV250' +     // B&N Nook Tablet 7 inch

            '|' +           // OR

            'Kindle Fire' + // Kindle Fire

            '|' +           // OR

            'Silk' +        // Kindle Fire, Silk Accelerated

            '|' +           // OR

            'GT-P1000' +    // Galaxy Tab 7 inch

            ')',            // End non-capturing group

            'i');           // Case-insensitive matching

    var match = function(regex, userAgent) {
        return regex.test(userAgent);
    };

    var IsMobileClass = function(userAgent) {
        var ua = userAgent || navigator.userAgent;

        // Facebook mobile app's integrated browser adds a bunch of strings that
        // match everything. Strip it out if it exists.
        var tmp = ua.split('[FBAN');
        if (typeof tmp[1] !== 'undefined') {
            ua = tmp[0];
        }

        // Twitter mobile app's integrated browser on iPad adds a "Twitter for
        // iPhone" string. Same probable happens on other tablet platforms.
        // This will confuse detection so strip it out if it exists.
        tmp = ua.split('Twitter');
        if (typeof tmp[1] !== 'undefined') {
            ua = tmp[0];
        }

        this.apple = {
            phone:  match(apple_phone, ua),
            ipod:   match(apple_ipod, ua),
            tablet: !match(apple_phone, ua) && match(apple_tablet, ua),
            device: match(apple_phone, ua) || match(apple_ipod, ua) || match(apple_tablet, ua)
        };
        this.amazon = {
            phone:  match(amazon_phone, ua),
            tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua),
            device: match(amazon_phone, ua) || match(amazon_tablet, ua)
        };
        this.android = {
            phone:  match(amazon_phone, ua) || match(android_phone, ua),
            tablet: !match(amazon_phone, ua) && !match(android_phone, ua) && (match(amazon_tablet, ua) || match(android_tablet, ua)),
            device: match(amazon_phone, ua) || match(amazon_tablet, ua) || match(android_phone, ua) || match(android_tablet, ua)
        };
        this.windows = {
            phone:  match(windows_phone, ua),
            tablet: match(windows_tablet, ua),
            device: match(windows_phone, ua) || match(windows_tablet, ua)
        };
        this.other = {
            blackberry:   match(other_blackberry, ua),
            blackberry10: match(other_blackberry_10, ua),
            opera:        match(other_opera, ua),
            firefox:      match(other_firefox, ua),
            chrome:       match(other_chrome, ua),
            device:       match(other_blackberry, ua) || match(other_blackberry_10, ua) || match(other_opera, ua) || match(other_firefox, ua) || match(other_chrome, ua)
        };
        this.seven_inch = match(seven_inch, ua);
        this.any = this.apple.device || this.android.device || this.windows.device || this.other.device || this.seven_inch;

        // excludes 'other' devices and ipods, targeting touchscreen phones
        this.phone = this.apple.phone || this.android.phone || this.windows.phone;

        // excludes 7 inch devices, classifying as phone or tablet is left to the user
        this.tablet = this.apple.tablet || this.android.tablet || this.windows.tablet;

        if (typeof window === 'undefined') {
            return this;
        }
    };

    var instantiate = function() {
        var IM = new IsMobileClass();
        IM.Class = IsMobileClass;
        return IM;
    };

    if (typeof module !== 'undefined' && module.exports && typeof window === 'undefined') {
        //node
        module.exports = IsMobileClass;
    } else if (typeof module !== 'undefined' && module.exports && typeof window !== 'undefined') {
        //browserify
        module.exports = instantiate();
    } else if (true) {
        //AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (global.isMobile = instantiate()),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        global.isMobile = instantiate();
    }

})(this);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(160)))

/***/ }),
/* 48 */
/***/ (function(module, exports) {


/**
 * Helper class to create a WebGL Texture
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param width {number} the width of the texture
 * @param height {number} the height of the texture
 * @param format {number} the pixel format of the texture. defaults to gl.RGBA
 * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE
 */
var Texture = function(gl, width, height, format, type)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;


	/**
	 * The WebGL texture
	 *
	 * @member {WebGLTexture}
	 */
	this.texture = gl.createTexture();

	/**
	 * If mipmapping was used for this texture, enable and disable with enableMipmap()
	 *
	 * @member {Boolean}
	 */
	// some settings..
	this.mipmap = false;


	/**
	 * Set to true to enable pre-multiplied alpha
	 *
	 * @member {Boolean}
	 */
	this.premultiplyAlpha = false;

	/**
	 * The width of texture
	 *
	 * @member {Number}
	 */
	this.width = width || -1;
	/**
	 * The height of texture
	 *
	 * @member {Number}
	 */
	this.height = height || -1;

	/**
	 * The pixel format of the texture. defaults to gl.RGBA
	 *
	 * @member {Number}
	 */
	this.format = format || gl.RGBA;

	/**
	 * The gl type of the texture. defaults to gl.UNSIGNED_BYTE
	 *
	 * @member {Number}
	 */
	this.type = type || gl.UNSIGNED_BYTE;


};

/**
 * Uploads this texture to the GPU
 * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture
 */
Texture.prototype.upload = function(source)
{
	this.bind();

	var gl = this.gl;


	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

	var newWidth = source.videoWidth || source.width;
	var newHeight = source.videoHeight || source.height;

	if(newHeight !== this.height || newWidth !== this.width)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);
	}
	else
	{
    	gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);
	}

	// if the source is a video, we need to use the videoWidth / videoHeight properties as width / height will be incorrect.
	this.width = newWidth;
	this.height = newHeight;

};

var FLOATING_POINT_AVAILABLE = false;

/**
 * Use a data source and uploads this texture to the GPU
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.prototype.uploadData = function(data, width, height)
{
	this.bind();

	var gl = this.gl;


	if(data instanceof Float32Array)
	{
		if(!FLOATING_POINT_AVAILABLE)
		{
			var ext = gl.getExtension("OES_texture_float");

			if(ext)
			{
				FLOATING_POINT_AVAILABLE = true;
			}
			else
			{
				throw new Error('floating point textures not available');
			}
		}

		this.type = gl.FLOAT;
	}
	else
	{
		// TODO support for other types
		this.type = this.type || gl.UNSIGNED_BYTE;
	}

	// what type of data?
	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);


	if(width !== this.width || height !== this.height)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format,  width, height, 0, this.format, this.type, data || null);
	}
	else
	{
		gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);
	}

	this.width = width;
	this.height = height;


//	texSubImage2D
};

/**
 * Binds the texture
 * @param  location
 */
Texture.prototype.bind = function(location)
{
	var gl = this.gl;

	if(location !== undefined)
	{
		gl.activeTexture(gl.TEXTURE0 + location);
	}

	gl.bindTexture(gl.TEXTURE_2D, this.texture);
};

/**
 * Unbinds the texture
 */
Texture.prototype.unbind = function()
{
	var gl = this.gl;
	gl.bindTexture(gl.TEXTURE_2D, null);
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.minFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	if(this.mipmap)
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
	}
	else
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);
	}
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.magFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);
};

/**
 * Enables mipmapping
 */
Texture.prototype.enableMipmap = function()
{
	var gl = this.gl;

	this.bind();

	this.mipmap = true;

	gl.generateMipmap(gl.TEXTURE_2D);
};

/**
 * Enables linear filtering
 */
Texture.prototype.enableLinearScaling = function()
{
	this.minFilter(true);
	this.magFilter(true);
};

/**
 * Enables nearest neighbour interpolation
 */
Texture.prototype.enableNearestScaling = function()
{
	this.minFilter(false);
	this.magFilter(false);
};

/**
 * Enables clamping on the texture so WebGL will not repeat it
 */
Texture.prototype.enableWrapClamp = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
};

/**
 * Enable tiling on the texture
 */
Texture.prototype.enableWrapRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
};

Texture.prototype.enableWrapMirrorRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
};


/**
 * Destroys this texture
 */
Texture.prototype.destroy = function()
{
	var gl = this.gl;
	//TODO
	gl.deleteTexture(this.texture);
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param source {HTMLImageElement|ImageData} the source image of the texture
 * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha
 */
Texture.fromSource = function(gl, source, premultiplyAlpha)
{
	var texture = new Texture(gl);
	texture.premultiplyAlpha = premultiplyAlpha || false;
	texture.upload(source);

	return texture;
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.fromData = function(gl, data, width, height)
{
	//console.log(data, width, height);
	var texture = new Texture(gl);
	texture.uploadData(data, width, height);

	return texture;
};


module.exports = Texture;


/***/ }),
/* 49 */
/***/ (function(module, exports) {

// var GL_MAP = {};

/**
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param attribs {*}
 * @param state {*}
 */
var setVertexAttribArrays = function (gl, attribs, state)
{
    var i;
    if(state)
    {
        var tempAttribState = state.tempAttribState,
            attribState = state.attribState;

        for (i = 0; i < tempAttribState.length; i++)
        {
            tempAttribState[i] = false;
        }

        // set the new attribs
        for (i = 0; i < attribs.length; i++)
        {
            tempAttribState[attribs[i].attribute.location] = true;
        }

        for (i = 0; i < attribState.length; i++)
        {
            if (attribState[i] !== tempAttribState[i])
            {
                attribState[i] = tempAttribState[i];

                if (state.attribState[i])
                {
                    gl.enableVertexAttribArray(i);
                }
                else
                {
                    gl.disableVertexAttribArray(i);
                }
            }
        }

    }
    else
    {
        for (i = 0; i < attribs.length; i++)
        {
            var attrib = attribs[i];
            gl.enableVertexAttribArray(attrib.attribute.location);
        }
    }
};

module.exports = setVertexAttribArrays;


/***/ }),
/* 50 */
/***/ (function(module, exports) {


/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
var compileProgram = function(gl, vertexSrc, fragmentSrc, attributeLocations)
{
    var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
    var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);

    // optionally, set the attributes manually for the program rather than letting WebGL decide..
    if(attributeLocations)
    {
        for(var i in attributeLocations)
        {
            gl.bindAttribLocation(program, attributeLocations[i], i);
        }
    }


    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return program;
};

/**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
var compileShader = function (gl, type, src)
{
    var shader = gl.createShader(type);

    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

module.exports = compileProgram;


/***/ }),
/* 51 */
/***/ (function(module, exports) {

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String} Type of value
 * @param size {Number}
 */
var defaultValue = function(type, size) 
{
    switch (type)
    {
        case 'float':
            return 0;

        case 'vec2': 
            return new Float32Array(2 * size);

        case 'vec3':
            return new Float32Array(3 * size);

        case 'vec4':     
            return new Float32Array(4 * size);
            
        case 'int':
        case 'sampler2D':
            return 0;

        case 'ivec2':   
            return new Int32Array(2 * size);

        case 'ivec3':
            return new Int32Array(3 * size);

        case 'ivec4': 
            return new Int32Array(4 * size);

        case 'bool':     
            return false;

        case 'bvec2':

            return booleanArray( 2 * size);

        case 'bvec3':
            return booleanArray(3 * size);

        case 'bvec4':
            return booleanArray(4 * size);

        case 'mat2':
            return new Float32Array([1, 0,
                                     0, 1]);

        case 'mat3': 
            return new Float32Array([1, 0, 0,
                                     0, 1, 0,
                                     0, 0, 1]);

        case 'mat4':
            return new Float32Array([1, 0, 0, 0,
                                     0, 1, 0, 0,
                                     0, 0, 1, 0,
                                     0, 0, 0, 1]);
    }
};

var booleanArray = function(size)
{
    var array = new Array(size);

    for (var i = 0; i < array.length; i++) 
    {
        array[i] = false;
    }

    return array;
};

module.exports = defaultValue;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {


var mapType = __webpack_require__(26);
var mapSize = __webpack_require__(55);

/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the attributes from
 * @return attributes {Object}
 */
var extractAttributes = function(gl, program)
{
    var attributes = {};

    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

    for (var i = 0; i < totalAttributes; i++)
    {
        var attribData = gl.getActiveAttrib(program, i);
        var type = mapType(gl, attribData.type);

        attributes[attribData.name] = {
            type:type,
            size:mapSize(type),
            location:gl.getAttribLocation(program, attribData.name),
            //TODO - make an attribute object
            pointer: pointer
        };
    }

    return attributes;
};

var pointer = function(type, normalized, stride, start){
    // console.log(this.location)
    gl.vertexAttribPointer(this.location,this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0);
};

module.exports = extractAttributes;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var mapType = __webpack_require__(26);
var defaultValue = __webpack_require__(51);

/**
 * Extracts the uniforms
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the uniforms from
 * @return uniforms {Object}
 */
var extractUniforms = function(gl, program)
{
	var uniforms = {};

    var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var i = 0; i < totalUniforms; i++)
    {
    	var uniformData = gl.getActiveUniform(program, i);
    	var name = uniformData.name.replace(/\[.*?\]/, "");
        var type = mapType(gl, uniformData.type );

    	uniforms[name] = {
    		type:type,
    		size:uniformData.size,
    		location:gl.getUniformLocation(program, name),
    		value:defaultValue(type, uniformData.size)
    	};
    }

	return uniforms;
};

module.exports = extractUniforms;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param uniforms {Array} @mat ?
 * @return attributes {Object}
 */
var generateUniformAccessObject = function(gl, uniformData)
{
    // this is the object we will be sending back.
    // an object hierachy will be created for structs
    var uniforms = {data:{}};

    uniforms.gl = gl;

    var uniformKeys= Object.keys(uniformData);

    for (var i = 0; i < uniformKeys.length; i++)
    {
        var fullName = uniformKeys[i];

        var nameTokens = fullName.split('.');
        var name = nameTokens[nameTokens.length - 1];


        var uniformGroup = getUniformGroup(nameTokens, uniforms);

        var uniform =  uniformData[fullName];
        uniformGroup.data[name] = uniform;

        uniformGroup.gl = gl;

        Object.defineProperty(uniformGroup, name, {
            get: generateGetter(name),
            set: generateSetter(name, uniform)
        });
    }

    return uniforms;
};

var generateGetter = function(name)
{
	var template = getterTemplate.replace('%%', name);
	return new Function(template); // jshint ignore:line
};

var generateSetter = function(name, uniform)
{
    var template = setterTemplate.replace(/%%/g, name);
    var setTemplate;

    if(uniform.size === 1)
    {
        setTemplate = GLSL_TO_SINGLE_SETTERS[uniform.type];
    }
    else
    {
        setTemplate = GLSL_TO_ARRAY_SETTERS[uniform.type];
    }

    if(setTemplate)
    {
        template += "\nthis.gl." + setTemplate + ";";
    }

  	return new Function('value', template); // jshint ignore:line
};

var getUniformGroup = function(nameTokens, uniform)
{
    var cur = uniform;

    for (var i = 0; i < nameTokens.length - 1; i++)
    {
        var o = cur[nameTokens[i]] || {data:{}};
        cur[nameTokens[i]] = o;
        cur = o;
    }

    return cur;
};

var getterTemplate = [
    'return this.data.%%.value;',
].join('\n');

var setterTemplate = [
    'this.data.%%.value = value;',
    'var location = this.data.%%.location;'
].join('\n');


var GLSL_TO_SINGLE_SETTERS = {

    'float':    'uniform1f(location, value)',

    'vec2':     'uniform2f(location, value[0], value[1])',
    'vec3':     'uniform3f(location, value[0], value[1], value[2])',
    'vec4':     'uniform4f(location, value[0], value[1], value[2], value[3])',

    'int':      'uniform1i(location, value)',
    'ivec2':    'uniform2i(location, value[0], value[1])',
    'ivec3':    'uniform3i(location, value[0], value[1], value[2])',
    'ivec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',

    'bool':     'uniform1i(location, value)',
    'bvec2':    'uniform2i(location, value[0], value[1])',
    'bvec3':    'uniform3i(location, value[0], value[1], value[2])',
    'bvec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',

    'mat2':     'uniformMatrix2fv(location, false, value)',
    'mat3':     'uniformMatrix3fv(location, false, value)',
    'mat4':     'uniformMatrix4fv(location, false, value)',

    'sampler2D':'uniform1i(location, value)'
};

var GLSL_TO_ARRAY_SETTERS = {

    'float':    'uniform1fv(location, value)',

    'vec2':     'uniform2fv(location, value)',
    'vec3':     'uniform3fv(location, value)',
    'vec4':     'uniform4fv(location, value)',

    'int':      'uniform1iv(location, value)',
    'ivec2':    'uniform2iv(location, value)',
    'ivec3':    'uniform3iv(location, value)',
    'ivec4':    'uniform4iv(location, value)',

    'bool':     'uniform1iv(location, value)',
    'bvec2':    'uniform2iv(location, value)',
    'bvec3':    'uniform3iv(location, value)',
    'bvec4':    'uniform4iv(location, value)',

    'sampler2D':'uniform1iv(location, value)'
};

module.exports = generateUniformAccessObject;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String}
 * @return {Number}
 */
var mapSize = function(type) 
{ 
    return GLSL_TO_SIZE[type];
};


var GLSL_TO_SIZE = {
    'float':    1,
    'vec2':     2,
    'vec3':     3,
    'vec4':     4,

    'int':      1,
    'ivec2':    2,
    'ivec3':    3,
    'ivec4':    4,

    'bool':     1,
    'bvec2':    2,
    'bvec3':    3,
    'bvec4':    4,

    'mat2':     4,
    'mat3':     9,
    'mat4':     16,

    'sampler2D':  1
};

module.exports = mapSize;


/***/ }),
/* 56 */
/***/ (function(module, exports) {

/**
 * Sets the float precision on the shader. If the precision is already present this function will do nothing
 * @param {string} src       the shader source
 * @param {string} precision The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 *
 * @return {string} modified shader source
 */
var setPrecision = function(src, precision)
{
    if(src.substring(0, 9) !== 'precision')
    {
        return 'precision ' + precision + ' float;\n' + src;
    }

    return src;
};

module.exports = setPrecision;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.autoDetectRenderer = autoDetectRenderer;

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _CanvasRenderer = __webpack_require__(12);

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _WebGLRenderer = __webpack_require__(19);

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
 * the browser then this function will return a canvas renderer
 *
 * @memberof PIXI
 * @function autoDetectRenderer
 * @param {number} [width=800] - the width of the renderers view
 * @param {number} [height=600] - the height of the renderers view
 * @param {object} [options] - The optional renderer parameters
 * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
 * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
 * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
 * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
 *      need to call toDataUrl on the webgl context
 * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
 * @param {boolean} [noWebGL=false] - prevents selection of WebGL renderer, even if such is present
 * @return {PIXI.WebGLRenderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
 */
function autoDetectRenderer() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 800;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 600;
    var options = arguments[2];
    var noWebGL = arguments[3];

    if (!noWebGL && utils.isWebGLSupported()) {
        return new _WebGLRenderer2.default(width, height, options);
    }

    return new _CanvasRenderer2.default(width, height, options);
}
//# sourceMappingURL=autoDetectRenderer.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventemitter = __webpack_require__(9);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _TransformStatic = __webpack_require__(60);

var _TransformStatic2 = _interopRequireDefault(_TransformStatic);

var _Transform = __webpack_require__(59);

var _Transform2 = _interopRequireDefault(_Transform);

var _Bounds = __webpack_require__(27);

var _Bounds2 = _interopRequireDefault(_Bounds);

var _math = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// _tempDisplayObjectParent = new DisplayObject();

/**
 * The base class for all objects that are rendered on the screen.
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class
 * @extends EventEmitter
 * @mixes PIXI.interaction.interactiveTarget
 * @memberof PIXI
 */
var DisplayObject = function (_EventEmitter) {
    _inherits(DisplayObject, _EventEmitter);

    /**
     *
     */
    function DisplayObject() {
        _classCallCheck(this, DisplayObject);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        var TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;

        _this.tempDisplayObjectParent = null;

        // TODO: need to create Transform from factory
        /**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing
         *
         * @member {PIXI.TransformBase}
         */
        _this.transform = new TransformClass();

        /**
         * The opacity of the object.
         *
         * @member {number}
         */
        _this.alpha = 1;

        /**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually
         *
         * @member {boolean}
         */
        _this.visible = true;

        /**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually
         *
         * @member {boolean}
         */
        _this.renderable = true;

        /**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         * @readonly
         */
        _this.parent = null;

        /**
         * The multiplied alpha of the displayObject
         *
         * @member {number}
         * @readonly
         */
        _this.worldAlpha = 1;

        /**
         * The area the filter is applied to. This is used as more of an optimisation
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
         *
         * Also works as an interaction mask
         *
         * @member {PIXI.Rectangle}
         */
        _this.filterArea = null;

        _this._filters = null;
        _this._enabledFilters = null;

        /**
         * The bounds object, this is used to calculate and store the bounds of the displayObject
         *
         * @member {PIXI.Rectangle}
         * @private
         */
        _this._bounds = new _Bounds2.default();
        _this._boundsID = 0;
        _this._lastBoundsID = -1;
        _this._boundsRect = null;
        _this._localBoundsRect = null;

        /**
         * The original, cached mask of the object
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         * @private
         */
        _this._mask = null;

        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @private
         * @readonly
         */
        _this._destroyed = false;
        return _this;
    }

    /**
     * @private
     * @member {PIXI.DisplayObject}
     */


    /**
     * Updates the object transform for rendering
     *
     * TODO - Optimization pass!
     */
    DisplayObject.prototype.updateTransform = function updateTransform() {
        this.transform.updateTransform(this.parent.transform);
        // multiply the alphas..
        this.worldAlpha = this.alpha * this.parent.worldAlpha;

        this._bounds.updateID++;
    };

    /**
     * recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */


    DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() {
        if (this.parent) {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
        } else {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
    };

    /**
     * Retrieves the bounds of the displayObject as a rectangle object.
     *
     * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost
     * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation
     * @return {PIXI.Rectangle} the rectangular bounding area
     */


    DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {
        if (!skipUpdate) {
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.updateTransform();
                this.parent = null;
            } else {
                this._recursivePostUpdateTransform();
                this.updateTransform();
            }
        }

        if (this._boundsID !== this._lastBoundsID) {
            this.calculateBounds();
        }

        if (!rect) {
            if (!this._boundsRect) {
                this._boundsRect = new _math.Rectangle();
            }

            rect = this._boundsRect;
        }

        return this._bounds.getRectangle(rect);
    };

    /**
     * Retrieves the local bounds of the displayObject as a rectangle object
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation
     * @return {PIXI.Rectangle} the rectangular bounding area
     */


    DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {
        var transformRef = this.transform;
        var parentRef = this.parent;

        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;

        if (!rect) {
            if (!this._localBoundsRect) {
                this._localBoundsRect = new _math.Rectangle();
            }

            rect = this._localBoundsRect;
        }

        var bounds = this.getBounds(false, rect);

        this.parent = parentRef;
        this.transform = transformRef;

        return bounds;
    };

    /**
     * Calculates the global position of the display object
     *
     * @param {PIXI.Point} position - The world origin to calculate from
     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point)
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.Point} A point object representing the position of this object
     */


    DisplayObject.prototype.toGlobal = function toGlobal(position, point) {
        var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (!skipUpdate) {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            } else {
                this.displayObjectUpdateTransform();
            }
        }

        // don't need to update the lot
        return this.worldTransform.apply(position, point);
    };

    /**
     * Calculates the local position of the display object relative to another point
     *
     * @param {PIXI.Point} position - The world origin to calculate from
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from
     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point)
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.Point} A point object representing the position of this object
     */


    DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {
        if (from) {
            position = from.toGlobal(position, point, skipUpdate);
        }

        if (!skipUpdate) {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            } else {
                this.displayObjectUpdateTransform();
            }
        }

        // simply apply the matrix..
        return this.worldTransform.applyInverse(position, point);
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    DisplayObject.prototype.renderWebGL = function renderWebGL(renderer) // eslint-disable-line no-unused-vars
    {}
    // OVERWRITE;


    /**
     * Renders the object using the Canvas renderer
     *
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    ;

    DisplayObject.prototype.renderCanvas = function renderCanvas(renderer) // eslint-disable-line no-unused-vars
    {}
    // OVERWRITE;


    /**
     * Set the parent Container of this DisplayObject
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to
     * @return {PIXI.Container} The Container that this DisplayObject was added to
     */
    ;

    DisplayObject.prototype.setParent = function setParent(container) {
        if (!container || !container.addChild) {
            throw new Error('setParent: Argument must be a Container');
        }

        container.addChild(this);

        return container;
    };

    /**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */


    DisplayObject.prototype.setTransform = function setTransform() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;

        return this;
    };

    /**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy`.
     *
     */


    DisplayObject.prototype.destroy = function destroy() {
        this.removeAllListeners();
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.transform = null;

        this.parent = null;

        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;

        this.filterArea = null;

        this.interactive = false;
        this.interactiveChildren = false;

        this._destroyed = true;
    };

    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     *
     * @member {number}
     */


    _createClass(DisplayObject, [{
        key: '_tempDisplayObjectParent',
        get: function get() {
            if (this.tempDisplayObjectParent === null) {
                this.tempDisplayObjectParent = new DisplayObject();
            }

            return this.tempDisplayObjectParent;
        }
    }, {
        key: 'x',
        get: function get() {
            return this.position.x;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.position.x = value;
        }

        /**
         * The position of the displayObject on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         *
         * @member {number}
         */

    }, {
        key: 'y',
        get: function get() {
            return this.position.y;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.position.y = value;
        }

        /**
         * Current transform of the object based on world (parent) factors
         *
         * @member {PIXI.Matrix}
         * @readonly
         */

    }, {
        key: 'worldTransform',
        get: function get() {
            return this.transform.worldTransform;
        }

        /**
         * Current transform of the object based on local factors: position, scale, other stuff
         *
         * @member {PIXI.Matrix}
         * @readonly
         */

    }, {
        key: 'localTransform',
        get: function get() {
            return this.transform.localTransform;
        }

        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.Point|PIXI.ObservablePoint}
         */

    }, {
        key: 'position',
        get: function get() {
            return this.transform.position;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.position.copy(value);
        }

        /**
         * The scale factor of the object.
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.Point|PIXI.ObservablePoint}
         */

    }, {
        key: 'scale',
        get: function get() {
            return this.transform.scale;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.scale.copy(value);
        }

        /**
         * The pivot point of the displayObject that it rotates around
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.Point|PIXI.ObservablePoint}
         */

    }, {
        key: 'pivot',
        get: function get() {
            return this.transform.pivot;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.pivot.copy(value);
        }

        /**
         * The skew factor for the object in radians.
         * Assignment by value since pixi-v4.
         *
         * @member {PIXI.ObservablePoint}
         */

    }, {
        key: 'skew',
        get: function get() {
            return this.transform.skew;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.skew.copy(value);
        }

        /**
         * The rotation of the object in radians.
         *
         * @member {number}
         */

    }, {
        key: 'rotation',
        get: function get() {
            return this.transform.rotation;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.transform.rotation = value;
        }

        /**
         * Indicates if the object is globally visible.
         *
         * @member {boolean}
         * @readonly
         */

    }, {
        key: 'worldVisible',
        get: function get() {
            var item = this;

            do {
                if (!item.visible) {
                    return false;
                }

                item = item.parent;
            } while (item);

            return true;
        }

        /**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PIXI a regular mask must be a
         * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it
         * utilises shape clipping. To remove a mask, set this property to null.
         *
         * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         */

    }, {
        key: 'mask',
        get: function get() {
            return this._mask;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._mask) {
                this._mask.renderable = true;
            }

            this._mask = value;

            if (this._mask) {
                this._mask.renderable = false;
            }
        }

        /**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to 'null'
         *
         * @member {PIXI.Filter[]}
         */

    }, {
        key: 'filters',
        get: function get() {
            return this._filters && this._filters.slice();
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._filters = value && value.slice();
        }
    }]);

    return DisplayObject;
}(_eventemitter2.default);

// performance increase to avoid using call.. (10x faster)


exports.default = DisplayObject;
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
//# sourceMappingURL=DisplayObject.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(2);

var _TransformBase2 = __webpack_require__(28);

var _TransformBase3 = _interopRequireDefault(_TransformBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Generic class to deal with traditional 2D matrix transforms
 * local transformation is calculated from position,scale,skew and rotation
 *
 * @class
 * @extends PIXI.TransformBase
 * @memberof PIXI
 */
var Transform = function (_TransformBase) {
  _inherits(Transform, _TransformBase);

  /**
   *
   */
  function Transform() {
    _classCallCheck(this, Transform);

    /**
    * The coordinate of the object relative to the local coordinates of the parent.
    *
    * @member {PIXI.Point}
    */
    var _this = _possibleConstructorReturn(this, _TransformBase.call(this));

    _this.position = new _math.Point(0, 0);

    /**
     * The scale factor of the object.
     *
     * @member {PIXI.Point}
     */
    _this.scale = new _math.Point(1, 1);

    /**
     * The skew amount, on the x and y axis.
     *
     * @member {PIXI.ObservablePoint}
     */
    _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @member {PIXI.Point}
     */
    _this.pivot = new _math.Point(0, 0);

    /**
     * The rotation value of the object, in radians
     *
     * @member {Number}
     * @private
     */
    _this._rotation = 0;

    _this._cx = 1; // cos rotation + skewY;
    _this._sx = 0; // sin rotation + skewY;
    _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
    _this._sy = 1; // sin rotation + Math.PI/2 - skewX;
    return _this;
  }

  /**
   * Updates the skew values when the skew or rotation changes.
   *
   * @private
   */


  Transform.prototype.updateSkew = function updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew._y);
    this._sx = Math.sin(this._rotation + this.skew._y);
    this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
    this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
  };

  /**
   * Updates only local matrix
   */


  Transform.prototype.updateLocalTransform = function updateLocalTransform() {
    var lt = this.localTransform;

    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;

    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
  };

  /**
   * Updates the values of the object and applies the parent's transform.
   *
   * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
   */


  Transform.prototype.updateTransform = function updateTransform(parentTransform) {
    var lt = this.localTransform;

    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;

    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);

    // concat the parent matrix with the objects transform.
    var pt = parentTransform.worldTransform;
    var wt = this.worldTransform;

    wt.a = lt.a * pt.a + lt.b * pt.c;
    wt.b = lt.a * pt.b + lt.b * pt.d;
    wt.c = lt.c * pt.a + lt.d * pt.c;
    wt.d = lt.c * pt.b + lt.d * pt.d;
    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

    this._worldID++;
  };

  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   *
   * @param {PIXI.Matrix} matrix - The matrix to decompose
   */


  Transform.prototype.setFromMatrix = function setFromMatrix(matrix) {
    matrix.decompose(this);
  };

  /**
   * The rotation of the object in radians.
   *
   * @member {number}
   */


  _createClass(Transform, [{
    key: 'rotation',
    get: function get() {
      return this._rotation;
    },
    set: function set(value) // eslint-disable-line require-jsdoc
    {
      this._rotation = value;
      this.updateSkew();
    }
  }]);

  return Transform;
}(_TransformBase3.default);

exports.default = Transform;
//# sourceMappingURL=Transform.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(2);

var _TransformBase2 = __webpack_require__(28);

var _TransformBase3 = _interopRequireDefault(_TransformBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Transform that takes care about its versions
 *
 * @class
 * @extends PIXI.TransformBase
 * @memberof PIXI
 */
var TransformStatic = function (_TransformBase) {
    _inherits(TransformStatic, _TransformBase);

    /**
     *
     */
    function TransformStatic() {
        _classCallCheck(this, TransformStatic);

        /**
        * The coordinate of the object relative to the local coordinates of the parent.
        *
        * @member {PIXI.ObservablePoint}
        */
        var _this = _possibleConstructorReturn(this, _TransformBase.call(this));

        _this.position = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

        /**
         * The scale factor of the object.
         *
         * @member {PIXI.ObservablePoint}
         */
        _this.scale = new _math.ObservablePoint(_this.onChange, _this, 1, 1);

        /**
         * The pivot point of the displayObject that it rotates around
         *
         * @member {PIXI.ObservablePoint}
         */
        _this.pivot = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

        /**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */
        _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

        _this._rotation = 0;

        _this._cx = 1; // cos rotation + skewY;
        _this._sx = 0; // sin rotation + skewY;
        _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
        _this._sy = 1; // sin rotation + Math.PI/2 - skewX;

        _this._localID = 0;
        _this._currentLocalID = 0;
        return _this;
    }

    /**
     * Called when a value changes.
     *
     * @private
     */


    TransformStatic.prototype.onChange = function onChange() {
        this._localID++;
    };

    /**
     * Called when skew or rotation changes
     *
     * @private
     */


    TransformStatic.prototype.updateSkew = function updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew._y);
        this._sx = Math.sin(this._rotation + this.skew._y);
        this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
        this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2

        this._localID++;
    };

    /**
     * Updates only local matrix
     */


    TransformStatic.prototype.updateLocalTransform = function updateLocalTransform() {
        var lt = this.localTransform;

        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;

            lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
            lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
            this._currentLocalID = this._localID;

            // force an update..
            this._parentID = -1;
        }
    };

    /**
     * Updates the values of the object and applies the parent's transform.
     *
     * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
     */


    TransformStatic.prototype.updateTransform = function updateTransform(parentTransform) {
        var lt = this.localTransform;

        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;

            lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
            lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
            this._currentLocalID = this._localID;

            // force an update..
            this._parentID = -1;
        }

        if (this._parentID !== parentTransform._worldID) {
            // concat the parent matrix with the objects transform.
            var pt = parentTransform.worldTransform;
            var wt = this.worldTransform;

            wt.a = lt.a * pt.a + lt.b * pt.c;
            wt.b = lt.a * pt.b + lt.b * pt.d;
            wt.c = lt.c * pt.a + lt.d * pt.c;
            wt.d = lt.c * pt.b + lt.d * pt.d;
            wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
            wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

            this._parentID = parentTransform._worldID;

            // update the id of the transform..
            this._worldID++;
        }
    };

    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */


    TransformStatic.prototype.setFromMatrix = function setFromMatrix(matrix) {
        matrix.decompose(this);
        this._localID++;
    };

    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */


    _createClass(TransformStatic, [{
        key: 'rotation',
        get: function get() {
            return this._rotation;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this._rotation = value;
            this.updateSkew();
        }
    }]);

    return TransformStatic;
}(_TransformBase3.default);

exports.default = TransformStatic;
//# sourceMappingURL=TransformStatic.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A GraphicsData object.
 *
 * @class
 * @memberof PIXI
 */
var GraphicsData = function () {
  /**
   *
   * @param {number} lineWidth - the width of the line to draw
   * @param {number} lineColor - the color of the line to draw
   * @param {number} lineAlpha - the alpha of the line to draw
   * @param {number} fillColor - the color of the fill
   * @param {number} fillAlpha - the alpha of the fill
   * @param {boolean} fill - whether or not the shape is filled with a colour
   * @param {boolean} nativeLines - the method for drawing lines
   * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Polygon} shape - The shape object to draw.
   */
  function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, nativeLines, shape) {
    _classCallCheck(this, GraphicsData);

    /**
     * @member {number} the width of the line to draw
     */
    this.lineWidth = lineWidth;
    /**
     * @member {boolean} if true the liens will be draw using LINES instead of TRIANGLE_STRIP
     */
    this.nativeLines = nativeLines;

    /**
     * @member {number} the color of the line to draw
     */
    this.lineColor = lineColor;

    /**
     * @member {number} the alpha of the line to draw
     */
    this.lineAlpha = lineAlpha;

    /**
     * @member {number} cached tint of the line to draw
     */
    this._lineTint = lineColor;

    /**
     * @member {number} the color of the fill
     */
    this.fillColor = fillColor;

    /**
     * @member {number} the alpha of the fill
     */
    this.fillAlpha = fillAlpha;

    /**
     * @member {number} cached tint of the fill
     */
    this._fillTint = fillColor;

    /**
     * @member {boolean} whether or not the shape is filled with a colour
     */
    this.fill = fill;

    this.holes = [];

    /**
     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} The shape object to draw.
     */
    this.shape = shape;

    /**
     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,
     */
    this.type = shape.type;
  }

  /**
   * Creates a new GraphicsData object with the same values as this one.
   *
   * @return {PIXI.GraphicsData} Cloned GraphicsData object
   */


  GraphicsData.prototype.clone = function clone() {
    return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.nativeLines, this.shape);
  };

  /**
   * Adds a hole to the shape.
   *
   * @param {PIXI.Rectangle|PIXI.Circle} shape - The shape of the hole.
   */


  GraphicsData.prototype.addHole = function addHole(shape) {
    this.holes.push(shape);
  };

  /**
   * Destroys the Graphics data.
   */


  GraphicsData.prototype.destroy = function destroy() {
    this.shape = null;
    this.holes = null;
  };

  return GraphicsData;
}();

exports.default = GraphicsData;
//# sourceMappingURL=GraphicsData.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.autoDetectRenderer = exports.Application = exports.Filter = exports.SpriteMaskFilter = exports.Quad = exports.RenderTarget = exports.ObjectRenderer = exports.WebGLManager = exports.Shader = exports.CanvasRenderTarget = exports.TextureUvs = exports.VideoBaseTexture = exports.BaseRenderTexture = exports.RenderTexture = exports.BaseTexture = exports.Texture = exports.Spritesheet = exports.CanvasGraphicsRenderer = exports.GraphicsRenderer = exports.GraphicsData = exports.Graphics = exports.TextStyle = exports.Text = exports.SpriteRenderer = exports.CanvasTinter = exports.CanvasSpriteRenderer = exports.Sprite = exports.TransformBase = exports.TransformStatic = exports.Transform = exports.Container = exports.DisplayObject = exports.Bounds = exports.glCore = exports.WebGLRenderer = exports.CanvasRenderer = exports.ticker = exports.utils = exports.settings = undefined;

var _const = __webpack_require__(0);

Object.keys(_const).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _const[key];
    }
  });
});

var _math = __webpack_require__(2);

Object.keys(_math).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _math[key];
    }
  });
});

var _pixiGlCore = __webpack_require__(4);

Object.defineProperty(exports, 'glCore', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_pixiGlCore).default;
  }
});

var _Bounds = __webpack_require__(27);

Object.defineProperty(exports, 'Bounds', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Bounds).default;
  }
});

var _DisplayObject = __webpack_require__(58);

Object.defineProperty(exports, 'DisplayObject', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DisplayObject).default;
  }
});

var _Container = __webpack_require__(11);

Object.defineProperty(exports, 'Container', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Container).default;
  }
});

var _Transform = __webpack_require__(59);

Object.defineProperty(exports, 'Transform', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Transform).default;
  }
});

var _TransformStatic = __webpack_require__(60);

Object.defineProperty(exports, 'TransformStatic', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TransformStatic).default;
  }
});

var _TransformBase = __webpack_require__(28);

Object.defineProperty(exports, 'TransformBase', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TransformBase).default;
  }
});

var _Sprite = __webpack_require__(31);

Object.defineProperty(exports, 'Sprite', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Sprite).default;
  }
});

var _CanvasSpriteRenderer = __webpack_require__(147);

Object.defineProperty(exports, 'CanvasSpriteRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasSpriteRenderer).default;
  }
});

var _CanvasTinter = __webpack_require__(71);

Object.defineProperty(exports, 'CanvasTinter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasTinter).default;
  }
});

var _SpriteRenderer = __webpack_require__(149);

Object.defineProperty(exports, 'SpriteRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SpriteRenderer).default;
  }
});

var _Text = __webpack_require__(151);

Object.defineProperty(exports, 'Text', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Text).default;
  }
});

var _TextStyle = __webpack_require__(72);

Object.defineProperty(exports, 'TextStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TextStyle).default;
  }
});

var _Graphics = __webpack_require__(118);

Object.defineProperty(exports, 'Graphics', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Graphics).default;
  }
});

var _GraphicsData = __webpack_require__(61);

Object.defineProperty(exports, 'GraphicsData', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_GraphicsData).default;
  }
});

var _GraphicsRenderer = __webpack_require__(121);

Object.defineProperty(exports, 'GraphicsRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_GraphicsRenderer).default;
  }
});

var _CanvasGraphicsRenderer = __webpack_require__(119);

Object.defineProperty(exports, 'CanvasGraphicsRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasGraphicsRenderer).default;
  }
});

var _Spritesheet = __webpack_require__(152);

Object.defineProperty(exports, 'Spritesheet', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Spritesheet).default;
  }
});

var _Texture = __webpack_require__(15);

Object.defineProperty(exports, 'Texture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Texture).default;
  }
});

var _BaseTexture = __webpack_require__(14);

Object.defineProperty(exports, 'BaseTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BaseTexture).default;
  }
});

var _RenderTexture = __webpack_require__(32);

Object.defineProperty(exports, 'RenderTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RenderTexture).default;
  }
});

var _BaseRenderTexture = __webpack_require__(73);

Object.defineProperty(exports, 'BaseRenderTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BaseRenderTexture).default;
  }
});

var _VideoBaseTexture = __webpack_require__(75);

Object.defineProperty(exports, 'VideoBaseTexture', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_VideoBaseTexture).default;
  }
});

var _TextureUvs = __webpack_require__(74);

Object.defineProperty(exports, 'TextureUvs', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TextureUvs).default;
  }
});

var _CanvasRenderTarget = __webpack_require__(66);

Object.defineProperty(exports, 'CanvasRenderTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasRenderTarget).default;
  }
});

var _Shader = __webpack_require__(17);

Object.defineProperty(exports, 'Shader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Shader).default;
  }
});

var _WebGLManager = __webpack_require__(13);

Object.defineProperty(exports, 'WebGLManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_WebGLManager).default;
  }
});

var _ObjectRenderer = __webpack_require__(20);

Object.defineProperty(exports, 'ObjectRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ObjectRenderer).default;
  }
});

var _RenderTarget = __webpack_require__(21);

Object.defineProperty(exports, 'RenderTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RenderTarget).default;
  }
});

var _Quad = __webpack_require__(70);

Object.defineProperty(exports, 'Quad', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Quad).default;
  }
});

var _SpriteMaskFilter = __webpack_require__(69);

Object.defineProperty(exports, 'SpriteMaskFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SpriteMaskFilter).default;
  }
});

var _Filter = __webpack_require__(68);

Object.defineProperty(exports, 'Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Filter).default;
  }
});

var _Application = __webpack_require__(117);

Object.defineProperty(exports, 'Application', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Application).default;
  }
});

var _autoDetectRenderer = __webpack_require__(57);

Object.defineProperty(exports, 'autoDetectRenderer', {
  enumerable: true,
  get: function get() {
    return _autoDetectRenderer.autoDetectRenderer;
  }
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _ticker = __webpack_require__(33);

var ticker = _interopRequireWildcard(_ticker);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _CanvasRenderer = __webpack_require__(12);

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _WebGLRenderer = __webpack_require__(19);

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.settings = _settings2.default;
exports.utils = utils;
exports.ticker = ticker;
exports.CanvasRenderer = _CanvasRenderer2.default;
exports.WebGLRenderer = _WebGLRenderer2.default; /**
                                                  * @namespace PIXI
                                                  */
//# sourceMappingURL=index.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Matrix = __webpack_require__(64);

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16

var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var tempMatrices = [];

var mul = [];

function signum(x) {
    if (x < 0) {
        return -1;
    }
    if (x > 0) {
        return 1;
    }

    return 0;
}

function init() {
    for (var i = 0; i < 16; i++) {
        var row = [];

        mul.push(row);

        for (var j = 0; j < 16; j++) {
            var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
            var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
            var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
            var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);

            for (var k = 0; k < 16; k++) {
                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
                    row.push(k);
                    break;
                }
            }
        }
    }

    for (var _i = 0; _i < 16; _i++) {
        var mat = new _Matrix2.default();

        mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);
        tempMatrices.push(mat);
    }
}

init();

/**
 * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},
 * D8 is the same but with diagonals. Used for texture rotations.
 *
 * Vector xX(i), xY(i) is U-axis of sprite with rotation i
 * Vector yY(i), yY(i) is V-axis of sprite with rotation i
 * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)
 * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)
 * This is the small part of gameofbombs.com portal system. It works.
 *
 * @author Ivan @ivanpopelyshev
 * @class
 * @memberof PIXI
 */
var GroupD8 = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MIRROR_HORIZONTAL: 12,
    uX: function uX(ind) {
        return ux[ind];
    },
    uY: function uY(ind) {
        return uy[ind];
    },
    vX: function vX(ind) {
        return vx[ind];
    },
    vY: function vY(ind) {
        return vy[ind];
    },
    inv: function inv(rotation) {
        if (rotation & 8) {
            return rotation & 15;
        }

        return -rotation & 7;
    },
    add: function add(rotationSecond, rotationFirst) {
        return mul[rotationSecond][rotationFirst];
    },
    sub: function sub(rotationSecond, rotationFirst) {
        return mul[rotationSecond][GroupD8.inv(rotationFirst)];
    },

    /**
     * Adds 180 degrees to rotation. Commutative operation.
     *
     * @memberof PIXI.GroupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} rotated number
     */
    rotate180: function rotate180(rotation) {
        return rotation ^ 4;
    },

    /**
     * I dont know why sometimes width and heights needs to be swapped. We'll fix it later.
     *
     * @memberof PIXI.GroupD8
     * @param {number} rotation - The number to check.
     * @returns {boolean} Whether or not the width/height should be swapped.
     */
    isSwapWidthHeight: function isSwapWidthHeight(rotation) {
        return (rotation & 3) === 2;
    },

    /**
     * @memberof PIXI.GroupD8
     * @param {number} dx - TODO
     * @param {number} dy - TODO
     *
     * @return {number} TODO
     */
    byDirection: function byDirection(dx, dy) {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return GroupD8.S;
            }

            return GroupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return GroupD8.E;
            }

            return GroupD8.W;
        } else if (dy > 0) {
            if (dx > 0) {
                return GroupD8.SE;
            }

            return GroupD8.SW;
        } else if (dx > 0) {
            return GroupD8.NE;
        }

        return GroupD8.NW;
    },

    /**
     * Helps sprite to compensate texture packer rotation.
     *
     * @memberof PIXI.GroupD8
     * @param {PIXI.Matrix} matrix - sprite world matrix
     * @param {number} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */
    matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) {
        var tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        // Packer used "rotation", we use "inv(rotation)"
        var mat = tempMatrices[GroupD8.inv(rotation)];

        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
};

exports.default = GroupD8;
//# sourceMappingURL=GroupD8.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Point = __webpack_require__(29);

var _Point2 = _interopRequireDefault(_Point);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The pixi Matrix class as an object, which makes it a lot faster,
 * here is a representation of it :
 * | a | b | tx|
 * | c | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 */
var Matrix = function () {
    /**
     * @param {number} [a=1] - x scale
     * @param {number} [b=0] - y skew
     * @param {number} [c=0] - x skew
     * @param {number} [d=1] - y scale
     * @param {number} [tx=0] - x translation
     * @param {number} [ty=0] - y translation
     */
    function Matrix() {
        var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        var tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

        _classCallCheck(this, Matrix);

        /**
         * @member {number}
         * @default 1
         */
        this.a = a;

        /**
         * @member {number}
         * @default 0
         */
        this.b = b;

        /**
         * @member {number}
         * @default 0
         */
        this.c = c;

        /**
         * @member {number}
         * @default 1
         */
        this.d = d;

        /**
         * @member {number}
         * @default 0
         */
        this.tx = tx;

        /**
         * @member {number}
         * @default 0
         */
        this.ty = ty;

        this.array = null;
    }

    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */


    Matrix.prototype.fromArray = function fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    };

    /**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.set = function set(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;

        return this;
    };

    /**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */


    Matrix.prototype.toArray = function toArray(transpose, out) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }

        var array = out || this.array;

        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }

        return array;
    };

    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */


    Matrix.prototype.apply = function apply(pos, newPos) {
        newPos = newPos || new _Point2.default();

        var x = pos.x;
        var y = pos.y;

        newPos.x = this.a * x + this.c * y + this.tx;
        newPos.y = this.b * x + this.d * y + this.ty;

        return newPos;
    };

    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */


    Matrix.prototype.applyInverse = function applyInverse(pos, newPos) {
        newPos = newPos || new _Point2.default();

        var id = 1 / (this.a * this.d + this.c * -this.b);

        var x = pos.x;
        var y = pos.y;

        newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
        newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

        return newPos;
    };

    /**
     * Translates the matrix on the x and y.
     *
     * @param {number} x How much to translate x by
     * @param {number} y How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.translate = function translate(x, y) {
        this.tx += x;
        this.ty += y;

        return this;
    };

    /**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x The amount to scale horizontally
     * @param {number} y The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.scale = function scale(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;

        return this;
    };

    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.rotate = function rotate(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);

        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;

        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;

        return this;
    };

    /**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.append = function append(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;

        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;

        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

        return this;
    };

    /**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.setTransform = function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        var sr = Math.sin(rotation);
        var cr = Math.cos(rotation);
        var cy = Math.cos(skewY);
        var sy = Math.sin(skewY);
        var nsx = -Math.sin(skewX);
        var cx = Math.cos(skewX);

        var a = cr * scaleX;
        var b = sr * scaleX;
        var c = -sr * scaleY;
        var d = cr * scaleY;

        this.a = cy * a + sy * c;
        this.b = cy * b + sy * d;
        this.c = nsx * a + cx * c;
        this.d = nsx * b + cx * d;

        this.tx = x + (pivotX * a + pivotY * c);
        this.ty = y + (pivotX * b + pivotY * d);

        return this;
    };

    /**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.prepend = function prepend(matrix) {
        var tx1 = this.tx;

        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            var a1 = this.a;
            var c1 = this.c;

            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
        }

        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;

        return this;
    };

    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform|PIXI.TransformStatic} transform - The transform to apply the properties to.
     * @return {PIXI.Transform|PIXI.TransformStatic} The transform with the newly applied properties
     */


    Matrix.prototype.decompose = function decompose(transform) {
        // sort out rotation / skew..
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;

        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);

        var delta = Math.abs(skewX + skewY);

        if (delta < 0.00001) {
            transform.rotation = skewY;

            if (a < 0 && d >= 0) {
                transform.rotation += transform.rotation <= 0 ? Math.PI : -Math.PI;
            }

            transform.skew.x = transform.skew.y = 0;
        } else {
            transform.skew.x = skewX;
            transform.skew.y = skewY;
        }

        // next set scale
        transform.scale.x = Math.sqrt(a * a + b * b);
        transform.scale.y = Math.sqrt(c * c + d * d);

        // next set position
        transform.position.x = this.tx;
        transform.position.y = this.ty;

        return transform;
    };

    /**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.invert = function invert() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;

        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;

        return this;
    };

    /**
     * Resets this Matix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */


    Matrix.prototype.identity = function identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;

        return this;
    };

    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */


    Matrix.prototype.clone = function clone() {
        var matrix = new Matrix();

        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;

        return matrix;
    };

    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */


    Matrix.prototype.copy = function copy(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;

        return matrix;
    };

    /**
     * A default (identity) matrix
     *
     * @static
     * @const
     */


    _createClass(Matrix, null, [{
        key: 'IDENTITY',
        get: function get() {
            return new Matrix();
        }

        /**
         * A temp matrix
         *
         * @static
         * @const
         */

    }, {
        key: 'TEMP_MATRIX',
        get: function get() {
            return new Matrix();
        }
    }]);

    return Matrix;
}();

exports.default = Matrix;
//# sourceMappingURL=Matrix.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(1);

var _math = __webpack_require__(2);

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _Container = __webpack_require__(11);

var _Container2 = _interopRequireDefault(_Container);

var _RenderTexture = __webpack_require__(32);

var _RenderTexture2 = _interopRequireDefault(_RenderTexture);

var _eventemitter = __webpack_require__(9);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var tempMatrix = new _math.Matrix();

/**
 * The SystemRenderer is the base for a Pixi Renderer. It is extended by the {@link PIXI.CanvasRenderer}
 * and {@link PIXI.WebGLRenderer} which can be used for rendering a Pixi scene.
 *
 * @abstract
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */

var SystemRenderer = function (_EventEmitter) {
  _inherits(SystemRenderer, _EventEmitter);

  /**
   * @param {string} system - The name of the system this renderer is for.
   * @param {number} [screenWidth=800] - the width of the screen
   * @param {number} [screenHeight=600] - the height of the screen
   * @param {object} [options] - The optional renderer parameters
   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
   *  resolution of the renderer retina would be 2.
   * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear the canvas or
   *      not before the new render pass.
   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
   *  (shown if not transparent).
   * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when rendering,
   *  stopping pixel interpolation.
   */
  function SystemRenderer(system, screenWidth, screenHeight, options) {
    _classCallCheck(this, SystemRenderer);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    (0, _utils.sayHello)(system);

    // prepare options
    if (options) {
      for (var i in _settings2.default.RENDER_OPTIONS) {
        if (typeof options[i] === 'undefined') {
          options[i] = _settings2.default.RENDER_OPTIONS[i];
        }
      }
    } else {
      options = _settings2.default.RENDER_OPTIONS;
    }

    /**
     * The type of the renderer.
     *
     * @member {number}
     * @default PIXI.RENDERER_TYPE.UNKNOWN
     * @see PIXI.RENDERER_TYPE
     */
    _this.type = _const.RENDERER_TYPE.UNKNOWN;

    /**
     * Measurements of the screen. (0, 0, screenWidth, screenHeight)
     *
     * Its safe to use as filterArea or hitArea for whole stage
     *
     * @member {PIXI.Rectangle}
     */
    _this.screen = new _math.Rectangle(0, 0, screenWidth || 800, screenHeight || 600);

    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    _this.view = options.view || document.createElement('canvas');

    /**
     * The resolution / device pixel ratio of the renderer
     *
     * @member {number}
     * @default 1
     */
    _this.resolution = options.resolution || _settings2.default.RESOLUTION;

    /**
     * Whether the render view is transparent
     *
     * @member {boolean}
     */
    _this.transparent = options.transparent;

    /**
     * Whether css dimensions of canvas view should be resized to screen dimensions automatically
     *
     * @member {boolean}
     */
    _this.autoResize = options.autoResize || false;

    /**
     * Tracks the blend modes useful for this renderer.
     *
     * @member {object<string, mixed>}
     */
    _this.blendModes = null;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of
     * the stencil buffer is retained after rendering.
     *
     * @member {boolean}
     */
    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every
     * frame to set the canvas background color. If the scene is transparent Pixi will use clearRect
     * to clear the canvas every frame. Disable this by setting this to false. For example if
     * your game has a canvas filling background image you often don't need this set.
     *
     * @member {boolean}
     * @default
     */
    _this.clearBeforeRender = options.clearBeforeRender;

    /**
     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Handy for crisp pixel art and speed on legacy devices.
     *
     * @member {boolean}
     */
    _this.roundPixels = options.roundPixels;

    /**
     * The background color as a number.
     *
     * @member {number}
     * @private
     */
    _this._backgroundColor = 0x000000;

    /**
     * The background color as an [R, G, B] array.
     *
     * @member {number[]}
     * @private
     */
    _this._backgroundColorRgba = [0, 0, 0, 0];

    /**
     * The background color as a string.
     *
     * @member {string}
     * @private
     */
    _this._backgroundColorString = '#000000';

    _this.backgroundColor = options.backgroundColor || _this._backgroundColor; // run bg color setter

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    _this._tempDisplayObjectParent = new _Container2.default();

    /**
     * The last root object that the renderer tried to render.
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    _this._lastObjectRendered = _this._tempDisplayObjectParent;
    return _this;
  }

  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal
   *
   * @member {number}
   * @readonly
   * @default 800
   */


  /**
   * Resizes the screen and canvas to the specified width and height
   * Canvas dimensions are multiplied by resolution
   *
   * @param {number} screenWidth - the new width of the screen
   * @param {number} screenHeight - the new height of the screen
   */
  SystemRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;

    this.view.width = screenWidth * this.resolution;
    this.view.height = screenHeight * this.resolution;

    if (this.autoResize) {
      this.view.style.width = screenWidth + 'px';
      this.view.style.height = screenHeight + 'px';
    }
  };

  /**
   * Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   *
   * @param {PIXI.DisplayObject} displayObject - The displayObject the object will be generated from
   * @param {number} scaleMode - Should be one of the scaleMode consts
   * @param {number} resolution - The resolution / device pixel ratio of the texture being generated
   * @return {PIXI.Texture} a texture of the graphics object
   */


  SystemRenderer.prototype.generateTexture = function generateTexture(displayObject, scaleMode, resolution) {
    var bounds = displayObject.getLocalBounds();

    var renderTexture = _RenderTexture2.default.create(bounds.width | 0, bounds.height | 0, scaleMode, resolution);

    tempMatrix.tx = -bounds.x;
    tempMatrix.ty = -bounds.y;

    this.render(displayObject, renderTexture, false, tempMatrix, true);

    return renderTexture;
  };

  /**
   * Removes everything from the renderer and optionally removes the Canvas DOM element.
   *
   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
   */


  SystemRenderer.prototype.destroy = function destroy(removeView) {
    if (removeView && this.view.parentNode) {
      this.view.parentNode.removeChild(this.view);
    }

    this.type = _const.RENDERER_TYPE.UNKNOWN;

    this.view = null;

    this.screen = null;

    this.resolution = 0;

    this.transparent = false;

    this.autoResize = false;

    this.blendModes = null;

    this.preserveDrawingBuffer = false;
    this.clearBeforeRender = false;

    this.roundPixels = false;

    this._backgroundColor = 0;
    this._backgroundColorRgba = null;
    this._backgroundColorString = null;

    this.backgroundColor = 0;
    this._tempDisplayObjectParent = null;
    this._lastObjectRendered = null;
  };

  /**
   * The background color to fill if not transparent
   *
   * @member {number}
   */


  _createClass(SystemRenderer, [{
    key: 'width',
    get: function get() {
      return this.view.width;
    }

    /**
     * Same as view.height, actual number of pixels in the canvas by vertical
     *
     * @member {number}
     * @readonly
     * @default 600
     */

  }, {
    key: 'height',
    get: function get() {
      return this.view.height;
    }
  }, {
    key: 'backgroundColor',
    get: function get() {
      return this._backgroundColor;
    },
    set: function set(value) // eslint-disable-line require-jsdoc
    {
      this._backgroundColor = value;
      this._backgroundColorString = (0, _utils.hex2string)(value);
      (0, _utils.hex2rgb)(value, this._backgroundColorRgba);
    }
  }]);

  return SystemRenderer;
}(_eventemitter2.default);

exports.default = SystemRenderer;
//# sourceMappingURL=SystemRenderer.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Creates a Canvas element of the given size.
 *
 * @class
 * @memberof PIXI
 */
var CanvasRenderTarget = function () {
  /**
   * @param {number} width - the width for the newly created canvas
   * @param {number} height - the height for the newly created canvas
   * @param {number} [resolution=1] - The resolution / device pixel ratio of the canvas
   */
  function CanvasRenderTarget(width, height, resolution) {
    _classCallCheck(this, CanvasRenderTarget);

    /**
     * The Canvas object that belongs to this CanvasRenderTarget.
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.canvas.getContext('2d');

    this.resolution = resolution || _settings2.default.RESOLUTION;

    this.resize(width, height);
  }

  /**
   * Clears the canvas that was created by the CanvasRenderTarget class.
   *
   * @private
   */


  CanvasRenderTarget.prototype.clear = function clear() {
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };

  /**
   * Resizes the canvas to the specified width and height.
   *
   * @param {number} width - the new width of the canvas
   * @param {number} height - the new height of the canvas
   */


  CanvasRenderTarget.prototype.resize = function resize(width, height) {
    this.canvas.width = width * this.resolution;
    this.canvas.height = height * this.resolution;
  };

  /**
   * Destroys this canvas.
   *
   */


  CanvasRenderTarget.prototype.destroy = function destroy() {
    this.context = null;
    this.canvas = null;
  };

  /**
   * The width of the canvas buffer in pixels.
   *
   * @member {number}
   */


  _createClass(CanvasRenderTarget, [{
    key: 'width',
    get: function get() {
      return this.canvas.width;
    },
    set: function set(val) // eslint-disable-line require-jsdoc
    {
      this.canvas.width = val;
    }

    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     */

  }, {
    key: 'height',
    get: function get() {
      return this.canvas.height;
    },
    set: function set(val) // eslint-disable-line require-jsdoc
    {
      this.canvas.height = val;
    }
  }]);

  return CanvasRenderTarget;
}();

exports.default = CanvasRenderTarget;
//# sourceMappingURL=CanvasRenderTarget.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = canUseNewCanvasBlendModes;
/**
 * Creates a little colored canvas
 *
 * @ignore
 * @param {string} color - The color to make the canvas
 * @return {canvas} a small canvas element
 */
function createColoredCanvas(color) {
    var canvas = document.createElement('canvas');

    canvas.width = 6;
    canvas.height = 1;

    var context = canvas.getContext('2d');

    context.fillStyle = color;
    context.fillRect(0, 0, 6, 1);

    return canvas;
}

/**
 * Checks whether the Canvas BlendModes are supported by the current browser
 *
 * @return {boolean} whether they are supported
 */
function canUseNewCanvasBlendModes() {
    if (typeof document === 'undefined') {
        return false;
    }

    var magenta = createColoredCanvas('#ff00ff');
    var yellow = createColoredCanvas('#ffff00');

    var canvas = document.createElement('canvas');

    canvas.width = 6;
    canvas.height = 1;

    var context = canvas.getContext('2d');

    context.globalCompositeOperation = 'multiply';
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);

    var imageData = context.getImageData(2, 0, 1, 1);

    if (!imageData) {
        return false;
    }

    var data = imageData.data;

    return data[0] === 255 && data[1] === 0 && data[2] === 0;
}
//# sourceMappingURL=canUseNewCanvasBlendModes.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extractUniformsFromSrc = __webpack_require__(138);

var _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);

var _utils = __webpack_require__(1);

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SOURCE_KEY_MAP = {};

// let math = require('../../../math');
/**
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 */

var Filter = function () {
  /**
   * @param {string} [vertexSrc] - The source of the vertex shader.
   * @param {string} [fragmentSrc] - The source of the fragment shader.
   * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
   */
  function Filter(vertexSrc, fragmentSrc, uniforms) {
    _classCallCheck(this, Filter);

    /**
     * The vertex shader.
     *
     * @member {string}
     */
    this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;

    /**
     * The fragment shader.
     *
     * @member {string}
     */
    this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;

    this.blendMode = _const.BLEND_MODES.NORMAL;

    this.uniformData = uniforms || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');

    /**
     * An object containing the current values of custom uniforms.
     * @example <caption>Updating the value of a custom uniform</caption>
     * filter.uniforms.time = performance.now();
     *
     * @member {object}
     */
    this.uniforms = {};

    for (var i in this.uniformData) {
      this.uniforms[i] = this.uniformData[i].value;
    }

    // this is where we store shader references..
    // TODO we could cache this!
    this.glShaders = {};

    // used for cacheing.. sure there is a better way!
    if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) {
      SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)();
    }

    this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];

    /**
     * The padding of the filter. Some filters require extra space to breath such as a blur.
     * Increasing this will add extra width and height to the bounds of the object that the
     * filter is applied to.
     *
     * @member {number}
     */
    this.padding = 4;

    /**
     * The resolution of the filter. Setting this to be lower will lower the quality but
     * increase the performance of the filter.
     *
     * @member {number}
     */
    this.resolution = _settings2.default.RESOLUTION;

    /**
     * If enabled is true the filter is applied, if false it will not.
     *
     * @member {boolean}
     */
    this.enabled = true;
  }

  /**
   * Applies the filter
   *
   * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
   * @param {PIXI.RenderTarget} input - The input render target.
   * @param {PIXI.RenderTarget} output - The target to output to.
   * @param {boolean} clear - Should the output be cleared before rendering to it
   * @param {object} [currentState] - It's current state of filter.
   *        There are some useful properties in the currentState :
   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
   */


  Filter.prototype.apply = function apply(filterManager, input, output, clear, currentState) // eslint-disable-line no-unused-vars
  {
    // --- //
    //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );

    // do as you please!

    filterManager.applyFilter(this, input, output, clear);

    // or just do a regular render..
  };

  /**
   * The default vertex shader source
   *
   * @static
   * @constant
   */


  _createClass(Filter, null, [{
    key: 'defaultVertexSrc',
    get: function get() {
      return ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 projectionMatrix;', 'uniform mat3 filterMatrix;', 'varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;', '   vTextureCoord = aTextureCoord ;', '}'].join('\n');
    }

    /**
     * The default fragment shader source
     *
     * @static
     * @constant
     */

  }, {
    key: 'defaultFragmentSrc',
    get: function get() {
      return ['varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'uniform sampler2D uSampler;', 'uniform sampler2D filterSampler;', 'void main(void){', '   vec4 masky = texture2D(filterSampler, vFilterCoord);', '   vec4 sample = texture2D(uSampler, vTextureCoord);', '   vec4 color;', '   if(mod(vFilterCoord.x, 1.0) > 0.5)', '   {', '     color = vec4(1.0, 0.0, 0.0, 1.0);', '   }', '   else', '   {', '     color = vec4(0.0, 1.0, 0.0, 1.0);', '   }',
      // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',
      '   gl_FragColor = mix(sample, masky, 0.5);', '   gl_FragColor *= sample.a;', '}'].join('\n');
    }
  }]);

  return Filter;
}();

exports.default = Filter;
//# sourceMappingURL=Filter.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Filter2 = __webpack_require__(68);

var _Filter3 = _interopRequireDefault(_Filter2);

var _math = __webpack_require__(2);

var _path = __webpack_require__(47);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The SpriteMaskFilter class
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI
 */
var SpriteMaskFilter = function (_Filter) {
    _inherits(SpriteMaskFilter, _Filter);

    /**
     * @param {PIXI.Sprite} sprite - the target sprite
     */
    function SpriteMaskFilter(sprite) {
        _classCallCheck(this, SpriteMaskFilter);

        var maskMatrix = new _math.Matrix();

        var _this = _possibleConstructorReturn(this, _Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n\n    original *= (masky.r * masky.a * alpha * clip);\n\n    gl_FragColor = original;\n}\n'));

        sprite.renderable = false;

        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        return _this;
    }

    /**
     * Applies the filter
     *
     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTarget} input - The input render target.
     * @param {PIXI.RenderTarget} output - The target to output to.
     */


    SpriteMaskFilter.prototype.apply = function apply(filterManager, input, output) {
        var maskSprite = this.maskSprite;

        this.uniforms.mask = maskSprite._texture;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite);
        this.uniforms.alpha = maskSprite.worldAlpha;

        filterManager.applyFilter(this, input, output);
    };

    return SpriteMaskFilter;
}(_Filter3.default);

exports.default = SpriteMaskFilter;
//# sourceMappingURL=SpriteMaskFilter.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pixiGlCore = __webpack_require__(4);

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _createIndicesForQuads = __webpack_require__(76);

var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Helper class to create a quad
 *
 * @class
 * @memberof PIXI
 */
var Quad = function () {
  /**
   * @param {WebGLRenderingContext} gl - The gl context for this quad to use.
   * @param {object} state - TODO: Description
   */
  function Quad(gl, state) {
    _classCallCheck(this, Quad);

    /*
     * the current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);

    /**
     * The Uvs of the quad
     *
     * @member {Float32Array}
     */
    this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);

    this.interleaved = new Float32Array(8 * 2);

    for (var i = 0; i < 4; i++) {
      this.interleaved[i * 4] = this.vertices[i * 2];
      this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
      this.interleaved[i * 4 + 2] = this.uvs[i * 2];
      this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
    }

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = (0, _createIndicesForQuads2.default)(1);

    /*
     * @member {glCore.GLBuffer} The vertex buffer
     */
    this.vertexBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.interleaved, gl.STATIC_DRAW);

    /*
     * @member {glCore.GLBuffer} The index buffer
     */
    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

    /*
     * @member {glCore.VertexArrayObject} The index buffer
     */
    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, state);
  }

  /**
   * Initialises the vaos and uses the shader.
   *
   * @param {PIXI.Shader} shader - the shader to use
   */


  Quad.prototype.initVao = function initVao(shader) {
    this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer, shader.attributes.aVertexPosition, this.gl.FLOAT, false, 4 * 4, 0).addAttribute(this.vertexBuffer, shader.attributes.aTextureCoord, this.gl.FLOAT, false, 4 * 4, 2 * 4);
  };

  /**
   * Maps two Rectangle to the quad.
   *
   * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
   * @param {PIXI.Rectangle} destinationFrame - the second rectangle
   * @return {PIXI.Quad} Returns itself.
   */


  Quad.prototype.map = function map(targetTextureFrame, destinationFrame) {
    var x = 0; // destinationFrame.x / targetTextureFrame.width;
    var y = 0; // destinationFrame.y / targetTextureFrame.height;

    this.uvs[0] = x;
    this.uvs[1] = y;

    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;

    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;

    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;

    x = destinationFrame.x;
    y = destinationFrame.y;

    this.vertices[0] = x;
    this.vertices[1] = y;

    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;

    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;

    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;

    return this;
  };

  /**
   * Binds the buffer and uploads the data
   *
   * @return {PIXI.Quad} Returns itself.
   */


  Quad.prototype.upload = function upload() {
    for (var i = 0; i < 4; i++) {
      this.interleaved[i * 4] = this.vertices[i * 2];
      this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
      this.interleaved[i * 4 + 2] = this.uvs[i * 2];
      this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
    }

    this.vertexBuffer.upload(this.interleaved);

    return this;
  };

  /**
   * Removes this quad from WebGL
   */


  Quad.prototype.destroy = function destroy() {
    var gl = this.gl;

    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.indexBuffer);
  };

  return Quad;
}();

exports.default = Quad;
//# sourceMappingURL=Quad.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(1);

var _canUseNewCanvasBlendModes = __webpack_require__(67);

var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Utility methods for Sprite/Texture tinting.
 *
 * @class
 * @memberof PIXI
 */
var CanvasTinter = {
    /**
     * Basically this method just needs a sprite and a color and tints the sprite with the given color.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Sprite} sprite - the sprite to tint
     * @param {number} color - the color to use to tint the sprite with
     * @return {HTMLCanvasElement} The tinted canvas
     */
    getTintedTexture: function getTintedTexture(sprite, color) {
        var texture = sprite.texture;

        color = CanvasTinter.roundColor(color);

        var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);

        texture.tintCache = texture.tintCache || {};

        if (texture.tintCache[stringColor]) {
            return texture.tintCache[stringColor];
        }

        // clone texture..
        var canvas = CanvasTinter.canvas || document.createElement('canvas');

        // CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
        CanvasTinter.tintMethod(texture, color, canvas);

        if (CanvasTinter.convertTintToImage) {
            // is this better?
            var tintImage = new Image();

            tintImage.src = canvas.toDataURL();

            texture.tintCache[stringColor] = tintImage;
        } else {
            texture.tintCache[stringColor] = canvas;
            // if we are not converting the texture to an image then we need to lose the reference to the canvas
            CanvasTinter.canvas = null;
        }

        return canvas;
    },

    /**
     * Tint a texture using the 'multiply' operation.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithMultiply: function tintWithMultiply(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture._frame.clone();
        var resolution = texture.baseTexture.resolution;

        crop.x *= resolution;
        crop.y *= resolution;
        crop.width *= resolution;
        crop.height *= resolution;

        canvas.width = Math.ceil(crop.width);
        canvas.height = Math.ceil(crop.height);

        context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);

        context.fillRect(0, 0, crop.width, crop.height);

        context.globalCompositeOperation = 'multiply';

        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

        context.globalCompositeOperation = 'destination-atop';

        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    },

    /**
     * Tint a texture using the 'overlay' operation.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithOverlay: function tintWithOverlay(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture._frame.clone();
        var resolution = texture.baseTexture.resolution;

        crop.x *= resolution;
        crop.y *= resolution;
        crop.width *= resolution;
        crop.height *= resolution;

        canvas.width = Math.ceil(crop.width);
        canvas.height = Math.ceil(crop.height);

        context.globalCompositeOperation = 'copy';
        context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, crop.width, crop.height);

        context.globalCompositeOperation = 'destination-atop';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

        // context.globalCompositeOperation = 'copy';
    },


    /**
     * Tint a texture pixel per pixel.
     *
     * @memberof PIXI.CanvasTinter
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture._frame.clone();
        var resolution = texture.baseTexture.resolution;

        crop.x *= resolution;
        crop.y *= resolution;
        crop.width *= resolution;
        crop.height *= resolution;

        canvas.width = Math.ceil(crop.width);
        canvas.height = Math.ceil(crop.height);

        context.globalCompositeOperation = 'copy';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

        var rgbValues = (0, _utils.hex2rgb)(color);
        var r = rgbValues[0];
        var g = rgbValues[1];
        var b = rgbValues[2];

        var pixelData = context.getImageData(0, 0, crop.width, crop.height);

        var pixels = pixelData.data;

        for (var i = 0; i < pixels.length; i += 4) {
            pixels[i + 0] *= r;
            pixels[i + 1] *= g;
            pixels[i + 2] *= b;
        }

        context.putImageData(pixelData, 0, 0);
    },

    /**
     * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
     *
     * @memberof PIXI.CanvasTinter
     * @param {number} color - the color to round, should be a hex color
     * @return {number} The rounded color.
     */
    roundColor: function roundColor(color) {
        var step = CanvasTinter.cacheStepsPerColorChannel;

        var rgbValues = (0, _utils.hex2rgb)(color);

        rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
        rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
        rgbValues[2] = Math.min(255, rgbValues[2] / step * step);

        return (0, _utils.rgb2hex)(rgbValues);
    },

    /**
     * Number of steps which will be used as a cap when rounding colors.
     *
     * @memberof PIXI.CanvasTinter
     * @type {number}
     */
    cacheStepsPerColorChannel: 8,

    /**
     * Tint cache boolean flag.
     *
     * @memberof PIXI.CanvasTinter
     * @type {boolean}
     */
    convertTintToImage: false,

    /**
     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
     *
     * @memberof PIXI.CanvasTinter
     * @type {boolean}
     */
    canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),

    /**
     * The tinting method that will be used.
     *
     * @memberof PIXI.CanvasTinter
     * @type {tintMethodFunctionType}
     */
    tintMethod: 0
};

CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;

/**
 * The tintMethod type.
 *
 * @memberof PIXI.CanvasTinter
 * @callback tintMethodFunctionType
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */

exports.default = CanvasTinter;
//# sourceMappingURL=CanvasTinter.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // disabling eslint for now, going to rewrite this in v5
/* eslint-disable */

var _const = __webpack_require__(0);

var _utils = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultStyle = {
    align: 'left',
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: '#000000',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: false,
    wordWrap: false,
    wordWrapWidth: 100
};

/**
 * A TextStyle Object decorates a Text Object. It can be shared between
 * multiple Text objects. Changing the style will update all text objects using it.
 *
 * @class
 * @memberof PIXI
 */

var TextStyle = function () {
    /**
     * @param {object} [style] - The style parameters
     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),
     *  does not affect single line text
     * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it
     *  needs wordWrap to be set to true
     * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text
     * @param {number} [style.dropShadowAlpha=1] - Set alpha for the drop shadow
     * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow
     * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius
     * @param {string} [style.dropShadowColor='#000000'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow
     * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas
     *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient
     *  eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     * @param {number} [style.fillGradientType=PIXI.TEXT_GRADIENT.LINEAR_VERTICAL] - If fill is an array of colours
     *  to create a gradient, this can change the type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}
     * @param {number[]} [style.fillGradientStops] - If fill is an array of colours to create a gradient, this array can set
     * the stop points (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     * @param {string|string[]} [style.fontFamily='Arial'] - The font family
     * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,
     *  equivalents are '26px','20pt','160%' or '1.6em')
     * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')
     * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')
     * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',
     *  '200', '300', '400', '500', '600', '700', 800' or '900')
     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0
     * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses
     * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve
     *      spiked text issues. Default is 'miter' (creates a sharp corner).
     * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce
     *      or increase the spikiness of rendered text.
     * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from
     *     happening by adding padding to all sides of the text.
     * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke
     *  e.g 'blue', '#FCFF00'
     * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.
     *  Default is 0 (no stroke)
     * @param {boolean} [style.trim=false] - Trim transparent borders
     * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.
     * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used
     * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true
     */
    function TextStyle(style) {
        _classCallCheck(this, TextStyle);

        this.styleID = 0;

        Object.assign(this, defaultStyle, style);
    }

    /**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return {PIXI.TextStyle} New cloned TextStyle object
     */


    TextStyle.prototype.clone = function clone() {
        var clonedProperties = {};

        for (var key in defaultStyle) {
            clonedProperties[key] = this[key];
        }

        return new TextStyle(clonedProperties);
    };

    /**
     * Resets all properties to the defaults specified in TextStyle.prototype._default
     */


    TextStyle.prototype.reset = function reset() {
        Object.assign(this, defaultStyle);
    };

    _createClass(TextStyle, [{
        key: 'align',
        get: function get() {
            return this._align;
        },
        set: function set(align) {
            if (this._align !== align) {
                this._align = align;
                this.styleID++;
            }
        }
    }, {
        key: 'breakWords',
        get: function get() {
            return this._breakWords;
        },
        set: function set(breakWords) {
            if (this._breakWords !== breakWords) {
                this._breakWords = breakWords;
                this.styleID++;
            }
        }
    }, {
        key: 'dropShadow',
        get: function get() {
            return this._dropShadow;
        },
        set: function set(dropShadow) {
            if (this._dropShadow !== dropShadow) {
                this._dropShadow = dropShadow;
                this.styleID++;
            }
        }
    }, {
        key: 'dropShadowAlpha',
        get: function get() {
            return this._dropShadowAlpha;
        },
        set: function set(dropShadowAlpha) {
            if (this._dropShadowAlpha !== dropShadowAlpha) {
                this._dropShadowAlpha = dropShadowAlpha;
                this.styleID++;
            }
        }
    }, {
        key: 'dropShadowAngle',
        get: function get() {
            return this._dropShadowAngle;
        },
        set: function set(dropShadowAngle) {
            if (this._dropShadowAngle !== dropShadowAngle) {
                this._dropShadowAngle = dropShadowAngle;
                this.styleID++;
            }
        }
    }, {
        key: 'dropShadowBlur',
        get: function get() {
            return this._dropShadowBlur;
        },
        set: function set(dropShadowBlur) {
            if (this._dropShadowBlur !== dropShadowBlur) {
                this._dropShadowBlur = dropShadowBlur;
                this.styleID++;
            }
        }
    }, {
        key: 'dropShadowColor',
        get: function get() {
            return this._dropShadowColor;
        },
        set: function set(dropShadowColor) {
            var outputColor = getColor(dropShadowColor);
            if (this._dropShadowColor !== outputColor) {
                this._dropShadowColor = outputColor;
                this.styleID++;
            }
        }
    }, {
        key: 'dropShadowDistance',
        get: function get() {
            return this._dropShadowDistance;
        },
        set: function set(dropShadowDistance) {
            if (this._dropShadowDistance !== dropShadowDistance) {
                this._dropShadowDistance = dropShadowDistance;
                this.styleID++;
            }
        }
    }, {
        key: 'fill',
        get: function get() {
            return this._fill;
        },
        set: function set(fill) {
            var outputColor = getColor(fill);
            if (this._fill !== outputColor) {
                this._fill = outputColor;
                this.styleID++;
            }
        }
    }, {
        key: 'fillGradientType',
        get: function get() {
            return this._fillGradientType;
        },
        set: function set(fillGradientType) {
            if (this._fillGradientType !== fillGradientType) {
                this._fillGradientType = fillGradientType;
                this.styleID++;
            }
        }
    }, {
        key: 'fillGradientStops',
        get: function get() {
            return this._fillGradientStops;
        },
        set: function set(fillGradientStops) {
            if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
                this._fillGradientStops = fillGradientStops;
                this.styleID++;
            }
        }
    }, {
        key: 'fontFamily',
        get: function get() {
            return this._fontFamily;
        },
        set: function set(fontFamily) {
            if (this.fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.styleID++;
            }
        }
    }, {
        key: 'fontSize',
        get: function get() {
            return this._fontSize;
        },
        set: function set(fontSize) {
            if (this._fontSize !== fontSize) {
                this._fontSize = fontSize;
                this.styleID++;
            }
        }
    }, {
        key: 'fontStyle',
        get: function get() {
            return this._fontStyle;
        },
        set: function set(fontStyle) {
            if (this._fontStyle !== fontStyle) {
                this._fontStyle = fontStyle;
                this.styleID++;
            }
        }
    }, {
        key: 'fontVariant',
        get: function get() {
            return this._fontVariant;
        },
        set: function set(fontVariant) {
            if (this._fontVariant !== fontVariant) {
                this._fontVariant = fontVariant;
                this.styleID++;
            }
        }
    }, {
        key: 'fontWeight',
        get: function get() {
            return this._fontWeight;
        },
        set: function set(fontWeight) {
            if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.styleID++;
            }
        }
    }, {
        key: 'letterSpacing',
        get: function get() {
            return this._letterSpacing;
        },
        set: function set(letterSpacing) {
            if (this._letterSpacing !== letterSpacing) {
                this._letterSpacing = letterSpacing;
                this.styleID++;
            }
        }
    }, {
        key: 'lineHeight',
        get: function get() {
            return this._lineHeight;
        },
        set: function set(lineHeight) {
            if (this._lineHeight !== lineHeight) {
                this._lineHeight = lineHeight;
                this.styleID++;
            }
        }
    }, {
        key: 'lineJoin',
        get: function get() {
            return this._lineJoin;
        },
        set: function set(lineJoin) {
            if (this._lineJoin !== lineJoin) {
                this._lineJoin = lineJoin;
                this.styleID++;
            }
        }
    }, {
        key: 'miterLimit',
        get: function get() {
            return this._miterLimit;
        },
        set: function set(miterLimit) {
            if (this._miterLimit !== miterLimit) {
                this._miterLimit = miterLimit;
                this.styleID++;
            }
        }
    }, {
        key: 'padding',
        get: function get() {
            return this._padding;
        },
        set: function set(padding) {
            if (this._padding !== padding) {
                this._padding = padding;
                this.styleID++;
            }
        }
    }, {
        key: 'stroke',
        get: function get() {
            return this._stroke;
        },
        set: function set(stroke) {
            var outputColor = getColor(stroke);
            if (this._stroke !== outputColor) {
                this._stroke = outputColor;
                this.styleID++;
            }
        }
    }, {
        key: 'strokeThickness',
        get: function get() {
            return this._strokeThickness;
        },
        set: function set(strokeThickness) {
            if (this._strokeThickness !== strokeThickness) {
                this._strokeThickness = strokeThickness;
                this.styleID++;
            }
        }
    }, {
        key: 'textBaseline',
        get: function get() {
            return this._textBaseline;
        },
        set: function set(textBaseline) {
            if (this._textBaseline !== textBaseline) {
                this._textBaseline = textBaseline;
                this.styleID++;
            }
        }
    }, {
        key: 'trim',
        get: function get() {
            return this._trim;
        },
        set: function set(trim) {
            if (this._trim !== trim) {
                this._trim = trim;
                this.styleID++;
            }
        }
    }, {
        key: 'wordWrap',
        get: function get() {
            return this._wordWrap;
        },
        set: function set(wordWrap) {
            if (this._wordWrap !== wordWrap) {
                this._wordWrap = wordWrap;
                this.styleID++;
            }
        }
    }, {
        key: 'wordWrapWidth',
        get: function get() {
            return this._wordWrapWidth;
        },
        set: function set(wordWrapWidth) {
            if (this._wordWrapWidth !== wordWrapWidth) {
                this._wordWrapWidth = wordWrapWidth;
                this.styleID++;
            }
        }
    }]);

    return TextStyle;
}();

/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 *
 * @param {number|number[]} color
 * @return {string} The color as a string.
 */


exports.default = TextStyle;
function getSingleColor(color) {
    if (typeof color === 'number') {
        return (0, _utils.hex2string)(color);
    } else if (typeof color === 'string') {
        if (color.indexOf('0x') === 0) {
            color = color.replace('0x', '#');
        }
    }

    return color;
}

/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * This version can also convert array of colors
 *
 * @param {number|number[]} color
 * @return {string} The color as a string.
 */
function getColor(color) {
    if (!Array.isArray(color)) {
        return getSingleColor(color);
    } else {
        for (var i = 0; i < color.length; ++i) {
            color[i] = getSingleColor(color[i]);
        }

        return color;
    }
}

/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * This version can also convert array of colors
 *
 * @param {Array} array1 First array to compare
 * @param {Array} array2 Second array to compare
 * @return {boolean} Do the arrays contain the same values in the same order
 */
function areArraysEqual(array1, array2) {
    if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
    }

    if (array1.length !== array2.length) {
        return false;
    }

    for (var i = 0; i < array1.length; ++i) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }

    return true;
}
//# sourceMappingURL=TextStyle.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _BaseTexture2 = __webpack_require__(14);

var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A BaseRenderTexture is a special texture that allows any Pixi display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position
 * and rotation of the given Display Objects is ignored. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
 * let baseRenderTexture = new PIXI.BaseRenderTexture(renderer, 800, 600);
 * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * baseRenderTexture.render(sprite);
 * ```
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);
 * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
 *
 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 */
var BaseRenderTexture = function (_BaseTexture) {
  _inherits(BaseRenderTexture, _BaseTexture);

  /**
   * @param {number} [width=100] - The width of the base render texture
   * @param {number} [height=100] - The height of the base render texture
   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
   * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
   */
  function BaseRenderTexture() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    var scaleMode = arguments[2];
    var resolution = arguments[3];

    _classCallCheck(this, BaseRenderTexture);

    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, null, scaleMode));

    _this.resolution = resolution || _settings2.default.RESOLUTION;

    _this.width = width;
    _this.height = height;

    _this.realWidth = _this.width * _this.resolution;
    _this.realHeight = _this.height * _this.resolution;

    _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
    _this.hasLoaded = true;

    /**
     * A map of renderer IDs to webgl renderTargets
     *
     * @private
     * @member {object<number, WebGLTexture>}
     */
    _this._glRenderTargets = {};

    /**
     * A reference to the canvas render target (we only need one as this can be shared across renderers)
     *
     * @private
     * @member {object<number, WebGLTexture>}
     */
    _this._canvasRenderTarget = null;

    /**
     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
     *
     * @member {boolean}
     */
    _this.valid = false;
    return _this;
  }

  /**
   * Resizes the BaseRenderTexture.
   *
   * @param {number} width - The width to resize to.
   * @param {number} height - The height to resize to.
   */


  BaseRenderTexture.prototype.resize = function resize(width, height) {
    if (width === this.width && height === this.height) {
      return;
    }

    this.valid = width > 0 && height > 0;

    this.width = width;
    this.height = height;

    this.realWidth = this.width * this.resolution;
    this.realHeight = this.height * this.resolution;

    if (!this.valid) {
      return;
    }

    this.emit('update', this);
  };

  /**
   * Destroys this texture
   *
   */


  BaseRenderTexture.prototype.destroy = function destroy() {
    _BaseTexture.prototype.destroy.call(this, true);
    this.renderer = null;
  };

  return BaseRenderTexture;
}(_BaseTexture3.default);

exports.default = BaseRenderTexture;
//# sourceMappingURL=BaseRenderTexture.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _GroupD = __webpack_require__(63);

var _GroupD2 = _interopRequireDefault(_GroupD);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A standard object to store the Uvs of a texture
 *
 * @class
 * @private
 * @memberof PIXI
 */
var TextureUvs = function () {
    /**
     *
     */
    function TextureUvs() {
        _classCallCheck(this, TextureUvs);

        this.x0 = 0;
        this.y0 = 0;

        this.x1 = 1;
        this.y1 = 0;

        this.x2 = 1;
        this.y2 = 1;

        this.x3 = 0;
        this.y3 = 1;

        this.uvsUint32 = new Uint32Array(4);
    }

    /**
     * Sets the texture Uvs based on the given frame information.
     *
     * @private
     * @param {PIXI.Rectangle} frame - The frame of the texture
     * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
     * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
     */


    TextureUvs.prototype.set = function set(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;

        if (rotate) {
            // width and height div 2 div baseFrame size
            var w2 = frame.width / 2 / tw;
            var h2 = frame.height / 2 / th;

            // coordinates of center
            var cX = frame.x / tw + w2;
            var cY = frame.y / th + h2;

            rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW); // NW is top-left corner
            this.x0 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y0 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2); // rotate 90 degrees clockwise
            this.x1 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y1 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2);
            this.x2 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y2 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2);
            this.x3 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y3 = cY + h2 * _GroupD2.default.uY(rotate);
        } else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;

            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;

            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;

            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
        }

        this.uvsUint32[0] = (this.y0 * 65535 & 0xFFFF) << 16 | this.x0 * 65535 & 0xFFFF;
        this.uvsUint32[1] = (this.y1 * 65535 & 0xFFFF) << 16 | this.x1 * 65535 & 0xFFFF;
        this.uvsUint32[2] = (this.y2 * 65535 & 0xFFFF) << 16 | this.x2 * 65535 & 0xFFFF;
        this.uvsUint32[3] = (this.y3 * 65535 & 0xFFFF) << 16 | this.x3 * 65535 & 0xFFFF;
    };

    return TextureUvs;
}();

exports.default = TextureUvs;
//# sourceMappingURL=TextureUvs.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseTexture2 = __webpack_require__(14);

var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

var _utils = __webpack_require__(1);

var _ticker = __webpack_require__(33);

var ticker = _interopRequireWildcard(_ticker);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A texture of a [playing] Video.
 *
 * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
 *
 * This can be used in several ways, such as:
 *
 * ```js
 * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
 *
 * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
 *
 * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
 *
 * let texture = PIXI.VideoBaseTexture.fromUrls([
 *     { src: '/video.webm', mime: 'video/webm' },
 *     { src: '/video.mp4', mime: 'video/mp4' }
 * ]);
 * ```
 *
 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 */
var VideoBaseTexture = function (_BaseTexture) {
    _inherits(VideoBaseTexture, _BaseTexture);

    /**
     * @param {HTMLVideoElement} source - Video source
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     */
    function VideoBaseTexture(source, scaleMode) {
        _classCallCheck(this, VideoBaseTexture);

        if (!source) {
            throw new Error('No video source element specified.');
        }

        // hook in here to check if video is already available.
        // BaseTexture looks for a source.complete boolean, plus width & height.

        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
            source.complete = true;
        }

        var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));

        _this.width = source.videoWidth;
        _this.height = source.videoHeight;

        _this._autoUpdate = true;
        _this._isAutoUpdating = false;

        /**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */
        _this.autoPlay = true;

        _this.update = _this.update.bind(_this);
        _this._onCanPlay = _this._onCanPlay.bind(_this);

        source.addEventListener('play', _this._onPlayStart.bind(_this));
        source.addEventListener('pause', _this._onPlayStop.bind(_this));
        _this.hasLoaded = false;
        _this.__loaded = false;

        if (!_this._isSourceReady()) {
            source.addEventListener('canplay', _this._onCanPlay);
            source.addEventListener('canplaythrough', _this._onCanPlay);
        } else {
            _this._onCanPlay();
        }
        return _this;
    }

    /**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */


    VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() {
        var source = this.source;

        return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
    };

    /**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */


    VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() {
        return this.source.readyState === 3 || this.source.readyState === 4;
    };

    /**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */


    VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {
        // Just in case the video has not received its can play even yet..
        if (!this.hasLoaded) {
            this._onCanPlay();
        }

        if (!this._isAutoUpdating && this.autoUpdate) {
            ticker.shared.add(this.update, this);
            this._isAutoUpdating = true;
        }
    };

    /**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */


    VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() {
        if (this._isAutoUpdating) {
            ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
        }
    };

    /**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */


    VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {
        this.hasLoaded = true;

        if (this.source) {
            this.source.removeEventListener('canplay', this._onCanPlay);
            this.source.removeEventListener('canplaythrough', this._onCanPlay);

            this.width = this.source.videoWidth;
            this.height = this.source.videoHeight;

            // prevent multiple loaded dispatches..
            if (!this.__loaded) {
                this.__loaded = true;
                this.emit('loaded', this);
            }

            if (this._isSourcePlaying()) {
                this._onPlayStart();
            } else if (this.autoPlay) {
                this.source.play();
            }
        }
    };

    /**
     * Destroys this texture
     *
     */


    VideoBaseTexture.prototype.destroy = function destroy() {
        if (this._isAutoUpdating) {
            ticker.shared.remove(this.update, this);
        }

        if (this.source && this.source._pixiId) {
            delete _utils.BaseTextureCache[this.source._pixiId];
            delete this.source._pixiId;
        }

        _BaseTexture.prototype.destroy.call(this);
    };

    /**
     * Mimic Pixi BaseTexture.from.... method.
     *
     * @static
     * @param {HTMLVideoElement} video - Video to create texture from
     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
     */


    VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode) {
        if (!video._pixiId) {
            video._pixiId = 'video_' + (0, _utils.uid)();
        }

        var baseTexture = _utils.BaseTextureCache[video._pixiId];

        if (!baseTexture) {
            baseTexture = new VideoBaseTexture(video, scaleMode);
            _utils.BaseTextureCache[video._pixiId] = baseTexture;
        }

        return baseTexture;
    };

    /**
     * Helper function that creates a new BaseTexture based on the given video element.
     * This BaseTexture can then be used to create a texture
     *
     * @static
     * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.
     * @param {string} [videoSrc.src] - One of the source urls for the video
     * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified
     *  the url's extension will be used as the second part of the mime type.
     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
     */


    VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode) {
        var video = document.createElement('video');

        video.setAttribute('webkit-playsinline', '');
        video.setAttribute('playsinline', '');

        // array of objects or strings
        if (Array.isArray(videoSrc)) {
            for (var i = 0; i < videoSrc.length; ++i) {
                video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
            }
        }
        // single object or string
        else {
                video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
            }

        video.load();

        return VideoBaseTexture.fromVideo(video, scaleMode);
    };

    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     */


    _createClass(VideoBaseTexture, [{
        key: 'autoUpdate',
        get: function get() {
            return this._autoUpdate;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (value !== this._autoUpdate) {
                this._autoUpdate = value;

                if (!this._autoUpdate && this._isAutoUpdating) {
                    ticker.shared.remove(this.update, this);
                    this._isAutoUpdating = false;
                } else if (this._autoUpdate && !this._isAutoUpdating) {
                    ticker.shared.add(this.update, this);
                    this._isAutoUpdating = true;
                }
            }
        }
    }]);

    return VideoBaseTexture;
}(_BaseTexture3.default);

exports.default = VideoBaseTexture;


VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

function createSource(path, type) {
    if (!type) {
        type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = path;
    source.type = type;

    return source;
}
//# sourceMappingURL=VideoBaseTexture.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = createIndicesForQuads;
/**
 * Generic Mask Stack data structure
 *
 * @memberof PIXI
 * @function createIndicesForQuads
 * @private
 * @param {number} size - Number of quads
 * @return {Uint16Array} indices
 */
function createIndicesForQuads(size) {
    // the total number of indices in our array, there are 6 points per quad.

    var totalIndices = size * 6;

    var indices = new Uint16Array(totalIndices);

    // fill the indices with the quads to draw
    for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
        indices[i + 0] = j + 0;
        indices[i + 1] = j + 1;
        indices[i + 2] = j + 2;
        indices[i + 3] = j + 0;
        indices[i + 4] = j + 2;
        indices[i + 5] = j + 3;
    }

    return indices;
}
//# sourceMappingURL=createIndicesForQuads.js.map

/***/ }),
/* 77 */,
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 03.03.2017.
 */
class CheckFields {
    constructor() {

    }

    static _checkLatin(value) {
        return value.match(/[а-яА-ЯёЁ]+/) === null;
    }

    static checkLogin(obj) {
        let arr = [];
        if (!this._checkLatin(obj.field.value)) {
            arr.push({
                err_text: 'Only Latin',
            })
        }
        if (obj.field.value.length < 4) {
            arr.push({
                err_text: '4 - min length',
            });
        }

        obj.help.textContent = '';
        arr.forEach(item => {
            this.fieldSetErr(obj.field);
            this.fieldRemoveOk(obj.field);

            if (obj.help.textContent === '') {
                obj.help.textContent = item.err_text;
            } else {
                obj.help.textContent = `${obj.help.textContent},${item.err_text}`;
                console.log(obj.help.textContent);
            }
        });

        if (arr.length == 0) {
            this.fieldSetOk(obj.field);
        }

        return arr.length == 0;
    }

    static _checkPassLength(value) {
        return value.length >= 8;
    }

    static _checkPassEquals(value1, value2) {
        return value1 === value2;
    }

    static checkEmpty(value) {
        return value.length == 0;
    }


    static checkPassword(obj1, obj2) {
        let arr = [];
        let check = true;

        if (check) {
            if (!this._checkPassLength(obj1.field.value)) {
                arr.push({
                    err_text: '8 - min length',
                    field: obj1.field,
                    help: obj1.help
                })
            }
            if (!this._checkPassEquals(obj1.field.value, obj2.field.value)) {
                arr.push({
                    err_text: 'Passwords not equals',
                    field: obj1.field,
                    help: obj1.help
                });
                arr.push({
                    err_text: 'Passwords not equals',
                    field: obj2.field,
                    help: obj2.help
                });
            }
        }

        obj1.help.textContent = '';
        obj2.help.textContent = '';
        arr.forEach(item => {
            this.fieldSetErr(item.field);
            this.fieldRemoveOk(item.field);

            if (item.help.textContent === '') {
                item.help.textContent = item.err_text;
            } else {
                item.help.textContent = `${item.help.textContent}.${item.err_text}`;
            }
        });

        if (arr.length == 0) {
            this.fieldSetOk(obj1.field);
            this.fieldSetOk(obj2.field);
        }
        return arr.length == 0;
    }

    static helpSetText(elem, value) {
        elem.textContent = value;
    }

    static fieldSetText(elem, value) {
        elem.value = value;
    }

    static fieldSetErr(elem) {
        elem.classList.add('input__error');
    }

    static fieldRemoveErr(elem) {
        elem.classList.remove('input__error');
    }

    static fieldSetOk(elem) {
        elem.classList.add('input__ok');
    }

    static fieldRemoveOk(elem) {
        elem.classList.remove('input__ok');
    }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CheckFields;



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Btn__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Input__ = __webpack_require__(175);
/**
 * Created by Denis on 02.03.2017.
 */


class Form {
    constructor(options = {data: {}}) {
        this.data = options.data;
        this.el = document.createElement('form');
        this.fields = [];
        this.controls = [];
        this._render();
    }

    _render() {
        this._setAttrs(this.data.form.attrs, this.el);
        let h3 = document.createElement('h3');
        this._setAttrs(this.data.title.attrs, h3);
        h3.innerHTML = this.data.title.text;
        this.el.appendChild(h3);


        this.fields = this._getFields();
        this.controls = this._getControls();
        this._fieldsAppendTo(this.fields, this.el);

        this._controlsAppendTo(this.controls, this.el);
    }

    getElem(){
        return this;
    }

    _getFields() {
        let {fields = []}=this.data;
        return fields.map(data => {
            return new __WEBPACK_IMPORTED_MODULE_1__Input__["a" /* default */](data).getElem();
        });
    }

    _setAttrs(attrs, elem) {
        Object.keys(attrs).forEach(name => {
            elem.setAttribute(name, attrs[name]);
        })
    }

    _fieldsAppendTo(array, elem) {
        array.forEach(item => {
            elem.appendChild(item.el);
            elem.appendChild(item.help_el);
        })
    }

    _controlsAppendTo(array, elem) {
        array.forEach(item => {
            elem.appendChild(item.el);
        })
    }

    _getControls() {
        let {controls = []}=this.data;
        return controls.map(data => {
            return new __WEBPACK_IMPORTED_MODULE_0__Btn__["a" /* default */](data).getElem();
        });
    }

    toString() {
        return this.el.outerHTML;
    }

    getFormData() {
        let elements = this.el.elements;
        let fields = {};

        Object.keys(elements).forEach(element => {
            let name = elements[element].name;
            let value = elements[element].value;

            if (!name) {
                return;
            }

            fields[name] = value;
        });
        return fields;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Form;




/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__views_menu_MenuView__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__views_menu_LoginView__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__views_menu_SignUpView__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__views_menu_AboutView__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__views_menu_LeaderBoardView__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__views_menu_ProfileView__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__game_object_User__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_UserService__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__views_game_GameView__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__anim_Animation__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__RouterUrls__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__game_modules_GameManager__ = __webpack_require__(169);
/**
 * Created by Denis on 17.03.2017.
 */














class Router {

    /**
     * Конструктор
     * @param node - область действия
     */
    constructor(node) {
        this.node = node;
        this.routes = {};
        this.currView = null;
        window.router = this;
        this.init();
        window.onpopstate = (event) => {
            this._setCurrView(document.location.pathname, false);
        };
    }

    /**
     * Инициализация всех вьюшек
     */
    init() {
        let gameView = new __WEBPACK_IMPORTED_MODULE_8__views_game_GameView__["a" /* default */](document.getElementById('game-view'));
        this._register(window.MAIN, new __WEBPACK_IMPORTED_MODULE_0__views_menu_MenuView__["a" /* default */](document.getElementById('menu-view')));
        this._register(window.SINGLEPLAYER, gameView);
        this._register(window.MULTIPLAYER, gameView);
        this._register(window.LOGIN, new __WEBPACK_IMPORTED_MODULE_1__views_menu_LoginView__["a" /* default */](document.getElementById('login-view')));
        this._register(window.SIGNUP, new __WEBPACK_IMPORTED_MODULE_2__views_menu_SignUpView__["a" /* default */](document.getElementById('signup-view')));
        this._register(window.LEADERBOARD, new __WEBPACK_IMPORTED_MODULE_4__views_menu_LeaderBoardView__["a" /* default */](document.getElementById('leaderboard-view')));
        this._register(window.ABOUT, new __WEBPACK_IMPORTED_MODULE_3__views_menu_AboutView__["a" /* default */](document.getElementById('about-view')));
        this._register(window.PROFILE, new __WEBPACK_IMPORTED_MODULE_5__views_menu_ProfileView__["a" /* default */](document.getElementById('profile-view')));
        this._setCurrView(document.location.pathname);
        this._start();
    }

    /**
     * Установить текущую вьюшку
     * @param path
     * @param isToHistory
     * @private
     */
    _setCurrView(path, isToHistory) {
        if (isToHistory !== false) {
            history.pushState({opa: 'opa'}, 'title1', path);
        }
        this._checkUser(path);
    }

    /**
     * Проверка, залогинен ли юзер
     * @param path
     * @private
     */
    _checkUser(path) {
        if (path === window.LOGIN || path === window.SIGNUP) {
            this._getUser().then(user => {
                window.USER = user;
                this._go(window.PROFILE);
            }).catch(err => {
                this._go(path);
            });
        } else if (path === window.PROFILE) {
            this._getUser().then(user => {
                window.USER = user;
                this._go(path);
            }).catch(err => {
                this._go(window.LOGIN);
            });
        } else if (path === window.SINGLEPLAYER) {
            this._getUser().then(user => {
                window.USER = user;
                new __WEBPACK_IMPORTED_MODULE_11__game_modules_GameManager__["a" /* default */](user, this.getViewByRoute(path), window.SINGLEPLAYER_STRATEGY);
                this._go(window.SINGLEPLAYER);
            }).catch(err => {
                console.error(err);
                this._go(window.LOGIN);
            });
        } else if (path === window.MULTIPLAYER) {
            this._getUser().then(user => {
                window.USER = user;
                new __WEBPACK_IMPORTED_MODULE_11__game_modules_GameManager__["a" /* default */](user, this.getViewByRoute(path), window.MULTIPLAYER_STRATEGY);
                this._go(window.MULTIPLAYER);
            }).catch(err => {
                this._go(window.LOGIN);
            });
        } else {
            this._go(path);
        }
    }

    /**
     * Получить юзера
     * @return {Promise}
     * @private
     */
    _getUser() {
        return new Promise(function (resolve, reject) {
            if (window.USER) {
                resolve(window.USER);
            }
            new __WEBPACK_IMPORTED_MODULE_7__service_UserService__["a" /* default */]().getUser().then(user => {
                resolve(user);
            }).catch(err => {
                reject();
            });
        });
    }

    /**
     * Перейти по маршруту и поменять текущую вьюшку
     * @param {string} path
     */
    _go(path) {
        if (this.currView !== null && this.currView.constructor.name === __WEBPACK_IMPORTED_MODULE_8__views_game_GameView__["a" /* default */].name) {
            this.currView.clear();
        }

        if (this.currView) {
            this.currView.toggleView();
        }
        this.currView = this.getViewByRoute(path);

        if (!this.currView) {
            return;
        }

        if (path === window.PROFILE) {
            this.currView.refresh();
        }

        this.currView.toggleView();
    }

    /**
     * Регистрация маршрута
     * @param {string} route
     * @param {Object} view
     */
    _register(route, view) {
        this.routes[route] = view;
    }

    /**
     * Получение маршрута
     * @param href
     * @return {*}
     */
    getViewByRoute(href) {
        return this.routes[href];
    }

    /**
     * Запустить процес маршрутизации
     */
    _start() {
        this.node.addEventListener('click', event => this._onRouteChange(event));
    }

    /**
     * Проверка на смененный маршрут
     * @param event
     * @private
     */
    _onRouteChange(event) {
        if (event.target instanceof HTMLAnchorElement) {
            event.preventDefault();
            this._setCurrView(event.target.getAttribute('href'));
        } else if (event.target.parentElement instanceof HTMLAnchorElement) {
            event.preventDefault();
            this._setCurrView(event.target.parentElement.getAttribute('href'));
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Router;



/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__support_router_Router__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__support_router_RouterUrls__ = __webpack_require__(10);
/**
 * Created by Denis on 04.03.2017.
 */


new __WEBPACK_IMPORTED_MODULE_1__support_router_RouterUrls__["a" /* default */]();
new __WEBPACK_IMPORTED_MODULE_0__support_router_Router__["a" /* default */](window.document.documentElement);





/***/ }),
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * iziToast | v1.1.0
 * http://izitoast.marcelodolce.com
 * by Marcelo Dolce.
 */ 
(function (root, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory(root)),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof exports === 'object') {
		module.exports = factory(root);
	} else {
		root.iziToast = factory(root);
	}
})(typeof global !== "undefined" ? global : this.window || this.global, function (root) {

	'use strict';

	//
	// Variables
	//
	var $iziToast = {},
		PLUGIN_NAME = 'iziToast',
		BODY = document.querySelector('body'),
		ISMOBILE = (/Mobi/.test(navigator.userAgent)) ? true : false,
		ISCHROME = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor),
		ISFIREFOX = typeof InstallTrigger !== 'undefined',
		ACCEPTSTOUCH = 'ontouchstart' in document.documentElement,
		POSITIONS = ['bottomRight','bottomLeft','bottomCenter','topRight','topLeft','topCenter','center'],
		THEMES = {
			info: {
				color: "blue",
				icon: "ico-info"
			},
			success: {
				color: "green",
				icon: "ico-check",
			},
			warning: {
				color: "yellow",
				icon: "ico-warning",
			},
			error: {
				color: "red",
				icon: "ico-error",
			}
		},
		MOBILEWIDTH = 568,
		CONFIG = {};

	// Default settings
	var defaults = {
		class: '',
		title: '',
		titleColor: '',
		message: '',
		messageColor: '',
		backgroundColor: '',
		color: '', // blue, red, green, yellow
		icon: '',
		iconText: '',
		iconColor: '',
		image: '',
		imageWidth: 50,
		zindex: 99999,
		layout: 1,
		balloon: false,
		close: true,
		rtl: false,
		position: 'bottomRight', // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
		target: '',
		targetFirst: true,
		timeout: 5000,
		drag: true,
		pauseOnHover: true,
		resetOnHover: false,
		progressBar: true,
		progressBarColor: '',
		animateInside: true,
		buttons: {},
		transitionIn: 'fadeInUp', // bounceInLeft, bounceInRight, bounceInUp, bounceInDown, fadeIn, fadeInDown, fadeInUp, fadeInLeft, fadeInRight, flipInX
		transitionOut: 'fadeOut', // fadeOut, fadeOutUp, fadeOutDown, fadeOutLeft, fadeOutRight, flipOutX
		transitionInMobile: 'fadeInUp',
		transitionOutMobile: 'fadeOutDown',
		onOpen: function () {},
		onClose: function () {}
	};

	//
	// Methods
	//


	/**
	 * Polyfill for remove() method
	 */
	if (!('remove' in Element.prototype)) {
	    Element.prototype.remove = function() {
	        if (this.parentNode) {
	            this.parentNode.removeChild(this);
	        }
	    };
	}

	/**
	 * A simple forEach() implementation for Arrays, Objects and NodeLists
	 * @private
	 * @param {Array|Object|NodeList} collection Collection of items to iterate
	 * @param {Function} callback Callback function for each iteration
	 * @param {Array|Object|NodeList} scope Object/NodeList/Array that forEach is iterating over (aka `this`)
	 */
	var forEach = function (collection, callback, scope) {
		if (Object.prototype.toString.call(collection) === '[object Object]') {
			for (var prop in collection) {
				if (Object.prototype.hasOwnProperty.call(collection, prop)) {
					callback.call(scope, collection[prop], prop, collection);
				}
			}
		} else {
			if(collection){
				for (var i = 0, len = collection.length; i < len; i++) {
					callback.call(scope, collection[i], i, collection);
				}
			}
		}
	};

	/**
	 * Merge defaults with user options
	 * @private
	 * @param {Object} defaults Default settings
	 * @param {Object} options User options
	 * @returns {Object} Merged values of defaults and options
	 */
	var extend = function (defaults, options) {
		var extended = {};
		forEach(defaults, function (value, prop) {
			extended[prop] = defaults[prop];
		});
		forEach(options, function (value, prop) {
			extended[prop] = options[prop];
		});
		return extended;
	};


	/**
	 * Create a fragment DOM elements
	 * @private
	 */
	var createFragElem = function(htmlStr) {
		var frag = document.createDocumentFragment(),
			temp = document.createElement('div');
		temp.innerHTML = htmlStr;
		while (temp.firstChild) {
			frag.appendChild(temp.firstChild);
		}
		return frag;
	};


	/**
	 * Check if is a color
	 * @private
	 */
	var isColor = function(color){
		if( color.substring(0,1) == "#" || color.substring(0,3) == "rgb" || color.substring(0,3) == "hsl" ){
			return true;
		} else {
			return false;
		}
	};


	/**
	 * Drag method of toasts
	 * @private
	 */
	var drag = function() {
	    
	    return {
	        move: function(toast, instance, settings, xpos) {

	        	var opacity,
	        		opacityRange = 0.3,
	        		distance = 180;
	            
	            toast.style.transform = 'translateX('+xpos + 'px)';

	            if(xpos > 0){
	            	opacity = (distance-xpos) / distance;
	            	if(opacity < opacityRange){
						instance.hide(extend(settings, { transitionOut: 'fadeOutRight', transitionOutMobile: 'fadeOutRight' }), toast, 'drag');
					}
	            } else {
	            	opacity = (distance+xpos) / distance;
	            	if(opacity < opacityRange){
						instance.hide(extend(settings, { transitionOut: 'fadeOutLeft', transitionOutMobile: 'fadeOutLeft' }), toast, 'drag');
					}
	            }
				toast.style.opacity = opacity;
		
				if(opacity < opacityRange){

					if(ISCHROME || ISFIREFOX)
						toast.style.left = xpos+'px';

					toast.parentNode.style.opacity = opacityRange;

	                this.stopMoving(toast, null);
				}
				
	        },
	        startMoving: function(toast, instance, settings, e) {

	            e = e || window.event;
	            var posX = ((ACCEPTSTOUCH) ? e.touches[0].clientX : e.clientX),
	                toastLeft = toast.style.transform.replace('px)', '');
	                toastLeft = toastLeft.replace('translateX(', '');
	            var offsetX = posX - toastLeft;

				toast.classList.remove(settings.transitionIn);
				toast.classList.remove(settings.transitionInMobile);
				toast.style.transition = "";

	            if (ACCEPTSTOUCH) {
	                document.ontouchmove = function(e) {
	                    e.preventDefault();
	                    e = e || window.event;
	                    var posX = e.touches[0].clientX,
	                        finalX = posX - offsetX;
                        drag.move(toast, instance, settings, finalX);
	                };
	            } else {
	                document.onmousemove = function(e) {
	                    e.preventDefault();
	                    e = e || window.event;
	                    var posX = e.clientX,
	                        finalX = posX - offsetX;
                        drag.move(toast, instance, settings, finalX);
	                };
	            }

	        },
	        stopMoving: function(toast, e) {

	            if (ACCEPTSTOUCH) {
	                document.ontouchmove = function() {};
	            } else {
	            	document.onmousemove = function() {};
	            }
				toast.style.transition = "transform 0.4s ease, opacity 0.4s ease";
				toast.style.opacity = "";
				toast.style.transform = "";
				window.setTimeout(function() {
					toast.style.transition = "";
				}, 400);
	        }
	    };

	}();


	/**
	 * Do the calculation to move the progress bar
	 * @private
	 */
	var moveProgress = function(toast, settings, callback){

		var isPaused = false;
		var isReseted = false;
		var isClosed = false;
		var timerTimeout = null;
		var elem = toast.querySelector("."+PLUGIN_NAME+"-progressbar div");
		var progressBar = {
			hideEta: null,
			maxHideTime: null,
			currentTime: new Date().getTime(),
			updateProgress: function()
			{
				isPaused = toast.classList.contains(PLUGIN_NAME+'-paused') ? true : false;
				isReseted = toast.classList.contains(PLUGIN_NAME+'-reseted') ? true : false;
				isClosed = toast.classList.contains(PLUGIN_NAME+'-closed') ? true : false;

				if(isReseted){
					clearTimeout(timerTimeout);
					elem.style.width = '100%';
					moveProgress(toast, settings, callback);
					toast.classList.remove(PLUGIN_NAME+'-reseted');
				}
				if(isClosed){
					clearTimeout(timerTimeout);
					toast.classList.remove(PLUGIN_NAME+'-closed');
				}

				if(!isPaused && !isReseted && !isClosed){
					progressBar.currentTime = progressBar.currentTime+10;
					var percentage = ((progressBar.hideEta - (progressBar.currentTime)) / progressBar.maxHideTime) * 100;
					elem.style.width = percentage + '%';

					if(Math.round(percentage) < 0 || typeof toast != 'object'){
						clearTimeout(timerTimeout);
						callback.apply();
					}
				}

			}
		};
		if (settings.timeout > 0) {
			progressBar.maxHideTime = parseFloat(settings.timeout);
			progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
			timerTimeout = setInterval(progressBar.updateProgress, 10);
		}
	};

	/**
	 * Destroy the current initialization.
	 * @public
	 */
	$iziToast.destroy = function () {

		forEach(document.querySelectorAll('.'+PLUGIN_NAME+'-wrapper'), function(element, index) {
			element.remove();
		});

		forEach(document.querySelectorAll('.'+PLUGIN_NAME), function(element, index) {
			element.remove();
		});

		// Remove event listeners
		document.removeEventListener(PLUGIN_NAME+'-open', {}, false);
		document.removeEventListener(PLUGIN_NAME+'-close', {}, false);

		// Reset variables
		CONFIG = {};
	};

	/**
	 * Initialize Plugin
	 * @public
	 * @param {Object} options User settings
	 */
	$iziToast.settings = function (options) {

		// Destroy any existing initializations
		$iziToast.destroy();

		CONFIG = options;
		defaults = extend(defaults, options || {});
	};


	/**
	 * Building themes functions.
	 * @public
	 * @param {Object} options User settings
	 */
	forEach(THEMES, function (theme, name) {

		$iziToast[name] = function (options) {

			var settings = extend(CONFIG, options || {});
			settings = extend(theme, settings || {});

			this.show(settings);
		};

	});


	/**
	 * Close the specific Toast
	 * @public
	 * @param {Object} options User settings
	 */
	$iziToast.hide = function (options, $toast, closedBy) {

		var settings = extend(defaults, options || {});
			closedBy = closedBy || false;

		if(typeof $toast != 'object'){
			$toast = document.querySelector($toast);
		}
		$toast.classList.add(PLUGIN_NAME+'-closed');

		if(settings.transitionIn || settings.transitionInMobile){
			$toast.classList.remove(settings.transitionIn);
			$toast.classList.remove(settings.transitionInMobile);
		}

		if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
			if(settings.transitionOutMobile)
				$toast.classList.add(settings.transitionOutMobile);
		} else{
			if(settings.transitionOut)
				$toast.classList.add(settings.transitionOut);
		}
		var H = $toast.parentNode.offsetHeight;
				$toast.parentNode.style.height = H+'px';
				$toast.style.pointerEvents = 'none';
		
		if(!ISMOBILE || window.innerWidth > MOBILEWIDTH){
			$toast.parentNode.style.transitionDelay = '0.2s';
		}

		setTimeout(function() {
			$toast.parentNode.style.height = '0px';
			$toast.parentNode.style.overflow = '';
			window.setTimeout(function(){
				$toast.parentNode.remove();
			},1000);
		},200);

		if (settings.class){
			try {
				var event;
				if (window.CustomEvent) {
					event = new CustomEvent(PLUGIN_NAME+'-close', {detail: {class: settings.class}});
				} else {
					event = document.createEvent('CustomEvent');
					event.initCustomEvent(PLUGIN_NAME+'-close', true, true, {class: settings.class});
				}
				document.dispatchEvent(event);
			} catch(ex){
				console.warn(ex);
			}
		}

		if(typeof settings.onClose !== "undefined"){
			settings.onClose.apply(null, [settings, $toast, closedBy]);
		}
	};

	/**
	 * Create and show the Toast
	 * @public
	 * @param {Object} options User settings
	 */
	$iziToast.show = function (options) {

		var that = this;

		// Merge user options with defaults
		var settings = extend(CONFIG, options || {});
			settings = extend(defaults, settings);

		var $toastCapsule = document.createElement("div");
			$toastCapsule.classList.add(PLUGIN_NAME+"-capsule");

		var $toast = document.createElement("div");
			$toast.classList.add(PLUGIN_NAME);

		if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
			if(settings.transitionInMobile.length>0)
				$toast.classList.add(settings.transitionInMobile);
		} else {
			if(settings.transitionIn.length>0)
				$toast.classList.add(settings.transitionIn);
		}

		if(settings.rtl){
			$toast.classList.add(PLUGIN_NAME + '-rtl');
		}

		if (settings.color.length > 0) { //#, rgb, rgba, hsl
			
			if( isColor(settings.color) ){
				$toast.style.background = settings.color;
			} else {
				$toast.classList.add(PLUGIN_NAME+'-color-'+settings.color);
			}
		}
		if (settings.backgroundColor.length > 0) {
			$toast.style.background = settings.backgroundColor;
		}

		if (settings.class){
			$toast.classList.add(settings.class);
		}

		if (settings.image) {
			var $cover = document.createElement("div");
			$cover.classList.add(PLUGIN_NAME + '-cover');
			$cover.style.width = settings.imageWidth + "px";
			$cover.style.backgroundImage = 'url(' + settings.image + ')';
			$toast.appendChild($cover);
		}

		var $buttonClose;
		if(settings.close){
			$buttonClose = document.createElement("button");
			$buttonClose.classList.add(PLUGIN_NAME + '-close');
			$toast.appendChild($buttonClose);
		} else {
			if(settings.rtl){
				$toast.style.paddingLeft = "30px";
			} else {
				$toast.style.paddingRight = "30px";
			}
		}

		if (settings.progressBar) {

			var $progressBar = document.createElement("div");
				$progressBar.classList.add(PLUGIN_NAME + '-progressbar');

			var $progressBarDiv = document.createElement("div");
				$progressBarDiv.style.background = settings.progressBarColor;

			$progressBar.appendChild($progressBarDiv);
			$toast.appendChild($progressBar);
			
			setTimeout(function() {
				moveProgress($toast, settings, function(){
					that.hide(settings, $toast);
				});
			},300);
		}
		else if( settings.progressBar === false && settings.timeout > 0){
			setTimeout(function() {
				that.hide(settings, $toast);
			}, settings.timeout);
		}

		var $toastBody = document.createElement("div");
			$toastBody.classList.add(PLUGIN_NAME + '-body');

		if (settings.image) {
			if(settings.rtl){
				$toastBody.style.marginRight = (settings.imageWidth + 10) + 'px';
			} else {
				$toastBody.style.marginLeft = (settings.imageWidth + 10) + 'px';				
			}
		}

		if (settings.icon) {
			var $icon = document.createElement("i");
				$icon.setAttribute("class", PLUGIN_NAME + '-icon ' + settings.icon);
			
			if (settings.iconText){
				$icon.appendChild(document.createTextNode(settings.iconText));
			}

			if(settings.rtl){
				$toastBody.style.paddingRight = '33px';
			} else {
				$toastBody.style.paddingLeft = '33px';				
			}
			
			if (settings.iconColor){
				$icon.style.color = settings.iconColor;
			}
			$toastBody.appendChild($icon);
		}

		var $strong = document.createElement("strong");
		if (settings.titleColor.length > 0) {
			$strong.style.color = settings.titleColor;
		}
		$strong.appendChild(createFragElem(settings.title));

		var $p = document.createElement("p");
		if (settings.messageColor.length > 0) {
			$p.style.color = settings.messageColor;
		}
		$p.appendChild(createFragElem(settings.message));

		if(settings.layout > 1){
			$toast.classList.add(PLUGIN_NAME+"-layout"+settings.layout);
		}

		if(settings.balloon){
			$toast.classList.add(PLUGIN_NAME+"-balloon");
		}

		$toastBody.appendChild($strong);
		$toastBody.appendChild($p);

		var $buttons;
		if (settings.buttons.length > 0) {

			$buttons = document.createElement("div");
			$buttons.classList.add(PLUGIN_NAME + '-buttons');

			$p.style.marginRight = '15px';

			var i = 0;
			forEach(settings.buttons, function (value, index) {
				$buttons.appendChild(createFragElem(value[0]));

				var $btns = $buttons.childNodes;

				$btns[i].addEventListener('click', function (e) {
					e.preventDefault();
					var ts = value[1];
					return new ts(that, $toast); 
				});

				i++;
			});
			$toastBody.appendChild($buttons);
		}

		$toast.appendChild($toastBody);
		$toastCapsule.style.visibility = 'hidden';
		$toastCapsule.appendChild($toast);

		setTimeout(function() {
			var H = $toast.offsetHeight;
			var style = $toast.currentStyle || window.getComputedStyle($toast);
			var marginTop = style.marginTop;
				marginTop = marginTop.split("px");
				marginTop = parseInt(marginTop[0]);
			var marginBottom = style.marginBottom;
				marginBottom = marginBottom.split("px");
				marginBottom = parseInt(marginBottom[0]);

			$toastCapsule.style.visibility = '';
			$toastCapsule.style.height = (H+marginBottom+marginTop)+'px';
			setTimeout(function() {
				$toastCapsule.style.height = 'auto';
				if(settings.target){
					$toastCapsule.style.overflow = 'visible';
				}
			},1000);
		}, 100);

		var position = settings.position,
			$wrapper;

		if(settings.target){

			$wrapper = document.querySelector(settings.target);
			$wrapper.classList.add(PLUGIN_NAME + '-target');

			if (settings.targetFirst) {
				$wrapper.insertBefore($toastCapsule, $wrapper.firstChild);
			} else {
				$wrapper.appendChild($toastCapsule);
			}

		} else {

			if( POSITIONS.indexOf(settings.position) == -1 ){
				console.warn("["+PLUGIN_NAME+"] Incorrect position.\nIt can be › " + POSITIONS);
				return;
			}

			if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
				if(settings.position == "bottomLeft" || settings.position == "bottomRight" || settings.position == "bottomCenter"){
					position = PLUGIN_NAME+'-wrapper-bottomCenter';
				}
				else if(settings.position == "topLeft" || settings.position == "topRight" || settings.position == "topCenter"){
					position = PLUGIN_NAME+'-wrapper-topCenter';
				}
				else{
					position = PLUGIN_NAME+'-wrapper-center';
				}
			} else {
				position = PLUGIN_NAME+'-wrapper-'+position;
			}
			$wrapper = document.querySelector('.' + PLUGIN_NAME + '-wrapper.'+position);

			if (!$wrapper) {
				$wrapper = document.createElement("div");
				$wrapper.classList.add(PLUGIN_NAME + '-wrapper');
				$wrapper.classList.add(position);
				document.body.appendChild($wrapper);
			}
			if(settings.position == "topLeft" || settings.position == "topCenter" || settings.position == "topRight"){
				$wrapper.insertBefore($toastCapsule, $wrapper.firstChild);
			} else {
				$wrapper.appendChild($toastCapsule);
			}
		}

		if (!isNaN(settings.zindex)) {
			$wrapper.style.zIndex = settings.zindex;
		} else {
			console.warn("["+PLUGIN_NAME+"] Invalid zIndex.");
		}

		settings.onOpen.apply(null, [settings, $toast]);

		try {
			var event;
			if (window.CustomEvent) {
				event = new CustomEvent(PLUGIN_NAME+'-open', {detail: {class: settings.class}});
			} else {
				event = document.createEvent('CustomEvent');
				event.initCustomEvent(PLUGIN_NAME+'-open', true, true, {class: settings.class});
			}
			document.dispatchEvent(event);
		} catch(ex){
			console.warn(ex);
		}

		if(settings.animateInside){
			$toast.classList.add(PLUGIN_NAME+'-animateInside');
		
			var timeAnimation1 = 200;
			var timeAnimation2 = 100;
			var timeAnimation3 = 300;
			if(settings.transitionIn == "bounceInLeft"){
				timeAnimation1 = 400;
				timeAnimation2 = 200;
				timeAnimation3 = 400;
			}

			window.setTimeout(function(){
				$strong.classList.add('slideIn');
			},timeAnimation1);

			window.setTimeout(function(){
				$p.classList.add('slideIn');
			},timeAnimation2);

			if (settings.icon) {
				window.setTimeout(function(){
					$icon.classList.add('revealIn');
				},timeAnimation3);
			}

			if (settings.buttons.length > 0 && $buttons) {
				var counter = 150;
				forEach($buttons.childNodes, function(element, index) {

					window.setTimeout(function(){
						element.classList.add('revealIn');
					},counter);
					counter = counter + counter;
				});
			}
		}
		
		if($buttonClose){
			$buttonClose.addEventListener('click', function (e) {
				var button = e.target;
				that.hide(settings, $toast, 'button');
			});
		}

		if(settings.pauseOnHover){
			
			$toast.addEventListener('mouseenter', function (e) {
				this.classList.add(PLUGIN_NAME+'-paused');
			});
			$toast.addEventListener('mouseleave', function (e) {
				this.classList.remove(PLUGIN_NAME+'-paused');
			});
		}

		if(settings.resetOnHover){

			$toast.addEventListener('mouseenter', function (e) {
				this.classList.add(PLUGIN_NAME+'-reseted');
			});
			$toast.addEventListener('mouseleave', function (e) {
				this.classList.remove(PLUGIN_NAME+'-reseted');
			});
		}

		if(settings.drag){

			if (ACCEPTSTOUCH) {

			    $toast.addEventListener('touchstart', function(e) {
			        drag.startMoving(this, that, settings, e);
			    }, false);

			    $toast.addEventListener('touchend', function(e) {
			        drag.stopMoving(this, e);
			    }, false);
			} else {

			    $toast.addEventListener('mousedown', function(e) {
			    	e.preventDefault();
			        drag.startMoving(this, that, settings, e);
			    }, false);

			    $toast.addEventListener('mouseup', function(e) {
			    	e.preventDefault();
			        drag.stopMoving(this, e);
			    }, false);
			}
		}


	};

	return $iziToast;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))

/***/ }),
/* 111 */
/***/ (function(module, exports) {

var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);

/**
 * Helper class to create a webGL buffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param type {gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER} @mat
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 * @param drawType {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
 */
var Buffer = function(gl, type, data, drawType)
{

	/**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
	this.gl = gl;

	/**
     * The WebGL buffer, created upon instantiation
     *
     * @member {WebGLBuffer}
     */
	this.buffer = gl.createBuffer();

	/**
     * The type of the buffer
     *
     * @member {gl.ARRAY_BUFFER|gl.ELEMENT_ARRAY_BUFFER}
     */
	this.type = type || gl.ARRAY_BUFFER;

	/**
     * The draw type of the buffer
     *
     * @member {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
     */
	this.drawType = drawType || gl.STATIC_DRAW;

	/**
     * The data in the buffer, as a typed array
     *
     * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
     */
	this.data = EMPTY_ARRAY_BUFFER;

	if(data)
	{
		this.upload(data);
	}

	this._updateID = 0;
};

/**
 * Uploads the buffer to the GPU
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data to upload
 * @param offset {Number} if only a subset of the data should be uploaded, this is the amount of data to subtract
 * @param dontBind {Boolean} whether to bind the buffer before uploading it
 */
Buffer.prototype.upload = function(data, offset, dontBind)
{
	// todo - needed?
	if(!dontBind) this.bind();

	var gl = this.gl;

	data = data || this.data;
	offset = offset || 0;

	if(this.data.byteLength >= data.byteLength)
	{
		gl.bufferSubData(this.type, offset, data);
	}
	else
	{
		gl.bufferData(this.type, data, this.drawType);
	}

	this.data = data;
};
/**
 * Binds the buffer
 *
 */
Buffer.prototype.bind = function()
{
	var gl = this.gl;
	gl.bindBuffer(this.type, this.buffer);
};

Buffer.createVertexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType);
};

Buffer.createIndexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType);
};

Buffer.create = function(gl, type, data, drawType)
{
	return new Buffer(gl, type, data, drawType);
};

/**
 * Destroys the buffer
 *
 */
Buffer.prototype.destroy = function(){
	this.gl.deleteBuffer(this.buffer);
};

module.exports = Buffer;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {


var Texture = __webpack_require__(48);

/**
 * Helper class to create a webGL Framebuffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 */
var Framebuffer = function(gl, width, height)
{
    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * The frame buffer
     *
     * @member {WebGLFramebuffer}
     */
    this.framebuffer = gl.createFramebuffer();

    /**
     * The stencil buffer
     *
     * @member {WebGLRenderbuffer}
     */
    this.stencil = null;

    /**
     * The stencil buffer
     *
     * @member {PIXI.glCore.GLTexture}
     */
    this.texture = null;

    /**
     * The width of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.width = width || 100;
    /**
     * The height of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.height = height || 100;
};

/**
 * Adds a texture to the frame buffer
 * @param texture {PIXI.glCore.GLTexture}
 */
Framebuffer.prototype.enableTexture = function(texture)
{
    var gl = this.gl;

    this.texture = texture || new Texture(gl);

    this.texture.bind();

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    this.bind();

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
};

/**
 * Initialises the stencil buffer
 */
Framebuffer.prototype.enableStencil = function()
{
    if(this.stencil)return;

    var gl = this.gl;

    this.stencil = gl.createRenderbuffer();

    gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);

    // TODO.. this is depth AND stencil?
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.width  , this.height );


};

/**
 * Erases the drawing area and fills it with a colour
 * @param  r {Number} the red value of the clearing colour
 * @param  g {Number} the green value of the clearing colour
 * @param  b {Number} the blue value of the clearing colour
 * @param  a {Number} the alpha value of the clearing colour
 */
Framebuffer.prototype.clear = function( r, g, b, a )
{
    this.bind();

    var gl = this.gl;

    gl.clearColor(r, g, b, a);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};

/**
 * Binds the frame buffer to the WebGL context
 */
Framebuffer.prototype.bind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );
};

/**
 * Unbinds the frame buffer to the WebGL context
 */
Framebuffer.prototype.unbind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null );
};
/**
 * Resizes the drawing area of the buffer to the given width and height
 * @param  width  {Number} the new width
 * @param  height {Number} the new height
 */
Framebuffer.prototype.resize = function(width, height)
{
    var gl = this.gl;

    this.width = width;
    this.height = height;

    if ( this.texture )
    {
        this.texture.uploadData(null, width, height);
    }

    if ( this.stencil )
    {
        // update the stencil buffer width and height
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    }
};

/**
 * Destroys this buffer
 */
Framebuffer.prototype.destroy = function()
{
    var gl = this.gl;

    //TODO
    if(this.texture)
    {
        this.texture.destroy();
    }

    gl.deleteFramebuffer(this.framebuffer);

    this.gl = null;

    this.stencil = null;
    this.texture = null;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createRGBA = function(gl, width, height, data)
{
    var texture = Texture.fromData(gl, null, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);

    //fbo.enableStencil(); // get this back on soon!

    fbo.unbind();

    return fbo;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createFloat32 = function(gl, width, height, data)
{
    // create a new texture..
    var texture = new Texture.fromData(gl, data, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);

    fbo.unbind();

    return fbo;
};

module.exports = Framebuffer;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {


var compileProgram = __webpack_require__(50),
	extractAttributes = __webpack_require__(52),
	extractUniforms = __webpack_require__(53),
	setPrecision = __webpack_require__(56),
	generateUniformAccessObject = __webpack_require__(54);

/**
 * Helper class to create a webGL Shader
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param precision {precision]} The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 * @param attributeLocations {object} A key value pair showing which location eact attribute should sit eg {position:0, uvs:1}
 */
var Shader = function(gl, vertexSrc, fragmentSrc, precision, attributeLocations)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;

	if(precision)
	{
		vertexSrc = setPrecision(vertexSrc, precision);
		fragmentSrc = setPrecision(fragmentSrc, precision);
	}

	/**
	 * The shader program
	 *
	 * @member {WebGLProgram}
	 */
	// First compile the program..
	this.program = compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations);

	/**
	 * The attributes of the shader as an object containing the following properties
	 * {
	 * 	type,
	 * 	size,
	 * 	location,
	 * 	pointer
	 * }
	 * @member {Object}
	 */
	// next extract the attributes
	this.attributes = extractAttributes(gl, this.program);

    this.uniformData = extractUniforms(gl, this.program);

	/**
	 * The uniforms of the shader as an object containing the following properties
	 * {
	 * 	gl,
	 * 	data
	 * }
	 * @member {Object}
	 */
	this.uniforms = generateUniformAccessObject( gl, this.uniformData );

};
/**
 * Uses this shader
 */
Shader.prototype.bind = function()
{
	this.gl.useProgram(this.program);
};

/**
 * Destroys this shader
 * TODO
 */
Shader.prototype.destroy = function()
{
	this.attributes = null;
	this.uniformData = null;
	this.uniforms = null;

	var gl = this.gl;
	gl.deleteProgram(this.program);
};


module.exports = Shader;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {


// state object//
var setVertexAttribArrays = __webpack_require__( 49 );

/**
 * Helper class to work with WebGL VertexArrayObjects (vaos)
 * Only works if WebGL extensions are enabled (they usually are)
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 */
function VertexArrayObject(gl, state)
{
    this.nativeVaoExtension = null;

    if(!VertexArrayObject.FORCE_NATIVE)
    {
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') ||
                                  gl.getExtension('MOZ_OES_vertex_array_object') ||
                                  gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    this.nativeState = state;

    if(this.nativeVaoExtension)
    {
        this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();

        var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        // VAO - overwrite the state..
        this.nativeState = {
            tempAttribState: new Array(maxAttribs),
            attribState: new Array(maxAttribs)
        };
    }

    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * An array of attributes
     *
     * @member {Array}
     */
    this.attributes = [];

    /**
     * @member {PIXI.glCore.GLBuffer}
     */
    this.indexBuffer = null;

    /**
     * A boolean flag
     *
     * @member {Boolean}
     */
    this.dirty = false;
}

VertexArrayObject.prototype.constructor = VertexArrayObject;
module.exports = VertexArrayObject;

/**
* Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
* If you find on older devices that things have gone a bit weird then set this to true.
*/
/**
 * Lets the VAO know if you should use the WebGL extension or the native methods.
 * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
 * If you find on older devices that things have gone a bit weird then set this to true.
 * @static
 * @property {Boolean} FORCE_NATIVE
 */
VertexArrayObject.FORCE_NATIVE = false;

/**
 * Binds the buffer
 */
VertexArrayObject.prototype.bind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);

        if(this.dirty)
        {
            this.dirty = false;
            this.activate();
        }
    }
    else
    {

        this.activate();
    }

    return this;
};

/**
 * Unbinds the buffer
 */
VertexArrayObject.prototype.unbind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(null);
    }

    return this;
};

/**
 * Uses this vao
 */
VertexArrayObject.prototype.activate = function()
{

    var gl = this.gl;
    var lastBuffer = null;

    for (var i = 0; i < this.attributes.length; i++)
    {
        var attrib = this.attributes[i];

        if(lastBuffer !== attrib.buffer)
        {
            attrib.buffer.bind();
            lastBuffer = attrib.buffer;
        }

        gl.vertexAttribPointer(attrib.attribute.location,
                               attrib.attribute.size,
                               attrib.type || gl.FLOAT,
                               attrib.normalized || false,
                               attrib.stride || 0,
                               attrib.start || 0);
    }

    setVertexAttribArrays(gl, this.attributes, this.nativeState);

    if(this.indexBuffer)
    {
        this.indexBuffer.bind();
    }

    return this;
};

/**
 *
 * @param buffer     {PIXI.gl.GLBuffer}
 * @param attribute  {*}
 * @param type       {String}
 * @param normalized {Boolean}
 * @param stride     {Number}
 * @param start      {Number}
 */
VertexArrayObject.prototype.addAttribute = function(buffer, attribute, type, normalized, stride, start)
{
    this.attributes.push({
        buffer:     buffer,
        attribute:  attribute,

        location:   attribute.location,
        type:       type || this.gl.FLOAT,
        normalized: normalized || false,
        stride:     stride || 0,
        start:      start || 0
    });

    this.dirty = true;

    return this;
};

/**
 *
 * @param buffer   {PIXI.gl.GLBuffer}
 */
VertexArrayObject.prototype.addIndex = function(buffer/*, options*/)
{
    this.indexBuffer = buffer;

    this.dirty = true;

    return this;
};

/**
 * Unbinds this vao and disables it
 */
VertexArrayObject.prototype.clear = function()
{
    // var gl = this.gl;

    // TODO - should this function unbind after clear?
    // for now, no but lets see what happens in the real world!
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
    }

    this.attributes.length = 0;
    this.indexBuffer = null;

    return this;
};

/**
 * @param type  {Number}
 * @param size  {Number}
 * @param start {Number}
 */
VertexArrayObject.prototype.draw = function(type, size, start)
{
    var gl = this.gl;

    if(this.indexBuffer)
    {
        gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2 );
    }
    else
    {
        // TODO need a better way to calculate size..
        gl.drawArrays(type, start, size || this.getSize());
    }

    return this;
};

/**
 * Destroy this vao
 */
VertexArrayObject.prototype.destroy = function()
{
    // lose references
    this.gl = null;
    this.indexBuffer = null;
    this.attributes = null;
    this.nativeState = null;

    if(this.nativeVao)
    {
        this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);
    }

    this.nativeVaoExtension = null;
    this.nativeVao = null;
};

VertexArrayObject.prototype.getSize = function()
{
    var attrib = this.attributes[0];
    return attrib.buffer.data.length / (( attrib.stride/4 ) || attrib.attribute.size);
};


/***/ }),
/* 115 */
/***/ (function(module, exports) {


/**
 * Helper class to create a webGL Context
 *
 * @class
 * @memberof PIXI.glCore
 * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
 * @param options {Object} An options object that gets passed in to the canvas element containing the context attributes,
 *                         see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext for the options available
 * @return {WebGLRenderingContext} the WebGL context
 */
var createContext = function(canvas, options)
{
    var gl = canvas.getContext('webgl', options) || 
         canvas.getContext('experimental-webgl', options);

    if (!gl)
    {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    return gl;
};

module.exports = createContext;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    compileProgram: __webpack_require__(50),
    defaultValue: __webpack_require__(51),
    extractAttributes: __webpack_require__(52),
    extractUniforms: __webpack_require__(53),
    generateUniformAccessObject: __webpack_require__(54),
    setPrecision: __webpack_require__(56),
    mapSize: __webpack_require__(55),
    mapType: __webpack_require__(26)
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _autoDetectRenderer = __webpack_require__(57);

var _Container = __webpack_require__(11);

var _Container2 = _interopRequireDefault(_Container);

var _ticker = __webpack_require__(33);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Convenience class to create a new PIXI application.
 * This class automatically creates the renderer, ticker
 * and root container.
 *
 * @example
 * // Create the application
 * const app = new PIXI.Application();
 *
 * // Add the view to the DOM
 * document.body.appendChild(app.view);
 *
 * // ex, add display objects
 * app.stage.addChild(PIXI.Sprite.fromImage('something.png'));
 *
 * @class
 * @memberof PIXI
 */
var Application = function () {
  /**
   * @param {number} [width=800] - the width of the renderers view
   * @param {number} [height=600] - the height of the renderers view
   * @param {object} [options] - The optional renderer parameters
   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
   *      need to call toDataUrl on the webgl context
   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
   * @param {boolean} [noWebGL=false] - prevents selection of WebGL renderer, even if such is present
   * @param {boolean} [options.legacy=false] - If true Pixi will aim to ensure compatibility
   * with older / less advanced devices. If you experience unexplained flickering try setting this to true.
   * @param {boolean} [useSharedTicker=false] - `true` to use PIXI.ticker.shared, `false` to create new ticker.
   */
  function Application(width, height, options, noWebGL) {
    var useSharedTicker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    _classCallCheck(this, Application);

    /**
     * WebGL renderer if available, otherwise CanvasRenderer
     * @member {PIXI.WebGLRenderer|PIXI.CanvasRenderer}
     */
    this.renderer = (0, _autoDetectRenderer.autoDetectRenderer)(width, height, options, noWebGL);

    /**
     * The root display container that's rendered.
     * @member {PIXI.Container}
     */
    this.stage = new _Container2.default();

    /**
     * Internal reference to the ticker
     * @member {PIXI.ticker.Ticker}
     * @private
     */
    this._ticker = null;

    /**
     * Ticker for doing render updates.
     * @member {PIXI.ticker.Ticker}
     * @default PIXI.ticker.shared
     */
    this.ticker = useSharedTicker ? _ticker.shared : new _ticker.Ticker();

    // Start the rendering
    this.start();
  }

  /**
   * Render the current stage.
   */
  Application.prototype.render = function render() {
    this.renderer.render(this.stage);
  };

  /**
   * Convenience method for stopping the render.
   */


  Application.prototype.stop = function stop() {
    this._ticker.stop();
  };

  /**
   * Convenience method for starting the render.
   */


  Application.prototype.start = function start() {
    this._ticker.start();
  };

  /**
   * Reference to the renderer's canvas element.
   * @member {HTMLCanvasElement}
   * @readonly
   */


  /**
   * Destroy and don't use after this.
   * @param {Boolean} [removeView=false] Automatically remove canvas from DOM.
   */
  Application.prototype.destroy = function destroy(removeView) {
    this.stop();
    this.ticker = null;

    this.stage.destroy();
    this.stage = null;

    this.renderer.destroy(removeView);
    this.renderer = null;
  };

  _createClass(Application, [{
    key: 'ticker',
    set: function set(ticker) // eslint-disable-line require-jsdoc
    {
      if (this._ticker) {
        this._ticker.remove(this.render, this);
      }
      this._ticker = ticker;
      if (ticker) {
        ticker.add(this.render, this);
      }
    },
    get: function get() // eslint-disable-line require-jsdoc
    {
      return this._ticker;
    }
  }, {
    key: 'view',
    get: function get() {
      return this.renderer.view;
    }

    /**
     * Reference to the renderer's screen rectangle. Its safe to use as filterArea or hitArea for whole screen
     * @member {PIXI.Rectangle}
     * @readonly
     */

  }, {
    key: 'screen',
    get: function get() {
      return this.renderer.screen;
    }
  }]);

  return Application;
}();

exports.default = Application;
//# sourceMappingURL=Application.js.map

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Container2 = __webpack_require__(11);

var _Container3 = _interopRequireDefault(_Container2);

var _RenderTexture = __webpack_require__(32);

var _RenderTexture2 = _interopRequireDefault(_RenderTexture);

var _Texture = __webpack_require__(15);

var _Texture2 = _interopRequireDefault(_Texture);

var _GraphicsData = __webpack_require__(61);

var _GraphicsData2 = _interopRequireDefault(_GraphicsData);

var _Sprite = __webpack_require__(31);

var _Sprite2 = _interopRequireDefault(_Sprite);

var _math = __webpack_require__(2);

var _utils = __webpack_require__(1);

var _const = __webpack_require__(0);

var _Bounds = __webpack_require__(27);

var _Bounds2 = _interopRequireDefault(_Bounds);

var _bezierCurveTo2 = __webpack_require__(120);

var _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);

var _CanvasRenderer = __webpack_require__(12);

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var canvasRenderer = void 0;
var tempMatrix = new _math.Matrix();
var tempPoint = new _math.Point();
var tempColor1 = new Float32Array(4);
var tempColor2 = new Float32Array(4);

/**
 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
 * rectangles to the display, and to color and fill them.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */

var Graphics = function (_Container) {
    _inherits(Graphics, _Container);

    /**
     *
     * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     */
    function Graphics() {
        var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        _classCallCheck(this, Graphics);

        /**
         * The alpha value used when filling the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        var _this = _possibleConstructorReturn(this, _Container.call(this));

        _this.fillAlpha = 1;

        /**
         * The width (thickness) of any lines drawn.
         *
         * @member {number}
         * @default 0
         */
        _this.lineWidth = 0;

        /**
         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         *
         * @member {boolean}
         */
        _this.nativeLines = nativeLines;

        /**
         * The color of any lines drawn.
         *
         * @member {string}
         * @default 0
         */
        _this.lineColor = 0;

        /**
         * Graphics data
         *
         * @member {PIXI.GraphicsData[]}
         * @private
         */
        _this.graphicsData = [];

        /**
         * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to
         * reset the tint.
         *
         * @member {number}
         * @default 0xFFFFFF
         */
        _this.tint = 0xFFFFFF;

        /**
         * The previous tint applied to the graphic shape. Used to compare to the current tint and
         * check if theres change.
         *
         * @member {number}
         * @private
         * @default 0xFFFFFF
         */
        _this._prevTint = 0xFFFFFF;

        /**
         * The blend mode to be applied to the graphic shape. Apply a value of
         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL;
         * @see PIXI.BLEND_MODES
         */
        _this.blendMode = _const.BLEND_MODES.NORMAL;

        /**
         * Current path
         *
         * @member {PIXI.GraphicsData}
         * @private
         */
        _this.currentPath = null;

        /**
         * Array containing some WebGL-related properties used by the WebGL renderer.
         *
         * @member {object<number, object>}
         * @private
         */
        // TODO - _webgl should use a prototype object, not a random undocumented object...
        _this._webGL = {};

        /**
         * Whether this shape is being used as a mask.
         *
         * @member {boolean}
         */
        _this.isMask = false;

        /**
         * The bounds' padding used for bounds calculation.
         *
         * @member {number}
         */
        _this.boundsPadding = 0;

        /**
         * A cache of the local bounds to prevent recalculation.
         *
         * @member {PIXI.Rectangle}
         * @private
         */
        _this._localBounds = new _Bounds2.default();

        /**
         * Used to detect if the graphics object has changed. If this is set to true then the graphics
         * object will be recalculated.
         *
         * @member {boolean}
         * @private
         */
        _this.dirty = 0;

        /**
         * Used to detect if we need to do a fast rect check using the id compare method
         * @type {Number}
         */
        _this.fastRectDirty = -1;

        /**
         * Used to detect if we clear the graphics webGL data
         * @type {Number}
         */
        _this.clearDirty = 0;

        /**
         * Used to detect if we we need to recalculate local bounds
         * @type {Number}
         */
        _this.boundsDirty = -1;

        /**
         * Used to detect if the cached sprite object needs to be updated.
         *
         * @member {boolean}
         * @private
         */
        _this.cachedSpriteDirty = false;

        _this._spriteRect = null;
        _this._fastRect = false;

        /**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */
        return _this;
    }

    /**
     * Creates a new Graphics object with the same values as this one.
     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */


    Graphics.prototype.clone = function clone() {
        var clone = new Graphics();

        clone.renderable = this.renderable;
        clone.fillAlpha = this.fillAlpha;
        clone.lineWidth = this.lineWidth;
        clone.lineColor = this.lineColor;
        clone.tint = this.tint;
        clone.blendMode = this.blendMode;
        clone.isMask = this.isMask;
        clone.boundsPadding = this.boundsPadding;
        clone.dirty = 0;
        clone.cachedSpriteDirty = this.cachedSpriteDirty;

        // copy graphics data
        for (var i = 0; i < this.graphicsData.length; ++i) {
            clone.graphicsData.push(this.graphicsData[i].clone());
        }

        clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];

        clone.updateLocalBounds();

        return clone;
    };

    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.lineStyle = function lineStyle() {
        var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

        this.lineWidth = lineWidth;
        this.lineColor = color;
        this.lineAlpha = alpha;

        if (this.currentPath) {
            if (this.currentPath.shape.points.length) {
                // halfway through a line? start a new one!
                var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));

                shape.closed = false;

                this.drawShape(shape);
            } else {
                // otherwise its empty so lets just set the line properties
                this.currentPath.lineWidth = this.lineWidth;
                this.currentPath.lineColor = this.lineColor;
                this.currentPath.lineAlpha = this.lineAlpha;
            }
        }

        return this;
    };

    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.moveTo = function moveTo(x, y) {
        var shape = new _math.Polygon([x, y]);

        shape.closed = false;
        this.drawShape(shape);

        return this;
    };

    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.lineTo = function lineTo(x, y) {
        this.currentPath.shape.points.push(x, y);
        this.dirty++;

        return this;
    };

    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points = [0, 0];
            }
        } else {
            this.moveTo(0, 0);
        }

        var n = 20;
        var points = this.currentPath.shape.points;
        var xa = 0;
        var ya = 0;

        if (points.length === 0) {
            this.moveTo(0, 0);
        }

        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];

        for (var i = 1; i <= n; ++i) {
            var j = i / n;

            xa = fromX + (cpX - fromX) * j;
            ya = fromY + (cpY - fromY) * j;

            points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
        }

        this.dirty++;

        return this;
    };

    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points = [0, 0];
            }
        } else {
            this.moveTo(0, 0);
        }

        var points = this.currentPath.shape.points;

        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];

        points.length -= 2;

        (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);

        this.dirty++;

        return this;
    };

    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points.push(x1, y1);
            }
        } else {
            this.moveTo(x1, y1);
        }

        var points = this.currentPath.shape.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);

        if (mm < 1.0e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                points.push(x1, y1);
            }
        } else {
            var dd = a1 * a1 + b1 * b1;
            var cc = a2 * a2 + b2 * b2;
            var tt = a1 * a2 + b1 * b2;
            var k1 = radius * Math.sqrt(dd) / mm;
            var k2 = radius * Math.sqrt(cc) / mm;
            var j1 = k1 * tt / dd;
            var j2 = k2 * tt / cc;
            var cx = k1 * b2 + k2 * b1;
            var cy = k1 * a2 + k2 * a1;
            var px = b1 * (k2 + j1);
            var py = a1 * (k2 + j1);
            var qx = b2 * (k1 + j2);
            var qy = a2 * (k1 + j2);
            var startAngle = Math.atan2(py - cy, px - cx);
            var endAngle = Math.atan2(qy - cy, qx - cx);

            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
        }

        this.dirty++;

        return this;
    };

    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {
        var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

        if (startAngle === endAngle) {
            return this;
        }

        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += Math.PI * 2;
        } else if (anticlockwise && startAngle <= endAngle) {
            startAngle += Math.PI * 2;
        }

        var sweep = endAngle - startAngle;
        var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;

        if (sweep === 0) {
            return this;
        }

        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;

        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
        var points = this.currentPath ? this.currentPath.shape.points : null;

        if (points) {
            if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
                points.push(startX, startY);
            }
        } else {
            this.moveTo(startX, startY);
            points = this.currentPath.shape.points;
        }

        var theta = sweep / (segs * 2);
        var theta2 = theta * 2;

        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);

        var segMinus = segs - 1;

        var remainder = segMinus % 1 / segMinus;

        for (var i = 0; i <= segMinus; ++i) {
            var real = i + remainder * i;

            var angle = theta + startAngle + theta2 * real;

            var c = Math.cos(angle);
            var s = -Math.sin(angle);

            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }

        this.dirty++;

        return this;
    };

    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.beginFill = function beginFill() {
        var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        this.filling = true;
        this.fillColor = color;
        this.fillAlpha = alpha;

        if (this.currentPath) {
            if (this.currentPath.shape.points.length <= 2) {
                this.currentPath.fill = this.filling;
                this.currentPath.fillColor = this.fillColor;
                this.currentPath.fillAlpha = this.fillAlpha;
            }
        }

        return this;
    };

    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.endFill = function endFill() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;

        return this;
    };

    /**
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawRect = function drawRect(x, y, width, height) {
        this.drawShape(new _math.Rectangle(x, y, width, height));

        return this;
    };

    /**
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {
        this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));

        return this;
    };

    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {
        this.drawShape(new _math.Circle(x, y, radius));

        return this;
    };

    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {
        this.drawShape(new _math.Ellipse(x, y, width, height));

        return this;
    };

    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.drawPolygon = function drawPolygon(path) {
        // prevents an argument assignment deopt
        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var points = path;

        var closed = true;

        if (points instanceof _math.Polygon) {
            closed = points.closed;
            points = points.points;
        }

        if (!Array.isArray(points)) {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);

            for (var i = 0; i < points.length; ++i) {
                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
            }
        }

        var shape = new _math.Polygon(points);

        shape.closed = closed;

        this.drawShape(shape);

        return this;
    };

    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */


    Graphics.prototype.clear = function clear() {
        if (this.lineWidth || this.filling || this.graphicsData.length > 0) {
            this.lineWidth = 0;
            this.filling = false;

            this.boundsDirty = -1;
            this.dirty++;
            this.clearDirty++;
            this.graphicsData.length = 0;
        }

        this.currentPath = null;
        this._spriteRect = null;

        return this;
    };

    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */


    Graphics.prototype.isFastRect = function isFastRect() {
        return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {
        // if the sprite is not visible or the alpha is 0 then no need to render this element
        if (this.dirty !== this.fastRectDirty) {
            this.fastRectDirty = this.dirty;
            this._fastRect = this.isFastRect();
        }

        // TODO this check can be moved to dirty?
        if (this._fastRect) {
            this._renderSpriteRect(renderer);
        } else {
            renderer.setObjectRenderer(renderer.plugins.graphics);
            renderer.plugins.graphics.render(this);
        }
    };

    /**
     * Renders a sprite rectangle.
     *
     * @private
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {
        var rect = this.graphicsData[0].shape;

        if (!this._spriteRect) {
            this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE));
        }

        var sprite = this._spriteRect;

        if (this.tint === 0xffffff) {
            sprite.tint = this.graphicsData[0].fillColor;
        } else {
            var t1 = tempColor1;
            var t2 = tempColor2;

            (0, _utils.hex2rgb)(this.graphicsData[0].fillColor, t1);
            (0, _utils.hex2rgb)(this.tint, t2);

            t1[0] *= t2[0];
            t1[1] *= t2[1];
            t1[2] *= t2[2];

            sprite.tint = (0, _utils.rgb2hex)(t1);
        }
        sprite.alpha = this.graphicsData[0].fillAlpha;
        sprite.worldAlpha = this.worldAlpha * sprite.alpha;
        sprite.blendMode = this.blendMode;

        sprite.texture._frame.width = rect.width;
        sprite.texture._frame.height = rect.height;

        sprite.transform.worldTransform = this.transform.worldTransform;

        sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);
        sprite._onAnchorUpdate();

        sprite._renderWebGL(renderer);
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */


    Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {
        if (this.isMask === true) {
            return;
        }

        renderer.plugins.graphics.render(this);
    };

    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @private
     */


    Graphics.prototype._calculateBounds = function _calculateBounds() {
        if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.updateLocalBounds();

            this.cachedSpriteDirty = true;
        }

        var lb = this._localBounds;

        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
    };

    /**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */


    Graphics.prototype.containsPoint = function containsPoint(point) {
        this.worldTransform.applyInverse(point, tempPoint);

        var graphicsData = this.graphicsData;

        for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];

            if (!data.fill) {
                continue;
            }

            // only deal with fills..
            if (data.shape) {
                if (data.shape.contains(tempPoint.x, tempPoint.y)) {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Update the bounds of the object
     *
     */


    Graphics.prototype.updateLocalBounds = function updateLocalBounds() {
        var minX = Infinity;
        var maxX = -Infinity;

        var minY = Infinity;
        var maxY = -Infinity;

        if (this.graphicsData.length) {
            var shape = 0;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;

            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                var type = data.type;
                var lineWidth = data.lineWidth;

                shape = data.shape;

                if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {
                    x = shape.x - lineWidth / 2;
                    y = shape.y - lineWidth / 2;
                    w = shape.width + lineWidth;
                    h = shape.height + lineWidth;

                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else if (type === _const.SHAPES.CIRC) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + lineWidth / 2;
                    h = shape.radius + lineWidth / 2;

                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else if (type === _const.SHAPES.ELIP) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + lineWidth / 2;
                    h = shape.height + lineWidth / 2;

                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else {
                    // POLY
                    var points = shape.points;
                    var x2 = 0;
                    var y2 = 0;
                    var dx = 0;
                    var dy = 0;
                    var rw = 0;
                    var rh = 0;
                    var cx = 0;
                    var cy = 0;

                    for (var j = 0; j + 2 < points.length; j += 2) {
                        x = points[j];
                        y = points[j + 1];
                        x2 = points[j + 2];
                        y2 = points[j + 3];
                        dx = Math.abs(x2 - x);
                        dy = Math.abs(y2 - y);
                        h = lineWidth;
                        w = Math.sqrt(dx * dx + dy * dy);

                        if (w < 1e-9) {
                            continue;
                        }

                        rw = (h / w * dy + dx) / 2;
                        rh = (h / w * dx + dy) / 2;
                        cx = (x2 + x) / 2;
                        cy = (y2 + y) / 2;

                        minX = cx - rw < minX ? cx - rw : minX;
                        maxX = cx + rw > maxX ? cx + rw : maxX;

                        minY = cy - rh < minY ? cy - rh : minY;
                        maxY = cy + rh > maxY ? cy + rh : maxY;
                    }
                }
            }
        } else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }

        var padding = this.boundsPadding;

        this._localBounds.minX = minX - padding;
        this._localBounds.maxX = maxX + padding * 2;

        this._localBounds.minY = minY - padding;
        this._localBounds.maxY = maxY + padding * 2;
    };

    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @return {PIXI.GraphicsData} The generated GraphicsData object.
     */


    Graphics.prototype.drawShape = function drawShape(shape) {
        if (this.currentPath) {
            // check current path!
            if (this.currentPath.shape.points.length <= 2) {
                this.graphicsData.pop();
            }
        }

        this.currentPath = null;

        var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, shape);

        this.graphicsData.push(data);

        if (data.type === _const.SHAPES.POLY) {
            data.shape.closed = data.shape.closed || this.filling;
            this.currentPath = data;
        }

        this.dirty++;

        return data;
    };

    /**
     * Generates a canvas texture.
     *
     * @param {number} scaleMode - The scale mode of the texture.
     * @param {number} resolution - The resolution of the texture.
     * @return {PIXI.Texture} The new texture.
     */


    Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {
        var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        var bounds = this.getLocalBounds();

        var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);

        if (!canvasRenderer) {
            canvasRenderer = new _CanvasRenderer2.default();
        }

        this.transform.updateLocalTransform();
        this.transform.localTransform.copy(tempMatrix);

        tempMatrix.invert();

        tempMatrix.tx -= bounds.x;
        tempMatrix.ty -= bounds.y;

        canvasRenderer.render(this, canvasBuffer, true, tempMatrix);

        var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode);

        texture.baseTexture.resolution = resolution;
        texture.baseTexture.update();

        return texture;
    };

    /**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */


    Graphics.prototype.closePath = function closePath() {
        // ok so close path assumes next one is a hole!
        var currentPath = this.currentPath;

        if (currentPath && currentPath.shape) {
            currentPath.shape.close();
        }

        return this;
    };

    /**
     * Adds a hole in the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */


    Graphics.prototype.addHole = function addHole() {
        // this is a hole!
        var hole = this.graphicsData.pop();

        this.currentPath = this.graphicsData[this.graphicsData.length - 1];

        this.currentPath.addHole(hole.shape);
        this.currentPath = null;

        return this;
    };

    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */


    Graphics.prototype.destroy = function destroy(options) {
        _Container.prototype.destroy.call(this, options);

        // destroy each of the GraphicsData objects
        for (var i = 0; i < this.graphicsData.length; ++i) {
            this.graphicsData[i].destroy();
        }

        // for each webgl data entry, destroy the WebGLGraphicsData
        for (var id in this._webgl) {
            for (var j = 0; j < this._webgl[id].data.length; ++j) {
                this._webgl[id].data[j].destroy();
            }
        }

        if (this._spriteRect) {
            this._spriteRect.destroy();
        }

        this.graphicsData = null;

        this.currentPath = null;
        this._webgl = null;
        this._localBounds = null;
    };

    return Graphics;
}(_Container3.default);

exports.default = Graphics;


Graphics._SPRITE_TEXTURE = null;
//# sourceMappingURL=Graphics.js.map

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _CanvasRenderer = __webpack_require__(12);

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _const = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they
 * now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's CanvasGraphicsRenderer:
 * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
 */

/**
 * Renderer dedicated to drawing and batching graphics objects.
 *
 * @class
 * @private
 * @memberof PIXI
 */
var CanvasGraphicsRenderer = function () {
    /**
     * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.
     */
    function CanvasGraphicsRenderer(renderer) {
        _classCallCheck(this, CanvasGraphicsRenderer);

        this.renderer = renderer;
    }

    /**
     * Renders a Graphics object to a canvas.
     *
     * @param {PIXI.Graphics} graphics - the actual graphics object to render
     */


    CanvasGraphicsRenderer.prototype.render = function render(graphics) {
        var renderer = this.renderer;
        var context = renderer.context;
        var worldAlpha = graphics.worldAlpha;
        var transform = graphics.transform.worldTransform;
        var resolution = renderer.resolution;

        // if the tint has changed, set the graphics object to dirty.
        if (this._prevTint !== this.tint) {
            this.dirty = true;
        }

        context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

        if (graphics.dirty) {
            this.updateGraphicsTint(graphics);
            graphics.dirty = false;
        }

        renderer.setBlendMode(graphics.blendMode);

        for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;

            var fillColor = data._fillTint;
            var lineColor = data._lineTint;

            context.lineWidth = data.lineWidth;

            if (data.type === _const.SHAPES.POLY) {
                context.beginPath();

                this.renderPolygon(shape.points, shape.closed, context);

                for (var j = 0; j < data.holes.length; j++) {
                    this.renderPolygon(data.holes[j].points, true, context);
                }

                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === _const.SHAPES.RECT) {
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fillRect(shape.x, shape.y, shape.width, shape.height);
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.strokeRect(shape.x, shape.y, shape.width, shape.height);
                }
            } else if (data.type === _const.SHAPES.CIRC) {
                // TODO - need to be Undefined!
                context.beginPath();
                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                context.closePath();

                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === _const.SHAPES.ELIP) {
                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

                var w = shape.width * 2;
                var h = shape.height * 2;

                var x = shape.x - w / 2;
                var y = shape.y - h / 2;

                context.beginPath();

                var kappa = 0.5522848;
                var ox = w / 2 * kappa; // control point offset horizontal
                var oy = h / 2 * kappa; // control point offset vertical
                var xe = x + w; // x-end
                var ye = y + h; // y-end
                var xm = x + w / 2; // x-middle
                var ym = y + h / 2; // y-middle

                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

                context.closePath();

                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === _const.SHAPES.RREC) {
                var rx = shape.x;
                var ry = shape.y;
                var width = shape.width;
                var height = shape.height;
                var radius = shape.radius;

                var maxRadius = Math.min(width, height) / 2 | 0;

                radius = radius > maxRadius ? maxRadius : radius;

                context.beginPath();
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();

                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }

                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            }
        }
    };

    /**
     * Updates the tint of a graphics object
     *
     * @private
     * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated
     */


    CanvasGraphicsRenderer.prototype.updateGraphicsTint = function updateGraphicsTint(graphics) {
        graphics._prevTint = graphics.tint;

        var tintR = (graphics.tint >> 16 & 0xFF) / 255;
        var tintG = (graphics.tint >> 8 & 0xFF) / 255;
        var tintB = (graphics.tint & 0xFF) / 255;

        for (var i = 0; i < graphics.graphicsData.length; ++i) {
            var data = graphics.graphicsData[i];

            var fillColor = data.fillColor | 0;
            var lineColor = data.lineColor | 0;

            // super inline cos im an optimization NAZI :)
            data._fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;

            data._lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255;
        }
    };

    /**
     * Renders a polygon.
     *
     * @param {PIXI.Point[]} points - The points to render
     * @param {boolean} close - Should the polygon be closed
     * @param {CanvasRenderingContext2D} context - The rendering context to use
     */


    CanvasGraphicsRenderer.prototype.renderPolygon = function renderPolygon(points, close, context) {
        context.moveTo(points[0], points[1]);

        for (var j = 1; j < points.length / 2; ++j) {
            context.lineTo(points[j * 2], points[j * 2 + 1]);
        }

        if (close) {
            context.closePath();
        }
    };

    /**
     * destroy graphics object
     *
     */


    CanvasGraphicsRenderer.prototype.destroy = function destroy() {
        this.renderer = null;
    };

    return CanvasGraphicsRenderer;
}();

exports.default = CanvasGraphicsRenderer;


_CanvasRenderer2.default.registerPlugin('graphics', CanvasGraphicsRenderer);
//# sourceMappingURL=CanvasGraphicsRenderer.js.map

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = bezierCurveTo;
/**
 * Calculate the points for a bezier curve and then draws it.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @param {number} fromX - Starting point x
 * @param {number} fromY - Starting point y
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} cpX2 - Second Control point x
 * @param {number} cpY2 - Second Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [path=[]] - Path array to push points into
 * @return {number[]} Array of points of the curve
 */
function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    var path = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];

    var n = 20;
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;

    path.push(fromX, fromY);

    for (var i = 1, j = 0; i <= n; ++i) {
        j = i / n;

        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }

    return path;
}
//# sourceMappingURL=bezierCurveTo.js.map

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(1);

var _const = __webpack_require__(0);

var _ObjectRenderer2 = __webpack_require__(20);

var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

var _WebGLRenderer = __webpack_require__(19);

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

var _WebGLGraphicsData = __webpack_require__(122);

var _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);

var _PrimitiveShader = __webpack_require__(123);

var _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);

var _buildPoly = __webpack_require__(125);

var _buildPoly2 = _interopRequireDefault(_buildPoly);

var _buildRectangle = __webpack_require__(126);

var _buildRectangle2 = _interopRequireDefault(_buildRectangle);

var _buildRoundedRectangle = __webpack_require__(127);

var _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);

var _buildCircle = __webpack_require__(124);

var _buildCircle2 = _interopRequireDefault(_buildCircle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Renders the graphics object.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 */
var GraphicsRenderer = function (_ObjectRenderer) {
    _inherits(GraphicsRenderer, _ObjectRenderer);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.
     */
    function GraphicsRenderer(renderer) {
        _classCallCheck(this, GraphicsRenderer);

        var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));

        _this.graphicsDataPool = [];

        _this.primitiveShader = null;

        _this.gl = renderer.gl;

        // easy access!
        _this.CONTEXT_UID = 0;
        return _this;
    }

    /**
     * Called when there is a WebGL context change
     *
     * @private
     *
     */


    GraphicsRenderer.prototype.onContextChange = function onContextChange() {
        this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.primitiveShader = new _PrimitiveShader2.default(this.gl);
    };

    /**
     * Destroys this renderer.
     *
     */


    GraphicsRenderer.prototype.destroy = function destroy() {
        _ObjectRenderer3.default.prototype.destroy.call(this);

        for (var i = 0; i < this.graphicsDataPool.length; ++i) {
            this.graphicsDataPool[i].destroy();
        }

        this.graphicsDataPool = null;
    };

    /**
     * Renders a graphics object.
     *
     * @param {PIXI.Graphics} graphics - The graphics object to render.
     */


    GraphicsRenderer.prototype.render = function render(graphics) {
        var renderer = this.renderer;
        var gl = renderer.gl;

        var webGLData = void 0;
        var webGL = graphics._webGL[this.CONTEXT_UID];

        if (!webGL || graphics.dirty !== webGL.dirty) {
            this.updateGraphics(graphics);

            webGL = graphics._webGL[this.CONTEXT_UID];
        }

        // This  could be speeded up for sure!
        var shader = this.primitiveShader;

        renderer.bindShader(shader);
        renderer.state.setBlendMode(graphics.blendMode);

        for (var i = 0, n = webGL.data.length; i < n; i++) {
            webGLData = webGL.data[i];
            var shaderTemp = webGLData.shader;

            renderer.bindShader(shaderTemp);
            shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);
            shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);
            shaderTemp.uniforms.alpha = graphics.worldAlpha;

            renderer.bindVao(webGLData.vao);

            if (graphics.nativeLines) {
                gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);
            } else {
                webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);
            }
        }
    };

    /**
     * Updates the graphics object
     *
     * @private
     * @param {PIXI.Graphics} graphics - The graphics object to update
     */


    GraphicsRenderer.prototype.updateGraphics = function updateGraphics(graphics) {
        var gl = this.renderer.gl;

        // get the contexts graphics object
        var webGL = graphics._webGL[this.CONTEXT_UID];

        // if the graphics object does not exist in the webGL context time to create it!
        if (!webGL) {
            webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 };
        }

        // flag the graphics as not dirty as we are about to update it...
        webGL.dirty = graphics.dirty;

        // if the user cleared the graphics object we will need to clear every object
        if (graphics.clearDirty !== webGL.clearDirty) {
            webGL.clearDirty = graphics.clearDirty;

            // loop through and return all the webGLDatas to the object pool so than can be reused later on
            for (var i = 0; i < webGL.data.length; i++) {
                this.graphicsDataPool.push(webGL.data[i]);
            }

            // clear the array and reset the index..
            webGL.data.length = 0;
            webGL.lastIndex = 0;
        }

        var webGLData = void 0;

        // loop through the graphics datas and construct each one..
        // if the object is a complex fill then the new stencil buffer technique will be used
        // other wise graphics objects will be pushed into a batch..
        for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {
            var data = graphics.graphicsData[_i];

            // TODO - this can be simplified
            webGLData = this.getWebGLData(webGL, 0);

            if (data.type === _const.SHAPES.POLY) {
                (0, _buildPoly2.default)(data, webGLData);
            }
            if (data.type === _const.SHAPES.RECT) {
                (0, _buildRectangle2.default)(data, webGLData);
            } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {
                (0, _buildCircle2.default)(data, webGLData);
            } else if (data.type === _const.SHAPES.RREC) {
                (0, _buildRoundedRectangle2.default)(data, webGLData);
            }

            webGL.lastIndex++;
        }

        this.renderer.bindVao(null);

        // upload all the dirty data...
        for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {
            webGLData = webGL.data[_i2];

            if (webGLData.dirty) {
                webGLData.upload();
            }
        }
    };

    /**
     *
     * @private
     * @param {WebGLRenderingContext} gl - the current WebGL drawing context
     * @param {number} type - TODO @Alvin
     * @return {*} TODO
     */


    GraphicsRenderer.prototype.getWebGLData = function getWebGLData(gl, type) {
        var webGLData = gl.data[gl.data.length - 1];

        if (!webGLData || webGLData.points.length > 320000) {
            webGLData = this.graphicsDataPool.pop() || new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);

            webGLData.reset(type);
            gl.data.push(webGLData);
        }

        webGLData.dirty = true;

        return webGLData;
    };

    return GraphicsRenderer;
}(_ObjectRenderer3.default);

exports.default = GraphicsRenderer;


_WebGLRenderer2.default.registerPlugin('graphics', GraphicsRenderer);
//# sourceMappingURL=GraphicsRenderer.js.map

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pixiGlCore = __webpack_require__(4);

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An object containing WebGL specific properties to be used by the WebGL renderer
 *
 * @class
 * @private
 * @memberof PIXI
 */
var WebGLGraphicsData = function () {
  /**
   * @param {WebGLRenderingContext} gl - The current WebGL drawing context
   * @param {PIXI.Shader} shader - The shader
   * @param {object} attribsState - The state for the VAO
   */
  function WebGLGraphicsData(gl, shader, attribsState) {
    _classCallCheck(this, WebGLGraphicsData);

    /**
     * The current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // TODO does this need to be split before uploading??
    /**
     * An array of color components (r,g,b)
     * @member {number[]}
     */
    this.color = [0, 0, 0]; // color split!

    /**
     * An array of points to draw
     * @member {PIXI.Point[]}
     */
    this.points = [];

    /**
     * The indices of the vertices
     * @member {number[]}
     */
    this.indices = [];
    /**
     * The main buffer
     * @member {WebGLBuffer}
     */
    this.buffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl);

    /**
     * The index buffer
     * @member {WebGLBuffer}
     */
    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl);

    /**
     * Whether this graphics is dirty or not
     * @member {boolean}
     */
    this.dirty = true;

    this.glPoints = null;
    this.glIndices = null;

    /**
     *
     * @member {PIXI.Shader}
     */
    this.shader = shader;

    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, attribsState).addIndex(this.indexBuffer).addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4);
  }

  /**
   * Resets the vertices and the indices
   */


  WebGLGraphicsData.prototype.reset = function reset() {
    this.points.length = 0;
    this.indices.length = 0;
  };

  /**
   * Binds the buffers and uploads the data
   */


  WebGLGraphicsData.prototype.upload = function upload() {
    this.glPoints = new Float32Array(this.points);
    this.buffer.upload(this.glPoints);

    this.glIndices = new Uint16Array(this.indices);
    this.indexBuffer.upload(this.glIndices);

    this.dirty = false;
  };

  /**
   * Empties all the data
   */


  WebGLGraphicsData.prototype.destroy = function destroy() {
    this.color = null;
    this.points = null;
    this.indices = null;

    this.vao.destroy();
    this.buffer.destroy();
    this.indexBuffer.destroy();

    this.gl = null;

    this.buffer = null;
    this.indexBuffer = null;

    this.glPoints = null;
    this.glIndices = null;
  };

  return WebGLGraphicsData;
}();

exports.default = WebGLGraphicsData;
//# sourceMappingURL=WebGLGraphicsData.js.map

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Shader2 = __webpack_require__(17);

var _Shader3 = _interopRequireDefault(_Shader2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 */
var PrimitiveShader = function (_Shader) {
    _inherits(PrimitiveShader, _Shader);

    /**
     * @param {WebGLRenderingContext} gl - The webgl shader manager this shader works for.
     */
    function PrimitiveShader(gl) {
        _classCallCheck(this, PrimitiveShader);

        return _possibleConstructorReturn(this, _Shader.call(this, gl,
        // vertex shader
        ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'),
        // fragment shader
        ['varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n')));
    }

    return PrimitiveShader;
}(_Shader3.default);

exports.default = PrimitiveShader;
//# sourceMappingURL=PrimitiveShader.js.map

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = buildCircle;

var _buildLine = __webpack_require__(18);

var _buildLine2 = _interopRequireDefault(_buildLine);

var _const = __webpack_require__(0);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a circle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildCircle(graphicsData, webGLData) {
    // need to convert points to a nice regular data
    var circleData = graphicsData.shape;
    var x = circleData.x;
    var y = circleData.y;
    var width = void 0;
    var height = void 0;

    // TODO - bit hacky??
    if (graphicsData.type === _const.SHAPES.CIRC) {
        width = circleData.radius;
        height = circleData.radius;
    } else {
        width = circleData.width;
        height = circleData.height;
    }

    if (width === 0 || height === 0) {
        return;
    }

    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));

    var seg = Math.PI * 2 / totalSegs;

    if (graphicsData.fill) {
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length / 6;

        indices.push(vecPos);

        for (var i = 0; i < totalSegs + 1; i++) {
            verts.push(x, y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos - 1);
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (var _i = 0; _i < totalSegs + 1; _i++) {
            graphicsData.points.push(x + Math.sin(seg * _i) * width, y + Math.cos(seg * _i) * height);
        }

        (0, _buildLine2.default)(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}
//# sourceMappingURL=buildCircle.js.map

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = buildPoly;

var _buildLine = __webpack_require__(18);

var _buildLine2 = _interopRequireDefault(_buildLine);

var _utils = __webpack_require__(1);

var _earcut = __webpack_require__(45);

var _earcut2 = _interopRequireDefault(_earcut);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a polygon to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildPoly(graphicsData, webGLData) {
    graphicsData.points = graphicsData.shape.points.slice();

    var points = graphicsData.points;

    if (graphicsData.fill && points.length >= 6) {
        var holeArray = [];
        // Process holes..
        var holes = graphicsData.holes;

        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];

            holeArray.push(points.length / 2);

            points = points.concat(hole.points);
        }

        // get first and last point.. figure out the middle!
        var verts = webGLData.points;
        var indices = webGLData.indices;

        var length = points.length / 2;

        // sort color
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var triangles = (0, _earcut2.default)(points, holeArray, 2);

        if (!triangles) {
            return;
        }

        var vertPos = verts.length / 6;

        for (var _i = 0; _i < triangles.length; _i += 3) {
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i + 1] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
        }

        for (var _i2 = 0; _i2 < length; _i2++) {
            verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth > 0) {
        (0, _buildLine2.default)(graphicsData, webGLData);
    }
}
//# sourceMappingURL=buildPoly.js.map

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = buildRectangle;

var _buildLine = __webpack_require__(18);

var _buildLine2 = _interopRequireDefault(_buildLine);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildRectangle(graphicsData, webGLData) {
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;

    if (graphicsData.fill) {
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length / 6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x, y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];

        (0, _buildLine2.default)(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}
//# sourceMappingURL=buildRectangle.js.map

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = buildRoundedRectangle;

var _earcut = __webpack_require__(45);

var _earcut2 = _interopRequireDefault(_earcut);

var _buildLine = __webpack_require__(18);

var _buildLine2 = _interopRequireDefault(_buildLine);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Builds a rounded rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildRoundedRectangle(graphicsData, webGLData) {
    var rrectData = graphicsData.shape;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;

    var radius = rrectData.radius;

    var recPoints = [];

    recPoints.push(x, y + radius);
    quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
    quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
    quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
    quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);

    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
    // TODO - fix this properly, this is not very elegant.. but it works for now.

    if (graphicsData.fill) {
        var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length / 6;

        var triangles = (0, _earcut2.default)(recPoints, null, 2);

        for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }

        for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {
            verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        (0, _buildLine2.default)(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}

/**
 * Calculate a single point for a quadratic bezier curve.
 * Utility function used by quadraticBezierCurve.
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} n1 - first number
 * @param {number} n2 - second number
 * @param {number} perc - percentage
 * @return {number} the result
 *
 */
function getPt(n1, n2, perc) {
    var diff = n2 - n1;

    return n1 + diff * perc;
}

/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {
    var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];

    var n = 20;
    var points = out;

    var xa = 0;
    var ya = 0;
    var xb = 0;
    var yb = 0;
    var x = 0;
    var y = 0;

    for (var i = 0, j = 0; i <= n; ++i) {
        j = i / n;

        // The Green Line
        xa = getPt(fromX, cpX, j);
        ya = getPt(fromY, cpY, j);
        xb = getPt(cpX, toX, j);
        yb = getPt(cpY, toY, j);

        // The Black Dot
        x = getPt(xa, xb, j);
        y = getPt(ya, yb, j);

        points.push(x, y);
    }

    return points;
}
//# sourceMappingURL=buildRoundedRectangle.js.map

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 * An observable point is a point that triggers a callback when the point's position is changed.
 *
 * @class
 * @memberof PIXI
 */
var ObservablePoint = function () {
    /**
     * @param {Function} cb - callback when changed
     * @param {object} scope - owner of callback
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    function ObservablePoint(cb, scope) {
        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        _classCallCheck(this, ObservablePoint);

        this._x = x;
        this._y = y;

        this.cb = cb;
        this.scope = scope;
    }

    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */


    ObservablePoint.prototype.set = function set(x, y) {
        var _x = x || 0;
        var _y = y || (y !== 0 ? _x : 0);

        if (this._x !== _x || this._y !== _y) {
            this._x = _x;
            this._y = _y;
            this.cb.call(this.scope);
        }
    };

    /**
     * Copies the data from another point
     *
     * @param {PIXI.Point|PIXI.ObservablePoint} point - point to copy from
     */


    ObservablePoint.prototype.copy = function copy(point) {
        if (this._x !== point.x || this._y !== point.y) {
            this._x = point.x;
            this._y = point.y;
            this.cb.call(this.scope);
        }
    };

    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */


    _createClass(ObservablePoint, [{
        key: "x",
        get: function get() {
            return this._x;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._x !== value) {
                this._x = value;
                this.cb.call(this.scope);
            }
        }

        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         *
         * @member {number}
         */

    }, {
        key: "y",
        get: function get() {
            return this._y;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            if (this._y !== value) {
                this._y = value;
                this.cb.call(this.scope);
            }
        }
    }]);

    return ObservablePoint;
}();

exports.default = ObservablePoint;
//# sourceMappingURL=ObservablePoint.js.map

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Rectangle = __webpack_require__(30);

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _const = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */
var Circle = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this circle
   * @param {number} [y=0] - The Y coordinate of the center of this circle
   * @param {number} [radius=0] - The radius of the circle
   */
  function Circle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Circle);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.CIRC
     * @see PIXI.SHAPES
     */
    this.type = _const.SHAPES.CIRC;
  }

  /**
   * Creates a clone of this Circle instance
   *
   * @return {PIXI.Circle} a copy of the Circle
   */


  Circle.prototype.clone = function clone() {
    return new Circle(this.x, this.y, this.radius);
  };

  /**
   * Checks whether the x and y coordinates given are contained within this circle
   *
   * @param {number} x - The X coordinate of the point to test
   * @param {number} y - The Y coordinate of the point to test
   * @return {boolean} Whether the x/y coordinates are within this Circle
   */


  Circle.prototype.contains = function contains(x, y) {
    if (this.radius <= 0) {
      return false;
    }

    var r2 = this.radius * this.radius;
    var dx = this.x - x;
    var dy = this.y - y;

    dx *= dx;
    dy *= dy;

    return dx + dy <= r2;
  };

  /**
  * Returns the framing rectangle of the circle as a Rectangle object
  *
  * @return {PIXI.Rectangle} the framing rectangle
  */


  Circle.prototype.getBounds = function getBounds() {
    return new _Rectangle2.default(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  };

  return Circle;
}();

exports.default = Circle;
//# sourceMappingURL=Circle.js.map

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Rectangle = __webpack_require__(30);

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _const = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */
var Ellipse = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this circle
   * @param {number} [y=0] - The Y coordinate of the center of this circle
   * @param {number} [width=0] - The half width of this ellipse
   * @param {number} [height=0] - The half height of this ellipse
   */
  function Ellipse() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Ellipse);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.ELIP
     * @see PIXI.SHAPES
     */
    this.type = _const.SHAPES.ELIP;
  }

  /**
   * Creates a clone of this Ellipse instance
   *
   * @return {PIXI.Ellipse} a copy of the ellipse
   */


  Ellipse.prototype.clone = function clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  };

  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   *
   * @param {number} x - The X coordinate of the point to test
   * @param {number} y - The Y coordinate of the point to test
   * @return {boolean} Whether the x/y coords are within this ellipse
   */


  Ellipse.prototype.contains = function contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }

    // normalize the coords to an ellipse with center 0,0
    var normx = (x - this.x) / this.width;
    var normy = (y - this.y) / this.height;

    normx *= normx;
    normy *= normy;

    return normx + normy <= 1;
  };

  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   *
   * @return {PIXI.Rectangle} the framing rectangle
   */


  Ellipse.prototype.getBounds = function getBounds() {
    return new _Rectangle2.default(this.x - this.width, this.y - this.height, this.width, this.height);
  };

  return Ellipse;
}();

exports.default = Ellipse;
//# sourceMappingURL=Ellipse.js.map

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _Point = __webpack_require__(29);

var _Point2 = _interopRequireDefault(_Point);

var _const = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var Polygon = function () {
    /**
     * @param {PIXI.Point[]|number[]} points - This can be an array of Points
     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
     *  the arguments passed can be all the points of the polygon e.g.
     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
     */
    function Polygon() {
        for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
            points[_key] = arguments[_key];
        }

        _classCallCheck(this, Polygon);

        if (Array.isArray(points[0])) {
            points = points[0];
        }

        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof _Point2.default) {
            var p = [];

            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }

            points = p;
        }

        this.closed = true;

        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = _const.SHAPES.POLY;
    }

    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */


    Polygon.prototype.clone = function clone() {
        return new Polygon(this.points.slice());
    };

    /**
     * Closes the polygon, adding points if necessary.
     *
     */


    Polygon.prototype.close = function close() {
        var points = this.points;

        // close the poly if the value is true!
        if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
            points.push(points[0], points[1]);
        }
    };

    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */


    Polygon.prototype.contains = function contains(x, y) {
        var inside = false;

        // use some raycasting to test hits
        // https://github.com/substack/point-in-polygon/blob/master/index.js
        var length = this.points.length / 2;

        for (var i = 0, j = length - 1; i < length; j = i++) {
            var xi = this.points[i * 2];
            var yi = this.points[i * 2 + 1];
            var xj = this.points[j * 2];
            var yj = this.points[j * 2 + 1];
            var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;

            if (intersect) {
                inside = !inside;
            }
        }

        return inside;
    };

    return Polygon;
}();

exports.default = Polygon;
//# sourceMappingURL=Polygon.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _const = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its
 * top-left corner point (x, y) and by its width and its height and its radius.
 *
 * @class
 * @memberof PIXI
 */
var RoundedRectangle = function () {
    /**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [width=0] - The overall width of this rounded rectangle
     * @param {number} [height=0] - The overall height of this rounded rectangle
     * @param {number} [radius=20] - Controls the radius of the rounded corners
     */
    function RoundedRectangle() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;

        _classCallCheck(this, RoundedRectangle);

        /**
         * @member {number}
         * @default 0
         */
        this.x = x;

        /**
         * @member {number}
         * @default 0
         */
        this.y = y;

        /**
         * @member {number}
         * @default 0
         */
        this.width = width;

        /**
         * @member {number}
         * @default 0
         */
        this.height = height;

        /**
         * @member {number}
         * @default 20
         */
        this.radius = radius;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */
        this.type = _const.SHAPES.RREC;
    }

    /**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */


    RoundedRectangle.prototype.clone = function clone() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    };

    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */


    RoundedRectangle.prototype.contains = function contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
                if (y >= this.y + this.radius && y <= this.y + this.height - this.radius || x >= this.x + this.radius && x <= this.x + this.width - this.radius) {
                    return true;
                }
                var dx = x - (this.x + this.radius);
                var dy = y - (this.y + this.radius);
                var radius2 = this.radius * this.radius;

                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.width - this.radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dy = y - (this.y + this.height - this.radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
            }
        }

        return false;
    };

    return RoundedRectangle;
}();

exports.default = RoundedRectangle;
//# sourceMappingURL=RoundedRectangle.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _const = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A set of functions used to handle masking.
 *
 * @class
 * @memberof PIXI
 */
var CanvasMaskManager = function () {
    /**
     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.
     */
    function CanvasMaskManager(renderer) {
        _classCallCheck(this, CanvasMaskManager);

        this.renderer = renderer;
    }

    /**
     * This method adds it to the current stack of masks.
     *
     * @param {object} maskData - the maskData that will be pushed
     */


    CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {
        var renderer = this.renderer;

        renderer.context.save();

        var cacheAlpha = maskData.alpha;
        var transform = maskData.transform.worldTransform;
        var resolution = renderer.resolution;

        renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

        // TODO suport sprite alpha masks??
        // lots of effort required. If demand is great enough..
        if (!maskData._texture) {
            this.renderGraphicsShape(maskData);
            renderer.context.clip();
        }

        maskData.worldAlpha = cacheAlpha;
    };

    /**
     * Renders a PIXI.Graphics shape.
     *
     * @param {PIXI.Graphics} graphics - The object to render.
     */


    CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {
        var context = this.renderer.context;
        var len = graphics.graphicsData.length;

        if (len === 0) {
            return;
        }

        context.beginPath();

        for (var i = 0; i < len; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;

            if (data.type === _const.SHAPES.POLY) {
                var points = shape.points;

                context.moveTo(points[0], points[1]);

                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }

                // if the first and last point are the same close the path - much neater :)
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }
            } else if (data.type === _const.SHAPES.RECT) {
                context.rect(shape.x, shape.y, shape.width, shape.height);
                context.closePath();
            } else if (data.type === _const.SHAPES.CIRC) {
                // TODO - need to be Undefined!
                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                context.closePath();
            } else if (data.type === _const.SHAPES.ELIP) {
                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

                var w = shape.width * 2;
                var h = shape.height * 2;

                var x = shape.x - w / 2;
                var y = shape.y - h / 2;

                var kappa = 0.5522848;
                var ox = w / 2 * kappa; // control point offset horizontal
                var oy = h / 2 * kappa; // control point offset vertical
                var xe = x + w; // x-end
                var ye = y + h; // y-end
                var xm = x + w / 2; // x-middle
                var ym = y + h / 2; // y-middle

                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
            } else if (data.type === _const.SHAPES.RREC) {
                var rx = shape.x;
                var ry = shape.y;
                var width = shape.width;
                var height = shape.height;
                var radius = shape.radius;

                var maxRadius = Math.min(width, height) / 2 | 0;

                radius = radius > maxRadius ? maxRadius : radius;

                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
            }
        }
    };

    /**
     * Restores the current drawing context to the state it was before the mask was applied.
     *
     * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.
     */


    CanvasMaskManager.prototype.popMask = function popMask(renderer) {
        renderer.context.restore();
    };

    /**
     * Destroys this canvas mask manager.
     *
     */


    CanvasMaskManager.prototype.destroy = function destroy() {
        /* empty */
    };

    return CanvasMaskManager;
}();

exports.default = CanvasMaskManager;
//# sourceMappingURL=CanvasMaskManager.js.map

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = mapCanvasBlendModesToPixi;

var _const = __webpack_require__(0);

var _canUseNewCanvasBlendModes = __webpack_require__(67);

var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Maps blend combinations to Canvas.
 *
 * @memberof PIXI
 * @function mapCanvasBlendModesToPixi
 * @private
 * @param {string[]} [array=[]] - The array to output into.
 * @return {string[]} Mapped modes.
 */
function mapCanvasBlendModesToPixi() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if ((0, _canUseNewCanvasBlendModes2.default)()) {
        array[_const.BLEND_MODES.NORMAL] = 'source-over';
        array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
        array[_const.BLEND_MODES.MULTIPLY] = 'multiply';
        array[_const.BLEND_MODES.SCREEN] = 'screen';
        array[_const.BLEND_MODES.OVERLAY] = 'overlay';
        array[_const.BLEND_MODES.DARKEN] = 'darken';
        array[_const.BLEND_MODES.LIGHTEN] = 'lighten';
        array[_const.BLEND_MODES.COLOR_DODGE] = 'color-dodge';
        array[_const.BLEND_MODES.COLOR_BURN] = 'color-burn';
        array[_const.BLEND_MODES.HARD_LIGHT] = 'hard-light';
        array[_const.BLEND_MODES.SOFT_LIGHT] = 'soft-light';
        array[_const.BLEND_MODES.DIFFERENCE] = 'difference';
        array[_const.BLEND_MODES.EXCLUSION] = 'exclusion';
        array[_const.BLEND_MODES.HUE] = 'hue';
        array[_const.BLEND_MODES.SATURATION] = 'saturate';
        array[_const.BLEND_MODES.COLOR] = 'color';
        array[_const.BLEND_MODES.LUMINOSITY] = 'luminosity';
    } else {
        // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
        array[_const.BLEND_MODES.NORMAL] = 'source-over';
        array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
        array[_const.BLEND_MODES.MULTIPLY] = 'source-over';
        array[_const.BLEND_MODES.SCREEN] = 'source-over';
        array[_const.BLEND_MODES.OVERLAY] = 'source-over';
        array[_const.BLEND_MODES.DARKEN] = 'source-over';
        array[_const.BLEND_MODES.LIGHTEN] = 'source-over';
        array[_const.BLEND_MODES.COLOR_DODGE] = 'source-over';
        array[_const.BLEND_MODES.COLOR_BURN] = 'source-over';
        array[_const.BLEND_MODES.HARD_LIGHT] = 'source-over';
        array[_const.BLEND_MODES.SOFT_LIGHT] = 'source-over';
        array[_const.BLEND_MODES.DIFFERENCE] = 'source-over';
        array[_const.BLEND_MODES.EXCLUSION] = 'source-over';
        array[_const.BLEND_MODES.HUE] = 'source-over';
        array[_const.BLEND_MODES.SATURATION] = 'source-over';
        array[_const.BLEND_MODES.COLOR] = 'source-over';
        array[_const.BLEND_MODES.LUMINOSITY] = 'source-over';
    }

    return array;
}
//# sourceMappingURL=mapCanvasBlendModesToPixi.js.map

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged
 * up with textures that are no longer being used.
 *
 * @class
 * @memberof PIXI
 */
var TextureGarbageCollector = function () {
    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function TextureGarbageCollector(renderer) {
        _classCallCheck(this, TextureGarbageCollector);

        this.renderer = renderer;

        this.count = 0;
        this.checkCount = 0;
        this.maxIdle = _settings2.default.GC_MAX_IDLE;
        this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;
        this.mode = _settings2.default.GC_MODE;
    }

    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */


    TextureGarbageCollector.prototype.update = function update() {
        this.count++;

        if (this.mode === _const.GC_MODES.MANUAL) {
            return;
        }

        this.checkCount++;

        if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;

            this.run();
        }
    };

    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */


    TextureGarbageCollector.prototype.run = function run() {
        var tm = this.renderer.textureManager;
        var managedTextures = tm._managedTextures;
        var wasRemoved = false;

        for (var i = 0; i < managedTextures.length; i++) {
            var texture = managedTextures[i];

            // only supports non generated textures at the moment!
            if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) {
                tm.destroyTexture(texture, true);
                managedTextures[i] = null;
                wasRemoved = true;
            }
        }

        if (wasRemoved) {
            var j = 0;

            for (var _i = 0; _i < managedTextures.length; _i++) {
                if (managedTextures[_i] !== null) {
                    managedTextures[j++] = managedTextures[_i];
                }
            }

            managedTextures.length = j;
        }
    };

    /**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */


    TextureGarbageCollector.prototype.unload = function unload(displayObject) {
        var tm = this.renderer.textureManager;

        // only destroy non generated textures
        if (displayObject._texture && displayObject._texture._glRenderTargets) {
            tm.destroyTexture(displayObject._texture, true);
        }

        for (var i = displayObject.children.length - 1; i >= 0; i--) {
            this.unload(displayObject.children[i]);
        }
    };

    return TextureGarbageCollector;
}();

exports.default = TextureGarbageCollector;
//# sourceMappingURL=TextureGarbageCollector.js.map

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pixiGlCore = __webpack_require__(4);

var _const = __webpack_require__(0);

var _RenderTarget = __webpack_require__(21);

var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Helper class to create a webGL Texture
 *
 * @class
 * @memberof PIXI
 */
var TextureManager = function () {
    /**
     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer
     */
    function TextureManager(renderer) {
        _classCallCheck(this, TextureManager);

        /**
         * A reference to the current renderer
         *
         * @member {PIXI.WebGLRenderer}
         */
        this.renderer = renderer;

        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = renderer.gl;

        /**
         * Track textures in the renderer so we can no longer listen to them on destruction.
         *
         * @member {Array<*>}
         * @private
         */
        this._managedTextures = [];
    }

    /**
     * Binds a texture.
     *
     */


    TextureManager.prototype.bindTexture = function bindTexture() {}
    // empty


    /**
     * Gets a texture.
     *
     */
    ;

    TextureManager.prototype.getTexture = function getTexture() {}
    // empty


    /**
     * Updates and/or Creates a WebGL texture for the renderer's context.
     *
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update
     * @param {number} location - the location the texture will be bound to.
     * @return {GLTexture} The gl texture.
     */
    ;

    TextureManager.prototype.updateTexture = function updateTexture(texture, location) {
        // assume it good!
        // texture = texture.baseTexture || texture;

        var gl = this.gl;

        var isRenderTexture = !!texture._glRenderTargets;

        if (!texture.hasLoaded) {
            return null;
        }

        var boundTextures = this.renderer.boundTextures;

        // if the location is undefined then this may have been called by n event.
        // this being the case the texture may already be bound to a slot. As a texture can only be bound once
        // we need to find its current location if it exists.
        if (location === undefined) {
            location = 0;

            // TODO maybe we can use texture bound ids later on...
            // check if texture is already bound..
            for (var i = 0; i < boundTextures.length; ++i) {
                if (boundTextures[i] === texture) {
                    location = i;
                    break;
                }
            }
        }

        boundTextures[location] = texture;

        gl.activeTexture(gl.TEXTURE0 + location);

        var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];

        if (!glTexture) {
            if (isRenderTexture) {
                var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);

                renderTarget.resize(texture.width, texture.height);
                texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;
                glTexture = renderTarget.texture;
            } else {
                glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);
                glTexture.bind(location);
                glTexture.premultiplyAlpha = true;
                glTexture.upload(texture.source);
            }

            texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;

            texture.on('update', this.updateTexture, this);
            texture.on('dispose', this.destroyTexture, this);

            this._managedTextures.push(texture);

            if (texture.isPowerOfTwo) {
                if (texture.mipmap) {
                    glTexture.enableMipmap();
                }

                if (texture.wrapMode === _const.WRAP_MODES.CLAMP) {
                    glTexture.enableWrapClamp();
                } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) {
                    glTexture.enableWrapRepeat();
                } else {
                    glTexture.enableWrapMirrorRepeat();
                }
            } else {
                glTexture.enableWrapClamp();
            }

            if (texture.scaleMode === _const.SCALE_MODES.NEAREST) {
                glTexture.enableNearestScaling();
            } else {
                glTexture.enableLinearScaling();
            }
        }
        // the texture already exists so we only need to update it..
        else if (isRenderTexture) {
                texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);
            } else {
                glTexture.upload(texture.source);
            }

        return glTexture;
    };

    /**
     * Deletes the texture from WebGL
     *
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */


    TextureManager.prototype.destroyTexture = function destroyTexture(texture, skipRemove) {
        texture = texture.baseTexture || texture;

        if (!texture.hasLoaded) {
            return;
        }

        if (texture._glTextures[this.renderer.CONTEXT_UID]) {
            this.renderer.unbindTexture(texture);

            texture._glTextures[this.renderer.CONTEXT_UID].destroy();
            texture.off('update', this.updateTexture, this);
            texture.off('dispose', this.destroyTexture, this);

            delete texture._glTextures[this.renderer.CONTEXT_UID];

            if (!skipRemove) {
                var i = this._managedTextures.indexOf(texture);

                if (i !== -1) {
                    (0, _utils.removeItems)(this._managedTextures, i, 1);
                }
            }
        }
    };

    /**
     * Deletes all the textures from WebGL
     */


    TextureManager.prototype.removeAll = function removeAll() {
        // empty all the old gl textures as they are useless now
        for (var i = 0; i < this._managedTextures.length; ++i) {
            var texture = this._managedTextures[i];

            if (texture._glTextures[this.renderer.CONTEXT_UID]) {
                delete texture._glTextures[this.renderer.CONTEXT_UID];
            }
        }
    };

    /**
     * Destroys this manager and removes all its textures
     */


    TextureManager.prototype.destroy = function destroy() {
        // destroy managed textures
        for (var i = 0; i < this._managedTextures.length; ++i) {
            var texture = this._managedTextures[i];

            this.destroyTexture(texture, true);

            texture.off('update', this.updateTexture, this);
            texture.off('dispose', this.destroyTexture, this);
        }

        this._managedTextures = null;
    };

    return TextureManager;
}();

exports.default = TextureManager;
//# sourceMappingURL=TextureManager.js.map

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _mapWebGLBlendModesToPixi = __webpack_require__(144);

var _mapWebGLBlendModesToPixi2 = _interopRequireDefault(_mapWebGLBlendModesToPixi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BLEND = 0;
var DEPTH_TEST = 1;
var FRONT_FACE = 2;
var CULL_FACE = 3;
var BLEND_FUNC = 4;

/**
 * A WebGL state machines
 *
 * @memberof PIXI
 * @class
 */

var WebGLState = function () {
    /**
     * @param {WebGLRenderingContext} gl - The current WebGL rendering context
     */
    function WebGLState(gl) {
        _classCallCheck(this, WebGLState);

        /**
         * The current active state
         *
         * @member {Uint8Array}
         */
        this.activeState = new Uint8Array(16);

        /**
         * The default state
         *
         * @member {Uint8Array}
         */
        this.defaultState = new Uint8Array(16);

        // default blend mode..
        this.defaultState[0] = 1;

        /**
         * The current state index in the stack
         *
         * @member {number}
         * @private
         */
        this.stackIndex = 0;

        /**
         * The stack holding all the different states
         *
         * @member {Array<*>}
         * @private
         */
        this.stack = [];

        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        this.attribState = {
            tempAttribState: new Array(this.maxAttribs),
            attribState: new Array(this.maxAttribs)
        };

        this.blendModes = (0, _mapWebGLBlendModesToPixi2.default)(gl);

        // check we have vao..
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    /**
     * Pushes a new active state
     */


    WebGLState.prototype.push = function push() {
        // next state..
        var state = this.stack[this.stackIndex];

        if (!state) {
            state = this.stack[this.stackIndex] = new Uint8Array(16);
        }

        ++this.stackIndex;

        // copy state..
        // set active state so we can force overrides of gl state
        for (var i = 0; i < this.activeState.length; i++) {
            state[i] = this.activeState[i];
        }
    };

    /**
     * Pops a state out
     */


    WebGLState.prototype.pop = function pop() {
        var state = this.stack[--this.stackIndex];

        this.setState(state);
    };

    /**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */


    WebGLState.prototype.setState = function setState(state) {
        this.setBlend(state[BLEND]);
        this.setDepthTest(state[DEPTH_TEST]);
        this.setFrontFace(state[FRONT_FACE]);
        this.setCullFace(state[CULL_FACE]);
        this.setBlendMode(state[BLEND_FUNC]);
    };

    /**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */


    WebGLState.prototype.setBlend = function setBlend(value) {
        value = value ? 1 : 0;

        if (this.activeState[BLEND] === value) {
            return;
        }

        this.activeState[BLEND] = value;
        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
    };

    /**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */


    WebGLState.prototype.setBlendMode = function setBlendMode(value) {
        if (value === this.activeState[BLEND_FUNC]) {
            return;
        }

        this.activeState[BLEND_FUNC] = value;

        this.gl.blendFunc(this.blendModes[value][0], this.blendModes[value][1]);
    };

    /**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */


    WebGLState.prototype.setDepthTest = function setDepthTest(value) {
        value = value ? 1 : 0;

        if (this.activeState[DEPTH_TEST] === value) {
            return;
        }

        this.activeState[DEPTH_TEST] = value;
        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
    };

    /**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */


    WebGLState.prototype.setCullFace = function setCullFace(value) {
        value = value ? 1 : 0;

        if (this.activeState[CULL_FACE] === value) {
            return;
        }

        this.activeState[CULL_FACE] = value;
        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
    };

    /**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */


    WebGLState.prototype.setFrontFace = function setFrontFace(value) {
        value = value ? 1 : 0;

        if (this.activeState[FRONT_FACE] === value) {
            return;
        }

        this.activeState[FRONT_FACE] = value;
        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
    };

    /**
     * Disables all the vaos in use
     *
     */


    WebGLState.prototype.resetAttributes = function resetAttributes() {
        for (var i = 0; i < this.attribState.tempAttribState.length; i++) {
            this.attribState.tempAttribState[i] = 0;
        }

        for (var _i = 0; _i < this.attribState.attribState.length; _i++) {
            this.attribState.attribState[_i] = 0;
        }

        // im going to assume one is always active for performance reasons.
        for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) {
            this.gl.disableVertexAttribArray(_i2);
        }
    };

    // used
    /**
     * Resets all the logic and disables the vaos
     */


    WebGLState.prototype.resetToDefault = function resetToDefault() {
        // unbind any VAO if they exist..
        if (this.nativeVaoExtension) {
            this.nativeVaoExtension.bindVertexArrayOES(null);
        }

        // reset all attributes..
        this.resetAttributes();

        // set active state so we can force overrides of gl state
        for (var i = 0; i < this.activeState.length; ++i) {
            this.activeState[i] = 32;
        }

        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);

        this.setState(this.defaultState);
    };

    return WebGLState;
}();

exports.default = WebGLState;
//# sourceMappingURL=WebGLState.js.map

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = extractUniformsFromSrc;

var _pixiGlCore = __webpack_require__(4);

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultValue = _pixiGlCore2.default.shader.defaultValue;

function extractUniformsFromSrc(vertexSrc, fragmentSrc, mask) {
    var vertUniforms = extractUniformsFromString(vertexSrc, mask);
    var fragUniforms = extractUniformsFromString(fragmentSrc, mask);

    return Object.assign(vertUniforms, fragUniforms);
}

function extractUniformsFromString(string) {
    var maskRegex = new RegExp('^(projectionMatrix|uSampler|filterArea|filterClamp)$');

    var uniforms = {};
    var nameSplit = void 0;

    // clean the lines a little - remove extra spaces / tabs etc
    // then split along ';'
    var lines = string.replace(/\s+/g, ' ').split(/\s*;\s*/);

    // loop through..
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();

        if (line.indexOf('uniform') > -1) {
            var splitLine = line.split(' ');
            var type = splitLine[1];

            var name = splitLine[2];
            var size = 1;

            if (name.indexOf('[') > -1) {
                // array!
                nameSplit = name.split(/\[|]/);
                name = nameSplit[0];
                size *= Number(nameSplit[1]);
            }

            if (!name.match(maskRegex)) {
                uniforms[name] = {
                    value: defaultValue(type, size),
                    name: name,
                    type: type
                };
            }
        }
    }

    return uniforms;
}
//# sourceMappingURL=extractUniformsFromSrc.js.map

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;
exports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;
exports.calculateSpriteMatrix = calculateSpriteMatrix;

var _math = __webpack_require__(2);

/*
 * Calculates the mapped matrix
 * @param filterArea {Rectangle} The filter area
 * @param sprite {Sprite} the target sprite
 * @param outputMatrix {Matrix} @alvin
 */
// TODO playing around here.. this is temporary - (will end up in the shader)
// this returns a matrix that will normalise map filter cords in the filter to screen space
function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
    // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),
    // let texture = {width:1136, height:700};//sprite._texture.baseTexture;

    // TODO unwrap?
    var mappedMatrix = outputMatrix.identity();

    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

    mappedMatrix.scale(textureSize.width, textureSize.height);

    return mappedMatrix;
}

function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
    var mappedMatrix = outputMatrix.identity();

    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

    var translateScaleX = textureSize.width / filterArea.width;
    var translateScaleY = textureSize.height / filterArea.height;

    mappedMatrix.scale(translateScaleX, translateScaleY);

    return mappedMatrix;
}

// this will map the filter coord so that a texture can be used based on the transform of a sprite
function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
    var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);
    var texture = sprite._texture.baseTexture;

    // TODO unwrap?
    var mappedMatrix = outputMatrix.identity();

    // scale..
    var ratio = textureSize.height / textureSize.width;

    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

    mappedMatrix.scale(1, ratio);

    var translateScaleX = textureSize.width / texture.width;
    var translateScaleY = textureSize.height / texture.height;

    worldTransform.tx /= texture.width * translateScaleX;

    // this...?  free beer for anyone who can explain why this makes sense!
    worldTransform.ty /= texture.width * translateScaleX;
    // worldTransform.ty /= texture.height * translateScaleY;

    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);

    // apply inverse scale..
    mappedMatrix.scale(1, 1 / ratio);

    mappedMatrix.scale(translateScaleX, translateScaleY);

    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

    return mappedMatrix;
}
//# sourceMappingURL=filterTransforms.js.map

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _WebGLManager2 = __webpack_require__(13);

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

var _RenderTarget = __webpack_require__(21);

var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

var _Quad = __webpack_require__(70);

var _Quad2 = _interopRequireDefault(_Quad);

var _math = __webpack_require__(2);

var _Shader = __webpack_require__(17);

var _Shader2 = _interopRequireDefault(_Shader);

var _filterTransforms = __webpack_require__(139);

var filterTransforms = _interopRequireWildcard(_filterTransforms);

var _bitTwiddle = __webpack_require__(24);

var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @ignore
 * @class
 */
var FilterState =
/**
 *
 */
function FilterState() {
    _classCallCheck(this, FilterState);

    this.renderTarget = null;
    this.sourceFrame = new _math.Rectangle();
    this.destinationFrame = new _math.Rectangle();
    this.filters = [];
    this.target = null;
    this.resolution = 1;
};

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGLManager
 */


var FilterManager = function (_WebGLManager) {
    _inherits(FilterManager, _WebGLManager);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function FilterManager(renderer) {
        _classCallCheck(this, FilterManager);

        var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

        _this.gl = _this.renderer.gl;
        // know about sprites!
        _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);

        _this.shaderCache = {};
        // todo add default!
        _this.pool = {};

        _this.filterData = null;
        return _this;
    }

    /**
     * Adds a new filter to the manager.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */


    FilterManager.prototype.pushFilter = function pushFilter(target, filters) {
        var renderer = this.renderer;

        var filterData = this.filterData;

        if (!filterData) {
            filterData = this.renderer._activeRenderTarget.filterStack;

            // add new stack
            var filterState = new FilterState();

            filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;
            filterState.renderTarget = renderer._activeRenderTarget;

            this.renderer._activeRenderTarget.filterData = filterData = {
                index: 0,
                stack: [filterState]
            };

            this.filterData = filterData;
        }

        // get the current filter state..
        var currentState = filterData.stack[++filterData.index];

        if (!currentState) {
            currentState = filterData.stack[filterData.index] = new FilterState();
        }

        // for now we go off the filter of the first resolution..
        var resolution = filters[0].resolution;
        var padding = filters[0].padding | 0;
        var targetBounds = target.filterArea || target.getBounds(true);
        var sourceFrame = currentState.sourceFrame;
        var destinationFrame = currentState.destinationFrame;

        sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;
        sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;
        sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;
        sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;

        if (filterData.stack[0].renderTarget.transform) {//

            // TODO we should fit the rect around the transform..
        } else {
            sourceFrame.fit(filterData.stack[0].destinationFrame);
        }

        // lets apply the padding After we fit the element to the screen.
        // this should stop the strange side effects that can occur when cropping to the edges
        sourceFrame.pad(padding);

        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;

        // lets play the padding after we fit the element to the screen.
        // this should stop the strange side effects that can occur when cropping to the edges

        var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);

        currentState.target = target;
        currentState.filters = filters;
        currentState.resolution = resolution;
        currentState.renderTarget = renderTarget;

        // bind the render target to draw the shape in the top corner..

        renderTarget.setFrame(destinationFrame, sourceFrame);

        // bind the render target
        renderer.bindRenderTarget(renderTarget);
        renderTarget.clear();
    };

    /**
     * Pops off the filter and applies it.
     *
     */


    FilterManager.prototype.popFilter = function popFilter() {
        var filterData = this.filterData;

        var lastState = filterData.stack[filterData.index - 1];
        var currentState = filterData.stack[filterData.index];

        this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();

        var filters = currentState.filters;

        if (filters.length === 1) {
            filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);
            this.freePotRenderTarget(currentState.renderTarget);
        } else {
            var flip = currentState.renderTarget;
            var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);

            flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);

            // finally lets clear the render target before drawing to it..
            flop.clear();

            var i = 0;

            for (i = 0; i < filters.length - 1; ++i) {
                filters[i].apply(this, flip, flop, true, currentState);

                var t = flip;

                flip = flop;
                flop = t;
            }

            filters[i].apply(this, flip, lastState.renderTarget, false, currentState);

            this.freePotRenderTarget(flip);
            this.freePotRenderTarget(flop);
        }

        filterData.index--;

        if (filterData.index === 0) {
            this.filterData = null;
        }
    };

    /**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTarget} input - The input render target.
     * @param {PIXI.RenderTarget} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */


    FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {
        var renderer = this.renderer;
        var gl = renderer.gl;

        var shader = filter.glShaders[renderer.CONTEXT_UID];

        // cacheing..
        if (!shader) {
            if (filter.glShaderKey) {
                shader = this.shaderCache[filter.glShaderKey];

                if (!shader) {
                    shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);

                    filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;
                }
            } else {
                shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);
            }

            // TODO - this only needs to be done once?
            renderer.bindVao(null);

            this.quad.initVao(shader);
        }

        renderer.bindVao(this.quad.vao);

        renderer.bindRenderTarget(output);

        if (clear) {
            gl.disable(gl.SCISSOR_TEST);
            renderer.clear(); // [1, 1, 1, 1]);
            gl.enable(gl.SCISSOR_TEST);
        }

        // in case the render target is being masked using a scissor rect
        if (output === renderer.maskManager.scissorRenderTarget) {
            renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);
        }

        renderer.bindShader(shader);

        // free unit 0 for us, doesn't matter what was there
        // don't try to restore it, because syncUniforms can upload it to another slot
        // and it'll be a problem
        var tex = this.renderer.emptyTextures[0];

        this.renderer.boundTextures[0] = tex;
        // this syncs the pixi filters  uniforms with glsl uniforms
        this.syncUniforms(shader, filter);

        renderer.state.setBlendMode(filter.blendMode);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);

        this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);

        gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
    };

    /**
     * Uploads the uniforms of the filter.
     *
     * @param {GLShader} shader - The underlying gl shader.
     * @param {PIXI.Filter} filter - The filter we are synchronizing.
     */


    FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {
        var uniformData = filter.uniformData;
        var uniforms = filter.uniforms;

        // 0 is reserved for the pixi texture so we start at 1!
        var textureCount = 1;
        var currentState = void 0;

        // filterArea and filterClamp that are handled by FilterManager directly
        // they must not appear in uniformData

        if (shader.uniforms.filterArea) {
            currentState = this.filterData.stack[this.filterData.index];

            var filterArea = shader.uniforms.filterArea;

            filterArea[0] = currentState.renderTarget.size.width;
            filterArea[1] = currentState.renderTarget.size.height;
            filterArea[2] = currentState.sourceFrame.x;
            filterArea[3] = currentState.sourceFrame.y;

            shader.uniforms.filterArea = filterArea;
        }

        // use this to clamp displaced texture coords so they belong to filterArea
        // see displacementFilter fragment shader for an example
        if (shader.uniforms.filterClamp) {
            currentState = currentState || this.filterData.stack[this.filterData.index];

            var filterClamp = shader.uniforms.filterClamp;

            filterClamp[0] = 0;
            filterClamp[1] = 0;
            filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;
            filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;

            shader.uniforms.filterClamp = filterClamp;
        }

        // TODO Cacheing layer..
        for (var i in uniformData) {
            if (uniformData[i].type === 'sampler2D' && uniforms[i] !== 0) {
                if (uniforms[i].baseTexture) {
                    shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);
                } else {
                    shader.uniforms[i] = textureCount;

                    // TODO
                    // this is helpful as renderTargets can also be set.
                    // Although thinking about it, we could probably
                    // make the filter texture cache return a RenderTexture
                    // rather than a renderTarget
                    var gl = this.renderer.gl;

                    this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];
                    gl.activeTexture(gl.TEXTURE0 + textureCount);

                    uniforms[i].texture.bind();
                }

                textureCount++;
            } else if (uniformData[i].type === 'mat3') {
                // check if its pixi matrix..
                if (uniforms[i].a !== undefined) {
                    shader.uniforms[i] = uniforms[i].toArray(true);
                } else {
                    shader.uniforms[i] = uniforms[i];
                }
            } else if (uniformData[i].type === 'vec2') {
                // check if its a point..
                if (uniforms[i].x !== undefined) {
                    var val = shader.uniforms[i] || new Float32Array(2);

                    val[0] = uniforms[i].x;
                    val[1] = uniforms[i].y;
                    shader.uniforms[i] = val;
                } else {
                    shader.uniforms[i] = uniforms[i];
                }
            } else if (uniformData[i].type === 'float') {
                if (shader.uniforms.data[i].value !== uniformData[i]) {
                    shader.uniforms[i] = uniforms[i];
                }
            } else {
                shader.uniforms[i] = uniforms[i];
            }
        }
    };

    /**
     * Gets a render target from the pool, or creates a new one.
     *
     * @param {boolean} clear - Should we clear the render texture when we get it?
     * @param {number} resolution - The resolution of the target.
     * @return {PIXI.RenderTarget} The new render target
     */


    FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) {
        var currentState = this.filterData.stack[this.filterData.index];
        var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);

        renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);

        return renderTarget;
    };

    /**
     * Returns a render target to the pool.
     *
     * @param {PIXI.RenderTarget} renderTarget - The render target to return.
     */


    FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) {
        this.freePotRenderTarget(renderTarget);
    };

    /**
     * Calculates the mapped matrix.
     *
     * TODO playing around here.. this is temporary - (will end up in the shader)
     * this returns a matrix that will normalise map filter cords in the filter to screen space
     *
     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */


    FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) {
        var currentState = this.filterData.stack[this.filterData.index];

        return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);
    };

    /**
     * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */


    FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) {
        var currentState = this.filterData.stack[this.filterData.index];

        return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame);
    };

    /**
     * This will map the filter coord so that a texture can be used based on the transform of a sprite
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */


    FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) {
        var currentState = this.filterData.stack[this.filterData.index];

        return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);
    };

    /**
     * Destroys this Filter Manager.
     *
     */


    FilterManager.prototype.destroy = function destroy() {
        this.shaderCache = {};
        this.emptyPool();
    };

    /**
     * Gets a Power-of-Two render texture.
     *
     * TODO move to a seperate class could be on renderer?
     * also - could cause issue with multiple contexts?
     *
     * @private
     * @param {WebGLRenderingContext} gl - The webgl rendering context
     * @param {number} minWidth - The minimum width of the render target.
     * @param {number} minHeight - The minimum height of the render target.
     * @param {number} resolution - The resolution of the render target.
     * @return {PIXI.RenderTarget} The new render target.
     */


    FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {
        // TODO you could return a bigger texture if there is not one in the pool?
        minWidth = _bitTwiddle2.default.nextPow2(minWidth * resolution);
        minHeight = _bitTwiddle2.default.nextPow2(minHeight * resolution);

        var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;

        if (!this.pool[key]) {
            this.pool[key] = [];
        }

        var renderTarget = this.pool[key].pop();

        // creating render target will cause texture to be bound!
        if (!renderTarget) {
            // temporary bypass cache..
            var tex = this.renderer.boundTextures[0];

            gl.activeTexture(gl.TEXTURE0);

            // internally - this will cause a texture to be bound..
            renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1);

            // set the current one back
            gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
        }

        // manually tweak the resolution...
        // this will not modify the size of the frame buffer, just its resolution.
        renderTarget.resolution = resolution;
        renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;
        renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;

        return renderTarget;
    };

    /**
     * Empties the texture pool.
     *
     */


    FilterManager.prototype.emptyPool = function emptyPool() {
        for (var i in this.pool) {
            var textures = this.pool[i];

            if (textures) {
                for (var j = 0; j < textures.length; j++) {
                    textures[j].destroy(true);
                }
            }
        }

        this.pool = {};
    };

    /**
     * Frees a render target back into the pool.
     *
     * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free
     */


    FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) {
        var minWidth = renderTarget.size.width * renderTarget.resolution;
        var minHeight = renderTarget.size.height * renderTarget.resolution;
        var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;

        this.pool[key].push(renderTarget);
    };

    return FilterManager;
}(_WebGLManager3.default);

exports.default = FilterManager;
//# sourceMappingURL=FilterManager.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _WebGLManager2 = __webpack_require__(13);

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

var _SpriteMaskFilter = __webpack_require__(69);

var _SpriteMaskFilter2 = _interopRequireDefault(_SpriteMaskFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 */
var MaskManager = function (_WebGLManager) {
    _inherits(MaskManager, _WebGLManager);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function MaskManager(renderer) {
        _classCallCheck(this, MaskManager);

        // TODO - we don't need both!
        var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

        _this.scissor = false;
        _this.scissorData = null;
        _this.scissorRenderTarget = null;

        _this.enableScissor = true;

        _this.alphaMaskPool = [];
        _this.alphaMaskIndex = 0;
        return _this;
    }

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.pushMask = function pushMask(target, maskData) {
        // TODO the root check means scissor rect will not
        // be used on render textures more info here:
        // https://github.com/pixijs/pixi.js/pull/3545

        if (maskData.texture) {
            this.pushSpriteMask(target, maskData);
        } else if (this.enableScissor && !this.scissor && this.renderer._activeRenderTarget.root && !this.renderer.stencilManager.stencilMaskStack.length && maskData.isFastRect()) {
            var matrix = maskData.worldTransform;

            var rot = Math.atan2(matrix.b, matrix.a);

            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));

            if (rot % 90) {
                this.pushStencilMask(maskData);
            } else {
                this.pushScissorMask(target, maskData);
            }
        } else {
            this.pushStencilMask(maskData);
        }
    };

    /**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.popMask = function popMask(target, maskData) {
        if (maskData.texture) {
            this.popSpriteMask(target, maskData);
        } else if (this.enableScissor && !this.renderer.stencilManager.stencilMaskStack.length) {
            this.popScissorMask(target, maskData);
        } else {
            this.popStencilMask(target, maskData);
        }
    };

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.RenderTarget} target - Display Object to push the sprite mask to
     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
     */


    MaskManager.prototype.pushSpriteMask = function pushSpriteMask(target, maskData) {
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];

        if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new _SpriteMaskFilter2.default(maskData)];
        }

        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskData;

        // TODO - may cause issues!
        target.filterArea = maskData.getBounds(true);

        this.renderer.filterManager.pushFilter(target, alphaMaskFilter);

        this.alphaMaskIndex++;
    };

    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */


    MaskManager.prototype.popSpriteMask = function popSpriteMask() {
        this.renderer.filterManager.popFilter();
        this.alphaMaskIndex--;
    };

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.pushStencilMask = function pushStencilMask(maskData) {
        this.renderer.currentRenderer.stop();
        this.renderer.stencilManager.pushStencil(maskData);
    };

    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */


    MaskManager.prototype.popStencilMask = function popStencilMask() {
        this.renderer.currentRenderer.stop();
        this.renderer.stencilManager.popStencil();
    };

    /**
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Graphics} maskData - The masking data.
     */


    MaskManager.prototype.pushScissorMask = function pushScissorMask(target, maskData) {
        maskData.renderable = true;

        var renderTarget = this.renderer._activeRenderTarget;

        var bounds = maskData.getBounds();

        bounds.fit(renderTarget.size);
        maskData.renderable = false;

        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);

        var resolution = this.renderer.resolution;

        this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);

        this.scissorRenderTarget = renderTarget;
        this.scissorData = maskData;
        this.scissor = true;
    };

    /**
     *
     *
     */


    MaskManager.prototype.popScissorMask = function popScissorMask() {
        this.scissorRenderTarget = null;
        this.scissorData = null;
        this.scissor = false;

        // must be scissor!
        var gl = this.renderer.gl;

        gl.disable(gl.SCISSOR_TEST);
    };

    return MaskManager;
}(_WebGLManager3.default);

exports.default = MaskManager;
//# sourceMappingURL=MaskManager.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _WebGLManager2 = __webpack_require__(13);

var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 */
var StencilManager = function (_WebGLManager) {
    _inherits(StencilManager, _WebGLManager);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
     */
    function StencilManager(renderer) {
        _classCallCheck(this, StencilManager);

        var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

        _this.stencilMaskStack = null;
        return _this;
    }

    /**
     * Changes the mask stack that is used by this manager.
     *
     * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
     */


    StencilManager.prototype.setMaskStack = function setMaskStack(stencilMaskStack) {
        this.stencilMaskStack = stencilMaskStack;

        var gl = this.renderer.gl;

        if (stencilMaskStack.length === 0) {
            gl.disable(gl.STENCIL_TEST);
        } else {
            gl.enable(gl.STENCIL_TEST);
        }
    };

    /**
     * Applies the Mask and adds it to the current filter stack. @alvin
     *
     * @param {PIXI.Graphics} graphics - The mask
     */


    StencilManager.prototype.pushStencil = function pushStencil(graphics) {
        this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

        this.renderer._activeRenderTarget.attachStencilBuffer();

        var gl = this.renderer.gl;
        var sms = this.stencilMaskStack;

        if (sms.length === 0) {
            gl.enable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.stencilFunc(gl.ALWAYS, 1, 1);
        }

        sms.push(graphics);

        gl.colorMask(false, false, false, false);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);

        this.renderer.plugins.graphics.render(graphics);

        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    };

    /**
     * TODO @alvin
     */


    StencilManager.prototype.popStencil = function popStencil() {
        this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

        var gl = this.renderer.gl;
        var sms = this.stencilMaskStack;

        var graphics = sms.pop();

        if (sms.length === 0) {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
        } else {
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);

            this.renderer.plugins.graphics.render(graphics);

            gl.colorMask(true, true, true, true);
            gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        }
    };

    /**
     * Destroys the mask stack.
     *
     */


    StencilManager.prototype.destroy = function destroy() {
        _WebGLManager3.default.prototype.destroy.call(this);

        this.stencilMaskStack.stencilStack = null;
    };

    return StencilManager;
}(_WebGLManager3.default);

exports.default = StencilManager;
//# sourceMappingURL=StencilManager.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = checkMaxIfStatmentsInShader;

var _pixiGlCore = __webpack_require__(4);

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fragTemplate = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n');

function checkMaxIfStatmentsInShader(maxIfs, gl) {
    var createTempContext = !gl;

    // @if DEBUG
    if (maxIfs === 0) {
        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
    }
    // @endif

    if (createTempContext) {
        var tinyCanvas = document.createElement('canvas');

        tinyCanvas.width = 1;
        tinyCanvas.height = 1;

        gl = _pixiGlCore2.default.createContext(tinyCanvas);
    }

    var shader = gl.createShader(gl.FRAGMENT_SHADER);

    while (true) // eslint-disable-line no-constant-condition
    {
        var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));

        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            maxIfs = maxIfs / 2 | 0;
        } else {
            // valid!
            break;
        }
    }

    if (createTempContext) {
        // get rid of context
        if (gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').loseContext();
        }
    }

    return maxIfs;
}

function generateIfTestSrc(maxIfs) {
    var src = '';

    for (var i = 0; i < maxIfs; ++i) {
        if (i > 0) {
            src += '\nelse ';
        }

        if (i < maxIfs - 1) {
            src += 'if(test == ' + i + '.0){}';
        }
    }

    return src;
}
//# sourceMappingURL=checkMaxIfStatmentsInShader.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = mapWebGLBlendModesToPixi;

var _const = __webpack_require__(0);

/**
 * Maps gl blend combinations to WebGL.
 *
 * @memberof PIXI
 * @function mapWebGLBlendModesToPixi
 * @private
 * @param {WebGLRenderingContext} gl - The rendering context.
 * @param {string[]} [array=[]] - The array to output into.
 * @return {string[]} Mapped modes.
 */
function mapWebGLBlendModesToPixi(gl) {
    var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    // TODO - premultiply alpha would be different.
    // add a boolean for that!
    array[_const.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA];
    array[_const.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
    array[_const.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_const.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

    return array;
}
//# sourceMappingURL=mapWebGLBlendModesToPixi.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = mapWebGLDrawModesToPixi;

var _const = __webpack_require__(0);

/**
 * Generic Mask Stack data structure.
 *
 * @memberof PIXI
 * @function mapWebGLDrawModesToPixi
 * @private
 * @param {WebGLRenderingContext} gl - The current WebGL drawing context
 * @param {object} [object={}] - The object to map into
 * @return {object} The mapped draw modes.
 */
function mapWebGLDrawModesToPixi(gl) {
  var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  object[_const.DRAW_MODES.POINTS] = gl.POINTS;
  object[_const.DRAW_MODES.LINES] = gl.LINES;
  object[_const.DRAW_MODES.LINE_LOOP] = gl.LINE_LOOP;
  object[_const.DRAW_MODES.LINE_STRIP] = gl.LINE_STRIP;
  object[_const.DRAW_MODES.TRIANGLES] = gl.TRIANGLES;
  object[_const.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
  object[_const.DRAW_MODES.TRIANGLE_FAN] = gl.TRIANGLE_FAN;

  return object;
}
//# sourceMappingURL=mapWebGLDrawModesToPixi.js.map

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = validateContext;
function validateContext(gl) {
    var attributes = gl.getContextAttributes();

    // this is going to be fairly simple for now.. but at least we have room to grow!
    if (!attributes.stencil) {
        /* eslint-disable no-console */
        console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
        /* eslint-enable no-console */
    }
}
//# sourceMappingURL=validateContext.js.map

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _CanvasRenderer = __webpack_require__(12);

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _const = __webpack_require__(0);

var _math = __webpack_require__(2);

var _CanvasTinter = __webpack_require__(71);

var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var canvasRenderWorldTransform = new _math.Matrix();

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
 * share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's CanvasSpriteRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java
 */

/**
 * Renderer dedicated to drawing and batching sprites.
 *
 * @class
 * @private
 * @memberof PIXI
 */

var CanvasSpriteRenderer = function () {
    /**
     * @param {PIXI.WebGLRenderer} renderer -The renderer sprite this batch works for.
     */
    function CanvasSpriteRenderer(renderer) {
        _classCallCheck(this, CanvasSpriteRenderer);

        this.renderer = renderer;
    }

    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */


    CanvasSpriteRenderer.prototype.render = function render(sprite) {
        var texture = sprite._texture;
        var renderer = this.renderer;

        var width = texture._frame.width;
        var height = texture._frame.height;

        var wt = sprite.transform.worldTransform;
        var dx = 0;
        var dy = 0;

        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) {
            return;
        }

        renderer.setBlendMode(sprite.blendMode);

        //  Ignore null sources
        if (texture.valid) {
            renderer.context.globalAlpha = sprite.worldAlpha;

            // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture
            var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;

            if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {
                renderer.context[renderer.smoothProperty] = smoothingEnabled;
            }

            if (texture.trim) {
                dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
                dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
            } else {
                dx = (0.5 - sprite.anchor.x) * texture.orig.width;
                dy = (0.5 - sprite.anchor.y) * texture.orig.height;
            }

            if (texture.rotate) {
                wt.copy(canvasRenderWorldTransform);
                wt = canvasRenderWorldTransform;
                _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
                // the anchor has already been applied above, so lets set it to zero
                dx = 0;
                dy = 0;
            }

            dx -= width / 2;
            dy -= height / 2;

            // Allow for pixel rounding
            if (renderer.roundPixels) {
                renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);

                dx = dx | 0;
                dy = dy | 0;
            } else {
                renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);
            }

            var resolution = texture.baseTexture.resolution;

            if (sprite.tint !== 0xFFFFFF) {
                if (sprite.cachedTint !== sprite.tint) {
                    sprite.cachedTint = sprite.tint;

                    // TODO clean up caching - how to clean up the caches?
                    sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint);
                }

                renderer.context.drawImage(sprite.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
            } else {
                renderer.context.drawImage(texture.baseTexture.source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
            }
        }
    };

    /**
     * destroy the sprite object.
     *
     */


    CanvasSpriteRenderer.prototype.destroy = function destroy() {
        this.renderer = null;
    };

    return CanvasSpriteRenderer;
}();

exports.default = CanvasSpriteRenderer;


_CanvasRenderer2.default.registerPlugin('sprite', CanvasSpriteRenderer);
//# sourceMappingURL=CanvasSpriteRenderer.js.map

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @memberof PIXI
 */
var Buffer = function () {
  /**
   * @param {number} size - The size of the buffer in bytes.
   */
  function Buffer(size) {
    _classCallCheck(this, Buffer);

    this.vertices = new ArrayBuffer(size);

    /**
     * View on the vertices as a Float32Array for positions
     *
     * @member {Float32Array}
     */
    this.float32View = new Float32Array(this.vertices);

    /**
     * View on the vertices as a Uint32Array for uvs
     *
     * @member {Float32Array}
     */
    this.uint32View = new Uint32Array(this.vertices);
  }

  /**
   * Destroys the buffer.
   *
   */


  Buffer.prototype.destroy = function destroy() {
    this.vertices = null;
    this.positions = null;
    this.uvs = null;
    this.colors = null;
  };

  return Buffer;
}();

exports.default = Buffer;
//# sourceMappingURL=BatchBuffer.js.map

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ObjectRenderer2 = __webpack_require__(20);

var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

var _WebGLRenderer = __webpack_require__(19);

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

var _createIndicesForQuads = __webpack_require__(76);

var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

var _generateMultiTextureShader = __webpack_require__(150);

var _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);

var _checkMaxIfStatmentsInShader = __webpack_require__(143);

var _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);

var _BatchBuffer = __webpack_require__(148);

var _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _pixiGlCore = __webpack_require__(4);

var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

var _bitTwiddle = __webpack_require__(24);

var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TICK = 0;
var TEXTURE_TICK = 0;

/**
 * Renderer dedicated to drawing and batching sprites.
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 */

var SpriteRenderer = function (_ObjectRenderer) {
    _inherits(SpriteRenderer, _ObjectRenderer);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.
     */
    function SpriteRenderer(renderer) {
        _classCallCheck(this, SpriteRenderer);

        /**
         * Number of values sent in the vertex buffer.
         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
         *
         * @member {number}
         */
        var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));

        _this.vertSize = 5;

        /**
         * The size of the vertex information in bytes.
         *
         * @member {number}
         */
        _this.vertByteSize = _this.vertSize * 4;

        /**
         * The number of images in the SpriteRenderer before it flushes.
         *
         * @member {number}
         */
        _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

        // the total number of bytes in our batch
        // let numVerts = this.size * 4 * this.vertByteSize;

        _this.buffers = [];
        for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {
            _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));
        }

        /**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         */
        _this.indices = (0, _createIndicesForQuads2.default)(_this.size);

        /**
         * The default shaders that is used if a sprite doesn't have a more specific one.
         * there is a shader for each number of textures that can be rendererd.
         * These shaders will also be generated on the fly as required.
         * @member {PIXI.Shader[]}
         */
        _this.shader = null;

        _this.currentIndex = 0;
        _this.groups = [];

        for (var k = 0; k < _this.size; k++) {
            _this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };
        }

        _this.sprites = [];

        _this.vertexBuffers = [];
        _this.vaos = [];

        _this.vaoMax = 2;
        _this.vertexCount = 0;

        _this.renderer.on('prerender', _this.onPrerender, _this);
        return _this;
    }

    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */


    SpriteRenderer.prototype.onContextChange = function onContextChange() {
        var gl = this.renderer.gl;

        if (this.renderer.legacy) {
            this.MAX_TEXTURES = 1;
        } else {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES);

            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);
        }

        var shader = this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES);

        // create a couple of buffers
        this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

        // we use the second shader as the first one depending on your browser may omit aTextureId
        // as it is not used by the shader so is optimized out.

        this.renderer.bindVao(null);

        for (var i = 0; i < this.vaoMax; i++) {
            this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);

            /* eslint-disable max-len */

            // build the vao object that will render..
            this.vaos[i] = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(this.vertexBuffers[i], shader.attributes.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(this.vertexBuffers[i], shader.attributes.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(this.vertexBuffers[i], shader.attributes.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);

            if (shader.attributes.aTextureId) {
                this.vaos[i].addAttribute(this.vertexBuffers[i], shader.attributes.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
            }

            /* eslint-enable max-len */
        }

        this.vao = this.vaos[0];
        this.currentBlendMode = 99999;

        this.boundTextures = new Array(this.MAX_TEXTURES);
    };

    /**
     * Called before the renderer starts rendering.
     *
     */


    SpriteRenderer.prototype.onPrerender = function onPrerender() {
        this.vertexCount = 0;
    };

    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */


    SpriteRenderer.prototype.render = function render(sprite) {
        // TODO set blend modes..
        // check texture..
        if (this.currentIndex >= this.size) {
            this.flush();
        }

        // get the uvs for the texture

        // if the uvs have not updated then no point rendering just yet!
        if (!sprite._texture._uvs) {
            return;
        }

        // push a texture.
        // increment the batchsize
        this.sprites[this.currentIndex++] = sprite;
    };

    /**
     * Renders the content and empties the current batch.
     *
     */


    SpriteRenderer.prototype.flush = function flush() {
        if (this.currentIndex === 0) {
            return;
        }

        var gl = this.renderer.gl;
        var MAX_TEXTURES = this.MAX_TEXTURES;

        var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);
        var log2 = _bitTwiddle2.default.log2(np2);
        var buffer = this.buffers[log2];

        var sprites = this.sprites;
        var groups = this.groups;

        var float32View = buffer.float32View;
        var uint32View = buffer.uint32View;

        var boundTextures = this.boundTextures;
        var rendererBoundTextures = this.renderer.boundTextures;
        var touch = this.renderer.textureGC.count;

        var index = 0;
        var nextTexture = void 0;
        var currentTexture = void 0;
        var groupCount = 1;
        var textureCount = 0;
        var currentGroup = groups[0];
        var vertexData = void 0;
        var uvs = void 0;
        var blendMode = sprites[0].blendMode;

        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.blend = blendMode;

        TICK++;

        var i = void 0;

        // copy textures..
        for (i = 0; i < MAX_TEXTURES; ++i) {
            boundTextures[i] = rendererBoundTextures[i];
            boundTextures[i]._virtalBoundId = i;
        }

        for (i = 0; i < this.currentIndex; ++i) {
            // upload the sprite elemetns...
            // they have all ready been calculated so we just need to push them into the buffer.
            var sprite = sprites[i];

            nextTexture = sprite._texture.baseTexture;

            if (blendMode !== sprite.blendMode) {
                // finish a group..
                blendMode = sprite.blendMode;

                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }

            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;

                if (nextTexture._enabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;

                        currentGroup.size = i - currentGroup.start;

                        textureCount = 0;

                        currentGroup = groups[groupCount++];
                        currentGroup.blend = blendMode;
                        currentGroup.textureCount = 0;
                        currentGroup.start = i;
                    }

                    nextTexture.touched = touch;

                    if (nextTexture._virtalBoundId === -1) {
                        for (var j = 0; j < MAX_TEXTURES; ++j) {
                            var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;

                            var t = boundTextures[tIndex];

                            if (t._enabled !== TICK) {
                                TEXTURE_TICK++;

                                t._virtalBoundId = -1;

                                nextTexture._virtalBoundId = tIndex;

                                boundTextures[tIndex] = nextTexture;
                                break;
                            }
                        }
                    }

                    nextTexture._enabled = TICK;

                    currentGroup.textureCount++;
                    currentGroup.ids[textureCount] = nextTexture._virtalBoundId;
                    currentGroup.textures[textureCount++] = nextTexture;
                }
            }

            vertexData = sprite.vertexData;

            // TODO this sum does not need to be set each frame..
            uvs = sprite._texture._uvs.uvsUint32;

            if (this.renderer.roundPixels) {
                var resolution = this.renderer.resolution;

                // xy
                float32View[index] = (vertexData[0] * resolution | 0) / resolution;
                float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution;

                // xy
                float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;
                float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution;

                // xy
                float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;
                float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution;

                // xy
                float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;
                float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution;
            } else {
                // xy
                float32View[index] = vertexData[0];
                float32View[index + 1] = vertexData[1];

                // xy
                float32View[index + 5] = vertexData[2];
                float32View[index + 6] = vertexData[3];

                // xy
                float32View[index + 10] = vertexData[4];
                float32View[index + 11] = vertexData[5];

                // xy
                float32View[index + 15] = vertexData[6];
                float32View[index + 16] = vertexData[7];
            }

            uint32View[index + 2] = uvs[0];
            uint32View[index + 7] = uvs[1];
            uint32View[index + 12] = uvs[2];
            uint32View[index + 17] = uvs[3];

            /* eslint-disable max-len */
            uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = sprite._tintRGB + (Math.min(sprite.worldAlpha, 1) * 255 << 24);

            float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;
            /* eslint-enable max-len */

            index += 20;
        }

        currentGroup.size = i - currentGroup.start;

        if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
            // this is still needed for IOS performance..
            // it really does not like uploading to the same buffer in a single frame!
            if (this.vaoMax <= this.vertexCount) {
                this.vaoMax++;
                this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);

                /* eslint-disable max-len */

                // build the vao object that will render..
                this.vaos[this.vertexCount] = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);

                if (this.shader.attributes.aTextureId) {
                    this.vaos[this.vertexCount].addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
                }

                /* eslint-enable max-len */
            }

            this.renderer.bindVao(this.vaos[this.vertexCount]);

            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);

            this.vertexCount++;
        } else {
            // lets use the faster option, always use buffer number 0
            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);
        }

        for (i = 0; i < MAX_TEXTURES; ++i) {
            rendererBoundTextures[i]._virtalBoundId = -1;
        }

        // render the groups..
        for (i = 0; i < groupCount; ++i) {
            var group = groups[i];
            var groupTextureCount = group.textureCount;

            for (var _j = 0; _j < groupTextureCount; _j++) {
                currentTexture = group.textures[_j];

                // reset virtual ids..
                // lets do a quick check..
                if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {
                    this.renderer.bindTexture(currentTexture, group.ids[_j], true);
                }

                // reset the virtualId..
                currentTexture._virtalBoundId = -1;
            }

            // set the blend mode..
            this.renderer.state.setBlendMode(group.blend);

            gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);
        }

        // reset elements for the next flush
        this.currentIndex = 0;
    };

    /**
     * Starts a new sprite batch.
     */


    SpriteRenderer.prototype.start = function start() {
        this.renderer.bindShader(this.shader);

        if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
            // bind buffer #0, we don't need others
            this.renderer.bindVao(this.vaos[this.vertexCount]);

            this.vertexBuffers[this.vertexCount].bind();
        }
    };

    /**
     * Stops and flushes the current batch.
     *
     */


    SpriteRenderer.prototype.stop = function stop() {
        this.flush();
    };

    /**
     * Destroys the SpriteRenderer.
     *
     */


    SpriteRenderer.prototype.destroy = function destroy() {
        for (var i = 0; i < this.vaoMax; i++) {
            if (this.vertexBuffers[i]) {
                this.vertexBuffers[i].destroy();
            }
            if (this.vaos[i]) {
                this.vaos[i].destroy();
            }
        }

        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }

        this.renderer.off('prerender', this.onPrerender, this);

        _ObjectRenderer.prototype.destroy.call(this);

        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }

        this.vertexBuffers = null;
        this.vaos = null;
        this.indexBuffer = null;
        this.indices = null;

        this.sprites = null;

        for (var _i = 0; _i < this.buffers.length; ++_i) {
            this.buffers[_i].destroy();
        }
    };

    return SpriteRenderer;
}(_ObjectRenderer3.default);

exports.default = SpriteRenderer;


_WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);
//# sourceMappingURL=SpriteRenderer.js.map

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = generateMultiTextureShader;

var _Shader = __webpack_require__(17);

var _Shader2 = _interopRequireDefault(_Shader);

var _path = __webpack_require__(47);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fragTemplate = ['varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureId;', 'uniform sampler2D uSamplers[%count%];', 'void main(void){', 'vec4 color;', 'float textureId = floor(vTextureId+0.5);', '%forloop%', 'gl_FragColor = color * vColor;', '}'].join('\n');

function generateMultiTextureShader(gl, maxTextures) {
    var vertexSrc = 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n';
    var fragmentSrc = fragTemplate;

    fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
    fragmentSrc = fragmentSrc.replace(/%forloop%/gi, generateSampleSrc(maxTextures));

    var shader = new _Shader2.default(gl, vertexSrc, fragmentSrc);

    var sampleValues = [];

    for (var i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
    }

    shader.bind();
    shader.uniforms.uSamplers = sampleValues;

    return shader;
}

function generateSampleSrc(maxTextures) {
    var src = '';

    src += '\n';
    src += '\n';

    for (var i = 0; i < maxTextures; i++) {
        if (i > 0) {
            src += '\nelse ';
        }

        if (i < maxTextures - 1) {
            src += 'if(textureId == ' + i + '.0)';
        }

        src += '\n{';
        src += '\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);';
        src += '\n}';
    }

    src += '\n';
    src += '\n';

    return src;
}
//# sourceMappingURL=generateMultiTextureShader.js.map

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Sprite2 = __webpack_require__(31);

var _Sprite3 = _interopRequireDefault(_Sprite2);

var _Texture = __webpack_require__(15);

var _Texture2 = _interopRequireDefault(_Texture);

var _math = __webpack_require__(2);

var _utils = __webpack_require__(1);

var _const = __webpack_require__(0);

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _TextStyle = __webpack_require__(72);

var _TextStyle2 = _interopRequireDefault(_TextStyle);

var _trimCanvas = __webpack_require__(159);

var _trimCanvas2 = _interopRequireDefault(_trimCanvas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint max-depth: [2, 8] */


var defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true
};

/**
 * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
 *
 * A Text can be created directly from a string and a style object
 *
 * ```js
 * let text = new PIXI.Text('This is a pixi text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});
 * ```
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI
 */

var Text = function (_Sprite) {
    _inherits(Text, _Sprite);

    /**
     * @param {string} text - The string that you would like the text to display
     * @param {object|PIXI.TextStyle} [style] - The style parameters
     * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text
     */
    function Text(text, style, canvas) {
        _classCallCheck(this, Text);

        canvas = canvas || document.createElement('canvas');

        canvas.width = 3;
        canvas.height = 3;

        var texture = _Texture2.default.fromCanvas(canvas);

        texture.orig = new _math.Rectangle();
        texture.trim = new _math.Rectangle();

        /**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */
        var _this = _possibleConstructorReturn(this, _Sprite.call(this, texture));

        _this.canvas = canvas;

        /**
         * The canvas 2d context that everything is drawn with
         * @member {CanvasRenderingContext2D}
         */
        _this.context = _this.canvas.getContext('2d');

        /**
         * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.
         * @member {number}
         * @default 1
         */
        _this.resolution = _settings2.default.RESOLUTION;

        /**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */
        _this._text = null;

        /**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */
        _this._style = null;
        /**
         * Private listener to track style changes.
         *
         * @member {Function}
         * @private
         */
        _this._styleListener = null;

        /**
         * Private tracker for the current font.
         *
         * @member {string}
         * @private
         */
        _this._font = '';

        _this.text = text;
        _this.style = style;

        _this.localStyleID = -1;
        return _this;
    }

    /**
     * Renders text and updates it when needed.
     *
     * @private
     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
     */


    Text.prototype.updateText = function updateText(respectDirty) {
        var style = this._style;

        // check if style has changed..
        if (this.localStyleID !== style.styleID) {
            this.dirty = true;
            this.localStyleID = style.styleID;
        }

        if (!this.dirty && respectDirty) {
            return;
        }

        this._font = Text.getFontStyle(style);

        this.context.font = this._font;

        // word wrap
        // preserve original text
        var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;

        // split text into lines
        var lines = outputText.split(/(?:\r\n|\r|\n)/);

        // calculate text width
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        var fontProperties = Text.calculateFontProperties(this._font);

        for (var i = 0; i < lines.length; i++) {
            var lineWidth = this.context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;

            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }

        var width = maxLineWidth + style.strokeThickness;

        if (style.dropShadow) {
            width += style.dropShadowDistance;
        }

        this.canvas.width = Math.ceil((width + style.padding * 2) * this.resolution);

        // calculate text height
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;

        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * lineHeight;

        if (style.dropShadow) {
            height += style.dropShadowDistance;
        }

        this.canvas.height = Math.ceil((height + style.padding * 2) * this.resolution);

        this.context.scale(this.resolution, this.resolution);

        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.context.font = this._font;
        this.context.strokeStyle = style.stroke;
        this.context.lineWidth = style.strokeThickness;
        this.context.textBaseline = style.textBaseline;
        this.context.lineJoin = style.lineJoin;
        this.context.miterLimit = style.miterLimit;

        var linePositionX = void 0;
        var linePositionY = void 0;

        if (style.dropShadow) {
            this.context.shadowBlur = style.dropShadowBlur;
            this.context.globalAlpha = style.dropShadowAlpha;

            if (style.dropShadowBlur > 0) {
                this.context.shadowColor = style.dropShadowColor;
            } else {
                this.context.fillStyle = style.dropShadowColor;
            }

            var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;

            for (var _i = 0; _i < lines.length; _i++) {
                linePositionX = style.strokeThickness / 2;
                linePositionY = style.strokeThickness / 2 + _i * lineHeight + fontProperties.ascent;

                if (style.align === 'right') {
                    linePositionX += maxLineWidth - lineWidths[_i];
                } else if (style.align === 'center') {
                    linePositionX += (maxLineWidth - lineWidths[_i]) / 2;
                }

                if (style.fill) {
                    this.drawLetterSpacing(lines[_i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding);

                    if (style.stroke && style.strokeThickness) {
                        this.context.strokeStyle = style.dropShadowColor;
                        this.drawLetterSpacing(lines[_i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding, true);
                        this.context.strokeStyle = style.stroke;
                    }
                }
            }
        }

        // reset the shadow blur and alpha that was set by the drop shadow, for the regular text
        this.context.shadowBlur = 0;
        this.context.globalAlpha = 1;

        // set canvas text styles
        this.context.fillStyle = this._generateFillStyle(style, lines);

        // draw lines line by line
        for (var _i2 = 0; _i2 < lines.length; _i2++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + _i2 * lineHeight + fontProperties.ascent;

            if (style.align === 'right') {
                linePositionX += maxLineWidth - lineWidths[_i2];
            } else if (style.align === 'center') {
                linePositionX += (maxLineWidth - lineWidths[_i2]) / 2;
            }

            if (style.stroke && style.strokeThickness) {
                this.drawLetterSpacing(lines[_i2], linePositionX + style.padding, linePositionY + style.padding, true);
            }

            if (style.fill) {
                this.drawLetterSpacing(lines[_i2], linePositionX + style.padding, linePositionY + style.padding);
            }
        }

        this.updateTexture();
    };

    /**
     * Render the text with letter-spacing.
     * @param {string} text - The text to draw
     * @param {number} x - Horizontal position to draw the text
     * @param {number} y - Vertical position to draw the text
     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
     *  text? If not, it's for the inside fill
     * @private
     */


    Text.prototype.drawLetterSpacing = function drawLetterSpacing(text, x, y) {
        var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var style = this._style;

        // letterSpacing of 0 means normal
        var letterSpacing = style.letterSpacing;

        if (letterSpacing === 0) {
            if (isStroke) {
                this.context.strokeText(text, x, y);
            } else {
                this.context.fillText(text, x, y);
            }

            return;
        }

        var characters = String.prototype.split.call(text, '');
        var currentPosition = x;
        var index = 0;
        var current = '';

        while (index < text.length) {
            current = characters[index++];
            if (isStroke) {
                this.context.strokeText(current, currentPosition, y);
            } else {
                this.context.fillText(current, currentPosition, y);
            }
            currentPosition += this.context.measureText(current).width + letterSpacing;
        }
    };

    /**
     * Updates texture size based on canvas size
     *
     * @private
     */


    Text.prototype.updateTexture = function updateTexture() {
        if (this._style.trim) {
            var trimmed = (0, _trimCanvas2.default)(this.canvas);

            this.canvas.width = trimmed.width;
            this.canvas.height = trimmed.height;
            this.context.putImageData(trimmed.data, 0, 0);
        }

        var texture = this._texture;
        var style = this._style;

        texture.baseTexture.hasLoaded = true;
        texture.baseTexture.resolution = this.resolution;

        texture.baseTexture.realWidth = this.canvas.width;
        texture.baseTexture.realHeight = this.canvas.height;
        texture.baseTexture.width = this.canvas.width / this.resolution;
        texture.baseTexture.height = this.canvas.height / this.resolution;
        texture.trim.width = texture._frame.width = this.canvas.width / this.resolution;
        texture.trim.height = texture._frame.height = this.canvas.height / this.resolution;

        texture.trim.x = -style.padding;
        texture.trim.y = -style.padding;

        texture.orig.width = texture._frame.width - style.padding * 2;
        texture.orig.height = texture._frame.height - style.padding * 2;

        // call sprite onTextureUpdate to update scale if _width or _height were set
        this._onTextureUpdate();

        texture.baseTexture.emit('update', texture.baseTexture);

        this.dirty = false;
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.WebGLRenderer} renderer - The renderer
     */


    Text.prototype.renderWebGL = function renderWebGL(renderer) {
        if (this.resolution !== renderer.resolution) {
            this.resolution = renderer.resolution;
            this.dirty = true;
        }

        this.updateText(true);

        _Sprite.prototype.renderWebGL.call(this, renderer);
    };

    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */


    Text.prototype._renderCanvas = function _renderCanvas(renderer) {
        if (this.resolution !== renderer.resolution) {
            this.resolution = renderer.resolution;
            this.dirty = true;
        }

        this.updateText(true);

        _Sprite.prototype._renderCanvas.call(this, renderer);
    };

    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @private
     * @param {string} text - String to apply word wrapping to
     * @return {string} New string with new lines applied where required
     */


    Text.prototype.wordWrap = function wordWrap(text) {
        // Greedy wrapping algorithm that will wrap words as the line grows longer
        // than its horizontal bounds.
        var result = '';
        var style = this._style;
        var lines = text.split('\n');
        var wordWrapWidth = style.wordWrapWidth;

        for (var i = 0; i < lines.length; i++) {
            var spaceLeft = wordWrapWidth;
            var words = lines[i].split(' ');

            for (var j = 0; j < words.length; j++) {
                var wordWidth = this.context.measureText(words[j]).width;

                if (style.breakWords && wordWidth > wordWrapWidth) {
                    // Word should be split in the middle
                    var characters = words[j].split('');

                    for (var c = 0; c < characters.length; c++) {
                        var characterWidth = this.context.measureText(characters[c]).width;

                        if (characterWidth > spaceLeft) {
                            result += '\n' + characters[c];
                            spaceLeft = wordWrapWidth - characterWidth;
                        } else {
                            if (c === 0) {
                                result += ' ';
                            }

                            result += characters[c];
                            spaceLeft -= characterWidth;
                        }
                    }
                } else {
                    var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;

                    if (j === 0 || wordWidthWithSpace > spaceLeft) {
                        // Skip printing the newline if it's the first word of the line that is
                        // greater than the word wrap width.
                        if (j > 0) {
                            result += '\n';
                        }
                        result += words[j];
                        spaceLeft = wordWrapWidth - wordWidth;
                    } else {
                        spaceLeft -= wordWidthWithSpace;
                        result += ' ' + words[j];
                    }
                }
            }

            if (i < lines.length - 1) {
                result += '\n';
            }
        }

        return result;
    };

    /**
     * Gets the local bounds of the text object.
     *
     * @param {Rectangle} rect - The output rectangle.
     * @return {Rectangle} The bounds.
     */


    Text.prototype.getLocalBounds = function getLocalBounds(rect) {
        this.updateText(true);

        return _Sprite.prototype.getLocalBounds.call(this, rect);
    };

    /**
     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
     */


    Text.prototype._calculateBounds = function _calculateBounds() {
        this.updateText(true);
        this.calculateVertices();
        // if we have already done this on THIS frame.
        this._bounds.addQuad(this.vertexData);
    };

    /**
     * Method to be called upon a TextStyle change.
     * @private
     */


    Text.prototype._onStyleChange = function _onStyleChange() {
        this.dirty = true;
    };

    /**
     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
     *
     * @private
     * @param {object} style - The style.
     * @param {string[]} lines - The lines of text.
     * @return {string|number|CanvasGradient} The fill style
     */


    Text.prototype._generateFillStyle = function _generateFillStyle(style, lines) {
        if (!Array.isArray(style.fill)) {
            return style.fill;
        }

        // cocoon on canvas+ cannot generate textures, so use the first colour instead
        if (navigator.isCocoonJS) {
            return style.fill[0];
        }

        // the gradient will be evenly spaced out according to how large the array is.
        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
        var gradient = void 0;
        var totalIterations = void 0;
        var currentIteration = void 0;
        var stop = void 0;

        var width = this.canvas.width / this.resolution;
        var height = this.canvas.height / this.resolution;

        // make a copy of the style settings, so we can manipulate them later
        var fill = style.fill.slice();
        var fillGradientStops = style.fillGradientStops.slice();

        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
        if (!fillGradientStops.length) {
            var lengthPlus1 = fill.length + 1;

            for (var i = 1; i < lengthPlus1; ++i) {
                fillGradientStops.push(i / lengthPlus1);
            }
        }

        // stop the bleeding of the last gradient on the line above to the top gradient of the this line
        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1
        fill.unshift(style.fill[0]);
        fillGradientStops.unshift(0);

        fill.push(style.fill[style.fill.length - 1]);
        fillGradientStops.push(1);

        if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);

            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
            totalIterations = (fill.length + 1) * lines.length;
            currentIteration = 0;
            for (var _i3 = 0; _i3 < lines.length; _i3++) {
                currentIteration += 1;
                for (var j = 0; j < fill.length; j++) {
                    if (fillGradientStops[j]) {
                        stop = fillGradientStops[j] / lines.length + _i3 / lines.length;
                    } else {
                        stop = currentIteration / totalIterations;
                    }
                    gradient.addColorStop(stop, fill[j]);
                    currentIteration++;
                }
            }
        } else {
            // start the gradient at the center left of the canvas, and end at the center right of the canvas
            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);

            // can just evenly space out the gradients in this case, as multiple lines makes no difference
            // to an even left to right gradient
            totalIterations = fill.length + 1;
            currentIteration = 1;

            for (var _i4 = 0; _i4 < fill.length; _i4++) {
                if (fillGradientStops[_i4]) {
                    stop = fillGradientStops[_i4];
                } else {
                    stop = currentIteration / totalIterations;
                }
                gradient.addColorStop(stop, fill[_i4]);
                currentIteration++;
            }
        }

        return gradient;
    };

    /**
     * Destroys this text object.
     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
     * the majority of the time the texture will not be shared with any other Sprites.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
     */


    Text.prototype.destroy = function destroy(options) {
        if (typeof options === 'boolean') {
            options = { children: options };
        }

        options = Object.assign({}, defaultDestroyOptions, options);

        _Sprite.prototype.destroy.call(this, options);

        // make sure to reset the the context and canvas.. dont want this hanging around in memory!
        this.context = null;
        this.canvas = null;

        this._style = null;
    };

    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */


    /**
     * Generates a font style string to use for Text.calculateFontProperties(). Takes the same parameter
     * as Text.style.
     *
     * @static
     * @param {object|TextStyle} style - String representing the style of the font
     * @return {string} Font style string, for passing to Text.calculateFontProperties()
     */
    Text.getFontStyle = function getFontStyle(style) {
        style = style || {};

        if (!(style instanceof _TextStyle2.default)) {
            style = new _TextStyle2.default(style);
        }

        // build canvas api font setting from individual components. Convert a numeric style.fontSize to px
        var fontSizeString = typeof style.fontSize === 'number' ? style.fontSize + 'px' : style.fontSize;

        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = style.fontFamily;

        if (!Array.isArray(style.fontFamily)) {
            fontFamilies = style.fontFamily.split(',');
        }

        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();

            // Check if font already contains strings
            if (!/([\"\'])[^\'\"]+\1/.test(fontFamily)) {
                fontFamily = '"' + fontFamily + '"';
            }
            fontFamilies[i] = fontFamily;
        }

        return style.fontStyle + ' ' + style.fontVariant + ' ' + style.fontWeight + ' ' + fontSizeString + ' ' + fontFamilies.join(',');
    };

    /**
     * Calculates the ascent, descent and fontSize of a given fontStyle
     *
     * @static
     * @param {string} fontStyle - String representing the style of the font
     * @return {Object} Font properties object
     */


    Text.calculateFontProperties = function calculateFontProperties(fontStyle) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (Text.fontPropertiesCache[fontStyle]) {
            return Text.fontPropertiesCache[fontStyle];
        }

        var properties = {};

        var canvas = Text.fontPropertiesCanvas;
        var context = Text.fontPropertiesContext;

        context.font = fontStyle;

        var width = Math.ceil(context.measureText('|MÉq').width);
        var baseline = Math.ceil(context.measureText('M').width);
        var height = 2 * baseline;

        baseline = baseline * 1.4 | 0;

        canvas.width = width;
        canvas.height = height;

        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);

        context.font = fontStyle;

        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText('|MÉq', 0, baseline);

        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;

        var i = 0;
        var idx = 0;
        var stop = false;

        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            } else {
                break;
            }
        }

        properties.ascent = baseline - i;

        idx = pixels - line;
        stop = false;

        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var _j = 0; _j < line; _j += 4) {
                if (imagedata[idx + _j] !== 255) {
                    stop = true;
                    break;
                }
            }

            if (!stop) {
                idx -= line;
            } else {
                break;
            }
        }

        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;

        Text.fontPropertiesCache[fontStyle] = properties;

        return properties;
    };

    _createClass(Text, [{
        key: 'width',
        get: function get() {
            this.updateText(true);

            return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.updateText(true);

            var s = (0, _utils.sign)(this.scale.x) || 1;

            this.scale.x = s * value / this._texture.orig.width;
            this._width = value;
        }

        /**
         * The height of the Text, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

    }, {
        key: 'height',
        get: function get() {
            this.updateText(true);

            return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
            this.updateText(true);

            var s = (0, _utils.sign)(this.scale.y) || 1;

            this.scale.y = s * value / this._texture.orig.height;
            this._height = value;
        }

        /**
         * Set the style of the text. Set up an event listener to listen for changes on the style
         * object and mark the text as dirty.
         *
         * @member {object|PIXI.TextStyle}
         */

    }, {
        key: 'style',
        get: function get() {
            return this._style;
        },
        set: function set(style) // eslint-disable-line require-jsdoc
        {
            style = style || {};

            if (style instanceof _TextStyle2.default) {
                this._style = style;
            } else {
                this._style = new _TextStyle2.default(style);
            }

            this.localStyleID = -1;
            this.dirty = true;
        }

        /**
         * Set the copy for the text object. To split a line you can use '\n'.
         *
         * @member {string}
         */

    }, {
        key: 'text',
        get: function get() {
            return this._text;
        },
        set: function set(text) // eslint-disable-line require-jsdoc
        {
            text = String(text === '' || text === null || text === undefined ? ' ' : text);

            if (this._text === text) {
                return;
            }
            this._text = text;
            this.dirty = true;
        }
    }]);

    return Text;
}(_Sprite3.default);

exports.default = Text;


Text.fontPropertiesCache = {};
Text.fontPropertiesCanvas = document.createElement('canvas');
Text.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');
//# sourceMappingURL=Text.js.map

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ = __webpack_require__(62);

var _utils = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility class for maintaining reference to a collection
 * of Textures on a single Spritesheet.
 *
 * @class
 * @memberof PIXI
 */
var Spritesheet = function () {
    _createClass(Spritesheet, null, [{
        key: 'BATCH_SIZE',

        /**
         * The maximum number of Textures to build per process.
         *
         * @type {number}
         * @default 1000
         */
        get: function get() {
            return 1000;
        }

        /**
         * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.
         * @param {Object} data - Spritesheet image data.
         * @param {string} [resolutionFilename] - The filename to consider when determining
         *        the resolution of the spritesheet. If not provided, the imageUrl will
         *        be used on the BaseTexture.
         */

    }]);

    function Spritesheet(baseTexture, data) {
        var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, Spritesheet);

        /**
         * Reference to ths source texture
         * @type {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;

        /**
         * Map of spritesheet textures.
         * @type {Object}
         */
        this.textures = {};

        /**
         * Reference to the original JSON data.
         * @type {Object}
         */
        this.data = data;

        /**
         * The resolution of the spritesheet.
         * @type {number}
         */
        this.resolution = this._updateResolution(resolutionFilename || this.baseTexture.imageUrl);

        /**
         * Map of spritesheet frames.
         * @type {Object}
         * @private
         */
        this._frames = this.data.frames;

        /**
         * Collection of frame names.
         * @type {string[]}
         * @private
         */
        this._frameKeys = Object.keys(this._frames);

        /**
         * Current batch index being processed.
         * @type {number}
         * @private
         */
        this._batchIndex = 0;

        /**
         * Callback when parse is completed.
         * @type {Function}
         * @private
         */
        this._callback = null;
    }

    /**
     * Generate the resolution from the filename or fallback
     * to the meta.scale field of the JSON data.
     *
     * @private
     * @param {string} resolutionFilename - The filename to use for resolving
     *        the default resolution.
     * @return {number} Resolution to use for spritesheet.
     */


    Spritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {
        var scale = this.data.meta.scale;

        // Use a defaultValue of `null` to check if a url-based resolution is set
        var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null);

        // No resolution found via URL
        if (resolution === null) {
            // Use the scale value or default to 1
            resolution = scale !== undefined ? parseFloat(scale) : 1;
        }

        // For non-1 resolutions, update baseTexture
        if (resolution !== 1) {
            this.baseTexture.resolution = resolution;
            this.baseTexture.update();
        }

        return resolution;
    };

    /**
     * Parser spritesheet from loaded data. This is done asynchronously
     * to prevent creating too many Texture within a single process.
     *
     * @param {Function} callback - Callback when complete returns
     *        a map of the Textures for this spritesheet.
     */


    Spritesheet.prototype.parse = function parse(callback) {
        this._batchIndex = 0;
        this._callback = callback;

        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._parseComplete();
        } else {
            this._nextBatch();
        }
    };

    /**
     * Process a batch of frames
     *
     * @private
     * @param {number} initialFrameIndex - The index of frame to start.
     */


    Spritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet.BATCH_SIZE;

        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            var i = this._frameKeys[frameIndex];
            var rect = this._frames[i].frame;

            if (rect) {
                var frame = null;
                var trim = null;
                var orig = new _.Rectangle(0, 0, this._frames[i].sourceSize.w / this.resolution, this._frames[i].sourceSize.h / this.resolution);

                if (this._frames[i].rotated) {
                    frame = new _.Rectangle(rect.x / this.resolution, rect.y / this.resolution, rect.h / this.resolution, rect.w / this.resolution);
                } else {
                    frame = new _.Rectangle(rect.x / this.resolution, rect.y / this.resolution, rect.w / this.resolution, rect.h / this.resolution);
                }

                //  Check to see if the sprite is trimmed
                if (this._frames[i].trimmed) {
                    trim = new _.Rectangle(this._frames[i].spriteSourceSize.x / this.resolution, this._frames[i].spriteSourceSize.y / this.resolution, rect.w / this.resolution, rect.h / this.resolution);
                }

                this.textures[i] = new _.Texture(this.baseTexture, frame, orig, trim, this._frames[i].rotated ? 2 : 0);

                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                _utils.TextureCache[i] = this.textures[i];
            }

            frameIndex++;
        }
    };

    /**
     * The parse has completed.
     *
     * @private
     */


    Spritesheet.prototype._parseComplete = function _parseComplete() {
        var callback = this._callback;

        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    };

    /**
     * Begin the next batch of textures.
     *
     * @private
     */


    Spritesheet.prototype._nextBatch = function _nextBatch() {
        var _this = this;

        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function () {
            if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {
                _this._nextBatch();
            } else {
                _this._parseComplete();
            }
        }, 0);
    };

    /**
     * Destroy Spritesheet and don't use after this.
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */


    Spritesheet.prototype.destroy = function destroy() {
        var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        for (var i in this.textures) {
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this.baseTexture.destroy();
        }
        this.baseTexture = null;
    };

    return Spritesheet;
}();

exports.default = Spritesheet;
//# sourceMappingURL=Spritesheet.js.map

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _settings = __webpack_require__(3);

var _settings2 = _interopRequireDefault(_settings);

var _eventemitter = __webpack_require__(9);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Internal event used by composed emitter
var TICK = 'tick';

/**
 * A Ticker class that runs an update loop that other objects listen to.
 * This class is composed around an EventEmitter object to add listeners
 * meant for execution on the next requested animation frame.
 * Animation frames are requested only when necessary,
 * e.g. When the ticker is started and the emitter has listeners.
 *
 * @class
 * @memberof PIXI.ticker
 */

var Ticker = function () {
    /**
     *
     */
    function Ticker() {
        var _this = this;

        _classCallCheck(this, Ticker);

        /**
         * Internal emitter used to fire 'tick' event
         * @private
         */
        this._emitter = new _eventemitter2.default();

        /**
         * Internal current frame request ID
         * @private
         */
        this._requestId = null;

        /**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         * @private
         */
        this._maxElapsedMS = 100;

        /**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.ticker.Ticker#start} automatically
         * when a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.autoStart = false;

        /**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
         * and is scaled with {@link PIXI.ticker.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         *
         * @member {number}
         * @default 1
         */
        this.deltaTime = 1;

        /**
         * Time elapsed in milliseconds from last frame to this frame.
         * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
         * is based, this value is neither capped nor scaled.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.elapsedMS = 1 / _settings2.default.TARGET_FPMS;

        /**
         * The last time {@link PIXI.ticker.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         *
         * @member {number}
         * @default 0
         */
        this.lastTime = 0;

        /**
         * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         *
         * @member {number}
         * @default 1
         */
        this.speed = 1;

        /**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.ticker.Ticker#start} has been called.
         * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
         * and a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.started = false;

        /**
         * Internal tick method bound to ticker instance.
         * This is because in early 2015, Function.bind
         * is still 60% slower in high performance scenarios.
         * Also separating frame requests from update method
         * so listeners may be called at any time and with
         * any animation API, just invoke ticker.update(time).
         *
         * @private
         * @param {number} time - Time since last tick.
         */
        this._tick = function (time) {
            _this._requestId = null;

            if (_this.started) {
                // Invoke listeners now
                _this.update(time);
                // Listener side effects may have modified ticker state.
                if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true)) {
                    _this._requestId = requestAnimationFrame(_this._tick);
                }
            }
        };
    }

    /**
     * Conditionally requests a new animation frame.
     * If a frame has not already been requested, and if the internal
     * emitter has listeners, a new frame is requested.
     *
     * @private
     */


    Ticker.prototype._requestIfNeeded = function _requestIfNeeded() {
        if (this._requestId === null && this._emitter.listeners(TICK, true)) {
            // ensure callbacks get correct delta
            this.lastTime = performance.now();
            this._requestId = requestAnimationFrame(this._tick);
        }
    };

    /**
     * Conditionally cancels a pending animation frame.
     *
     * @private
     */


    Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    };

    /**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */


    Ticker.prototype._startIfPossible = function _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        } else if (this.autoStart) {
            this.start();
        }
    };

    /**
     * Calls {@link module:eventemitter3.EventEmitter#on} internally for the
     * internal 'tick' event. It checks if the emitter has listeners,
     * and if so it requests a new animation frame at this point.
     *
     * @param {Function} fn - The listener function to be added for updates
     * @param {Function} [context] - The listener context
     * @returns {PIXI.ticker.Ticker} This instance of a ticker
     */


    Ticker.prototype.add = function add(fn, context) {
        this._emitter.on(TICK, fn, context);

        this._startIfPossible();

        return this;
    };

    /**
     * Calls {@link module:eventemitter3.EventEmitter#once} internally for the
     * internal 'tick' event. It checks if the emitter has listeners,
     * and if so it requests a new animation frame at this point.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} [context] - The listener context
     * @returns {PIXI.ticker.Ticker} This instance of a ticker
     */


    Ticker.prototype.addOnce = function addOnce(fn, context) {
        this._emitter.once(TICK, fn, context);

        this._startIfPossible();

        return this;
    };

    /**
     * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.
     * It checks if the emitter has listeners for 'tick' event.
     * If it does, then it cancels the animation frame.
     *
     * @param {Function} [fn] - The listener function to be removed
     * @param {Function} [context] - The listener context to be removed
     * @returns {PIXI.ticker.Ticker} This instance of a ticker
     */


    Ticker.prototype.remove = function remove(fn, context) {
        this._emitter.off(TICK, fn, context);

        if (!this._emitter.listeners(TICK, true)) {
            this._cancelIfNeeded();
        }

        return this;
    };

    /**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */


    Ticker.prototype.start = function start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    };

    /**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */


    Ticker.prototype.stop = function stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    };

    /**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.ticker.Ticker#elapsedMS},
     * the current {@link PIXI.ticker.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.ticker.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */


    Ticker.prototype.update = function update() {
        var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();

        var elapsedMS = void 0;

        // If the difference in time is zero or negative, we ignore most of the work done here.
        // If there is no valid difference, then should be no reason to let anyone know about it.
        // A zero delta, is exactly that, nothing should update.
        //
        // The difference in time can be negative, and no this does not mean time traveling.
        // This can be the result of a race condition between when an animation frame is requested
        // on the current JavaScript engine event loop, and when the ticker's start method is invoked
        // (which invokes the internal _requestIfNeeded method). If a frame is requested before
        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
        // can receive a time argument that can be less than the lastTime value that was set within
        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
        //
        // This check covers this browser engine timing issue, as well as if consumers pass an invalid
        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.

        if (currentTime > this.lastTime) {
            // Save uncapped elapsedMS for measurement
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;

            // cap the milliseconds elapsed used for deltaTime
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }

            this.deltaTime = elapsedMS * _settings2.default.TARGET_FPMS * this.speed;

            // Invoke listeners added to internal emitter
            this._emitter.emit(TICK, this.deltaTime);
        } else {
            this.deltaTime = this.elapsedMS = 0;
        }

        this.lastTime = currentTime;
    };

    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.ticker.Ticker#speed}, which is specific
     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
     *
     * @member {number}
     * @readonly
     */


    _createClass(Ticker, [{
        key: 'FPS',
        get: function get() {
            return 1000 / this.elapsedMS;
        }

        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link PIXI.ticker.Ticker#update}.
         * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
         * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
         *
         * @member {number}
         * @default 10
         */

    }, {
        key: 'minFPS',
        get: function get() {
            return 1000 / this._maxElapsedMS;
        },
        set: function set(fps) // eslint-disable-line require-jsdoc
        {
            // Clamp: 0 to TARGET_FPMS
            var minFPMS = Math.min(Math.max(0, fps) / 1000, _settings2.default.TARGET_FPMS);

            this._maxElapsedMS = 1 / minFPMS;
        }
    }]);

    return Ticker;
}();

exports.default = Ticker;
//# sourceMappingURL=Ticker.js.map

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = canUploadSameBuffer;
function canUploadSameBuffer() {
	// Uploading the same buffer multiple times in a single frame can cause perf issues.
	// Apparent on IOS so only check for that at the moment
	// this check may become more complex if this issue pops up elsewhere.
	var ios = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);

	return !ios;
}
//# sourceMappingURL=canUploadSameBuffer.js.map

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = determineCrossOrigin;

var _url2 = __webpack_require__(166);

var _url3 = _interopRequireDefault(_url2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tempAnchor = void 0;

/**
 * Sets the `crossOrigin` property for this resource based on if the url
 * for this resource is cross-origin. If crossOrigin was manually set, this
 * function does nothing.
 * Nipped from the resource loader!
 *
 * @ignore
 * @param {string} url - The url to test.
 * @param {object} [loc=window.location] - The location object to test against.
 * @return {string} The crossOrigin value to use (or empty string for none).
 */
function determineCrossOrigin(url) {
    var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location;

    // data: and javascript: urls are considered same-origin
    if (url.indexOf('data:') === 0) {
        return '';
    }

    // default is window.location
    loc = loc || window.location;

    if (!tempAnchor) {
        tempAnchor = document.createElement('a');
    }

    // let the browser determine the full href for the url of this resource and then
    // parse with the node url lib, we can't use the properties of the anchor element
    // because they don't work in IE9 :(
    tempAnchor.href = url;
    url = _url3.default.parse(tempAnchor.href);

    var samePort = !url.port && loc.port === '' || url.port === loc.port;

    // if cross origin
    if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
        return 'anonymous';
    }

    return '';
}
//# sourceMappingURL=determineCrossOrigin.js.map

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = maxRecommendedTextures;

var _ismobilejs = __webpack_require__(46);

var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function maxRecommendedTextures(max) {
    if (_ismobilejs2.default.tablet || _ismobilejs2.default.phone) {
        // check if the res is iphone 6 or higher..
        return 4;
    }

    // desktop should be ok
    return max;
}
//# sourceMappingURL=maxRecommendedTextures.js.map

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.mixin = mixin;
exports.delayMixin = delayMixin;
exports.performMixins = performMixins;
/**
 * Mixes all enumerable properties and methods from a source object to a target object.
 *
 * @memberof PIXI.utils.mixins
 * @function mixin
 * @param {object} target The prototype or instance that properties and methods should be added to.
 * @param {object} source The source of properties and methods to mix in.
 */
function mixin(target, source) {
    if (!target || !source) return;
    // in ES8/ES2017, this would be really easy:
    // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));

    // get all the enumerable property keys
    var keys = Object.keys(source);

    // loop through properties
    for (var i = 0; i < keys.length; ++i) {
        var propertyName = keys[i];

        // Set the property using the property descriptor - this works for accessors and normal value properties
        Object.defineProperty(target, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
}

var mixins = [];

/**
 * Queues a mixin to be handled towards the end of the initialization of PIXI, so that deprecation
 * can take effect.
 *
 * @memberof PIXI.utils.mixins
 * @function delayMixin
 * @private
 * @param {object} target The prototype or instance that properties and methods should be added to.
 * @param {object} source The source of properties and methods to mix in.
 */
function delayMixin(target, source) {
    mixins.push(target, source);
}

/**
 * Handles all mixins queued via delayMixin().
 *
 * @memberof PIXI.utils.mixins
 * @function performMixins
 * @private
 */
function performMixins() {
    for (var i = 0; i < mixins.length; i += 2) {
        mixin(mixins[i], mixins[i + 1]);
    }
    mixins.length = 0;
}
//# sourceMappingURL=mixin.js.map

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Mixins functionality to make an object have "plugins".
 *
 * @example
 *      function MyObject() {}
 *
 *      pluginTarget.mixin(MyObject);
 *
 * @mixin
 * @memberof PIXI.utils
 * @param {object} obj - The object to mix into.
 */
function pluginTarget(obj) {
    obj.__plugins = {};

    /**
     * Adds a plugin to an object
     *
     * @param {string} pluginName - The events that should be listed.
     * @param {Function} ctor - The constructor function for the plugin.
     */
    obj.registerPlugin = function registerPlugin(pluginName, ctor) {
        obj.__plugins[pluginName] = ctor;
    };

    /**
     * Instantiates all the plugins of this object
     *
     */
    obj.prototype.initPlugins = function initPlugins() {
        this.plugins = this.plugins || {};

        for (var o in obj.__plugins) {
            this.plugins[o] = new obj.__plugins[o](this);
        }
    };

    /**
     * Removes all the plugins of this object
     *
     */
    obj.prototype.destroyPlugins = function destroyPlugins() {
        for (var o in this.plugins) {
            this.plugins[o].destroy();
            this.plugins[o] = null;
        }

        this.plugins = null;
    };
}

exports.default = {
    /**
     * Mixes in the properties of the pluginTarget into another object
     *
     * @param {object} obj - The obj to mix into
     */
    mixin: function mixin(obj) {
        pluginTarget(obj);
    }
};
//# sourceMappingURL=pluginTarget.js.map

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = trimCanvas;
/**
 * Trim transparent borders from a canvas
 *
 * @memberof PIXI
 * @function trimCanvas
 * @private
 * @param {HTMLCanvasElement} canvas - the canvas to trim
 * @returns {object} Trim data
 */
function trimCanvas(canvas) {
    // https://gist.github.com/remy/784508

    var width = canvas.width;
    var height = canvas.height;

    var context = canvas.getContext('2d');
    var imageData = context.getImageData(0, 0, width, height);
    var pixels = imageData.data;
    var len = pixels.length;

    var bound = {
        top: null,
        left: null,
        right: null,
        bottom: null
    };
    var i = void 0;
    var x = void 0;
    var y = void 0;

    for (i = 0; i < len; i += 4) {
        if (pixels[i + 3] !== 0) {
            x = i / 4 % width;
            y = ~~(i / 4 / width);

            if (bound.top === null) {
                bound.top = y;
            }

            if (bound.left === null) {
                bound.left = x;
            } else if (x < bound.left) {
                bound.left = x;
            }

            if (bound.right === null) {
                bound.right = x + 1;
            } else if (bound.right < x) {
                bound.right = x + 1;
            }

            if (bound.bottom === null) {
                bound.bottom = y;
            } else if (bound.bottom < y) {
                bound.bottom = y;
            }
        }
    }

    width = bound.right - bound.left;
    height = bound.bottom - bound.top + 1;

    var data = context.getImageData(bound.left, bound.top, width, height);

    return {
        height: height,
        width: width,
        data: data
    };
}
//# sourceMappingURL=trimCanvas.js.map

/***/ }),
/* 160 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(168)(module), __webpack_require__(22)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(162);
exports.encode = exports.stringify = __webpack_require__(163);


/***/ }),
/* 165 */,
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(161);
var util = __webpack_require__(167);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(164);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GameScene__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__strategies_Singleplayer__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__strategies_Multiplayer__ = __webpack_require__(171);
/**
 * Created by Denis on 02.04.2017.
 */



class GameManager {
    constructor(user, view, strategy) {
        this._subscribed = [];

        this.user = user;
        this.strategy = strategy === window.SINGLEPLAYER_STRATEGY ? new __WEBPACK_IMPORTED_MODULE_1__strategies_Singleplayer__["a" /* default */]() : new __WEBPACK_IMPORTED_MODULE_2__strategies_Multiplayer__["a" /* default */]();
        this.node = view.node;
        this.view = view;

        this.scene = new __WEBPACK_IMPORTED_MODULE_0__GameScene__["a" /* default */](view.node);

        this._start();
    }

    /**
     * Начать игровой процесс
     * @private
     */
    _start(){
        //TODO start strategy
        this.scene.setState(window.STATEWAIT);
        setTimeout(()=>{
            this.opponent = this._getOpponent();
            this.scene.setNames(this.user.login, this.opponent.login);
            this.scene.setState(window.STATEGAME);
        }, 1000);

       /* setTimeout(()=>{
            this.opponent = this._getOpponent();
            this.scene.setUserResult({
                result: 'win',
                divscore: 1
            }, this.user);
            this.scene.setState(window.STATERESULT);
        }, 2000);*/
    }

    /**
     * Получить противника
     * @return {*}
     * @private
     */
    _getOpponent() {
        if (this.strategy.constructor.name === __WEBPACK_IMPORTED_MODULE_1__strategies_Singleplayer__["a" /* default */].name) {
            return {login: 'dc.DRE'};
        } else {
            //TODO search for opponent in global
            return {login: 'MULTIPLAYER'};
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameManager;


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pixi_js_lib_core_index__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pixi_js_lib_core_index___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_pixi_js_lib_core_index__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vendor_three__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vendor_three___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__vendor_three__);
/**
 * Created by Denis on 29.03.2017.
 */


class GameScene {
    constructor(node) {
        this.HDim = 34;
        this.WDim = 50;

        this.router = window.router;
        this.node = node;

        this._setSize();
        this._renderContainer();
    }

    _setSize(){
        const height = window.innerHeight;
        this.fieldSize = (height / this.HDim) | 0;
        this.WIDTH = this.fieldSize * this.WDim;
        this.HEGHT = this.fieldSize / 3 * 2 * this.HDim
    }

    _renderContainer(){
        this.scene = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["Scene"]();
        this.renderer = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["WebGLRenderer"]();
        this.renderer.setClearColor(0xEEEEEE, 1);
        this.renderer.setSize( this.WIDTH, this.HEGHT);
        this.renderer.domElement.setAttribute('class', 'game-area');
        this.renderer.domElement.setAttribute('id', 'game-area');


        this.node.appendChild(this.renderer.domElement);
    }

    _renderField(){
        let axes = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["AxisHelper"]( 20 );
        this.scene.add(axes);

        let planeGeometry = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["PlaneGeometry"](60,20,1,1);
        let planeMaterial = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["MeshBasicMaterial"]({color: 0xcccccc});
        let plane = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["Mesh"](planeGeometry,planeMaterial);
        plane.rotation.x=-0.5*Math.PI;
        plane.position.x = 0;
        plane.position.y = -10;
        plane.position.z = 0;
        this.scene.add(plane);
    }

    _renderHelpFigure(){
        let cubeGeometry = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["CubeGeometry"](4,4,4);
        let cubeMaterial = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["MeshBasicMaterial"](
            {color: 0xff0000, wireframe: true});
        let cube = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["Mesh"](cubeGeometry, cubeMaterial);
        cube.position.x = -4;
        cube.position.y = -7;
        cube.position.z = 0;
        this.scene.add(cube);

        let sphereGeometry = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["SphereGeometry"](4,20,20);
        let sphereMaterial = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["MeshBasicMaterial"](
            {color: 0x7777ff, wireframe: true});
        let sphere = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["Mesh"](sphereGeometry,sphereMaterial);
        sphere.position.x = 20;
        sphere.position.y = -6;
        sphere.position.z = 2;
        this.scene.add(sphere);
    }

    refreshScene(){
        let camera = new __WEBPACK_IMPORTED_MODULE_1__vendor_three__["PerspectiveCamera"](45
            , this.WIDTH / this.HEGHT , 0.1, 1000);

        camera.position.x = 0; // красная
        camera.position.y = 20; // зеленая
        camera.position.z = 35; // синяя
        camera.lookAt(this.scene.position);

        this.renderer.render(this.scene, camera);
    }

    /**
     * Установить текущее состояние
     * @param state - состояние
     */
    setState(state) {
        this.state = state;
        this._renderState();
    }

    /**
     * Отрисовка, относительно входного события
     * @private
     */
    _renderState() {
        switch (this.state) {
            case window.STATEWAIT: {
                this._renderWait();
                break;
            }
            case window.STATEGAME: {
                this._renderGame();
                break;
            }
            case window.STATERESULT: {
                this._renderResult();
                break;
            }
        }
    }

    /**
     * Отрисовка ждущего режима
     * @private
     */
    _renderWait() {
        this.clear();

    }

    /**
     * Отрисовка игрового режима
     * @private
     */
    _renderGame() {
        this.clear();
        //this._resizer();

        this._renderField();
        this._renderHelpFigure();
        this.refreshScene();
        /*this._renderNames();
        //this._renderActionContainer();
        this._renderHealthBar();
        this._renderField();*/
    }

    /**
     * Отрисовка логинов игроков по углам
     * @private
     */
    /*_renderNames() {
        let meLogin = new PIXI.Text(this.players.me, {
            fontFamily: 'Orbitron',
            fontSize: 15,
            fill: 'black',
            align: 'left'
        });
        meLogin.x = 10;
        meLogin.y = 10;

        let opponentLogin = new PIXI.Text(this.players.opponent, {
            fontFamily: 'Orbitron',
            fontSize: 15,
            fill: 'black',
            align: 'right'
        });
        opponentLogin.x = this.app.renderer.width - opponentLogin.width - 10;
        opponentLogin.y = 10;

        this.app.stage.addChild(meLogin, opponentLogin);
    }*/

    /**
     * Отрисовка баланса здоровья
     * @private
     */
    /*_renderHealthBar() {
        //Create the health bar
        this.opponentHealthBar = new PIXI.Container();
        this.opponentHealthBar.position.set(this.app.renderer.width - 12, 40);
        this.app.stage.addChild(this.opponentHealthBar);

        this.myHealthBar = new PIXI.Container();
        this.myHealthBar.position.set(12, 40);
        this.app.stage.addChild(this.myHealthBar);

        //Create the front red rectangle
        let opponentOuterBar = new PIXI.Graphics();
        opponentOuterBar.beginFill(0x081b32);
        opponentOuterBar.drawRect(0, 0, -100, 8);
        opponentOuterBar.endFill();
        this.opponentHealthBar.addChild(opponentOuterBar);

        let myOuterBar = new PIXI.Graphics();
        myOuterBar.beginFill(0x081b32);
        myOuterBar.drawRect(0, 0, 100, 8);
        myOuterBar.endFill();
        this.myHealthBar.addChild(myOuterBar);

        this.opponentHealthBar.outer = opponentOuterBar;
        this.myHealthBar.outer = myOuterBar;
    }*/

    /**
     * Установить текущее здоровье
     * @param health
     */
    /*setMyHealth(health) {
        this.opponentHealthBar.outer.width = health;
    }*/

    /**
     * Установить текущее здоровье противника
     * @param health
     */
    /*setOpponentHealth(health) {
        this.myHealthBar.outer.width = health;
    }*/



    /**
     * Отрисовка послеигрового режима (результаты, итоги)
     * @private
     */
    _renderResult() {
        this.clear();

    }

    /**
     * Отчистка основного контейнера
     */
    clear() {
        this.scene.children.splice(0, this.scene.children.length);
        this.refreshScene();
    }

    /**
     * Установка имен игроков
     * @param me
     * @param opponent
     */
    setNames(me, opponent) {
        this.players = {me: me, opponent: opponent};
    }

    setUserResult(objResult, user) {
        this.objResult = objResult;
    }


}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameScene;


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 02.04.2017.
 */
class MultiPlayerStrategy{
    constructor() {
        console.log('MultiPlayerStrategy.c');
    }

    gameLoop(){

    }

    startGameLoop() {
        this.inteval = setInterval(() => this.gameLoop(), 100);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MultiPlayerStrategy;


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 02.04.2017.
 */
class SinglePlayerStrategy{
    constructor() {

    }

    gameLoop(){

    }

    startGameLoop() {
        this.inteval = setInterval(() => this.gameLoop(), 100);
    }


}
/* harmony export (immutable) */ __webpack_exports__["a"] = SinglePlayerStrategy;


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 02.03.2017.
 */
class Button {
    constructor(options) {
        this.text = options.text;
        this.attrs = options.attrs || [];
        this.el = document.createElement(options.type);
        this._render();
    }

    _setAttrs(attrs) {
        Object.keys(attrs).forEach(name => {
            this.el.setAttribute(name, attrs[name]);
        })
    }

    getElem(){
        return this;
    }

    _render() {
        this.el.innerHTML = this.text;
        this._setAttrs(this.attrs);
    }

    toString() {
        return this.el.outerHTML;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Button;



/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 23.03.2017.
 */

class Diamond {
    constructor(color, strokeWidth) {
        this._render(color || 'white', strokeWidth || '2');
    }

    getElem() {
        return this;
    }

    _render(color, strokeWidth) {
        this.el = document.createElement('canvas');
        this.el.setAttribute('width', '50');
        this.el.setAttribute('height', '50');
        this.el.setAttribute('class', 'diamond');
        if(this.el.getContext){
            let context = this.el.getContext('2d');
            context.beginPath();
            context.lineWidth=`${strokeWidth}`;
            context.strokeStyle=`${color}`;
            context.moveTo(12,8);
            context.lineTo(38,8);
            context.lineTo(47,19);
            context.lineTo(25,45);
            context.lineTo(2,19);
            context.lineTo(12,8);
            context.lineTo(17,19);
            context.lineTo(25,8);
            context.lineTo(32,19);
            context.lineTo(38,8);
            context.moveTo(2,19);
            context.lineTo(47,19);
            context.moveTo(17,19);
            context.lineTo(25,45);
            context.lineTo(32,19);
            context.stroke();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Diamond;


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__ = __webpack_require__(78);
/**
 * Created by Denis on 02.03.2017.
 */


class Input {
    constructor(options) {
        this.text = options.text;
        this.attrs = options.attrs || [];
        this.help_attrs = options.help_attrs || [];
        this.el = document.createElement('input');
        this.help_el = document.createElement('p');
        this._render();
    }

    _setAttrs(attrs, elem) {
        Object.keys(attrs).forEach(name => {
            elem.setAttribute(name, attrs[name]);
        })
    }

    _render() {
        this._setAttrs(this.attrs, this.el);
        this._setAttrs(this.help_attrs, this.help_el);
    }

    getElem(){
        return this;
    }

    toString() {
        return this.el.outerHTML;
    }

    validate(prev) {
        let check = true;
        if (__WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].checkEmpty(this.el.value)) {
            __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].fieldSetErr(this.el);
            __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].helpSetText(this.help_el, 'empty field');
            check = false;
        } else {
            __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].fieldRemoveErr(this.el);
            __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].helpSetText(this.help_el, '');

            const valid = this.el.getAttribute('valid');
            if (valid === 'login') {
                let result = __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].checkLogin({field: this.el, help: this.help_el});
                if (check === true) {
                    check = result;
                }
            } else if (valid === 'password') {

            } else if (valid === 'repeatpassword') {
                let result = __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].checkPassword(
                    {field: prev.el, help: prev.help_el},
                    {field: this.el, help: this.help_el});
                if (check === true) {
                    check = result;
                }
            }
        }
        return check;
    }

    clear() {
        __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].helpSetText(this.help_el, '');
        __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].fieldSetText(this.el, '');
        __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].fieldRemoveOk(this.el);
        __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].fieldRemoveErr(this.el);
    }

    //noinspection JSDuplicatedDeclaration
    setError() {
        __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].fieldSetErr(this.el);
    }

    //noinspection JSDuplicatedDeclaration
    setError(value) {
        __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].fieldSetErr(this.el);
        __WEBPACK_IMPORTED_MODULE_0__actions_CheckFields__["a" /* default */].helpSetText(this.help_el, value);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Input;



/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__support_service_UserService__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elements_ProgressBar__ = __webpack_require__(23);
/**
 * Created by Denis on 04.03.2017.
 */



class LeaderBoard {
    constructor(node) {
        this.node = node;
    }

    _render(data) {
        let leaderBoardSource = `
                        {{#with titles}}
                            <h2>{{title}}</h2>
                        {{/with}}
                        <p class="{{control.class}}" id="{{control.id}}">{{control.text}}</p>
                        {{#if leaderboard}}
                        <ul class="list-group">
                            {{#each leaderboard}}
                            <li class="list-group-item">{{login}}<span class="badge">{{rating}}</span>
                            <span class="position">{{position}}</span></li>
                            {{/each}}
                        </ul>
                        {{/if}}`;
        let leaderBoardTemplate = Handlebars.compile(leaderBoardSource);
        return leaderBoardTemplate(data);
    }

    refreshLeaderBoard() {
        this._setProgressBar(this.node);

        new __WEBPACK_IMPORTED_MODULE_0__support_service_UserService__["a" /* default */]().getLeaders().then(response => {
            let arr = response.leaders;
            let iter = 1;
            arr.forEach(elem=>{
               elem.position = `${iter}.`;
               iter++;
            });
            setTimeout(() => {
                this.node.innerHTML = this._render({
                    titles: {
                        title: 'Top players:',
                    },
                    leaderboard: arr,
                    control: {
                        text: 'Refresh',
                        class: 'link__refresh',
                        id: 'refresh-lb'
                    }
                });
                this._initRefreshListener();
            }, 500);
        }).catch(err => {
            console.error(err);
            this.node.innerHTML = this._render({
                titles: {
                    title: 'No connection',
                },
                err: {},
                control: {
                    text: 'Refresh',
                    class: 'link',
                    id: 'refresh-lb'
                }
            });
            this._initRefreshListener();
        });
    }

    _initRefreshListener() {
        let refresh = document.getElementById('refresh-lb');
        if (refresh) {
            refresh.addEventListener('click', () => {
                this.refreshLeaderBoard();
            });
        }
    }

    _clearContainer(container) {
        while (container.children.length > 1) {
            container.removeChild(container.lastChild);
        }
    }

    _setProgressBar(container) {
        this._clearContainer(container);
        container.appendChild(new __WEBPACK_IMPORTED_MODULE_1__elements_ProgressBar__["a" /* default */]().getElem());
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LeaderBoard;




/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 12.03.2017.
 */

class Animation{
    constructor(){

    }

    show(elem){
        if(elem){
            elem.classList.remove('elem-hide');
            elem.classList.add('elem-show');
        }
    }

    hide(elem){
        if(elem){
            elem.classList.remove('elem-show');
            elem.classList.add('elem-hide');
        }
    }
}
/* unused harmony export default */


/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(7);
/**
 * Created by Denis on 17.03.2017.
 */


class GameView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */]{
    constructor(node){
        super(node);
        this.router = window.router;
        this.node = node;
    }

    /**
     * Удаляем все элементы из вьюшки
     */
    clear(){
        while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameView;


/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(7);
/**
 * Created by Denis on 19.03.2017.
 */

class AboutView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */]{
    constructor(node){
        super(node);
        this.node = node;

    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AboutView;


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__menu_templates_LeaderBoard__ = __webpack_require__(176);
/**
 * Created by Denis on 19.03.2017.
 */


class LeaderBoardView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */]{
    constructor(node){
        super(node);
        this.node = node;
        new __WEBPACK_IMPORTED_MODULE_1__menu_templates_LeaderBoard__["a" /* default */](node).refreshLeaderBoard();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LeaderBoardView;


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__menu_elements_ProgressBar__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__menu_elements_Form__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__support_service_UserService__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__game_object_User__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__support_router_RouterUrls__ = __webpack_require__(10);
/**
 * Created by Denis on 19.03.2017.
 */







class LoginView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */] {
    constructor(node) {
        super(node);
        this.node = node;
        this.router = window.router;
        this._showViewProgressBar();
        this._render();
    }

    /**
     * Отрисовка вьюшки
     * @private
     */
    _render() {
        this.loginForm = new __WEBPACK_IMPORTED_MODULE_2__menu_elements_Form__["a" /* default */]({
            data: {
                title: {
                    text: 'Log In',
                    attrs: {
                        class: 'text-center'
                    }
                },
                form: {
                    attrs: {
                        class: 'fcontainer-column',
                        action: '',
                        method: ''
                    }
                },
                fields: [
                    {
                        attrs: {
                            placeholder: 'Login',
                            id: 'l-login',
                            class: 'input',
                            type: 'text',
                            name: 'login'
                        },
                        help_attrs: {
                            id: 'l-login-help',
                            class: 'p__error'
                        }
                    },
                    {
                        attrs: {
                            placeholder: 'Password',
                            id: 'l-password',
                            class: 'input',
                            type: 'password',
                            name: 'password'
                        },
                        help_attrs: {
                            id: 'l-password-help',
                            class: 'p__error'
                        }
                    }
                ],
                controls: [
                    {
                        text: 'Enter',
                        attrs: {
                            type: 'submit',
                            class: 'btn',
                            id: 'btn-login'
                        },
                        type: 'button'
                    },
                    {
                        text: 'Sign up',
                        attrs: {
                            class: 'link router',
                            id: 'btn-to-signup',
                            href: window.SIGNUP
                        },
                        type: 'a'
                    }
                ]
            }
        }).getElem();

        setTimeout(() => {
            this._hideViewProgressBar();
            this.node.appendChild(this.loginForm.el);

            this.login = document.getElementById('l-login');
            this.password = document.getElementById('l-password');
            this.loginHelp = document.getElementById('l-login-help');
            this.btnLogin = document.getElementById('btn-login');
            this.btnToSignUp = document.getElementById('btn-to-signup');

            this._initListener();
        }, 500);
    }

    /**
     * Показать прогресс бар вьюшки
     * @private
     */
    _showViewProgressBar() {
        let progressBar = new __WEBPACK_IMPORTED_MODULE_1__menu_elements_ProgressBar__["a" /* default */]().getElem();
        this.node.appendChild(progressBar);
    }

    /**
     * Спрятать прогресс бар вьюшки
     * @private
     */
    _hideViewProgressBar() {
        this.node.removeChild(this.node.lastChild);
    }

    /**
     * Показать прогресс бар формы
     * @private
     */
    _showProgressBar() {
        this.btnLogin.hidden = true;
        let progressBar = new __WEBPACK_IMPORTED_MODULE_1__menu_elements_ProgressBar__["a" /* default */]().getElem();
        this.btnLogin.parentNode.insertBefore(progressBar, this.btnLogin.nextSibling);
    }

    /**
     * Спрятать прогресс бар формы
     * @private
     */
    _hideProgressBar() {
        setTimeout(() => {
            this.btnLogin.hidden = false;
            this.btnLogin.parentNode.removeChild(this.btnLogin.nextElementSibling);
        }, 500);
    }

    /**
     * Запуск слушателей на форму
     * @private
     */
    _initListener() {
        //Submit form
        this.loginForm.el.addEventListener('submit', event => {
            event.preventDefault();
            if (this._checkFields()) {
                let body = this.loginForm.getFormData();

                this._showProgressBar();

                new __WEBPACK_IMPORTED_MODULE_3__support_service_UserService__["a" /* default */]().login(body).then(user => {
                    this._clearFields();
                    //new User().obj = user;
                    window.USER = user;
                    this.router._setCurrView(window.PROFILE);

                    this._hideProgressBar();
                }).catch(e => {
                    this.loginForm.fields.forEach(elem => {
                        elem.setError();
                        elem.setError('wrong data');
                    });
                    this._hideProgressBar();
                    console.error(e);
                });
            }
        });
        this.btnToSignUp.addEventListener('click', event=>{
            this._clearFields();
        })
    }

    /**
     * Отчистка полей формы
     * @private
     */
    _clearFields() {
        this.loginForm.fields.forEach(elem => {
            elem.clear();
        });
    }

    /**
     * Проверка полей формы
     * @return {boolean}
     * @private
     */
    _checkFields() {
        let check = true;

        this.loginForm.fields.forEach(elem => {
            let result = elem.validate();
            if (check === true) {
                check = result;
            }
        });

        return check;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LoginView;


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__support_router_RouterUrls__ = __webpack_require__(10);
/**
 * Created by Denis on 19.03.2017.
 */


class MenuView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */] {
    constructor(node) {
        super(node);
        this.node = node;
        this.render({
            elements: [
                {
                    type: 'a',
                    attrs: {
                        href: window.LEADERBOARD,
                        class: 'btn__play router'
                    },
                    element: {
                        type: 'h1',
                        text: 'LEADER BOARD'
                    }
                },
                {
                    type: 'a',
                    attrs: {
                        href: window.LOGIN,
                        class: 'btn__main-play router'
                    },
                    element: {
                        type: 'h1',
                        text: 'PLAY'
                    }
                },
                {
                    type: 'a',
                    attrs: {
                        href: window.ABOUT,
                        class: 'btn__play router'
                    },
                    element: {
                        type: 'h1',
                        text: 'ABOUT'
                    }
                }
            ]
        });

    }

    /**
     * Отрисовка меню
     * @param instr
     */
    render(instr) {
        let elemArray = this._getElems(instr.elements);
        this._elemsAppendTo(elemArray, this.node);
    }

    /**
     * Установка массив атрибкутов
     * @param attrs
     * @param elem
     * @private
     */
    _setAttrs(attrs, elem) {
        Object.keys(attrs).forEach(name => {
            elem.setAttribute(name, attrs[name]);
        });
    }

    /**
     * Добавить массив элементов
     * @param array
     * @param elem
     * @private
     */
    _elemsAppendTo(array, elem) {
        array.forEach(item => {
            elem.appendChild(item);
        })
    }

    /**
     * Получить массив элементов
     * @param elements - инструкции по созданию
     * @private
     */
    _getElems(elements) {
        return elements.map(data => {
            let elem = document.createElement(data.type);
            this._setAttrs(data.attrs, elem);
            let textElem = document.createElement(data.element.type);
            textElem.textContent = data.element.text;
            elem.appendChild(textElem);
            return elem;
        });
    }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = MenuView;


/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__support_service_UserService__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__game_object_User__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__menu_elements_ProgressBar__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__menu_elements_Diamond__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__support_router_RouterUrls__ = __webpack_require__(10);
/**
 * Created by Denis on 19.03.2017.
 */







class ProfileView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */] {
    constructor(node) {
        super(node);
        this.router = window.router;
        this.node = node;
        //this.refreshProfile();
        this._showViewProgressBar();
        this._render();
    }

    /**
     * Получить юзера
     * @return {Promise}
     * @private
     */
    _getUser() {
        return new Promise(function (resolve, reject) {
            new __WEBPACK_IMPORTED_MODULE_1__support_service_UserService__["a" /* default */]().getUser().then(user => {
                window.USER = user;
                resolve(user);
            }).catch(err => {
                reject({});
            });
        });
    }

    /**
     * Отрисовка профайла
     * @private
     */
    _render() {
        this._getUser().then(user => {
            this.profile = this._createProfile(user);

            setTimeout(() => {
                this._hideViewProgressBar();
                this.node.appendChild(this.profile);

                this.login = document.getElementById('l-login');
                this.password = document.getElementById('l-password');
                this.loginHelp = document.getElementById('l-login-help');
                this.btnLogin = document.getElementById('btn-login');

                this._initListener();
            }, 500);
        }).catch(err => {
            this._hideViewProgressBar();
        });
    }

    /**
     * Запуск слушателей
     * @private
     */
    _initListener() {
        document.getElementById('btn-logout').addEventListener('click', event => {
            new __WEBPACK_IMPORTED_MODULE_1__support_service_UserService__["a" /* default */]().logOutUser().then(response => {
                this.router._setCurrView(window.LOGIN);
            }).catch(err => {

            });
        });
    }

    /**
     * Показать прогресс бар вьюшки
     * @private
     */
    _showViewProgressBar() {
        let progressBar = new __WEBPACK_IMPORTED_MODULE_3__menu_elements_ProgressBar__["a" /* default */]().getElem();
        this.node.appendChild(progressBar);
    }

    /**
     * Спрятать прогресс бар вьюшки
     * @private
     */
    _hideViewProgressBar() {
        this.node.removeChild(this.node.lastChild);
    }

    /**
     * Отчистка контейнера
     * @private
     */
    _clearContainer() {
        while (this.node.children.length > 0) {
            this.node.removeChild(this.node.lastChild);
        }
    }

    /**
     * Обновить вьюшку
     */
    refresh() {
        this._clearContainer();
        this._showViewProgressBar();
        this._render();
    }

    /**
     * Создание элементов профайла
     * @param user
     * @return {Element}
     * @private
     */
    _createProfile(user) {
        let profile = document.createElement('div');
        profile.setAttribute('class', 'fcontainer-row');

        /* create controllers div*/
        let controllersDiv = document.createElement('div');
        controllersDiv.setAttribute('class', 'profile__container fcontainer-row');

        let hrefPlayM = document.createElement('a');
        hrefPlayM.setAttribute('href', window.MULTIPLAYER);
        hrefPlayM.setAttribute('class', 'router btn__profile');
        let h1 = document.createElement('h1');
        h1.innerHTML = 'Multiplayer';
        hrefPlayM.appendChild(h1);

        let hrefPlayS = document.createElement('a');
        hrefPlayS.setAttribute('href', window.SINGLEPLAYER);
        hrefPlayS.setAttribute('class', 'router btn__profile');
        h1 = document.createElement('h1');
        h1.innerHTML = 'Single play';
        hrefPlayS.appendChild(h1);

        controllersDiv.appendChild(hrefPlayM);
        controllersDiv.appendChild(hrefPlayS);

        /*create user div*/
        let userDiv = document.createElement('div');
        userDiv.setAttribute('class', 'fcontainer-column');

        let elem = document.createElement('h2');
        elem.setAttribute('class', 'text__profile-login');
        elem.innerText = `${user.login}`;
        userDiv.appendChild(elem);

        let arrValue = [
            {
                name: 'Rating:',
                value: user.rating
            },
            {
                name: 'Winnings:',
                value: user.game_count_win
            }, {
                name: 'Total matches: ',
                value: user.game_count
            }
        ];

        arrValue.forEach(el => {
            elem = document.createElement('h3');
            elem.setAttribute('class', 'text__profile-item');
            elem.innerText = `${el.name} ${el.value}`;
            userDiv.appendChild(elem);
        });

        /*create resources div*/
        let resourcesDiv = document.createElement('div');
        resourcesDiv.setAttribute('class', 'fcontainer-column');

        let arrCrystals = [
            {value: user.crystal_green, color: 'rgb(29, 140, 114)'},
            {value: user.crystal_blue, color: 'rgb(57, 108, 219)'},
            {value: user.crystal_red, color: 'rgb(138, 34, 76)'},
            {value: user.crystal_purple, color: 'rgb(80, 35, 153)'}];
        arrCrystals.forEach(params => {
            let div = document.createElement('div');
            div.setAttribute('class', 'fcontainer-row');

            let d = new __WEBPACK_IMPORTED_MODULE_4__menu_elements_Diamond__["a" /* default */](`${params.color}`).getElem().el;
            div.appendChild(d);

            elem = document.createElement('h3');
            elem.setAttribute('class', 'text__profile-diamond');
            elem.innerText = `${params.value}`;
            div.appendChild(elem);
            resourcesDiv.appendChild(div);
        });

        profile.appendChild(userDiv);
        profile.appendChild(resourcesDiv);
        profile.appendChild(controllersDiv);

        let hrefLogout = document.createElement('a');
        hrefLogout.setAttribute('class', 'router link__logout');
        hrefLogout.setAttribute('id', 'btn-logout');
        hrefLogout.innerText = 'Log out';
        profile.appendChild(hrefLogout);

        return profile;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ProfileView;


/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__menu_elements_Form__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__menu_elements_ProgressBar__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__menu_actions_CheckFields__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_izitoast__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_izitoast___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_izitoast__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__support_service_UserService__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__support_router_RouterUrls__ = __webpack_require__(10);
/**
 * Created by Denis on 19.03.2017.
 */








class SignUpView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */]{
    constructor(node){
        super(node);
        this.node = node;
        this.router = window.router;
        this._showViewProgressBar();
        this._render();
    }

    /**
     * Отрисовка вьюшки
     * @private
     */
    _render() {
        this.signupForm = new __WEBPACK_IMPORTED_MODULE_1__menu_elements_Form__["a" /* default */]({
            data: {
                title: {
                    text: 'Sign up',
                    attrs: {
                        class: 'text-center',
                    }
                },
                form: {
                    attrs: {
                        class: 'fcontainer-column',
                        action: '',
                        method: ''
                    }
                },
                fields: [
                    {
                        attrs: {
                            placeholder: 'Login',
                            id: 'r-login',
                            class: 'input',
                            type: 'text',
                            name: 'login',
                            valid: 'login'
                        },
                        help_attrs: {
                            id: 'r-login-help',
                            class: 'p__error'
                        }
                    },
                    {
                        attrs: {
                            placeholder: 'Password',
                            id: 'r-password',
                            class: 'input',
                            type: 'password',
                            name: 'password',
                            valid: 'password'
                        },
                        help_attrs: {
                            id: 'r-password-help',
                            class: 'p__error'
                        }
                    },
                    {
                        attrs: {
                            placeholder: 'Repeat password',
                            id: 'r-repeatpassword',
                            class: 'input',
                            type: 'password',
                            name: 'repeatpassword',
                            valid: 'repeatpassword'
                        },
                        help_attrs: {
                            id: 'r-repeatpassword-help',
                            class: 'p__error'
                        }
                    }
                ],
                controls: [
                    {
                        text: 'Registrate',
                        attrs: {
                            type: 'submit',
                            class: 'btn',
                            id: 'btn-signup'
                        },
                        type: 'button'
                    },
                    {
                        text: 'Log In',
                        attrs: {
                            class: 'link router',
                            id: 'btn-to-login',
                            href: window.LOGIN
                        },
                        type: 'a'
                    }
                ]
            }
        }).getElem();
        setTimeout(()=>{
            this._hideViewProgressBar();
            this.node.appendChild(this.signupForm.el);

            this.login = document.getElementById('r-login');
            this.password = document.getElementById('r-password');
            this.repeatPassword = document.getElementById('r-repeatpassword');

            this.loginHelp = document.getElementById('r-login-help');
            this.passwordHelp = document.getElementById('r-password-help');
            this.repeatPasswordHelp = document.getElementById('r-repeatpassword-help');

            this.btnSignUp = document.getElementById('btn-signup');

            this.btnToLogin = document.getElementById('btn-to-login');
            this._initListener();
        }, 500);
    }

    /**
     * Показать прогресс бар вьюшки
     * @private
     */
    _showViewProgressBar() {
        let progressBar = new __WEBPACK_IMPORTED_MODULE_2__menu_elements_ProgressBar__["a" /* default */]().getElem();
        this.node.appendChild(progressBar);
    }

    /**
     * Спрятать прогресс бар вьюшки
     * @private
     */
    _hideViewProgressBar() {
        this.node.removeChild(this.node.lastChild);
    }

    /**
     * Показать прогресс бар формы
     * @private
     */
    _showProgressBar() {
        this.btnSignUp.hidden = true;
        let progressBar = new __WEBPACK_IMPORTED_MODULE_2__menu_elements_ProgressBar__["a" /* default */]().getElem();
        this.btnSignUp.parentNode.insertBefore(progressBar, this.btnSignUp.nextSibling);
    }

    /**
     * Спрятать прогресс бар формы
     * @private
     */
    _hideProgressBar() {
        setTimeout(() => {
            this.btnSignUp.hidden = false;
            this.btnSignUp.parentNode.removeChild(this.btnSignUp.nextElementSibling);
        }, 500);
    }

    /**
     * Запуск слушателей
     * @private
     */
    _initListener() {
        //Submit form
        this.signupForm.el.addEventListener('submit', event => {
            event.preventDefault();

            if (this._checkFields()) {
                let body = this.signupForm.getFormData();
                this._showProgressBar();

                new __WEBPACK_IMPORTED_MODULE_5__support_service_UserService__["a" /* default */]().signup(body).then(response => {
                    this._clearFields();
                    this._hideProgressBar();
                    __WEBPACK_IMPORTED_MODULE_4_izitoast___default.a.success({
                        title: 'Successfully registrated',
                        position: 'topRight'
                    });
                    this.router._setCurrView(window.LOGIN);
                }).catch(err => {
                    __WEBPACK_IMPORTED_MODULE_3__menu_actions_CheckFields__["a" /* default */].fieldRemoveOk(this.login);
                    __WEBPACK_IMPORTED_MODULE_3__menu_actions_CheckFields__["a" /* default */].fieldSetErr(this.login);
                    if(err.result === 'no-conn'){
                        __WEBPACK_IMPORTED_MODULE_3__menu_actions_CheckFields__["a" /* default */].helpSetText(this.loginHelp, 'check connection');
                    } else {
                        __WEBPACK_IMPORTED_MODULE_3__menu_actions_CheckFields__["a" /* default */].helpSetText(this.loginHelp, 'login used');
                    }
                    this._hideProgressBar();
                    console.error(err);
                });
            }
        });
        this.btnToLogin.addEventListener('click', event=>{
            this._clearFields();
        })
    }

    /**
     * Проверка полей формы
     * @return {boolean}
     * @private
     */
    _checkFields() {
        let check = true;
        let prev = null;

        this.signupForm.fields.forEach(elem => {
            let result = elem.validate(prev);
            prev = elem;
            if (check === true) {
                check = result;
            }
        });

        return check;
    }

    /**
     * Отчистка полей формы
     * @private
     */
    _clearFields() {
        this.signupForm.fields.forEach(elem => {
            elem.clear();
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = SignUpView;


/***/ }),
/* 185 */,
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(16);
module.exports = __webpack_require__(81);


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// threejs.org/license
(function (l, pa) {
     true ? pa(exports) : "function" === typeof define && define.amd ? define(["exports"], pa) : pa(l.THREE = l.THREE || {})
})(this, function (l) {
    function pa() {
    }

    function D(a, b) {
        this.x = a || 0;
        this.y = b || 0
    }

    function ea(a, b, c, d, e, f, g, h, m, k) {
        Object.defineProperty(this, "id", {value: Ze++});
        this.uuid = N.generateUUID();
        this.name = "";
        this.image = void 0 !== a ? a : ea.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = void 0 !== b ? b : ea.DEFAULT_MAPPING;
        this.wrapS = void 0 !== c ? c : 1001;
        this.wrapT =
            void 0 !== d ? d : 1001;
        this.magFilter = void 0 !== e ? e : 1006;
        this.minFilter = void 0 !== f ? f : 1008;
        this.anisotropy = void 0 !== m ? m : 1;
        this.format = void 0 !== g ? g : 1023;
        this.type = void 0 !== h ? h : 1009;
        this.offset = new D(0, 0);
        this.repeat = new D(1, 1);
        this.generateMipmaps = !0;
        this.premultiplyAlpha = !1;
        this.flipY = !0;
        this.unpackAlignment = 4;
        this.encoding = void 0 !== k ? k : 3E3;
        this.version = 0;
        this.onUpdate = null
    }

    function fa(a, b, c, d) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = c || 0;
        this.w = void 0 !== d ? d : 1
    }

    function Ya(a, b, c) {
        this.uuid = N.generateUUID();
        this.width =
            a;
        this.height = b;
        this.scissor = new fa(0, 0, a, b);
        this.scissorTest = !1;
        this.viewport = new fa(0, 0, a, b);
        c = c || {};
        void 0 === c.minFilter && (c.minFilter = 1006);
        this.texture = new ea(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding);
        this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
        this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
        this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null
    }

    function Gb(a, b, c) {
        Ya.call(this, a, b, c);
        this.activeMipMapLevel =
            this.activeCubeFace = 0
    }

    function ca(a, b, c, d) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = c || 0;
        this._w = void 0 !== d ? d : 1
    }

    function q(a, b, c) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = c || 0
    }

    function S() {
        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function Za(a, b, c, d, e, f, g, h, m, k) {
        a = void 0 !== a ? a : [];
        ea.call(this, a, void 0 !== b ? b : 301, c, d, e, f, g, h, m, k);
        this.flipY = !1
    }

    function Hb(a, b, c) {
        var d = a[0];
        if (0 >=
            d || 0 < d)return a;
        var e = b * c, f = Be[e];
        void 0 === f && (f = new Float32Array(e), Be[e] = f);
        if (0 !== b)for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d)e += c, a[d].toArray(f, e);
        return f
    }

    function Ce(a, b) {
        var c = De[b];
        void 0 === c && (c = new Int32Array(b), De[b] = c);
        for (var d = 0; d !== b; ++d)c[d] = a.allocTextureUnit();
        return c
    }

    function $e(a, b) {
        a.uniform1f(this.addr, b)
    }

    function af(a, b) {
        a.uniform1i(this.addr, b)
    }

    function bf(a, b) {
        void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y)
    }

    function cf(a, b) {
        void 0 !== b.x ? a.uniform3f(this.addr,
            b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b)
    }

    function df(a, b) {
        void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w)
    }

    function ef(a, b) {
        a.uniformMatrix2fv(this.addr, !1, b.elements || b)
    }

    function ff(a, b) {
        a.uniformMatrix3fv(this.addr, !1, b.elements || b)
    }

    function gf(a, b) {
        a.uniformMatrix4fv(this.addr, !1, b.elements || b)
    }

    function hf(a, b, c) {
        var d = c.allocTextureUnit();
        a.uniform1i(this.addr, d);
        c.setTexture2D(b || Ee, d)
    }

    function jf(a, b, c) {
        var d = c.allocTextureUnit();
        a.uniform1i(this.addr, d);
        c.setTextureCube(b || Fe, d)
    }

    function Ge(a, b) {
        a.uniform2iv(this.addr, b)
    }

    function He(a, b) {
        a.uniform3iv(this.addr, b)
    }

    function Ie(a, b) {
        a.uniform4iv(this.addr, b)
    }

    function kf(a) {
        switch (a) {
            case 5126:
                return $e;
            case 35664:
                return bf;
            case 35665:
                return cf;
            case 35666:
                return df;
            case 35674:
                return ef;
            case 35675:
                return ff;
            case 35676:
                return gf;
            case 35678:
                return hf;
            case 35680:
                return jf;
            case 5124:
            case 35670:
                return af;
            case 35667:
            case 35671:
                return Ge;
            case 35668:
            case 35672:
                return He;
            case 35669:
            case 35673:
                return Ie
        }
    }

    function lf(a, b) {
        a.uniform1fv(this.addr, b)
    }

    function mf(a, b) {
        a.uniform1iv(this.addr, b)
    }

    function nf(a, b) {
        a.uniform2fv(this.addr, Hb(b, this.size, 2))
    }

    function of(a, b) {
        a.uniform3fv(this.addr, Hb(b, this.size, 3))
    }

    function pf(a, b) {
        a.uniform4fv(this.addr, Hb(b, this.size, 4))
    }

    function qf(a, b) {
        a.uniformMatrix2fv(this.addr, !1, Hb(b, this.size, 4))
    }

    function rf(a, b) {
        a.uniformMatrix3fv(this.addr, !1, Hb(b, this.size, 9))
    }

    function sf(a, b) {
        a.uniformMatrix4fv(this.addr, !1, Hb(b, this.size, 16))
    }

    function tf(a, b, c) {
        var d = b.length,
            e = Ce(c, d);
        a.uniform1iv(this.addr, e);
        for (a = 0; a !== d; ++a)c.setTexture2D(b[a] || Ee, e[a])
    }

    function uf(a, b, c) {
        var d = b.length, e = Ce(c, d);
        a.uniform1iv(this.addr, e);
        for (a = 0; a !== d; ++a)c.setTextureCube(b[a] || Fe, e[a])
    }

    function vf(a) {
        switch (a) {
            case 5126:
                return lf;
            case 35664:
                return nf;
            case 35665:
                return of;
            case 35666:
                return pf;
            case 35674:
                return qf;
            case 35675:
                return rf;
            case 35676:
                return sf;
            case 35678:
                return tf;
            case 35680:
                return uf;
            case 5124:
            case 35670:
                return mf;
            case 35667:
            case 35671:
                return Ge;
            case 35668:
            case 35672:
                return He;
            case 35669:
            case 35673:
                return Ie
        }
    }

    function wf(a, b, c) {
        this.id = a;
        this.addr = c;
        this.setValue = kf(b.type)
    }

    function xf(a, b, c) {
        this.id = a;
        this.addr = c;
        this.size = b.size;
        this.setValue = vf(b.type)
    }

    function Je(a) {
        this.id = a;
        this.seq = [];
        this.map = {}
    }

    function $a(a, b, c) {
        this.seq = [];
        this.map = {};
        this.renderer = c;
        c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
        for (var d = 0; d < c; ++d) {
            var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, h = e.name, m = h.length;
            for (Rd.lastIndex = 0; ;) {
                var k = Rd.exec(h), t = Rd.lastIndex, p =
                    k[1], n = k[3];
                "]" === k[2] && (p |= 0);
                if (void 0 === n || "[" === n && t + 2 === m) {
                    h = g;
                    e = void 0 === n ? new wf(p, e, f) : new xf(p, e, f);
                    h.seq.push(e);
                    h.map[e.id] = e;
                    break
                } else n = g.map[p], void 0 === n && (n = new Je(p), p = g, g = n, p.seq.push(g), p.map[g.id] = g), g = n
            }
        }
    }

    function J(a, b, c) {
        return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
    }

    function eb(a, b, c, d, e, f, g, h, m, k, t, p) {
        ea.call(this, null, f, g, h, m, k, d, e, t, p);
        this.image = {data: a, width: b, height: c};
        this.magFilter = void 0 !== m ? m : 1003;
        this.minFilter = void 0 !== k ? k : 1003;
        this.flipY = this.generateMipmaps =
            !1;
        this.unpackAlignment = 1
    }

    function sc(a, b) {
        this.min = void 0 !== a ? a : new D(Infinity, Infinity);
        this.max = void 0 !== b ? b : new D(-Infinity, -Infinity)
    }

    function yf(a, b) {
        var c, d, e, f, g, h, m, k, t, p, n = a.context, u = a.state, l, r, A, w, y, K;
        this.render = function (v, E, L) {
            if (0 !== b.length) {
                v = new q;
                var C = L.w / L.z, F = .5 * L.z, da = .5 * L.w, H = 16 / L.w, aa = new D(H * C, H), Da = new q(1, 1, 0),
                    fb = new D(1, 1), Sd = new sc;
                Sd.min.set(L.x, L.y);
                Sd.max.set(L.x + (L.z - 16), L.y + (L.w - 16));
                if (void 0 === w) {
                    var H = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), Q =
                        new Uint16Array([0, 1, 2, 0, 2, 3]);
                    l = n.createBuffer();
                    r = n.createBuffer();
                    n.bindBuffer(n.ARRAY_BUFFER, l);
                    n.bufferData(n.ARRAY_BUFFER, H, n.STATIC_DRAW);
                    n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r);
                    n.bufferData(n.ELEMENT_ARRAY_BUFFER, Q, n.STATIC_DRAW);
                    y = n.createTexture();
                    K = n.createTexture();
                    u.bindTexture(n.TEXTURE_2D, y);
                    n.texImage2D(n.TEXTURE_2D, 0, n.RGB, 16, 16, 0, n.RGB, n.UNSIGNED_BYTE, null);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
                    u.bindTexture(n.TEXTURE_2D, K);
                    n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, 16, 16, 0, n.RGBA, n.UNSIGNED_BYTE, null);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
                    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
                    var H = A = {
                            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                            fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                        }, Q = n.createProgram(), M = n.createShader(n.FRAGMENT_SHADER),
                        O = n.createShader(n.VERTEX_SHADER), P = "precision " + a.getPrecision() + " float;\n";
                    n.shaderSource(M, P + H.fragmentShader);
                    n.shaderSource(O, P + H.vertexShader);
                    n.compileShader(M);
                    n.compileShader(O);
                    n.attachShader(Q, M);
                    n.attachShader(Q, O);
                    n.linkProgram(Q);
                    w = Q;
                    t = n.getAttribLocation(w, "position");
                    p = n.getAttribLocation(w, "uv");
                    c = n.getUniformLocation(w, "renderType");
                    d = n.getUniformLocation(w, "map");
                    e = n.getUniformLocation(w, "occlusionMap");
                    f = n.getUniformLocation(w, "opacity");
                    g = n.getUniformLocation(w, "color");
                    h = n.getUniformLocation(w,
                        "scale");
                    m = n.getUniformLocation(w, "rotation");
                    k = n.getUniformLocation(w, "screenPosition")
                }
                n.useProgram(w);
                u.initAttributes();
                u.enableAttribute(t);
                u.enableAttribute(p);
                u.disableUnusedAttributes();
                n.uniform1i(e, 0);
                n.uniform1i(d, 1);
                n.bindBuffer(n.ARRAY_BUFFER, l);
                n.vertexAttribPointer(t, 2, n.FLOAT, !1, 16, 0);
                n.vertexAttribPointer(p, 2, n.FLOAT, !1, 16, 8);
                n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r);
                u.disable(n.CULL_FACE);
                u.setDepthWrite(!1);
                Q = 0;
                for (M = b.length; Q < M; Q++)if (H = 16 / L.w, aa.set(H * C, H), O = b[Q], v.set(O.matrixWorld.elements[12],
                        O.matrixWorld.elements[13], O.matrixWorld.elements[14]), v.applyMatrix4(E.matrixWorldInverse), v.applyMatrix4(E.projectionMatrix), Da.copy(v), fb.x = L.x + Da.x * F + F - 8, fb.y = L.y + Da.y * da + da - 8, !0 === Sd.containsPoint(fb)) {
                    u.activeTexture(n.TEXTURE0);
                    u.bindTexture(n.TEXTURE_2D, null);
                    u.activeTexture(n.TEXTURE1);
                    u.bindTexture(n.TEXTURE_2D, y);
                    n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGB, fb.x, fb.y, 16, 16, 0);
                    n.uniform1i(c, 0);
                    n.uniform2f(h, aa.x, aa.y);
                    n.uniform3f(k, Da.x, Da.y, Da.z);
                    u.disable(n.BLEND);
                    u.enable(n.DEPTH_TEST);
                    n.drawElements(n.TRIANGLES,
                        6, n.UNSIGNED_SHORT, 0);
                    u.activeTexture(n.TEXTURE0);
                    u.bindTexture(n.TEXTURE_2D, K);
                    n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGBA, fb.x, fb.y, 16, 16, 0);
                    n.uniform1i(c, 1);
                    u.disable(n.DEPTH_TEST);
                    u.activeTexture(n.TEXTURE1);
                    u.bindTexture(n.TEXTURE_2D, y);
                    n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);
                    O.positionScreen.copy(Da);
                    O.customUpdateCallback ? O.customUpdateCallback(O) : O.updateLensFlares();
                    n.uniform1i(c, 2);
                    u.enable(n.BLEND);
                    for (var P = 0, wa = O.lensFlares.length; P < wa; P++) {
                        var W = O.lensFlares[P];
                        .001 < W.opacity && .001 <
                        W.scale && (Da.x = W.x, Da.y = W.y, Da.z = W.z, H = W.size * W.scale / L.w, aa.x = H * C, aa.y = H, n.uniform3f(k, Da.x, Da.y, Da.z), n.uniform2f(h, aa.x, aa.y), n.uniform1f(m, W.rotation), n.uniform1f(f, W.opacity), n.uniform3f(g, W.color.r, W.color.g, W.color.b), u.setBlending(W.blending, W.blendEquation, W.blendSrc, W.blendDst), a.setTexture2D(W.texture, 1), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0))
                    }
                }
                u.enable(n.CULL_FACE);
                u.enable(n.DEPTH_TEST);
                u.setDepthWrite(!0);
                a.resetGLState()
            }
        }
    }

    function zf(a, b) {
        var c, d, e, f, g, h, m, k, t, p, n, u, l, r,
            A, w, y;

        function K(a, b) {
            return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
        }

        var v = a.context, E = a.state, L, C, F, da, H = new q, aa = new ca, Da = new q;
        this.render = function (q, D) {
            if (0 !== b.length) {
                if (void 0 === F) {
                    var Q = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        M = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    L = v.createBuffer();
                    C = v.createBuffer();
                    v.bindBuffer(v.ARRAY_BUFFER, L);
                    v.bufferData(v.ARRAY_BUFFER, Q, v.STATIC_DRAW);
                    v.bindBuffer(v.ELEMENT_ARRAY_BUFFER, C);
                    v.bufferData(v.ELEMENT_ARRAY_BUFFER,
                        M, v.STATIC_DRAW);
                    var Q = v.createProgram(), M = v.createShader(v.VERTEX_SHADER),
                        O = v.createShader(v.FRAGMENT_SHADER);
                    v.shaderSource(M, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
                    v.shaderSource(O, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
                    v.compileShader(M);
                    v.compileShader(O);
                    v.attachShader(Q, M);
                    v.attachShader(Q, O);
                    v.linkProgram(Q);
                    F = Q;
                    w = v.getAttribLocation(F, "position");
                    y = v.getAttribLocation(F, "uv");
                    c = v.getUniformLocation(F, "uvOffset");
                    d = v.getUniformLocation(F, "uvScale");
                    e = v.getUniformLocation(F, "rotation");
                    f = v.getUniformLocation(F, "scale");
                    g = v.getUniformLocation(F, "color");
                    h = v.getUniformLocation(F, "map");
                    m = v.getUniformLocation(F, "opacity");
                    k = v.getUniformLocation(F, "modelViewMatrix");
                    t = v.getUniformLocation(F, "projectionMatrix");
                    p =
                        v.getUniformLocation(F, "fogType");
                    n = v.getUniformLocation(F, "fogDensity");
                    u = v.getUniformLocation(F, "fogNear");
                    l = v.getUniformLocation(F, "fogFar");
                    r = v.getUniformLocation(F, "fogColor");
                    A = v.getUniformLocation(F, "alphaTest");
                    Q = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    Q.width = 8;
                    Q.height = 8;
                    M = Q.getContext("2d");
                    M.fillStyle = "white";
                    M.fillRect(0, 0, 8, 8);
                    da = new ea(Q);
                    da.needsUpdate = !0
                }
                v.useProgram(F);
                E.initAttributes();
                E.enableAttribute(w);
                E.enableAttribute(y);
                E.disableUnusedAttributes();
                E.disable(v.CULL_FACE);
                E.enable(v.BLEND);
                v.bindBuffer(v.ARRAY_BUFFER, L);
                v.vertexAttribPointer(w, 2, v.FLOAT, !1, 16, 0);
                v.vertexAttribPointer(y, 2, v.FLOAT, !1, 16, 8);
                v.bindBuffer(v.ELEMENT_ARRAY_BUFFER, C);
                v.uniformMatrix4fv(t, !1, D.projectionMatrix.elements);
                E.activeTexture(v.TEXTURE0);
                v.uniform1i(h, 0);
                M = Q = 0;
                (O = q.fog) ? (v.uniform3f(r, O.color.r, O.color.g, O.color.b), O.isFog ? (v.uniform1f(u, O.near), v.uniform1f(l, O.far), v.uniform1i(p, 1), M = Q = 1) : O.isFogExp2 && (v.uniform1f(n, O.density), v.uniform1i(p, 2), M = Q = 2)) : (v.uniform1i(p,
                    0), M = Q = 0);
                for (var O = 0, P = b.length; O < P; O++) {
                    var wa = b[O];
                    wa.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, wa.matrixWorld);
                    wa.z = -wa.modelViewMatrix.elements[14]
                }
                b.sort(K);
                for (var W = [], O = 0, P = b.length; O < P; O++) {
                    var wa = b[O], x = wa.material;
                    !1 !== x.visible && (v.uniform1f(A, x.alphaTest), v.uniformMatrix4fv(k, !1, wa.modelViewMatrix.elements), wa.matrixWorld.decompose(H, aa, Da), W[0] = Da.x, W[1] = Da.y, wa = 0, q.fog && x.fog && (wa = M), Q !== wa && (v.uniform1i(p, wa), Q = wa), null !== x.map ? (v.uniform2f(c, x.map.offset.x, x.map.offset.y),
                        v.uniform2f(d, x.map.repeat.x, x.map.repeat.y)) : (v.uniform2f(c, 0, 0), v.uniform2f(d, 1, 1)), v.uniform1f(m, x.opacity), v.uniform3f(g, x.color.r, x.color.g, x.color.b), v.uniform1f(e, x.rotation), v.uniform2fv(f, W), E.setBlending(x.blending, x.blendEquation, x.blendSrc, x.blendDst), E.setDepthTest(x.depthTest), E.setDepthWrite(x.depthWrite), x.map ? a.setTexture2D(x.map, 0) : a.setTexture2D(da, 0), v.drawElements(v.TRIANGLES, 6, v.UNSIGNED_SHORT, 0))
                }
                E.enable(v.CULL_FACE);
                a.resetGLState()
            }
        }
    }

    function X() {
        Object.defineProperty(this,
            "id", {value: Af++});
        this.uuid = N.generateUUID();
        this.name = "";
        this.type = "Material";
        this.lights = this.fog = !0;
        this.blending = 1;
        this.side = 0;
        this.shading = 2;
        this.vertexColors = 0;
        this.opacity = 1;
        this.transparent = !1;
        this.blendSrc = 204;
        this.blendDst = 205;
        this.blendEquation = 100;
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
        this.depthFunc = 3;
        this.depthWrite = this.depthTest = !0;
        this.clippingPlanes = null;
        this.clipShadows = this.clipIntersection = !1;
        this.colorWrite = !0;
        this.precision = null;
        this.polygonOffset =
            !1;
        this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
        this.premultipliedAlpha = !1;
        this.overdraw = 0;
        this._needsUpdate = this.visible = !0
    }

    function Ha(a) {
        X.call(this);
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        this.linewidth = 1;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.morphNormals =
            this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
        this.extensions = {derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1};
        this.defaultAttributeValues = {color: [1, 1, 1], uv: [0, 0], uv2: [0, 0]};
        this.index0AttributeName = void 0;
        void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
    }

    function ab(a) {
        X.call(this);
        this.type = "MeshDepthMaterial";
        this.depthPacking = 3200;
        this.morphTargets =
            this.skinning = !1;
        this.displacementMap = this.alphaMap = this.map = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.lights = this.fog = !1;
        this.setValues(a)
    }

    function Pa(a, b) {
        this.min = void 0 !== a ? a : new q(Infinity, Infinity, Infinity);
        this.max = void 0 !== b ? b : new q(-Infinity, -Infinity, -Infinity)
    }

    function Na(a, b) {
        this.center = void 0 !== a ? a : new q;
        this.radius = void 0 !== b ? b : 0
    }

    function ya() {
        this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function la(a, b) {
        this.normal = void 0 !== a ? a : new q(1, 0, 0);
        this.constant = void 0 !== b ? b : 0
    }

    function tc(a, b, c, d, e, f) {
        this.planes = [void 0 !== a ? a : new la, void 0 !== b ? b : new la, void 0 !== c ? c : new la, void 0 !== d ? d : new la, void 0 !== e ? e : new la, void 0 !== f ? f : new la]
    }

    function Ke(a, b, c, d) {
        function e(b, c, d, e) {
            var f = b.geometry, g;
            g = A;
            var h = b.customDepthMaterial;
            d && (g = w, h = b.customDistanceMaterial);
            h ? g = h : (h = !1, c.morphTargets && (f && f.isBufferGeometry ? h = f.morphAttributes && f.morphAttributes.position && 0 < f.morphAttributes.position.length :
                f && f.isGeometry && (h = f.morphTargets && 0 < f.morphTargets.length)), b = b.isSkinnedMesh && c.skinning, f = 0, h && (f |= 1), b && (f |= 2), g = g[f]);
            a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (f = g.uuid, h = c.uuid, b = y[f], void 0 === b && (b = {}, y[f] = b), f = b[h], void 0 === f && (f = g.clone(), b[h] = f), g = f);
            g.visible = c.visible;
            g.wireframe = c.wireframe;
            h = c.side;
            aa.renderSingleSided && 2 == h && (h = 0);
            aa.renderReverseSided && (0 === h ? h = 1 : 1 === h && (h = 0));
            g.side = h;
            g.clipShadows = c.clipShadows;
            g.clippingPlanes = c.clippingPlanes;
            g.wireframeLinewidth =
                c.wireframeLinewidth;
            g.linewidth = c.linewidth;
            d && void 0 !== g.uniforms.lightPos && g.uniforms.lightPos.value.copy(e);
            return g
        }

        function f(a, b, c) {
            if (!1 !== a.visible) {
                0 !== (a.layers.mask & b.layers.mask) && (a.isMesh || a.isLine || a.isPoints) && a.castShadow && (!1 === a.frustumCulled || !0 === m.intersectsObject(a)) && !0 === a.material.visible && (a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), r.push(a));
                a = a.children;
                for (var d = 0, e = a.length; d < e; d++)f(a[d], b, c)
            }
        }

        var g = a.context, h = a.state, m = new tc, k = new S,
            t = b.shadows, p = new D, n = new D(d.maxTextureSize, d.maxTextureSize), u = new q, l = new q, r = [],
            A = Array(4), w = Array(4), y = {},
            K = [new q(1, 0, 0), new q(-1, 0, 0), new q(0, 0, 1), new q(0, 0, -1), new q(0, 1, 0), new q(0, -1, 0)],
            v = [new q(0, 1, 0), new q(0, 1, 0), new q(0, 1, 0), new q(0, 1, 0), new q(0, 0, 1), new q(0, 0, -1)],
            E = [new fa, new fa, new fa, new fa, new fa, new fa];
        b = new ab;
        b.depthPacking = 3201;
        b.clipping = !0;
        d = bb.distanceRGBA;
        for (var L = Ja.clone(d.uniforms), C = 0; 4 !== C; ++C) {
            var F = 0 !== (C & 1), da = 0 !== (C & 2), H = b.clone();
            H.morphTargets = F;
            H.skinning =
                da;
            A[C] = H;
            F = new Ha({
                defines: {USE_SHADOWMAP: ""},
                uniforms: L,
                vertexShader: d.vertexShader,
                fragmentShader: d.fragmentShader,
                morphTargets: F,
                skinning: da,
                clipping: !0
            });
            w[C] = F
        }
        var aa = this;
        this.enabled = !1;
        this.autoUpdate = !0;
        this.needsUpdate = !1;
        this.type = 1;
        this.renderSingleSided = this.renderReverseSided = !0;
        this.render = function (b, d) {
            if (!1 !== aa.enabled && (!1 !== aa.autoUpdate || !1 !== aa.needsUpdate) && 0 !== t.length) {
                h.buffers.color.setClear(1, 1, 1, 1);
                h.disable(g.BLEND);
                h.setDepthTest(!0);
                h.setScissorTest(!1);
                for (var y,
                         q, A = 0, C = t.length; A < C; A++) {
                    var w = t[A], L = w.shadow;
                    if (void 0 === L) console.warn("THREE.WebGLShadowMap:", w, "has no shadow."); else {
                        var F = L.camera;
                        p.copy(L.mapSize);
                        p.min(n);
                        if (w && w.isPointLight) {
                            y = 6;
                            q = !0;
                            var H = p.x, da = p.y;
                            E[0].set(2 * H, da, H, da);
                            E[1].set(0, da, H, da);
                            E[2].set(3 * H, da, H, da);
                            E[3].set(H, da, H, da);
                            E[4].set(3 * H, 0, H, da);
                            E[5].set(H, 0, H, da);
                            p.x *= 4;
                            p.y *= 2
                        } else y = 1, q = !1;
                        null === L.map && (L.map = new Ya(p.x, p.y, {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        }), F.updateProjectionMatrix());
                        L.isSpotLightShadow && L.update(w);
                        L && L.isRectAreaLightShadow && L.update(w);
                        H = L.map;
                        L = L.matrix;
                        l.setFromMatrixPosition(w.matrixWorld);
                        F.position.copy(l);
                        a.setRenderTarget(H);
                        a.clear();
                        for (H = 0; H < y; H++) {
                            q ? (u.copy(F.position), u.add(K[H]), F.up.copy(v[H]), F.lookAt(u), h.viewport(E[H])) : (u.setFromMatrixPosition(w.target.matrixWorld), F.lookAt(u));
                            F.updateMatrixWorld();
                            F.matrixWorldInverse.getInverse(F.matrixWorld);
                            L.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
                            L.multiply(F.projectionMatrix);
                            L.multiply(F.matrixWorldInverse);
                            k.multiplyMatrices(F.projectionMatrix,
                                F.matrixWorldInverse);
                            m.setFromMatrix(k);
                            r.length = 0;
                            f(b, d, F);
                            for (var da = 0, x = r.length; da < x; da++) {
                                var D = r[da], Td = c.update(D), Sa = D.material;
                                if (Sa && Sa.isMultiMaterial)for (var Le = Td.groups, Sa = Sa.materials, z = 0,
                                                                      Ea = Le.length; z < Ea; z++) {
                                    var I = Le[z], J = Sa[I.materialIndex];
                                    !0 === J.visible && (J = e(D, J, q, l), a.renderBufferDirect(F, null, Td, J, D, I))
                                } else J = e(D, Sa, q, l), a.renderBufferDirect(F, null, Td, J, D, null)
                            }
                        }
                    }
                }
                y = a.getClearColor();
                q = a.getClearAlpha();
                a.setClearColor(y, q);
                aa.needsUpdate = !1
            }
        }
    }

    function cb(a, b) {
        this.origin =
            void 0 !== a ? a : new q;
        this.direction = void 0 !== b ? b : new q
    }

    function db(a, b, c, d) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = c || 0;
        this._order = d || db.DefaultOrder
    }

    function nd() {
        this.mask = 1
    }

    function x() {
        Object.defineProperty(this, "id", {value: Bf++});
        this.uuid = N.generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = x.DefaultUp.clone();
        var a = new q, b = new db, c = new ca, d = new q(1, 1, 1);
        b.onChange(function () {
            c.setFromEuler(b, !1)
        });
        c.onChange(function () {
            b.setFromQuaternion(c, void 0, !1)
        });
        Object.defineProperties(this,
            {
                position: {enumerable: !0, value: a},
                rotation: {enumerable: !0, value: b},
                quaternion: {enumerable: !0, value: c},
                scale: {enumerable: !0, value: d},
                modelViewMatrix: {value: new S},
                normalMatrix: {value: new ya}
            });
        this.matrix = new S;
        this.matrixWorld = new S;
        this.matrixAutoUpdate = x.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = !1;
        this.layers = new nd;
        this.visible = !0;
        this.receiveShadow = this.castShadow = !1;
        this.frustumCulled = !0;
        this.renderOrder = 0;
        this.userData = {};
        this.onBeforeRender = function () {
        };
        this.onAfterRender = function () {
        }
    }

    function hb(a, b) {
        this.start = void 0 !== a ? a : new q;
        this.end = void 0 !== b ? b : new q
    }

    function za(a, b, c) {
        this.a = void 0 !== a ? a : new q;
        this.b = void 0 !== b ? b : new q;
        this.c = void 0 !== c ? c : new q
    }

    function ha(a, b, c, d, e, f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = d && d.isVector3 ? d : new q;
        this.vertexNormals = Array.isArray(d) ? d : [];
        this.color = e && e.isColor ? e : new J;
        this.vertexColors = Array.isArray(e) ? e : [];
        this.materialIndex = void 0 !== f ? f : 0
    }

    function Ka(a) {
        X.call(this);
        this.type = "MeshBasicMaterial";
        this.color = new J(16777215);
        this.lightMap =
            this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.lights = this.morphTargets = this.skinning = !1;
        this.setValues(a)
    }

    function U(a, b, c) {
        if (Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = N.generateUUID();
        this.array = a;
        this.itemSize = b;
        this.count = void 0 !== a ? a.length / b : 0;
        this.normalized = !0 === c;
        this.dynamic = !1;
        this.updateRange = {offset: 0, count: -1};
        this.onUploadCallback = function () {
        };
        this.version = 0
    }

    function uc(a, b) {
        U.call(this, new Int8Array(a), b)
    }

    function vc(a, b) {
        U.call(this, new Uint8Array(a), b)
    }

    function wc(a, b) {
        U.call(this, new Uint8ClampedArray(a), b)
    }

    function xc(a, b) {
        U.call(this, new Int16Array(a), b)
    }

    function ib(a, b) {
        U.call(this, new Uint16Array(a), b)
    }

    function yc(a, b) {
        U.call(this, new Int32Array(a), b)
    }

    function jb(a, b) {
        U.call(this,
            new Uint32Array(a), b)
    }

    function z(a, b) {
        U.call(this, new Float32Array(a), b)
    }

    function zc(a, b) {
        U.call(this, new Float64Array(a), b)
    }

    function Me() {
        this.indices = [];
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingSphere = this.boundingBox = null;
        this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }

    function Ud(a) {
        for (var b = a.length, c = -Infinity; b--;)a[b] >
        c && (c = a[b]);
        return c
    }

    function T() {
        Object.defineProperty(this, "id", {value: Vd++});
        this.uuid = N.generateUUID();
        this.name = "";
        this.type = "Geometry";
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingSphere = this.boundingBox = null;
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate =
            !1
    }

    function I() {
        Object.defineProperty(this, "id", {value: Vd++});
        this.uuid = N.generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingSphere = this.boundingBox = null;
        this.drawRange = {start: 0, count: Infinity}
    }

    function Aa(a, b) {
        x.call(this);
        this.type = "Mesh";
        this.geometry = void 0 !== a ? a : new I;
        this.material = void 0 !== b ? b : new Ka({color: 16777215 * Math.random()});
        this.drawMode = 0;
        this.updateMorphTargets()
    }

    function Ib(a, b, c, d, e, f) {
        T.call(this);
        this.type = "BoxGeometry";
        this.parameters = {width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f};
        this.fromBufferGeometry(new kb(a, b, c, d, e, f));
        this.mergeVertices()
    }

    function kb(a, b, c, d, e, f) {
        function g(a, b, c, d, e, f, g, l, L, C, F) {
            var da = f / L, H = g / C, aa = f / 2, x = g / 2, D = l / 2;
            g = L + 1;
            var z = C + 1, Q = f = 0, M, O, P = new q;
            for (O = 0; O < z; O++) {
                var J = O * H - x;
                for (M = 0; M < g; M++)P[a] = (M * da - aa) * d, P[b] = J * e, P[c] = D, k.push(P.x, P.y, P.z), P[a] = 0, P[b] = 0, P[c] = 0 < l ? 1 : -1, t.push(P.x, P.y, P.z), p.push(M / L), p.push(1 - O / C), f += 1
            }
            for (O = 0; O < C; O++)for (M =
                                            0; M < L; M++)a = n + M + g * (O + 1), b = n + (M + 1) + g * (O + 1), c = n + (M + 1) + g * O, m.push(n + M + g * O, a, c), m.push(a, b, c), Q += 6;
            h.addGroup(u, Q, F);
            u += Q;
            n += f
        }

        I.call(this);
        this.type = "BoxBufferGeometry";
        this.parameters = {width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f};
        var h = this;
        d = Math.floor(d) || 1;
        e = Math.floor(e) || 1;
        f = Math.floor(f) || 1;
        var m = [], k = [], t = [], p = [], n = 0, u = 0;
        g("z", "y", "x", -1, -1, c, b, a, f, e, 0);
        g("z", "y", "x", 1, -1, c, b, -a, f, e, 1);
        g("x", "z", "y", 1, 1, a, c, b, d, f, 2);
        g("x", "z", "y", 1, -1, a, c, -b, d, f, 3);
        g("x", "y", "z",
            1, -1, a, b, c, d, e, 4);
        g("x", "y", "z", -1, -1, a, b, -c, d, e, 5);
        this.setIndex(m);
        this.addAttribute("position", new z(k, 3));
        this.addAttribute("normal", new z(t, 3));
        this.addAttribute("uv", new z(p, 2))
    }

    function Ac(a, b, c, d) {
        T.call(this);
        this.type = "PlaneGeometry";
        this.parameters = {width: a, height: b, widthSegments: c, heightSegments: d};
        this.fromBufferGeometry(new lb(a, b, c, d))
    }

    function lb(a, b, c, d) {
        I.call(this);
        this.type = "PlaneBufferGeometry";
        this.parameters = {width: a, height: b, widthSegments: c, heightSegments: d};
        var e = a / 2, f = b /
            2;
        c = Math.floor(c) || 1;
        d = Math.floor(d) || 1;
        var g = c + 1, h = d + 1, m = a / c, k = b / d, t = [], p = [], n = [], u = [];
        for (a = 0; a < h; a++) {
            var l = a * k - f;
            for (b = 0; b < g; b++)p.push(b * m - e, -l, 0), n.push(0, 0, 1), u.push(b / c), u.push(1 - a / d)
        }
        for (a = 0; a < d; a++)for (b = 0; b < c; b++)e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, t.push(b + g * a, e, h), t.push(e, f, h);
        this.setIndex(t);
        this.addAttribute("position", new z(p, 3));
        this.addAttribute("normal", new z(n, 3));
        this.addAttribute("uv", new z(u, 2))
    }

    function ra() {
        x.call(this);
        this.type = "Camera";
        this.matrixWorldInverse = new S;
        this.projectionMatrix =
            new S
    }

    function Fa(a, b, c, d) {
        ra.call(this);
        this.type = "PerspectiveCamera";
        this.fov = void 0 !== a ? a : 50;
        this.zoom = 1;
        this.near = void 0 !== c ? c : .1;
        this.far = void 0 !== d ? d : 2E3;
        this.focus = 10;
        this.aspect = void 0 !== b ? b : 1;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix()
    }

    function Jb(a, b, c, d, e, f) {
        ra.call(this);
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = a;
        this.right = b;
        this.top = c;
        this.bottom = d;
        this.near = void 0 !== e ? e : .1;
        this.far = void 0 !== f ? f : 2E3;
        this.updateProjectionMatrix()
    }

    function Cf(a, b, c) {
        var d, e, f;
        return {
            setMode: function (a) {
                d = a
            }, setIndex: function (c) {
                c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (e = a.UNSIGNED_INT, f = 4) : c.array instanceof Uint16Array ? (e = a.UNSIGNED_SHORT, f = 2) : (e = a.UNSIGNED_BYTE, f = 1)
            }, render: function (b, h) {
                a.drawElements(d, h, e, b * f);
                c.calls++;
                c.vertices += h;
                d === a.TRIANGLES && (c.faces += h / 3)
            }, renderInstances: function (g, h, m) {
                var k = b.get("ANGLE_instanced_arrays");
                null === k ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") :
                    (k.drawElementsInstancedANGLE(d, m, e, h * f, g.maxInstancedCount), c.calls++, c.vertices += m * g.maxInstancedCount, d === a.TRIANGLES && (c.faces += g.maxInstancedCount * m / 3))
            }
        }
    }

    function Df(a, b, c) {
        var d;
        return {
            setMode: function (a) {
                d = a
            }, render: function (b, f) {
                a.drawArrays(d, b, f);
                c.calls++;
                c.vertices += f;
                d === a.TRIANGLES && (c.faces += f / 3)
            }, renderInstances: function (e) {
                var f = b.get("ANGLE_instanced_arrays");
                if (null === f) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    var g = e.attributes.position, g = g.isInterleavedBufferAttribute ? g.data.count : g.count;
                    f.drawArraysInstancedANGLE(d, 0, g, e.maxInstancedCount);
                    c.calls++;
                    c.vertices += g * e.maxInstancedCount;
                    d === a.TRIANGLES && (c.faces += e.maxInstancedCount * g / 3)
                }
            }
        }
    }

    function Ef() {
        var a = {};
        return {
            get: function (b) {
                if (void 0 !== a[b.id])return a[b.id];
                var c;
                switch (b.type) {
                    case "DirectionalLight":
                        c = {
                            direction: new q,
                            color: new J,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new D
                        };
                        break;
                    case "SpotLight":
                        c = {
                            position: new q,
                            direction: new q,
                            color: new J,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new D
                        };
                        break;
                    case "PointLight":
                        c = {
                            position: new q,
                            color: new J,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new D
                        };
                        break;
                    case "HemisphereLight":
                        c = {direction: new q, skyColor: new J, groundColor: new J};
                        break;
                    case "RectAreaLight":
                        c = {color: new J, position: new q, halfWidth: new q, halfHeight: new q}
                }
                return a[b.id] = c
            }
        }
    }

    function Ff(a) {
        a = a.split("\n");
        for (var b = 0; b < a.length; b++)a[b] =
            b + 1 + ": " + a[b];
        return a.join("\n")
    }

    function Ne(a, b, c) {
        var d = a.createShader(b);
        a.shaderSource(d, c);
        a.compileShader(d);
        !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
        "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), Ff(c));
        return d
    }

    function Oe(a) {
        switch (a) {
            case 3E3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE",
                    "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw Error("unsupported encoding: " + a);
        }
    }

    function Wd(a, b) {
        var c = Oe(b);
        return "vec4 " + a + "( vec4 value ) { return " + c[0] + "ToLinear" + c[1] + "; }"
    }

    function Gf(a, b) {
        var c = Oe(b);
        return "vec4 " + a + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"
    }

    function Hf(a, b) {
        var c;
        switch (b) {
            case 1:
                c = "Linear";
                break;
            case 2:
                c = "Reinhard";
                break;
            case 3:
                c = "Uncharted2";
                break;
            case 4:
                c = "OptimizedCineon";
                break;
            default:
                throw Error("unsupported toneMapping: " + b);
        }
        return "vec3 " + a + "( vec3 color ) { return " + c + "ToneMapping( color ); }"
    }

    function If(a, b, c) {
        a = a || {};
        return [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ?
            "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Bc).join("\n")
    }

    function Jf(a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            !1 !== d && b.push("#define " + c + " " + d)
        }
        return b.join("\n")
    }

    function Bc(a) {
        return "" !== a
    }

    function Pe(a, b) {
        return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,
            b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
    }

    function Xd(a) {
        return a.replace(/#include +<([\w\d.]+)>/g, function (a, c) {
            var d = Z[c];
            if (void 0 === d)throw Error("Can not resolve #include <" + c + ">");
            return Xd(d)
        })
    }

    function Qe(a) {
        return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (a, c, d, e) {
            a = "";
            for (c = parseInt(c); c < parseInt(d); c++)a += e.replace(/\[ i \]/g, "[ " + c + " ]");
            return a
        })
    }

    function Kf(a, b, c, d) {
        var e = a.context, f = c.extensions, g = c.defines, h = c.__webglShader.vertexShader,
            m = c.__webglShader.fragmentShader, k = "SHADOWMAP_TYPE_BASIC";
        1 === d.shadowMapType ? k = "SHADOWMAP_TYPE_PCF" : 2 === d.shadowMapType && (k = "SHADOWMAP_TYPE_PCF_SOFT");
        var t = "ENVMAP_TYPE_CUBE", p = "ENVMAP_MODE_REFLECTION", n = "ENVMAP_BLENDING_MULTIPLY";
        if (d.envMap) {
            switch (c.envMap.mapping) {
                case 301:
                case 302:
                    t = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    t = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    t = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    t = "ENVMAP_TYPE_SPHERE"
            }
            switch (c.envMap.mapping) {
                case 302:
                case 304:
                    p = "ENVMAP_MODE_REFRACTION"
            }
            switch (c.combine) {
                case 0:
                    n =
                        "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    n = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    n = "ENVMAP_BLENDING_ADD"
            }
        }
        var u = 0 < a.gammaFactor ? a.gammaFactor : 1, f = If(f, d, a.extensions), l = Jf(g), r = e.createProgram();
        c.isRawShaderMaterial ? (g = [l, "\n"].filter(Bc).join("\n"), k = [f, l, "\n"].filter(Bc).join("\n")) : (g = ["precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, l, d.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + u, "#define MAX_BONES " +
        d.maxBones, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + p : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.displacementMap && d.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" :
            "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.skinning ? "#define USE_SKINNING" : "", d.useVertexTexture ? "#define BONE_TEXTURE" : "", d.morphTargets ? "#define USE_MORPHTARGETS" : "", d.morphNormals && !1 === d.flatShading ? "#define USE_MORPHNORMALS" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, d.shadowMapEnabled ? "#define USE_SHADOWMAP" :
            "", d.shadowMapEnabled ? "#define " + k : "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR",
            "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;",
            "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Bc).join("\n"), k = [f, "precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, l, d.alphaTest ? "#define ALPHATEST " + d.alphaTest : "", "#define GAMMA_FACTOR " + u, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + t : "", d.envMap ?
            "#define " + p : "", d.envMap ? "#define " + n : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.gradientMap ? "#define USE_GRADIENTMAP" : "", d.flatShading ? "#define FLAT_SHADED" :
            "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (d.numClippingPlanes - d.numClipIntersection), d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + k : "", d.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", d.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ?
            "#define USE_LOGDEPTHBUF_EXT" : "", d.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== d.toneMapping ? "#define TONE_MAPPING" : "", 0 !== d.toneMapping ? Z.tonemapping_pars_fragment : "", 0 !== d.toneMapping ? Hf("toneMapping", d.toneMapping) : "", d.outputEncoding || d.mapEncoding || d.envMapEncoding || d.emissiveMapEncoding ? Z.encodings_pars_fragment : "", d.mapEncoding ? Wd("mapTexelToLinear", d.mapEncoding) : "", d.envMapEncoding ? Wd("envMapTexelToLinear",
            d.envMapEncoding) : "", d.emissiveMapEncoding ? Wd("emissiveMapTexelToLinear", d.emissiveMapEncoding) : "", d.outputEncoding ? Gf("linearToOutputTexel", d.outputEncoding) : "", d.depthPacking ? "#define DEPTH_PACKING " + c.depthPacking : "", "\n"].filter(Bc).join("\n"));
        h = Xd(h, d);
        h = Pe(h, d);
        m = Xd(m, d);
        m = Pe(m, d);
        c.isShaderMaterial || (h = Qe(h), m = Qe(m));
        m = k + m;
        h = Ne(e, e.VERTEX_SHADER, g + h);
        m = Ne(e, e.FRAGMENT_SHADER, m);
        e.attachShader(r, h);
        e.attachShader(r, m);
        void 0 !== c.index0AttributeName ? e.bindAttribLocation(r, 0, c.index0AttributeName) :
            !0 === d.morphTargets && e.bindAttribLocation(r, 0, "position");
        e.linkProgram(r);
        d = e.getProgramInfoLog(r);
        t = e.getShaderInfoLog(h);
        p = e.getShaderInfoLog(m);
        u = n = !0;
        if (!1 === e.getProgramParameter(r, e.LINK_STATUS)) n = !1, console.error("THREE.WebGLProgram: shader error: ", e.getError(), "gl.VALIDATE_STATUS", e.getProgramParameter(r, e.VALIDATE_STATUS), "gl.getProgramInfoLog", d, t, p); else if ("" !== d) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", d); else if ("" === t || "" === p) u = !1;
        u && (this.diagnostics = {
            runnable: n,
            material: c, programLog: d, vertexShader: {log: t, prefix: g}, fragmentShader: {log: p, prefix: k}
        });
        e.deleteShader(h);
        e.deleteShader(m);
        var q;
        this.getUniforms = function () {
            void 0 === q && (q = new $a(e, r, a));
            return q
        };
        var w;
        this.getAttributes = function () {
            if (void 0 === w) {
                for (var a = {}, b = e.getProgramParameter(r, e.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) {
                    var d = e.getActiveAttrib(r, c).name;
                    a[d] = e.getAttribLocation(r, d)
                }
                w = a
            }
            return w
        };
        this.destroy = function () {
            e.deleteProgram(r);
            this.program = void 0
        };
        Object.defineProperties(this, {
            uniforms: {
                get: function () {
                    console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
                    return this.getUniforms()
                }
            }, attributes: {
                get: function () {
                    console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
                    return this.getAttributes()
                }
            }
        });
        this.id = Lf++;
        this.code = b;
        this.usedTimes = 1;
        this.program = r;
        this.vertexShader = h;
        this.fragmentShader = m;
        return this
    }

    function Mf(a, b) {
        function c(a, b) {
            var c;
            a ? a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c =
                    a.texture.encoding) : c = 3E3;
            3E3 === c && b && (c = 3007);
            return c
        }

        var d = [], e = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points"
            },
            f = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking".split(" ");
        this.getParameters = function (d, f, m, k, t, p) {
            var n = e[d.type], u;
            b.floatVertexTextures && p && p.skeleton && p.skeleton.useVertexTexture ? u = 1024 : (u = Math.floor((b.maxVertexUniforms - 20) / 4), void 0 !== p && p && p.isSkinnedMesh && (u = Math.min(p.skeleton.bones.length, u), u < p.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + p.skeleton.bones.length + ", this GPU supports just " + u + " (try OpenGL instead of ANGLE)")));
            var l = a.getPrecision();
            null !== d.precision && (l = b.getMaxPrecision(d.precision), l !== d.precision &&
            console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", l, "instead."));
            var r = a.getCurrentRenderTarget();
            return {
                shaderID: n,
                precision: l,
                supportsVertexTextures: b.vertexTextures,
                outputEncoding: c(r ? r.texture : null, a.gammaOutput),
                map: !!d.map,
                mapEncoding: c(d.map, a.gammaInput),
                envMap: !!d.envMap,
                envMapMode: d.envMap && d.envMap.mapping,
                envMapEncoding: c(d.envMap, a.gammaInput),
                envMapCubeUV: !!d.envMap && (306 === d.envMap.mapping || 307 === d.envMap.mapping),
                lightMap: !!d.lightMap,
                aoMap: !!d.aoMap,
                emissiveMap: !!d.emissiveMap,
                emissiveMapEncoding: c(d.emissiveMap, a.gammaInput),
                bumpMap: !!d.bumpMap,
                normalMap: !!d.normalMap,
                displacementMap: !!d.displacementMap,
                roughnessMap: !!d.roughnessMap,
                metalnessMap: !!d.metalnessMap,
                specularMap: !!d.specularMap,
                alphaMap: !!d.alphaMap,
                gradientMap: !!d.gradientMap,
                combine: d.combine,
                vertexColors: d.vertexColors,
                fog: !!m,
                useFog: d.fog,
                fogExp: m && m.isFogExp2,
                flatShading: 1 === d.shading,
                sizeAttenuation: d.sizeAttenuation,
                logarithmicDepthBuffer: b.logarithmicDepthBuffer,
                skinning: d.skinning,
                maxBones: u,
                useVertexTexture: b.floatVertexTextures && p && p.skeleton && p.skeleton.useVertexTexture,
                morphTargets: d.morphTargets,
                morphNormals: d.morphNormals,
                maxMorphTargets: a.maxMorphTargets,
                maxMorphNormals: a.maxMorphNormals,
                numDirLights: f.directional.length,
                numPointLights: f.point.length,
                numSpotLights: f.spot.length,
                numRectAreaLights: f.rectArea.length,
                numHemiLights: f.hemi.length,
                numClippingPlanes: k,
                numClipIntersection: t,
                shadowMapEnabled: a.shadowMap.enabled && p.receiveShadow && 0 < f.shadows.length,
                shadowMapType: a.shadowMap.type,
                toneMapping: a.toneMapping,
                physicallyCorrectLights: a.physicallyCorrectLights,
                premultipliedAlpha: d.premultipliedAlpha,
                alphaTest: d.alphaTest,
                doubleSided: 2 === d.side,
                flipSided: 1 === d.side,
                depthPacking: void 0 !== d.depthPacking ? d.depthPacking : !1
            }
        };
        this.getProgramCode = function (a, b) {
            var c = [];
            b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader));
            if (void 0 !== a.defines)for (var d in a.defines)c.push(d), c.push(a.defines[d]);
            for (d = 0; d < f.length; d++)c.push(b[f[d]]);
            return c.join()
        };
        this.acquireProgram =
            function (b, c, e) {
                for (var f, t = 0, p = d.length; t < p; t++) {
                    var n = d[t];
                    if (n.code === e) {
                        f = n;
                        ++f.usedTimes;
                        break
                    }
                }
                void 0 === f && (f = new Kf(a, e, b, c), d.push(f));
                return f
            };
        this.releaseProgram = function (a) {
            if (0 === --a.usedTimes) {
                var b = d.indexOf(a);
                d[b] = d[d.length - 1];
                d.pop();
                a.destroy()
            }
        };
        this.programs = d
    }

    function Nf(a, b, c) {
        function d(a) {
            var h = a.target;
            a = f[h.id];
            null !== a.index && e(a.index);
            var m = a.attributes, k;
            for (k in m)e(m[k]);
            h.removeEventListener("dispose", d);
            delete f[h.id];
            k = b.get(h);
            k.wireframe && e(k.wireframe);
            b["delete"](h);
            h = b.get(a);
            h.wireframe && e(h.wireframe);
            b["delete"](a);
            c.memory.geometries--
        }

        function e(c) {
            var d;
            d = c.isInterleavedBufferAttribute ? b.get(c.data).__webglBuffer : b.get(c).__webglBuffer;
            void 0 !== d && (a.deleteBuffer(d), c.isInterleavedBufferAttribute ? b["delete"](c.data) : b["delete"](c))
        }

        var f = {};
        return {
            get: function (a) {
                var b = a.geometry;
                if (void 0 !== f[b.id])return f[b.id];
                b.addEventListener("dispose", d);
                var e;
                b.isBufferGeometry ? e = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new I).setFromObject(a)),
                        e = b._bufferGeometry);
                f[b.id] = e;
                c.memory.geometries++;
                return e
            }
        }
    }

    function Of(a, b, c) {
        function d(c, d) {
            var e = c.isInterleavedBufferAttribute ? c.data : c, m = b.get(e);
            if (void 0 === m.__webglBuffer) {
                m.__webglBuffer = a.createBuffer();
                a.bindBuffer(d, m.__webglBuffer);
                a.bufferData(d, e.array, e.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW);
                var k = a.FLOAT, t = e.array;
                t instanceof Float32Array ? k = a.FLOAT : t instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : t instanceof Uint16Array ? k = a.UNSIGNED_SHORT :
                    t instanceof Int16Array ? k = a.SHORT : t instanceof Uint32Array ? k = a.UNSIGNED_INT : t instanceof Int32Array ? k = a.INT : t instanceof Int8Array ? k = a.BYTE : t instanceof Uint8Array && (k = a.UNSIGNED_BYTE);
                m.bytesPerElement = t.BYTES_PER_ELEMENT;
                m.type = k;
                m.version = e.version;
                e.onUploadCallback()
            } else m.version !== e.version && (a.bindBuffer(d, m.__webglBuffer), !1 === e.dynamic ? a.bufferData(d, e.array, a.STATIC_DRAW) : -1 === e.updateRange.count ? a.bufferSubData(d, 0, e.array) : 0 === e.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") :
                (a.bufferSubData(d, e.updateRange.offset * e.array.BYTES_PER_ELEMENT, e.array.subarray(e.updateRange.offset, e.updateRange.offset + e.updateRange.count)), e.updateRange.count = 0), m.version = e.version)
        }

        var e = new Nf(a, b, c);
        return {
            getAttributeBuffer: function (a) {
                return a.isInterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer
            }, getAttributeProperties: function (a) {
                return a.isInterleavedBufferAttribute ? b.get(a.data) : b.get(a)
            }, getWireframeAttribute: function (c) {
                var e = b.get(c);
                if (void 0 !== e.wireframe)return e.wireframe;
                var h = [], m = c.index;
                c = c.attributes;
                if (null !== m) {
                    m = m.array;
                    c = 0;
                    for (var k = m.length; c < k; c += 3) {
                        var t = m[c + 0], p = m[c + 1], n = m[c + 2];
                        h.push(t, p, p, n, n, t)
                    }
                } else for (m = c.position.array, c = 0, k = m.length / 3 - 1; c < k; c += 3)t = c + 0, p = c + 1, n = c + 2, h.push(t, p, p, n, n, t);
                h = new (65535 < Ud(h) ? jb : ib)(h, 1);
                d(h, a.ELEMENT_ARRAY_BUFFER);
                return e.wireframe = h
            }, update: function (b) {
                var c = e.get(b);
                b.geometry.isGeometry && c.updateFromObject(b);
                b = c.index;
                var h = c.attributes;
                null !== b && d(b, a.ELEMENT_ARRAY_BUFFER);
                for (var m in h)d(h[m], a.ARRAY_BUFFER);
                b = c.morphAttributes;
                for (m in b)for (var h = b[m], k = 0, t = h.length; k < t; k++)d(h[k], a.ARRAY_BUFFER);
                return c
            }
        }
    }

    function Pf(a, b, c, d, e, f, g) {
        function h(a, b) {
            if (a.width > b || a.height > b) {
                var c = b / Math.max(a.width, a.height),
                    d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                d.width = Math.floor(a.width * c);
                d.height = Math.floor(a.height * c);
                d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height);
                console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " +
                    d.width + "x" + d.height, a);
                return d
            }
            return a
        }

        function m(a) {
            return N.isPowerOfTwo(a.width) && N.isPowerOfTwo(a.height)
        }

        function k(b) {
            return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR
        }

        function t(b) {
            b = b.target;
            b.removeEventListener("dispose", t);
            a:{
                var c = d.get(b);
                if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube); else {
                    if (void 0 === c.__webglInit)break a;
                    a.deleteTexture(c.__webglTexture)
                }
                d["delete"](b)
            }
            q.textures--
        }

        function p(b) {
            b = b.target;
            b.removeEventListener("dispose",
                p);
            var c = d.get(b), e = d.get(b.texture);
            if (b) {
                void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture);
                b.depthTexture && b.depthTexture.dispose();
                if (b.isWebGLRenderTargetCube)for (e = 0; 6 > e; e++)a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]); else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
                d["delete"](b.texture);
                d["delete"](b)
            }
            q.textures--
        }

        function n(b, g) {
            var k = d.get(b);
            if (0 <
                b.version && k.__version !== b.version) {
                var n = b.image;
                if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", b); else if (!1 === n.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", b); else {
                    void 0 === k.__webglInit && (k.__webglInit = !0, b.addEventListener("dispose", t), k.__webglTexture = a.createTexture(), q.textures++);
                    c.activeTexture(a.TEXTURE0 + g);
                    c.bindTexture(a.TEXTURE_2D, k.__webglTexture);
                    a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,
                        b.flipY);
                    a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
                    a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment);
                    var p = h(b.image, e.maxTextureSize);
                    if ((1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && !1 === m(p))if (n = p, n instanceof HTMLImageElement || n instanceof HTMLCanvasElement) {
                        var l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        l.width = N.nearestPowerOfTwo(n.width);
                        l.height = N.nearestPowerOfTwo(n.height);
                        l.getContext("2d").drawImage(n, 0, 0,
                            l.width, l.height);
                        console.warn("THREE.WebGLRenderer: image is not power of two (" + n.width + "x" + n.height + "). Resized to " + l.width + "x" + l.height, n);
                        p = l
                    } else p = n;
                    var n = m(p), l = f(b.format), G = f(b.type);
                    u(a.TEXTURE_2D, b, n);
                    var r = b.mipmaps;
                    if (b.isDepthTexture) {
                        r = a.DEPTH_COMPONENT;
                        if (1015 === b.type) {
                            if (!w)throw Error("Float Depth Texture only supported in WebGL2.0");
                            r = a.DEPTH_COMPONENT32F
                        } else w && (r = a.DEPTH_COMPONENT16);
                        1026 === b.format && r === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                            b.type = 1012, G = f(b.type));
                        1027 === b.format && (r = a.DEPTH_STENCIL, 1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, G = f(b.type)));
                        c.texImage2D(a.TEXTURE_2D, 0, r, p.width, p.height, 0, l, G, null)
                    } else if (b.isDataTexture)if (0 < r.length && n) {
                        for (var H = 0,
                                 aa = r.length; H < aa; H++)p = r[H], c.texImage2D(a.TEXTURE_2D, H, l, p.width, p.height, 0, l, G, p.data);
                        b.generateMipmaps = !1
                    } else c.texImage2D(a.TEXTURE_2D, 0, l, p.width, p.height, 0, l, G, p.data); else if (b.isCompressedTexture)for (H =
                                                                                                                                         0, aa = r.length; H < aa; H++)p = r[H], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(l) ? c.compressedTexImage2D(a.TEXTURE_2D, H, l, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, H, l, p.width, p.height, 0, l, G, p.data); else if (0 < r.length && n) {
                        H = 0;
                        for (aa = r.length; H < aa; H++)p = r[H], c.texImage2D(a.TEXTURE_2D, H, l, l, G, p);
                        b.generateMipmaps = !1
                    } else c.texImage2D(a.TEXTURE_2D, 0, l, l,
                        G, p);
                    b.generateMipmaps && n && a.generateMipmap(a.TEXTURE_2D);
                    k.__version = b.version;
                    if (b.onUpdate) b.onUpdate(b);
                    return
                }
            }
            c.activeTexture(a.TEXTURE0 + g);
            c.bindTexture(a.TEXTURE_2D, k.__webglTexture)
        }

        function u(c, g, h) {
            h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T,
                a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", g), a.texParameteri(c, a.TEXTURE_MAG_FILTER, k(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, k(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", g));
            !(h = b.get("EXT_texture_filter_anisotropic")) ||
            1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === b.get("OES_texture_half_float_linear") || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy)
        }

        function l(b, e, g, h) {
            var m = f(e.texture.format), k = f(e.texture.type);
            c.texImage2D(h, 0, m, e.width, e.height, 0, m, k, null);
            a.bindFramebuffer(a.FRAMEBUFFER, b);
            a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture,
                0);
            a.bindFramebuffer(a.FRAMEBUFFER, null)
        }

        function r(b, c) {
            a.bindRenderbuffer(a.RENDERBUFFER, b);
            c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER,
                a.RGBA4, c.width, c.height);
            a.bindRenderbuffer(a.RENDERBUFFER, null)
        }

        var q = g.memory, w = "undefined" !== typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext;
        this.setTexture2D = n;
        this.setTextureCube = function (b, g) {
            var k = d.get(b);
            if (6 === b.image.length)if (0 < b.version && k.__version !== b.version) {
                k.__image__webglTextureCube || (b.addEventListener("dispose", t), k.__image__webglTextureCube = a.createTexture(), q.textures++);
                c.activeTexture(a.TEXTURE0 + g);
                c.bindTexture(a.TEXTURE_CUBE_MAP, k.__image__webglTextureCube);
                a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
                for (var n = b && b.isCompressedTexture, p = b.image[0] && b.image[0].isDataTexture, l = [],
                         r = 0; 6 > r; r++)l[r] = n || p ? p ? b.image[r].image : b.image[r] : h(b.image[r], e.maxCubemapSize);
                var G = m(l[0]), w = f(b.format), aa = f(b.type);
                u(a.TEXTURE_CUBE_MAP, b, G);
                for (r = 0; 6 > r; r++)if (n)for (var x, D = l[r].mipmaps, z = 0,
                                                      Q = D.length; z < Q; z++)x = D[z], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(w) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + r, z, w, x.width, x.height,
                    0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + r, z, w, x.width, x.height, 0, w, aa, x.data); else p ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, w, l[r].width, l[r].height, 0, w, aa, l[r].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, w, w, aa, l[r]);
                b.generateMipmaps && G && a.generateMipmap(a.TEXTURE_CUBE_MAP);
                k.__version = b.version;
                if (b.onUpdate) b.onUpdate(b)
            } else c.activeTexture(a.TEXTURE0 +
                g), c.bindTexture(a.TEXTURE_CUBE_MAP, k.__image__webglTextureCube)
        };
        this.setTextureCubeDynamic = function (b, e) {
            c.activeTexture(a.TEXTURE0 + e);
            c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture)
        };
        this.setupRenderTarget = function (b) {
            var e = d.get(b), f = d.get(b.texture);
            b.addEventListener("dispose", p);
            f.__webglTexture = a.createTexture();
            q.textures++;
            var g = !0 === b.isWebGLRenderTargetCube, h = m(b);
            if (g) {
                e.__webglFramebuffer = [];
                for (var k = 0; 6 > k; k++)e.__webglFramebuffer[k] = a.createFramebuffer()
            } else e.__webglFramebuffer =
                a.createFramebuffer();
            if (g) {
                c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture);
                u(a.TEXTURE_CUBE_MAP, b.texture, h);
                for (k = 0; 6 > k; k++)l(e.__webglFramebuffer[k], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + k);
                b.texture.generateMipmaps && h && a.generateMipmap(a.TEXTURE_CUBE_MAP);
                c.bindTexture(a.TEXTURE_CUBE_MAP, null)
            } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), u(a.TEXTURE_2D, b.texture, h), l(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), b.texture.generateMipmaps && h && a.generateMipmap(a.TEXTURE_2D),
                c.bindTexture(a.TEXTURE_2D, null);
            if (b.depthBuffer) {
                e = d.get(b);
                f = !0 === b.isWebGLRenderTargetCube;
                if (b.depthTexture) {
                    if (f)throw Error("target.depthTexture not supported in Cube render targets");
                    if (b && b.isWebGLRenderTargetCube)throw Error("Depth Texture with cube render targets is not supported!");
                    a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer);
                    if (!b.depthTexture || !b.depthTexture.isDepthTexture)throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    d.get(b.depthTexture).__webglTexture &&
                    b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0);
                    n(b.depthTexture, 0);
                    e = d.get(b.depthTexture).__webglTexture;
                    if (1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0); else if (1027 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0); else throw Error("Unknown depthTexture format");
                } else if (f)for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++)a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), r(e.__webglDepthbuffer[f], b); else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), r(e.__webglDepthbuffer, b);
                a.bindFramebuffer(a.FRAMEBUFFER, null)
            }
        };
        this.updateRenderTargetMipmap = function (b) {
            var e = b.texture;
            e.generateMipmaps && m(b) && 1003 !== e.minFilter && 1006 !== e.minFilter && (b = b && b.isWebGLRenderTargetCube ?
                a.TEXTURE_CUBE_MAP : a.TEXTURE_2D, e = d.get(e).__webglTexture, c.bindTexture(b, e), a.generateMipmap(b), c.bindTexture(b, null))
        }
    }

    function Qf() {
        var a = {};
        return {
            get: function (b) {
                b = b.uuid;
                var c = a[b];
                void 0 === c && (c = {}, a[b] = c);
                return c
            }, "delete": function (b) {
                delete a[b.uuid]
            }, clear: function () {
                a = {}
            }
        }
    }

    function Rf(a, b, c) {
        function d(b, c, d) {
            var e = new Uint8Array(4), f = a.createTexture();
            a.bindTexture(b, f);
            a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST);
            a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST);
            for (b = 0; b < d; b++)a.texImage2D(c +
                b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
            return f
        }

        function e(b) {
            !0 !== y[b] && (a.enable(b), y[b] = !0)
        }

        function f(b) {
            !1 !== y[b] && (a.disable(b), y[b] = !1)
        }

        function g(b, d, g, h, m, k, n, t) {
            0 !== b ? e(a.BLEND) : f(a.BLEND);
            if (b !== v || t !== x) 2 === b ? t ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : 3 === b ? t ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) :
                (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : 4 === b ? t ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : t ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)),
                v = b, x = t;
            if (5 === b) {
                m = m || d;
                k = k || g;
                n = n || h;
                if (d !== E || m !== F) a.blendEquationSeparate(c(d), c(m)), E = d, F = m;
                if (g !== L || h !== C || k !== da || n !== H) a.blendFuncSeparate(c(g), c(h), c(k), c(n)), L = g, C = h, da = k, H = n
            } else H = da = F = C = L = E = null
        }

        function h(a) {
            n.setFunc(a)
        }

        function m(b) {
            D !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), D = b)
        }

        function k(b) {
            0 !== b ? (e(a.CULL_FACE), b !== z && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : f(a.CULL_FACE);
            z = b
        }

        function t(b) {
            void 0 === b && (b = a.TEXTURE0 + P - 1);
            W !== b && (a.activeTexture(b),
                W = b)
        }

        var p = new function () {
                var b = !1, c = new fa, d = null, e = new fa;
                return {
                    setMask: function (c) {
                        d === c || b || (a.colorMask(c, c, c, c), d = c)
                    }, setLocked: function (a) {
                        b = a
                    }, setClear: function (b, d, f, g, h) {
                        !0 === h && (b *= g, d *= g, f *= g);
                        c.set(b, d, f, g);
                        !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c))
                    }, reset: function () {
                        b = !1;
                        d = null;
                        e.set(0, 0, 0, 1)
                    }
                }
            }, n = new function () {
                var b = !1, c = null, d = null, g = null;
                return {
                    setTest: function (b) {
                        b ? e(a.DEPTH_TEST) : f(a.DEPTH_TEST)
                    }, setMask: function (d) {
                        c === d || b || (a.depthMask(d), c = d)
                    }, setFunc: function (b) {
                        if (d !==
                            b) {
                            if (b)switch (b) {
                                case 0:
                                    a.depthFunc(a.NEVER);
                                    break;
                                case 1:
                                    a.depthFunc(a.ALWAYS);
                                    break;
                                case 2:
                                    a.depthFunc(a.LESS);
                                    break;
                                case 3:
                                    a.depthFunc(a.LEQUAL);
                                    break;
                                case 4:
                                    a.depthFunc(a.EQUAL);
                                    break;
                                case 5:
                                    a.depthFunc(a.GEQUAL);
                                    break;
                                case 6:
                                    a.depthFunc(a.GREATER);
                                    break;
                                case 7:
                                    a.depthFunc(a.NOTEQUAL);
                                    break;
                                default:
                                    a.depthFunc(a.LEQUAL)
                            } else a.depthFunc(a.LEQUAL);
                            d = b
                        }
                    }, setLocked: function (a) {
                        b = a
                    }, setClear: function (b) {
                        g !== b && (a.clearDepth(b), g = b)
                    }, reset: function () {
                        b = !1;
                        g = d = c = null
                    }
                }
            }, u = new function () {
                var b = !1, c =
                    null, d = null, g = null, h = null, m = null, k = null, n = null, t = null;
                return {
                    setTest: function (b) {
                        b ? e(a.STENCIL_TEST) : f(a.STENCIL_TEST)
                    }, setMask: function (d) {
                        c === d || b || (a.stencilMask(d), c = d)
                    }, setFunc: function (b, c, e) {
                        if (d !== b || g !== c || h !== e) a.stencilFunc(b, c, e), d = b, g = c, h = e
                    }, setOp: function (b, c, d) {
                        if (m !== b || k !== c || n !== d) a.stencilOp(b, c, d), m = b, k = c, n = d
                    }, setLocked: function (a) {
                        b = a
                    }, setClear: function (b) {
                        t !== b && (a.clearStencil(b), t = b)
                    }, reset: function () {
                        b = !1;
                        t = n = k = m = h = g = d = c = null
                    }
                }
            }, l = a.getParameter(a.MAX_VERTEX_ATTRIBS), r = new Uint8Array(l),
            q = new Uint8Array(l), w = new Uint8Array(l), y = {}, K = null, v = null, E = null, L = null, C = null,
            F = null, da = null, H = null, x = !1, D = null, z = null, J = null, Q = null, M = null, O = null,
            P = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
            l = parseFloat(/^WebGL\ ([0-9])/.exec(a.getParameter(a.VERSION))[1]), I = 1 <= parseFloat(l), W = null,
            S = {}, R = new fa, T = new fa, N = {};
        N[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1);
        N[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        return {
            buffers: {color: p, depth: n, stencil: u}, init: function () {
                p.setClear(0,
                    0, 0, 1);
                n.setClear(1);
                u.setClear(0);
                e(a.DEPTH_TEST);
                h(3);
                m(!1);
                k(1);
                e(a.CULL_FACE);
                e(a.BLEND);
                g(1)
            }, initAttributes: function () {
                for (var a = 0, b = r.length; a < b; a++)r[a] = 0
            }, enableAttribute: function (c) {
                r[c] = 1;
                0 === q[c] && (a.enableVertexAttribArray(c), q[c] = 1);
                0 !== w[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), w[c] = 0)
            }, enableAttributeAndDivisor: function (b, c, d) {
                r[b] = 1;
                0 === q[b] && (a.enableVertexAttribArray(b), q[b] = 1);
                w[b] !== c && (d.vertexAttribDivisorANGLE(b, c), w[b] = c)
            }, disableUnusedAttributes: function () {
                for (var b =
                    0, c = q.length; b !== c; ++b)q[b] !== r[b] && (a.disableVertexAttribArray(b), q[b] = 0)
            }, enable: e, disable: f, getCompressedTextureFormats: function () {
                if (null === K && (K = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1")))for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS),
                                                                                                                                                                                 d = 0; d < c.length; d++)K.push(c[d]);
                return K
            }, setBlending: g, setColorWrite: function (a) {
                p.setMask(a)
            }, setDepthTest: function (a) {
                n.setTest(a)
            }, setDepthWrite: function (a) {
                n.setMask(a)
            },
            setDepthFunc: h, setStencilTest: function (a) {
                u.setTest(a)
            }, setStencilWrite: function (a) {
                u.setMask(a)
            }, setStencilFunc: function (a, b, c) {
                u.setFunc(a, b, c)
            }, setStencilOp: function (a, b, c) {
                u.setOp(a, b, c)
            }, setFlipSided: m, setCullFace: k, setLineWidth: function (b) {
                b !== J && (I && a.lineWidth(b), J = b)
            }, setPolygonOffset: function (b, c, d) {
                if (b) {
                    if (e(a.POLYGON_OFFSET_FILL), Q !== c || M !== d) a.polygonOffset(c, d), Q = c, M = d
                } else f(a.POLYGON_OFFSET_FILL)
            }, getScissorTest: function () {
                return O
            }, setScissorTest: function (b) {
                (O = b) ? e(a.SCISSOR_TEST) :
                    f(a.SCISSOR_TEST)
            }, activeTexture: t, bindTexture: function (b, c) {
                null === W && t();
                var d = S[W];
                void 0 === d && (d = {type: void 0, texture: void 0}, S[W] = d);
                if (d.type !== b || d.texture !== c) a.bindTexture(b, c || N[b]), d.type = b, d.texture = c
            }, compressedTexImage2D: function () {
                try {
                    a.compressedTexImage2D.apply(a, arguments)
                } catch (b) {
                    console.error(b)
                }
            }, texImage2D: function () {
                try {
                    a.texImage2D.apply(a, arguments)
                } catch (b) {
                    console.error(b)
                }
            }, scissor: function (b) {
                !1 === R.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), R.copy(b))
            }, viewport: function (b) {
                !1 ===
                T.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), T.copy(b))
            }, reset: function () {
                for (var b = 0; b < q.length; b++)1 === q[b] && (a.disableVertexAttribArray(b), q[b] = 0);
                y = {};
                W = K = null;
                S = {};
                z = D = v = null;
                p.reset();
                n.reset();
                u.reset()
            }
        }
    }

    function Sf(a, b, c) {
        function d(b) {
            if ("highp" === b) {
                if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision)return "highp";
                b = "mediump"
            }
            return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision &&
            0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
        }

        var e, f = void 0 !== c.precision ? c.precision : "highp", g = d(f);
        g !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", g, "instead."), f = g);
        c = !0 === c.logarithmicDepthBuffer && !!b.get("EXT_frag_depth");
        var g = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), h = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            m = a.getParameter(a.MAX_TEXTURE_SIZE), k = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
            t = a.getParameter(a.MAX_VERTEX_ATTRIBS),
            p = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), n = a.getParameter(a.MAX_VARYING_VECTORS),
            u = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), l = 0 < h, r = !!b.get("OES_texture_float");
        return {
            getMaxAnisotropy: function () {
                if (void 0 !== e)return e;
                var c = b.get("EXT_texture_filter_anisotropic");
                return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: d,
            precision: f,
            logarithmicDepthBuffer: c,
            maxTextures: g,
            maxVertexTextures: h,
            maxTextureSize: m,
            maxCubemapSize: k,
            maxAttributes: t,
            maxVertexUniforms: p,
            maxVaryings: n,
            maxFragmentUniforms: u,
            vertexTextures: l,
            floatFragmentTextures: r,
            floatVertexTextures: l && r
        }
    }

    function Tf(a) {
        var b = {};
        return {
            get: function (c) {
                if (void 0 !== b[c])return b[c];
                var d;
                switch (c) {
                    case "WEBGL_depth_texture":
                        d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                            a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    case "WEBGL_compressed_texture_etc1":
                        d = a.getExtension("WEBGL_compressed_texture_etc1");
                        break;
                    default:
                        d = a.getExtension(c)
                }
                null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
                return b[c] = d
            }
        }
    }

    function Uf() {
        function a() {
            k.value !== d && (k.value = d, k.needsUpdate = 0 < e);
            c.numPlanes = e;
            c.numIntersection = 0
        }

        function b(a, b, d, e) {
            var f = null !== a ? a.length : 0, g = null;
            if (0 !== f) {
                g = k.value;
                if (!0 !== e || null === g) {
                    e = d + 4 * f;
                    b = b.matrixWorldInverse;
                    m.getNormalMatrix(b);
                    if (null === g || g.length < e) g = new Float32Array(e);
                    for (e = 0; e !== f; ++e, d += 4)h.copy(a[e]).applyMatrix4(b, m), h.normal.toArray(g, d), g[d +
                    3] = h.constant
                }
                k.value = g;
                k.needsUpdate = !0
            }
            c.numPlanes = f;
            return g
        }

        var c = this, d = null, e = 0, f = !1, g = !1, h = new la, m = new ya, k = {value: null, needsUpdate: !1};
        this.uniform = k;
        this.numIntersection = this.numPlanes = 0;
        this.init = function (a, c, g) {
            var h = 0 !== a.length || c || 0 !== e || f;
            f = c;
            d = b(a, g, 0);
            e = a.length;
            return h
        };
        this.beginShadows = function () {
            g = !0;
            b(null)
        };
        this.endShadows = function () {
            g = !1;
            a()
        };
        this.setState = function (c, h, m, l, G, r) {
            if (!f || null === c || 0 === c.length || g && !m) g ? b(null) : a(); else {
                m = g ? 0 : e;
                var q = 4 * m, w = G.clippingState || null;
                k.value = w;
                w = b(c, l, q, r);
                for (c = 0; c !== q; ++c)w[c] = d[c];
                G.clippingState = w;
                this.numIntersection = h ? this.numPlanes : 0;
                this.numPlanes += m
            }
        }
    }

    function Yd(a) {
        function b() {
            Y.init();
            Y.scissor(X.copy(ga).multiplyScalar(Ra));
            Y.viewport(Z.copy(ia).multiplyScalar(Ra));
            Y.buffers.color.setClear(Ea.r, Ea.g, Ea.b, gb, F)
        }

        function c() {
            U = wa = null;
            V = "";
            R = -1;
            Y.reset()
        }

        function d(a) {
            a.preventDefault();
            c();
            b();
            ha.clear()
        }

        function e(a) {
            a = a.target;
            a.removeEventListener("dispose", e);
            f(a);
            ha["delete"](a)
        }

        function f(a) {
            var b = ha.get(a).program;
            a.program = void 0;
            void 0 !== b && ya.releaseProgram(b)
        }

        function g(a, b) {
            return Math.abs(b[0]) - Math.abs(a[0])
        }

        function h(a, b) {
            return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.program && b.material.program && a.material.program !== b.material.program ? a.material.program.id - b.material.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
        }

        function m(a, b) {
            return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder -
                b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
        }

        function k(a, b, c, d, e) {
            var f;
            c.transparent ? (d = z, f = ++T) : (d = aa, f = ++D);
            f = d[f];
            void 0 !== f ? (f.id = a.id, f.object = a, f.geometry = b, f.material = c, f.z = Ga.z, f.group = e) : (f = {
                id: a.id,
                object: a,
                geometry: b,
                material: c,
                z: Ga.z,
                group: e
            }, d.push(f))
        }

        function t(a) {
            if (!ma.intersectsSphere(a))return !1;
            var b = ca.numPlanes;
            if (0 === b)return !0;
            var c = P.clippingPlanes, d = a.center;
            a = -a.radius;
            var e = 0;
            do if (c[e].distanceToPoint(d) < a)return !1; while (++e !== b);
            return !0
        }

        function p(a, b) {
            if (!1 !==
                a.visible) {
                if (0 !== (a.layers.mask & b.layers.mask))if (a.isLight) H.push(a); else if (a.isSprite) {
                    var c;
                    (c = !1 === a.frustumCulled) || (na.center.set(0, 0, 0), na.radius = .7071067811865476, na.applyMatrix4(a.matrixWorld), c = !0 === t(na));
                    c && M.push(a)
                } else if (a.isLensFlare) O.push(a); else if (a.isImmediateRenderObject) !0 === P.sortObjects && (Ga.setFromMatrixPosition(a.matrixWorld), Ga.applyMatrix4(ua)), k(a, null, a.material, Ga.z, null); else if (a.isMesh || a.isLine || a.isPoints)if (a.isSkinnedMesh && a.skeleton.update(), (c = !1 === a.frustumCulled) ||
                    (c = a.geometry, null === c.boundingSphere && c.computeBoundingSphere(), na.copy(c.boundingSphere).applyMatrix4(a.matrixWorld), c = !0 === t(na)), c) {
                    var d = a.material;
                    if (!0 === d.visible)if (!0 === P.sortObjects && (Ga.setFromMatrixPosition(a.matrixWorld), Ga.applyMatrix4(ua)), c = qa.update(a), d.isMultiMaterial)for (var e = c.groups,
                                                                                                                                                                                  f = d.materials,
                                                                                                                                                                                  d = 0,
                                                                                                                                                                                  g = e.length; d < g; d++) {
                        var h = e[d], m = f[h.materialIndex];
                        !0 === m.visible && k(a, c, m, Ga.z, h)
                    } else k(a, c, d, Ga.z, null)
                }
                c = a.children;
                d = 0;
                for (g = c.length; d < g; d++)p(c[d], b)
            }
        }

        function n(a, b, c,
                   d) {
            for (var e = 0, f = a.length; e < f; e++) {
                var g = a[e], h = g.object, m = g.geometry, k = void 0 === d ? g.material : d, g = g.group;
                h.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, h.matrixWorld);
                h.normalMatrix.getNormalMatrix(h.modelViewMatrix);
                h.onBeforeRender(P, b, c, m, k, g);
                if (h.isImmediateRenderObject) {
                    l(k);
                    var n = G(c, b.fog, k, h);
                    V = "";
                    h.render(function (a) {
                        P.renderBufferImmediate(a, n, k)
                    })
                } else P.renderBufferDirect(c, b.fog, m, k, h, g);
                h.onAfterRender(P, b, c, m, k, g)
            }
        }

        function l(a) {
            2 === a.side ? Y.disable(B.CULL_FACE) : Y.enable(B.CULL_FACE);
            Y.setFlipSided(1 === a.side);
            !0 === a.transparent ? Y.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha) : Y.setBlending(0);
            Y.setDepthFunc(a.depthFunc);
            Y.setDepthTest(a.depthTest);
            Y.setDepthWrite(a.depthWrite);
            Y.setColorWrite(a.colorWrite);
            Y.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
        }

        function G(a, b, c, d) {
            ea = 0;
            var g = ha.get(c);
            oa && (ra || a !== U) && ca.setState(c.clippingPlanes, c.clipIntersection,
                c.clipShadows, a, g, a === U && c.id === R);
            !1 === c.needsUpdate && (void 0 === g.program ? c.needsUpdate = !0 : c.fog && g.fog !== b ? c.needsUpdate = !0 : c.lights && g.lightsHash !== ba.hash ? c.needsUpdate = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === ca.numPlanes && g.numIntersection === ca.numIntersection || (c.needsUpdate = !0));
            if (c.needsUpdate) {
                a:{
                    var h = ha.get(c), m = ya.getParameters(c, ba, b, ca.numPlanes, ca.numIntersection, d),
                        k = ya.getProgramCode(c, m), n = h.program, t = !0;
                    if (void 0 === n) c.addEventListener("dispose", e); else if (n.code !==
                        k) f(c); else if (void 0 !== m.shaderID)break a; else t = !1;
                    t && (m.shaderID ? (n = bb[m.shaderID], h.__webglShader = {
                        name: c.type,
                        uniforms: Ja.clone(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader
                    }) : h.__webglShader = {
                        name: c.type,
                        uniforms: c.uniforms,
                        vertexShader: c.vertexShader,
                        fragmentShader: c.fragmentShader
                    }, c.__webglShader = h.__webglShader, n = ya.acquireProgram(c, m, k), h.program = n, c.program = n);
                    m = n.getAttributes();
                    if (c.morphTargets)for (k = c.numSupportedMorphTargets = 0; k < P.maxMorphTargets; k++)0 <=
                    m["morphTarget" + k] && c.numSupportedMorphTargets++;
                    if (c.morphNormals)for (k = c.numSupportedMorphNormals = 0; k < P.maxMorphNormals; k++)0 <= m["morphNormal" + k] && c.numSupportedMorphNormals++;
                    m = h.__webglShader.uniforms;
                    if (!c.isShaderMaterial && !c.isRawShaderMaterial || !0 === c.clipping) h.numClippingPlanes = ca.numPlanes, h.numIntersection = ca.numIntersection, m.clippingPlanes = ca.uniform;
                    h.fog = b;
                    h.lightsHash = ba.hash;
                    c.lights && (m.ambientLightColor.value = ba.ambient, m.directionalLights.value = ba.directional, m.spotLights.value =
                        ba.spot, m.rectAreaLights.value = ba.rectArea, m.pointLights.value = ba.point, m.hemisphereLights.value = ba.hemi, m.directionalShadowMap.value = ba.directionalShadowMap, m.directionalShadowMatrix.value = ba.directionalShadowMatrix, m.spotShadowMap.value = ba.spotShadowMap, m.spotShadowMatrix.value = ba.spotShadowMatrix, m.pointShadowMap.value = ba.pointShadowMap, m.pointShadowMatrix.value = ba.pointShadowMatrix);
                    k = h.program.getUniforms();
                    m = $a.seqWithValue(k.seq, m);
                    h.uniformsList = m
                }
                c.needsUpdate = !1
            }
            var p = !1, t = n = !1, h = g.program,
                m = h.getUniforms(), k = g.__webglShader.uniforms;
            h.id !== wa && (B.useProgram(h.program), wa = h.id, t = n = p = !0);
            c.id !== R && (R = c.id, n = !0);
            if (p || a !== U) {
                m.set(B, a, "projectionMatrix");
                la.logarithmicDepthBuffer && m.setValue(B, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
                a !== U && (U = a, t = n = !0);
                if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) p = m.map.cameraPosition, void 0 !== p && p.setValue(B, Ga.setFromMatrixPosition(a.matrixWorld));
                (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial ||
                c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && m.setValue(B, "viewMatrix", a.matrixWorldInverse);
                m.set(B, P, "toneMappingExposure");
                m.set(B, P, "toneMappingWhitePoint")
            }
            c.skinning && (m.setOptional(B, d, "bindMatrix"), m.setOptional(B, d, "bindMatrixInverse"), a = d.skeleton) && (la.floatVertexTextures && a.useVertexTexture ? (m.set(B, a, "boneTexture"), m.set(B, a, "boneTextureWidth"), m.set(B, a, "boneTextureHeight")) : m.setOptional(B, a, "boneMatrices"));
            if (n) {
                c.lights && (a = t, k.ambientLightColor.needsUpdate = a, k.directionalLights.needsUpdate =
                    a, k.pointLights.needsUpdate = a, k.spotLights.needsUpdate = a, k.rectAreaLights.needsUpdate = a, k.hemisphereLights.needsUpdate = a);
                b && c.fog && (k.fogColor.value = b.color, b.isFog ? (k.fogNear.value = b.near, k.fogFar.value = b.far) : b.isFogExp2 && (k.fogDensity.value = b.density));
                if (c.isMeshBasicMaterial || c.isMeshLambertMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.isMeshNormalMaterial || c.isMeshDepthMaterial) {
                    k.opacity.value = c.opacity;
                    k.diffuse.value = c.color;
                    c.emissive && k.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity);
                    k.map.value = c.map;
                    k.specularMap.value = c.specularMap;
                    k.alphaMap.value = c.alphaMap;
                    c.lightMap && (k.lightMap.value = c.lightMap, k.lightMapIntensity.value = c.lightMapIntensity);
                    c.aoMap && (k.aoMap.value = c.aoMap, k.aoMapIntensity.value = c.aoMapIntensity);
                    var l;
                    c.map ? l = c.map : c.specularMap ? l = c.specularMap : c.displacementMap ? l = c.displacementMap : c.normalMap ? l = c.normalMap : c.bumpMap ? l = c.bumpMap : c.roughnessMap ? l = c.roughnessMap : c.metalnessMap ? l = c.metalnessMap : c.alphaMap ? l = c.alphaMap : c.emissiveMap && (l = c.emissiveMap);
                    void 0 !==
                    l && (l.isWebGLRenderTarget && (l = l.texture), b = l.offset, l = l.repeat, k.offsetRepeat.value.set(b.x, b.y, l.x, l.y));
                    k.envMap.value = c.envMap;
                    k.flipEnvMap.value = c.envMap && c.envMap.isCubeTexture ? -1 : 1;
                    k.reflectivity.value = c.reflectivity;
                    k.refractionRatio.value = c.refractionRatio
                }
                c.isLineBasicMaterial ? (k.diffuse.value = c.color, k.opacity.value = c.opacity) : c.isLineDashedMaterial ? (k.diffuse.value = c.color, k.opacity.value = c.opacity, k.dashSize.value = c.dashSize, k.totalSize.value = c.dashSize + c.gapSize, k.scale.value = c.scale) :
                    c.isPointsMaterial ? (k.diffuse.value = c.color, k.opacity.value = c.opacity, k.size.value = c.size * Ra, k.scale.value = .5 * Cc, k.map.value = c.map, null !== c.map && (l = c.map.offset, c = c.map.repeat, k.offsetRepeat.value.set(l.x, l.y, c.x, c.y))) : c.isMeshLambertMaterial ? c.emissiveMap && (k.emissiveMap.value = c.emissiveMap) : c.isMeshToonMaterial ? (r(k, c), c.gradientMap && (k.gradientMap.value = c.gradientMap)) : c.isMeshPhongMaterial ? r(k, c) : c.isMeshPhysicalMaterial ? (k.clearCoat.value = c.clearCoat, k.clearCoatRoughness.value = c.clearCoatRoughness,
                        A(k, c)) : c.isMeshStandardMaterial ? A(k, c) : c.isMeshDepthMaterial ? c.displacementMap && (k.displacementMap.value = c.displacementMap, k.displacementScale.value = c.displacementScale, k.displacementBias.value = c.displacementBias) : c.isMeshNormalMaterial && (c.bumpMap && (k.bumpMap.value = c.bumpMap, k.bumpScale.value = c.bumpScale), c.normalMap && (k.normalMap.value = c.normalMap, k.normalScale.value.copy(c.normalScale)), c.displacementMap && (k.displacementMap.value = c.displacementMap, k.displacementScale.value = c.displacementScale,
                            k.displacementBias.value = c.displacementBias));
                void 0 !== k.ltcMat && (k.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE);
                void 0 !== k.ltcMag && (k.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE);
                $a.upload(B, g.uniformsList, k, P)
            }
            m.set(B, d, "modelViewMatrix");
            m.set(B, d, "normalMatrix");
            m.setValue(B, "modelMatrix", d.matrixWorld);
            return h
        }

        function r(a, b) {
            a.specular.value = b.specular;
            a.shininess.value = Math.max(b.shininess, 1E-4);
            b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
            b.bumpMap && (a.bumpMap.value = b.bumpMap,
                a.bumpScale.value = b.bumpScale);
            b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale));
            b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias)
        }

        function A(a, b) {
            a.roughness.value = b.roughness;
            a.metalness.value = b.metalness;
            b.roughnessMap && (a.roughnessMap.value = b.roughnessMap);
            b.metalnessMap && (a.metalnessMap.value = b.metalnessMap);
            b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
            b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale);
            b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale));
            b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);
            b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
        }

        function w(a) {
            var b;
            if (1E3 === a)return B.REPEAT;
            if (1001 === a)return B.CLAMP_TO_EDGE;
            if (1002 === a)return B.MIRRORED_REPEAT;
            if (1003 === a)return B.NEAREST;
            if (1004 === a)return B.NEAREST_MIPMAP_NEAREST;
            if (1005 === a)return B.NEAREST_MIPMAP_LINEAR;
            if (1006 === a)return B.LINEAR;
            if (1007 === a)return B.LINEAR_MIPMAP_NEAREST;
            if (1008 === a)return B.LINEAR_MIPMAP_LINEAR;
            if (1009 === a)return B.UNSIGNED_BYTE;
            if (1017 === a)return B.UNSIGNED_SHORT_4_4_4_4;
            if (1018 === a)return B.UNSIGNED_SHORT_5_5_5_1;
            if (1019 === a)return B.UNSIGNED_SHORT_5_6_5;
            if (1010 === a)return B.BYTE;
            if (1011 === a)return B.SHORT;
            if (1012 === a)return B.UNSIGNED_SHORT;
            if (1013 === a)return B.INT;
            if (1014 === a)return B.UNSIGNED_INT;
            if (1015 === a)return B.FLOAT;
            if (1016 === a && (b = ja.get("OES_texture_half_float"), null !== b))return b.HALF_FLOAT_OES;
            if (1021 === a)return B.ALPHA;
            if (1022 === a)return B.RGB;
            if (1023 === a)return B.RGBA;
            if (1024 === a)return B.LUMINANCE;
            if (1025 === a)return B.LUMINANCE_ALPHA;
            if (1026 === a)return B.DEPTH_COMPONENT;
            if (1027 === a)return B.DEPTH_STENCIL;
            if (100 === a)return B.FUNC_ADD;
            if (101 === a)return B.FUNC_SUBTRACT;
            if (102 === a)return B.FUNC_REVERSE_SUBTRACT;
            if (200 === a)return B.ZERO;
            if (201 === a)return B.ONE;
            if (202 === a)return B.SRC_COLOR;
            if (203 === a)return B.ONE_MINUS_SRC_COLOR;
            if (204 === a)return B.SRC_ALPHA;
            if (205 === a)return B.ONE_MINUS_SRC_ALPHA;
            if (206 === a)return B.DST_ALPHA;
            if (207 === a)return B.ONE_MINUS_DST_ALPHA;
            if (208 === a)return B.DST_COLOR;
            if (209 === a)return B.ONE_MINUS_DST_COLOR;
            if (210 === a)return B.SRC_ALPHA_SATURATE;
            if (2001 === a || 2002 === a || 2003 === a || 2004 === a)if (b = ja.get("WEBGL_compressed_texture_s3tc"), null !== b) {
                if (2001 === a)return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (2002 === a)return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (2003 === a)return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (2004 === a)return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if (2100 === a || 2101 === a || 2102 === a || 2103 === a)if (b = ja.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
                if (2100 === a)return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (2101 === a)return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (2102 === a)return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (2103 === a)return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (2151 === a && (b = ja.get("WEBGL_compressed_texture_etc1"), null !== b))return b.COMPRESSED_RGB_ETC1_WEBGL;
            if (103 === a || 104 === a)if (b = ja.get("EXT_blend_minmax"),
                null !== b) {
                if (103 === a)return b.MIN_EXT;
                if (104 === a)return b.MAX_EXT
            }
            return 1020 === a && (b = ja.get("WEBGL_depth_texture"), null !== b) ? b.UNSIGNED_INT_24_8_WEBGL : 0
        }

        console.log("THREE.WebGLRenderer", "84");
        a = a || {};
        var y = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            K = void 0 !== a.context ? a.context : null, v = void 0 !== a.alpha ? a.alpha : !1,
            E = void 0 !== a.depth ? a.depth : !0, L = void 0 !== a.stencil ? a.stencil : !0,
            C = void 0 !== a.antialias ? a.antialias : !1, F = void 0 !== a.premultipliedAlpha ?
                a.premultipliedAlpha : !0, x = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, H = [],
            aa = [], D = -1, z = [], T = -1, Q = new Float32Array(8), M = [], O = [];
        this.domElement = y;
        this.context = null;
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
        this.clippingPlanes = [];
        this.localClippingEnabled = !1;
        this.gammaFactor = 2;
        this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
        this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
        this.maxMorphTargets =
            8;
        this.maxMorphNormals = 4;
        var P = this, wa = null, W = null, N = null, R = -1, V = "", U = null, X = new fa, Sa = null, Z = new fa,
            ea = 0, Ea = new J(0), gb = 0, md = y.width, Cc = y.height, Ra = 1, ga = new fa(0, 0, md, Cc), ka = !1,
            ia = new fa(0, 0, md, Cc), ma = new tc, ca = new Uf, oa = !1, ra = !1, na = new Na, ua = new S, Ga = new q,
            Ba = new S, xa = new S, ba = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                shadows: []
            }, pa = {
                calls: 0,
                vertices: 0, faces: 0, points: 0
            };
        this.info = {render: pa, memory: {geometries: 0, textures: 0}, programs: null};
        var B;
        try {
            v = {alpha: v, depth: E, stencil: L, antialias: C, premultipliedAlpha: F, preserveDrawingBuffer: x};
            B = K || y.getContext("webgl", v) || y.getContext("experimental-webgl", v);
            if (null === B) {
                if (null !== y.getContext("webgl"))throw"Error creating WebGL context with your selected attributes.";
                throw"Error creating WebGL context.";
            }
            void 0 === B.getShaderPrecisionFormat && (B.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1, precision: 1
                }
            });
            y.addEventListener("webglcontextlost", d, !1)
        } catch (Vf) {
            console.error("THREE.WebGLRenderer: " + Vf)
        }
        var ja = new Tf(B);
        ja.get("WEBGL_depth_texture");
        ja.get("OES_texture_float");
        ja.get("OES_texture_float_linear");
        ja.get("OES_texture_half_float");
        ja.get("OES_texture_half_float_linear");
        ja.get("OES_standard_derivatives");
        ja.get("ANGLE_instanced_arrays");
        ja.get("OES_element_index_uint") && (I.MaxIndex = 4294967296);
        var la = new Sf(B, ja, a), Y = new Rf(B, ja, w), ha = new Qf, ta = new Pf(B, ja, Y, ha, la,
            w, this.info), qa = new Of(B, ha, this.info), ya = new Mf(this, la), za = new Ef;
        this.info.programs = ya.programs;
        var La = new Df(B, ja, pa), Oa = new Cf(B, ja, pa), Ia, Ca, sa, va;
        b();
        this.context = B;
        this.capabilities = la;
        this.extensions = ja;
        this.properties = ha;
        this.state = Y;
        var Ma = new Ke(this, ba, qa, la);
        this.shadowMap = Ma;
        var Pa = new zf(this, M), Qa = new yf(this, O);
        this.getContext = function () {
            return B
        };
        this.getContextAttributes = function () {
            return B.getContextAttributes()
        };
        this.forceContextLoss = function () {
            ja.get("WEBGL_lose_context").loseContext()
        };
        this.getMaxAnisotropy = function () {
            return la.getMaxAnisotropy()
        };
        this.getPrecision = function () {
            return la.precision
        };
        this.getPixelRatio = function () {
            return Ra
        };
        this.setPixelRatio = function (a) {
            void 0 !== a && (Ra = a, this.setSize(ia.z, ia.w, !1))
        };
        this.getSize = function () {
            return {width: md, height: Cc}
        };
        this.setSize = function (a, b, c) {
            md = a;
            Cc = b;
            y.width = a * Ra;
            y.height = b * Ra;
            !1 !== c && (y.style.width = a + "px", y.style.height = b + "px");
            this.setViewport(0, 0, a, b)
        };
        this.setViewport = function (a, b, c, d) {
            Y.viewport(ia.set(a, b, c, d))
        };
        this.setScissor =
            function (a, b, c, d) {
                Y.scissor(ga.set(a, b, c, d))
            };
        this.setScissorTest = function (a) {
            Y.setScissorTest(ka = a)
        };
        this.getClearColor = function () {
            return Ea
        };
        this.setClearColor = function (a, b) {
            Ea.set(a);
            gb = void 0 !== b ? b : 1;
            Y.buffers.color.setClear(Ea.r, Ea.g, Ea.b, gb, F)
        };
        this.getClearAlpha = function () {
            return gb
        };
        this.setClearAlpha = function (a) {
            gb = a;
            Y.buffers.color.setClear(Ea.r, Ea.g, Ea.b, gb, F)
        };
        this.clear = function (a, b, c) {
            var d = 0;
            if (void 0 === a || a) d |= B.COLOR_BUFFER_BIT;
            if (void 0 === b || b) d |= B.DEPTH_BUFFER_BIT;
            if (void 0 === c ||
                c) d |= B.STENCIL_BUFFER_BIT;
            B.clear(d)
        };
        this.clearColor = function () {
            this.clear(!0, !1, !1)
        };
        this.clearDepth = function () {
            this.clear(!1, !0, !1)
        };
        this.clearStencil = function () {
            this.clear(!1, !1, !0)
        };
        this.clearTarget = function (a, b, c, d) {
            this.setRenderTarget(a);
            this.clear(b, c, d)
        };
        this.resetGLState = c;
        this.dispose = function () {
            z = [];
            T = -1;
            aa = [];
            D = -1;
            y.removeEventListener("webglcontextlost", d, !1)
        };
        this.renderBufferImmediate = function (a, b, c) {
            Y.initAttributes();
            var d = ha.get(a);
            a.hasPositions && !d.position && (d.position = B.createBuffer());
            a.hasNormals && !d.normal && (d.normal = B.createBuffer());
            a.hasUvs && !d.uv && (d.uv = B.createBuffer());
            a.hasColors && !d.color && (d.color = B.createBuffer());
            b = b.getAttributes();
            a.hasPositions && (B.bindBuffer(B.ARRAY_BUFFER, d.position), B.bufferData(B.ARRAY_BUFFER, a.positionArray, B.DYNAMIC_DRAW), Y.enableAttribute(b.position), B.vertexAttribPointer(b.position, 3, B.FLOAT, !1, 0, 0));
            if (a.hasNormals) {
                B.bindBuffer(B.ARRAY_BUFFER, d.normal);
                if (!c.isMeshPhongMaterial && !c.isMeshStandardMaterial && !c.isMeshNormalMaterial && 1 ===
                    c.shading)for (var e = 0, f = 3 * a.count; e < f; e += 9) {
                    var g = a.normalArray, h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3,
                        m = (g[e + 1] + g[e + 4] + g[e + 7]) / 3, k = (g[e + 2] + g[e + 5] + g[e + 8]) / 3;
                    g[e + 0] = h;
                    g[e + 1] = m;
                    g[e + 2] = k;
                    g[e + 3] = h;
                    g[e + 4] = m;
                    g[e + 5] = k;
                    g[e + 6] = h;
                    g[e + 7] = m;
                    g[e + 8] = k
                }
                B.bufferData(B.ARRAY_BUFFER, a.normalArray, B.DYNAMIC_DRAW);
                Y.enableAttribute(b.normal);
                B.vertexAttribPointer(b.normal, 3, B.FLOAT, !1, 0, 0)
            }
            a.hasUvs && c.map && (B.bindBuffer(B.ARRAY_BUFFER, d.uv), B.bufferData(B.ARRAY_BUFFER, a.uvArray, B.DYNAMIC_DRAW), Y.enableAttribute(b.uv), B.vertexAttribPointer(b.uv,
                2, B.FLOAT, !1, 0, 0));
            a.hasColors && 0 !== c.vertexColors && (B.bindBuffer(B.ARRAY_BUFFER, d.color), B.bufferData(B.ARRAY_BUFFER, a.colorArray, B.DYNAMIC_DRAW), Y.enableAttribute(b.color), B.vertexAttribPointer(b.color, 3, B.FLOAT, !1, 0, 0));
            Y.disableUnusedAttributes();
            B.drawArrays(B.TRIANGLES, 0, a.count);
            a.count = 0
        };
        this.renderBufferDirect = function (a, b, c, d, e, f) {
            l(d);
            var h = G(a, b, d, e), m = !1;
            a = c.id + "_" + h.id + "_" + d.wireframe;
            a !== V && (V = a, m = !0);
            b = e.morphTargetInfluences;
            if (void 0 !== b) {
                var k = [];
                a = 0;
                for (var n = b.length; a < n; a++)m =
                    b[a], k.push([m, a]);
                k.sort(g);
                8 < k.length && (k.length = 8);
                var t = c.morphAttributes;
                a = 0;
                for (n = k.length; a < n; a++)m = k[a], Q[a] = m[0], 0 !== m[0] ? (b = m[1], !0 === d.morphTargets && t.position && c.addAttribute("morphTarget" + a, t.position[b]), !0 === d.morphNormals && t.normal && c.addAttribute("morphNormal" + a, t.normal[b])) : (!0 === d.morphTargets && c.removeAttribute("morphTarget" + a), !0 === d.morphNormals && c.removeAttribute("morphNormal" + a));
                a = k.length;
                for (b = Q.length; a < b; a++)Q[a] = 0;
                h.getUniforms().setValue(B, "morphTargetInfluences", Q);
                m = !0
            }
            b = c.index;
            n = c.attributes.position;
            k = 1;
            !0 === d.wireframe && (b = qa.getWireframeAttribute(c), k = 2);
            null !== b ? (a = Oa, a.setIndex(b)) : a = La;
            if (m) {
                a:{
                    var m = void 0, p;
                    if (c && c.isInstancedBufferGeometry && (p = ja.get("ANGLE_instanced_arrays"), null === p)) {
                        console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        break a
                    }
                    void 0 === m && (m = 0);
                    Y.initAttributes();
                    var t = c.attributes, h = h.getAttributes(), r = d.defaultAttributeValues,
                        q;
                    for (q in h) {
                        var y = h[q];
                        if (0 <= y) {
                            var v = t[q];
                            if (void 0 !== v) {
                                var w = v.normalized, A = v.itemSize, K = qa.getAttributeProperties(v),
                                    C = K.__webglBuffer, L = K.type, K = K.bytesPerElement;
                                if (v.isInterleavedBufferAttribute) {
                                    var F = v.data, E = F.stride, v = v.offset;
                                    F && F.isInstancedInterleavedBuffer ? (Y.enableAttributeAndDivisor(y, F.meshPerAttribute, p), void 0 === c.maxInstancedCount && (c.maxInstancedCount = F.meshPerAttribute * F.count)) : Y.enableAttribute(y);
                                    B.bindBuffer(B.ARRAY_BUFFER, C);
                                    B.vertexAttribPointer(y, A, L, w, E * K, (m * E + v) *
                                        K)
                                } else v.isInstancedBufferAttribute ? (Y.enableAttributeAndDivisor(y, v.meshPerAttribute, p), void 0 === c.maxInstancedCount && (c.maxInstancedCount = v.meshPerAttribute * v.count)) : Y.enableAttribute(y), B.bindBuffer(B.ARRAY_BUFFER, C), B.vertexAttribPointer(y, A, L, w, 0, m * A * K)
                            } else if (void 0 !== r && (w = r[q], void 0 !== w))switch (w.length) {
                                case 2:
                                    B.vertexAttrib2fv(y, w);
                                    break;
                                case 3:
                                    B.vertexAttrib3fv(y, w);
                                    break;
                                case 4:
                                    B.vertexAttrib4fv(y, w);
                                    break;
                                default:
                                    B.vertexAttrib1fv(y, w)
                            }
                        }
                    }
                    Y.disableUnusedAttributes()
                }
                null !== b && B.bindBuffer(B.ELEMENT_ARRAY_BUFFER,
                    qa.getAttributeBuffer(b))
            }
            p = 0;
            null !== b ? p = b.count : void 0 !== n && (p = n.count);
            b = c.drawRange.start * k;
            n = null !== f ? f.start * k : 0;
            q = Math.max(b, n);
            f = Math.max(0, Math.min(p, b + c.drawRange.count * k, n + (null !== f ? f.count * k : Infinity)) - 1 - q + 1);
            if (0 !== f) {
                if (e.isMesh)if (!0 === d.wireframe) Y.setLineWidth(d.wireframeLinewidth * (null === W ? Ra : 1)), a.setMode(B.LINES); else switch (e.drawMode) {
                    case 0:
                        a.setMode(B.TRIANGLES);
                        break;
                    case 1:
                        a.setMode(B.TRIANGLE_STRIP);
                        break;
                    case 2:
                        a.setMode(B.TRIANGLE_FAN)
                } else e.isLine ? (d = d.linewidth, void 0 ===
                d && (d = 1), Y.setLineWidth(d * (null === W ? Ra : 1)), e.isLineSegments ? a.setMode(B.LINES) : a.setMode(B.LINE_STRIP)) : e.isPoints && a.setMode(B.POINTS);
                c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, q, f) : a.render(q, f)
            }
        };
        this.render = function (a, b, c, d) {
            if (void 0 !== b && !0 !== b.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else {
                V = "";
                R = -1;
                U = null;
                !0 === a.autoUpdate && a.updateMatrixWorld();
                null === b.parent && b.updateMatrixWorld();
                b.matrixWorldInverse.getInverse(b.matrixWorld);
                ua.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
                ma.setFromMatrix(ua);
                H.length = 0;
                T = D = -1;
                M.length = 0;
                O.length = 0;
                ra = this.localClippingEnabled;
                oa = ca.init(this.clippingPlanes, ra, b);
                p(a, b);
                aa.length = D + 1;
                z.length = T + 1;
                !0 === P.sortObjects && (aa.sort(h), z.sort(m));
                oa && ca.beginShadows();
                for (var e = H, f = 0, g = 0, k = e.length; g < k; g++) {
                    var t = e[g];
                    t.castShadow && (ba.shadows[f++] = t)
                }
                ba.shadows.length = f;
                Ma.render(a, b);
                for (var e = H, l = t = 0, u = 0, r, G, q, y, v = b.matrixWorldInverse, w = 0, A = 0, K = 0, C = 0,
                         L = 0, f = 0, g = e.length; f < g; f++)if (k =
                        e[f], r = k.color, G = k.intensity, q = k.distance, y = k.shadow && k.shadow.map ? k.shadow.map.texture : null, k.isAmbientLight) t += r.r * G, l += r.g * G, u += r.b * G; else if (k.isDirectionalLight) {
                    var E = za.get(k);
                    E.color.copy(k.color).multiplyScalar(k.intensity);
                    E.direction.setFromMatrixPosition(k.matrixWorld);
                    Ga.setFromMatrixPosition(k.target.matrixWorld);
                    E.direction.sub(Ga);
                    E.direction.transformDirection(v);
                    if (E.shadow = k.castShadow) E.shadowBias = k.shadow.bias, E.shadowRadius = k.shadow.radius, E.shadowMapSize = k.shadow.mapSize;
                    ba.directionalShadowMap[w] =
                        y;
                    ba.directionalShadowMatrix[w] = k.shadow.matrix;
                    ba.directional[w++] = E
                } else if (k.isSpotLight) {
                    E = za.get(k);
                    E.position.setFromMatrixPosition(k.matrixWorld);
                    E.position.applyMatrix4(v);
                    E.color.copy(r).multiplyScalar(G);
                    E.distance = q;
                    E.direction.setFromMatrixPosition(k.matrixWorld);
                    Ga.setFromMatrixPosition(k.target.matrixWorld);
                    E.direction.sub(Ga);
                    E.direction.transformDirection(v);
                    E.coneCos = Math.cos(k.angle);
                    E.penumbraCos = Math.cos(k.angle * (1 - k.penumbra));
                    E.decay = 0 === k.distance ? 0 : k.decay;
                    if (E.shadow = k.castShadow) E.shadowBias =
                        k.shadow.bias, E.shadowRadius = k.shadow.radius, E.shadowMapSize = k.shadow.mapSize;
                    ba.spotShadowMap[K] = y;
                    ba.spotShadowMatrix[K] = k.shadow.matrix;
                    ba.spot[K++] = E
                } else if (k.isRectAreaLight) E = za.get(k), E.color.copy(r).multiplyScalar(G / (k.width * k.height)), E.position.setFromMatrixPosition(k.matrixWorld), E.position.applyMatrix4(v), xa.identity(), Ba.copy(k.matrixWorld), Ba.premultiply(v), xa.extractRotation(Ba), E.halfWidth.set(.5 * k.width, 0, 0), E.halfHeight.set(0, .5 * k.height, 0), E.halfWidth.applyMatrix4(xa), E.halfHeight.applyMatrix4(xa),
                    ba.rectArea[C++] = E; else if (k.isPointLight) {
                    E = za.get(k);
                    E.position.setFromMatrixPosition(k.matrixWorld);
                    E.position.applyMatrix4(v);
                    E.color.copy(k.color).multiplyScalar(k.intensity);
                    E.distance = k.distance;
                    E.decay = 0 === k.distance ? 0 : k.decay;
                    if (E.shadow = k.castShadow) E.shadowBias = k.shadow.bias, E.shadowRadius = k.shadow.radius, E.shadowMapSize = k.shadow.mapSize;
                    ba.pointShadowMap[A] = y;
                    void 0 === ba.pointShadowMatrix[A] && (ba.pointShadowMatrix[A] = new S);
                    Ga.setFromMatrixPosition(k.matrixWorld).negate();
                    ba.pointShadowMatrix[A].identity().setPosition(Ga);
                    ba.point[A++] = E
                } else k.isHemisphereLight && (E = za.get(k), E.direction.setFromMatrixPosition(k.matrixWorld), E.direction.transformDirection(v), E.direction.normalize(), E.skyColor.copy(k.color).multiplyScalar(G), E.groundColor.copy(k.groundColor).multiplyScalar(G), ba.hemi[L++] = E);
                ba.ambient[0] = t;
                ba.ambient[1] = l;
                ba.ambient[2] = u;
                ba.directional.length = w;
                ba.spot.length = K;
                ba.rectArea.length = C;
                ba.point.length = A;
                ba.hemi.length = L;
                ba.hash = w + "," + A + "," + K + "," + C + "," + L + "," + ba.shadows.length;
                oa && ca.endShadows();
                pa.calls =
                    0;
                pa.vertices = 0;
                pa.faces = 0;
                pa.points = 0;
                void 0 === c && (c = null);
                this.setRenderTarget(c);
                e = a.background;
                null === e ? Y.buffers.color.setClear(Ea.r, Ea.g, Ea.b, gb, F) : e && e.isColor && (Y.buffers.color.setClear(e.r, e.g, e.b, 1, F), d = !0);
                (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
                e && e.isCubeTexture ? (void 0 === sa && (sa = new Fa, va = new Aa(new kb(5, 5, 5), new Ha({
                    uniforms: bb.cube.uniforms,
                    vertexShader: bb.cube.vertexShader,
                    fragmentShader: bb.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))), sa.projectionMatrix.copy(b.projectionMatrix), sa.matrixWorld.extractRotation(b.matrixWorld), sa.matrixWorldInverse.getInverse(sa.matrixWorld), va.material.uniforms.tCube.value = e, va.modelViewMatrix.multiplyMatrices(sa.matrixWorldInverse, va.matrixWorld), qa.update(va), P.renderBufferDirect(sa, null, va.geometry, va.material, va, null)) : e && e.isTexture && (void 0 === Ia && (Ia = new Jb(-1, 1, 1, -1, 0, 1), Ca = new Aa(new lb(2, 2), new Ka({
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))), Ca.material.map = e, qa.update(Ca),
                        P.renderBufferDirect(Ia, null, Ca.geometry, Ca.material, Ca, null));
                a.overrideMaterial ? (d = a.overrideMaterial, n(aa, a, b, d), n(z, a, b, d)) : (Y.setBlending(0), n(aa, a, b), n(z, a, b));
                Pa.render(a, b);
                Qa.render(a, b, Z);
                c && ta.updateRenderTargetMipmap(c);
                Y.setDepthTest(!0);
                Y.setDepthWrite(!0);
                Y.setColorWrite(!0)
            }
        };
        this.setFaceCulling = function (a, b) {
            Y.setCullFace(a);
            Y.setFlipSided(0 === b)
        };
        this.allocTextureUnit = function () {
            var a = ea;
            a >= la.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " +
                la.maxTextures);
            ea += 1;
            return a
        };
        this.setTexture2D = function () {
            var a = !1;
            return function (b, c) {
                b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
                ta.setTexture2D(b, c)
            }
        }();
        this.setTexture = function () {
            var a = !1;
            return function (b, c) {
                a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0);
                ta.setTexture2D(b, c)
            }
        }();
        this.setTextureCube = function () {
            var a =
                !1;
            return function (b, c) {
                b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
                b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? ta.setTextureCube(b, c) : ta.setTextureCubeDynamic(b, c)
            }
        }();
        this.getCurrentRenderTarget = function () {
            return W
        };
        this.setRenderTarget = function (a) {
            (W = a) && void 0 === ha.get(a).__webglFramebuffer && ta.setupRenderTarget(a);
            var b = a && a.isWebGLRenderTargetCube,
                c;
            a ? (c = ha.get(a), c = b ? c.__webglFramebuffer[a.activeCubeFace] : c.__webglFramebuffer, X.copy(a.scissor), Sa = a.scissorTest, Z.copy(a.viewport)) : (c = null, X.copy(ga).multiplyScalar(Ra), Sa = ka, Z.copy(ia).multiplyScalar(Ra));
            N !== c && (B.bindFramebuffer(B.FRAMEBUFFER, c), N = c);
            Y.scissor(X);
            Y.setScissorTest(Sa);
            Y.viewport(Z);
            b && (b = ha.get(a.texture), B.framebufferTexture2D(B.FRAMEBUFFER, B.COLOR_ATTACHMENT0, B.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, b.__webglTexture, a.activeMipMapLevel))
        };
        this.readRenderTargetPixels =
            function (a, b, c, d, e, f) {
                if (!1 === (a && a.isWebGLRenderTarget)) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); else {
                    var g = ha.get(a).__webglFramebuffer;
                    if (g) {
                        var h = !1;
                        g !== N && (B.bindFramebuffer(B.FRAMEBUFFER, g), h = !0);
                        try {
                            var k = a.texture, m = k.format, n = k.type;
                            1023 !== m && w(m) !== B.getParameter(B.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 ===
                            n || w(n) === B.getParameter(B.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === n && (ja.get("OES_texture_float") || ja.get("WEBGL_color_buffer_float")) || 1016 === n && ja.get("EXT_color_buffer_half_float") ? B.checkFramebufferStatus(B.FRAMEBUFFER) === B.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && B.readPixels(b, c, d, e, w(m), w(n), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                        } finally {
                            h &&
                            B.bindFramebuffer(B.FRAMEBUFFER, N)
                        }
                    }
                }
            }
    }

    function Kb(a, b) {
        this.name = "";
        this.color = new J(a);
        this.density = void 0 !== b ? b : 2.5E-4
    }

    function Lb(a, b, c) {
        this.name = "";
        this.color = new J(a);
        this.near = void 0 !== b ? b : 1;
        this.far = void 0 !== c ? c : 1E3
    }

    function mb() {
        x.call(this);
        this.type = "Scene";
        this.overrideMaterial = this.fog = this.background = null;
        this.autoUpdate = !0
    }

    function Zd(a, b, c, d, e) {
        x.call(this);
        this.lensFlares = [];
        this.positionScreen = new q;
        this.customUpdateCallback = void 0;
        void 0 !== a && this.add(a, b, c, d, e)
    }

    function nb(a) {
        X.call(this);
        this.type = "SpriteMaterial";
        this.color = new J(16777215);
        this.map = null;
        this.rotation = 0;
        this.lights = this.fog = !1;
        this.setValues(a)
    }

    function Dc(a) {
        x.call(this);
        this.type = "Sprite";
        this.material = void 0 !== a ? a : new nb
    }

    function Ec() {
        x.call(this);
        this.type = "LOD";
        Object.defineProperties(this, {levels: {enumerable: !0, value: []}})
    }

    function od(a, b, c) {
        this.useVertexTexture = void 0 !== c ? c : !0;
        this.identityMatrix = new S;
        a = a || [];
        this.bones = a.slice(0);
        this.useVertexTexture ? (a = Math.sqrt(4 * this.bones.length), a = N.nextPowerOfTwo(Math.ceil(a)),
            this.boneTextureHeight = this.boneTextureWidth = a = Math.max(a, 4), this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new eb(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, 1023, 1015)) : this.boneMatrices = new Float32Array(16 * this.bones.length);
        if (void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], b =
            0, a = this.bones.length; b < a; b++)this.boneInverses.push(new S)
    }

    function pd() {
        x.call(this);
        this.type = "Bone"
    }

    function qd(a, b, c) {
        Aa.call(this, a, b);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new S;
        this.bindMatrixInverse = new S;
        a = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
            for (var d, e = 0,
                     f = this.geometry.bones.length; e < f; ++e)d = this.geometry.bones[e], b = new pd, a.push(b), b.name = d.name, b.position.fromArray(d.pos), b.quaternion.fromArray(d.rotq), void 0 !== d.scl && b.scale.fromArray(d.scl);
            e = 0;
            for (f = this.geometry.bones.length; e < f; ++e)d = this.geometry.bones[e], -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[e]) : this.add(a[e])
        }
        this.normalizeSkinWeights();
        this.updateMatrixWorld(!0);
        this.bind(new od(a, void 0, c), this.matrixWorld)
    }

    function ia(a) {
        X.call(this);
        this.type = "LineBasicMaterial";
        this.color = new J(16777215);
        this.linewidth = 1;
        this.linejoin = this.linecap = "round";
        this.lights = !1;
        this.setValues(a)
    }

    function Ua(a, b, c) {
        if (1 === c)return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
            new ga(a, b);
        x.call(this);
        this.type = "Line";
        this.geometry = void 0 !== a ? a : new I;
        this.material = void 0 !== b ? b : new ia({color: 16777215 * Math.random()})
    }

    function ga(a, b) {
        Ua.call(this, a, b);
        this.type = "LineSegments"
    }

    function Oa(a) {
        X.call(this);
        this.type = "PointsMaterial";
        this.color = new J(16777215);
        this.map = null;
        this.size = 1;
        this.sizeAttenuation = !0;
        this.lights = !1;
        this.setValues(a)
    }

    function Mb(a, b) {
        x.call(this);
        this.type = "Points";
        this.geometry = void 0 !== a ? a : new I;
        this.material = void 0 !== b ? b : new Oa({color: 16777215 * Math.random()})
    }

    function Fc() {
        x.call(this);
        this.type = "Group"
    }

    function rd(a, b, c, d, e, f, g, h, m) {
        function k() {
            requestAnimationFrame(k);
            a.readyState >= a.HAVE_CURRENT_DATA && (t.needsUpdate = !0)
        }

        ea.call(this, a, b, c, d, e, f, g, h, m);
        this.generateMipmaps = !1;
        var t = this;
        k()
    }

    function Nb(a, b, c, d, e, f, g, h, m, k, t, p) {
        ea.call(this, null, f, g, h, m, k, d, e, t, p);
        this.image = {width: b, height: c};
        this.mipmaps = a;
        this.generateMipmaps = this.flipY = !1
    }

    function sd(a, b, c, d, e, f, g, h, m) {
        ea.call(this, a, b, c, d, e, f, g, h, m);
        this.needsUpdate = !0
    }

    function Gc(a, b, c, d, e, f, g,
                h, m, k) {
        k = void 0 !== k ? k : 1026;
        if (1026 !== k && 1027 !== k)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === c && 1026 === k && (c = 1012);
        void 0 === c && 1027 === k && (c = 1020);
        ea.call(this, null, d, e, f, g, h, k, c, m);
        this.image = {width: a, height: b};
        this.magFilter = void 0 !== g ? g : 1003;
        this.minFilter = void 0 !== h ? h : 1003;
        this.generateMipmaps = this.flipY = !1
    }

    function Ob(a) {
        function b(a, b) {
            return a - b
        }

        I.call(this);
        this.type = "WireframeGeometry";
        var c = [], d, e, f, g, h = [0, 0], m = {}, k, t = ["a", "b",
            "c"];
        if (a && a.isGeometry) {
            var p = a.faces;
            d = 0;
            for (f = p.length; d < f; d++) {
                var n = p[d];
                for (e = 0; 3 > e; e++)h[0] = n[t[e]], h[1] = n[t[(e + 1) % 3]], h.sort(b), k = h.toString(), void 0 === m[k] && (m[k] = {
                    index1: h[0],
                    index2: h[1]
                })
            }
            for (k in m)d = m[k], t = a.vertices[d.index1], c.push(t.x, t.y, t.z), t = a.vertices[d.index2], c.push(t.x, t.y, t.z)
        } else if (a && a.isBufferGeometry) {
            var l, t = new q;
            if (null !== a.index) {
                p = a.attributes.position;
                n = a.index;
                l = a.groups;
                0 === l.length && a.addGroup(0, n.count);
                a = 0;
                for (g = l.length; a < g; ++a)for (d = l[a], e = d.start, f = d.count,
                                                       d = e, f = e + f; d < f; d += 3)for (e = 0; 3 > e; e++)h[0] = n.getX(d + e), h[1] = n.getX(d + (e + 1) % 3), h.sort(b), k = h.toString(), void 0 === m[k] && (m[k] = {
                    index1: h[0],
                    index2: h[1]
                });
                for (k in m)d = m[k], t.fromBufferAttribute(p, d.index1), c.push(t.x, t.y, t.z), t.fromBufferAttribute(p, d.index2), c.push(t.x, t.y, t.z)
            } else for (p = a.attributes.position, d = 0, f = p.count / 3; d < f; d++)for (e = 0; 3 > e; e++)m = 3 * d + e, t.fromBufferAttribute(p, m), c.push(t.x, t.y, t.z), m = 3 * d + (e + 1) % 3, t.fromBufferAttribute(p, m), c.push(t.x, t.y, t.z)
        }
        this.addAttribute("position", new z(c, 3))
    }

    function Hc(a, b, c) {
        T.call(this);
        this.type = "ParametricGeometry";
        this.parameters = {func: a, slices: b, stacks: c};
        this.fromBufferGeometry(new Pb(a, b, c));
        this.mergeVertices()
    }

    function Pb(a, b, c) {
        I.call(this);
        this.type = "ParametricBufferGeometry";
        this.parameters = {func: a, slices: b, stacks: c};
        var d = [], e = [], f = [], g, h, m = b + 1;
        for (g = 0; g <= c; g++) {
            var k = g / c;
            for (h = 0; h <= b; h++) {
                var t = h / b, p = a(t, k);
                e.push(p.x, p.y, p.z);
                f.push(t, k)
            }
        }
        for (g = 0; g < c; g++)for (h = 0; h < b; h++)a = g * m + h + 1, k = (g + 1) * m + h + 1, t = (g + 1) * m + h, d.push(g * m + h, a, t), d.push(a, k,
            t);
        this.setIndex(d);
        this.addAttribute("position", new z(e, 3));
        this.addAttribute("uv", new z(f, 2));
        this.computeVertexNormals()
    }

    function Ic(a, b, c, d) {
        T.call(this);
        this.type = "PolyhedronGeometry";
        this.parameters = {vertices: a, indices: b, radius: c, detail: d};
        this.fromBufferGeometry(new Ba(a, b, c, d));
        this.mergeVertices()
    }

    function Ba(a, b, c, d) {
        function e(a) {
            h.push(a.x, a.y, a.z)
        }

        function f(b, c) {
            var d = 3 * b;
            c.x = a[d + 0];
            c.y = a[d + 1];
            c.z = a[d + 2]
        }

        function g(a, b, c, d) {
            0 > d && 1 === a.x && (m[b] = a.x - 1);
            0 === c.x && 0 === c.z && (m[b] = d / 2 / Math.PI +
                .5)
        }

        I.call(this);
        this.type = "PolyhedronBufferGeometry";
        this.parameters = {vertices: a, indices: b, radius: c, detail: d};
        c = c || 1;
        var h = [], m = [];
        (function (a) {
            for (var c = new q, d = new q, g = new q, h = 0; h < b.length; h += 3) {
                f(b[h + 0], c);
                f(b[h + 1], d);
                f(b[h + 2], g);
                var m = c, l = d, A = g, w = Math.pow(2, a), y = [], K, v;
                for (K = 0; K <= w; K++) {
                    y[K] = [];
                    var E = m.clone().lerp(A, K / w), L = l.clone().lerp(A, K / w), C = w - K;
                    for (v = 0; v <= C; v++)y[K][v] = 0 === v && K === w ? E : E.clone().lerp(L, v / C)
                }
                for (K = 0; K < w; K++)for (v = 0; v < 2 * (w - K) - 1; v++)m = Math.floor(v / 2), 0 === v % 2 ? (e(y[K][m + 1]),
                    e(y[K + 1][m]), e(y[K][m])) : (e(y[K][m + 1]), e(y[K + 1][m + 1]), e(y[K + 1][m]))
            }
        })(d || 0);
        (function (a) {
            for (var b = new q,
                     c = 0; c < h.length; c += 3)b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z
        })(c);
        (function () {
            for (var a = new q,
                     b = 0; b < h.length; b += 3)a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], m.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
            for (var a = new q, b = new q, c = new q, d = new q, e = new D, f = new D, l = new D, A = 0,
                     w = 0; A < h.length; A += 9, w +=
                6) {
                a.set(h[A + 0], h[A + 1], h[A + 2]);
                b.set(h[A + 3], h[A + 4], h[A + 5]);
                c.set(h[A + 6], h[A + 7], h[A + 8]);
                e.set(m[w + 0], m[w + 1]);
                f.set(m[w + 2], m[w + 3]);
                l.set(m[w + 4], m[w + 5]);
                d.copy(a).add(b).add(c).divideScalar(3);
                var y = Math.atan2(d.z, -d.x);
                g(e, w + 0, a, y);
                g(f, w + 2, b, y);
                g(l, w + 4, c, y)
            }
            for (a = 0; a < m.length; a += 6)b = m[a + 0], c = m[a + 2], d = m[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (m[a + 0] += 1), .2 > c && (m[a + 2] += 1), .2 > d && (m[a + 4] += 1))
        })();
        this.addAttribute("position", new z(h, 3));
        this.addAttribute("normal", new z(h.slice(), 3));
        this.addAttribute("uv",
            new z(m, 2));
        this.normalizeNormals()
    }

    function Jc(a, b) {
        T.call(this);
        this.type = "TetrahedronGeometry";
        this.parameters = {radius: a, detail: b};
        this.fromBufferGeometry(new Qb(a, b));
        this.mergeVertices()
    }

    function Qb(a, b) {
        Ba.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
        this.type = "TetrahedronBufferGeometry";
        this.parameters = {radius: a, detail: b}
    }

    function Kc(a, b) {
        T.call(this);
        this.type = "OctahedronGeometry";
        this.parameters = {radius: a, detail: b};
        this.fromBufferGeometry(new ob(a, b));
        this.mergeVertices()
    }

    function ob(a, b) {
        Ba.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
        this.type = "OctahedronBufferGeometry";
        this.parameters = {radius: a, detail: b}
    }

    function Lc(a, b) {
        T.call(this);
        this.type = "IcosahedronGeometry";
        this.parameters = {radius: a, detail: b};
        this.fromBufferGeometry(new Rb(a, b));
        this.mergeVertices()
    }

    function Rb(a, b) {
        var c = (1 + Math.sqrt(5)) / 2;
        Ba.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11,
            5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
        this.type = "IcosahedronBufferGeometry";
        this.parameters = {radius: a, detail: b}
    }

    function Mc(a, b) {
        T.call(this);
        this.type = "DodecahedronGeometry";
        this.parameters = {radius: a, detail: b};
        this.fromBufferGeometry(new Sb(a, b));
        this.mergeVertices()
    }

    function Sb(a, b) {
        var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
        Ba.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0,
            d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b);
        this.type = "DodecahedronBufferGeometry";
        this.parameters = {radius: a, detail: b}
    }

    function Nc(a, b, c, d, e, f) {
        T.call(this);
        this.type = "TubeGeometry";
        this.parameters = {
            path: a,
            tubularSegments: b, radius: c, radialSegments: d, closed: e
        };
        void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed.");
        a = new Tb(a, b, c, d, e);
        this.tangents = a.tangents;
        this.normals = a.normals;
        this.binormals = a.binormals;
        this.fromBufferGeometry(a);
        this.mergeVertices()
    }

    function Tb(a, b, c, d, e) {
        function f(e) {
            var f = a.getPointAt(e / b), k = g.normals[e];
            e = g.binormals[e];
            for (p = 0; p <= d; p++) {
                var t = p / d * Math.PI * 2, r = Math.sin(t), t = -Math.cos(t);
                m.x = t * k.x + r * e.x;
                m.y = t * k.y + r * e.y;
                m.z = t * k.z + r * e.z;
                m.normalize();
                l.push(m.x,
                    m.y, m.z);
                h.x = f.x + c * m.x;
                h.y = f.y + c * m.y;
                h.z = f.z + c * m.z;
                n.push(h.x, h.y, h.z)
            }
        }

        I.call(this);
        this.type = "TubeBufferGeometry";
        this.parameters = {path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e};
        b = b || 64;
        c = c || 1;
        d = d || 8;
        e = e || !1;
        var g = a.computeFrenetFrames(b, e);
        this.tangents = g.tangents;
        this.normals = g.normals;
        this.binormals = g.binormals;
        var h = new q, m = new q, k = new D, t, p, n = [], l = [], G = [], r = [];
        for (t = 0; t < b; t++)f(t);
        f(!1 === e ? b : 0);
        for (t = 0; t <= b; t++)for (p = 0; p <= d; p++)k.x = t / b, k.y = p / d, G.push(k.x, k.y);
        (function () {
            for (p =
                     1; p <= b; p++)for (t = 1; t <= d; t++) {
                var a = (d + 1) * p + (t - 1), c = (d + 1) * p + t, e = (d + 1) * (p - 1) + t;
                r.push((d + 1) * (p - 1) + (t - 1), a, e);
                r.push(a, c, e)
            }
        })();
        this.setIndex(r);
        this.addAttribute("position", new z(n, 3));
        this.addAttribute("normal", new z(l, 3));
        this.addAttribute("uv", new z(G, 2))
    }

    function Oc(a, b, c, d, e, f, g) {
        T.call(this);
        this.type = "TorusKnotGeometry";
        this.parameters = {radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f};
        void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
        this.fromBufferGeometry(new Ub(a, b, c, d, e, f));
        this.mergeVertices()
    }

    function Ub(a, b, c, d, e, f) {
        function g(a, b, c, d, e) {
            var f = Math.sin(a);
            b = c / b * a;
            c = Math.cos(b);
            e.x = d * (2 + c) * .5 * Math.cos(a);
            e.y = d * (2 + c) * f * .5;
            e.z = d * Math.sin(b) * .5
        }

        I.call(this);
        this.type = "TorusKnotBufferGeometry";
        this.parameters = {radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f};
        a = a || 100;
        b = b || 40;
        c = Math.floor(c) || 64;
        d = Math.floor(d) || 8;
        e = e || 2;
        f = f || 3;
        var h = [], m = [], k = [], t = [], p, n, l = new q, G = new q;
        new D;
        var r = new q, A = new q, w = new q, y = new q, K =
            new q;
        for (p = 0; p <= c; ++p)for (n = p / c * e * Math.PI * 2, g(n, e, f, a, r), g(n + .01, e, f, a, A), y.subVectors(A, r), K.addVectors(A, r), w.crossVectors(y, K), K.crossVectors(w, y), w.normalize(), K.normalize(), n = 0; n <= d; ++n) {
            var v = n / d * Math.PI * 2, E = -b * Math.cos(v), v = b * Math.sin(v);
            l.x = r.x + (E * K.x + v * w.x);
            l.y = r.y + (E * K.y + v * w.y);
            l.z = r.z + (E * K.z + v * w.z);
            m.push(l.x, l.y, l.z);
            G.subVectors(l, r).normalize();
            k.push(G.x, G.y, G.z);
            t.push(p / c);
            t.push(n / d)
        }
        for (n = 1; n <= c; n++)for (p = 1; p <= d; p++)a = (d + 1) * n + (p - 1), b = (d + 1) * n + p, e = (d + 1) * (n - 1) + p, h.push((d + 1) * (n - 1) +
            (p - 1), a, e), h.push(a, b, e);
        this.setIndex(h);
        this.addAttribute("position", new z(m, 3));
        this.addAttribute("normal", new z(k, 3));
        this.addAttribute("uv", new z(t, 2))
    }

    function Pc(a, b, c, d, e) {
        T.call(this);
        this.type = "TorusGeometry";
        this.parameters = {radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e};
        this.fromBufferGeometry(new Vb(a, b, c, d, e))
    }

    function Vb(a, b, c, d, e) {
        I.call(this);
        this.type = "TorusBufferGeometry";
        this.parameters = {radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e};
        a = a || 100;
        b = b || 40;
        c = Math.floor(c) ||
            8;
        d = Math.floor(d) || 6;
        e = e || 2 * Math.PI;
        var f = [], g = [], h = [], m = [], k = new q, t = new q, p = new q, n, l;
        for (n = 0; n <= c; n++)for (l = 0; l <= d; l++) {
            var G = l / d * e, r = n / c * Math.PI * 2;
            t.x = (a + b * Math.cos(r)) * Math.cos(G);
            t.y = (a + b * Math.cos(r)) * Math.sin(G);
            t.z = b * Math.sin(r);
            g.push(t.x, t.y, t.z);
            k.x = a * Math.cos(G);
            k.y = a * Math.sin(G);
            p.subVectors(t, k).normalize();
            h.push(p.x, p.y, p.z);
            m.push(l / d);
            m.push(n / c)
        }
        for (n = 1; n <= c; n++)for (l = 1; l <= d; l++)a = (d + 1) * (n - 1) + l - 1, b = (d + 1) * (n - 1) + l, e = (d + 1) * n + l, f.push((d + 1) * n + l - 1, a, e), f.push(a, b, e);
        this.setIndex(f);
        this.addAttribute("position", new z(g, 3));
        this.addAttribute("normal", new z(h, 3));
        this.addAttribute("uv", new z(m, 2))
    }

    function La(a, b) {
        "undefined" !== typeof a && (T.call(this), this.type = "ExtrudeGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeFaceNormals())
    }

    function Qc(a, b) {
        b = b || {};
        var c = b.font;
        if (!1 === (c && c.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new T;
        c = c.generateShapes(a, b.size, b.curveSegments);
        b.amount = void 0 !== b.height ?
            b.height : 50;
        void 0 === b.bevelThickness && (b.bevelThickness = 10);
        void 0 === b.bevelSize && (b.bevelSize = 8);
        void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
        La.call(this, c, b);
        this.type = "TextGeometry"
    }

    function Rc(a, b, c, d, e, f, g) {
        T.call(this);
        this.type = "SphereGeometry";
        this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: g
        };
        this.fromBufferGeometry(new pb(a, b, c, d, e, f, g))
    }

    function pb(a, b, c, d, e, f, g) {
        I.call(this);
        this.type = "SphereBufferGeometry";
        this.parameters = {
            radius: a,
            widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g
        };
        a = a || 50;
        b = Math.max(3, Math.floor(b) || 8);
        c = Math.max(2, Math.floor(c) || 6);
        d = void 0 !== d ? d : 0;
        e = void 0 !== e ? e : 2 * Math.PI;
        f = void 0 !== f ? f : 0;
        g = void 0 !== g ? g : Math.PI;
        var h = f + g, m, k, t = 0, p = [], n = new q, l = new q, G = [], r = [], A = [], w = [];
        for (k = 0; k <= c; k++) {
            var y = [], K = k / c;
            for (m = 0; m <= b; m++) {
                var v = m / b;
                n.x = -a * Math.cos(d + v * e) * Math.sin(f + K * g);
                n.y = a * Math.cos(f + K * g);
                n.z = a * Math.sin(d + v * e) * Math.sin(f + K * g);
                r.push(n.x, n.y, n.z);
                l.set(n.x, n.y, n.z).normalize();
                A.push(l.x, l.y, l.z);
                w.push(v, 1 - K);
                y.push(t++)
            }
            p.push(y)
        }
        for (k = 0; k < c; k++)for (m = 0; m < b; m++)a = p[k][m + 1], d = p[k][m], e = p[k + 1][m], g = p[k + 1][m + 1], (0 !== k || 0 < f) && G.push(a, d, g), (k !== c - 1 || h < Math.PI) && G.push(d, e, g);
        this.setIndex(G);
        this.addAttribute("position", new z(r, 3));
        this.addAttribute("normal", new z(A, 3));
        this.addAttribute("uv", new z(w, 2))
    }

    function Sc(a, b, c, d, e, f) {
        T.call(this);
        this.type = "RingGeometry";
        this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
        };
        this.fromBufferGeometry(new Wb(a,
            b, c, d, e, f))
    }

    function Wb(a, b, c, d, e, f) {
        I.call(this);
        this.type = "RingBufferGeometry";
        this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
        };
        a = a || 20;
        b = b || 50;
        e = void 0 !== e ? e : 0;
        f = void 0 !== f ? f : 2 * Math.PI;
        c = void 0 !== c ? Math.max(3, c) : 8;
        d = void 0 !== d ? Math.max(1, d) : 1;
        var g = [], h = [], m = [], k = [], t = a, p = (b - a) / d, n = new q, l = new D, G, r;
        for (G = 0; G <= d; G++) {
            for (r = 0; r <= c; r++)a = e + r / c * f, n.x = t * Math.cos(a), n.y = t * Math.sin(a), h.push(n.x, n.y, n.z), m.push(0, 0, 1), l.x = (n.x / b + 1) / 2, l.y = (n.y / b + 1) /
                2, k.push(l.x, l.y);
            t += p
        }
        for (G = 0; G < d; G++)for (b = G * (c + 1), r = 0; r < c; r++)a = r + b, e = a + c + 1, f = a + c + 2, t = a + 1, g.push(a, e, t), g.push(e, f, t);
        this.setIndex(g);
        this.addAttribute("position", new z(h, 3));
        this.addAttribute("normal", new z(m, 3));
        this.addAttribute("uv", new z(k, 2))
    }

    function Tc(a, b, c, d) {
        T.call(this);
        this.type = "LatheGeometry";
        this.parameters = {points: a, segments: b, phiStart: c, phiLength: d};
        this.fromBufferGeometry(new Xb(a, b, c, d));
        this.mergeVertices()
    }

    function Xb(a, b, c, d) {
        I.call(this);
        this.type = "LatheBufferGeometry";
        this.parameters = {points: a, segments: b, phiStart: c, phiLength: d};
        b = Math.floor(b) || 12;
        c = c || 0;
        d = d || 2 * Math.PI;
        d = N.clamp(d, 0, 2 * Math.PI);
        var e = [], f = [], g = [], h = 1 / b, m = new q, k = new D, t, p;
        for (t = 0; t <= b; t++) {
            p = c + t * h * d;
            var n = Math.sin(p), l = Math.cos(p);
            for (p = 0; p <= a.length - 1; p++)m.x = a[p].x * n, m.y = a[p].y, m.z = a[p].x * l, f.push(m.x, m.y, m.z), k.x = t / b, k.y = p / (a.length - 1), g.push(k.x, k.y)
        }
        for (t = 0; t < b; t++)for (p = 0; p < a.length - 1; p++)c = p + t * a.length, h = c + a.length, m = c + a.length + 1, k = c + 1, e.push(c, h, k), e.push(h, m, k);
        this.setIndex(e);
        this.addAttribute("position",
            new z(f, 3));
        this.addAttribute("uv", new z(g, 2));
        this.computeVertexNormals();
        if (d === 2 * Math.PI)for (d = this.attributes.normal.array, e = new q, f = new q, g = new q, c = b * a.length * 3, p = t = 0; t < a.length; t++, p += 3)e.x = d[p + 0], e.y = d[p + 1], e.z = d[p + 2], f.x = d[c + p + 0], f.y = d[c + p + 1], f.z = d[c + p + 2], g.addVectors(e, f).normalize(), d[p + 0] = d[c + p + 0] = g.x, d[p + 1] = d[c + p + 1] = g.y, d[p + 2] = d[c + p + 2] = g.z
    }

    function Yb(a, b) {
        T.call(this);
        this.type = "ShapeGeometry";
        "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
            b = b.curveSegments);
        this.parameters = {shapes: a, curveSegments: b};
        this.fromBufferGeometry(new Zb(a, b));
        this.mergeVertices()
    }

    function Zb(a, b) {
        function c(a) {
            var c, h, k = e.length / 3;
            a = a.extractPoints(b);
            var l = a.shape, r = a.holes;
            if (!1 === Ia.isClockWise(l))for (l = l.reverse(), a = 0, c = r.length; a < c; a++)h = r[a], !0 === Ia.isClockWise(h) && (r[a] = h.reverse());
            var q = Ia.triangulateShape(l, r);
            a = 0;
            for (c = r.length; a < c; a++)h = r[a], l = l.concat(h);
            a = 0;
            for (c = l.length; a < c; a++)h = l[a], e.push(h.x, h.y, 0), f.push(0, 0, 1), g.push(h.x, h.y);
            a = 0;
            for (c =
                     q.length; a < c; a++)l = q[a], d.push(l[0] + k, l[1] + k, l[2] + k), m += 3
        }

        I.call(this);
        this.type = "ShapeBufferGeometry";
        this.parameters = {shapes: a, curveSegments: b};
        b = b || 12;
        var d = [], e = [], f = [], g = [], h = 0, m = 0;
        if (!1 === Array.isArray(a)) c(a); else for (var k = 0; k < a.length; k++)c(a[k]), this.addGroup(h, m, k), h += m, m = 0;
        this.setIndex(d);
        this.addAttribute("position", new z(e, 3));
        this.addAttribute("normal", new z(f, 3));
        this.addAttribute("uv", new z(g, 2))
    }

    function $b(a, b) {
        function c(a, b) {
            return a - b
        }

        I.call(this);
        this.type = "EdgesGeometry";
        this.parameters = {thresholdAngle: b};
        var d = [], e = Math.cos(N.DEG2RAD * (void 0 !== b ? b : 1)), f = [0, 0], g = {}, h, m = ["a", "b", "c"], k;
        a.isBufferGeometry ? (k = new T, k.fromBufferGeometry(a)) : k = a.clone();
        k.mergeVertices();
        k.computeFaceNormals();
        var t = k.vertices;
        k = k.faces;
        for (var p = 0, n = k.length; p < n; p++)for (var l = k[p],
                                                          q = 0; 3 > q; q++)f[0] = l[m[q]], f[1] = l[m[(q + 1) % 3]], f.sort(c), h = f.toString(), void 0 === g[h] ? g[h] = {
            index1: f[0],
            index2: f[1],
            face1: p,
            face2: void 0
        } : g[h].face2 = p;
        for (h in g)if (f = g[h], void 0 === f.face2 || k[f.face1].normal.dot(k[f.face2].normal) <=
            e) m = t[f.index1], d.push(m.x, m.y, m.z), m = t[f.index2], d.push(m.x, m.y, m.z);
        this.addAttribute("position", new z(d, 3))
    }

    function qb(a, b, c, d, e, f, g, h) {
        T.call(this);
        this.type = "CylinderGeometry";
        this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: g,
            thetaLength: h
        };
        this.fromBufferGeometry(new Va(a, b, c, d, e, f, g, h));
        this.mergeVertices()
    }

    function Va(a, b, c, d, e, f, g, h) {
        function m(c) {
            var e, f, m, r = new D, C = new q, F = 0, x = !0 === c ? a : b, H = !0 === c ? 1 : -1;
            f = G;
            for (e = 1; e <= d; e++)p.push(0,
                A * H, 0), n.push(0, H, 0), l.push(.5, .5), G++;
            m = G;
            for (e = 0; e <= d; e++) {
                var aa = e / d * h + g, z = Math.cos(aa), aa = Math.sin(aa);
                C.x = x * aa;
                C.y = A * H;
                C.z = x * z;
                p.push(C.x, C.y, C.z);
                n.push(0, H, 0);
                r.x = .5 * z + .5;
                r.y = .5 * aa * H + .5;
                l.push(r.x, r.y);
                G++
            }
            for (e = 0; e < d; e++)r = f + e, C = m + e, !0 === c ? t.push(C, C + 1, r) : t.push(C + 1, C, r), F += 3;
            k.addGroup(w, F, !0 === c ? 1 : 2);
            w += F
        }

        I.call(this);
        this.type = "CylinderBufferGeometry";
        this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: g,
            thetaLength: h
        };
        var k = this;
        a = void 0 !== a ? a : 20;
        b = void 0 !== b ? b : 20;
        c = void 0 !== c ? c : 100;
        d = Math.floor(d) || 8;
        e = Math.floor(e) || 1;
        f = void 0 !== f ? f : !1;
        g = void 0 !== g ? g : 0;
        h = void 0 !== h ? h : 2 * Math.PI;
        var t = [], p = [], n = [], l = [], G = 0, r = [], A = c / 2, w = 0;
        (function () {
            var f, m, v = new q, E = new q, L = 0, C = (b - a) / c;
            for (m = 0; m <= e; m++) {
                var F = [], x = m / e, H = x * (b - a) + a;
                for (f = 0; f <= d; f++) {
                    var D = f / d, z = D * h + g, J = Math.sin(z), z = Math.cos(z);
                    E.x = H * J;
                    E.y = -x * c + A;
                    E.z = H * z;
                    p.push(E.x, E.y, E.z);
                    v.set(J, C, z).normalize();
                    n.push(v.x, v.y, v.z);
                    l.push(D, 1 - x);
                    F.push(G++)
                }
                r.push(F)
            }
            for (f = 0; f < d; f++)for (m =
                                            0; m < e; m++)v = r[m + 1][f], E = r[m + 1][f + 1], C = r[m][f + 1], t.push(r[m][f], v, C), t.push(v, E, C), L += 6;
            k.addGroup(w, L, 0);
            w += L
        })();
        !1 === f && (0 < a && m(!0), 0 < b && m(!1));
        this.setIndex(t);
        this.addAttribute("position", new z(p, 3));
        this.addAttribute("normal", new z(n, 3));
        this.addAttribute("uv", new z(l, 2))
    }

    function Uc(a, b, c, d, e, f, g) {
        qb.call(this, 0, a, b, c, d, e, f, g);
        this.type = "ConeGeometry";
        this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        }
    }

    function Vc(a, b, c, d, e, f, g) {
        Va.call(this,
            0, a, b, c, d, e, f, g);
        this.type = "ConeBufferGeometry";
        this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        }
    }

    function Wc(a, b, c, d) {
        T.call(this);
        this.type = "CircleGeometry";
        this.parameters = {radius: a, segments: b, thetaStart: c, thetaLength: d};
        this.fromBufferGeometry(new ac(a, b, c, d))
    }

    function ac(a, b, c, d) {
        I.call(this);
        this.type = "CircleBufferGeometry";
        this.parameters = {radius: a, segments: b, thetaStart: c, thetaLength: d};
        a = a || 50;
        b = void 0 !== b ? Math.max(3, b) : 8;
        c = void 0 !==
        c ? c : 0;
        d = void 0 !== d ? d : 2 * Math.PI;
        var e = [], f = [], g = [], h = [], m, k, t = new q, p = new D;
        f.push(0, 0, 0);
        g.push(0, 0, 1);
        h.push(.5, .5);
        k = 0;
        for (m = 3; k <= b; k++, m += 3) {
            var n = c + k / b * d;
            t.x = a * Math.cos(n);
            t.y = a * Math.sin(n);
            f.push(t.x, t.y, t.z);
            g.push(0, 0, 1);
            p.x = (f[m] / a + 1) / 2;
            p.y = (f[m + 1] / a + 1) / 2;
            h.push(p.x, p.y)
        }
        for (m = 1; m <= b; m++)e.push(m, m + 1, 0);
        this.setIndex(e);
        this.addAttribute("position", new z(f, 3));
        this.addAttribute("normal", new z(g, 3));
        this.addAttribute("uv", new z(h, 2))
    }

    function bc() {
        Ha.call(this, {
            uniforms: Ja.merge([V.lights,
                {opacity: {value: 1}}]), vertexShader: Z.shadow_vert, fragmentShader: Z.shadow_frag
        });
        this.transparent = this.lights = !0;
        Object.defineProperties(this, {
            opacity: {
                enumerable: !0, get: function () {
                    return this.uniforms.opacity.value
                }, set: function (a) {
                    this.uniforms.opacity.value = a
                }
            }
        })
    }

    function cc(a) {
        Ha.call(this, a);
        this.type = "RawShaderMaterial"
    }

    function Xc(a) {
        this.uuid = N.generateUUID();
        this.type = "MultiMaterial";
        this.materials = Array.isArray(a) ? a : [];
        this.visible = !0
    }

    function Qa(a) {
        X.call(this);
        this.defines = {STANDARD: ""};
        this.type = "MeshStandardMaterial";
        this.color = new J(16777215);
        this.metalness = this.roughness = .5;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new J(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new D(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio =
            .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a)
    }

    function rb(a) {
        Qa.call(this);
        this.defines = {PHYSICAL: ""};
        this.type = "MeshPhysicalMaterial";
        this.reflectivity = .5;
        this.clearCoatRoughness = this.clearCoat = 0;
        this.setValues(a)
    }

    function Ca(a) {
        X.call(this);
        this.type = "MeshPhongMaterial";
        this.color = new J(16777215);
        this.specular = new J(1118481);
        this.shininess = 30;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new J(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new D(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals =
            this.morphTargets = this.skinning = !1;
        this.setValues(a)
    }

    function sb(a) {
        Ca.call(this);
        this.defines = {TOON: ""};
        this.type = "MeshToonMaterial";
        this.gradientMap = null;
        this.setValues(a)
    }

    function tb(a) {
        X.call(this, a);
        this.type = "MeshNormalMaterial";
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new D(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog =
            !1;
        this.setValues(a)
    }

    function ub(a) {
        X.call(this);
        this.type = "MeshLambertMaterial";
        this.color = new J(16777215);
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new J(0);
        this.emissiveIntensity = 1;
        this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets =
            this.skinning = !1;
        this.setValues(a)
    }

    function vb(a) {
        X.call(this);
        this.type = "LineDashedMaterial";
        this.color = new J(16777215);
        this.scale = this.linewidth = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.lights = !1;
        this.setValues(a)
    }

    function $d(a, b, c) {
        var d = this, e = !1, f = 0, g = 0;
        this.onStart = void 0;
        this.onLoad = a;
        this.onProgress = b;
        this.onError = c;
        this.itemStart = function (a) {
            g++;
            if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g);
            e = !0
        };
        this.itemEnd = function (a) {
            f++;
            if (void 0 !== d.onProgress) d.onProgress(a, f, g);
            if (f === g && (e = !1, void 0 !==
                d.onLoad)) d.onLoad()
        };
        this.itemError = function (a) {
            if (void 0 !== d.onError) d.onError(a)
        }
    }

    function sa(a) {
        this.manager = void 0 !== a ? a : ta
    }

    function Re(a) {
        this.manager = void 0 !== a ? a : ta;
        this._parser = null
    }

    function ae(a) {
        this.manager = void 0 !== a ? a : ta;
        this._parser = null
    }

    function Yc(a) {
        this.manager = void 0 !== a ? a : ta
    }

    function be(a) {
        this.manager = void 0 !== a ? a : ta
    }

    function td(a) {
        this.manager = void 0 !== a ? a : ta
    }

    function ma(a, b) {
        x.call(this);
        this.type = "Light";
        this.color = new J(a);
        this.intensity = void 0 !== b ? b : 1;
        this.receiveShadow =
            void 0
    }

    function ud(a, b, c) {
        ma.call(this, a, c);
        this.type = "HemisphereLight";
        this.castShadow = void 0;
        this.position.copy(x.DefaultUp);
        this.updateMatrix();
        this.groundColor = new J(b)
    }

    function wb(a) {
        this.camera = a;
        this.bias = 0;
        this.radius = 1;
        this.mapSize = new D(512, 512);
        this.map = null;
        this.matrix = new S
    }

    function vd() {
        wb.call(this, new Fa(50, 1, .5, 500))
    }

    function wd(a, b, c, d, e, f) {
        ma.call(this, a, b);
        this.type = "SpotLight";
        this.position.copy(x.DefaultUp);
        this.updateMatrix();
        this.target = new x;
        Object.defineProperty(this, "power",
            {
                get: function () {
                    return this.intensity * Math.PI
                }, set: function (a) {
                this.intensity = a / Math.PI
            }
            });
        this.distance = void 0 !== c ? c : 0;
        this.angle = void 0 !== d ? d : Math.PI / 3;
        this.penumbra = void 0 !== e ? e : 0;
        this.decay = void 0 !== f ? f : 1;
        this.shadow = new vd
    }

    function xd(a, b, c, d) {
        ma.call(this, a, b);
        this.type = "PointLight";
        Object.defineProperty(this, "power", {
            get: function () {
                return 4 * this.intensity * Math.PI
            }, set: function (a) {
                this.intensity = a / (4 * Math.PI)
            }
        });
        this.distance = void 0 !== c ? c : 0;
        this.decay = void 0 !== d ? d : 1;
        this.shadow = new wb(new Fa(90,
            1, .5, 500))
    }

    function yd() {
        wb.call(this, new Jb(-5, 5, 5, -5, .5, 500))
    }

    function zd(a, b) {
        ma.call(this, a, b);
        this.type = "DirectionalLight";
        this.position.copy(x.DefaultUp);
        this.updateMatrix();
        this.target = new x;
        this.shadow = new yd
    }

    function Ad(a, b) {
        ma.call(this, a, b);
        this.type = "AmbientLight";
        this.castShadow = void 0
    }

    function xa(a, b, c, d) {
        this.parameterPositions = a;
        this._cachedIndex = 0;
        this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
        this.sampleValues = b;
        this.valueSize = c
    }

    function Bd(a, b, c, d) {
        xa.call(this, a, b, c, d);
        this._offsetNext =
            this._weightNext = this._offsetPrev = this._weightPrev = -0
    }

    function Zc(a, b, c, d) {
        xa.call(this, a, b, c, d)
    }

    function Cd(a, b, c, d) {
        xa.call(this, a, b, c, d)
    }

    function xb(a, b, c, d) {
        if (void 0 === a)throw Error("track name is undefined");
        if (void 0 === b || 0 === b.length)throw Error("no keyframes in track named " + a);
        this.name = a;
        this.times = na.convertArray(b, this.TimeBufferType);
        this.values = na.convertArray(c, this.ValueBufferType);
        this.setInterpolation(d || this.DefaultInterpolation);
        this.validate();
        this.optimize()
    }

    function dc(a, b,
                c, d) {
        xb.call(this, a, b, c, d)
    }

    function Dd(a, b, c, d) {
        xa.call(this, a, b, c, d)
    }

    function $c(a, b, c, d) {
        xb.call(this, a, b, c, d)
    }

    function ec(a, b, c, d) {
        xb.call(this, a, b, c, d)
    }

    function Ed(a, b, c, d) {
        xb.call(this, a, b, c, d)
    }

    function Fd(a, b, c) {
        xb.call(this, a, b, c)
    }

    function Gd(a, b, c, d) {
        xb.call(this, a, b, c, d)
    }

    function yb(a, b, c, d) {
        xb.apply(this, arguments)
    }

    function qa(a, b, c) {
        this.name = a;
        this.tracks = c;
        this.duration = void 0 !== b ? b : -1;
        this.uuid = N.generateUUID();
        0 > this.duration && this.resetDuration();
        this.optimize()
    }

    function Hd(a) {
        this.manager =
            void 0 !== a ? a : ta;
        this.textures = {}
    }

    function ce(a) {
        this.manager = void 0 !== a ? a : ta
    }

    function zb() {
        this.onLoadStart = function () {
        };
        this.onLoadProgress = function () {
        };
        this.onLoadComplete = function () {
        }
    }

    function de(a) {
        "boolean" === typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0);
        this.manager = void 0 !== a ? a : ta;
        this.withCredentials = !1
    }

    function Se(a) {
        this.manager = void 0 !== a ? a : ta;
        this.texturePath = ""
    }

    function Te(a, b, c, d, e) {
        b = .5 * (d - b);
        e = .5 * (e - c);
        var f = a * a;
        return (2 *
            c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c
    }

    function Ab(a, b, c, d) {
        var e = 1 - a;
        return e * e * b + 2 * (1 - a) * a * c + a * a * d
    }

    function Bb(a, b, c, d, e) {
        var f = 1 - a, g = 1 - a;
        return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
    }

    function ua() {
    }

    function Ta(a, b) {
        this.v1 = a;
        this.v2 = b
    }

    function ad() {
        this.curves = [];
        this.autoClose = !1
    }

    function Wa(a, b, c, d, e, f, g, h) {
        this.aX = a;
        this.aY = b;
        this.xRadius = c;
        this.yRadius = d;
        this.aStartAngle = e;
        this.aEndAngle = f;
        this.aClockwise = g;
        this.aRotation = h || 0
    }

    function Cb(a) {
        this.points = void 0 === a ? [] : a
    }

    function fc(a, b, c,
                d) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = c;
        this.v3 = d
    }

    function gc(a, b, c) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = c
    }

    function bd(a) {
        ad.call(this);
        this.currentPoint = new D;
        a && this.fromPoints(a)
    }

    function Db() {
        bd.apply(this, arguments);
        this.holes = []
    }

    function ee() {
        this.subPaths = [];
        this.currentPath = null
    }

    function fe(a) {
        this.data = a
    }

    function Ue(a) {
        this.manager = void 0 !== a ? a : ta
    }

    function ge(a) {
        this.manager = void 0 !== a ? a : ta
    }

    function he(a, b, c, d) {
        ma.call(this, a, b);
        this.type = "RectAreaLight";
        this.position.set(0, 1, 0);
        this.updateMatrix();
        this.width =
            void 0 !== c ? c : 10;
        this.height = void 0 !== d ? d : 10
    }

    function Ve() {
        this.type = "StereoCamera";
        this.aspect = 1;
        this.eyeSep = .064;
        this.cameraL = new Fa;
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = !1;
        this.cameraR = new Fa;
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = !1
    }

    function Id(a, b, c) {
        x.call(this);
        this.type = "CubeCamera";
        var d = new Fa(90, 1, a, b);
        d.up.set(0, -1, 0);
        d.lookAt(new q(1, 0, 0));
        this.add(d);
        var e = new Fa(90, 1, a, b);
        e.up.set(0, -1, 0);
        e.lookAt(new q(-1, 0, 0));
        this.add(e);
        var f = new Fa(90,
            1, a, b);
        f.up.set(0, 0, 1);
        f.lookAt(new q(0, 1, 0));
        this.add(f);
        var g = new Fa(90, 1, a, b);
        g.up.set(0, 0, -1);
        g.lookAt(new q(0, -1, 0));
        this.add(g);
        var h = new Fa(90, 1, a, b);
        h.up.set(0, -1, 0);
        h.lookAt(new q(0, 0, 1));
        this.add(h);
        var m = new Fa(90, 1, a, b);
        m.up.set(0, -1, 0);
        m.lookAt(new q(0, 0, -1));
        this.add(m);
        this.renderTarget = new Gb(c, c, {format: 1022, magFilter: 1006, minFilter: 1006});
        this.updateCubeMap = function (a, b) {
            null === this.parent && this.updateMatrixWorld();
            var c = this.renderTarget, n = c.texture.generateMipmaps;
            c.texture.generateMipmaps =
                !1;
            c.activeCubeFace = 0;
            a.render(b, d, c);
            c.activeCubeFace = 1;
            a.render(b, e, c);
            c.activeCubeFace = 2;
            a.render(b, f, c);
            c.activeCubeFace = 3;
            a.render(b, g, c);
            c.activeCubeFace = 4;
            a.render(b, h, c);
            c.texture.generateMipmaps = n;
            c.activeCubeFace = 5;
            a.render(b, m, c);
            a.setRenderTarget(null)
        }
    }

    function ie() {
        x.call(this);
        this.type = "AudioListener";
        this.context = je.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null
    }

    function hc(a) {
        x.call(this);
        this.type = "Audio";
        this.context =
            a.context;
        this.gain = this.context.createGain();
        this.gain.connect(a.getInput());
        this.autoplay = !1;
        this.buffer = null;
        this.loop = !1;
        this.startTime = 0;
        this.playbackRate = 1;
        this.isPlaying = !1;
        this.hasPlaybackControl = !0;
        this.sourceType = "empty";
        this.filters = []
    }

    function ke(a) {
        hc.call(this, a);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain)
    }

    function le(a, b) {
        this.analyser = a.context.createAnalyser();
        this.analyser.fftSize = void 0 !== b ? b : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        a.getOutput().connect(this.analyser)
    }

    function Jd(a, b, c) {
        this.binding = a;
        this.valueSize = c;
        a = Float64Array;
        switch (b) {
            case "quaternion":
                b = this._slerp;
                break;
            case "string":
            case "bool":
                a = Array;
                b = this._select;
                break;
            default:
                b = this._lerp
        }
        this.buffer = new a(4 * c);
        this._mixBufferRegion = b;
        this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }

    function ka(a, b, c) {
        this.path = b;
        this.parsedPath = c || ka.parseTrackName(b);
        this.node = ka.findNode(a, this.parsedPath.nodeName) || a;
        this.rootNode = a
    }

    function me(a) {
        this.uuid = N.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var b = {};
        this._indicesByUUID = b;
        for (var c = 0, d = arguments.length; c !== d; ++c)b[arguments[c].uuid] = c;
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var e = this;
        this.stats = {
            objects: {
                get total() {
                    return e._objects.length
                }, get inUse() {
                    return this.total - e.nCachedObjects_
                }
            }, get bindingsPerObject() {
                return e._bindings.length
            }
        }
    }

    function ne(a, b, c) {
        this._mixer = a;
        this._clip = b;
        this._localRoot = c || null;
        a = b.tracks;
        b = a.length;
        c = Array(b);
        for (var d = {endingStart: 2400, endingEnd: 2400}, e = 0; e !== b; ++e) {
            var f = a[e].createInterpolant(null);
            c[e] = f;
            f.settings = d
        }
        this._interpolantSettings = d;
        this._interpolants = c;
        this._propertyBindings = Array(b);
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
        this.loop = 2201;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
        this.repetitions = Infinity;
        this.paused = !1;
        this.enabled =
            !0;
        this.clampWhenFinished = !1;
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }

    function cd(a) {
        this._root = a;
        this._initMemoryManager();
        this.time = this._accuIndex = 0;
        this.timeScale = 1
    }

    function Kd(a, b) {
        "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b);
        this.value = a
    }

    function Eb() {
        I.call(this);
        this.type = "InstancedBufferGeometry";
        this.maxInstancedCount = void 0
    }

    function oe(a, b, c, d) {
        this.uuid = N.generateUUID();
        this.data = a;
        this.itemSize = b;
        this.offset = c;
        this.normalized = !0 ===
            d
    }

    function ic(a, b) {
        this.uuid = N.generateUUID();
        this.array = a;
        this.stride = b;
        this.count = void 0 !== a ? a.length / b : 0;
        this.dynamic = !1;
        this.updateRange = {offset: 0, count: -1};
        this.onUploadCallback = function () {
        };
        this.version = 0
    }

    function jc(a, b, c) {
        ic.call(this, a, b);
        this.meshPerAttribute = c || 1
    }

    function kc(a, b, c) {
        U.call(this, a, b);
        this.meshPerAttribute = c || 1
    }

    function pe(a, b, c, d) {
        this.ray = new cb(a, b);
        this.near = c || 0;
        this.far = d || Infinity;
        this.params = {Mesh: {}, Line: {}, LOD: {}, Points: {threshold: 1}, Sprite: {}};
        Object.defineProperties(this.params,
            {
                PointCloud: {
                    get: function () {
                        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                        return this.Points
                    }
                }
            })
    }

    function We(a, b) {
        return a.distance - b.distance
    }

    function qe(a, b, c, d) {
        if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
            a = a.children;
            d = 0;
            for (var e = a.length; d < e; d++)qe(a[d], b, c, !0)
        }
    }

    function re(a) {
        this.autoStart = void 0 !== a ? a : !0;
        this.elapsedTime = this.oldTime = this.startTime = 0;
        this.running = !1
    }

    function se(a, b, c) {
        this.radius = void 0 !== a ? a : 1;
        this.phi = void 0 !== b ? b : 0;
        this.theta = void 0 !==
        c ? c : 0;
        return this
    }

    function te(a, b, c) {
        this.radius = void 0 !== a ? a : 1;
        this.theta = void 0 !== b ? b : 0;
        this.y = void 0 !== c ? c : 0;
        return this
    }

    function oa(a, b) {
        Aa.call(this, a, b);
        this.animationsMap = {};
        this.animationsList = [];
        var c = this.geometry.morphTargets.length;
        this.createAnimation("__default", 0, c - 1, c / 1);
        this.setAnimationWeight("__default", 1)
    }

    function dd(a) {
        x.call(this);
        this.material = a;
        this.render = function (a) {
        }
    }

    function ed(a, b, c, d) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== c ? c : 16711680;
        d = void 0 !== d ? d : 1;
        b = 0;
        (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count);
        c = new I;
        b = new z(6 * b, 3);
        c.addAttribute("position", b);
        ga.call(this, c, new ia({color: a, linewidth: d}));
        this.matrixAutoUpdate = !1;
        this.update()
    }

    function lc(a) {
        x.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        a = new I;
        for (var b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1],
                 c = 0, d = 1; 32 > c; c++, d++) {
            var e = c / 32 * Math.PI * 2, f = d / 32 *
                Math.PI * 2;
            b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
        }
        a.addAttribute("position", new z(b, 3));
        b = new ia({fog: !1});
        this.cone = new ga(a, b);
        this.add(this.cone);
        this.update()
    }

    function mc(a) {
        this.bones = this.getBoneList(a);
        for (var b = new I, c = [], d = [], e = new J(0, 0, 1), f = new J(0, 1, 0), g = 0; g < this.bones.length; g++) {
            var h = this.bones[g];
            h.parent && h.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), d.push(e.r, e.g, e.b), d.push(f.r, f.g, f.b))
        }
        b.addAttribute("position", new z(c, 3));
        b.addAttribute("color", new z(d, 3));
        c = new ia({vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0});
        ga.call(this, b, c);
        this.root = a;
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.update()
    }

    function nc(a, b) {
        this.light = a;
        this.light.updateMatrixWorld();
        var c = new pb(b, 4, 2), d = new Ka({wireframe: !0, fog: !1});
        d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        Aa.call(this, c, d);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = !1
    }

    function oc(a) {
        x.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        var b =
            new Ka({color: a.color, fog: !1});
        a = new Ka({color: a.color, fog: !1, wireframe: !0});
        var c = new I;
        c.addAttribute("position", new U(new Float32Array(18), 3));
        this.add(new Aa(c, b));
        this.add(new Aa(c, a));
        this.update()
    }

    function pc(a, b) {
        x.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        var c = new ob(b);
        c.rotateY(.5 * Math.PI);
        var d = new Ka({vertexColors: 2, wireframe: !0}), e = c.getAttribute("position"),
            e = new Float32Array(3 * e.count);
        c.addAttribute("color", new U(e,
            3));
        this.add(new Aa(c, d));
        this.update()
    }

    function fd(a, b, c, d) {
        a = a || 10;
        b = b || 10;
        c = new J(void 0 !== c ? c : 4473924);
        d = new J(void 0 !== d ? d : 8947848);
        var e = b / 2, f = a / b, g = a / 2;
        a = [];
        for (var h = [], m = 0, k = 0, t = -g; m <= b; m++, t += f) {
            a.push(-g, 0, t, g, 0, t);
            a.push(t, 0, -g, t, 0, g);
            var l = m === e ? c : d;
            l.toArray(h, k);
            k += 3;
            l.toArray(h, k);
            k += 3;
            l.toArray(h, k);
            k += 3;
            l.toArray(h, k);
            k += 3
        }
        b = new I;
        b.addAttribute("position", new z(a, 3));
        b.addAttribute("color", new z(h, 3));
        c = new ia({vertexColors: 2});
        ga.call(this, b, c)
    }

    function Ld(a, b, c, d, e, f) {
        a = a || 10;
        b = b || 16;
        c = c || 8;
        d = d || 64;
        e = new J(void 0 !== e ? e : 4473924);
        f = new J(void 0 !== f ? f : 8947848);
        var g = [], h = [], m, k, t, l, n;
        for (t = 0; t <= b; t++)k = t / b * 2 * Math.PI, m = Math.sin(k) * a, k = Math.cos(k) * a, g.push(0, 0, 0), g.push(m, 0, k), n = t & 1 ? e : f, h.push(n.r, n.g, n.b), h.push(n.r, n.g, n.b);
        for (t = 0; t <= c; t++)for (n = t & 1 ? e : f, l = a - a / c * t, b = 0; b < d; b++)k = b / d * 2 * Math.PI, m = Math.sin(k) * l, k = Math.cos(k) * l, g.push(m, 0, k), h.push(n.r, n.g, n.b), k = (b + 1) / d * 2 * Math.PI, m = Math.sin(k) * l, k = Math.cos(k) * l, g.push(m, 0, k), h.push(n.r, n.g, n.b);
        a = new I;
        a.addAttribute("position",
            new z(g, 3));
        a.addAttribute("color", new z(h, 3));
        g = new ia({vertexColors: 2});
        ga.call(this, a, g)
    }

    function gd(a, b, c, d) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== c ? c : 16776960;
        d = void 0 !== d ? d : 1;
        b = 0;
        (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        c = new I;
        b = new z(6 * b, 3);
        c.addAttribute("position", b);
        ga.call(this, c, new ia({color: a, linewidth: d}));
        this.matrixAutoUpdate = !1;
        this.update()
    }

    function qc(a, b) {
        x.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        void 0 === b && (b = 1);
        var c = new I;
        c.addAttribute("position", new z([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
        var d = new ia({fog: !1});
        this.add(new Ua(c, d));
        c = new I;
        c.addAttribute("position", new z([0, 0, 0, 0, 0, 1], 3));
        this.add(new Ua(c, d));
        this.update()
    }

    function hd(a) {
        function b(a, b, d) {
            c(a, d);
            c(b, d)
        }

        function c(a, b) {
            f.push(0, 0, 0);
            g.push(b.r, b.g, b.b);
            void 0 === h[a] && (h[a] = []);
            h[a].push(f.length /
                3 - 1)
        }

        var d = new I, e = new ia({color: 16777215, vertexColors: 1}), f = [], g = [], h = {}, m = new J(16755200),
            k = new J(16711680), l = new J(43775), p = new J(16777215), n = new J(3355443);
        b("n1", "n2", m);
        b("n2", "n4", m);
        b("n4", "n3", m);
        b("n3", "n1", m);
        b("f1", "f2", m);
        b("f2", "f4", m);
        b("f4", "f3", m);
        b("f3", "f1", m);
        b("n1", "f1", m);
        b("n2", "f2", m);
        b("n3", "f3", m);
        b("n4", "f4", m);
        b("p", "n1", k);
        b("p", "n2", k);
        b("p", "n3", k);
        b("p", "n4", k);
        b("u1", "u2", l);
        b("u2", "u3", l);
        b("u3", "u1", l);
        b("c", "t", p);
        b("p", "c", n);
        b("cn1", "cn2", n);
        b("cn3", "cn4", n);
        b("cf1", "cf2", n);
        b("cf3", "cf4", n);
        d.addAttribute("position", new z(f, 3));
        d.addAttribute("color", new z(g, 3));
        ga.call(this, d, e);
        this.camera = a;
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.pointMap = h;
        this.update()
    }

    function rc(a, b) {
        void 0 === b && (b = 16776960);
        var c = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            d = new Float32Array(24), e = new I;
        e.setIndex(new U(c, 1));
        e.addAttribute("position", new U(d, 3));
        ga.call(this,
            e, new ia({color: b}));
        void 0 !== a && this.update(a)
    }

    function Fb(a, b, c, d, e, f) {
        x.call(this);
        void 0 === d && (d = 16776960);
        void 0 === c && (c = 1);
        void 0 === e && (e = .2 * c);
        void 0 === f && (f = .2 * e);
        void 0 === Md && (Md = new I, Md.addAttribute("position", new z([0, 0, 0, 0, 1, 0], 3)), ue = new Va(0, .5, 1, 5, 1), ue.translate(0, -.5, 0));
        this.position.copy(b);
        this.line = new Ua(Md, new ia({color: d}));
        this.line.matrixAutoUpdate = !1;
        this.add(this.line);
        this.cone = new Aa(ue, new Ka({color: d}));
        this.cone.matrixAutoUpdate = !1;
        this.add(this.cone);
        this.setDirection(a);
        this.setLength(c, e, f)
    }

    function Nd(a) {
        a = a || 1;
        var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
        a = new I;
        a.addAttribute("position", new z(b, 3));
        a.addAttribute("color", new z([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        b = new ia({vertexColors: 2});
        ga.call(this, a, b)
    }

    function ve() {
        var a = 0, b = 0, c = 0, d = 0;
        return {
            initCatmullRom: function (e, f, g, h, m) {
                e = m * (g - e);
                h = m * (h - f);
                a = f;
                b = e;
                c = -3 * f + 3 * g - 2 * e - h;
                d = 2 * f - 2 * g + e + h
            }, initNonuniformCatmullRom: function (e, f, g, h, m, k, l) {
                e = ((f - e) / m - (g - e) / (m + k) + (g - f) / k) * k;
                h = ((g - f) / k - (h - f) / (k + l) + (h - g) /
                    l) * k;
                a = f;
                b = e;
                c = -3 * f + 3 * g - 2 * e - h;
                d = 2 * f - 2 * g + e + h
            }, calc: function (e) {
                var f = e * e;
                return a + b * e + c * f + d * f * e
            }
        }
    }

    function va(a) {
        this.points = a || [];
        this.closed = !1
    }

    function id(a, b, c, d) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = c;
        this.v3 = d
    }

    function jd(a, b, c) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = c
    }

    function kd(a, b) {
        this.v1 = a;
        this.v2 = b
    }

    function Od(a, b, c, d, e, f) {
        Wa.call(this, a, b, c, c, d, e, f)
    }

    function Xe(a) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
        va.call(this, a);
        this.type = "catmullrom";
        this.closed =
            !0
    }

    function Ye(a) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
        va.call(this, a);
        this.type = "catmullrom"
    }

    function we(a) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
        va.call(this, a);
        this.type = "catmullrom"
    }

    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
    void 0 === Math.sign && (Math.sign = function (a) {
        return 0 > a ? -1 : 0 < a ? 1 : +a
    });
    void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
        get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    });
    void 0 === Object.assign && function () {
        Object.assign = function (a) {
            if (void 0 === a || null === a)throw new TypeError("Cannot convert undefined or null to object");
            for (var b = Object(a), c = 1; c < arguments.length; c++) {
                var d = arguments[c];
                if (void 0 !== d && null !== d)for (var e in d)Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
            }
            return b
        }
    }();
    pa.prototype = {
        addEventListener: function (a, b) {
            void 0 === this._listeners && (this._listeners = {});
            var c = this._listeners;
            void 0 === c[a] && (c[a] = []);
            -1 === c[a].indexOf(b) && c[a].push(b)
        }, hasEventListener: function (a,
                                       b) {
            if (void 0 === this._listeners)return !1;
            var c = this._listeners;
            return void 0 !== c[a] && -1 !== c[a].indexOf(b)
        }, removeEventListener: function (a, b) {
            if (void 0 !== this._listeners) {
                var c = this._listeners[a];
                if (void 0 !== c) {
                    var d = c.indexOf(b);
                    -1 !== d && c.splice(d, 1)
                }
            }
        }, dispatchEvent: function (a) {
            if (void 0 !== this._listeners) {
                var b = this._listeners[a.type];
                if (void 0 !== b) {
                    a.target = this;
                    var c = [], d, e = b.length;
                    for (d = 0; d < e; d++)c[d] = b[d];
                    for (d = 0; d < e; d++)c[d].call(this, a)
                }
            }
        }
    };
    var N = {
        DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
            var a =
                "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), b = Array(36), c = 0, d;
            return function () {
                for (var e = 0; 36 > e; e++)8 === e || 13 === e || 18 === e || 23 === e ? b[e] = "-" : 14 === e ? b[e] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 === e ? d & 3 | 8 : d]);
                return b.join("")
            }
        }(), clamp: function (a, b, c) {
            return Math.max(b, Math.min(c, a))
        }, euclideanModulo: function (a, b) {
            return (a % b + b) % b
        }, mapLinear: function (a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b)
        }, lerp: function (a, b, c) {
            return (1 - c) * a + c * b
        }, smoothstep: function (a,
                                 b, c) {
            if (a <= b)return 0;
            if (a >= c)return 1;
            a = (a - b) / (c - b);
            return a * a * (3 - 2 * a)
        }, smootherstep: function (a, b, c) {
            if (a <= b)return 0;
            if (a >= c)return 1;
            a = (a - b) / (c - b);
            return a * a * a * (a * (6 * a - 15) + 10)
        }, randInt: function (a, b) {
            return a + Math.floor(Math.random() * (b - a + 1))
        }, randFloat: function (a, b) {
            return a + Math.random() * (b - a)
        }, randFloatSpread: function (a) {
            return a * (.5 - Math.random())
        }, degToRad: function (a) {
            return a * N.DEG2RAD
        }, radToDeg: function (a) {
            return a * N.RAD2DEG
        }, isPowerOfTwo: function (a) {
            return 0 === (a & a - 1) && 0 !== a
        }, nearestPowerOfTwo: function (a) {
            return Math.pow(2,
                Math.round(Math.log(a) / Math.LN2))
        }, nextPowerOfTwo: function (a) {
            a--;
            a |= a >> 1;
            a |= a >> 2;
            a |= a >> 4;
            a |= a >> 8;
            a |= a >> 16;
            a++;
            return a
        }
    };
    D.prototype = {
        constructor: D, isVector2: !0, get width() {
            return this.x
        }, set width(a) {
            this.x = a
        }, get height() {
            return this.y
        }, set height(a) {
            this.y = a
        }, set: function (a, b) {
            this.x = a;
            this.y = b;
            return this
        }, setScalar: function (a) {
            this.y = this.x = a;
            return this
        }, setX: function (a) {
            this.x = a;
            return this
        }, setY: function (a) {
            this.y = a;
            return this
        }, setComponent: function (a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
            return this
        }, getComponent: function (a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y)
        }, copy: function (a) {
            this.x = a.x;
            this.y = a.y;
            return this
        }, add: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            return this
        }, addScalar: function (a) {
            this.x += a;
            this.y += a;
            return this
        }, addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this
        }, addScaledVector: function (a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            return this
        }, sub: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            return this
        }, subScalar: function (a) {
            this.x -= a;
            this.y -= a;
            return this
        }, subVectors: function (a, b) {
            this.x =
                a.x - b.x;
            this.y = a.y - b.y;
            return this
        }, multiply: function (a) {
            this.x *= a.x;
            this.y *= a.y;
            return this
        }, multiplyScalar: function (a) {
            isFinite(a) ? (this.x *= a, this.y *= a) : this.y = this.x = 0;
            return this
        }, divide: function (a) {
            this.x /= a.x;
            this.y /= a.y;
            return this
        }, divideScalar: function (a) {
            return this.multiplyScalar(1 / a)
        }, min: function (a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            return this
        }, max: function (a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            return this
        }, clamp: function (a, b) {
            this.x = Math.max(a.x,
                Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            return this
        }, clampScalar: function () {
            var a, b;
            return function (c, d) {
                void 0 === a && (a = new D, b = new D);
                a.set(c, c);
                b.set(d, d);
                return this.clamp(a, b)
            }
        }(), clampLength: function (a, b) {
            var c = this.length();
            return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
        }, floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this
        }, ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this
        }, round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this
        }, roundToZero: function () {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            return this
        }, negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            return this
        }, dot: function (a) {
            return this.x * a.x + this.y * a.y
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }, lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        }, normalize: function () {
            return this.divideScalar(this.length())
        },
        angle: function () {
            var a = Math.atan2(this.y, this.x);
            0 > a && (a += 2 * Math.PI);
            return a
        }, distanceTo: function (a) {
            return Math.sqrt(this.distanceToSquared(a))
        }, distanceToSquared: function (a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return b * b + a * a
        }, distanceToManhattan: function (a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
        }, setLength: function (a) {
            return this.multiplyScalar(a / this.length())
        }, lerp: function (a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            return this
        }, lerpVectors: function (a, b, c) {
            return this.subVectors(b,
                a).multiplyScalar(c).add(a)
        }, equals: function (a) {
            return a.x === this.x && a.y === this.y
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            return a
        }, fromBufferAttribute: function (a, b, c) {
            void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b);
            this.y = a.getY(b);
            return this
        }, rotateAround: function (a, b) {
            var c = Math.cos(b), d = Math.sin(b), e = this.x -
                a.x, f = this.y - a.y;
            this.x = e * c - f * d + a.x;
            this.y = e * d + f * c + a.y;
            return this
        }
    };
    var Ze = 0;
    ea.DEFAULT_IMAGE = void 0;
    ea.DEFAULT_MAPPING = 300;
    ea.prototype = {
        constructor: ea, isTexture: !0, set needsUpdate(a) {
            !0 === a && this.version++
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.image = a.image;
            this.mipmaps = a.mipmaps.slice(0);
            this.mapping = a.mapping;
            this.wrapS = a.wrapS;
            this.wrapT = a.wrapT;
            this.magFilter = a.magFilter;
            this.minFilter = a.minFilter;
            this.anisotropy = a.anisotropy;
            this.format = a.format;
            this.type = a.type;
            this.offset.copy(a.offset);
            this.repeat.copy(a.repeat);
            this.generateMipmaps = a.generateMipmaps;
            this.premultiplyAlpha = a.premultiplyAlpha;
            this.flipY = a.flipY;
            this.unpackAlignment = a.unpackAlignment;
            this.encoding = a.encoding;
            return this
        }, toJSON: function (a) {
            if (void 0 !== a.textures[this.uuid])return a.textures[this.uuid];
            var b = {
                metadata: {version: 4.4, type: "Texture", generator: "Texture.toJSON"},
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x,
                    this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var c = this.image;
                void 0 === c.uuid && (c.uuid = N.generateUUID());
                if (void 0 === a.images[c.uuid]) {
                    var d = a.images, e = c.uuid, f = c.uuid, g;
                    void 0 !== c.toDataURL ? g = c : (g = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), g.width = c.width, g.height = c.height, g.getContext("2d").drawImage(c, 0, 0, c.width, c.height));
                    g = 2048 < g.width || 2048 < g.height ? g.toDataURL("image/jpeg",
                        .6) : g.toDataURL("image/png");
                    d[e] = {uuid: f, url: g}
                }
                b.image = c.uuid
            }
            return a.textures[this.uuid] = b
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }, transformUv: function (a) {
            if (300 === this.mapping) {
                a.multiply(this.repeat);
                a.add(this.offset);
                if (0 > a.x || 1 < a.x)switch (this.wrapS) {
                    case 1E3:
                        a.x -= Math.floor(a.x);
                        break;
                    case 1001:
                        a.x = 0 > a.x ? 0 : 1;
                        break;
                    case 1002:
                        a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
                }
                if (0 > a.y || 1 < a.y)switch (this.wrapT) {
                    case 1E3:
                        a.y -= Math.floor(a.y);
                        break;
                    case 1001:
                        a.y =
                            0 > a.y ? 0 : 1;
                        break;
                    case 1002:
                        a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
                }
                this.flipY && (a.y = 1 - a.y)
            }
        }
    };
    Object.assign(ea.prototype, pa.prototype);
    fa.prototype = {
        constructor: fa, isVector4: !0, set: function (a, b, c, d) {
            this.x = a;
            this.y = b;
            this.z = c;
            this.w = d;
            return this
        }, setScalar: function (a) {
            this.w = this.z = this.y = this.x = a;
            return this
        }, setX: function (a) {
            this.x = a;
            return this
        }, setY: function (a) {
            this.y = a;
            return this
        }, setZ: function (a) {
            this.z = a;
            return this
        }, setW: function (a) {
            this.w = a;
            return this
        },
        setComponent: function (a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                case 3:
                    this.w = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
            return this
        }, getComponent: function (a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }, copy: function (a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w = void 0 !== a.w ?
                a.w : 1;
            return this
        }, add: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            this.w += a.w;
            return this
        }, addScalar: function (a) {
            this.x += a;
            this.y += a;
            this.z += a;
            this.w += a;
            return this
        }, addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this
        }, addScaledVector: function (a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            this.z += a.z * b;
            this.w += a.w * b;
            return this
        }, sub: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            this.w -= a.w;
            return this
        }, subScalar: function (a) {
            this.x -= a;
            this.y -= a;
            this.z -= a;
            this.w -= a;
            return this
        }, subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this
        }, multiplyScalar: function (a) {
            isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a, this.w *= a) : this.w = this.z =
                this.y = this.x = 0;
            return this
        }, applyMatrix4: function (a) {
            var b = this.x, c = this.y, d = this.z, e = this.w;
            a = a.elements;
            this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
            this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
            this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
            this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
            return this
        }, divideScalar: function (a) {
            return this.multiplyScalar(1 / a)
        }, setAxisAngleFromQuaternion: function (a) {
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
            return this
        },
        setAxisAngleFromRotationMatrix: function (a) {
            var b, c, d;
            a = a.elements;
            var e = a[0];
            d = a[4];
            var f = a[8], g = a[1], h = a[5], m = a[9];
            c = a[2];
            b = a[6];
            var k = a[10];
            if (.01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(m - b)) {
                if (.1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(m + b) && .1 > Math.abs(e + h + k - 3))return this.set(1, 0, 0, 0), this;
                a = Math.PI;
                e = (e + 1) / 2;
                h = (h + 1) / 2;
                k = (k + 1) / 2;
                d = (d + g) / 4;
                f = (f + c) / 4;
                m = (m + b) / 4;
                e > h && e > k ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > k ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h),
                    b = d / c, d = m / c) : .01 > k ? (c = b = .707106781, d = 0) : (d = Math.sqrt(k), b = f / d, c = m / d);
                this.set(b, c, d, a);
                return this
            }
            a = Math.sqrt((b - m) * (b - m) + (f - c) * (f - c) + (g - d) * (g - d));
            .001 > Math.abs(a) && (a = 1);
            this.x = (b - m) / a;
            this.y = (f - c) / a;
            this.z = (g - d) / a;
            this.w = Math.acos((e + h + k - 1) / 2);
            return this
        }, min: function (a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            this.z = Math.min(this.z, a.z);
            this.w = Math.min(this.w, a.w);
            return this
        }, max: function (a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            this.z = Math.max(this.z, a.z);
            this.w = Math.max(this.w, a.w);
            return this
        }, clamp: function (a, b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            this.z = Math.max(a.z, Math.min(b.z, this.z));
            this.w = Math.max(a.w, Math.min(b.w, this.w));
            return this
        }, clampScalar: function () {
            var a, b;
            return function (c, d) {
                void 0 === a && (a = new fa, b = new fa);
                a.set(c, c, c, c);
                b.set(d, d, d, d);
                return this.clamp(a, b)
            }
        }(), floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this
        }, ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this
        }, round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this
        }, roundToZero: function () {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
            return this
        }, negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this
        }, dot: function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }, lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }, normalize: function () {
            return this.divideScalar(this.length())
        },
        setLength: function (a) {
            return this.multiplyScalar(a / this.length())
        }, lerp: function (a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            this.w += (a.w - this.w) * b;
            return this
        }, lerpVectors: function (a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        }, equals: function (a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            this.w = a[b + 3];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a =
                []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            a[b + 3] = this.w;
            return a
        }, fromBufferAttribute: function (a, b, c) {
            void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b);
            this.y = a.getY(b);
            this.z = a.getZ(b);
            this.w = a.getW(b);
            return this
        }
    };
    Ya.prototype = {
        constructor: Ya, isWebGLRenderTarget: !0, setSize: function (a, b) {
            if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose();
            this.viewport.set(0, 0, a, b);
            this.scissor.set(0, 0, a,
                b)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.width = a.width;
            this.height = a.height;
            this.viewport.copy(a.viewport);
            this.texture = a.texture.clone();
            this.depthBuffer = a.depthBuffer;
            this.stencilBuffer = a.stencilBuffer;
            this.depthTexture = a.depthTexture;
            return this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    Object.assign(Ya.prototype, pa.prototype);
    Gb.prototype = Object.create(Ya.prototype);
    Gb.prototype.constructor = Gb;
    Gb.prototype.isWebGLRenderTargetCube = !0;
    ca.prototype = {
        constructor: ca, get x() {
            return this._x
        }, set x(a) {
            this._x = a;
            this.onChangeCallback()
        }, get y() {
            return this._y
        }, set y(a) {
            this._y = a;
            this.onChangeCallback()
        }, get z() {
            return this._z
        }, set z(a) {
            this._z = a;
            this.onChangeCallback()
        }, get w() {
            return this._w
        }, set w(a) {
            this._w = a;
            this.onChangeCallback()
        }, set: function (a, b, c, d) {
            this._x = a;
            this._y = b;
            this._z = c;
            this._w = d;
            this.onChangeCallback();
            return this
        }, clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }, copy: function (a) {
            this._x =
                a.x;
            this._y = a.y;
            this._z = a.z;
            this._w = a.w;
            this.onChangeCallback();
            return this
        }, setFromEuler: function (a, b) {
            if (!1 === (a && a.isEuler))throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2),
                g = Math.sin(a._y / 2), h = Math.sin(a._z / 2), m = a.order;
            "XYZ" === m ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === m ? (this._x = f * d * e + c * g * h, this._y = c * g *
                e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === m ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === m ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === m ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === m && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
            if (!1 !== b) this.onChangeCallback();
            return this
        }, setFromAxisAngle: function (a, b) {
            var c =
                b / 2, d = Math.sin(c);
            this._x = a.x * d;
            this._y = a.y * d;
            this._z = a.z * d;
            this._w = Math.cos(c);
            this.onChangeCallback();
            return this
        }, setFromRotationMatrix: function (a) {
            var b = a.elements, c = b[0];
            a = b[4];
            var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], m = b[6], b = b[10], k = c + f + b;
            0 < k ? (c = .5 / Math.sqrt(k + 1), this._w = .25 / c, this._x = (m - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (m - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c,
                this._z = (g + m) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + m) / c, this._z = .25 * c);
            this.onChangeCallback();
            return this
        }, setFromUnitVectors: function () {
            var a, b;
            return function (c, d) {
                void 0 === a && (a = new q);
                b = c.dot(d) + 1;
                1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
                this._x = a.x;
                this._y = a.y;
                this._z = a.z;
                this._w = b;
                return this.normalize()
            }
        }(), inverse: function () {
            return this.conjugate().normalize()
        }, conjugate: function () {
            this._x *= -1;
            this._y *=
                -1;
            this._z *= -1;
            this.onChangeCallback();
            return this
        }, dot: function (a) {
            return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
        }, lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }, length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }, normalize: function () {
            var a = this.length();
            0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
            this.onChangeCallback();
            return this
        }, multiply: function (a,
                               b) {
            return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
        }, premultiply: function (a) {
            return this.multiplyQuaternions(a, this)
        }, multiplyQuaternions: function (a, b) {
            var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, m = b._z, k = b._w;
            this._x = c * k + f * g + d * m - e * h;
            this._y = d * k + f * h + e * g - c * m;
            this._z = e * k + f * m + c * h - d * g;
            this._w = f * k - c * g - d * h - e * m;
            this.onChangeCallback();
            return this
        }, slerp: function (a,
                            b) {
            if (0 === b)return this;
            if (1 === b)return this.copy(a);
            var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
            0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
            if (1 <= g)return this._w = f, this._x = c, this._y = d, this._z = e, this;
            var h = Math.sqrt(1 - g * g);
            if (.001 > Math.abs(h))return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
            var m = Math.atan2(h, g), g = Math.sin((1 - b) * m) / h, h = Math.sin(b * m) / h;
            this._w = f * g + this._w * h;
            this._x =
                c * g + this._x * h;
            this._y = d * g + this._y * h;
            this._z = e * g + this._z * h;
            this.onChangeCallback();
            return this
        }, equals: function (a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this._x = a[b];
            this._y = a[b + 1];
            this._z = a[b + 2];
            this._w = a[b + 3];
            this.onChangeCallback();
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] = this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._w;
            return a
        }, onChange: function (a) {
            this.onChangeCallback = a;
            return this
        },
        onChangeCallback: function () {
        }
    };
    Object.assign(ca, {
        slerp: function (a, b, c, d) {
            return c.copy(a).slerp(b, d)
        }, slerpFlat: function (a, b, c, d, e, f, g) {
            var h = c[d + 0], m = c[d + 1], k = c[d + 2];
            c = c[d + 3];
            d = e[f + 0];
            var l = e[f + 1], p = e[f + 2];
            e = e[f + 3];
            if (c !== e || h !== d || m !== l || k !== p) {
                f = 1 - g;
                var n = h * d + m * l + k * p + c * e, u = 0 <= n ? 1 : -1, q = 1 - n * n;
                q > Number.EPSILON && (q = Math.sqrt(q), n = Math.atan2(q, n * u), f = Math.sin(f * n) / q, g = Math.sin(g * n) / q);
                u *= g;
                h = h * f + d * u;
                m = m * f + l * u;
                k = k * f + p * u;
                c = c * f + e * u;
                f === 1 - g && (g = 1 / Math.sqrt(h * h + m * m + k * k + c * c), h *= g, m *= g, k *= g, c *= g)
            }
            a[b] = h;
            a[b +
            1] = m;
            a[b + 2] = k;
            a[b + 3] = c
        }
    });
    q.prototype = {
        constructor: q, isVector3: !0, set: function (a, b, c) {
            this.x = a;
            this.y = b;
            this.z = c;
            return this
        }, setScalar: function (a) {
            this.z = this.y = this.x = a;
            return this
        }, setX: function (a) {
            this.x = a;
            return this
        }, setY: function (a) {
            this.y = a;
            return this
        }, setZ: function (a) {
            this.z = a;
            return this
        }, setComponent: function (a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
            return this
        }, getComponent: function (a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        }, copy: function (a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        }, add: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            return this
        }, addScalar: function (a) {
            this.x += a;
            this.y += a;
            this.z += a;
            return this
        },
        addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this
        }, addScaledVector: function (a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            this.z += a.z * b;
            return this
        }, sub: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this
        }, subScalar: function (a) {
            this.x -= a;
            this.y -= a;
            this.z -= a;
            return this
        }, subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z =
                a.z - b.z;
            return this
        }, multiply: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            return this
        }, multiplyScalar: function (a) {
            isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
            return this
        }, multiplyVectors: function (a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this
        }, applyEuler: function () {
            var a;
            return function (b) {
                !1 === (b &&
                b.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
                void 0 === a && (a = new ca);
                return this.applyQuaternion(a.setFromEuler(b))
            }
        }(), applyAxisAngle: function () {
            var a;
            return function (b, c) {
                void 0 === a && (a = new ca);
                return this.applyQuaternion(a.setFromAxisAngle(b, c))
            }
        }(), applyMatrix3: function (a) {
            var b = this.x, c = this.y, d = this.z;
            a = a.elements;
            this.x = a[0] * b + a[3] * c + a[6] * d;
            this.y = a[1] * b + a[4] * c + a[7] * d;
            this.z = a[2] * b + a[5] * c + a[8] * d;
            return this
        }, applyMatrix4: function (a) {
            var b =
                this.x, c = this.y, d = this.z;
            a = a.elements;
            this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
            this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
            this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
            return this.divideScalar(a[3] * b + a[7] * c + a[11] * d + a[15])
        }, applyQuaternion: function (a) {
            var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
            a = a.w;
            var h = a * b + f * d - g * c, m = a * c + g * b - e * d, k = a * d + e * c - f * b,
                b = -e * b - f * c - g * d;
            this.x = h * a + b * -e + m * -g - k * -f;
            this.y = m * a + b * -f + k * -e - h * -g;
            this.z = k * a + b * -g + h * -f - m * -e;
            return this
        }, project: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new S);
                a.multiplyMatrices(b.projectionMatrix,
                    a.getInverse(b.matrixWorld));
                return this.applyMatrix4(a)
            }
        }(), unproject: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new S);
                a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
                return this.applyMatrix4(a)
            }
        }(), transformDirection: function (a) {
            var b = this.x, c = this.y, d = this.z;
            a = a.elements;
            this.x = a[0] * b + a[4] * c + a[8] * d;
            this.y = a[1] * b + a[5] * c + a[9] * d;
            this.z = a[2] * b + a[6] * c + a[10] * d;
            return this.normalize()
        }, divide: function (a) {
            this.x /= a.x;
            this.y /= a.y;
            this.z /= a.z;
            return this
        }, divideScalar: function (a) {
            return this.multiplyScalar(1 /
                a)
        }, min: function (a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            this.z = Math.min(this.z, a.z);
            return this
        }, max: function (a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            this.z = Math.max(this.z, a.z);
            return this
        }, clamp: function (a, b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            this.z = Math.max(a.z, Math.min(b.z, this.z));
            return this
        }, clampScalar: function () {
            var a, b;
            return function (c, d) {
                void 0 === a && (a = new q, b = new q);
                a.set(c, c, c);
                b.set(d, d, d);
                return this.clamp(a,
                    b)
            }
        }(), clampLength: function (a, b) {
            var c = this.length();
            return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
        }, floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this
        }, ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this
        }, round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this
        }, roundToZero: function () {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            return this
        }, negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this
        }, dot: function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }, lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }, normalize: function () {
            return this.divideScalar(this.length())
        },
        setLength: function (a) {
            return this.multiplyScalar(a / this.length())
        }, lerp: function (a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            return this
        }, lerpVectors: function (a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        }, cross: function (a, b) {
            if (void 0 !== b)return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
            var c = this.x, d = this.y, e = this.z;
            this.x = d * a.z - e * a.y;
            this.y = e * a.x - c * a.z;
            this.z = c * a.y -
                d * a.x;
            return this
        }, crossVectors: function (a, b) {
            var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
            this.x = d * h - e * g;
            this.y = e * f - c * h;
            this.z = c * g - d * f;
            return this
        }, projectOnVector: function (a) {
            var b = a.dot(this) / a.lengthSq();
            return this.copy(a).multiplyScalar(b)
        }, projectOnPlane: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new q);
                a.copy(this).projectOnVector(b);
                return this.sub(a)
            }
        }(), reflect: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new q);
                return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
            }
        }(), angleTo: function (a) {
            a =
                this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
            return Math.acos(N.clamp(a, -1, 1))
        }, distanceTo: function (a) {
            return Math.sqrt(this.distanceToSquared(a))
        }, distanceToSquared: function (a) {
            var b = this.x - a.x, c = this.y - a.y;
            a = this.z - a.z;
            return b * b + c * c + a * a
        }, distanceToManhattan: function (a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
        }, setFromSpherical: function (a) {
            var b = Math.sin(a.phi) * a.radius;
            this.x = b * Math.sin(a.theta);
            this.y = Math.cos(a.phi) * a.radius;
            this.z = b * Math.cos(a.theta);
            return this
        },
        setFromCylindrical: function (a) {
            this.x = a.radius * Math.sin(a.theta);
            this.y = a.y;
            this.z = a.radius * Math.cos(a.theta);
            return this
        }, setFromMatrixPosition: function (a) {
            return this.setFromMatrixColumn(a, 3)
        }, setFromMatrixScale: function (a) {
            var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length();
            a = this.setFromMatrixColumn(a, 2).length();
            this.x = b;
            this.y = c;
            this.z = a;
            return this
        }, setFromMatrixColumn: function (a, b) {
            if ("number" === typeof a) {
                console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                var c = a;
                a = b;
                b = c
            }
            return this.fromArray(a.elements, 4 * b)
        }, equals: function (a) {
            return a.x === this.x && a.y === this.y && a.z === this.z
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            return a
        }, fromBufferAttribute: function (a, b, c) {
            void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b);
            this.y = a.getY(b);
            this.z = a.getZ(b);
            return this
        }
    };
    S.prototype = {
        constructor: S, isMatrix4: !0, set: function (a, b, c, d, e, f, g, h, m, k, l, p, n, u, q, r) {
            var A = this.elements;
            A[0] = a;
            A[4] = b;
            A[8] = c;
            A[12] = d;
            A[1] = e;
            A[5] = f;
            A[9] = g;
            A[13] = h;
            A[2] = m;
            A[6] = k;
            A[10] = l;
            A[14] = p;
            A[3] = n;
            A[7] = u;
            A[11] = q;
            A[15] = r;
            return this
        }, identity: function () {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this
        }, clone: function () {
            return (new S).fromArray(this.elements)
        }, copy: function (a) {
            this.elements.set(a.elements);
            return this
        }, copyPosition: function (a) {
            var b = this.elements;
            a = a.elements;
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            return this
        }, extractBasis: function (a, b, c) {
            a.setFromMatrixColumn(this, 0);
            b.setFromMatrixColumn(this, 1);
            c.setFromMatrixColumn(this, 2);
            return this
        }, makeBasis: function (a, b, c) {
            this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
            return this
        }, extractRotation: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new q);
                var c = this.elements, d = b.elements, e = 1 / a.setFromMatrixColumn(b, 0).length(),
                    f = 1 / a.setFromMatrixColumn(b, 1).length();
                b = 1 / a.setFromMatrixColumn(b, 2).length();
                c[0] = d[0] * e;
                c[1] = d[1] * e;
                c[2] = d[2] * e;
                c[4] = d[4] * f;
                c[5] = d[5] * f;
                c[6] = d[6] * f;
                c[8] = d[8] * b;
                c[9] = d[9] * b;
                c[10] = d[10] * b;
                return this
            }
        }(), makeRotationFromEuler: function (a) {
            !1 === (a && a.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d),
                d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
            if ("XYZ" === a.order) {
                a = f * h;
                var m = f * e, k = c * h, l = c * e;
                b[0] = g * h;
                b[4] = -g * e;
                b[8] = d;
                b[1] = m +
                    k * d;
                b[5] = a - l * d;
                b[9] = -c * g;
                b[2] = l - a * d;
                b[6] = k + m * d;
                b[10] = f * g
            } else"YXZ" === a.order ? (a = g * h, m = g * e, k = d * h, l = d * e, b[0] = a + l * c, b[4] = k * c - m, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = m * c - k, b[6] = l + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, m = g * e, k = d * h, l = d * e, b[0] = a - l * c, b[4] = -f * e, b[8] = k + m * c, b[1] = m + k * c, b[5] = f * h, b[9] = l - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, m = f * e, k = c * h, l = c * e, b[0] = g * h, b[4] = k * d - m, b[8] = a * d + l, b[1] = g * e, b[5] = l * d + a, b[9] = m * d - k, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, m = f * d, k = c * g, l = c * d, b[0] =
                g * h, b[4] = l - a * e, b[8] = k * e + m, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = m * e + k, b[10] = a - l * e) : "XZY" === a.order && (a = f * g, m = f * d, k = c * g, l = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + l, b[5] = f * h, b[9] = m * e - k, b[2] = k * e - m, b[6] = c * h, b[10] = l * e + a);
            b[3] = 0;
            b[7] = 0;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this
        }, makeRotationFromQuaternion: function (a) {
            var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, m = e + e;
            a = c * g;
            var k = c * h, c = c * m, l = d * h, d = d * m, e = e * m, g = f * g, h = f * h, f = f * m;
            b[0] = 1 - (l + e);
            b[4] = k - f;
            b[8] = c + h;
            b[1] = k + f;
            b[5] = 1 - (a + e);
            b[9] =
                d - g;
            b[2] = c - h;
            b[6] = d + g;
            b[10] = 1 - (a + l);
            b[3] = 0;
            b[7] = 0;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this
        }, lookAt: function () {
            var a, b, c;
            return function (d, e, f) {
                void 0 === a && (a = new q, b = new q, c = new q);
                var g = this.elements;
                c.subVectors(d, e).normalize();
                0 === c.lengthSq() && (c.z = 1);
                a.crossVectors(f, c).normalize();
                0 === a.lengthSq() && (c.z += 1E-4, a.crossVectors(f, c).normalize());
                b.crossVectors(c, a);
                g[0] = a.x;
                g[4] = b.x;
                g[8] = c.x;
                g[1] = a.y;
                g[5] = b.y;
                g[9] = c.y;
                g[2] = a.z;
                g[6] = b.z;
                g[10] = c.z;
                return this
            }
        }(), multiply: function (a, b) {
            return void 0 !==
            b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
        }, premultiply: function (a) {
            return this.multiplyMatrices(a, this)
        }, multiplyMatrices: function (a, b) {
            var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], m = c[12], k = c[1],
                l = c[5], p = c[9], n = c[13], u = c[2], q = c[6], r = c[10], A = c[14], w = c[3], y = c[7], K = c[11],
                c = c[15], v = d[0], E = d[4], L = d[8], C = d[12], F = d[1], x = d[5], H = d[9], D = d[13], z = d[2],
                J = d[6],
                I = d[10], Q = d[14], M = d[3], O = d[7], P = d[11], d = d[15];
            e[0] = f * v + g * F + h * z + m * M;
            e[4] = f * E + g * x + h * J + m * O;
            e[8] = f * L + g * H + h * I + m * P;
            e[12] = f * C + g * D + h * Q + m * d;
            e[1] = k * v + l * F + p * z + n * M;
            e[5] = k * E + l * x + p * J + n * O;
            e[9] = k * L + l * H + p * I + n * P;
            e[13] = k * C + l * D + p * Q + n * d;
            e[2] = u * v + q * F + r * z + A * M;
            e[6] = u * E + q * x + r * J + A * O;
            e[10] = u * L + q * H + r * I + A * P;
            e[14] = u * C + q * D + r * Q + A * d;
            e[3] = w * v + y * F + K * z + c * M;
            e[7] = w * E + y * x + K * J + c * O;
            e[11] = w * L + y * H + K * I + c * P;
            e[15] = w * C + y * D + K * Q + c * d;
            return this
        }, multiplyToArray: function (a, b, c) {
            var d = this.elements;
            this.multiplyMatrices(a, b);
            c[0] = d[0];
            c[1] = d[1];
            c[2] =
                d[2];
            c[3] = d[3];
            c[4] = d[4];
            c[5] = d[5];
            c[6] = d[6];
            c[7] = d[7];
            c[8] = d[8];
            c[9] = d[9];
            c[10] = d[10];
            c[11] = d[11];
            c[12] = d[12];
            c[13] = d[13];
            c[14] = d[14];
            c[15] = d[15];
            return this
        }, multiplyScalar: function (a) {
            var b = this.elements;
            b[0] *= a;
            b[4] *= a;
            b[8] *= a;
            b[12] *= a;
            b[1] *= a;
            b[5] *= a;
            b[9] *= a;
            b[13] *= a;
            b[2] *= a;
            b[6] *= a;
            b[10] *= a;
            b[14] *= a;
            b[3] *= a;
            b[7] *= a;
            b[11] *= a;
            b[15] *= a;
            return this
        }, applyToBufferAttribute: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new q);
                for (var c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c),
                    a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);
                return b
            }
        }(), determinant: function () {
            var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], m = a[13],
                k = a[2], l = a[6], p = a[10], n = a[14];
            return a[3] * (+e * h * l - d * m * l - e * g * p + c * m * p + d * g * n - c * h * n) + a[7] * (+b * h * n - b * m * p + e * f * p - d * f * n + d * m * k - e * h * k) + a[11] * (+b * m * l - b * g * n - e * f * l + c * f * n + e * g * k - c * m * k) + a[15] * (-d * g * k - b * h * l + b * g * p + d * f * l - c * f * p + c * h * k)
        }, transpose: function () {
            var a = this.elements, b;
            b = a[1];
            a[1] = a[4];
            a[4] = b;
            b = a[2];
            a[2] = a[8];
            a[8] = b;
            b = a[6];
            a[6] = a[9];
            a[9] = b;
            b = a[3];
            a[3] =
                a[12];
            a[12] = b;
            b = a[7];
            a[7] = a[13];
            a[13] = b;
            b = a[11];
            a[11] = a[14];
            a[14] = b;
            return this
        }, setPosition: function (a) {
            var b = this.elements;
            b[12] = a.x;
            b[13] = a.y;
            b[14] = a.z;
            return this
        }, getInverse: function (a, b) {
            var c = this.elements, d = a.elements, e = d[0], f = d[1], g = d[2], h = d[3], m = d[4], k = d[5], l = d[6],
                p = d[7], n = d[8], u = d[9], q = d[10], r = d[11], A = d[12], w = d[13], y = d[14], d = d[15],
                K = u * y * p - w * q * p + w * l * r - k * y * r - u * l * d + k * q * d,
                v = A * q * p - n * y * p - A * l * r + m * y * r + n * l * d - m * q * d,
                E = n * w * p - A * u * p + A * k * r - m * w * r - n * k * d + m * u * d,
                L = A * u * l - n * w * l - A * k * q + m * w * q + n * k * y - m * u * y, C = e * K +
                    f * v + g * E + h * L;
            if (0 === C) {
                if (!0 === b)throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                return this.identity()
            }
            C = 1 / C;
            c[0] = K * C;
            c[1] = (w * q * h - u * y * h - w * g * r + f * y * r + u * g * d - f * q * d) * C;
            c[2] = (k * y * h - w * l * h + w * g * p - f * y * p - k * g * d + f * l * d) * C;
            c[3] = (u * l * h - k * q * h - u * g * p + f * q * p + k * g * r - f * l * r) * C;
            c[4] = v * C;
            c[5] = (n * y * h - A * q * h + A * g * r - e * y * r - n * g * d + e * q * d) * C;
            c[6] = (A * l * h - m * y * h - A * g * p + e * y * p + m * g * d - e * l * d) * C;
            c[7] = (m * q * h - n * l * h + n * g * p - e * q * p - m * g *
                r + e * l * r) * C;
            c[8] = E * C;
            c[9] = (A * u * h - n * w * h - A * f * r + e * w * r + n * f * d - e * u * d) * C;
            c[10] = (m * w * h - A * k * h + A * f * p - e * w * p - m * f * d + e * k * d) * C;
            c[11] = (n * k * h - m * u * h - n * f * p + e * u * p + m * f * r - e * k * r) * C;
            c[12] = L * C;
            c[13] = (n * w * g - A * u * g + A * f * q - e * w * q - n * f * y + e * u * y) * C;
            c[14] = (A * k * g - m * w * g - A * f * l + e * w * l + m * f * y - e * k * y) * C;
            c[15] = (m * u * g - n * k * g + n * f * l - e * u * l - m * f * q + e * k * q) * C;
            return this
        }, scale: function (a) {
            var b = this.elements, c = a.x, d = a.y;
            a = a.z;
            b[0] *= c;
            b[4] *= d;
            b[8] *= a;
            b[1] *= c;
            b[5] *= d;
            b[9] *= a;
            b[2] *= c;
            b[6] *= d;
            b[10] *= a;
            b[3] *= c;
            b[7] *= d;
            b[11] *= a;
            return this
        }, getMaxScaleOnAxis: function () {
            var a =
                this.elements;
            return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
        }, makeTranslation: function (a, b, c) {
            this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
            return this
        }, makeRotationX: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
            return this
        }, makeRotationY: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
            return this
        }, makeRotationZ: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this
        }, makeRotationAxis: function (a, b) {
            var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, m = e * f, k = e * g;
            this.set(m * f + c, m * g - d * h, m * h + d * g, 0, m * g + d * h, k * g + c, k * h - d * f, 0, m * h - d * g, k * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
            return this
        }, makeScale: function (a, b, c) {
            this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
            return this
        }, makeShear: function (a, b, c) {
            this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
            return this
        }, compose: function (a, b, c) {
            this.makeRotationFromQuaternion(b);
            this.scale(c);
            this.setPosition(a);
            return this
        }, decompose: function () {
            var a, b;
            return function (c, d, e) {
                void 0 === a && (a = new q, b = new S);
                var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(),
                    m = a.set(f[8], f[9], f[10]).length();
                0 > this.determinant() && (g = -g);
                c.x = f[12];
                c.y = f[13];
                c.z = f[14];
                b.elements.set(this.elements);
                c = 1 / g;
                var f = 1 / h, k = 1 / m;
                b.elements[0] *= c;
                b.elements[1] *= c;
                b.elements[2] *= c;
                b.elements[4] *= f;
                b.elements[5] *= f;
                b.elements[6] *= f;
                b.elements[8] *= k;
                b.elements[9] *= k;
                b.elements[10] *= k;
                d.setFromRotationMatrix(b);
                e.x = g;
                e.y = h;
                e.z = m;
                return this
            }
        }(), makePerspective: function (a, b, c, d, e, f) {
            void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var g = this.elements;
            g[0] = 2 * e / (b - a);
            g[4] = 0;
            g[8] = (b + a) / (b - a);
            g[12] = 0;
            g[1] = 0;
            g[5] = 2 * e / (c - d);
            g[9] = (c + d) / (c - d);
            g[13] = 0;
            g[2] = 0;
            g[6] = 0;
            g[10] = -(f + e) / (f - e);
            g[14] = -2 * f * e / (f - e);
            g[3] = 0;
            g[7] = 0;
            g[11] = -1;
            g[15] = 0;
            return this
        }, makeOrthographic: function (a, b, c, d, e, f) {
            var g = this.elements, h = 1 / (b - a), m = 1 / (c - d), k = 1 / (f - e);
            g[0] =
                2 * h;
            g[4] = 0;
            g[8] = 0;
            g[12] = -((b + a) * h);
            g[1] = 0;
            g[5] = 2 * m;
            g[9] = 0;
            g[13] = -((c + d) * m);
            g[2] = 0;
            g[6] = 0;
            g[10] = -2 * k;
            g[14] = -((f + e) * k);
            g[3] = 0;
            g[7] = 0;
            g[11] = 0;
            g[15] = 1;
            return this
        }, equals: function (a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 16 > c; c++)if (b[c] !== a[c])return !1;
            return !0
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 16 > c; c++)this.elements[c] = a[c + b];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            var c = this.elements;
            a[b] = c[0];
            a[b + 1] = c[1];
            a[b + 2] = c[2];
            a[b + 3] = c[3];
            a[b + 4] = c[4];
            a[b + 5] = c[5];
            a[b + 6] = c[6];
            a[b + 7] = c[7];
            a[b + 8] = c[8];
            a[b + 9] = c[9];
            a[b + 10] = c[10];
            a[b + 11] = c[11];
            a[b + 12] = c[12];
            a[b + 13] = c[13];
            a[b + 14] = c[14];
            a[b + 15] = c[15];
            return a
        }
    };
    Za.prototype = Object.create(ea.prototype);
    Za.prototype.constructor = Za;
    Za.prototype.isCubeTexture = !0;
    Object.defineProperty(Za.prototype, "images", {
        get: function () {
            return this.image
        }, set: function (a) {
            this.image = a
        }
    });
    var Ee = new ea, Fe = new Za, Be = [], De = [];
    Je.prototype.setValue = function (a, b) {
        for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
            var f = c[d];
            f.setValue(a,
                b[f.id])
        }
    };
    var Rd = /([\w\d_]+)(\])?(\[|\.)?/g;
    $a.prototype.setValue = function (a, b, c) {
        b = this.map[b];
        void 0 !== b && b.setValue(a, c, this.renderer)
    };
    $a.prototype.set = function (a, b, c) {
        var d = this.map[c];
        void 0 !== d && d.setValue(a, b[c], this.renderer)
    };
    $a.prototype.setOptional = function (a, b, c) {
        b = b[c];
        void 0 !== b && this.setValue(a, c, b)
    };
    $a.upload = function (a, b, c, d) {
        for (var e = 0, f = b.length; e !== f; ++e) {
            var g = b[e], h = c[g.id];
            !1 !== h.needsUpdate && g.setValue(a, h.value, d)
        }
    };
    $a.seqWithValue = function (a, b) {
        for (var c = [], d = 0, e = a.length; d !==
        e; ++d) {
            var f = a[d];
            f.id in b && c.push(f)
        }
        return c
    };
    var Ja = {
        merge: function (a) {
            for (var b = {}, c = 0; c < a.length; c++) {
                var d = this.clone(a[c]), e;
                for (e in d)b[e] = d[e]
            }
            return b
        }, clone: function (a) {
            var b = {}, c;
            for (c in a) {
                b[c] = {};
                for (var d in a[c]) {
                    var e = a[c][d];
                    e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e
                }
            }
            return b
        }
    }, Z = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex: "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_flip: "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
        normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex: "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
        distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
        equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
        shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
    };
    J.prototype = {
        constructor: J,
        isColor: !0, r: 1, g: 1, b: 1, set: function (a) {
            a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
            return this
        }, setScalar: function (a) {
            this.b = this.g = this.r = a;
            return this
        }, setHex: function (a) {
            a = Math.floor(a);
            this.r = (a >> 16 & 255) / 255;
            this.g = (a >> 8 & 255) / 255;
            this.b = (a & 255) / 255;
            return this
        }, setRGB: function (a, b, c) {
            this.r = a;
            this.g = b;
            this.b = c;
            return this
        }, setHSL: function () {
            function a(a, c, d) {
                0 > d && (d += 1);
                1 < d && --d;
                return d < 1 / 6 ? a + 6 * (c - a) * d : .5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a
            }

            return function (b,
                             c, d) {
                b = N.euclideanModulo(b, 1);
                c = N.clamp(c, 0, 1);
                d = N.clamp(d, 0, 1);
                0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3));
                return this
            }
        }(), setStyle: function (a) {
            function b(b) {
                void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
            }

            var c;
            if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                var d = c[2];
                switch (c[1]) {
                    case "rgb":
                    case "rgba":
                        if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r =
                            Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
                        if (c = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                            var d = parseFloat(c[1]) /
                                360, e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100;
                            b(c[5]);
                            return this.setHSL(d, e, f)
                        }
                }
            } else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
                c = c[1];
                d = c.length;
                if (3 === d)return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                if (6 === d)return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
            }
            a && 0 < a.length && (c = Wf[a], void 0 !==
            c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a));
            return this
        }, clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        }, copy: function (a) {
            this.r = a.r;
            this.g = a.g;
            this.b = a.b;
            return this
        }, copyGammaToLinear: function (a, b) {
            void 0 === b && (b = 2);
            this.r = Math.pow(a.r, b);
            this.g = Math.pow(a.g, b);
            this.b = Math.pow(a.b, b);
            return this
        }, copyLinearToGamma: function (a, b) {
            void 0 === b && (b = 2);
            var c = 0 < b ? 1 / b : 1;
            this.r = Math.pow(a.r, c);
            this.g = Math.pow(a.g, c);
            this.b = Math.pow(a.b, c);
            return this
        }, convertGammaToLinear: function () {
            var a =
                this.r, b = this.g, c = this.b;
            this.r = a * a;
            this.g = b * b;
            this.b = c * c;
            return this
        }, convertLinearToGamma: function () {
            this.r = Math.sqrt(this.r);
            this.g = Math.sqrt(this.g);
            this.b = Math.sqrt(this.b);
            return this
        }, getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }, getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }, getHSL: function (a) {
            a = a || {h: 0, s: 0, l: 0};
            var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2;
            if (f === e) f = g = 0; else {
                var m = e - f, f = .5 >= h ? m / (e + f) :
                    m / (2 - e - f);
                switch (e) {
                    case b:
                        g = (c - d) / m + (c < d ? 6 : 0);
                        break;
                    case c:
                        g = (d - b) / m + 2;
                        break;
                    case d:
                        g = (b - c) / m + 4
                }
                g /= 6
            }
            a.h = g;
            a.s = f;
            a.l = h;
            return a
        }, getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }, offsetHSL: function (a, b, c) {
            var d = this.getHSL();
            d.h += a;
            d.s += b;
            d.l += c;
            this.setHSL(d.h, d.s, d.l);
            return this
        }, add: function (a) {
            this.r += a.r;
            this.g += a.g;
            this.b += a.b;
            return this
        }, addColors: function (a, b) {
            this.r = a.r + b.r;
            this.g = a.g + b.g;
            this.b = a.b + b.b;
            return this
        }, addScalar: function (a) {
            this.r +=
                a;
            this.g += a;
            this.b += a;
            return this
        }, sub: function (a) {
            this.r = Math.max(0, this.r - a.r);
            this.g = Math.max(0, this.g - a.g);
            this.b = Math.max(0, this.b - a.b);
            return this
        }, multiply: function (a) {
            this.r *= a.r;
            this.g *= a.g;
            this.b *= a.b;
            return this
        }, multiplyScalar: function (a) {
            this.r *= a;
            this.g *= a;
            this.b *= a;
            return this
        }, lerp: function (a, b) {
            this.r += (a.r - this.r) * b;
            this.g += (a.g - this.g) * b;
            this.b += (a.b - this.b) * b;
            return this
        }, equals: function (a) {
            return a.r === this.r && a.g === this.g && a.b === this.b
        }, fromArray: function (a, b) {
            void 0 === b && (b =
                0);
            this.r = a[b];
            this.g = a[b + 1];
            this.b = a[b + 2];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.r;
            a[b + 1] = this.g;
            a[b + 2] = this.b;
            return a
        }, toJSON: function () {
            return this.getHex()
        }
    };
    var Wf = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    eb.prototype = Object.create(ea.prototype);
    eb.prototype.constructor = eb;
    eb.prototype.isDataTexture = !0;
    var V = {
        common: {
            diffuse: {value: new J(15658734)},
            opacity: {value: 1},
            map: {value: null},
            offsetRepeat: {
                value: new fa(0,
                    0, 1, 1)
            },
            specularMap: {value: null},
            alphaMap: {value: null},
            envMap: {value: null},
            flipEnvMap: {value: -1},
            reflectivity: {value: 1},
            refractionRatio: {value: .98}
        },
        aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
        lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
        emissivemap: {emissiveMap: {value: null}},
        bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
        normalmap: {normalMap: {value: null}, normalScale: {value: new D(1, 1)}},
        displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}},
        roughnessmap: {roughnessMap: {value: null}},
        metalnessmap: {metalnessMap: {value: null}},
        gradientmap: {gradientMap: {value: null}},
        fog: {
            fogDensity: {value: 2.5E-4},
            fogNear: {value: 1},
            fogFar: {value: 2E3},
            fogColor: {value: new J(16777215)}
        },
        lights: {
            ambientLightColor: {value: []},
            directionalLights: {
                value: [],
                properties: {direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}}
            },
            directionalShadowMap: {value: []},
            directionalShadowMatrix: {value: []},
            spotLights: {
                value: [], properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {value: []},
            spotShadowMatrix: {value: []},
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            pointShadowMap: {value: []},
            pointShadowMatrix: {value: []},
            hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
            rectAreaLights: {
                value: [], properties: {
                    color: {}, position: {},
                    width: {}, height: {}
                }
            }
        },
        points: {
            diffuse: {value: new J(15658734)},
            opacity: {value: 1},
            size: {value: 1},
            scale: {value: 1},
            map: {value: null},
            offsetRepeat: {value: new fa(0, 0, 1, 1)}
        }
    }, bb = {
        basic: {
            uniforms: Ja.merge([V.common, V.aomap, V.lightmap, V.fog]),
            vertexShader: Z.meshbasic_vert,
            fragmentShader: Z.meshbasic_frag
        },
        lambert: {
            uniforms: Ja.merge([V.common, V.aomap, V.lightmap, V.emissivemap, V.fog, V.lights, {emissive: {value: new J(0)}}]),
            vertexShader: Z.meshlambert_vert,
            fragmentShader: Z.meshlambert_frag
        },
        phong: {
            uniforms: Ja.merge([V.common,
                V.aomap, V.lightmap, V.emissivemap, V.bumpmap, V.normalmap, V.displacementmap, V.gradientmap, V.fog, V.lights, {
                    emissive: {value: new J(0)},
                    specular: {value: new J(1118481)},
                    shininess: {value: 30}
                }]), vertexShader: Z.meshphong_vert, fragmentShader: Z.meshphong_frag
        },
        standard: {
            uniforms: Ja.merge([V.common, V.aomap, V.lightmap, V.emissivemap, V.bumpmap, V.normalmap, V.displacementmap, V.roughnessmap, V.metalnessmap, V.fog, V.lights, {
                emissive: {value: new J(0)},
                roughness: {value: .5},
                metalness: {value: 0},
                envMapIntensity: {value: 1}
            }]),
            vertexShader: Z.meshphysical_vert, fragmentShader: Z.meshphysical_frag
        },
        points: {uniforms: Ja.merge([V.points, V.fog]), vertexShader: Z.points_vert, fragmentShader: Z.points_frag},
        dashed: {
            uniforms: Ja.merge([V.common, V.fog, {
                scale: {value: 1},
                dashSize: {value: 1},
                totalSize: {value: 2}
            }]), vertexShader: Z.linedashed_vert, fragmentShader: Z.linedashed_frag
        },
        depth: {
            uniforms: Ja.merge([V.common, V.displacementmap]),
            vertexShader: Z.depth_vert,
            fragmentShader: Z.depth_frag
        },
        normal: {
            uniforms: Ja.merge([V.common, V.bumpmap, V.normalmap,
                V.displacementmap, {opacity: {value: 1}}]), vertexShader: Z.normal_vert, fragmentShader: Z.normal_frag
        },
        cube: {
            uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
            vertexShader: Z.cube_vert,
            fragmentShader: Z.cube_frag
        },
        equirect: {
            uniforms: {tEquirect: {value: null}, tFlip: {value: -1}},
            vertexShader: Z.equirect_vert,
            fragmentShader: Z.equirect_frag
        },
        distanceRGBA: {
            uniforms: {lightPos: {value: new q}},
            vertexShader: Z.distanceRGBA_vert,
            fragmentShader: Z.distanceRGBA_frag
        }
    };
    bb.physical = {
        uniforms: Ja.merge([bb.standard.uniforms,
            {clearCoat: {value: 0}, clearCoatRoughness: {value: 0}}]),
        vertexShader: Z.meshphysical_vert,
        fragmentShader: Z.meshphysical_frag
    };
    sc.prototype = {
        constructor: sc, set: function (a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this
        }, setFromPoints: function (a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]);
            return this
        }, setFromCenterAndSize: function () {
            var a = new D;
            return function (b, c) {
                var d = a.copy(c).multiplyScalar(.5);
                this.min.copy(b).sub(d);
                this.max.copy(b).add(d);
                return this
            }
        }(), clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this
        }, makeEmpty: function () {
            this.min.x = this.min.y = Infinity;
            this.max.x = this.max.y = -Infinity;
            return this
        }, isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }, getCenter: function (a) {
            a = a || new D;
            return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
        }, getSize: function (a) {
            a = a || new D;
            return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
        }, expandByPoint: function (a) {
            this.min.min(a);
            this.max.max(a);
            return this
        }, expandByVector: function (a) {
            this.min.sub(a);
            this.max.add(a);
            return this
        }, expandByScalar: function (a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this
        }, containsPoint: function (a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
        }, containsBox: function (a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
        }, getParameter: function (a, b) {
            return (b || new D).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y -
                this.min.y))
        }, intersectsBox: function (a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
        }, clampPoint: function (a, b) {
            return (b || new D).copy(a).clamp(this.min, this.max)
        }, distanceToPoint: function () {
            var a = new D;
            return function (b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length()
            }
        }(), intersect: function (a) {
            this.min.max(a.min);
            this.max.min(a.max);
            return this
        }, union: function (a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this
        }, translate: function (a) {
            this.min.add(a);
            this.max.add(a);
            return this
        }, equals: function (a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
    };
    var Af = 0;
    X.prototype = {
        constructor: X, isMaterial: !0, get needsUpdate() {
            return this._needsUpdate
        }, set needsUpdate(a) {
            !0 === a && this.update();
            this._needsUpdate = a
        }, setValues: function (a) {
            if (void 0 !== a)for (var b in a) {
                var c = a[b];
                if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined."); else {
                    var d = this[b];
                    void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") :
                        d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c
                }
            }
        }, toJSON: function (a) {
            function b(a) {
                var b = [], c;
                for (c in a) {
                    var d = a[c];
                    delete d.metadata;
                    b.push(d)
                }
                return b
            }

            var c = void 0 === a;
            c && (a = {textures: {}, images: {}});
            var d = {metadata: {version: 4.4, type: "Material", generator: "Material.toJSON"}};
            d.uuid = this.uuid;
            d.type = this.type;
            "" !== this.name && (d.name = this.name);
            this.color && this.color.isColor && (d.color = this.color.getHex());
            void 0 !== this.roughness && (d.roughness = this.roughness);
            void 0 !== this.metalness && (d.metalness = this.metalness);
            this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex());
            this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
            void 0 !== this.shininess && (d.shininess = this.shininess);
            void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat);
            void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness);
            this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
            this.alphaMap && this.alphaMap.isTexture && (d.alphaMap =
                this.alphaMap.toJSON(a).uuid);
            this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid);
            this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
            this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray());
            this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias =
                this.displacementBias);
            this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
            this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
            this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
            this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
            this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity);
            this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
            void 0 !== this.size && (d.size = this.size);
            void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
            1 !== this.blending && (d.blending = this.blending);
            2 !== this.shading && (d.shading = this.shading);
            0 !== this.side && (d.side = this.side);
            0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
            1 > this.opacity && (d.opacity = this.opacity);
            !0 === this.transparent && (d.transparent = this.transparent);
            d.depthFunc = this.depthFunc;
            d.depthTest = this.depthTest;
            d.depthWrite = this.depthWrite;
            0 < this.alphaTest && (d.alphaTest = this.alphaTest);
            !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha);
            !0 === this.wireframe && (d.wireframe = this.wireframe);
            1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
            "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap);
            "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
            d.skinning = this.skinning;
            d.morphTargets = this.morphTargets;
            c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
            return d
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.name = a.name;
            this.fog = a.fog;
            this.lights = a.lights;
            this.blending = a.blending;
            this.side = a.side;
            this.shading = a.shading;
            this.vertexColors = a.vertexColors;
            this.opacity = a.opacity;
            this.transparent = a.transparent;
            this.blendSrc = a.blendSrc;
            this.blendDst = a.blendDst;
            this.blendEquation = a.blendEquation;
            this.blendSrcAlpha = a.blendSrcAlpha;
            this.blendDstAlpha =
                a.blendDstAlpha;
            this.blendEquationAlpha = a.blendEquationAlpha;
            this.depthFunc = a.depthFunc;
            this.depthTest = a.depthTest;
            this.depthWrite = a.depthWrite;
            this.colorWrite = a.colorWrite;
            this.precision = a.precision;
            this.polygonOffset = a.polygonOffset;
            this.polygonOffsetFactor = a.polygonOffsetFactor;
            this.polygonOffsetUnits = a.polygonOffsetUnits;
            this.alphaTest = a.alphaTest;
            this.premultipliedAlpha = a.premultipliedAlpha;
            this.overdraw = a.overdraw;
            this.visible = a.visible;
            this.clipShadows = a.clipShadows;
            this.clipIntersection = a.clipIntersection;
            a = a.clippingPlanes;
            var b = null;
            if (null !== a)for (var c = a.length, b = Array(c), d = 0; d !== c; ++d)b[d] = a[d].clone();
            this.clippingPlanes = b;
            return this
        }, update: function () {
            this.dispatchEvent({type: "update"})
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    Object.assign(X.prototype, pa.prototype);
    Ha.prototype = Object.create(X.prototype);
    Ha.prototype.constructor = Ha;
    Ha.prototype.isShaderMaterial = !0;
    Ha.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.fragmentShader = a.fragmentShader;
        this.vertexShader =
            a.vertexShader;
        this.uniforms = Ja.clone(a.uniforms);
        this.defines = a.defines;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.lights = a.lights;
        this.clipping = a.clipping;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        this.extensions = a.extensions;
        return this
    };
    Ha.prototype.toJSON = function (a) {
        a = X.prototype.toJSON.call(this, a);
        a.uniforms = this.uniforms;
        a.vertexShader = this.vertexShader;
        a.fragmentShader = this.fragmentShader;
        return a
    };
    ab.prototype =
        Object.create(X.prototype);
    ab.prototype.constructor = ab;
    ab.prototype.isMeshDepthMaterial = !0;
    ab.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.depthPacking = a.depthPacking;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.map = a.map;
        this.alphaMap = a.alphaMap;
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        return this
    };
    Pa.prototype =
        {
            constructor: Pa, isBox3: !0, set: function (a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this
        }, setFromArray: function (a) {
            for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0,
                     m = a.length; h < m; h += 3) {
                var k = a[h], l = a[h + 1], p = a[h + 2];
                k < b && (b = k);
                l < c && (c = l);
                p < d && (d = p);
                k > e && (e = k);
                l > f && (f = l);
                p > g && (g = p)
            }
            this.min.set(b, c, d);
            this.max.set(e, f, g);
            return this
        }, setFromBufferAttribute: function (a) {
            for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0,
                     m = a.count; h < m; h++) {
                var k =
                    a.getX(h), l = a.getY(h), p = a.getZ(h);
                k < b && (b = k);
                l < c && (c = l);
                p < d && (d = p);
                k > e && (e = k);
                l > f && (f = l);
                p > g && (g = p)
            }
            this.min.set(b, c, d);
            this.max.set(e, f, g);
            return this
        }, setFromPoints: function (a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]);
            return this
        }, setFromCenterAndSize: function () {
            var a = new q;
            return function (b, c) {
                var d = a.copy(c).multiplyScalar(.5);
                this.min.copy(b).sub(d);
                this.max.copy(b).add(d);
                return this
            }
        }(), setFromObject: function (a) {
            this.makeEmpty();
            return this.expandByObject(a)
        },
            clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this
        }, makeEmpty: function () {
            this.min.x = this.min.y = this.min.z = Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this
        }, isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }, getCenter: function (a) {
            a = a || new q;
            return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
        }, getSize: function (a) {
            a = a || new q;
            return this.isEmpty() ?
                a.set(0, 0, 0) : a.subVectors(this.max, this.min)
        }, expandByPoint: function (a) {
            this.min.min(a);
            this.max.max(a);
            return this
        }, expandByVector: function (a) {
            this.min.sub(a);
            this.max.add(a);
            return this
        }, expandByScalar: function (a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this
        }, expandByObject: function () {
            var a = new q;
            return function (b) {
                var c = this;
                b.updateMatrixWorld(!0);
                b.traverse(function (b) {
                    var e, f;
                    e = b.geometry;
                    if (void 0 !== e)if (e.isGeometry) {
                        var g = e.vertices;
                        e = 0;
                        for (f = g.length; e < f; e++)a.copy(g[e]), a.applyMatrix4(b.matrixWorld),
                            c.expandByPoint(a)
                    } else if (e.isBufferGeometry && (g = e.attributes.position, void 0 !== g))for (e = 0, f = g.count; e < f; e++)a.fromBufferAttribute(g, e).applyMatrix4(b.matrixWorld), c.expandByPoint(a)
                });
                return this
            }
        }(), containsPoint: function (a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
        }, containsBox: function (a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
        }, getParameter: function (a,
                                   b) {
            return (b || new q).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
        }, intersectsBox: function (a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
        }, intersectsSphere: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new q);
                this.clampPoint(b.center, a);
                return a.distanceToSquared(b.center) <= b.radius * b.radius
            }
        }(), intersectsPlane: function (a) {
            var b,
                c;
            0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x);
            0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y);
            0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z);
            return b <= a.constant && c >= a.constant
        }, clampPoint: function (a, b) {
            return (b || new q).copy(a).clamp(this.min, this.max)
        }, distanceToPoint: function () {
            var a = new q;
            return function (b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length()
            }
        }(), getBoundingSphere: function () {
            var a = new q;
            return function (b) {
                b = b || new Na;
                this.getCenter(b.center);
                b.radius = .5 * this.getSize(a).length();
                return b
            }
        }(), intersect: function (a) {
            this.min.max(a.min);
            this.max.min(a.max);
            this.isEmpty() && this.makeEmpty();
            return this
        }, union: function (a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this
        }, applyMatrix4: function () {
            var a = [new q, new q, new q, new q, new q, new q, new q, new q];
            return function (b) {
                if (this.isEmpty())return this;
                a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
                a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
                a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
                a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
                a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
                a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
                a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
                a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
                this.setFromPoints(a);
                return this
            }
        }(),
            translate: function (a) {
                this.min.add(a);
                this.max.add(a);
                return this
            }, equals: function (a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
        };
    Na.prototype = {
        constructor: Na, set: function (a, b) {
            this.center.copy(a);
            this.radius = b;
            return this
        }, setFromPoints: function () {
            var a;
            return function (b, c) {
                void 0 === a && (a = new Pa);
                var d = this.center;
                void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
                for (var e = 0, f = 0, g = b.length; f < g; f++)e = Math.max(e, d.distanceToSquared(b[f]));
                this.radius = Math.sqrt(e);
                return this
            }
        }(), clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (a) {
            this.center.copy(a.center);
            this.radius = a.radius;
            return this
        }, empty: function () {
            return 0 >= this.radius
        }, containsPoint: function (a) {
            return a.distanceToSquared(this.center) <= this.radius * this.radius
        }, distanceToPoint: function (a) {
            return a.distanceTo(this.center) - this.radius
        }, intersectsSphere: function (a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b
        }, intersectsBox: function (a) {
            return a.intersectsSphere(this)
        }, intersectsPlane: function (a) {
            return Math.abs(this.center.dot(a.normal) -
                    a.constant) <= this.radius
        }, clampPoint: function (a, b) {
            var c = this.center.distanceToSquared(a), d = b || new q;
            d.copy(a);
            c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
            return d
        }, getBoundingBox: function (a) {
            a = a || new Pa;
            a.set(this.center, this.center);
            a.expandByScalar(this.radius);
            return a
        }, applyMatrix4: function (a) {
            this.center.applyMatrix4(a);
            this.radius *= a.getMaxScaleOnAxis();
            return this
        }, translate: function (a) {
            this.center.add(a);
            return this
        }, equals: function (a) {
            return a.center.equals(this.center) &&
                a.radius === this.radius
        }
    };
    ya.prototype = {
        constructor: ya, isMatrix3: !0, set: function (a, b, c, d, e, f, g, h, m) {
            var k = this.elements;
            k[0] = a;
            k[1] = d;
            k[2] = g;
            k[3] = b;
            k[4] = e;
            k[5] = h;
            k[6] = c;
            k[7] = f;
            k[8] = m;
            return this
        }, identity: function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this
        }, clone: function () {
            return (new this.constructor).fromArray(this.elements)
        }, copy: function (a) {
            a = a.elements;
            this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
            return this
        }, setFromMatrix4: function (a) {
            a = a.elements;
            this.set(a[0], a[4], a[8], a[1], a[5], a[9],
                a[2], a[6], a[10]);
            return this
        }, applyToBufferAttribute: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new q);
                for (var c = 0,
                         d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);
                return b
            }
        }(), multiplyScalar: function (a) {
            var b = this.elements;
            b[0] *= a;
            b[3] *= a;
            b[6] *= a;
            b[1] *= a;
            b[4] *= a;
            b[7] *= a;
            b[2] *= a;
            b[5] *= a;
            b[8] *= a;
            return this
        }, determinant: function () {
            var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], m = a[7],
                a = a[8];
            return b * f * a - b * g * m - c * e *
                a + c * g * h + d * e * m - d * f * h
        }, getInverse: function (a, b) {
            a && a.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
            var c = a.elements, d = this.elements, e = c[0], f = c[1], g = c[2], h = c[3], m = c[4], k = c[5], l = c[6],
                p = c[7], c = c[8], n = c * m - k * p, u = k * l - c * h, q = p * h - m * l, r = e * n + f * u + g * q;
            if (0 === r) {
                if (!0 === b)throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
                console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
                return this.identity()
            }
            r = 1 / r;
            d[0] = n * r;
            d[1] = (g * p - c * f) * r;
            d[2] = (k * f - g * m) * r;
            d[3] = u * r;
            d[4] = (c * e - g * l) * r;
            d[5] = (g * h - k * e) * r;
            d[6] = q * r;
            d[7] = (f * l - p * e) * r;
            d[8] = (m * e - f * h) * r;
            return this
        }, transpose: function () {
            var a, b = this.elements;
            a = b[1];
            b[1] = b[3];
            b[3] = a;
            a = b[2];
            b[2] = b[6];
            b[6] = a;
            a = b[5];
            b[5] = b[7];
            b[7] = a;
            return this
        }, getNormalMatrix: function (a) {
            return this.setFromMatrix4(a).getInverse(this).transpose()
        }, transposeIntoArray: function (a) {
            var b = this.elements;
            a[0] = b[0];
            a[1] = b[3];
            a[2] = b[6];
            a[3] = b[1];
            a[4] = b[4];
            a[5] = b[7];
            a[6] = b[2];
            a[7] = b[5];
            a[8] = b[8];
            return this
        },
        fromArray: function (a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 9 > c; c++)this.elements[c] = a[c + b];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            var c = this.elements;
            a[b] = c[0];
            a[b + 1] = c[1];
            a[b + 2] = c[2];
            a[b + 3] = c[3];
            a[b + 4] = c[4];
            a[b + 5] = c[5];
            a[b + 6] = c[6];
            a[b + 7] = c[7];
            a[b + 8] = c[8];
            return a
        }
    };
    la.prototype = {
        constructor: la, set: function (a, b) {
            this.normal.copy(a);
            this.constant = b;
            return this
        }, setComponents: function (a, b, c, d) {
            this.normal.set(a, b, c);
            this.constant = d;
            return this
        }, setFromNormalAndCoplanarPoint: function (a,
                                                    b) {
            this.normal.copy(a);
            this.constant = -b.dot(this.normal);
            return this
        }, setFromCoplanarPoints: function () {
            var a = new q, b = new q;
            return function (c, d, e) {
                d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
                this.setFromNormalAndCoplanarPoint(d, c);
                return this
            }
        }(), clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.normal.copy(a.normal);
            this.constant = a.constant;
            return this
        }, normalize: function () {
            var a = 1 / this.normal.length();
            this.normal.multiplyScalar(a);
            this.constant *= a;
            return this
        },
        negate: function () {
            this.constant *= -1;
            this.normal.negate();
            return this
        }, distanceToPoint: function (a) {
            return this.normal.dot(a) + this.constant
        }, distanceToSphere: function (a) {
            return this.distanceToPoint(a.center) - a.radius
        }, projectPoint: function (a, b) {
            return this.orthoPoint(a, b).sub(a).negate()
        }, orthoPoint: function (a, b) {
            var c = this.distanceToPoint(a);
            return (b || new q).copy(this.normal).multiplyScalar(c)
        }, intersectLine: function () {
            var a = new q;
            return function (b, c) {
                var d = c || new q, e = b.delta(a), f = this.normal.dot(e);
                if (0 === f) {
                    if (0 === this.distanceToPoint(b.start))return d.copy(b.start)
                } else return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)
            }
        }(), intersectsLine: function (a) {
            var b = this.distanceToPoint(a.start);
            a = this.distanceToPoint(a.end);
            return 0 > b && 0 < a || 0 > a && 0 < b
        }, intersectsBox: function (a) {
            return a.intersectsPlane(this)
        }, intersectsSphere: function (a) {
            return a.intersectsPlane(this)
        }, coplanarPoint: function (a) {
            return (a || new q).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function () {
            var a = new q, b = new ya;
            return function (c, d) {
                var e = this.coplanarPoint(a).applyMatrix4(c), f = d || b.getNormalMatrix(c),
                    f = this.normal.applyMatrix3(f).normalize();
                this.constant = -e.dot(f);
                return this
            }
        }(), translate: function (a) {
            this.constant -= a.dot(this.normal);
            return this
        }, equals: function (a) {
            return a.normal.equals(this.normal) && a.constant === this.constant
        }
    };
    tc.prototype = {
        constructor: tc, set: function (a, b, c, d, e, f) {
            var g = this.planes;
            g[0].copy(a);
            g[1].copy(b);
            g[2].copy(c);
            g[3].copy(d);
            g[4].copy(e);
            g[5].copy(f);
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            for (var b = this.planes, c = 0; 6 > c; c++)b[c].copy(a.planes[c]);
            return this
        }, setFromMatrix: function (a) {
            var b = this.planes, c = a.elements;
            a = c[0];
            var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], m = c[6], k = c[7], l = c[8], p = c[9], n = c[10],
                u = c[11], q = c[12], r = c[13], A = c[14], c = c[15];
            b[0].setComponents(f - a, k - g, u - l, c - q).normalize();
            b[1].setComponents(f + a, k + g, u + l, c + q).normalize();
            b[2].setComponents(f + d, k + h, u + p, c + r).normalize();
            b[3].setComponents(f -
                d, k - h, u - p, c - r).normalize();
            b[4].setComponents(f - e, k - m, u - n, c - A).normalize();
            b[5].setComponents(f + e, k + m, u + n, c + A).normalize();
            return this
        }, intersectsObject: function () {
            var a = new Na;
            return function (b) {
                var c = b.geometry;
                null === c.boundingSphere && c.computeBoundingSphere();
                a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);
                return this.intersectsSphere(a)
            }
        }(), intersectsSprite: function () {
            var a = new Na;
            return function (b) {
                a.center.set(0, 0, 0);
                a.radius = .7071067811865476;
                a.applyMatrix4(b.matrixWorld);
                return this.intersectsSphere(a)
            }
        }(),
        intersectsSphere: function (a) {
            var b = this.planes, c = a.center;
            a = -a.radius;
            for (var d = 0; 6 > d; d++)if (b[d].distanceToPoint(c) < a)return !1;
            return !0
        }, intersectsBox: function () {
            var a = new q, b = new q;
            return function (c) {
                for (var d = this.planes, e = 0; 6 > e; e++) {
                    var f = d[e];
                    a.x = 0 < f.normal.x ? c.min.x : c.max.x;
                    b.x = 0 < f.normal.x ? c.max.x : c.min.x;
                    a.y = 0 < f.normal.y ? c.min.y : c.max.y;
                    b.y = 0 < f.normal.y ? c.max.y : c.min.y;
                    a.z = 0 < f.normal.z ? c.min.z : c.max.z;
                    b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                    var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
                    if (0 >
                        g && 0 > f)return !1
                }
                return !0
            }
        }(), containsPoint: function (a) {
            for (var b = this.planes, c = 0; 6 > c; c++)if (0 > b[c].distanceToPoint(a))return !1;
            return !0
        }
    };
    cb.prototype = {
        constructor: cb, set: function (a, b) {
            this.origin.copy(a);
            this.direction.copy(b);
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.origin.copy(a.origin);
            this.direction.copy(a.direction);
            return this
        }, at: function (a, b) {
            return (b || new q).copy(this.direction).multiplyScalar(a).add(this.origin)
        }, lookAt: function (a) {
            this.direction.copy(a).sub(this.origin).normalize();
            return this
        }, recast: function () {
            var a = new q;
            return function (b) {
                this.origin.copy(this.at(b, a));
                return this
            }
        }(), closestPointToPoint: function (a, b) {
            var c = b || new q;
            c.subVectors(a, this.origin);
            var d = c.dot(this.direction);
            return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
        }, distanceToPoint: function (a) {
            return Math.sqrt(this.distanceSqToPoint(a))
        }, distanceSqToPoint: function () {
            var a = new q;
            return function (b) {
                var c = a.subVectors(b, this.origin).dot(this.direction);
                if (0 > c)return this.origin.distanceToSquared(b);
                a.copy(this.direction).multiplyScalar(c).add(this.origin);
                return a.distanceToSquared(b)
            }
        }(), distanceSqToSegment: function () {
            var a = new q, b = new q, c = new q;
            return function (d, e, f, g) {
                a.copy(d).add(e).multiplyScalar(.5);
                b.copy(e).sub(d).normalize();
                c.copy(this.origin).sub(a);
                var h = .5 * d.distanceTo(e), m = -this.direction.dot(b), k = c.dot(this.direction), l = -c.dot(b),
                    p = c.lengthSq(), n = Math.abs(1 - m * m), u;
                0 < n ? (d = m * l - k, e = m * k - l, u = h * n, 0 <= d ? e >= -u ? e <= u ? (h = 1 / n, d *= h, e *= h, m = d * (d + m * e + 2 * k) + e * (m * d + e + 2 * l) + p) : (e = h, d = Math.max(0, -(m *
                e + k)), m = -d * d + e * (e + 2 * l) + p) : (e = -h, d = Math.max(0, -(m * e + k)), m = -d * d + e * (e + 2 * l) + p) : e <= -u ? (d = Math.max(0, -(-m * h + k)), e = 0 < d ? -h : Math.min(Math.max(-h, -l), h), m = -d * d + e * (e + 2 * l) + p) : e <= u ? (d = 0, e = Math.min(Math.max(-h, -l), h), m = e * (e + 2 * l) + p) : (d = Math.max(0, -(m * h + k)), e = 0 < d ? h : Math.min(Math.max(-h, -l), h), m = -d * d + e * (e + 2 * l) + p)) : (e = 0 < m ? -h : h, d = Math.max(0, -(m * e + k)), m = -d * d + e * (e + 2 * l) + p);
                f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
                g && g.copy(b).multiplyScalar(e).add(a);
                return m
            }
        }(), intersectSphere: function () {
            var a = new q;
            return function (b, c) {
                a.subVectors(b.center, this.origin);
                var d = a.dot(this.direction), e = a.dot(a) - d * d, f = b.radius * b.radius;
                if (e > f)return null;
                f = Math.sqrt(f - e);
                e = d - f;
                d += f;
                return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c)
            }
        }(), intersectsSphere: function (a) {
            return this.distanceToPoint(a.center) <= a.radius
        }, distanceToPlane: function (a) {
            var b = a.normal.dot(this.direction);
            if (0 === b)return 0 === a.distanceToPoint(this.origin) ? 0 : null;
            a = -(this.origin.dot(a.normal) + a.constant) / b;
            return 0 <= a ? a : null
        }, intersectPlane: function (a,
                                     b) {
            var c = this.distanceToPlane(a);
            return null === c ? null : this.at(c, b)
        }, intersectsPlane: function (a) {
            var b = a.distanceToPoint(this.origin);
            return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
        }, intersectBox: function (a, b) {
            var c, d, e, f, g;
            d = 1 / this.direction.x;
            f = 1 / this.direction.y;
            g = 1 / this.direction.z;
            var h = this.origin;
            0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
            0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
            if (c > f || e > d)return null;
            if (e > c || c !== c) c = e;
            if (f < d || d !== d) d = f;
            0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);
            if (c > g || e > d)return null;
            if (e > c || c !== c) c = e;
            if (g < d || d !== d) d = g;
            return 0 > d ? null : this.at(0 <= c ? c : d, b)
        }, intersectsBox: function () {
            var a = new q;
            return function (b) {
                return null !== this.intersectBox(b, a)
            }
        }(), intersectTriangle: function () {
            var a = new q, b = new q, c = new q, d = new q;
            return function (e, f, g, h, m) {
                b.subVectors(f, e);
                c.subVectors(g, e);
                d.crossVectors(b, c);
                f = this.direction.dot(d);
                if (0 < f) {
                    if (h)return null;
                    h = 1
                } else if (0 > f) h =
                    -1, f = -f; else return null;
                a.subVectors(this.origin, e);
                e = h * this.direction.dot(c.crossVectors(a, c));
                if (0 > e)return null;
                g = h * this.direction.dot(b.cross(a));
                if (0 > g || e + g > f)return null;
                e = -h * a.dot(d);
                return 0 > e ? null : this.at(e / f, m)
            }
        }(), applyMatrix4: function (a) {
            this.direction.add(this.origin).applyMatrix4(a);
            this.origin.applyMatrix4(a);
            this.direction.sub(this.origin);
            this.direction.normalize();
            return this
        }, equals: function (a) {
            return a.origin.equals(this.origin) && a.direction.equals(this.direction)
        }
    };
    db.RotationOrders =
        "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
    db.DefaultOrder = "XYZ";
    db.prototype = {
        constructor: db, isEuler: !0, get x() {
            return this._x
        }, set x(a) {
            this._x = a;
            this.onChangeCallback()
        }, get y() {
            return this._y
        }, set y(a) {
            this._y = a;
            this.onChangeCallback()
        }, get z() {
            return this._z
        }, set z(a) {
            this._z = a;
            this.onChangeCallback()
        }, get order() {
            return this._order
        }, set order(a) {
            this._order = a;
            this.onChangeCallback()
        }, set: function (a, b, c, d) {
            this._x = a;
            this._y = b;
            this._z = c;
            this._order = d || this._order;
            this.onChangeCallback();
            return this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }, copy: function (a) {
            this._x = a._x;
            this._y = a._y;
            this._z = a._z;
            this._order = a._order;
            this.onChangeCallback();
            return this
        }, setFromRotationMatrix: function (a, b, c) {
            var d = N.clamp, e = a.elements;
            a = e[0];
            var f = e[4], g = e[8], h = e[1], m = e[5], k = e[9], l = e[2], p = e[6], e = e[10];
            b = b || this._order;
            "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-k, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(p, m), this._z = 0)) : "YXZ" ===
            b ? (this._x = Math.asin(-d(k, -1, 1)), .99999 > Math.abs(k) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, m)) : (this._y = Math.atan2(-l, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(p, -1, 1)), .99999 > Math.abs(p) ? (this._y = Math.atan2(-l, e), this._z = Math.atan2(-f, m)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(p, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, m))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x =
                Math.atan2(-k, m), this._y = Math.atan2(-l, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(p, m), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-k, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
            this._order = b;
            if (!1 !== c) this.onChangeCallback();
            return this
        }, setFromQuaternion: function () {
            var a;
            return function (b, c, d) {
                void 0 === a && (a = new S);
                a.makeRotationFromQuaternion(b);
                return this.setFromRotationMatrix(a,
                    c, d)
            }
        }(), setFromVector3: function (a, b) {
            return this.set(a.x, a.y, a.z, b || this._order)
        }, reorder: function () {
            var a = new ca;
            return function (b) {
                a.setFromEuler(this);
                return this.setFromQuaternion(a, b)
            }
        }(), equals: function (a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
        }, fromArray: function (a) {
            this._x = a[0];
            this._y = a[1];
            this._z = a[2];
            void 0 !== a[3] && (this._order = a[3]);
            this.onChangeCallback();
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] =
                this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._order;
            return a
        }, toVector3: function (a) {
            return a ? a.set(this._x, this._y, this._z) : new q(this._x, this._y, this._z)
        }, onChange: function (a) {
            this.onChangeCallback = a;
            return this
        }, onChangeCallback: function () {
        }
    };
    nd.prototype = {
        constructor: nd, set: function (a) {
            this.mask = 1 << a
        }, enable: function (a) {
            this.mask |= 1 << a
        }, toggle: function (a) {
            this.mask ^= 1 << a
        }, disable: function (a) {
            this.mask &= ~(1 << a)
        }, test: function (a) {
            return 0 !== (this.mask & a.mask)
        }
    };
    var Bf = 0;
    x.DefaultUp = new q(0, 1, 0);
    x.DefaultMatrixAutoUpdate =
        !0;
    x.prototype = {
        constructor: x, isObject3D: !0, applyMatrix: function (a) {
            this.matrix.multiplyMatrices(a, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }, setRotationFromAxisAngle: function (a, b) {
            this.quaternion.setFromAxisAngle(a, b)
        }, setRotationFromEuler: function (a) {
            this.quaternion.setFromEuler(a, !0)
        }, setRotationFromMatrix: function (a) {
            this.quaternion.setFromRotationMatrix(a)
        }, setRotationFromQuaternion: function (a) {
            this.quaternion.copy(a)
        }, rotateOnAxis: function () {
            var a = new ca;
            return function (b,
                             c) {
                a.setFromAxisAngle(b, c);
                this.quaternion.multiply(a);
                return this
            }
        }(), rotateX: function () {
            var a = new q(1, 0, 0);
            return function (b) {
                return this.rotateOnAxis(a, b)
            }
        }(), rotateY: function () {
            var a = new q(0, 1, 0);
            return function (b) {
                return this.rotateOnAxis(a, b)
            }
        }(), rotateZ: function () {
            var a = new q(0, 0, 1);
            return function (b) {
                return this.rotateOnAxis(a, b)
            }
        }(), translateOnAxis: function () {
            var a = new q;
            return function (b, c) {
                a.copy(b).applyQuaternion(this.quaternion);
                this.position.add(a.multiplyScalar(c));
                return this
            }
        }(),
        translateX: function () {
            var a = new q(1, 0, 0);
            return function (b) {
                return this.translateOnAxis(a, b)
            }
        }(), translateY: function () {
            var a = new q(0, 1, 0);
            return function (b) {
                return this.translateOnAxis(a, b)
            }
        }(), translateZ: function () {
            var a = new q(0, 0, 1);
            return function (b) {
                return this.translateOnAxis(a, b)
            }
        }(), localToWorld: function (a) {
            return a.applyMatrix4(this.matrixWorld)
        }, worldToLocal: function () {
            var a = new S;
            return function (b) {
                return b.applyMatrix4(a.getInverse(this.matrixWorld))
            }
        }(), lookAt: function () {
            var a = new S;
            return function (b) {
                a.lookAt(b,
                    this.position, this.up);
                this.quaternion.setFromRotationMatrix(a)
            }
        }(), add: function (a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++)this.add(arguments[b]);
                return this
            }
            if (a === this)return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
            a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type: "added"}), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
            return this
        }, remove: function (a) {
            if (1 <
                arguments.length)for (var b = 0; b < arguments.length; b++)this.remove(arguments[b]);
            b = this.children.indexOf(a);
            -1 !== b && (a.parent = null, a.dispatchEvent({type: "removed"}), this.children.splice(b, 1))
        }, getObjectById: function (a) {
            return this.getObjectByProperty("id", a)
        }, getObjectByName: function (a) {
            return this.getObjectByProperty("name", a)
        }, getObjectByProperty: function (a, b) {
            if (this[a] === b)return this;
            for (var c = 0, d = this.children.length; c < d; c++) {
                var e = this.children[c].getObjectByProperty(a, b);
                if (void 0 !== e)return e
            }
        },
        getWorldPosition: function (a) {
            a = a || new q;
            this.updateMatrixWorld(!0);
            return a.setFromMatrixPosition(this.matrixWorld)
        }, getWorldQuaternion: function () {
            var a = new q, b = new q;
            return function (c) {
                c = c || new ca;
                this.updateMatrixWorld(!0);
                this.matrixWorld.decompose(a, c, b);
                return c
            }
        }(), getWorldRotation: function () {
            var a = new ca;
            return function (b) {
                b = b || new db;
                this.getWorldQuaternion(a);
                return b.setFromQuaternion(a, this.rotation.order, !1)
            }
        }(), getWorldScale: function () {
            var a = new q, b = new ca;
            return function (c) {
                c = c || new q;
                this.updateMatrixWorld(!0);
                this.matrixWorld.decompose(a, b, c);
                return c
            }
        }(), getWorldDirection: function () {
            var a = new ca;
            return function (b) {
                b = b || new q;
                this.getWorldQuaternion(a);
                return b.set(0, 0, 1).applyQuaternion(a)
            }
        }(), raycast: function () {
        }, traverse: function (a) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverse(a)
        }, traverseVisible: function (a) {
            if (!1 !== this.visible) {
                a(this);
                for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverseVisible(a)
            }
        }, traverseAncestors: function (a) {
            var b = this.parent;
            null !== b && (a(b), b.traverseAncestors(a))
        }, updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = !0
        }, updateMatrixWorld: function (a) {
            !0 === this.matrixAutoUpdate && this.updateMatrix();
            if (!0 === this.matrixWorldNeedsUpdate || !0 === a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
            for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].updateMatrixWorld(a)
        },
        toJSON: function (a) {
            function b(a) {
                var b = [], c;
                for (c in a) {
                    var d = a[c];
                    delete d.metadata;
                    b.push(d)
                }
                return b
            }

            var c = void 0 === a || "" === a, d = {};
            c && (a = {geometries: {}, materials: {}, textures: {}, images: {}}, d.metadata = {
                version: 4.4,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var e = {};
            e.uuid = this.uuid;
            e.type = this.type;
            "" !== this.name && (e.name = this.name);
            "{}" !== JSON.stringify(this.userData) && (e.userData = this.userData);
            !0 === this.castShadow && (e.castShadow = !0);
            !0 === this.receiveShadow && (e.receiveShadow = !0);
            !1 === this.visible &&
            (e.visible = !1);
            e.matrix = this.matrix.toArray();
            void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)), e.geometry = this.geometry.uuid);
            void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)), e.material = this.material.uuid);
            if (0 < this.children.length) {
                e.children = [];
                for (var f = 0; f < this.children.length; f++)e.children.push(this.children[f].toJSON(a).object)
            }
            if (c) {
                var c =
                    b(a.geometries), f = b(a.materials), g = b(a.textures);
                a = b(a.images);
                0 < c.length && (d.geometries = c);
                0 < f.length && (d.materials = f);
                0 < g.length && (d.textures = g);
                0 < a.length && (d.images = a)
            }
            d.object = e;
            return d
        }, clone: function (a) {
            return (new this.constructor).copy(this, a)
        }, copy: function (a, b) {
            void 0 === b && (b = !0);
            this.name = a.name;
            this.up.copy(a.up);
            this.position.copy(a.position);
            this.quaternion.copy(a.quaternion);
            this.scale.copy(a.scale);
            this.matrix.copy(a.matrix);
            this.matrixWorld.copy(a.matrixWorld);
            this.matrixAutoUpdate =
                a.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
            this.layers.mask = a.layers.mask;
            this.visible = a.visible;
            this.castShadow = a.castShadow;
            this.receiveShadow = a.receiveShadow;
            this.frustumCulled = a.frustumCulled;
            this.renderOrder = a.renderOrder;
            this.userData = JSON.parse(JSON.stringify(a.userData));
            if (!0 === b)for (var c = 0; c < a.children.length; c++)this.add(a.children[c].clone());
            return this
        }
    };
    Object.assign(x.prototype, pa.prototype);
    hb.prototype = {
        constructor: hb, set: function (a, b) {
            this.start.copy(a);
            this.end.copy(b);
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.start.copy(a.start);
            this.end.copy(a.end);
            return this
        }, getCenter: function (a) {
            return (a || new q).addVectors(this.start, this.end).multiplyScalar(.5)
        }, delta: function (a) {
            return (a || new q).subVectors(this.end, this.start)
        }, distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        }, distance: function () {
            return this.start.distanceTo(this.end)
        }, at: function (a, b) {
            var c = b || new q;
            return this.delta(c).multiplyScalar(a).add(this.start)
        },
        closestPointToPointParameter: function () {
            var a = new q, b = new q;
            return function (c, d) {
                a.subVectors(c, this.start);
                b.subVectors(this.end, this.start);
                var e = b.dot(b), e = b.dot(a) / e;
                d && (e = N.clamp(e, 0, 1));
                return e
            }
        }(), closestPointToPoint: function (a, b, c) {
            a = this.closestPointToPointParameter(a, b);
            c = c || new q;
            return this.delta(c).multiplyScalar(a).add(this.start)
        }, applyMatrix4: function (a) {
            this.start.applyMatrix4(a);
            this.end.applyMatrix4(a);
            return this
        }, equals: function (a) {
            return a.start.equals(this.start) && a.end.equals(this.end)
        }
    };
    za.normal = function () {
        var a = new q;
        return function (b, c, d, e) {
            e = e || new q;
            e.subVectors(d, c);
            a.subVectors(b, c);
            e.cross(a);
            b = e.lengthSq();
            return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
        }
    }();
    za.barycoordFromPoint = function () {
        var a = new q, b = new q, c = new q;
        return function (d, e, f, g, h) {
            a.subVectors(g, e);
            b.subVectors(f, e);
            c.subVectors(d, e);
            d = a.dot(a);
            e = a.dot(b);
            f = a.dot(c);
            var m = b.dot(b);
            g = b.dot(c);
            var k = d * m - e * e;
            h = h || new q;
            if (0 === k)return h.set(-2, -1, -1);
            k = 1 / k;
            m = (m * f - e * g) * k;
            d = (d * g - e * f) * k;
            return h.set(1 - m -
                d, d, m)
        }
    }();
    za.containsPoint = function () {
        var a = new q;
        return function (b, c, d, e) {
            b = za.barycoordFromPoint(b, c, d, e, a);
            return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
        }
    }();
    za.prototype = {
        constructor: za, set: function (a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this
        }, setFromPointsAndIndices: function (a, b, c, d) {
            this.a.copy(a[b]);
            this.b.copy(a[c]);
            this.c.copy(a[d]);
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.a.copy(a.a);
            this.b.copy(a.b);
            this.c.copy(a.c);
            return this
        },
        area: function () {
            var a = new q, b = new q;
            return function () {
                a.subVectors(this.c, this.b);
                b.subVectors(this.a, this.b);
                return .5 * a.cross(b).length()
            }
        }(), midpoint: function (a) {
            return (a || new q).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }, normal: function (a) {
            return za.normal(this.a, this.b, this.c, a)
        }, plane: function (a) {
            return (a || new la).setFromCoplanarPoints(this.a, this.b, this.c)
        }, barycoordFromPoint: function (a, b) {
            return za.barycoordFromPoint(a, this.a, this.b, this.c, b)
        }, containsPoint: function (a) {
            return za.containsPoint(a,
                this.a, this.b, this.c)
        }, closestPointToPoint: function () {
            var a, b, c, d;
            return function (e, f) {
                void 0 === a && (a = new la, b = [new hb, new hb, new hb], c = new q, d = new q);
                var g = f || new q, h = Infinity;
                a.setFromCoplanarPoints(this.a, this.b, this.c);
                a.projectPoint(e, c);
                if (!0 === this.containsPoint(c)) g.copy(c); else {
                    b[0].set(this.a, this.b);
                    b[1].set(this.b, this.c);
                    b[2].set(this.c, this.a);
                    for (var m = 0; m < b.length; m++) {
                        b[m].closestPointToPoint(c, !0, d);
                        var k = c.distanceToSquared(d);
                        k < h && (h = k, g.copy(d))
                    }
                }
                return g
            }
        }(), equals: function (a) {
            return a.a.equals(this.a) &&
                a.b.equals(this.b) && a.c.equals(this.c)
        }
    };
    ha.prototype = {
        constructor: ha, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.normal.copy(a.normal);
            this.color.copy(a.color);
            this.materialIndex = a.materialIndex;
            for (var b = 0, c = a.vertexNormals.length; b < c; b++)this.vertexNormals[b] = a.vertexNormals[b].clone();
            b = 0;
            for (c = a.vertexColors.length; b < c; b++)this.vertexColors[b] = a.vertexColors[b].clone();
            return this
        }
    };
    Ka.prototype = Object.create(X.prototype);
    Ka.prototype.constructor =
        Ka;
    Ka.prototype.isMeshBasicMaterial = !0;
    Ka.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        return this
    };
    U.prototype = {
        constructor: U, isBufferAttribute: !0, set needsUpdate(a) {
            !0 === a && this.version++
        }, setArray: function (a) {
            if (Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== a ? a.length / this.itemSize : 0;
            this.array = a
        }, setDynamic: function (a) {
            this.dynamic = a;
            return this
        }, copy: function (a) {
            this.array =
                new a.array.constructor(a.array);
            this.itemSize = a.itemSize;
            this.count = a.count;
            this.normalized = a.normalized;
            this.dynamic = a.dynamic;
            return this
        }, copyAt: function (a, b, c) {
            a *= this.itemSize;
            c *= b.itemSize;
            for (var d = 0, e = this.itemSize; d < e; d++)this.array[a + d] = b.array[c + d];
            return this
        }, copyArray: function (a) {
            this.array.set(a);
            return this
        }, copyColorsArray: function (a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",
                    d), f = new J);
                b[c++] = f.r;
                b[c++] = f.g;
                b[c++] = f.b
            }
            return this
        }, copyIndicesArray: function (a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                b[c++] = f.a;
                b[c++] = f.b;
                b[c++] = f.c
            }
            return this
        }, copyVector2sArray: function (a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new D);
                b[c++] = f.x;
                b[c++] = f.y
            }
            return this
        }, copyVector3sArray: function (a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f =
                    a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new q);
                b[c++] = f.x;
                b[c++] = f.y;
                b[c++] = f.z
            }
            return this
        }, copyVector4sArray: function (a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new fa);
                b[c++] = f.x;
                b[c++] = f.y;
                b[c++] = f.z;
                b[c++] = f.w
            }
            return this
        }, set: function (a, b) {
            void 0 === b && (b = 0);
            this.array.set(a, b);
            return this
        }, getX: function (a) {
            return this.array[a *
            this.itemSize]
        }, setX: function (a, b) {
            this.array[a * this.itemSize] = b;
            return this
        }, getY: function (a) {
            return this.array[a * this.itemSize + 1]
        }, setY: function (a, b) {
            this.array[a * this.itemSize + 1] = b;
            return this
        }, getZ: function (a) {
            return this.array[a * this.itemSize + 2]
        }, setZ: function (a, b) {
            this.array[a * this.itemSize + 2] = b;
            return this
        }, getW: function (a) {
            return this.array[a * this.itemSize + 3]
        }, setW: function (a, b) {
            this.array[a * this.itemSize + 3] = b;
            return this
        }, setXY: function (a, b, c) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a +
            1] = c;
            return this
        }, setXYZ: function (a, b, c, d) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            this.array[a + 2] = d;
            return this
        }, setXYZW: function (a, b, c, d, e) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            this.array[a + 2] = d;
            this.array[a + 3] = e;
            return this
        }, onUpload: function (a) {
            this.onUploadCallback = a;
            return this
        }, clone: function () {
            return (new this.constructor(this.array, this.itemSize)).copy(this)
        }
    };
    uc.prototype = Object.create(U.prototype);
    uc.prototype.constructor = uc;
    vc.prototype = Object.create(U.prototype);
    vc.prototype.constructor = vc;
    wc.prototype = Object.create(U.prototype);
    wc.prototype.constructor = wc;
    xc.prototype = Object.create(U.prototype);
    xc.prototype.constructor = xc;
    ib.prototype = Object.create(U.prototype);
    ib.prototype.constructor = ib;
    yc.prototype = Object.create(U.prototype);
    yc.prototype.constructor = yc;
    jb.prototype = Object.create(U.prototype);
    jb.prototype.constructor = jb;
    z.prototype = Object.create(U.prototype);
    z.prototype.constructor = z;
    zc.prototype = Object.create(U.prototype);
    zc.prototype.constructor = zc;
    Object.assign(Me.prototype, {
        computeGroups: function (a) {
            var b, c = [], d = void 0;
            a = a.faces;
            for (var e = 0; e < a.length; e++) {
                var f = a[e];
                f.materialIndex !== d && (d = f.materialIndex, void 0 !== b && (b.count = 3 * e - b.start, c.push(b)), b = {
                    start: 3 * e,
                    materialIndex: d
                })
            }
            void 0 !== b && (b.count = 3 * e - b.start, c.push(b));
            this.groups = c
        }, fromGeometry: function (a) {
            var b = a.faces, c = a.vertices, d = a.faceVertexUvs, e = d[0] && 0 < d[0].length,
                f = d[1] && 0 < d[1].length, g = a.morphTargets, h = g.length, m;
            if (0 < h) {
                m = [];
                for (var k = 0; k < h; k++)m[k] = [];
                this.morphTargets.position =
                    m
            }
            var l = a.morphNormals, p = l.length, n;
            if (0 < p) {
                n = [];
                for (k = 0; k < p; k++)n[k] = [];
                this.morphTargets.normal = n
            }
            for (var u = a.skinIndices, q = a.skinWeights, r = u.length === c.length, A = q.length === c.length,
                     k = 0; k < b.length; k++) {
                var w = b[k];
                this.vertices.push(c[w.a], c[w.b], c[w.c]);
                var y = w.vertexNormals;
                3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = w.normal, this.normals.push(y, y, y));
                y = w.vertexColors;
                3 === y.length ? this.colors.push(y[0], y[1], y[2]) : (y = w.color, this.colors.push(y, y, y));
                !0 === e && (y = d[0][k], void 0 !== y ? this.uvs.push(y[0],
                    y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", k), this.uvs.push(new D, new D, new D)));
                !0 === f && (y = d[1][k], void 0 !== y ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", k), this.uvs2.push(new D, new D, new D)));
                for (y = 0; y < h; y++) {
                    var K = g[y].vertices;
                    m[y].push(K[w.a], K[w.b], K[w.c])
                }
                for (y = 0; y < p; y++)K = l[y].vertexNormals[k], n[y].push(K.a, K.b, K.c);
                r && this.skinIndices.push(u[w.a], u[w.b], u[w.c]);
                A && this.skinWeights.push(q[w.a],
                    q[w.b], q[w.c])
            }
            this.computeGroups(a);
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            return this
        }
    });
    var Vd = 0;
    T.prototype = {
        constructor: T, isGeometry: !0, applyMatrix: function (a) {
            for (var b = (new ya).getNormalMatrix(a), c = 0,
                     d = this.vertices.length; c < d; c++)this.vertices[c].applyMatrix4(a);
            c = 0;
            for (d = this.faces.length; c < d; c++) {
                a = this.faces[c];
                a.normal.applyMatrix3(b).normalize();
                for (var e = 0, f = a.vertexNormals.length; e < f; e++)a.vertexNormals[e].applyMatrix3(b).normalize()
            }
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
            return this
        }, rotateX: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new S);
                a.makeRotationX(b);
                this.applyMatrix(a);
                return this
            }
        }(), rotateY: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new S);
                a.makeRotationY(b);
                this.applyMatrix(a);
                return this
            }
        }(),
        rotateZ: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new S);
                a.makeRotationZ(b);
                this.applyMatrix(a);
                return this
            }
        }(), translate: function () {
            var a;
            return function (b, c, d) {
                void 0 === a && (a = new S);
                a.makeTranslation(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(), scale: function () {
            var a;
            return function (b, c, d) {
                void 0 === a && (a = new S);
                a.makeScale(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(), lookAt: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new x);
                a.lookAt(b);
                a.updateMatrix();
                this.applyMatrix(a.matrix)
            }
        }(),
        fromBufferGeometry: function (a) {
            function b(a, b, d, e) {
                var f = void 0 !== g ? [l[a].clone(), l[b].clone(), l[d].clone()] : [],
                    u = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : [];
                e = new ha(a, b, d, f, u, e);
                c.faces.push(e);
                void 0 !== m && c.faceVertexUvs[0].push([p[a].clone(), p[b].clone(), p[d].clone()]);
                void 0 !== k && c.faceVertexUvs[1].push([n[a].clone(), n[b].clone(), n[d].clone()])
            }

            var c = this, d = null !== a.index ? a.index.array : void 0, e = a.attributes, f = e.position.array,
                g = void 0 !== e.normal ? e.normal.array :
                    void 0, h = void 0 !== e.color ? e.color.array : void 0, m = void 0 !== e.uv ? e.uv.array : void 0,
                k = void 0 !== e.uv2 ? e.uv2.array : void 0;
            void 0 !== k && (this.faceVertexUvs[1] = []);
            for (var l = [], p = [], n = [],
                     u = e = 0; e < f.length; e += 3, u += 2)c.vertices.push(new q(f[e], f[e + 1], f[e + 2])), void 0 !== g && l.push(new q(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new J(h[e], h[e + 1], h[e + 2])), void 0 !== m && p.push(new D(m[u], m[u + 1])), void 0 !== k && n.push(new D(k[u], k[u + 1]));
            if (void 0 !== d)if (f = a.groups, 0 < f.length)for (e = 0; e < f.length; e++)for (var G = f[e],
                                                                                                   r = G.start,
                                                                                                   A = G.count, u = r,
                                                                                                   r = r + A; u < r; u += 3)b(d[u], d[u + 1], d[u + 2], G.materialIndex); else for (e = 0; e < d.length; e += 3)b(d[e], d[e + 1], d[e + 2]); else for (e = 0; e < f.length / 3; e += 3)b(e, e + 1, e + 2);
            this.computeFaceNormals();
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
            return this
        }, center: function () {
            this.computeBoundingBox();
            var a = this.boundingBox.getCenter().negate();
            this.translate(a.x, a.y, a.z);
            return a
        }, normalize: function () {
            this.computeBoundingSphere();
            var a = this.boundingSphere.center, b = this.boundingSphere.radius, b = 0 === b ? 1 : 1 / b, c = new S;
            c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
            this.applyMatrix(c);
            return this
        }, computeFaceNormals: function () {
            for (var a = new q, b = new q, c = 0, d = this.faces.length; c < d; c++) {
                var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
                a.subVectors(this.vertices[e.c], g);
                b.subVectors(f, g);
                a.cross(b);
                a.normalize();
                e.normal.copy(a)
            }
        }, computeVertexNormals: function (a) {
            void 0 === a && (a = !0);
            var b, c, d;
            d = Array(this.vertices.length);
            b = 0;
            for (c = this.vertices.length; b < c; b++)d[b] = new q;
            if (a) {
                var e, f, g, h = new q, m = new q;
                a = 0;
                for (b = this.faces.length; a < b; a++)c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), m.subVectors(e, f), h.cross(m), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
            } else for (this.computeFaceNormals(), a = 0, b = this.faces.length; a < b; a++)c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
            b = 0;
            for (c = this.vertices.length; b < c; b++)d[b].normalize();
            a = 0;
            for (b = this.faces.length; a <
            b; a++)c = this.faces[a], e = c.vertexNormals, 3 === e.length ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c])) : (e[0] = d[c.a].clone(), e[1] = d[c.b].clone(), e[2] = d[c.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        }, computeFlatVertexNormals: function () {
            var a, b, c;
            this.computeFaceNormals();
            a = 0;
            for (b = this.faces.length; a < b; a++) {
                c = this.faces[a];
                var d = c.vertexNormals;
                3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone())
            }
            0 <
            this.faces.length && (this.normalsNeedUpdate = !0)
        }, computeMorphNormals: function () {
            var a, b, c, d, e;
            c = 0;
            for (d = this.faces.length; c < d; c++)for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++)e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
            var f = new T;
            f.faces =
                this.faces;
            a = 0;
            for (b = this.morphTargets.length; a < b; a++) {
                if (!this.morphNormals[a]) {
                    this.morphNormals[a] = {};
                    this.morphNormals[a].faceNormals = [];
                    this.morphNormals[a].vertexNormals = [];
                    e = this.morphNormals[a].faceNormals;
                    var g = this.morphNormals[a].vertexNormals, h, m;
                    c = 0;
                    for (d = this.faces.length; c < d; c++)h = new q, m = {
                        a: new q,
                        b: new q,
                        c: new q
                    }, e.push(h), g.push(m)
                }
                g = this.morphNormals[a];
                f.vertices = this.morphTargets[a].vertices;
                f.computeFaceNormals();
                f.computeVertexNormals();
                c = 0;
                for (d = this.faces.length; c < d; c++)e =
                    this.faces[c], h = g.faceNormals[c], m = g.vertexNormals[c], h.copy(e.normal), m.a.copy(e.vertexNormals[0]), m.b.copy(e.vertexNormals[1]), m.c.copy(e.vertexNormals[2])
            }
            c = 0;
            for (d = this.faces.length; c < d; c++)e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
        }, computeLineDistances: function () {
            for (var a = 0, b = this.vertices, c = 0,
                     d = b.length; c < d; c++)0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new Pa);
            this.boundingBox.setFromPoints(this.vertices)
        }, computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new Na);
            this.boundingSphere.setFromPoints(this.vertices)
        }, merge: function (a, b, c) {
            if (!1 === (a && a.isGeometry)) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a); else {
                var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, m = a.faces,
                    k = this.faceVertexUvs[0], l = a.faceVertexUvs[0], p = this.colors, n = a.colors;
                void 0 === c && (c = 0);
                void 0 !==
                b && (d = (new ya).getNormalMatrix(b));
                a = 0;
                for (var u = g.length; a < u; a++) {
                    var q = g[a].clone();
                    void 0 !== b && q.applyMatrix4(b);
                    f.push(q)
                }
                a = 0;
                for (u = n.length; a < u; a++)p.push(n[a].clone());
                a = 0;
                for (u = m.length; a < u; a++) {
                    var g = m[a], r = g.vertexNormals, n = g.vertexColors, p = new ha(g.a + e, g.b + e, g.c + e);
                    p.normal.copy(g.normal);
                    void 0 !== d && p.normal.applyMatrix3(d).normalize();
                    b = 0;
                    for (f = r.length; b < f; b++)q = r[b].clone(), void 0 !== d && q.applyMatrix3(d).normalize(), p.vertexNormals.push(q);
                    p.color.copy(g.color);
                    b = 0;
                    for (f = n.length; b < f; b++)q =
                        n[b], p.vertexColors.push(q.clone());
                    p.materialIndex = g.materialIndex + c;
                    h.push(p)
                }
                a = 0;
                for (u = l.length; a < u; a++)if (c = l[a], d = [], void 0 !== c) {
                    b = 0;
                    for (f = c.length; b < f; b++)d.push(c[b].clone());
                    k.push(d)
                }
            }
        }, mergeMesh: function (a) {
            !1 === (a && a.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix))
        }, mergeVertices: function () {
            var a = {}, b = [], c = [], d, e = Math.pow(10, 4), f, g;
            f = 0;
            for (g = this.vertices.length; f < g; f++)d = this.vertices[f],
                d = Math.round(d.x * e) + "_" + Math.round(d.y * e) + "_" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
            a = [];
            f = 0;
            for (g = this.faces.length; f < g; f++)for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], d = 0; 3 > d; d++)if (e[d] === e[(d + 1) % 3]) {
                a.push(f);
                break
            }
            for (f = a.length - 1; 0 <= f; f--)for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++)this.faceVertexUvs[c].splice(e, 1);
            f = this.vertices.length - b.length;
            this.vertices = b;
            return f
        }, sortFacesByMaterialIndex: function () {
            for (var a =
                this.faces, b = a.length, c = 0; c < b; c++)a[c]._id = c;
            a.sort(function (a, b) {
                return a.materialIndex - b.materialIndex
            });
            var d = this.faceVertexUvs[0], e = this.faceVertexUvs[1], f, g;
            d && d.length === b && (f = []);
            e && e.length === b && (g = []);
            for (c = 0; c < b; c++) {
                var h = a[c]._id;
                f && f.push(d[h]);
                g && g.push(e[h])
            }
            f && (this.faceVertexUvs[0] = f);
            g && (this.faceVertexUvs[1] = g)
        }, toJSON: function () {
            function a(a, b, c) {
                return c ? a | 1 << b : a & ~(1 << b)
            }

            function b(a) {
                var b = a.x.toString() + a.y.toString() + a.z.toString();
                if (void 0 !== k[b])return k[b];
                k[b] = m.length /
                    3;
                m.push(a.x, a.y, a.z);
                return k[b]
            }

            function c(a) {
                var b = a.r.toString() + a.g.toString() + a.b.toString();
                if (void 0 !== p[b])return p[b];
                p[b] = l.length;
                l.push(a.getHex());
                return p[b]
            }

            function d(a) {
                var b = a.x.toString() + a.y.toString();
                if (void 0 !== u[b])return u[b];
                u[b] = n.length / 2;
                n.push(a.x, a.y);
                return u[b]
            }

            var e = {metadata: {version: 4.4, type: "Geometry", generator: "Geometry.toJSON"}};
            e.uuid = this.uuid;
            e.type = this.type;
            "" !== this.name && (e.name = this.name);
            if (void 0 !== this.parameters) {
                var f = this.parameters, g;
                for (g in f)void 0 !==
                f[g] && (e[g] = f[g]);
                return e
            }
            f = [];
            for (g = 0; g < this.vertices.length; g++) {
                var h = this.vertices[g];
                f.push(h.x, h.y, h.z)
            }
            var h = [], m = [], k = {}, l = [], p = {}, n = [], u = {};
            for (g = 0; g < this.faces.length; g++) {
                var q = this.faces[g], r = void 0 !== this.faceVertexUvs[0][g], A = 0 < q.normal.length(),
                    w = 0 < q.vertexNormals.length, y = 1 !== q.color.r || 1 !== q.color.g || 1 !== q.color.b,
                    K = 0 < q.vertexColors.length, v = 0, v = a(v, 0, 0), v = a(v, 1, !0), v = a(v, 2, !1),
                    v = a(v, 3, r), v = a(v, 4, A), v = a(v, 5, w), v = a(v, 6, y), v = a(v, 7, K);
                h.push(v);
                h.push(q.a, q.b, q.c);
                h.push(q.materialIndex);
                r && (r = this.faceVertexUvs[0][g], h.push(d(r[0]), d(r[1]), d(r[2])));
                A && h.push(b(q.normal));
                w && (A = q.vertexNormals, h.push(b(A[0]), b(A[1]), b(A[2])));
                y && h.push(c(q.color));
                K && (q = q.vertexColors, h.push(c(q[0]), c(q[1]), c(q[2])))
            }
            e.data = {};
            e.data.vertices = f;
            e.data.normals = m;
            0 < l.length && (e.data.colors = l);
            0 < n.length && (e.data.uvs = [n]);
            e.data.faces = h;
            return e
        }, clone: function () {
            return (new T).copy(this)
        }, copy: function (a) {
            var b, c, d, e, f, g;
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets =
                [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            d = a.vertices;
            b = 0;
            for (c = d.length; b < c; b++)this.vertices.push(d[b].clone());
            d = a.colors;
            b = 0;
            for (c = d.length; b < c; b++)this.colors.push(d[b].clone());
            d = a.faces;
            b = 0;
            for (c = d.length; b < c; b++)this.faces.push(d[b].clone());
            b = 0;
            for (c = a.faceVertexUvs.length; b < c; b++) {
                var h = a.faceVertexUvs[b];
                void 0 === this.faceVertexUvs[b] && (this.faceVertexUvs[b] = []);
                d = 0;
                for (e = h.length; d <
                e; d++) {
                    var m = h[d], k = [];
                    f = 0;
                    for (g = m.length; f < g; f++)k.push(m[f].clone());
                    this.faceVertexUvs[b].push(k)
                }
            }
            f = a.morphTargets;
            b = 0;
            for (c = f.length; b < c; b++) {
                g = {};
                g.name = f[b].name;
                if (void 0 !== f[b].vertices)for (g.vertices = [], d = 0, e = f[b].vertices.length; d < e; d++)g.vertices.push(f[b].vertices[d].clone());
                if (void 0 !== f[b].normals)for (g.normals = [], d = 0, e = f[b].normals.length; d < e; d++)g.normals.push(f[b].normals[d].clone());
                this.morphTargets.push(g)
            }
            f = a.morphNormals;
            b = 0;
            for (c = f.length; b < c; b++) {
                g = {};
                if (void 0 !== f[b].vertexNormals)for (g.vertexNormals =
                                                           [], d = 0, e = f[b].vertexNormals.length; d < e; d++)h = f[b].vertexNormals[d], m = {}, m.a = h.a.clone(), m.b = h.b.clone(), m.c = h.c.clone(), g.vertexNormals.push(m);
                if (void 0 !== f[b].faceNormals)for (g.faceNormals = [], d = 0, e = f[b].faceNormals.length; d < e; d++)g.faceNormals.push(f[b].faceNormals[d].clone());
                this.morphNormals.push(g)
            }
            d = a.skinWeights;
            b = 0;
            for (c = d.length; b < c; b++)this.skinWeights.push(d[b].clone());
            d = a.skinIndices;
            b = 0;
            for (c = d.length; b < c; b++)this.skinIndices.push(d[b].clone());
            d = a.lineDistances;
            b = 0;
            for (c = d.length; b <
            c; b++)this.lineDistances.push(d[b]);
            b = a.boundingBox;
            null !== b && (this.boundingBox = b.clone());
            b = a.boundingSphere;
            null !== b && (this.boundingSphere = b.clone());
            this.elementsNeedUpdate = a.elementsNeedUpdate;
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            return this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    Object.assign(T.prototype, pa.prototype);
    I.prototype = {
        constructor: I, isBufferGeometry: !0, getIndex: function () {
            return this.index
        }, setIndex: function (a) {
            Array.isArray(a) ? this.index = new (65535 < Ud(a) ? jb : ib)(a, 1) : this.index = a
        }, addAttribute: function (a, b, c) {
            if (!1 === (b && b.isBufferAttribute) && !1 === (b && b.isInterleavedBufferAttribute)) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new U(b, c)); else if ("index" === a) console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                this.setIndex(b); else return this.attributes[a] = b, this
        }, getAttribute: function (a) {
            return this.attributes[a]
        }, removeAttribute: function (a) {
            delete this.attributes[a];
            return this
        }, addGroup: function (a, b, c) {
            this.groups.push({start: a, count: b, materialIndex: void 0 !== c ? c : 0})
        }, clearGroups: function () {
            this.groups = []
        }, setDrawRange: function (a, b) {
            this.drawRange.start = a;
            this.drawRange.count = b
        }, applyMatrix: function (a) {
            var b = this.attributes.position;
            void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0);
            b = this.attributes.normal;
            void 0 !== b && ((new ya).getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = !0);
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            return this
        }, rotateX: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new S);
                a.makeRotationX(b);
                this.applyMatrix(a);
                return this
            }
        }(), rotateY: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new S);
                a.makeRotationY(b);
                this.applyMatrix(a);
                return this
            }
        }(), rotateZ: function () {
            var a;
            return function (b) {
                void 0 ===
                a && (a = new S);
                a.makeRotationZ(b);
                this.applyMatrix(a);
                return this
            }
        }(), translate: function () {
            var a;
            return function (b, c, d) {
                void 0 === a && (a = new S);
                a.makeTranslation(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(), scale: function () {
            var a;
            return function (b, c, d) {
                void 0 === a && (a = new S);
                a.makeScale(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(), lookAt: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new x);
                a.lookAt(b);
                a.updateMatrix();
                this.applyMatrix(a.matrix)
            }
        }(), center: function () {
            this.computeBoundingBox();
            var a = this.boundingBox.getCenter().negate();
            this.translate(a.x, a.y, a.z);
            return a
        }, setFromObject: function (a) {
            var b = a.geometry;
            if (a.isPoints || a.isLine) {
                a = new z(3 * b.vertices.length, 3);
                var c = new z(3 * b.colors.length, 3);
                this.addAttribute("position", a.copyVector3sArray(b.vertices));
                this.addAttribute("color", c.copyColorsArray(b.colors));
                b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new z(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
                null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
                null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
            } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
            return this
        }, updateFromObject: function (a) {
            var b = a.geometry;
            if (a.isMesh) {
                var c = b.__directGeometry;
                !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1);
                if (void 0 === c)return this.fromGeometry(b);
                c.verticesNeedUpdate = b.verticesNeedUpdate;
                c.normalsNeedUpdate = b.normalsNeedUpdate;
                c.colorsNeedUpdate = b.colorsNeedUpdate;
                c.uvsNeedUpdate = b.uvsNeedUpdate;
                c.groupsNeedUpdate = b.groupsNeedUpdate;
                b.verticesNeedUpdate = !1;
                b.normalsNeedUpdate = !1;
                b.colorsNeedUpdate = !1;
                b.uvsNeedUpdate = !1;
                b.groupsNeedUpdate = !1;
                b = c
            }
            !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1);
            !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1);
            !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0),
                b.colorsNeedUpdate = !1);
            b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1);
            b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
            b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
            return this
        }, fromGeometry: function (a) {
            a.__directGeometry = (new Me).fromGeometry(a);
            return this.fromDirectGeometry(a.__directGeometry)
        },
        fromDirectGeometry: function (a) {
            var b = new Float32Array(3 * a.vertices.length);
            this.addAttribute("position", (new U(b, 3)).copyVector3sArray(a.vertices));
            0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new U(b, 3)).copyVector3sArray(a.normals)));
            0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new U(b, 3)).copyColorsArray(a.colors)));
            0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new U(b, 2)).copyVector2sArray(a.uvs)));
            0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new U(b, 2)).copyVector2sArray(a.uvs2)));
            0 < a.indices.length && (b = new (65535 < Ud(a.indices) ? Uint32Array : Uint16Array)(3 * a.indices.length), this.setIndex((new U(b, 1)).copyIndicesArray(a.indices)));
            this.groups = a.groups;
            for (var c in a.morphTargets) {
                for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                    var g = d[e], h = new z(3 * g.length, 3);
                    b.push(h.copyVector3sArray(g))
                }
                this.morphAttributes[c] = b
            }
            0 < a.skinIndices.length && (c = new z(4 *
                a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
            0 < a.skinWeights.length && (c = new z(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            return this
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new Pa);
            var a = this.attributes.position;
            void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) :
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }, computeBoundingSphere: function () {
            var a = new Pa, b = new q;
            return function () {
                null === this.boundingSphere && (this.boundingSphere = new Na);
                var c = this.attributes.position;
                if (c) {
                    var d = this.boundingSphere.center;
                    a.setFromBufferAttribute(c);
                    a.getCenter(d);
                    for (var e = 0, f = 0,
                             g = c.count; f < g; f++)b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));
                    this.boundingSphere.radius = Math.sqrt(e);
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(), computeFaceNormals: function () {
        }, computeVertexNormals: function () {
            var a = this.index, b = this.attributes, c = this.groups;
            if (b.position) {
                var d = b.position.array;
                if (void 0 === b.normal) this.addAttribute("normal", new U(new Float32Array(d.length), 3)); else for (var e = b.normal.array,
                                                                                                                          f = 0,
                                                                                                                          g = e.length; f < g; f++)e[f] = 0;
                var e = b.normal.array, h, m, k, l = new q, p = new q, n = new q, u = new q, G = new q;
                if (a) {
                    a = a.array;
                    0 === c.length && this.addGroup(0, a.length);
                    for (var r = 0,
                             A = c.length; r < A; ++r)for (f = c[r], g = f.start, h = f.count, f = g, g += h; f < g; f += 3)h = 3 * a[f + 0], m = 3 * a[f + 1], k = 3 * a[f + 2], l.fromArray(d, h), p.fromArray(d, m), n.fromArray(d, k), u.subVectors(n, p), G.subVectors(l, p), u.cross(G), e[h] += u.x, e[h + 1] += u.y,
                        e[h + 2] += u.z, e[m] += u.x, e[m + 1] += u.y, e[m + 2] += u.z, e[k] += u.x, e[k + 1] += u.y, e[k + 2] += u.z
                } else for (f = 0, g = d.length; f < g; f += 9)l.fromArray(d, f), p.fromArray(d, f + 3), n.fromArray(d, f + 6), u.subVectors(n, p), G.subVectors(l, p), u.cross(G), e[f] = u.x, e[f + 1] = u.y, e[f + 2] = u.z, e[f + 3] = u.x, e[f + 4] = u.y, e[f + 5] = u.z, e[f + 6] = u.x, e[f + 7] = u.y, e[f + 8] = u.z;
                this.normalizeNormals();
                b.normal.needsUpdate = !0
            }
        }, merge: function (a, b) {
            if (!1 === (a && a.isBufferGeometry)) console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                a); else {
                void 0 === b && (b = 0);
                var c = this.attributes, d;
                for (d in c)if (void 0 !== a.attributes[d])for (var e = c[d].array, f = a.attributes[d], g = f.array,
                                                                    h = 0,
                                                                    f = f.itemSize * b; h < g.length; h++, f++)e[f] = g[h];
                return this
            }
        }, normalizeNormals: function () {
            for (var a = this.attributes.normal.array, b, c, d, e = 0,
                     f = a.length; e < f; e += 3)b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b
        }, toNonIndexed: function () {
            if (null === this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var a = new I, b = this.index.array, c = this.attributes, d;
            for (d in c) {
                for (var e = c[d], f = e.array, e = e.itemSize, g = new f.constructor(b.length * e), h, m = 0, k = 0,
                         l = b.length; k < l; k++) {
                    h = b[k] * e;
                    for (var p = 0; p < e; p++)g[m++] = f[h++]
                }
                a.addAttribute(d, new U(g, e))
            }
            return a
        }, toJSON: function () {
            var a = {metadata: {version: 4.4, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
            a.uuid = this.uuid;
            a.type = this.type;
            "" !== this.name && (a.name = this.name);
            if (void 0 !== this.parameters) {
                var b = this.parameters, c;
                for (c in b)void 0 !== b[c] &&
                (a[c] = b[c]);
                return a
            }
            a.data = {attributes: {}};
            var d = this.index;
            null !== d && (b = Array.prototype.slice.call(d.array), a.data.index = {
                type: d.array.constructor.name,
                array: b
            });
            d = this.attributes;
            for (c in d) {
                var e = d[c], b = Array.prototype.slice.call(e.array);
                a.data.attributes[c] = {
                    itemSize: e.itemSize,
                    type: e.array.constructor.name,
                    array: b,
                    normalized: e.normalized
                }
            }
            c = this.groups;
            0 < c.length && (a.data.groups = JSON.parse(JSON.stringify(c)));
            c = this.boundingSphere;
            null !== c && (a.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            });
            return a
        }, clone: function () {
            return (new I).copy(this)
        }, copy: function (a) {
            var b, c, d;
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            c = a.index;
            null !== c && this.setIndex(c.clone());
            c = a.attributes;
            for (b in c)this.addAttribute(b, c[b].clone());
            var e = a.morphAttributes;
            for (b in e) {
                var f = [], g = e[b];
                c = 0;
                for (d = g.length; c < d; c++)f.push(g[c].clone());
                this.morphAttributes[b] = f
            }
            b = a.groups;
            c = 0;
            for (d = b.length; c < d; c++)e =
                b[c], this.addGroup(e.start, e.count, e.materialIndex);
            b = a.boundingBox;
            null !== b && (this.boundingBox = b.clone());
            b = a.boundingSphere;
            null !== b && (this.boundingSphere = b.clone());
            this.drawRange.start = a.drawRange.start;
            this.drawRange.count = a.drawRange.count;
            return this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    I.MaxIndex = 65535;
    Object.assign(I.prototype, pa.prototype);
    Aa.prototype = Object.assign(Object.create(x.prototype), {
        constructor: Aa, isMesh: !0, setDrawMode: function (a) {
            this.drawMode = a
        }, copy: function (a) {
            x.prototype.copy.call(this,
                a);
            this.drawMode = a.drawMode;
            return this
        }, updateMorphTargets: function () {
            var a = this.geometry.morphTargets;
            if (void 0 !== a && 0 < a.length) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (var b = 0,
                         c = a.length; b < c; b++)this.morphTargetInfluences.push(0), this.morphTargetDictionary[a[b].name] = b
            }
        }, raycast: function () {
            function a(a, b, c, d, e, f, g) {
                za.barycoordFromPoint(a, b, c, d, r);
                e.multiplyScalar(r.x);
                f.multiplyScalar(r.y);
                g.multiplyScalar(r.z);
                e.add(f).add(g);
                return e.clone()
            }

            function b(a, b, c, d, e, f, g) {
                var h =
                    a.material;
                if (null === (1 === h.side ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, 2 !== h.side, g)))return null;
                w.copy(g);
                w.applyMatrix4(a.matrixWorld);
                c = b.ray.origin.distanceTo(w);
                return c < b.near || c > b.far ? null : {distance: c, point: w.clone(), object: a}
            }

            function c(c, d, e, f, k, l, p, t) {
                g.fromBufferAttribute(f, l);
                h.fromBufferAttribute(f, p);
                m.fromBufferAttribute(f, t);
                if (c = b(c, d, e, g, h, m, A)) k && (n.fromBufferAttribute(k, l), u.fromBufferAttribute(k, p), G.fromBufferAttribute(k, t), c.uv = a(A, g, h, m, n, u, G)), c.face =
                    new ha(l, p, t, za.normal(g, h, m)), c.faceIndex = l;
                return c
            }

            var d = new S, e = new cb, f = new Na, g = new q, h = new q, m = new q, k = new q, l = new q, p = new q,
                n = new D, u = new D, G = new D, r = new q, A = new q, w = new q;
            return function (q, r) {
                var v = this.geometry, w = this.material, L = this.matrixWorld;
                if (void 0 !== w && (null === v.boundingSphere && v.computeBoundingSphere(), f.copy(v.boundingSphere), f.applyMatrix4(L), !1 !== q.ray.intersectsSphere(f) && (d.getInverse(L), e.copy(q.ray).applyMatrix4(d), null === v.boundingBox || !1 !== e.intersectsBox(v.boundingBox)))) {
                    var C;
                    if (v.isBufferGeometry) {
                        var F, x, w = v.index, H = v.attributes.position, L = v.attributes.uv, D, z;
                        if (null !== w)for (D = 0, z = w.count; D < z; D += 3) {
                            if (v = w.getX(D), F = w.getX(D + 1), x = w.getX(D + 2), C = c(this, q, e, H, L, v, F, x)) C.faceIndex = Math.floor(D / 3), r.push(C)
                        } else for (D = 0, z = H.count; D < z; D += 3)if (v = D, F = D + 1, x = D + 2, C = c(this, q, e, H, L, v, F, x)) C.index = v, r.push(C)
                    } else if (v.isGeometry) {
                        var J, I, L = w && w.isMultiMaterial;
                        D = !0 === L ? w.materials : null;
                        z = v.vertices;
                        F = v.faces;
                        x = v.faceVertexUvs[0];
                        0 < x.length && (H = x);
                        for (var Q = 0, M = F.length; Q < M; Q++) {
                            var O =
                                F[Q];
                            C = !0 === L ? D[O.materialIndex] : w;
                            if (void 0 !== C) {
                                x = z[O.a];
                                J = z[O.b];
                                I = z[O.c];
                                if (!0 === C.morphTargets) {
                                    C = v.morphTargets;
                                    var P = this.morphTargetInfluences;
                                    g.set(0, 0, 0);
                                    h.set(0, 0, 0);
                                    m.set(0, 0, 0);
                                    for (var T = 0, W = C.length; T < W; T++) {
                                        var S = P[T];
                                        if (0 !== S) {
                                            var R = C[T].vertices;
                                            g.addScaledVector(k.subVectors(R[O.a], x), S);
                                            h.addScaledVector(l.subVectors(R[O.b], J), S);
                                            m.addScaledVector(p.subVectors(R[O.c], I), S)
                                        }
                                    }
                                    g.add(x);
                                    h.add(J);
                                    m.add(I);
                                    x = g;
                                    J = h;
                                    I = m
                                }
                                if (C = b(this, q, e, x, J, I, A)) H && (P = H[Q], n.copy(P[0]), u.copy(P[1]), G.copy(P[2]),
                                    C.uv = a(A, x, J, I, n, u, G)), C.face = O, C.faceIndex = Q, r.push(C)
                            }
                        }
                    }
                }
            }
        }(), clone: function () {
            return (new this.constructor(this.geometry, this.material)).copy(this)
        }
    });
    Ib.prototype = Object.create(T.prototype);
    Ib.prototype.constructor = Ib;
    kb.prototype = Object.create(I.prototype);
    kb.prototype.constructor = kb;
    Ac.prototype = Object.create(T.prototype);
    Ac.prototype.constructor = Ac;
    lb.prototype = Object.create(I.prototype);
    lb.prototype.constructor = lb;
    ra.prototype = Object.create(x.prototype);
    ra.prototype.constructor = ra;
    ra.prototype.isCamera =
        !0;
    ra.prototype.getWorldDirection = function () {
        var a = new ca;
        return function (b) {
            b = b || new q;
            this.getWorldQuaternion(a);
            return b.set(0, 0, -1).applyQuaternion(a)
        }
    }();
    ra.prototype.lookAt = function () {
        var a = new S;
        return function (b) {
            a.lookAt(this.position, b, this.up);
            this.quaternion.setFromRotationMatrix(a)
        }
    }();
    ra.prototype.clone = function () {
        return (new this.constructor).copy(this)
    };
    ra.prototype.copy = function (a) {
        x.prototype.copy.call(this, a);
        this.matrixWorldInverse.copy(a.matrixWorldInverse);
        this.projectionMatrix.copy(a.projectionMatrix);
        return this
    };
    Fa.prototype = Object.assign(Object.create(ra.prototype), {
        constructor: Fa, isPerspectiveCamera: !0, copy: function (a) {
            ra.prototype.copy.call(this, a);
            this.fov = a.fov;
            this.zoom = a.zoom;
            this.near = a.near;
            this.far = a.far;
            this.focus = a.focus;
            this.aspect = a.aspect;
            this.view = null === a.view ? null : Object.assign({}, a.view);
            this.filmGauge = a.filmGauge;
            this.filmOffset = a.filmOffset;
            return this
        }, setFocalLength: function (a) {
            a = .5 * this.getFilmHeight() / a;
            this.fov = 2 * N.RAD2DEG * Math.atan(a);
            this.updateProjectionMatrix()
        },
        getFocalLength: function () {
            var a = Math.tan(.5 * N.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / a
        }, getEffectiveFOV: function () {
            return 2 * N.RAD2DEG * Math.atan(Math.tan(.5 * N.DEG2RAD * this.fov) / this.zoom)
        }, getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        }, getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        }, setViewOffset: function (a, b, c, d, e, f) {
            this.aspect = a / b;
            this.view = {fullWidth: a, fullHeight: b, offsetX: c, offsetY: d, width: e, height: f};
            this.updateProjectionMatrix()
        }, clearViewOffset: function () {
            this.view =
                null;
            this.updateProjectionMatrix()
        }, updateProjectionMatrix: function () {
            var a = this.near, b = a * Math.tan(.5 * N.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c,
                e = -.5 * d, f = this.view;
            if (null !== f)var g = f.fullWidth, h = f.fullHeight, e = e + f.offsetX * d / g, b = b - f.offsetY * c / h,
                d = f.width / g * d, c = f.height / h * c;
            f = this.filmOffset;
            0 !== f && (e += a * f / this.getFilmWidth());
            this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far)
        }, toJSON: function (a) {
            a = x.prototype.toJSON.call(this, a);
            a.object.fov = this.fov;
            a.object.zoom = this.zoom;
            a.object.near =
                this.near;
            a.object.far = this.far;
            a.object.focus = this.focus;
            a.object.aspect = this.aspect;
            null !== this.view && (a.object.view = Object.assign({}, this.view));
            a.object.filmGauge = this.filmGauge;
            a.object.filmOffset = this.filmOffset;
            return a
        }
    });
    Jb.prototype = Object.assign(Object.create(ra.prototype), {
        constructor: Jb, isOrthographicCamera: !0, copy: function (a) {
            ra.prototype.copy.call(this, a);
            this.left = a.left;
            this.right = a.right;
            this.top = a.top;
            this.bottom = a.bottom;
            this.near = a.near;
            this.far = a.far;
            this.zoom = a.zoom;
            this.view =
                null === a.view ? null : Object.assign({}, a.view);
            return this
        }, setViewOffset: function (a, b, c, d, e, f) {
            this.view = {fullWidth: a, fullHeight: b, offsetX: c, offsetY: d, width: e, height: f};
            this.updateProjectionMatrix()
        }, clearViewOffset: function () {
            this.view = null;
            this.updateProjectionMatrix()
        }, updateProjectionMatrix: function () {
            var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom),
                c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2, e = c - a, c = c + a, a = d + b,
                b = d - b;
            if (null !== this.view)var c = this.zoom /
                    (this.view.width / this.view.fullWidth), b = this.zoom / (this.view.height / this.view.fullHeight),
                f = (this.right - this.left) / this.view.width, d = (this.top - this.bottom) / this.view.height,
                e = e + this.view.offsetX / c * f, c = e + this.view.width / c * f, a = a - this.view.offsetY / b * d,
                b = a - this.view.height / b * d;
            this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far)
        }, toJSON: function (a) {
            a = x.prototype.toJSON.call(this, a);
            a.object.zoom = this.zoom;
            a.object.left = this.left;
            a.object.right = this.right;
            a.object.top = this.top;
            a.object.bottom =
                this.bottom;
            a.object.near = this.near;
            a.object.far = this.far;
            null !== this.view && (a.object.view = Object.assign({}, this.view));
            return a
        }
    });
    var Lf = 0;
    Kb.prototype.isFogExp2 = !0;
    Kb.prototype.clone = function () {
        return new Kb(this.color.getHex(), this.density)
    };
    Kb.prototype.toJSON = function (a) {
        return {type: "FogExp2", color: this.color.getHex(), density: this.density}
    };
    Lb.prototype.isFog = !0;
    Lb.prototype.clone = function () {
        return new Lb(this.color.getHex(), this.near, this.far)
    };
    Lb.prototype.toJSON = function (a) {
        return {
            type: "Fog",
            color: this.color.getHex(), near: this.near, far: this.far
        }
    };
    mb.prototype = Object.create(x.prototype);
    mb.prototype.constructor = mb;
    mb.prototype.copy = function (a, b) {
        x.prototype.copy.call(this, a, b);
        null !== a.background && (this.background = a.background.clone());
        null !== a.fog && (this.fog = a.fog.clone());
        null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
        this.autoUpdate = a.autoUpdate;
        this.matrixAutoUpdate = a.matrixAutoUpdate;
        return this
    };
    mb.prototype.toJSON = function (a) {
        var b = x.prototype.toJSON.call(this,
            a);
        null !== this.background && (b.object.background = this.background.toJSON(a));
        null !== this.fog && (b.object.fog = this.fog.toJSON());
        return b
    };
    Zd.prototype = Object.assign(Object.create(x.prototype), {
        constructor: Zd, isLensFlare: !0, copy: function (a) {
            x.prototype.copy.call(this, a);
            this.positionScreen.copy(a.positionScreen);
            this.customUpdateCallback = a.customUpdateCallback;
            for (var b = 0, c = a.lensFlares.length; b < c; b++)this.lensFlares.push(a.lensFlares[b]);
            return this
        }, add: function (a, b, c, d, e, f) {
            void 0 === b && (b = -1);
            void 0 ===
            c && (c = 0);
            void 0 === f && (f = 1);
            void 0 === e && (e = new J(16777215));
            void 0 === d && (d = 1);
            c = Math.min(c, Math.max(0, c));
            this.lensFlares.push({
                texture: a,
                size: b,
                distance: c,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: f,
                color: e,
                blending: d
            })
        }, updateLensFlares: function () {
            var a, b = this.lensFlares.length, c, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
            for (a = 0; a < b; a++)c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * .25, c.rotation += .25 * (c.wantedRotation -
                c.rotation)
        }
    });
    nb.prototype = Object.create(X.prototype);
    nb.prototype.constructor = nb;
    nb.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.rotation = a.rotation;
        return this
    };
    Dc.prototype = Object.assign(Object.create(x.prototype), {
        constructor: Dc, isSprite: !0, raycast: function () {
            var a = new q;
            return function (b, c) {
                a.setFromMatrixPosition(this.matrixWorld);
                var d = b.ray.distanceSqToPoint(a);
                d > this.scale.x * this.scale.y / 4 || c.push({
                    distance: Math.sqrt(d), point: this.position,
                    face: null, object: this
                })
            }
        }(), clone: function () {
            return (new this.constructor(this.material)).copy(this)
        }
    });
    Ec.prototype = Object.assign(Object.create(x.prototype), {
        constructor: Ec, copy: function (a) {
            x.prototype.copy.call(this, a, !1);
            a = a.levels;
            for (var b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                this.addLevel(d.object.clone(), d.distance)
            }
            return this
        }, addLevel: function (a, b) {
            void 0 === b && (b = 0);
            b = Math.abs(b);
            for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
            c.splice(d, 0, {distance: b, object: a});
            this.add(a)
        }, getObjectForDistance: function (a) {
            for (var b =
                this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
            return b[c - 1].object
        }, raycast: function () {
            var a = new q;
            return function (b, c) {
                a.setFromMatrixPosition(this.matrixWorld);
                var d = b.ray.origin.distanceTo(a);
                this.getObjectForDistance(d).raycast(b, c)
            }
        }(), update: function () {
            var a = new q, b = new q;
            return function (c) {
                var d = this.levels;
                if (1 < d.length) {
                    a.setFromMatrixPosition(c.matrixWorld);
                    b.setFromMatrixPosition(this.matrixWorld);
                    c = a.distanceTo(b);
                    d[0].object.visible = !0;
                    for (var e = 1, f = d.length; e < f; e++)if (c >= d[e].distance) d[e -
                    1].object.visible = !1, d[e].object.visible = !0; else break;
                    for (; e < f; e++)d[e].object.visible = !1
                }
            }
        }(), toJSON: function (a) {
            a = x.prototype.toJSON.call(this, a);
            a.object.levels = [];
            for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
                var e = b[c];
                a.object.levels.push({object: e.object.uuid, distance: e.distance})
            }
            return a
        }
    });
    Object.assign(od.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var a = 0, b = this.bones.length; a < b; a++) {
                var c = new S;
                this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
                this.boneInverses.push(c)
            }
        },
        pose: function () {
            for (var a, b = 0,
                     c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
            b = 0;
            for (c = this.bones.length; b < c; b++)if (a = this.bones[b]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
        }, update: function () {
            var a = new S;
            return function () {
                for (var b = 0,
                         c = this.bones.length; b < c; b++)a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld :
                    this.identityMatrix, this.boneInverses[b]), a.toArray(this.boneMatrices, 16 * b);
                this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
            }
        }(), clone: function () {
            return new od(this.bones, this.boneInverses, this.useVertexTexture)
        }
    });
    pd.prototype = Object.assign(Object.create(x.prototype), {constructor: pd, isBone: !0});
    qd.prototype = Object.assign(Object.create(Aa.prototype), {
        constructor: qd, isSkinnedMesh: !0, bind: function (a, b) {
            this.skeleton = a;
            void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(),
                b = this.matrixWorld);
            this.bindMatrix.copy(b);
            this.bindMatrixInverse.getInverse(b)
        }, pose: function () {
            this.skeleton.pose()
        }, normalizeSkinWeights: function () {
            if (this.geometry && this.geometry.isGeometry)for (var a = 0; a < this.geometry.skinWeights.length; a++) {
                var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
                Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
            } else if (this.geometry && this.geometry.isBufferGeometry)for (var b = new fa,
                                                                                d = this.geometry.attributes.skinWeight,
                                                                                a = 0; a < d.count; a++)b.x = d.getX(a), b.y = d.getY(a),
                b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.lengthManhattan(), Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w)
        }, updateMatrixWorld: function (a) {
            Aa.prototype.updateMatrixWorld.call(this, !0);
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
        }, clone: function () {
            return (new this.constructor(this.geometry, this.material,
                this.skeleton.useVertexTexture)).copy(this)
        }
    });
    ia.prototype = Object.create(X.prototype);
    ia.prototype.constructor = ia;
    ia.prototype.isLineBasicMaterial = !0;
    ia.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.linewidth = a.linewidth;
        this.linecap = a.linecap;
        this.linejoin = a.linejoin;
        return this
    };
    Ua.prototype = Object.assign(Object.create(x.prototype), {
        constructor: Ua, isLine: !0, raycast: function () {
            var a = new S, b = new cb, c = new Na;
            return function (d, e) {
                var f = d.linePrecision, f = f * f,
                    g = this.geometry, h = this.matrixWorld;
                null === g.boundingSphere && g.computeBoundingSphere();
                c.copy(g.boundingSphere);
                c.applyMatrix4(h);
                if (!1 !== d.ray.intersectsSphere(c)) {
                    a.getInverse(h);
                    b.copy(d.ray).applyMatrix4(a);
                    var m = new q, k = new q, h = new q, l = new q, p = this && this.isLineSegments ? 2 : 1;
                    if (g.isBufferGeometry) {
                        var n = g.index, u = g.attributes.position.array;
                        if (null !== n)for (var n = n.array, g = 0, G = n.length - 1; g < G; g += p) {
                            var r = n[g + 1];
                            m.fromArray(u, 3 * n[g]);
                            k.fromArray(u, 3 * r);
                            r = b.distanceSqToSegment(m, k, l, h);
                            r > f || (l.applyMatrix4(this.matrixWorld),
                                r = d.ray.origin.distanceTo(l), r < d.near || r > d.far || e.push({
                                distance: r,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: g,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        } else for (g = 0, G = u.length / 3 - 1; g < G; g += p)m.fromArray(u, 3 * g), k.fromArray(u, 3 * g + 3), r = b.distanceSqToSegment(m, k, l, h), r > f || (l.applyMatrix4(this.matrixWorld), r = d.ray.origin.distanceTo(l), r < d.near || r > d.far || e.push({
                            distance: r,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                    } else if (g.isGeometry)for (m = g.vertices,
                                                     k = m.length, g = 0; g < k - 1; g += p)r = b.distanceSqToSegment(m[g], m[g + 1], l, h), r > f || (l.applyMatrix4(this.matrixWorld), r = d.ray.origin.distanceTo(l), r < d.near || r > d.far || e.push({
                        distance: r,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: g,
                        face: null,
                        faceIndex: null,
                        object: this
                    }))
                }
            }
        }(), clone: function () {
            return (new this.constructor(this.geometry, this.material)).copy(this)
        }
    });
    ga.prototype = Object.assign(Object.create(Ua.prototype), {constructor: ga, isLineSegments: !0});
    Oa.prototype = Object.create(X.prototype);
    Oa.prototype.constructor =
        Oa;
    Oa.prototype.isPointsMaterial = !0;
    Oa.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.size = a.size;
        this.sizeAttenuation = a.sizeAttenuation;
        return this
    };
    Mb.prototype = Object.assign(Object.create(x.prototype), {
        constructor: Mb, isPoints: !0, raycast: function () {
            var a = new S, b = new cb, c = new Na;
            return function (d, e) {
                function f(a, c) {
                    var f = b.distanceSqToPoint(a);
                    if (f < l) {
                        var h = b.closestPointToPoint(a);
                        h.applyMatrix4(m);
                        var k = d.ray.origin.distanceTo(h);
                        k < d.near ||
                        k > d.far || e.push({
                            distance: k,
                            distanceToRay: Math.sqrt(f),
                            point: h.clone(),
                            index: c,
                            face: null,
                            object: g
                        })
                    }
                }

                var g = this, h = this.geometry, m = this.matrixWorld, k = d.params.Points.threshold;
                null === h.boundingSphere && h.computeBoundingSphere();
                c.copy(h.boundingSphere);
                c.applyMatrix4(m);
                if (!1 !== d.ray.intersectsSphere(c)) {
                    a.getInverse(m);
                    b.copy(d.ray).applyMatrix4(a);
                    var k = k / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = k * k, k = new q;
                    if (h.isBufferGeometry) {
                        var p = h.index, h = h.attributes.position.array;
                        if (null !== p)for (var n =
                            p.array, p = 0, u = n.length; p < u; p++) {
                            var G = n[p];
                            k.fromArray(h, 3 * G);
                            f(k, G)
                        } else for (p = 0, n = h.length / 3; p < n; p++)k.fromArray(h, 3 * p), f(k, p)
                    } else for (k = h.vertices, p = 0, n = k.length; p < n; p++)f(k[p], p)
                }
            }
        }(), clone: function () {
            return (new this.constructor(this.geometry, this.material)).copy(this)
        }
    });
    Fc.prototype = Object.assign(Object.create(x.prototype), {constructor: Fc});
    rd.prototype = Object.create(ea.prototype);
    rd.prototype.constructor = rd;
    Nb.prototype = Object.create(ea.prototype);
    Nb.prototype.constructor = Nb;
    Nb.prototype.isCompressedTexture =
        !0;
    sd.prototype = Object.create(ea.prototype);
    sd.prototype.constructor = sd;
    Gc.prototype = Object.create(ea.prototype);
    Gc.prototype.constructor = Gc;
    Gc.prototype.isDepthTexture = !0;
    Ob.prototype = Object.create(I.prototype);
    Ob.prototype.constructor = Ob;
    Hc.prototype = Object.create(T.prototype);
    Hc.prototype.constructor = Hc;
    Pb.prototype = Object.create(I.prototype);
    Pb.prototype.constructor = Pb;
    Ic.prototype = Object.create(T.prototype);
    Ic.prototype.constructor = Ic;
    Ba.prototype = Object.create(I.prototype);
    Ba.prototype.constructor =
        Ba;
    Jc.prototype = Object.create(T.prototype);
    Jc.prototype.constructor = Jc;
    Qb.prototype = Object.create(Ba.prototype);
    Qb.prototype.constructor = Qb;
    Kc.prototype = Object.create(T.prototype);
    Kc.prototype.constructor = Kc;
    ob.prototype = Object.create(Ba.prototype);
    ob.prototype.constructor = ob;
    Lc.prototype = Object.create(T.prototype);
    Lc.prototype.constructor = Lc;
    Rb.prototype = Object.create(Ba.prototype);
    Rb.prototype.constructor = Rb;
    Mc.prototype = Object.create(T.prototype);
    Mc.prototype.constructor = Mc;
    Sb.prototype = Object.create(Ba.prototype);
    Sb.prototype.constructor = Sb;
    Nc.prototype = Object.create(T.prototype);
    Nc.prototype.constructor = Nc;
    Tb.prototype = Object.create(I.prototype);
    Tb.prototype.constructor = Tb;
    Oc.prototype = Object.create(T.prototype);
    Oc.prototype.constructor = Oc;
    Ub.prototype = Object.create(I.prototype);
    Ub.prototype.constructor = Ub;
    Pc.prototype = Object.create(T.prototype);
    Pc.prototype.constructor = Pc;
    Vb.prototype = Object.create(I.prototype);
    Vb.prototype.constructor = Vb;
    var Ia = {
        area: function (a) {
            for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++)c +=
                a[d].x * a[e].y - a[e].x * a[d].y;
            return .5 * c
        }, triangulate: function () {
            return function (a, b) {
                var c = a.length;
                if (3 > c)return null;
                var d = [], e = [], f = [], g, h, m;
                if (0 < Ia.area(a))for (h = 0; h < c; h++)e[h] = h; else for (h = 0; h < c; h++)e[h] = c - 1 - h;
                var k = 2 * c;
                for (h = c - 1; 2 < c;) {
                    if (0 >= k--) {
                        console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                        break
                    }
                    g = h;
                    c <= g && (g = 0);
                    h = g + 1;
                    c <= h && (h = 0);
                    m = h + 1;
                    c <= m && (m = 0);
                    var l;
                    a:{
                        var p, n, q, G, r, A, w, y;
                        p = a[e[g]].x;
                        n = a[e[g]].y;
                        q = a[e[h]].x;
                        G = a[e[h]].y;
                        r = a[e[m]].x;
                        A = a[e[m]].y;
                        if (0 >= (q -
                            p) * (A - n) - (G - n) * (r - p)) l = !1; else {
                            var K, v, E, x, C, F, D, H, z, J;
                            K = r - q;
                            v = A - G;
                            E = p - r;
                            x = n - A;
                            C = q - p;
                            F = G - n;
                            for (l = 0; l < c; l++)if (w = a[e[l]].x, y = a[e[l]].y, !(w === p && y === n || w === q && y === G || w === r && y === A) && (D = w - p, H = y - n, z = w - q, J = y - G, w -= r, y -= A, z = K * J - v * z, D = C * H - F * D, H = E * y - x * w, z >= -Number.EPSILON && H >= -Number.EPSILON && D >= -Number.EPSILON)) {
                                l = !1;
                                break a
                            }
                            l = !0
                        }
                    }
                    if (l) {
                        d.push([a[e[g]], a[e[h]], a[e[m]]]);
                        f.push([e[g], e[h], e[m]]);
                        g = h;
                        for (m = h + 1; m < c; g++, m++)e[g] = e[m];
                        c--;
                        k = 2 * c
                    }
                }
                return b ? f : d
            }
        }(), triangulateShape: function (a, b) {
            function c(a) {
                var b =
                    a.length;
                2 < b && a[b - 1].equals(a[0]) && a.pop()
            }

            function d(a, b, c) {
                return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
            }

            function e(a, b, c, e, f) {
                var g = b.x - a.x, h = b.y - a.y, k = e.x - c.x, m = e.y - c.y, l = a.x - c.x, n = a.y - c.y,
                    p = h * k - g * m, t = h * l - g * n;
                if (Math.abs(p) > Number.EPSILON) {
                    if (0 < p) {
                        if (0 > t || t > p)return [];
                        k = m * l - k * n;
                        if (0 > k || k > p)return []
                    } else {
                        if (0 < t || t < p)return [];
                        k = m * l - k * n;
                        if (0 < k || k < p)return []
                    }
                    if (0 === k)return !f || 0 !== t && t !== p ? [a] : [];
                    if (k === p)return !f || 0 !== t && t !== p ? [b] : [];
                    if (0 === t)return [c];
                    if (t === p)return [e];
                    f = k / p;
                    return [{x: a.x + f * g, y: a.y + f * h}]
                }
                if (0 !== t || m * l !== k * n)return [];
                h = 0 === g && 0 === h;
                k = 0 === k && 0 === m;
                if (h && k)return a.x !== c.x || a.y !== c.y ? [] : [a];
                if (h)return d(c, e, a) ? [a] : [];
                if (k)return d(a, b, c) ? [c] : [];
                0 !== g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), c.x < e.x ? (b = c, p = c.x, m = e, c = e.x) : (b = e, p = e.x, m = c, c = c.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), c.y < e.y ? (b = c, p = c.y, m = e, c = e.y) : (b = e, p = e.y, m = c, c = c.y));
                return k <= p ? a < p ? [] : a === p ? f ? [] : [b] : a <= c ? [b, h] : [b, m] :
                    k > c ? [] : k === c ? f ? [] : [g] : a <= c ? [g, h] : [g, m]
            }

            function f(a, b, c, d) {
                var e = b.x - a.x, f = b.y - a.y;
                b = c.x - a.x;
                c = c.y - a.y;
                var g = d.x - a.x;
                d = d.y - a.y;
                a = e * c - f * b;
                e = e * d - f * g;
                return Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
            }

            c(a);
            b.forEach(c);
            var g, h, m, k, l, p = {};
            m = a.concat();
            g = 0;
            for (h = b.length; g < h; g++)Array.prototype.push.apply(m, b[g]);
            g = 0;
            for (h = m.length; g < h; g++)l = m[g].x + ":" + m[g].y, void 0 !== p[l] && console.warn("THREE.ShapeUtils: Duplicate point", l, g), p[l] = g;
            g = function (a, b) {
                function c(a, b) {
                    var d = h.length -
                        1, e = a - 1;
                    0 > e && (e = d);
                    var g = a + 1;
                    g > d && (g = 0);
                    d = f(h[a], h[e], h[g], k[b]);
                    if (!d)return !1;
                    d = k.length - 1;
                    e = b - 1;
                    0 > e && (e = d);
                    g = b + 1;
                    g > d && (g = 0);
                    return (d = f(k[b], k[e], k[g], h[a])) ? !0 : !1
                }

                function d(a, b) {
                    var c, f;
                    for (c = 0; c < h.length; c++)if (f = c + 1, f %= h.length, f = e(a, b, h[c], h[f], !0), 0 < f.length)return !0;
                    return !1
                }

                function g(a, c) {
                    var d, f, h, k;
                    for (d = 0; d < m.length; d++)for (f = b[m[d]], h = 0; h < f.length; h++)if (k = h + 1, k %= f.length, k = e(a, c, f[h], f[k], !0), 0 < k.length)return !0;
                    return !1
                }

                var h = a.concat(), k, m = [], l, n, p, t, q, x = [], D, z, J, I = 0;
                for (l = b.length; I <
                l; I++)m.push(I);
                D = 0;
                for (var Q = 2 * m.length; 0 < m.length;) {
                    Q--;
                    if (0 > Q) {
                        console.log("Infinite Loop! Holes left:" + m.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (n = D; n < h.length; n++) {
                        p = h[n];
                        l = -1;
                        for (I = 0; I < m.length; I++)if (t = m[I], q = p.x + ":" + p.y + ":" + t, void 0 === x[q]) {
                            k = b[t];
                            for (z = 0; z < k.length; z++)if (t = k[z], c(n, z) && !d(p, t) && !g(p, t)) {
                                l = z;
                                m.splice(I, 1);
                                D = h.slice(0, n + 1);
                                t = h.slice(n);
                                z = k.slice(l);
                                J = k.slice(0, l + 1);
                                h = D.concat(z).concat(J).concat(t);
                                D = n;
                                break
                            }
                            if (0 <= l)break;
                            x[q] = !0
                        }
                        if (0 <= l)break
                    }
                }
                return h
            }(a, b);
            var n =
                Ia.triangulate(g, !1);
            g = 0;
            for (h = n.length; g < h; g++)for (k = n[g], m = 0; 3 > m; m++)l = k[m].x + ":" + k[m].y, l = p[l], void 0 !== l && (k[m] = l);
            return n.concat()
        }, isClockWise: function (a) {
            return 0 > Ia.area(a)
        }
    };
    La.prototype = Object.create(T.prototype);
    La.prototype.constructor = La;
    La.prototype.addShapeList = function (a, b) {
        for (var c = a.length, d = 0; d < c; d++)this.addShape(a[d], b)
    };
    La.prototype.addShape = function (a, b) {
        function c(a, b, c) {
            b || console.error("THREE.ExtrudeGeometry: vec does not exist");
            return b.clone().multiplyScalar(c).add(a)
        }

        function d(a, b, c) {
            var d, e, f;
            e = a.x - b.x;
            f = a.y - b.y;
            d = c.x - a.x;
            var g = c.y - a.y, h = e * e + f * f;
            if (Math.abs(e * g - f * d) > Number.EPSILON) {
                var k = Math.sqrt(h), m = Math.sqrt(d * d + g * g), h = b.x - f / k;
                b = b.y + e / k;
                g = ((c.x - g / m - h) * g - (c.y + d / m - b) * d) / (e * g - f * d);
                d = h + e * g - a.x;
                e = b + f * g - a.y;
                f = d * d + e * e;
                if (2 >= f)return new D(d, e);
                f = Math.sqrt(f / 2)
            } else a = !1, e > Number.EPSILON ? d > Number.EPSILON && (a = !0) : e < -Number.EPSILON ? d < -Number.EPSILON && (a = !0) : Math.sign(f) === Math.sign(g) && (a = !0), a ? (d = -f, f = Math.sqrt(h)) : (d = e, e = f, f = Math.sqrt(h / 2));
            return new D(d / f, e / f)
        }

        function e(a, b) {
            var c, d;
            for (R = a.length; 0 <= --R;) {
                c = R;
                d = R - 1;
                0 > d && (d = a.length - 1);
                var e, f = u + 2 * l;
                for (e = 0; e < f; e++) {
                    var g = U * e, h = U * (e + 1), k = b + c + g, g = b + d + g, m = b + d + h, h = b + c + h,
                        k = k + H, g = g + H, m = m + H, h = h + H;
                    J.faces.push(new ha(k, g, h, null, null, 1));
                    J.faces.push(new ha(g, m, h, null, null, 1));
                    k = w.generateSideWallUV(J, k, g, m, h);
                    J.faceVertexUvs[0].push([k[0], k[1], k[3]]);
                    J.faceVertexUvs[0].push([k[1], k[2], k[3]])
                }
            }
        }

        function f(a, b, c) {
            J.vertices.push(new q(a, b, c))
        }

        function g(a, b, c) {
            a += H;
            b += H;
            c += H;
            J.faces.push(new ha(a, b, c, null, null,
                0));
            a = w.generateTopUV(J, a, b, c);
            J.faceVertexUvs[0].push(a)
        }

        var h = void 0 !== b.amount ? b.amount : 100, m = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
            k = void 0 !== b.bevelSize ? b.bevelSize : m - 2, l = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
            p = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, n = void 0 !== b.curveSegments ? b.curveSegments : 12,
            u = void 0 !== b.steps ? b.steps : 1, G = b.extrudePath, r, A = !1,
            w = void 0 !== b.UVGenerator ? b.UVGenerator : La.WorldUVGenerator, y, x, v, E;
        G && (r = G.getSpacedPoints(u), A = !0, p = !1, y = void 0 !== b.frames ? b.frames :
            G.computeFrenetFrames(u, !1), x = new q, v = new q, E = new q);
        p || (k = m = l = 0);
        var z, C, F, J = this, H = this.vertices.length, G = a.extractPoints(n), n = G.shape, I = G.holes;
        if (G = !Ia.isClockWise(n)) {
            n = n.reverse();
            C = 0;
            for (F = I.length; C < F; C++)z = I[C], Ia.isClockWise(z) && (I[C] = z.reverse());
            G = !1
        }
        var T = Ia.triangulateShape(n, I), S = n;
        C = 0;
        for (F = I.length; C < F; C++)z = I[C], n = n.concat(z);
        var N, Q, M, O, P, U = n.length, W, V = T.length, G = [], R = 0;
        M = S.length;
        N = M - 1;
        for (Q = R + 1; R < M; R++, N++, Q++)N === M && (N = 0), Q === M && (Q = 0), G[R] = d(S[R], S[N], S[Q]);
        var X = [], Z, ca = G.concat();
        C = 0;
        for (F = I.length; C < F; C++) {
            z = I[C];
            Z = [];
            R = 0;
            M = z.length;
            N = M - 1;
            for (Q = R + 1; R < M; R++, N++, Q++)N === M && (N = 0), Q === M && (Q = 0), Z[R] = d(z[R], z[N], z[Q]);
            X.push(Z);
            ca = ca.concat(Z)
        }
        for (N = 0; N < l; N++) {
            M = N / l;
            O = m * Math.cos(M * Math.PI / 2);
            Q = k * Math.sin(M * Math.PI / 2);
            R = 0;
            for (M = S.length; R < M; R++)P = c(S[R], G[R], Q), f(P.x, P.y, -O);
            C = 0;
            for (F = I.length; C < F; C++)for (z = I[C], Z = X[C], R = 0, M = z.length; R < M; R++)P = c(z[R], Z[R], Q), f(P.x, P.y, -O)
        }
        Q = k;
        for (R = 0; R < U; R++)P = p ? c(n[R], ca[R], Q) : n[R], A ? (v.copy(y.normals[0]).multiplyScalar(P.x), x.copy(y.binormals[0]).multiplyScalar(P.y),
            E.copy(r[0]).add(v).add(x), f(E.x, E.y, E.z)) : f(P.x, P.y, 0);
        for (M = 1; M <= u; M++)for (R = 0; R < U; R++)P = p ? c(n[R], ca[R], Q) : n[R], A ? (v.copy(y.normals[M]).multiplyScalar(P.x), x.copy(y.binormals[M]).multiplyScalar(P.y), E.copy(r[M]).add(v).add(x), f(E.x, E.y, E.z)) : f(P.x, P.y, h / u * M);
        for (N = l - 1; 0 <= N; N--) {
            M = N / l;
            O = m * Math.cos(M * Math.PI / 2);
            Q = k * Math.sin(M * Math.PI / 2);
            R = 0;
            for (M = S.length; R < M; R++)P = c(S[R], G[R], Q), f(P.x, P.y, h + O);
            C = 0;
            for (F = I.length; C < F; C++)for (z = I[C], Z = X[C], R = 0, M = z.length; R < M; R++)P = c(z[R], Z[R], Q), A ? f(P.x, P.y + r[u - 1].y,
                r[u - 1].x + O) : f(P.x, P.y, h + O)
        }
        (function () {
            if (p) {
                var a = 0 * U;
                for (R = 0; R < V; R++)W = T[R], g(W[2] + a, W[1] + a, W[0] + a);
                a = U * (u + 2 * l);
                for (R = 0; R < V; R++)W = T[R], g(W[0] + a, W[1] + a, W[2] + a)
            } else {
                for (R = 0; R < V; R++)W = T[R], g(W[2], W[1], W[0]);
                for (R = 0; R < V; R++)W = T[R], g(W[0] + U * u, W[1] + U * u, W[2] + U * u)
            }
        })();
        (function () {
            var a = 0;
            e(S, a);
            a += S.length;
            C = 0;
            for (F = I.length; C < F; C++)z = I[C], e(z, a), a += z.length
        })()
    };
    La.WorldUVGenerator = {
        generateTopUV: function (a, b, c, d) {
            a = a.vertices;
            b = a[b];
            c = a[c];
            d = a[d];
            return [new D(b.x, b.y), new D(c.x, c.y), new D(d.x, d.y)]
        },
        generateSideWallUV: function (a, b, c, d, e) {
            a = a.vertices;
            b = a[b];
            c = a[c];
            d = a[d];
            e = a[e];
            return .01 > Math.abs(b.y - c.y) ? [new D(b.x, 1 - b.z), new D(c.x, 1 - c.z), new D(d.x, 1 - d.z), new D(e.x, 1 - e.z)] : [new D(b.y, 1 - b.z), new D(c.y, 1 - c.z), new D(d.y, 1 - d.z), new D(e.y, 1 - e.z)]
        }
    };
    Qc.prototype = Object.create(La.prototype);
    Qc.prototype.constructor = Qc;
    Rc.prototype = Object.create(T.prototype);
    Rc.prototype.constructor = Rc;
    pb.prototype = Object.create(I.prototype);
    pb.prototype.constructor = pb;
    Sc.prototype = Object.create(T.prototype);
    Sc.prototype.constructor =
        Sc;
    Wb.prototype = Object.create(I.prototype);
    Wb.prototype.constructor = Wb;
    Tc.prototype = Object.create(T.prototype);
    Tc.prototype.constructor = Tc;
    Xb.prototype = Object.create(I.prototype);
    Xb.prototype.constructor = Xb;
    Yb.prototype = Object.create(T.prototype);
    Yb.prototype.constructor = Yb;
    Zb.prototype = Object.create(I.prototype);
    Zb.prototype.constructor = Zb;
    $b.prototype = Object.create(I.prototype);
    $b.prototype.constructor = $b;
    qb.prototype = Object.create(T.prototype);
    qb.prototype.constructor = qb;
    Va.prototype = Object.create(I.prototype);
    Va.prototype.constructor = Va;
    Uc.prototype = Object.create(qb.prototype);
    Uc.prototype.constructor = Uc;
    Vc.prototype = Object.create(Va.prototype);
    Vc.prototype.constructor = Vc;
    Wc.prototype = Object.create(T.prototype);
    Wc.prototype.constructor = Wc;
    ac.prototype = Object.create(I.prototype);
    ac.prototype.constructor = ac;
    var Ma = Object.freeze({
        WireframeGeometry: Ob,
        ParametricGeometry: Hc,
        ParametricBufferGeometry: Pb,
        TetrahedronGeometry: Jc,
        TetrahedronBufferGeometry: Qb,
        OctahedronGeometry: Kc,
        OctahedronBufferGeometry: ob,
        IcosahedronGeometry: Lc,
        IcosahedronBufferGeometry: Rb,
        DodecahedronGeometry: Mc,
        DodecahedronBufferGeometry: Sb,
        PolyhedronGeometry: Ic,
        PolyhedronBufferGeometry: Ba,
        TubeGeometry: Nc,
        TubeBufferGeometry: Tb,
        TorusKnotGeometry: Oc,
        TorusKnotBufferGeometry: Ub,
        TorusGeometry: Pc,
        TorusBufferGeometry: Vb,
        TextGeometry: Qc,
        SphereGeometry: Rc,
        SphereBufferGeometry: pb,
        RingGeometry: Sc,
        RingBufferGeometry: Wb,
        PlaneGeometry: Ac,
        PlaneBufferGeometry: lb,
        LatheGeometry: Tc,
        LatheBufferGeometry: Xb,
        ShapeGeometry: Yb,
        ShapeBufferGeometry: Zb,
        ExtrudeGeometry: La,
        EdgesGeometry: $b,
        ConeGeometry: Uc,
        ConeBufferGeometry: Vc,
        CylinderGeometry: qb,
        CylinderBufferGeometry: Va,
        CircleGeometry: Wc,
        CircleBufferGeometry: ac,
        BoxGeometry: Ib,
        BoxBufferGeometry: kb
    });
    bc.prototype = Object.create(Ha.prototype);
    bc.prototype.constructor = bc;
    bc.prototype.isShadowMaterial = !0;
    cc.prototype = Object.create(Ha.prototype);
    cc.prototype.constructor = cc;
    cc.prototype.isRawShaderMaterial = !0;
    Xc.prototype = {
        constructor: Xc, isMultiMaterial: !0, toJSON: function (a) {
            for (var b = {
                metadata: {version: 4.2, type: "material", generator: "MaterialExporter"},
                uuid: this.uuid, type: this.type, materials: []
            }, c = this.materials, d = 0, e = c.length; d < e; d++) {
                var f = c[d].toJSON(a);
                delete f.metadata;
                b.materials.push(f)
            }
            b.visible = this.visible;
            return b
        }, clone: function () {
            for (var a = new this.constructor,
                     b = 0; b < this.materials.length; b++)a.materials.push(this.materials[b].clone());
            a.visible = this.visible;
            return a
        }
    };
    Qa.prototype = Object.create(X.prototype);
    Qa.prototype.constructor = Qa;
    Qa.prototype.isMeshStandardMaterial = !0;
    Qa.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.defines = {STANDARD: ""};
        this.color.copy(a.color);
        this.roughness = a.roughness;
        this.metalness = a.metalness;
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.roughnessMap = a.roughnessMap;
        this.metalnessMap = a.metalnessMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.envMapIntensity = a.envMapIntensity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals =
            a.morphNormals;
        return this
    };
    rb.prototype = Object.create(Qa.prototype);
    rb.prototype.constructor = rb;
    rb.prototype.isMeshPhysicalMaterial = !0;
    rb.prototype.copy = function (a) {
        Qa.prototype.copy.call(this, a);
        this.defines = {PHYSICAL: ""};
        this.reflectivity = a.reflectivity;
        this.clearCoat = a.clearCoat;
        this.clearCoatRoughness = a.clearCoatRoughness;
        return this
    };
    Ca.prototype = Object.create(X.prototype);
    Ca.prototype.constructor = Ca;
    Ca.prototype.isMeshPhongMaterial = !0;
    Ca.prototype.copy = function (a) {
        X.prototype.copy.call(this,
            a);
        this.color.copy(a.color);
        this.specular.copy(a.specular);
        this.shininess = a.shininess;
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale =
            a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this
    };
    sb.prototype =
        Object.create(Ca.prototype);
    sb.prototype.constructor = sb;
    sb.prototype.isMeshToonMaterial = !0;
    sb.prototype.copy = function (a) {
        Ca.prototype.copy.call(this, a);
        this.gradientMap = a.gradientMap;
        return this
    };
    tb.prototype = Object.create(X.prototype);
    tb.prototype.constructor = tb;
    tb.prototype.isMeshNormalMaterial = !0;
    tb.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this
    };
    ub.prototype = Object.create(X.prototype);
    ub.prototype.constructor = ub;
    ub.prototype.isMeshLambertMaterial = !0;
    ub.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity =
            a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this
    };
    vb.prototype = Object.create(X.prototype);
    vb.prototype.constructor = vb;
    vb.prototype.isLineDashedMaterial = !0;
    vb.prototype.copy = function (a) {
        X.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.linewidth = a.linewidth;
        this.scale = a.scale;
        this.dashSize = a.dashSize;
        this.gapSize = a.gapSize;
        return this
    };
    var Xf = Object.freeze({
        ShadowMaterial: bc,
        SpriteMaterial: nb,
        RawShaderMaterial: cc,
        ShaderMaterial: Ha,
        PointsMaterial: Oa,
        MultiMaterial: Xc,
        MeshPhysicalMaterial: rb,
        MeshStandardMaterial: Qa,
        MeshPhongMaterial: Ca,
        MeshToonMaterial: sb,
        MeshNormalMaterial: tb,
        MeshLambertMaterial: ub,
        MeshDepthMaterial: ab,
        MeshBasicMaterial: Ka,
        LineDashedMaterial: vb,
        LineBasicMaterial: ia,
        Material: X
    }), ld = {
        enabled: !1, files: {}, add: function (a, b) {
            !1 !== this.enabled && (this.files[a] = b)
        }, get: function (a) {
            if (!1 !== this.enabled)return this.files[a]
        }, remove: function (a) {
            delete this.files[a]
        }, clear: function () {
            this.files = {}
        }
    }, ta = new $d;
    Object.assign(sa.prototype, {
        load: function (a,
                        b, c, d) {
            void 0 === a && (a = "");
            void 0 !== this.path && (a = this.path + a);
            var e = this, f = ld.get(a);
            if (void 0 !== f)return e.manager.itemStart(a), setTimeout(function () {
                b && b(f);
                e.manager.itemEnd(a)
            }, 0), f;
            var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
            if (g) {
                var h = g[1], m = !!g[2], g = g[3], g = window.decodeURIComponent(g);
                m && (g = window.atob(g));
                try {
                    var k, l = (this.responseType || "").toLowerCase();
                    switch (l) {
                        case "arraybuffer":
                        case "blob":
                            k = new ArrayBuffer(g.length);
                            for (var p = new Uint8Array(k), m = 0; m < g.length; m++)p[m] = g.charCodeAt(m);
                            "blob" === l && (k = new Blob([k], {type: h}));
                            break;
                        case "document":
                            k = (new DOMParser).parseFromString(g, h);
                            break;
                        case "json":
                            k = JSON.parse(g);
                            break;
                        default:
                            k = g
                    }
                    window.setTimeout(function () {
                        b && b(k);
                        e.manager.itemEnd(a)
                    }, 0)
                } catch (q) {
                    window.setTimeout(function () {
                        d && d(q);
                        e.manager.itemError(a)
                    }, 0)
                }
            } else {
                var n = new XMLHttpRequest;
                n.open("GET", a, !0);
                n.addEventListener("load", function (c) {
                    var f = c.target.response;
                    ld.add(a, f);
                    200 === this.status ? (b && b(f), e.manager.itemEnd(a)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    b && b(f), e.manager.itemEnd(a)) : (d && d(c), e.manager.itemError(a))
                }, !1);
                void 0 !== c && n.addEventListener("progress", function (a) {
                    c(a)
                }, !1);
                n.addEventListener("error", function (b) {
                    d && d(b);
                    e.manager.itemError(a)
                }, !1);
                void 0 !== this.responseType && (n.responseType = this.responseType);
                void 0 !== this.withCredentials && (n.withCredentials = this.withCredentials);
                n.overrideMimeType && n.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                n.send(null)
            }
            e.manager.itemStart(a);
            return n
        }, setPath: function (a) {
            this.path =
                a;
            return this
        }, setResponseType: function (a) {
            this.responseType = a;
            return this
        }, setWithCredentials: function (a) {
            this.withCredentials = a;
            return this
        }, setMimeType: function (a) {
            this.mimeType = a;
            return this
        }
    });
    Object.assign(Re.prototype, {
        load: function (a, b, c, d) {
            function e(e) {
                m.load(a[e], function (a) {
                    a = f._parser(a, !0);
                    g[e] = {width: a.width, height: a.height, format: a.format, mipmaps: a.mipmaps};
                    k += 1;
                    6 === k && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h))
                }, c, d)
            }

            var f = this, g = [], h = new Nb;
            h.image = g;
            var m = new sa(this.manager);
            m.setPath(this.path);
            m.setResponseType("arraybuffer");
            if (Array.isArray(a))for (var k = 0, l = 0, p = a.length; l < p; ++l)e(l); else m.load(a, function (a) {
                a = f._parser(a, !0);
                if (a.isCubemap)for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                    g[d] = {mipmaps: []};
                    for (var e = 0; e < a.mipmapCount; e++)g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
                } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
                1 === a.mipmapCount &&
                (h.minFilter = 1006);
                h.format = a.format;
                h.needsUpdate = !0;
                b && b(h)
            }, c, d);
            return h
        }, setPath: function (a) {
            this.path = a;
            return this
        }
    });
    Object.assign(ae.prototype, {
        load: function (a, b, c, d) {
            var e = this, f = new eb, g = new sa(this.manager);
            g.setResponseType("arraybuffer");
            g.load(a, function (a) {
                if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !==
                a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a)
            }, c, d);
            return f
        }
    });
    Object.assign(Yc.prototype, {
        load: function (a, b, c, d) {
            void 0 === a && (a = "");
            void 0 !== this.path && (a = this.path + a);
            var e = this, f = ld.get(a);
            if (void 0 !== f)return e.manager.itemStart(a), setTimeout(function () {
                b &&
                b(f);
                e.manager.itemEnd(a)
            }, 0), f;
            c = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            c.addEventListener("load", function () {
                ld.add(a, this);
                b && b(this);
                e.manager.itemEnd(a)
            }, !1);
            c.addEventListener("error", function (b) {
                d && d(b);
                e.manager.itemError(a)
            }, !1);
            void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin);
            e.manager.itemStart(a);
            c.src = a;
            return c
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a;
            return this
        }, setPath: function (a) {
            this.path = a;
            return this
        }
    });
    Object.assign(be.prototype, {
        load: function (a,
                        b, c, d) {
            function e(c) {
                g.load(a[c], function (a) {
                    f.images[c] = a;
                    h++;
                    6 === h && (f.needsUpdate = !0, b && b(f))
                }, void 0, d)
            }

            var f = new Za, g = new Yc(this.manager);
            g.setCrossOrigin(this.crossOrigin);
            g.setPath(this.path);
            var h = 0;
            for (c = 0; c < a.length; ++c)e(c);
            return f
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a;
            return this
        }, setPath: function (a) {
            this.path = a;
            return this
        }
    });
    Object.assign(td.prototype, {
        load: function (a, b, c, d) {
            var e = new ea, f = new Yc(this.manager);
            f.setCrossOrigin(this.crossOrigin);
            f.setPath(this.path);
            f.load(a,
                function (c) {
                    var d = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data\:image\/jpeg/);
                    e.format = d ? 1022 : 1023;
                    e.image = c;
                    e.needsUpdate = !0;
                    void 0 !== b && b(e)
                }, c, d);
            return e
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a;
            return this
        }, setPath: function (a) {
            this.path = a;
            return this
        }
    });
    ma.prototype = Object.assign(Object.create(x.prototype), {
        constructor: ma, isLight: !0, copy: function (a) {
            x.prototype.copy.call(this, a);
            this.color.copy(a.color);
            this.intensity = a.intensity;
            return this
        }, toJSON: function (a) {
            a = x.prototype.toJSON.call(this,
                a);
            a.object.color = this.color.getHex();
            a.object.intensity = this.intensity;
            void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
            void 0 !== this.distance && (a.object.distance = this.distance);
            void 0 !== this.angle && (a.object.angle = this.angle);
            void 0 !== this.decay && (a.object.decay = this.decay);
            void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
            void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
            return a
        }
    });
    ud.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: ud,
        isHemisphereLight: !0, copy: function (a) {
            ma.prototype.copy.call(this, a);
            this.groundColor.copy(a.groundColor);
            return this
        }
    });
    Object.assign(wb.prototype, {
        copy: function (a) {
            this.camera = a.camera.clone();
            this.bias = a.bias;
            this.radius = a.radius;
            this.mapSize.copy(a.mapSize);
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, toJSON: function () {
            var a = {};
            0 !== this.bias && (a.bias = this.bias);
            1 !== this.radius && (a.radius = this.radius);
            if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray();
            a.camera = this.camera.toJSON(!1).object;
            delete a.camera.matrix;
            return a
        }
    });
    vd.prototype = Object.assign(Object.create(wb.prototype), {
        constructor: vd,
        isSpotLightShadow: !0,
        update: function (a) {
            var b = 2 * N.RAD2DEG * a.angle, c = this.mapSize.width / this.mapSize.height;
            a = a.distance || 500;
            var d = this.camera;
            if (b !== d.fov || c !== d.aspect || a !== d.far) d.fov = b, d.aspect = c, d.far = a, d.updateProjectionMatrix()
        }
    });
    wd.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: wd, isSpotLight: !0, copy: function (a) {
            ma.prototype.copy.call(this,
                a);
            this.distance = a.distance;
            this.angle = a.angle;
            this.penumbra = a.penumbra;
            this.decay = a.decay;
            this.target = a.target.clone();
            this.shadow = a.shadow.clone();
            return this
        }
    });
    xd.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: xd, isPointLight: !0, copy: function (a) {
            ma.prototype.copy.call(this, a);
            this.distance = a.distance;
            this.decay = a.decay;
            this.shadow = a.shadow.clone();
            return this
        }
    });
    yd.prototype = Object.assign(Object.create(wb.prototype), {constructor: yd});
    zd.prototype = Object.assign(Object.create(ma.prototype),
        {
            constructor: zd, isDirectionalLight: !0, copy: function (a) {
            ma.prototype.copy.call(this, a);
            this.target = a.target.clone();
            this.shadow = a.shadow.clone();
            return this
        }
        });
    Ad.prototype = Object.assign(Object.create(ma.prototype), {constructor: Ad, isAmbientLight: !0});
    var na = {
        arraySlice: function (a, b, c) {
            return na.isTypedArray(a) ? new a.constructor(a.subarray(b, c)) : a.slice(b, c)
        }, convertArray: function (a, b, c) {
            return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
        },
        isTypedArray: function (a) {
            return ArrayBuffer.isView(a) && !(a instanceof DataView)
        }, getKeyframeOrder: function (a) {
            for (var b = a.length, c = Array(b), d = 0; d !== b; ++d)c[d] = d;
            c.sort(function (b, c) {
                return a[b] - a[c]
            });
            return c
        }, sortedArray: function (a, b, c) {
            for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)for (var h = c[f] * b,
                                                                                                 m = 0; m !== b; ++m)e[g++] = a[h + m];
            return e
        }, flattenJSON: function (a, b, c, d) {
            for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];)f = a[e++];
            if (void 0 !== f) {
                var g = f[d];
                if (void 0 !== g)if (Array.isArray(g)) {
                    do g =
                        f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
                } else if (void 0 !== g.toArray) {
                    do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
                } else {
                    do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f)
                }
            }
        }
    };
    xa.prototype = {
        constructor: xa, evaluate: function (a) {
            var b = this.parameterPositions, c = this._cachedIndex, d = b[c], e = b[c - 1];
            a:{
                b:{
                    c:{
                        d:if (!(a < d)) {
                            for (var f = c + 2; ;) {
                                if (void 0 === d) {
                                    if (a < e)break d;
                                    this._cachedIndex = c = b.length;
                                    return this.afterEnd_(c -
                                        1, a, e)
                                }
                                if (c === f)break;
                                e = d;
                                d = b[++c];
                                if (a < d)break b
                            }
                            d = b.length;
                            break c
                        }
                        if (a >= e)break a; else {
                            f = b[1];
                            a < f && (c = 2, e = f);
                            for (f = c - 2; ;) {
                                if (void 0 === e)return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                                if (c === f)break;
                                d = e;
                                e = b[--c - 1];
                                if (a >= e)break b
                            }
                            d = c;
                            c = 0
                        }
                    }
                    for (; c < d;)e = c + d >>> 1, a < b[e] ? d = e : c = e + 1;
                    d = b[c];
                    e = b[c - 1];
                    if (void 0 === e)return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                    if (void 0 === d)return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
                }
                this._cachedIndex = c;
                this.intervalChanged_(c, e, d)
            }
            return this.interpolate_(c,
                e, a, d)
        }, settings: null, DefaultSettings_: {}, getSettings_: function () {
            return this.settings || this.DefaultSettings_
        }, copySampleValue_: function (a) {
            var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize;
            a *= d;
            for (var e = 0; e !== d; ++e)b[e] = c[a + e];
            return b
        }, interpolate_: function (a, b, c, d) {
            throw Error("call to abstract method");
        }, intervalChanged_: function (a, b, c) {
        }
    };
    Object.assign(xa.prototype, {
        beforeStart_: xa.prototype.copySampleValue_,
        afterEnd_: xa.prototype.copySampleValue_
    });
    Bd.prototype = Object.assign(Object.create(xa.prototype),
        {
            constructor: Bd,
            DefaultSettings_: {endingStart: 2400, endingEnd: 2400},
            intervalChanged_: function (a, b, c) {
                var d = this.parameterPositions, e = a - 2, f = a + 1, g = d[e], h = d[f];
                if (void 0 === g)switch (this.getSettings_().endingStart) {
                    case 2401:
                        e = a;
                        g = 2 * b - c;
                        break;
                    case 2402:
                        e = d.length - 2;
                        g = b + d[e] - d[e + 1];
                        break;
                    default:
                        e = a, g = c
                }
                if (void 0 === h)switch (this.getSettings_().endingEnd) {
                    case 2401:
                        f = a;
                        h = 2 * c - b;
                        break;
                    case 2402:
                        f = 1;
                        h = c + d[1] - d[0];
                        break;
                    default:
                        f = a - 1, h = b
                }
                a = .5 * (c - b);
                d = this.valueSize;
                this._weightPrev = a / (b - g);
                this._weightNext =
                    a / (h - c);
                this._offsetPrev = e * d;
                this._offsetNext = f * d
            },
            interpolate_: function (a, b, c, d) {
                var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
                a *= g;
                var h = a - g, m = this._offsetPrev, k = this._offsetNext, l = this._weightPrev, p = this._weightNext,
                    n = (c - b) / (d - b);
                c = n * n;
                d = c * n;
                b = -l * d + 2 * l * c - l * n;
                l = (1 + l) * d + (-1.5 - 2 * l) * c + (-.5 + l) * n + 1;
                n = (-1 - p) * d + (1.5 + p) * c + .5 * n;
                p = p * d - p * c;
                for (c = 0; c !== g; ++c)e[c] = b * f[m + c] + l * f[h + c] + n * f[a + c] + p * f[k + c];
                return e
            }
        });
    Zc.prototype = Object.assign(Object.create(xa.prototype), {
        constructor: Zc, interpolate_: function (a,
                                                 b, c, d) {
            var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
            a *= g;
            var h = a - g;
            b = (c - b) / (d - b);
            c = 1 - b;
            for (d = 0; d !== g; ++d)e[d] = f[h + d] * c + f[a + d] * b;
            return e
        }
    });
    Cd.prototype = Object.assign(Object.create(xa.prototype), {
        constructor: Cd, interpolate_: function (a, b, c, d) {
            return this.copySampleValue_(a - 1)
        }
    });
    var Xa;
    Xa = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (a) {
            return new Cd(this.times, this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodLinear: function (a) {
            return new Zc(this.times,
                this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodSmooth: function (a) {
            return new Bd(this.times, this.values, this.getValueSize(), a)
        },
        setInterpolation: function (a) {
            var b;
            switch (a) {
                case 2300:
                    b = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    b = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    b = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === b) {
                b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant)if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw Error(b);
                console.warn(b)
            } else this.createInterpolant = b
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length
        },
        shift: function (a) {
            if (0 !== a)for (var b = this.times, c = 0, d = b.length; c !== d; ++c)b[c] += a;
            return this
        },
        scale: function (a) {
            if (1 !== a)for (var b = this.times, c =
                0, d = b.length; c !== d; ++c)b[c] *= a;
            return this
        },
        trim: function (a, b) {
            for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;)++e;
            for (; -1 !== f && c[f] > b;)--f;
            ++f;
            if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), d = this.getValueSize(), this.times = na.arraySlice(c, e, f), this.values = na.arraySlice(this.values, e * d, f * d);
            return this
        },
        validate: function () {
            var a = !0, b = this.getValueSize();
            0 !== b - Math.floor(b) && (console.error("invalid value size in track", this), a = !1);
            var c = this.times, b = this.values, d = c.length;
            0 === d && (console.error("track is empty",
                this), a = !1);
            for (var e = null, f = 0; f !== d; f++) {
                var g = c[f];
                if ("number" === typeof g && isNaN(g)) {
                    console.error("time is not a valid number", this, f, g);
                    a = !1;
                    break
                }
                if (null !== e && e > g) {
                    console.error("out of order keys", this, f, g, e);
                    a = !1;
                    break
                }
                e = g
            }
            if (void 0 !== b && na.isTypedArray(b))for (f = 0, c = b.length; f !== c; ++f)if (d = b[f], isNaN(d)) {
                console.error("value is not a valid number", this, f, d);
                a = !1;
                break
            }
            return a
        },
        optimize: function () {
            for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(),
                     e = 1,
                     f = a.length - 1, g = 1; g < f; ++g) {
                var h = !1, m = a[g];
                if (m !== a[g + 1] && (1 !== g || m !== m[0]))if (d) h = !0; else for (var k = g * c, l = k - c,
                                                                                           p = k + c,
                                                                                           m = 0; m !== c; ++m) {
                    var n = b[k + m];
                    if (n !== b[l + m] || n !== b[p + m]) {
                        h = !0;
                        break
                    }
                }
                if (h) {
                    if (g !== e)for (a[e] = a[g], h = g * c, k = e * c, m = 0; m !== c; ++m)b[k + m] = b[h + m];
                    ++e
                }
            }
            if (0 < f) {
                a[e] = a[f];
                h = f * c;
                k = e * c;
                for (m = 0; m !== c; ++m)b[k + m] = b[h + m];
                ++e
            }
            e !== a.length && (this.times = na.arraySlice(a, 0, e), this.values = na.arraySlice(b, 0, e * c));
            return this
        }
    };
    dc.prototype = Object.assign(Object.create(Xa), {constructor: dc, ValueTypeName: "vector"});
    Dd.prototype = Object.assign(Object.create(xa.prototype), {
        constructor: Dd, interpolate_: function (a, b, c, d) {
            var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
            a *= g;
            b = (c - b) / (d - b);
            for (c = a + g; a !== c; a += 4)ca.slerpFlat(e, 0, f, a - g, f, a, b);
            return e
        }
    });
    $c.prototype = Object.assign(Object.create(Xa), {
        constructor: $c,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (a) {
            return new Dd(this.times, this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodSmooth: void 0
    });
    ec.prototype = Object.assign(Object.create(Xa), {constructor: ec, ValueTypeName: "number"});
    Ed.prototype = Object.assign(Object.create(Xa), {
        constructor: Ed,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    });
    Fd.prototype = Object.assign(Object.create(Xa), {
        constructor: Fd,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    });
    Gd.prototype = Object.assign(Object.create(Xa), {constructor: Gd, ValueTypeName: "color"});
    yb.prototype = Xa;
    Xa.constructor = yb;
    Object.assign(yb, {
        parse: function (a) {
            if (void 0 === a.type)throw Error("track type undefined, can not parse");
            var b = yb._getTrackTypeForValueTypeName(a.type);
            if (void 0 === a.times) {
                var c = [], d = [];
                na.flattenJSON(a.keys, c, d, "value");
                a.times = c;
                a.values = d
            }
            return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
        }, toJSON: function (a) {
            var b = a.constructor;
            if (void 0 !== b.toJSON) b =
                b.toJSON(a); else {
                var b = {
                    name: a.name,
                    times: na.convertArray(a.times, Array),
                    values: na.convertArray(a.values, Array)
                }, c = a.getInterpolation();
                c !== a.DefaultInterpolation && (b.interpolation = c)
            }
            b.type = a.ValueTypeName;
            return b
        }, _getTrackTypeForValueTypeName: function (a) {
            switch (a.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return ec;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return dc;
                case "color":
                    return Gd;
                case "quaternion":
                    return $c;
                case "bool":
                case "boolean":
                    return Fd;
                case "string":
                    return Ed
            }
            throw Error("Unsupported typeName: " + a);
        }
    });
    qa.prototype = {
        constructor: qa, resetDuration: function () {
            for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b)var d = this.tracks[b],
                a = Math.max(a, d.times[d.times.length - 1]);
            this.duration = a
        }, trim: function () {
            for (var a = 0; a < this.tracks.length; a++)this.tracks[a].trim(0, this.duration);
            return this
        }, optimize: function () {
            for (var a = 0; a < this.tracks.length; a++)this.tracks[a].optimize();
            return this
        }
    };
    Object.assign(qa, {
        parse: function (a) {
            for (var b = [], c = a.tracks,
                     d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e)b.push(yb.parse(c[e]).scale(d));
            return new qa(a.name, a.duration, b)
        }, toJSON: function (a) {
            var b = [], c = a.tracks;
            a = {name: a.name, duration: a.duration, tracks: b};
            for (var d = 0, e = c.length; d !== e; ++d)b.push(yb.toJSON(c[d]));
            return a
        }, CreateFromMorphTargetSequence: function (a, b, c, d) {
            for (var e = b.length, f = [], g = 0; g < e; g++) {
                var h = [], m = [];
                h.push((g + e - 1) % e, g, (g + 1) % e);
                m.push(0, 1, 0);
                var k = na.getKeyframeOrder(h), h = na.sortedArray(h, 1, k), m = na.sortedArray(m, 1, k);
                d || 0 !== h[0] || (h.push(e),
                    m.push(m[0]));
                f.push((new ec(".morphTargetInfluences[" + b[g].name + "]", h, m)).scale(1 / c))
            }
            return new qa(a, -1, f)
        }, findByName: function (a, b) {
            var c = a;
            Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
            for (var d = 0; d < c.length; d++)if (c[d].name === b)return c[d];
            return null
        }, CreateClipsFromMorphTargetSequences: function (a, b, c) {
            for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
                var h = a[f], m = h.name.match(e);
                if (m && 1 < m.length) {
                    var k = m[1];
                    (m = d[k]) || (d[k] = m = []);
                    m.push(h)
                }
            }
            a = [];
            for (k in d)a.push(qa.CreateFromMorphTargetSequence(k,
                d[k], b, c));
            return a
        }, parseAnimation: function (a, b) {
            if (!a)return console.error("  no animation in JSONLoader data"), null;
            for (var c = function (a, b, c, d, e) {
                    if (0 !== c.length) {
                        var f = [], g = [];
                        na.flattenJSON(c, f, g, d);
                        0 !== f.length && e.push(new a(b, f, g))
                    }
                }, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30, h = a.hierarchy || [],
                     m = 0; m < h.length; m++) {
                var k = h[m].keys;
                if (k && 0 !== k.length)if (k[0].morphTargets) {
                    for (var f = {},
                             l = 0; l < k.length; l++)if (k[l].morphTargets)for (var p = 0; p < k[l].morphTargets.length; p++)f[k[l].morphTargets[p]] =
                        -1;
                    for (var n in f) {
                        for (var q = [], G = [], p = 0; p !== k[l].morphTargets.length; ++p) {
                            var r = k[l];
                            q.push(r.time);
                            G.push(r.morphTarget === n ? 1 : 0)
                        }
                        d.push(new ec(".morphTargetInfluence[" + n + "]", q, G))
                    }
                    f = f.length * (g || 1)
                } else l = ".bones[" + b[m].name + "]", c(dc, l + ".position", k, "pos", d), c($c, l + ".quaternion", k, "rot", d), c(dc, l + ".scale", k, "scl", d)
            }
            return 0 === d.length ? null : new qa(e, f, d)
        }
    });
    Object.assign(Hd.prototype, {
        load: function (a, b, c, d) {
            var e = this;
            (new sa(e.manager)).load(a, function (a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        }, setTextures: function (a) {
            this.textures =
                a
        }, parse: function (a) {
            function b(a) {
                void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
                return c[a]
            }

            var c = this.textures, d = new Xf[a.type];
            void 0 !== a.uuid && (d.uuid = a.uuid);
            void 0 !== a.name && (d.name = a.name);
            void 0 !== a.color && d.color.setHex(a.color);
            void 0 !== a.roughness && (d.roughness = a.roughness);
            void 0 !== a.metalness && (d.metalness = a.metalness);
            void 0 !== a.emissive && d.emissive.setHex(a.emissive);
            void 0 !== a.specular && d.specular.setHex(a.specular);
            void 0 !== a.shininess && (d.shininess = a.shininess);
            void 0 !== a.clearCoat && (d.clearCoat = a.clearCoat);
            void 0 !== a.clearCoatRoughness && (d.clearCoatRoughness = a.clearCoatRoughness);
            void 0 !== a.uniforms && (d.uniforms = a.uniforms);
            void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader);
            void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader);
            void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
            void 0 !== a.fog && (d.fog = a.fog);
            void 0 !== a.shading && (d.shading = a.shading);
            void 0 !== a.blending && (d.blending = a.blending);
            void 0 !== a.side && (d.side = a.side);
            void 0 !==
            a.opacity && (d.opacity = a.opacity);
            void 0 !== a.transparent && (d.transparent = a.transparent);
            void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest);
            void 0 !== a.depthTest && (d.depthTest = a.depthTest);
            void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite);
            void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite);
            void 0 !== a.wireframe && (d.wireframe = a.wireframe);
            void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth);
            void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap);
            void 0 !== a.wireframeLinejoin &&
            (d.wireframeLinejoin = a.wireframeLinejoin);
            void 0 !== a.skinning && (d.skinning = a.skinning);
            void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets);
            void 0 !== a.size && (d.size = a.size);
            void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation);
            void 0 !== a.map && (d.map = b(a.map));
            void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0);
            void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap));
            void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale);
            void 0 !== a.normalMap && (d.normalMap = b(a.normalMap));
            if (void 0 !== a.normalScale) {
                var e =
                    a.normalScale;
                !1 === Array.isArray(e) && (e = [e, e]);
                d.normalScale = (new D).fromArray(e)
            }
            void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap));
            void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale);
            void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias);
            void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap));
            void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap));
            void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap));
            void 0 !== a.emissiveIntensity && (d.emissiveIntensity =
                a.emissiveIntensity);
            void 0 !== a.specularMap && (d.specularMap = b(a.specularMap));
            void 0 !== a.envMap && (d.envMap = b(a.envMap));
            void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity);
            void 0 !== a.lightMap && (d.lightMap = b(a.lightMap));
            void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity);
            void 0 !== a.aoMap && (d.aoMap = b(a.aoMap));
            void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity);
            void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap));
            if (void 0 !== a.materials)for (var e = 0, f = a.materials.length; e <
            f; e++)d.materials.push(this.parse(a.materials[e]));
            return d
        }
    });
    Object.assign(ce.prototype, {
        load: function (a, b, c, d) {
            var e = this;
            (new sa(e.manager)).load(a, function (a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        }, parse: function (a) {
            var b = new I, c = a.data.index, d = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            void 0 !== c && (c = new d[c.type](c.array),
                b.setIndex(new U(c, 1)));
            var e = a.data.attributes, f;
            for (f in e) {
                var g = e[f], c = new d[g.type](g.array);
                b.addAttribute(f, new U(c, g.itemSize, g.normalized))
            }
            d = a.data.groups || a.data.drawcalls || a.data.offsets;
            if (void 0 !== d)for (f = 0, c = d.length; f !== c; ++f)e = d[f], b.addGroup(e.start, e.count, e.materialIndex);
            a = a.data.boundingSphere;
            void 0 !== a && (d = new q, void 0 !== a.center && d.fromArray(a.center), b.boundingSphere = new Na(d, a.radius));
            return b
        }
    });
    zb.prototype = {
        constructor: zb, crossOrigin: void 0, extractUrlBase: function (a) {
            a =
                a.split("/");
            if (1 === a.length)return "./";
            a.pop();
            return a.join("/") + "/"
        }, initMaterials: function (a, b, c) {
            for (var d = [], e = 0; e < a.length; ++e)d[e] = this.createMaterial(a[e], b, c);
            return d
        }, createMaterial: function () {
            var a = {
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5
            }, b, c, d;
            return function (e, f, g) {
                function h(a, b, d, e, h) {
                    a = f + a;
                    var k = zb.Handlers.get(a);
                    null !== k ? a = k.load(a) : (c.setCrossOrigin(g), a = c.load(a));
                    void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] &&
                    (a.wrapS = 1E3), 1 !== b[1] && (a.wrapT = 1E3));
                    void 0 !== d && a.offset.fromArray(d);
                    void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1E3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1E3), "mirror" === e[1] && (a.wrapT = 1002));
                    void 0 !== h && (a.anisotropy = h);
                    b = N.generateUUID();
                    m[b] = a;
                    return b
                }

                void 0 === b && (b = new J);
                void 0 === c && (c = new td);
                void 0 === d && (d = new Hd);
                var m = {}, k = {uuid: N.generateUUID(), type: "MeshLambertMaterial"}, l;
                for (l in e) {
                    var p = e[l];
                    switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            k.name = p;
                            break;
                        case "blending":
                            k.blending = a[p];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            k.color = b.fromArray(p).getHex();
                            break;
                        case "colorSpecular":
                            k.specular = b.fromArray(p).getHex();
                            break;
                        case "colorEmissive":
                            k.emissive = b.fromArray(p).getHex();
                            break;
                        case "specularCoef":
                            k.shininess = p;
                            break;
                        case "shading":
                            "basic" === p.toLowerCase() && (k.type = "MeshBasicMaterial");
                            "phong" === p.toLowerCase() &&
                            (k.type = "MeshPhongMaterial");
                            "standard" === p.toLowerCase() && (k.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            k.map = h(p, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            k.emissiveMap = h(p, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            k.lightMap = h(p, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            k.aoMap = h(p, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            k.bumpMap = h(p, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            k.bumpScale =
                                p;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            k.normalMap = h(p, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            k.normalScale = [p, p];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            k.specularMap = h(p, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            k.metalnessMap = h(p, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            k.roughnessMap = h(p, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            k.alphaMap =
                                h(p, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            k.side = 1;
                            break;
                        case "doubleSided":
                            k.side = 2;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
                            k.opacity = p;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            k[l] =
                                p;
                            break;
                        case "vertexColors":
                            !0 === p && (k.vertexColors = 2);
                            "face" === p && (k.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", l, p)
                    }
                }
                "MeshBasicMaterial" === k.type && delete k.emissive;
                "MeshPhongMaterial" !== k.type && delete k.specular;
                1 > k.opacity && (k.transparent = !0);
                d.setTextures(m);
                return d.parse(k)
            }
        }()
    };
    zb.Handlers = {
        handlers: [], add: function (a, b) {
            this.handlers.push(a, b)
        }, get: function (a) {
            for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
                var e = b[c + 1];
                if (b[c].test(a))return e
            }
            return null
        }
    };
    Object.assign(de.prototype, {
        load: function (a, b, c, d) {
            var e = this,
                f = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : zb.prototype.extractUrlBase(a),
                g = new sa(this.manager);
            g.setWithCredentials(this.withCredentials);
            g.load(a, function (c) {
                c = JSON.parse(c);
                var d = c.metadata;
                if (void 0 !== d && (d = d.type, void 0 !== d)) {
                    if ("object" === d.toLowerCase()) {
                        console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                        return
                    }
                    if ("scene" === d.toLowerCase()) {
                        console.error("THREE.JSONLoader: " +
                            a + " should be loaded with THREE.SceneLoader instead.");
                        return
                    }
                }
                c = e.parse(c, f);
                b(c.geometry, c.materials)
            }, c, d)
        }, setTexturePath: function (a) {
            this.texturePath = a
        }, parse: function (a, b) {
            var c = new T, d = void 0 !== a.scale ? 1 / a.scale : 1;
            (function (b) {
                var d, g, h, m, k, l, p, n, u, G, r, A, w, y = a.faces;
                l = a.vertices;
                var x = a.normals, v = a.colors, z = 0;
                if (void 0 !== a.uvs) {
                    for (d = 0; d < a.uvs.length; d++)a.uvs[d].length && z++;
                    for (d = 0; d < z; d++)c.faceVertexUvs[d] = []
                }
                m = 0;
                for (k = l.length; m < k;)d = new q, d.x = l[m++] * b, d.y = l[m++] * b, d.z = l[m++] * b, c.vertices.push(d);
                m = 0;
                for (k = y.length; m < k;)if (b = y[m++], u = b & 1, h = b & 2, d = b & 8, p = b & 16, G = b & 32, l = b & 64, b &= 128, u) {
                    u = new ha;
                    u.a = y[m];
                    u.b = y[m + 1];
                    u.c = y[m + 3];
                    r = new ha;
                    r.a = y[m + 1];
                    r.b = y[m + 2];
                    r.c = y[m + 3];
                    m += 4;
                    h && (h = y[m++], u.materialIndex = h, r.materialIndex = h);
                    h = c.faces.length;
                    if (d)for (d = 0; d < z; d++)for (A = a.uvs[d], c.faceVertexUvs[d][h] = [], c.faceVertexUvs[d][h + 1] = [], g = 0; 4 > g; g++)n = y[m++], w = A[2 * n], n = A[2 * n + 1], w = new D(w, n), 2 !== g && c.faceVertexUvs[d][h].push(w), 0 !== g && c.faceVertexUvs[d][h + 1].push(w);
                    p && (p = 3 * y[m++], u.normal.set(x[p++], x[p++], x[p]),
                        r.normal.copy(u.normal));
                    if (G)for (d = 0; 4 > d; d++)p = 3 * y[m++], G = new q(x[p++], x[p++], x[p]), 2 !== d && u.vertexNormals.push(G), 0 !== d && r.vertexNormals.push(G);
                    l && (l = y[m++], l = v[l], u.color.setHex(l), r.color.setHex(l));
                    if (b)for (d = 0; 4 > d; d++)l = y[m++], l = v[l], 2 !== d && u.vertexColors.push(new J(l)), 0 !== d && r.vertexColors.push(new J(l));
                    c.faces.push(u);
                    c.faces.push(r)
                } else {
                    u = new ha;
                    u.a = y[m++];
                    u.b = y[m++];
                    u.c = y[m++];
                    h && (h = y[m++], u.materialIndex = h);
                    h = c.faces.length;
                    if (d)for (d = 0; d < z; d++)for (A = a.uvs[d], c.faceVertexUvs[d][h] =
                        [], g = 0; 3 > g; g++)n = y[m++], w = A[2 * n], n = A[2 * n + 1], w = new D(w, n), c.faceVertexUvs[d][h].push(w);
                    p && (p = 3 * y[m++], u.normal.set(x[p++], x[p++], x[p]));
                    if (G)for (d = 0; 3 > d; d++)p = 3 * y[m++], G = new q(x[p++], x[p++], x[p]), u.vertexNormals.push(G);
                    l && (l = y[m++], u.color.setHex(v[l]));
                    if (b)for (d = 0; 3 > d; d++)l = y[m++], u.vertexColors.push(new J(v[l]));
                    c.faces.push(u)
                }
            })(d);
            (function () {
                var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
                if (a.skinWeights)for (var d = 0,
                                           g = a.skinWeights.length; d < g; d += b)c.skinWeights.push(new fa(a.skinWeights[d],
                    1 < b ? a.skinWeights[d + 1] : 0, 2 < b ? a.skinWeights[d + 2] : 0, 3 < b ? a.skinWeights[d + 3] : 0));
                if (a.skinIndices)for (d = 0, g = a.skinIndices.length; d < g; d += b)c.skinIndices.push(new fa(a.skinIndices[d], 1 < b ? a.skinIndices[d + 1] : 0, 2 < b ? a.skinIndices[d + 2] : 0, 3 < b ? a.skinIndices[d + 3] : 0));
                c.bones = a.bones;
                c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" +
                    c.skinWeights.length + ") should match.")
            })();
            (function (b) {
                if (void 0 !== a.morphTargets)for (var d = 0, g = a.morphTargets.length; d < g; d++) {
                    c.morphTargets[d] = {};
                    c.morphTargets[d].name = a.morphTargets[d].name;
                    c.morphTargets[d].vertices = [];
                    for (var h = c.morphTargets[d].vertices, m = a.morphTargets[d].vertices, k = 0,
                             l = m.length; k < l; k += 3) {
                        var p = new q;
                        p.x = m[k] * b;
                        p.y = m[k + 1] * b;
                        p.z = m[k + 2] * b;
                        h.push(p)
                    }
                }
                if (void 0 !== a.morphColors && 0 < a.morphColors.length)for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'),
                                                                                  b = c.faces, h = a.morphColors[0].colors, d = 0, g = b.length; d < g; d++)b[d].color.fromArray(h, 3 * d)
            })(d);
            (function () {
                var b = [], d = [];
                void 0 !== a.animation && d.push(a.animation);
                void 0 !== a.animations && (a.animations.length ? d = d.concat(a.animations) : d.push(a.animations));
                for (var g = 0; g < d.length; g++) {
                    var h = qa.parseAnimation(d[g], c.bones);
                    h && b.push(h)
                }
                c.morphTargets && (d = qa.CreateClipsFromMorphTargetSequences(c.morphTargets, 10), b = b.concat(d));
                0 < b.length && (c.animations = b)
            })();
            c.computeFaceNormals();
            c.computeBoundingSphere();
            if (void 0 === a.materials || 0 === a.materials.length)return {geometry: c};
            d = zb.prototype.initMaterials(a.materials, b, this.crossOrigin);
            return {geometry: c, materials: d}
        }
    });
    Object.assign(Se.prototype, {
        load: function (a, b, c, d) {
            "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
            var e = this;
            (new sa(e.manager)).load(a, function (c) {
                var g = null;
                try {
                    g = JSON.parse(c)
                } catch (h) {
                    void 0 !== d && d(h);
                    console.error("THREE:ObjectLoader: Can't parse " + a + ".", h.message);
                    return
                }
                c = g.metadata;
                void 0 === c || void 0 ===
                c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(g, b)
            }, c, d)
        }, setTexturePath: function (a) {
            this.texturePath = a
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a
        }, parse: function (a, b) {
            var c = this.parseGeometries(a.geometries), d = this.parseImages(a.images, function () {
                    void 0 !== b && b(e)
                }), d = this.parseTextures(a.textures, d), d = this.parseMaterials(a.materials, d),
                e = this.parseObject(a.object, c, d);
            a.animations && (e.animations = this.parseAnimations(a.animations));
            void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
            return e
        }, parseGeometries: function (a) {
            var b = {};
            if (void 0 !== a)for (var c = new de, d = new ce, e = 0, f = a.length; e < f; e++) {
                var g, h = a[e];
                switch (h.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        g = new Ma[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        g = new Ma[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        g =
                            new Ma[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        g = new Ma[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        g = new Ma[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        g = new Ma[h.type](h.radius, h.widthSegments,
                            h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "IcosahedronGeometry":
                    case "OctahedronGeometry":
                    case "TetrahedronGeometry":
                        g = new Ma[h.type](h.radius, h.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        g = new Ma[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        g = new Ma[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        g = new Ma[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        g = new Ma[h.type](h.points, h.segments, h.phiStart, h.phiLength);
                        break;
                    case "BufferGeometry":
                        g = d.parse(h);
                        break;
                    case "Geometry":
                        g = c.parse(h.data, this.texturePath).geometry;
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                        continue
                }
                g.uuid = h.uuid;
                void 0 !== h.name && (g.name = h.name);
                b[h.uuid] = g
            }
            return b
        }, parseMaterials: function (a, b) {
            var c = {};
            if (void 0 !== a) {
                var d = new Hd;
                d.setTextures(b);
                for (var e = 0, f = a.length; e < f; e++) {
                    var g = d.parse(a[e]);
                    c[g.uuid] = g
                }
            }
            return c
        }, parseAnimations: function (a) {
            for (var b = [], c = 0; c < a.length; c++) {
                var d = qa.parse(a[c]);
                b.push(d)
            }
            return b
        }, parseImages: function (a, b) {
            function c(a) {
                d.manager.itemStart(a);
                return g.load(a, function () {
                    d.manager.itemEnd(a)
                }, void 0, function () {
                    d.manager.itemError(a)
                })
            }

            var d = this, e = {};
            if (void 0 !== a && 0 < a.length) {
                var f = new $d(b), g = new Yc(f);
                g.setCrossOrigin(this.crossOrigin);
                for (var f = 0, h = a.length; f < h; f++) {
                    var m = a[f], k = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m.url) ? m.url : d.texturePath + m.url;
                    e[m.uuid] = c(k)
                }
            }
            return e
        }, parseTextures: function (a, b) {
            function c(a, b) {
                if ("number" === typeof a)return a;
                console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
                return b[a]
            }

            var d = {
                UVMapping: 300,
                CubeReflectionMapping: 301,
                CubeRefractionMapping: 302,
                EquirectangularReflectionMapping: 303,
                EquirectangularRefractionMapping: 304,
                SphericalReflectionMapping: 305,
                CubeUVReflectionMapping: 306,
                CubeUVRefractionMapping: 307
            }, e = {RepeatWrapping: 1E3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002}, f = {
                NearestFilter: 1003,
                NearestMipMapNearestFilter: 1004,
                NearestMipMapLinearFilter: 1005,
                LinearFilter: 1006,
                LinearMipMapNearestFilter: 1007,
                LinearMipMapLinearFilter: 1008
            }, g = {};
            if (void 0 !== a)for (var h = 0, m = a.length; h < m; h++) {
                var k = a[h];
                void 0 === k.image && console.warn('THREE.ObjectLoader: No "image" specified for', k.uuid);
                void 0 === b[k.image] && console.warn("THREE.ObjectLoader: Undefined image",
                    k.image);
                var l = new ea(b[k.image]);
                l.needsUpdate = !0;
                l.uuid = k.uuid;
                void 0 !== k.name && (l.name = k.name);
                void 0 !== k.mapping && (l.mapping = c(k.mapping, d));
                void 0 !== k.offset && l.offset.fromArray(k.offset);
                void 0 !== k.repeat && l.repeat.fromArray(k.repeat);
                void 0 !== k.wrap && (l.wrapS = c(k.wrap[0], e), l.wrapT = c(k.wrap[1], e));
                void 0 !== k.minFilter && (l.minFilter = c(k.minFilter, f));
                void 0 !== k.magFilter && (l.magFilter = c(k.magFilter, f));
                void 0 !== k.anisotropy && (l.anisotropy = k.anisotropy);
                void 0 !== k.flipY && (l.flipY = k.flipY);
                g[k.uuid] =
                    l
            }
            return g
        }, parseObject: function () {
            var a = new S;
            return function (b, c, d) {
                function e(a) {
                    void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
                    return c[a]
                }

                function f(a) {
                    if (void 0 !== a)return void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a), d[a]
                }

                var g;
                switch (b.type) {
                    case "Scene":
                        g = new mb;
                        void 0 !== b.background && Number.isInteger(b.background) && (g.background = new J(b.background));
                        void 0 !== b.fog && ("Fog" === b.fog.type ? g.fog = new Lb(b.fog.color, b.fog.near, b.fog.far) : "FogExp2" ===
                            b.fog.type && (g.fog = new Kb(b.fog.color, b.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        g = new Fa(b.fov, b.aspect, b.near, b.far);
                        void 0 !== b.focus && (g.focus = b.focus);
                        void 0 !== b.zoom && (g.zoom = b.zoom);
                        void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge);
                        void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset);
                        void 0 !== b.view && (g.view = Object.assign({}, b.view));
                        break;
                    case "OrthographicCamera":
                        g = new Jb(b.left, b.right, b.top, b.bottom, b.near, b.far);
                        break;
                    case "AmbientLight":
                        g = new Ad(b.color, b.intensity);
                        break;
                    case "DirectionalLight":
                        g =
                            new zd(b.color, b.intensity);
                        break;
                    case "PointLight":
                        g = new xd(b.color, b.intensity, b.distance, b.decay);
                        break;
                    case "SpotLight":
                        g = new wd(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay);
                        break;
                    case "HemisphereLight":
                        g = new ud(b.color, b.groundColor, b.intensity);
                        break;
                    case "Mesh":
                        g = e(b.geometry);
                        var h = f(b.material);
                        g = g.bones && 0 < g.bones.length ? new qd(g, h) : new Aa(g, h);
                        break;
                    case "LOD":
                        g = new Ec;
                        break;
                    case "Line":
                        g = new Ua(e(b.geometry), f(b.material), b.mode);
                        break;
                    case "LineSegments":
                        g = new ga(e(b.geometry),
                            f(b.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        g = new Mb(e(b.geometry), f(b.material));
                        break;
                    case "Sprite":
                        g = new Dc(f(b.material));
                        break;
                    case "Group":
                        g = new Fc;
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.");
                    default:
                        g = new x
                }
                g.uuid = b.uuid;
                void 0 !== b.name && (g.name = b.name);
                void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position),
                void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.quaternion && g.quaternion.fromArray(b.quaternion), void 0 !== b.scale && g.scale.fromArray(b.scale));
                void 0 !== b.castShadow && (g.castShadow = b.castShadow);
                void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow);
                b.shadow && (void 0 !== b.shadow.bias && (g.shadow.bias = b.shadow.bias), void 0 !== b.shadow.radius && (g.shadow.radius = b.shadow.radius), void 0 !== b.shadow.mapSize && g.shadow.mapSize.fromArray(b.shadow.mapSize), void 0 !== b.shadow.camera && (g.shadow.camera =
                    this.parseObject(b.shadow.camera)));
                void 0 !== b.visible && (g.visible = b.visible);
                void 0 !== b.userData && (g.userData = b.userData);
                if (void 0 !== b.children)for (var m in b.children)g.add(this.parseObject(b.children[m], c, d));
                if ("LOD" === b.type)for (b = b.levels, h = 0; h < b.length; h++) {
                    var k = b[h];
                    m = g.getObjectByProperty("uuid", k.object);
                    void 0 !== m && g.addLevel(m, k.distance)
                }
                return g
            }
        }()
    });
    ua.prototype = {
        constructor: ua, getPoint: function (a) {
            console.warn("THREE.Curve: Warning, getPoint() not implemented!");
            return null
        }, getPointAt: function (a) {
            a =
                this.getUtoTmapping(a);
            return this.getPoint(a)
        }, getPoints: function (a) {
            isNaN(a) && (a = 5);
            for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a));
            return b
        }, getSpacedPoints: function (a) {
            isNaN(a) && (a = 5);
            for (var b = [], c = 0; c <= a; c++)b.push(this.getPointAt(c / a));
            return b
        }, getLength: function () {
            var a = this.getLengths();
            return a[a.length - 1]
        }, getLengths: function (a) {
            isNaN(a) && (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
            if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate)return this.cacheArcLengths;
            this.needsUpdate = !1;
            var b = [], c, d = this.getPoint(0), e, f = 0;
            b.push(0);
            for (e = 1; e <= a; e++)c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
            return this.cacheArcLengths = b
        }, updateArcLengths: function () {
            this.needsUpdate = !0;
            this.getLengths()
        }, getUtoTmapping: function (a, b) {
            var c = this.getLengths(), d, e = c.length, f;
            f = b ? b : a * c[e - 1];
            for (var g = 0, h = e - 1,
                     m; g <= h;)if (d = Math.floor(g + (h - g) / 2), m = c[d] - f, 0 > m) g = d + 1; else if (0 < m) h = d - 1; else {
                h = d;
                break
            }
            d = h;
            if (c[d] === f)return d / (e - 1);
            g = c[d];
            return (d + (f - g) / (c[d + 1] - g)) / (e - 1)
        }, getTangent: function (a) {
            var b =
                a - 1E-4;
            a += 1E-4;
            0 > b && (b = 0);
            1 < a && (a = 1);
            b = this.getPoint(b);
            return this.getPoint(a).clone().sub(b).normalize()
        }, getTangentAt: function (a) {
            a = this.getUtoTmapping(a);
            return this.getTangent(a)
        }, computeFrenetFrames: function (a, b) {
            var c = new q, d = [], e = [], f = [], g = new q, h = new S, m, k;
            for (m = 0; m <= a; m++)k = m / a, d[m] = this.getTangentAt(k), d[m].normalize();
            e[0] = new q;
            f[0] = new q;
            m = Number.MAX_VALUE;
            k = Math.abs(d[0].x);
            var l = Math.abs(d[0].y), p = Math.abs(d[0].z);
            k <= m && (m = k, c.set(1, 0, 0));
            l <= m && (m = l, c.set(0, 1, 0));
            p <= m && c.set(0, 0, 1);
            g.crossVectors(d[0], c).normalize();
            e[0].crossVectors(d[0], g);
            f[0].crossVectors(d[0], e[0]);
            for (m = 1; m <= a; m++)e[m] = e[m - 1].clone(), f[m] = f[m - 1].clone(), g.crossVectors(d[m - 1], d[m]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(N.clamp(d[m - 1].dot(d[m]), -1, 1)), e[m].applyMatrix4(h.makeRotationAxis(g, c))), f[m].crossVectors(d[m], e[m]);
            if (!0 === b)for (c = Math.acos(N.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c), m = 1; m <= a; m++)e[m].applyMatrix4(h.makeRotationAxis(d[m], c * m)),
                f[m].crossVectors(d[m], e[m]);
            return {tangents: d, normals: e, binormals: f}
        }
    };
    Ta.prototype = Object.create(ua.prototype);
    Ta.prototype.constructor = Ta;
    Ta.prototype.isLineCurve = !0;
    Ta.prototype.getPoint = function (a) {
        if (1 === a)return this.v2.clone();
        var b = this.v2.clone().sub(this.v1);
        b.multiplyScalar(a).add(this.v1);
        return b
    };
    Ta.prototype.getPointAt = function (a) {
        return this.getPoint(a)
    };
    Ta.prototype.getTangent = function (a) {
        return this.v2.clone().sub(this.v1).normalize()
    };
    ad.prototype = Object.assign(Object.create(ua.prototype),
        {
            constructor: ad, add: function (a) {
            this.curves.push(a)
        }, closePath: function () {
            var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
            a.equals(b) || this.curves.push(new Ta(b, a))
        }, getPoint: function (a) {
            var b = a * this.getLength(), c = this.getCurveLengths();
            for (a = 0; a < c.length;) {
                if (c[a] >= b)return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
                a++
            }
            return null
        }, getLength: function () {
            var a = this.getCurveLengths();
            return a[a.length - 1]
        }, updateArcLengths: function () {
            this.needsUpdate =
                !0;
            this.cacheLengths = null;
            this.getLengths()
        }, getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)return this.cacheLengths;
            for (var a = [], b = 0, c = 0,
                     d = this.curves.length; c < d; c++)b += this.curves[c].getLength(), a.push(b);
            return this.cacheLengths = a
        }, getSpacedPoints: function (a) {
            isNaN(a) && (a = 40);
            for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a));
            this.autoClose && b.push(b[0]);
            return b
        }, getPoints: function (a) {
            a = a || 12;
            for (var b = [], c, d = 0, e = this.curves; d < e.length; d++)for (var f =
                    e[d],
                                                                                   f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && f.isLineCurve ? 1 : f && f.isSplineCurve ? a * f.points.length : a),
                                                                                   g = 0; g < f.length; g++) {
                var h = f[g];
                c && c.equals(h) || (b.push(h), c = h)
            }
            this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
            return b
        }, createPointsGeometry: function (a) {
            a = this.getPoints(a);
            return this.createGeometry(a)
        }, createSpacedPointsGeometry: function (a) {
            a = this.getSpacedPoints(a);
            return this.createGeometry(a)
        }, createGeometry: function (a) {
            for (var b = new T, c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                b.vertices.push(new q(e.x, e.y, e.z || 0))
            }
            return b
        }
        });
    Wa.prototype = Object.create(ua.prototype);
    Wa.prototype.constructor = Wa;
    Wa.prototype.isEllipseCurve = !0;
    Wa.prototype.getPoint = function (a) {
        for (var b = 2 * Math.PI, c = this.aEndAngle - this.aStartAngle,
                 d = Math.abs(c) < Number.EPSILON; 0 > c;)c += b;
        for (; c > b;)c -= b;
        c < Number.EPSILON && (c = d ? 0 : b);
        !0 !== this.aClockwise || d || (c = c === b ? -b : c - b);
        b = this.aStartAngle + a * c;
        a = this.aX + this.xRadius * Math.cos(b);
        var e = this.aY + this.yRadius * Math.sin(b);
        0 !== this.aRotation && (b = Math.cos(this.aRotation),
            c = Math.sin(this.aRotation), d = a - this.aX, e -= this.aY, a = d * b - e * c + this.aX, e = d * c + e * b + this.aY);
        return new D(a, e)
    };
    Cb.prototype = Object.create(ua.prototype);
    Cb.prototype.constructor = Cb;
    Cb.prototype.isSplineCurve = !0;
    Cb.prototype.getPoint = function (a) {
        var b = this.points, c = (b.length - 1) * a;
        a = Math.floor(c);
        var c = c - a, d = b[0 === a ? a : a - 1], e = b[a], f = b[a > b.length - 2 ? b.length - 1 : a + 1],
            b = b[a > b.length - 3 ? b.length - 1 : a + 2];
        return new D(Te(c, d.x, e.x, f.x, b.x), Te(c, d.y, e.y, f.y, b.y))
    };
    fc.prototype = Object.create(ua.prototype);
    fc.prototype.constructor =
        fc;
    fc.prototype.getPoint = function (a) {
        var b = this.v0, c = this.v1, d = this.v2, e = this.v3;
        return new D(Bb(a, b.x, c.x, d.x, e.x), Bb(a, b.y, c.y, d.y, e.y))
    };
    gc.prototype = Object.create(ua.prototype);
    gc.prototype.constructor = gc;
    gc.prototype.getPoint = function (a) {
        var b = this.v0, c = this.v1, d = this.v2;
        return new D(Ab(a, b.x, c.x, d.x), Ab(a, b.y, c.y, d.y))
    };
    var xe = Object.assign(Object.create(ad.prototype), {
        fromPoints: function (a) {
            this.moveTo(a[0].x, a[0].y);
            for (var b = 1, c = a.length; b < c; b++)this.lineTo(a[b].x, a[b].y)
        }, moveTo: function (a,
                             b) {
            this.currentPoint.set(a, b)
        }, lineTo: function (a, b) {
            var c = new Ta(this.currentPoint.clone(), new D(a, b));
            this.curves.push(c);
            this.currentPoint.set(a, b)
        }, quadraticCurveTo: function (a, b, c, d) {
            a = new gc(this.currentPoint.clone(), new D(a, b), new D(c, d));
            this.curves.push(a);
            this.currentPoint.set(c, d)
        }, bezierCurveTo: function (a, b, c, d, e, f) {
            a = new fc(this.currentPoint.clone(), new D(a, b), new D(c, d), new D(e, f));
            this.curves.push(a);
            this.currentPoint.set(e, f)
        }, splineThru: function (a) {
            var b = [this.currentPoint.clone()].concat(a),
                b = new Cb(b);
            this.curves.push(b);
            this.currentPoint.copy(a[a.length - 1])
        }, arc: function (a, b, c, d, e, f) {
            this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
        }, absarc: function (a, b, c, d, e, f) {
            this.absellipse(a, b, c, c, d, e, f)
        }, ellipse: function (a, b, c, d, e, f, g, h) {
            this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h)
        }, absellipse: function (a, b, c, d, e, f, g, h) {
            a = new Wa(a, b, c, d, e, f, g, h);
            0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
            this.curves.push(a);
            a = a.getPoint(1);
            this.currentPoint.copy(a)
        }
    });
    bd.prototype = xe;
    xe.constructor = bd;
    Db.prototype = Object.assign(Object.create(xe), {
        constructor: Db, getPointsHoles: function (a) {
            for (var b = [], c = 0, d = this.holes.length; c < d; c++)b[c] = this.holes[c].getPoints(a);
            return b
        }, extractAllPoints: function (a) {
            return {shape: this.getPoints(a), holes: this.getPointsHoles(a)}
        }, extractPoints: function (a) {
            return this.extractAllPoints(a)
        }
    });
    ee.prototype = {
        moveTo: function (a, b) {
            this.currentPath = new bd;
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(a, b)
        }, lineTo: function (a, b) {
            this.currentPath.lineTo(a, b)
        }, quadraticCurveTo: function (a, b, c, d) {
            this.currentPath.quadraticCurveTo(a, b, c, d)
        }, bezierCurveTo: function (a, b, c, d, e, f) {
            this.currentPath.bezierCurveTo(a, b, c, d, e, f)
        }, splineThru: function (a) {
            this.currentPath.splineThru(a)
        }, toShapes: function (a, b) {
            function c(a) {
                for (var b = [], c = 0, d = a.length; c < d; c++) {
                    var e = a[c], f = new Db;
                    f.curves = e.curves;
                    b.push(f)
                }
                return b
            }

            function d(a, b) {
                for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                    var g = b[e], h =
                        b[f], k = h.x - g.x, m = h.y - g.y;
                    if (Math.abs(m) > Number.EPSILON) {
                        if (0 > m && (g = b[f], k = -k, h = b[e], m = -m), !(a.y < g.y || a.y > h.y))if (a.y === g.y) {
                            if (a.x === g.x)return !0
                        } else {
                            e = m * (a.x - g.x) - k * (a.y - g.y);
                            if (0 === e)return !0;
                            0 > e || (d = !d)
                        }
                    } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x))return !0
                }
                return d
            }

            var e = Ia.isClockWise, f = this.subPaths;
            if (0 === f.length)return [];
            if (!0 === b)return c(f);
            var g, h, m, k = [];
            if (1 === f.length)return h = f[0], m = new Db, m.curves = h.curves, k.push(m), k;
            var l = !e(f[0].getPoints()), l = a ? !l : l;
            m = [];
            var p =
                [], n = [], q = 0, x;
            p[q] = void 0;
            n[q] = [];
            for (var r = 0,
                     A = f.length; r < A; r++)h = f[r], x = h.getPoints(), g = e(x), (g = a ? !g : g) ? (!l && p[q] && q++, p[q] = {
                s: new Db,
                p: x
            }, p[q].s.curves = h.curves, l && q++, n[q] = []) : n[q].push({h: h, p: x[0]});
            if (!p[0])return c(f);
            if (1 < p.length) {
                r = !1;
                h = [];
                e = 0;
                for (f = p.length; e < f; e++)m[e] = [];
                e = 0;
                for (f = p.length; e < f; e++)for (g = n[e], l = 0; l < g.length; l++) {
                    q = g[l];
                    x = !0;
                    for (A = 0; A < p.length; A++)d(q.p, p[A].p) && (e !== A && h.push({
                        froms: e,
                        tos: A,
                        hole: l
                    }), x ? (x = !1, m[A].push(q)) : r = !0);
                    x && m[e].push(q)
                }
                0 < h.length && (r || (n = m))
            }
            r =
                0;
            for (e = p.length; r < e; r++)for (m = p[r].s, k.push(m), h = n[r], f = 0, g = h.length; f < g; f++)m.holes.push(h[f].h);
            return k
        }
    };
    Object.assign(fe.prototype, {
        isFont: !0, generateShapes: function (a, b, c) {
            void 0 === b && (b = 100);
            void 0 === c && (c = 4);
            var d = this.data;
            a = String(a).split("");
            var e = b / d.resolution, f = (d.boundingBox.yMax - d.boundingBox.yMin + d.underlineThickness) * e, g = 0,
                h = 0;
            b = [];
            for (var m = 0; m < a.length; m++) {
                var k = a[m];
                if ("\n" === k) g = 0, h -= f; else {
                    var l;
                    l = e;
                    var p = g, n = h;
                    if (k = d.glyphs[k] || d.glyphs["?"]) {
                        var q = new ee, x = [], r, A, w, y, z,
                            v, D, I;
                        if (k.o)for (var C = k._cachedOutline || (k._cachedOutline = k.o.split(" ")), F = 0,
                                         J = C.length; F < J;)switch (C[F++]) {
                            case "m":
                                r = C[F++] * l + p;
                                A = C[F++] * l + n;
                                q.moveTo(r, A);
                                break;
                            case "l":
                                r = C[F++] * l + p;
                                A = C[F++] * l + n;
                                q.lineTo(r, A);
                                break;
                            case "q":
                                r = C[F++] * l + p;
                                A = C[F++] * l + n;
                                z = C[F++] * l + p;
                                v = C[F++] * l + n;
                                q.quadraticCurveTo(z, v, r, A);
                                if (y = x[x.length - 1]) {
                                    w = y.x;
                                    y = y.y;
                                    for (var H = 1; H <= c; H++) {
                                        var N = H / c;
                                        Ab(N, w, z, r);
                                        Ab(N, y, v, A)
                                    }
                                }
                                break;
                            case "b":
                                if (r = C[F++] * l + p, A = C[F++] * l + n, z = C[F++] * l + p, v = C[F++] * l + n, D = C[F++] * l + p, I = C[F++] * l + n, q.bezierCurveTo(z,
                                        v, D, I, r, A), y = x[x.length - 1])for (w = y.x, y = y.y, H = 1; H <= c; H++)N = H / c, Bb(N, w, z, D, r), Bb(N, y, v, I, A)
                        }
                        l = {offsetX: k.ha * l, path: q}
                    } else l = void 0;
                    g += l.offsetX;
                    b.push(l.path)
                }
            }
            c = [];
            d = 0;
            for (a = b.length; d < a; d++)Array.prototype.push.apply(c, b[d].toShapes());
            return c
        }
    });
    Object.assign(Ue.prototype, {
        load: function (a, b, c, d) {
            var e = this;
            (new sa(this.manager)).load(a, function (a) {
                var c;
                try {
                    c = JSON.parse(a)
                } catch (d) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65,
                        a.length - 2))
                }
                a = e.parse(c);
                b && b(a)
            }, c, d)
        }, parse: function (a) {
            return new fe(a)
        }
    });
    var Pd, je = {
        getContext: function () {
            void 0 === Pd && (Pd = new (window.AudioContext || window.webkitAudioContext));
            return Pd
        }, setContext: function (a) {
            Pd = a
        }
    };
    Object.assign(ge.prototype, {
        load: function (a, b, c, d) {
            var e = new sa(this.manager);
            e.setResponseType("arraybuffer");
            e.load(a, function (a) {
                je.getContext().decodeAudioData(a, function (a) {
                    b(a)
                })
            }, c, d)
        }
    });
    he.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: he, isRectAreaLight: !0,
        copy: function (a) {
            ma.prototype.copy.call(this, a);
            this.width = a.width;
            this.height = a.height;
            return this
        }
    });
    Object.assign(Ve.prototype, {
        update: function () {
            var a, b, c, d, e, f, g, h = new S, m = new S;
            return function (k) {
                if (a !== this || b !== k.focus || c !== k.fov || d !== k.aspect * this.aspect || e !== k.near || f !== k.far || g !== k.zoom) {
                    a = this;
                    b = k.focus;
                    c = k.fov;
                    d = k.aspect * this.aspect;
                    e = k.near;
                    f = k.far;
                    g = k.zoom;
                    var l = k.projectionMatrix.clone(), p = this.eyeSep / 2, n = p * e / b,
                        q = e * Math.tan(N.DEG2RAD * c * .5) / g, x;
                    m.elements[12] = -p;
                    h.elements[12] = p;
                    p =
                        -q * d + n;
                    x = q * d + n;
                    l.elements[0] = 2 * e / (x - p);
                    l.elements[8] = (x + p) / (x - p);
                    this.cameraL.projectionMatrix.copy(l);
                    p = -q * d - n;
                    x = q * d - n;
                    l.elements[0] = 2 * e / (x - p);
                    l.elements[8] = (x + p) / (x - p);
                    this.cameraR.projectionMatrix.copy(l)
                }
                this.cameraL.matrixWorld.copy(k.matrixWorld).multiply(m);
                this.cameraR.matrixWorld.copy(k.matrixWorld).multiply(h)
            }
        }()
    });
    Id.prototype = Object.create(x.prototype);
    Id.prototype.constructor = Id;
    ie.prototype = Object.assign(Object.create(x.prototype), {
        constructor: ie, getInput: function () {
            return this.gain
        },
        removeFilter: function () {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
        }, getFilter: function () {
            return this.filter
        }, setFilter: function (a) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
            this.filter = a;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination)
        }, getMasterVolume: function () {
            return this.gain.gain.value
        },
        setMasterVolume: function (a) {
            this.gain.gain.value = a
        }, updateMatrixWorld: function () {
            var a = new q, b = new ca, c = new q, d = new q;
            return function (e) {
                x.prototype.updateMatrixWorld.call(this, e);
                e = this.context.listener;
                var f = this.up;
                this.matrixWorld.decompose(a, b, c);
                d.set(0, 0, -1).applyQuaternion(b);
                e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime),
                    e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z))
            }
        }()
    });
    hc.prototype = Object.assign(Object.create(x.prototype), {
        constructor: hc, getOutput: function () {
            return this.gain
        }, setNodeSource: function (a) {
            this.hasPlaybackControl =
                !1;
            this.sourceType = "audioNode";
            this.source = a;
            this.connect();
            return this
        }, setBuffer: function (a) {
            this.buffer = a;
            this.sourceType = "buffer";
            this.autoplay && this.play();
            return this
        }, play: function () {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else {
                var a = this.context.createBufferSource();
                a.buffer = this.buffer;
                a.loop = this.loop;
                a.onended = this.onEnded.bind(this);
                a.playbackRate.setValueAtTime(this.playbackRate,
                    this.startTime);
                a.start(0, this.startTime);
                this.isPlaying = !0;
                this.source = a;
                return this.connect()
            }
        }, pause: function () {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this
        }, stop: function () {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.source.stop(), this.startTime = 0, this.isPlaying = !1, this
        }, connect: function () {
            if (0 <
                this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].connect(this.filters[a]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        }, disconnect: function () {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].disconnect(this.filters[a]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        }, getFilters: function () {
            return this.filters
        }, setFilters: function (a) {
            a || (a = []);
            !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
            return this
        }, getFilter: function () {
            return this.getFilters()[0]
        }, setFilter: function (a) {
            return this.setFilters(a ? [a] : [])
        }, setPlaybackRate: function (a) {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate,
                this.context.currentTime), this
        }, getPlaybackRate: function () {
            return this.playbackRate
        }, onEnded: function () {
            this.isPlaying = !1
        }, getLoop: function () {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        }, setLoop: function (a) {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this
        }, getVolume: function () {
            return this.gain.gain.value
        },
        setVolume: function (a) {
            this.gain.gain.value = a;
            return this
        }
    });
    ke.prototype = Object.assign(Object.create(hc.prototype), {
        constructor: ke, getOutput: function () {
            return this.panner
        }, getRefDistance: function () {
            return this.panner.refDistance
        }, setRefDistance: function (a) {
            this.panner.refDistance = a
        }, getRolloffFactor: function () {
            return this.panner.rolloffFactor
        }, setRolloffFactor: function (a) {
            this.panner.rolloffFactor = a
        }, getDistanceModel: function () {
            return this.panner.distanceModel
        }, setDistanceModel: function (a) {
            this.panner.distanceModel =
                a
        }, getMaxDistance: function () {
            return this.panner.maxDistance
        }, setMaxDistance: function (a) {
            this.panner.maxDistance = a
        }, updateMatrixWorld: function () {
            var a = new q;
            return function (b) {
                x.prototype.updateMatrixWorld.call(this, b);
                a.setFromMatrixPosition(this.matrixWorld);
                this.panner.setPosition(a.x, a.y, a.z)
            }
        }()
    });
    Object.assign(le.prototype, {
        getFrequencyData: function () {
            this.analyser.getByteFrequencyData(this.data);
            return this.data
        }, getAverageFrequency: function () {
            for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++)a +=
                b[c];
            return a / b.length
        }
    });
    Jd.prototype = {
        constructor: Jd, accumulate: function (a, b) {
            var c = this.buffer, d = this.valueSize, e = a * d + d, f = this.cumulativeWeight;
            if (0 === f) {
                for (f = 0; f !== d; ++f)c[e + f] = c[f];
                f = b
            } else f += b, this._mixBufferRegion(c, e, 0, b / f, d);
            this.cumulativeWeight = f
        }, apply: function (a) {
            var b = this.valueSize, c = this.buffer;
            a = a * b + b;
            var d = this.cumulativeWeight, e = this.binding;
            this.cumulativeWeight = 0;
            1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
            for (var d = b, f = b + b; d !== f; ++d)if (c[d] !== c[d + b]) {
                e.setValue(c, a);
                break
            }
        },
        saveOriginalState: function () {
            var a = this.buffer, b = this.valueSize, c = 3 * b;
            this.binding.getValue(a, c);
            for (var d = b; d !== c; ++d)a[d] = a[c + d % b];
            this.cumulativeWeight = 0
        }, restoreOriginalState: function () {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        }, _select: function (a, b, c, d, e) {
            if (.5 <= d)for (d = 0; d !== e; ++d)a[b + d] = a[c + d]
        }, _slerp: function (a, b, c, d, e) {
            ca.slerpFlat(a, b, a, b, a, c, d)
        }, _lerp: function (a, b, c, d, e) {
            for (var f = 1 - d, g = 0; g !== e; ++g) {
                var h = b + g;
                a[h] = a[h] * f + a[c + g] * d
            }
        }
    };
    ka.prototype = {
        constructor: ka, getValue: function (a,
                                             b) {
            this.bind();
            this.getValue(a, b)
        }, setValue: function (a, b) {
            this.bind();
            this.setValue(a, b)
        }, bind: function () {
            var a = this.node, b = this.parsedPath, c = b.objectName, d = b.propertyName, e = b.propertyIndex;
            a || (this.node = a = ka.findNode(this.rootNode, b.nodeName) || this.rootNode);
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            if (a) {
                if (c) {
                    var f = b.objectIndex;
                    switch (c) {
                        case "materials":
                            if (!a.material) {
                                console.error("  can not bind to material as node does not have a material", this);
                                return
                            }
                            if (!a.material.materials) {
                                console.error("  can not bind to material.materials as node.material does not have a materials array",
                                    this);
                                return
                            }
                            a = a.material.materials;
                            break;
                        case "bones":
                            if (!a.skeleton) {
                                console.error("  can not bind to bones as node does not have a skeleton", this);
                                return
                            }
                            a = a.skeleton.bones;
                            for (c = 0; c < a.length; c++)if (a[c].name === f) {
                                f = c;
                                break
                            }
                            break;
                        default:
                            if (void 0 === a[c]) {
                                console.error("  can not bind to objectName of node, undefined", this);
                                return
                            }
                            a = a[c]
                    }
                    if (void 0 !== f) {
                        if (void 0 === a[f]) {
                            console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
                            return
                        }
                        a = a[f]
                    }
                }
                f = a[d];
                if (void 0 === f) console.error("  trying to update property for track: " +
                    b.nodeName + "." + d + " but it wasn't found.", a); else {
                    b = this.Versioning.None;
                    void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a);
                    c = this.BindingType.Direct;
                    if (void 0 !== e) {
                        if ("morphTargetInfluences" === d) {
                            if (!a.geometry) {
                                console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                                return
                            }
                            if (!a.geometry.morphTargets) {
                                console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets",
                                    this);
                                return
                            }
                            for (c = 0; c < this.node.geometry.morphTargets.length; c++)if (a.geometry.morphTargets[c].name === e) {
                                e = c;
                                break
                            }
                        }
                        c = this.BindingType.ArrayElement;
                        this.resolvedProperty = f;
                        this.propertyIndex = e
                    } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : void 0 !== f.length ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
                    this.getValue = this.GetterByBindingType[c];
                    this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
                }
            } else console.error("  trying to update node for track: " +
                this.path + " but it wasn't found.")
        }, unbind: function () {
            this.node = null;
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound
        }
    };
    Object.assign(ka.prototype, {
        _getValue_unavailable: function () {
        },
        _setValue_unavailable: function () {
        },
        _getValue_unbound: ka.prototype.getValue,
        _setValue_unbound: ka.prototype.setValue,
        BindingType: {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3},
        Versioning: {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2},
        GetterByBindingType: [function (a, b) {
            a[b] = this.node[this.propertyName]
        },
            function (a, b) {
                for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)a[b++] = c[d]
            }, function (a, b) {
                a[b] = this.resolvedProperty[this.propertyIndex]
            }, function (a, b) {
                this.resolvedProperty.toArray(a, b)
            }],
        SetterByBindingTypeAndVersioning: [[function (a, b) {
            this.node[this.propertyName] = a[b]
        }, function (a, b) {
            this.node[this.propertyName] = a[b];
            this.targetObject.needsUpdate = !0
        }, function (a, b) {
            this.node[this.propertyName] = a[b];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (a, b) {
            for (var c = this.resolvedProperty,
                     d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]
        }, function (a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++];
            this.targetObject.needsUpdate = !0
        }, function (a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b]
        }, function (a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b];
            this.targetObject.needsUpdate = !0
        }, function (a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (a, b) {
            this.resolvedProperty.fromArray(a, b)
        }, function (a, b) {
            this.resolvedProperty.fromArray(a, b);
            this.targetObject.needsUpdate = !0
        }, function (a, b) {
            this.resolvedProperty.fromArray(a, b);
            this.targetObject.matrixWorldNeedsUpdate = !0
        }]]
    });
    ka.Composite = function (a, b, c) {
        c = c || ka.parseTrackName(b);
        this._targetGroup = a;
        this._bindings = a.subscribe_(b, c)
    };
    ka.Composite.prototype = {
        constructor: ka.Composite, getValue: function (a, b) {
            this.bind();
            var c = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== c && c.getValue(a, b)
        }, setValue: function (a, b) {
            for (var c = this._bindings, d = this._targetGroup.nCachedObjects_,
                     e = c.length; d !== e; ++d)c[d].setValue(a, b)
        }, bind: function () {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)a[b].bind()
        }, unbind: function () {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)a[b].unbind()
        }
    };
    ka.create = function (a, b, c) {
        return a && a.isAnimationObjectGroup ? new ka.Composite(a, b, c) : new ka(a, b, c)
    };
    ka.parseTrackName = function (a) {
        var b =
            /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/.exec(a);
        if (!b)throw Error("cannot parse trackName at all: " + a);
        b = {nodeName: b[2], objectName: b[3], objectIndex: b[4], propertyName: b[5], propertyIndex: b[6]};
        if (null === b.propertyName || 0 === b.propertyName.length)throw Error("can not parse propertyName from trackName: " + a);
        return b
    };
    ka.findNode = function (a, b) {
        if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid)return a;
        if (a.skeleton) {
            var c = function (a) {
                for (var c =
                    0; c < a.bones.length; c++) {
                    var d = a.bones[c];
                    if (d.name === b)return d
                }
                return null
            }(a.skeleton);
            if (c)return c
        }
        if (a.children) {
            var d = function (a) {
                for (var c = 0; c < a.length; c++) {
                    var g = a[c];
                    if (g.name === b || g.uuid === b || (g = d(g.children)))return g
                }
                return null
            };
            if (c = d(a.children))return c
        }
        return null
    };
    me.prototype = {
        constructor: me, isAnimationObjectGroup: !0, add: function (a) {
            for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID,
                     f = this._paths, g = this._parsedPaths, h = this._bindings, m = h.length, k = 0, l =
                    arguments.length; k !== l; ++k) {
                var p = arguments[k], n = p.uuid, q = e[n];
                if (void 0 === q) {
                    q = c++;
                    e[n] = q;
                    b.push(p);
                    for (var n = 0, x = m; n !== x; ++n)h[n].push(new ka(p, f[n], g[n]))
                } else if (q < d) {
                    var r = --d, x = b[r];
                    e[x.uuid] = q;
                    b[q] = x;
                    e[n] = r;
                    b[r] = p;
                    n = 0;
                    for (x = m; n !== x; ++n) {
                        var z = h[n], w = z[q];
                        z[q] = z[r];
                        void 0 === w && (w = new ka(p, f[n], g[n]));
                        z[r] = w
                    }
                } else void 0 !== b[q] && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
            }
            this.nCachedObjects_ = d
        }, remove: function (a) {
            for (var b =
                    this._objects, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length,
                     g = 0, h = arguments.length; g !== h; ++g) {
                var m = arguments[g], k = m.uuid, l = d[k];
                if (void 0 !== l && l >= c) {
                    var p = c++, n = b[p];
                    d[n.uuid] = l;
                    b[l] = n;
                    d[k] = p;
                    b[p] = m;
                    m = 0;
                    for (k = f; m !== k; ++m) {
                        var n = e[m], q = n[l];
                        n[l] = n[p];
                        n[p] = q
                    }
                }
            }
            this.nCachedObjects_ = c
        }, uncache: function (a) {
            for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID,
                     f = this._bindings, g = f.length, h = 0, m = arguments.length; h !== m; ++h) {
                var k = arguments[h].uuid, l = e[k];
                if (void 0 !== l)if (delete e[k], l < d) {
                    var k = --d, p = b[k], n = --c, q = b[n];
                    e[p.uuid] = l;
                    b[l] = p;
                    e[q.uuid] = k;
                    b[k] = q;
                    b.pop();
                    p = 0;
                    for (q = g; p !== q; ++p) {
                        var x = f[p], r = x[n];
                        x[l] = x[k];
                        x[k] = r;
                        x.pop()
                    }
                } else for (n = --c, q = b[n], e[q.uuid] = l, b[l] = q, b.pop(), p = 0, q = g; p !== q; ++p)x = f[p], x[l] = x[n], x.pop()
            }
            this.nCachedObjects_ = d
        }, subscribe_: function (a, b) {
            var c = this._bindingsIndicesByPath, d = c[a], e = this._bindings;
            if (void 0 !== d)return e[d];
            var f = this._paths, g = this._parsedPaths, h = this._objects, l = this.nCachedObjects_,
                k = Array(h.length), d = e.length;
            c[a] = d;
            f.push(a);
            g.push(b);
            e.push(k);
            c = l;
            for (d = h.length; c !== d; ++c)k[c] = new ka(h[c], a, b);
            return k
        }, unsubscribe_: function (a) {
            var b = this._bindingsIndicesByPath, c = b[a];
            if (void 0 !== c) {
                var d = this._paths, e = this._parsedPaths, f = this._bindings, g = f.length - 1, h = f[g];
                b[a[g]] = c;
                f[c] = h;
                f.pop();
                e[c] = e[g];
                e.pop();
                d[c] = d[g];
                d.pop()
            }
        }
    };
    ne.prototype = {
        constructor: ne, play: function () {
            this._mixer._activateAction(this);
            return this
        }, stop: function () {
            this._mixer._deactivateAction(this);
            return this.reset()
        }, reset: function () {
            this.paused =
                !1;
            this.enabled = !0;
            this.time = 0;
            this._loopCount = -1;
            this._startTime = null;
            return this.stopFading().stopWarping()
        }, isRunning: function () {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }, isScheduled: function () {
            return this._mixer._isActiveAction(this)
        }, startAt: function (a) {
            this._startTime = a;
            return this
        }, setLoop: function (a, b) {
            this.loop = a;
            this.repetitions = b;
            return this
        }, setEffectiveWeight: function (a) {
            this.weight = a;
            this._effectiveWeight = this.enabled ?
                a : 0;
            return this.stopFading()
        }, getEffectiveWeight: function () {
            return this._effectiveWeight
        }, fadeIn: function (a) {
            return this._scheduleFading(a, 0, 1)
        }, fadeOut: function (a) {
            return this._scheduleFading(a, 1, 0)
        }, crossFadeFrom: function (a, b, c) {
            a.fadeOut(b);
            this.fadeIn(b);
            if (c) {
                c = this._clip.duration;
                var d = a._clip.duration, e = c / d;
                a.warp(1, d / c, b);
                this.warp(e, 1, b)
            }
            return this
        }, crossFadeTo: function (a, b, c) {
            return a.crossFadeFrom(this, b, c)
        }, stopFading: function () {
            var a = this._weightInterpolant;
            null !== a && (this._weightInterpolant =
                null, this._mixer._takeBackControlInterpolant(a));
            return this
        }, setEffectiveTimeScale: function (a) {
            this.timeScale = a;
            this._effectiveTimeScale = this.paused ? 0 : a;
            return this.stopWarping()
        }, getEffectiveTimeScale: function () {
            return this._effectiveTimeScale
        }, setDuration: function (a) {
            this.timeScale = this._clip.duration / a;
            return this.stopWarping()
        }, syncWith: function (a) {
            this.time = a.time;
            this.timeScale = a.timeScale;
            return this.stopWarping()
        }, halt: function (a) {
            return this.warp(this._effectiveTimeScale, 0, a)
        }, warp: function (a,
                           b, c) {
            var d = this._mixer, e = d.time, f = this._timeScaleInterpolant, g = this.timeScale;
            null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant());
            d = f.parameterPositions;
            f = f.sampleValues;
            d[0] = e;
            d[1] = e + c;
            f[0] = a / g;
            f[1] = b / g;
            return this
        }, stopWarping: function () {
            var a = this._timeScaleInterpolant;
            null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
            return this
        }, getMixer: function () {
            return this._mixer
        }, getClip: function () {
            return this._clip
        }, getRoot: function () {
            return this._localRoot ||
                this._mixer._root
        }, _update: function (a, b, c, d) {
            var e = this._startTime;
            if (null !== e) {
                b = (a - e) * c;
                if (0 > b || 0 === c)return;
                this._startTime = null;
                b *= c
            }
            b *= this._updateTimeScale(a);
            c = this._updateTime(b);
            a = this._updateWeight(a);
            if (0 < a) {
                b = this._interpolants;
                for (var e = this._propertyBindings, f = 0,
                         g = b.length; f !== g; ++f)b[f].evaluate(c), e[f].accumulate(d, a)
            }
        }, _updateWeight: function (a) {
            var b = 0;
            if (this.enabled) {
                var b = this.weight, c = this._weightInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0], b = b * d;
                    a > c.parameterPositions[1] &&
                    (this.stopFading(), 0 === d && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = b
        }, _updateTimeScale: function (a) {
            var b = 0;
            if (!this.paused) {
                var b = this.timeScale, c = this._timeScaleInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0], b = b * d;
                    a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
                }
            }
            return this._effectiveTimeScale = b
        }, _updateTime: function (a) {
            var b = this.time + a;
            if (0 === a)return b;
            var c = this._clip.duration, d = this.loop, e = this._loopCount;
            if (2200 === d)a:{
                if (-1 === e && (this._loopCount =
                        0, this._setEndings(!0, !0, !1)), b >= c) b = c; else if (0 > b) b = 0; else break a;
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
                this._mixer.dispatchEvent({type: "finished", action: this, direction: 0 > a ? -1 : 1})
            } else {
                d = 2202 === d;
                -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d));
                if (b >= c || 0 > b) {
                    var f = Math.floor(b / c), b = b - c * f, e = e + Math.abs(f), g = this.repetitions - e;
                    0 > g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this, direction: 0 < a ? 1 : -1
                    })) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), this._loopCount = e, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: f
                    }))
                }
                if (d && 1 === (e & 1))return this.time = b, c - b
            }
            return this.time = b
        }, _setEndings: function (a, b, c) {
            var d = this._interpolantSettings;
            c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        }, _scheduleFading: function (a, b, c) {
            var d = this._mixer, e = d.time,
                f = this._weightInterpolant;
            null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
            d = f.parameterPositions;
            f = f.sampleValues;
            d[0] = e;
            f[0] = b;
            d[1] = e + a;
            f[1] = c;
            return this
        }
    };
    cd.prototype = {
        constructor: cd, clipAction: function (a, b) {
            var c = b || this._root, d = c.uuid, e = "string" === typeof a ? qa.findByName(c, a) : a,
                c = null !== e ? e.uuid : a, f = this._actionsByClip[c], g = null;
            if (void 0 !== f) {
                g = f.actionByRoot[d];
                if (void 0 !== g)return g;
                g = f.knownActions[0];
                null === e && (e = g._clip)
            }
            if (null === e)return null;
            e = new ne(this, e, b);
            this._bindAction(e,
                g);
            this._addInactiveAction(e, c, d);
            return e
        }, existingAction: function (a, b) {
            var c = b || this._root, d = c.uuid, c = "string" === typeof a ? qa.findByName(c, a) : a,
                c = this._actionsByClip[c ? c.uuid : a];
            return void 0 !== c ? c.actionByRoot[d] || null : null
        }, stopAllAction: function () {
            for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings,
                     e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e)a[e].reset();
            for (e = 0; e !== d; ++e)c[e].useCount = 0;
            return this
        }, update: function (a) {
            a *= this.timeScale;
            for (var b =
                    this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1,
                     g = 0; g !== c; ++g) {
                var h = b[g];
                h.enabled && h._update(d, a, e, f)
            }
            a = this._bindings;
            b = this._nActiveBindings;
            for (g = 0; g !== b; ++g)a[g].apply(f);
            return this
        }, getRoot: function () {
            return this._root
        }, uncacheClip: function (a) {
            var b = this._actions;
            a = a.uuid;
            var c = this._actionsByClip, d = c[a];
            if (void 0 !== d) {
                for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
                    var g = d[e];
                    this._deactivateAction(g);
                    var h = g._cacheIndex, l = b[b.length - 1];
                    g._cacheIndex =
                        null;
                    g._byClipCacheIndex = null;
                    l._cacheIndex = h;
                    b[h] = l;
                    b.pop();
                    this._removeInactiveBindingsForAction(g)
                }
                delete c[a]
            }
        }, uncacheRoot: function (a) {
            a = a.uuid;
            var b = this._actionsByClip, c;
            for (c in b) {
                var d = b[c].actionByRoot[a];
                void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d))
            }
            c = this._bindingsByRootAndName[a];
            if (void 0 !== c)for (var e in c)a = c[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
        }, uncacheAction: function (a, b) {
            var c = this.existingAction(a, b);
            null !== c && (this._deactivateAction(c),
                this._removeInactiveAction(c))
        }
    };
    Object.assign(cd.prototype, {
        _bindAction: function (a, b) {
            var c = a._localRoot || this._root, d = a._clip.tracks, e = d.length, f = a._propertyBindings,
                g = a._interpolants, h = c.uuid, l = this._bindingsByRootAndName, k = l[h];
            void 0 === k && (k = {}, l[h] = k);
            for (l = 0; l !== e; ++l) {
                var q = d[l], p = q.name, n = k[p];
                if (void 0 === n) {
                    n = f[l];
                    if (void 0 !== n) {
                        null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, h, p));
                        continue
                    }
                    n = new Jd(ka.create(c, p, b && b._propertyBindings[l].binding.parsedPath), q.ValueTypeName,
                        q.getValueSize());
                    ++n.referenceCount;
                    this._addInactiveBinding(n, h, p)
                }
                f[l] = n;
                g[l].resultBuffer = n.buffer
            }
        }, _activateAction: function (a) {
            if (!this._isActiveAction(a)) {
                if (null === a._cacheIndex) {
                    var b = (a._localRoot || this._root).uuid, c = a._clip.uuid, d = this._actionsByClip[c];
                    this._bindAction(a, d && d.knownActions[0]);
                    this._addInactiveAction(a, c, b)
                }
                b = a._propertyBindings;
                c = 0;
                for (d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
                }
                this._lendAction(a)
            }
        }, _deactivateAction: function (a) {
            if (this._isActiveAction(a)) {
                for (var b =
                    a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
                }
                this._takeBackAction(a)
            }
        }, _initMemoryManager: function () {
            this._actions = [];
            this._nActiveActions = 0;
            this._actionsByClip = {};
            this._bindings = [];
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {};
            this._controlInterpolants = [];
            this._nActiveControlInterpolants = 0;
            var a = this;
            this.stats = {
                actions: {
                    get total() {
                        return a._actions.length
                    }, get inUse() {
                        return a._nActiveActions
                    }
                }, bindings: {
                    get total() {
                        return a._bindings.length
                    },
                    get inUse() {
                        return a._nActiveBindings
                    }
                }, controlInterpolants: {
                    get total() {
                        return a._controlInterpolants.length
                    }, get inUse() {
                        return a._nActiveControlInterpolants
                    }
                }
            }
        }, _isActiveAction: function (a) {
            a = a._cacheIndex;
            return null !== a && a < this._nActiveActions
        }, _addInactiveAction: function (a, b, c) {
            var d = this._actions, e = this._actionsByClip, f = e[b];
            void 0 === f ? (f = {
                knownActions: [a],
                actionByRoot: {}
            }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
            a._cacheIndex = d.length;
            d.push(a);
            f.actionByRoot[c] = a
        }, _removeInactiveAction: function (a) {
            var b = this._actions, c = b[b.length - 1], d = a._cacheIndex;
            c._cacheIndex = d;
            b[d] = c;
            b.pop();
            a._cacheIndex = null;
            var c = a._clip.uuid, d = this._actionsByClip, e = d[c], f = e.knownActions, g = f[f.length - 1],
                h = a._byClipCacheIndex;
            g._byClipCacheIndex = h;
            f[h] = g;
            f.pop();
            a._byClipCacheIndex = null;
            delete e.actionByRoot[(b._localRoot || this._root).uuid];
            0 === f.length && delete d[c];
            this._removeInactiveBindingsForAction(a)
        }, _removeInactiveBindingsForAction: function (a) {
            a = a._propertyBindings;
            for (var b = 0, c = a.length; b !== c; ++b) {
                var d = a[b];
                0 === --d.referenceCount && this._removeInactiveBinding(d)
            }
        }, _lendAction: function (a) {
            var b = this._actions, c = a._cacheIndex, d = this._nActiveActions++, e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        }, _takeBackAction: function (a) {
            var b = this._actions, c = a._cacheIndex, d = --this._nActiveActions, e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        }, _addInactiveBinding: function (a, b, c) {
            var d = this._bindingsByRootAndName, e = d[b], f = this._bindings;
            void 0 === e && (e = {}, d[b] =
                e);
            e[c] = a;
            a._cacheIndex = f.length;
            f.push(a)
        }, _removeInactiveBinding: function (a) {
            var b = this._bindings, c = a.binding, d = c.rootNode.uuid, c = c.path, e = this._bindingsByRootAndName,
                f = e[d], g = b[b.length - 1];
            a = a._cacheIndex;
            g._cacheIndex = a;
            b[a] = g;
            b.pop();
            delete f[c];
            a:{
                for (var h in f)break a;
                delete e[d]
            }
        }, _lendBinding: function (a) {
            var b = this._bindings, c = a._cacheIndex, d = this._nActiveBindings++, e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        }, _takeBackBinding: function (a) {
            var b = this._bindings, c = a._cacheIndex, d =
                --this._nActiveBindings, e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        }, _lendControlInterpolant: function () {
            var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b];
            void 0 === c && (c = new Zc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
            return c
        }, _takeBackControlInterpolant: function (a) {
            var b = this._controlInterpolants, c = a.__cacheIndex, d = --this._nActiveControlInterpolants, e = b[d];
            a.__cacheIndex = d;
            b[d] = a;
            e.__cacheIndex = c;
            b[c] = e
        }, _controlInterpolantsResultBuffer: new Float32Array(1)
    });
    Object.assign(cd.prototype, pa.prototype);
    Kd.prototype.clone = function () {
        return new Kd(void 0 === this.value.clone ? this.value : this.value.clone())
    };
    Eb.prototype = Object.create(I.prototype);
    Eb.prototype.constructor = Eb;
    Eb.prototype.isInstancedBufferGeometry = !0;
    Eb.prototype.addGroup = function (a, b, c) {
        this.groups.push({start: a, count: b, materialIndex: c})
    };
    Eb.prototype.copy = function (a) {
        var b = a.index;
        null !== b && this.setIndex(b.clone());
        var b = a.attributes,
            c;
        for (c in b)this.addAttribute(c, b[c].clone());
        a = a.groups;
        c = 0;
        for (b = a.length; c < b; c++) {
            var d = a[c];
            this.addGroup(d.start, d.count, d.materialIndex)
        }
        return this
    };
    oe.prototype = {
        constructor: oe, isInterleavedBufferAttribute: !0, get count() {
            return this.data.count
        }, get array() {
            return this.data.array
        }, setX: function (a, b) {
            this.data.array[a * this.data.stride + this.offset] = b;
            return this
        }, setY: function (a, b) {
            this.data.array[a * this.data.stride + this.offset + 1] = b;
            return this
        }, setZ: function (a, b) {
            this.data.array[a * this.data.stride +
            this.offset + 2] = b;
            return this
        }, setW: function (a, b) {
            this.data.array[a * this.data.stride + this.offset + 3] = b;
            return this
        }, getX: function (a) {
            return this.data.array[a * this.data.stride + this.offset]
        }, getY: function (a) {
            return this.data.array[a * this.data.stride + this.offset + 1]
        }, getZ: function (a) {
            return this.data.array[a * this.data.stride + this.offset + 2]
        }, getW: function (a) {
            return this.data.array[a * this.data.stride + this.offset + 3]
        }, setXY: function (a, b, c) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a +
            1] = c;
            return this
        }, setXYZ: function (a, b, c, d) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            this.data.array[a + 2] = d;
            return this
        }, setXYZW: function (a, b, c, d, e) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            this.data.array[a + 2] = d;
            this.data.array[a + 3] = e;
            return this
        }
    };
    ic.prototype = {
        constructor: ic, isInterleavedBuffer: !0, set needsUpdate(a) {
            !0 === a && this.version++
        }, setArray: function (a) {
            if (Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== a ? a.length / this.stride : 0;
            this.array = a
        }, setDynamic: function (a) {
            this.dynamic = a;
            return this
        }, copy: function (a) {
            this.array = new a.array.constructor(a.array);
            this.count = a.count;
            this.stride = a.stride;
            this.dynamic = a.dynamic;
            return this
        }, copyAt: function (a, b, c) {
            a *= this.stride;
            c *= b.stride;
            for (var d = 0, e = this.stride; d < e; d++)this.array[a + d] = b.array[c + d];
            return this
        }, set: function (a, b) {
            void 0 === b && (b = 0);
            this.array.set(a, b);
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, onUpload: function (a) {
            this.onUploadCallback =
                a;
            return this
        }
    };
    jc.prototype = Object.create(ic.prototype);
    jc.prototype.constructor = jc;
    jc.prototype.isInstancedInterleavedBuffer = !0;
    jc.prototype.copy = function (a) {
        ic.prototype.copy.call(this, a);
        this.meshPerAttribute = a.meshPerAttribute;
        return this
    };
    kc.prototype = Object.create(U.prototype);
    kc.prototype.constructor = kc;
    kc.prototype.isInstancedBufferAttribute = !0;
    kc.prototype.copy = function (a) {
        U.prototype.copy.call(this, a);
        this.meshPerAttribute = a.meshPerAttribute;
        return this
    };
    pe.prototype = {
        constructor: pe, linePrecision: 1,
        set: function (a, b) {
            this.ray.set(a, b)
        }, setFromCamera: function (a, b) {
            b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        }, intersectObject: function (a, b) {
            var c = [];
            qe(a, this, c,
                b);
            c.sort(We);
            return c
        }, intersectObjects: function (a, b) {
            var c = [];
            if (!1 === Array.isArray(a))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
            for (var d = 0, e = a.length; d < e; d++)qe(a[d], this, c, b);
            c.sort(We);
            return c
        }
    };
    re.prototype = {
        constructor: re, start: function () {
            this.oldTime = this.startTime = (performance || Date).now();
            this.elapsedTime = 0;
            this.running = !0
        }, stop: function () {
            this.getElapsedTime();
            this.running = !1
        }, getElapsedTime: function () {
            this.getDelta();
            return this.elapsedTime
        },
        getDelta: function () {
            var a = 0;
            this.autoStart && !this.running && this.start();
            if (this.running) {
                var b = (performance || Date).now(), a = (b - this.oldTime) / 1E3;
                this.oldTime = b;
                this.elapsedTime += a
            }
            return a
        }
    };
    se.prototype = {
        constructor: se, set: function (a, b, c) {
            this.radius = a;
            this.phi = b;
            this.theta = c;
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.radius = a.radius;
            this.phi = a.phi;
            this.theta = a.theta;
            return this
        }, makeSafe: function () {
            this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
            return this
        }, setFromVector3: function (a) {
            this.radius = a.length();
            0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(N.clamp(a.y / this.radius, -1, 1)));
            return this
        }
    };
    te.prototype = {
        constructor: te, set: function (a, b, c) {
            this.radius = a;
            this.theta = b;
            this.y = c;
            return this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (a) {
            this.radius = a.radius;
            this.theta = a.theta;
            this.y = a.y;
            return this
        }, setFromVector3: function (a) {
            this.radius = Math.sqrt(a.x * a.x + a.z * a.z);
            this.theta = Math.atan2(a.x, a.z);
            this.y = a.y;
            return this
        }
    };
    oa.prototype = Object.create(Aa.prototype);
    oa.prototype.constructor = oa;
    oa.prototype.createAnimation = function (a, b, c, d) {
        b = {
            start: b,
            end: c,
            length: c - b + 1,
            fps: d,
            duration: (c - b) / d,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        };
        this.animationsMap[a] = b;
        this.animationsList.push(b)
    };
    oa.prototype.autoCreateAnimations = function (a) {
        for (var b = /([a-z]+)_?(\d+)/i, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f <
        g; f++) {
            var h = e.morphTargets[f].name.match(b);
            if (h && 1 < h.length) {
                var l = h[1];
                d[l] || (d[l] = {start: Infinity, end: -Infinity});
                h = d[l];
                f < h.start && (h.start = f);
                f > h.end && (h.end = f);
                c || (c = l)
            }
        }
        for (l in d)h = d[l], this.createAnimation(l, h.start, h.end, a);
        this.firstAnimation = c
    };
    oa.prototype.setAnimationDirectionForward = function (a) {
        if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1
    };
    oa.prototype.setAnimationDirectionBackward = function (a) {
        if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0
    };
    oa.prototype.setAnimationFPS =
        function (a, b) {
            var c = this.animationsMap[a];
            c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
        };
    oa.prototype.setAnimationDuration = function (a, b) {
        var c = this.animationsMap[a];
        c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
    };
    oa.prototype.setAnimationWeight = function (a, b) {
        var c = this.animationsMap[a];
        c && (c.weight = b)
    };
    oa.prototype.setAnimationTime = function (a, b) {
        var c = this.animationsMap[a];
        c && (c.time = b)
    };
    oa.prototype.getAnimationTime = function (a) {
        var b = 0;
        if (a = this.animationsMap[a]) b = a.time;
        return b
    };
    oa.prototype.getAnimationDuration =
        function (a) {
            var b = -1;
            if (a = this.animationsMap[a]) b = a.duration;
            return b
        };
    oa.prototype.playAnimation = function (a) {
        var b = this.animationsMap[a];
        b ? (b.time = 0, b.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
    };
    oa.prototype.stopAnimation = function (a) {
        if (a = this.animationsMap[a]) a.active = !1
    };
    oa.prototype.update = function (a) {
        for (var b = 0, c = this.animationsList.length; b < c; b++) {
            var d = this.animationsList[b];
            if (d.active) {
                var e = d.duration / d.length;
                d.time += d.direction * a;
                if (d.mirroredLoop) {
                    if (d.time >
                        d.duration || 0 > d.time) d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1)
                } else d.time %= d.duration, 0 > d.time && (d.time += d.duration);
                var f = d.start + N.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
                f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
                e = d.time % e / e;
                d.directionBackwards && (e = 1 - e);
                d.currentFrame !==
                d.lastFrame ? (this.morphTargetInfluences[d.currentFrame] = e * g, this.morphTargetInfluences[d.lastFrame] = (1 - e) * g) : this.morphTargetInfluences[d.currentFrame] = g
            }
        }
    };
    dd.prototype = Object.create(x.prototype);
    dd.prototype.constructor = dd;
    dd.prototype.isImmediateRenderObject = !0;
    ed.prototype = Object.create(ga.prototype);
    ed.prototype.constructor = ed;
    ed.prototype.update = function () {
        var a = new q, b = new q, c = new ya;
        return function () {
            var d = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0);
            c.getNormalMatrix(this.object.matrixWorld);
            var e = this.object.matrixWorld, f = this.geometry.attributes.position, g = this.object.geometry;
            if (g && g.isGeometry)for (var h = g.vertices, l = g.faces, k = g = 0,
                                           q = l.length; k < q; k++)for (var p = l[k], n = 0,
                                                                             u = p.vertexNormals.length; n < u; n++) {
                var x = p.vertexNormals[n];
                a.copy(h[p[d[n]]]).applyMatrix4(e);
                b.copy(x).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
                f.setXYZ(g, a.x, a.y, a.z);
                g += 1;
                f.setXYZ(g, b.x, b.y, b.z);
                g += 1
            } else if (g && g.isBufferGeometry)for (d = g.attributes.position, h = g.attributes.normal, n = g = 0, u = d.count; n <
            u; n++)a.set(d.getX(n), d.getY(n), d.getZ(n)).applyMatrix4(e), b.set(h.getX(n), h.getY(n), h.getZ(n)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
            f.needsUpdate = !0;
            return this
        }
    }();
    lc.prototype = Object.create(x.prototype);
    lc.prototype.constructor = lc;
    lc.prototype.dispose = function () {
        this.cone.geometry.dispose();
        this.cone.material.dispose()
    };
    lc.prototype.update = function () {
        var a = new q, b = new q;
        return function () {
            var c = this.light.distance ?
                this.light.distance : 1E3, d = c * Math.tan(this.light.angle);
            this.cone.scale.set(d, d, c);
            a.setFromMatrixPosition(this.light.matrixWorld);
            b.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(b.sub(a));
            this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
    }();
    mc.prototype = Object.create(ga.prototype);
    mc.prototype.constructor = mc;
    mc.prototype.getBoneList = function (a) {
        var b = [];
        a && a.isBone && b.push(a);
        for (var c = 0; c < a.children.length; c++)b.push.apply(b, this.getBoneList(a.children[c]));
        return b
    };
    mc.prototype.update = function () {
        var a = new q, b = new S, c = new S;
        return function () {
            var d = this.geometry, e = d.getAttribute("position");
            c.getInverse(this.root.matrixWorld);
            for (var f = 0, g = 0; f < this.bones.length; f++) {
                var h = this.bones[f];
                h.parent && h.parent.isBone && (b.multiplyMatrices(c, h.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g, a.x, a.y, a.z), b.multiplyMatrices(c, h.parent.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g + 1, a.x, a.y, a.z), g += 2)
            }
            d.getAttribute("position").needsUpdate = !0
        }
    }();
    nc.prototype =
        Object.create(Aa.prototype);
    nc.prototype.constructor = nc;
    nc.prototype.dispose = function () {
        this.geometry.dispose();
        this.material.dispose()
    };
    nc.prototype.update = function () {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    };
    oc.prototype = Object.create(x.prototype);
    oc.prototype.constructor = oc;
    oc.prototype.dispose = function () {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
        this.children[1].geometry.dispose();
        this.children[1].material.dispose()
    };
    oc.prototype.update =
        function () {
            var a = new q, b = new q;
            return function () {
                var c = this.children[0], d = this.children[1];
                if (this.light.target) {
                    a.setFromMatrixPosition(this.light.matrixWorld);
                    b.setFromMatrixPosition(this.light.target.matrixWorld);
                    var e = b.clone().sub(a);
                    c.lookAt(e);
                    d.lookAt(e)
                }
                c.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                var d = .5 * this.light.width, e = .5 * this.light.height, c = c.geometry.getAttribute("position"),
                    f = c.array;
                f[0] = d;
                f[1] = -e;
                f[2] = 0;
                f[3] = d;
                f[4] = e;
                f[5] = 0;
                f[6] = -d;
                f[7] = e;
                f[8] = 0;
                f[9] = -d;
                f[10] = e;
                f[11] = 0;
                f[12] = -d;
                f[13] = -e;
                f[14] = 0;
                f[15] = d;
                f[16] = -e;
                f[17] = 0;
                c.needsUpdate = !0
            }
        }();
    pc.prototype = Object.create(x.prototype);
    pc.prototype.constructor = pc;
    pc.prototype.dispose = function () {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose()
    };
    pc.prototype.update = function () {
        var a = new q, b = new J, c = new J;
        return function () {
            var d = this.children[0], e = d.geometry.getAttribute("color");
            b.copy(this.light.color).multiplyScalar(this.light.intensity);
            c.copy(this.light.groundColor).multiplyScalar(this.light.intensity);
            for (var f = 0, g = e.count; f < g; f++) {
                var h = f < g / 2 ? b : c;
                e.setXYZ(f, h.r, h.g, h.b)
            }
            d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
            e.needsUpdate = !0
        }
    }();
    fd.prototype = Object.create(ga.prototype);
    fd.prototype.constructor = fd;
    Ld.prototype = Object.create(ga.prototype);
    Ld.prototype.constructor = Ld;
    gd.prototype = Object.create(ga.prototype);
    gd.prototype.constructor = gd;
    gd.prototype.update = function () {
        var a = new q, b = new q, c = new ya;
        return function () {
            this.object.updateMatrixWorld(!0);
            c.getNormalMatrix(this.object.matrixWorld);
            for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry,
                     g = f.vertices, f = f.faces, h = 0, l = 0, k = f.length; l < k; l++) {
                var q = f[l], p = q.normal;
                a.copy(g[q.a]).add(g[q.b]).add(g[q.c]).divideScalar(3).applyMatrix4(d);
                b.copy(p).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
                e.setXYZ(h, a.x, a.y, a.z);
                h += 1;
                e.setXYZ(h, b.x, b.y, b.z);
                h += 1
            }
            e.needsUpdate = !0;
            return this
        }
    }();
    qc.prototype = Object.create(x.prototype);
    qc.prototype.constructor =
        qc;
    qc.prototype.dispose = function () {
        var a = this.children[0], b = this.children[1];
        a.geometry.dispose();
        a.material.dispose();
        b.geometry.dispose();
        b.material.dispose()
    };
    qc.prototype.update = function () {
        var a = new q, b = new q, c = new q;
        return function () {
            a.setFromMatrixPosition(this.light.matrixWorld);
            b.setFromMatrixPosition(this.light.target.matrixWorld);
            c.subVectors(b, a);
            var d = this.children[0], e = this.children[1];
            d.lookAt(c);
            d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            e.lookAt(c);
            e.scale.z = c.length()
        }
    }();
    hd.prototype = Object.create(ga.prototype);
    hd.prototype.constructor = hd;
    hd.prototype.update = function () {
        function a(a, g, h, l) {
            d.set(g, h, l).unproject(e);
            a = c[a];
            if (void 0 !== a)for (g = b.getAttribute("position"), h = 0, l = a.length; h < l; h++)g.setXYZ(a[h], d.x, d.y, d.z)
        }

        var b, c, d = new q, e = new ra;
        return function () {
            b = this.geometry;
            c = this.pointMap;
            e.projectionMatrix.copy(this.camera.projectionMatrix);
            a("c", 0, 0, -1);
            a("t", 0, 0, 1);
            a("n1", -1, -1, -1);
            a("n2", 1, -1, -1);
            a("n3", -1, 1, -1);
            a("n4", 1, 1, -1);
            a("f1",
                -1, -1, 1);
            a("f2", 1, -1, 1);
            a("f3", -1, 1, 1);
            a("f4", 1, 1, 1);
            a("u1", .7, 1.1, -1);
            a("u2", -.7, 1.1, -1);
            a("u3", 0, 2, -1);
            a("cf1", -1, 0, 1);
            a("cf2", 1, 0, 1);
            a("cf3", 0, -1, 1);
            a("cf4", 0, 1, 1);
            a("cn1", -1, 0, -1);
            a("cn2", 1, 0, -1);
            a("cn3", 0, -1, -1);
            a("cn4", 0, 1, -1);
            b.getAttribute("position").needsUpdate = !0
        }
    }();
    rc.prototype = Object.create(ga.prototype);
    rc.prototype.constructor = rc;
    rc.prototype.update = function () {
        var a = new Pa;
        return function (b) {
            b && b.isBox3 ? a.copy(b) : a.setFromObject(b);
            if (!a.isEmpty()) {
                b = a.min;
                var c = a.max, d = this.geometry.attributes.position,
                    e = d.array;
                e[0] = c.x;
                e[1] = c.y;
                e[2] = c.z;
                e[3] = b.x;
                e[4] = c.y;
                e[5] = c.z;
                e[6] = b.x;
                e[7] = b.y;
                e[8] = c.z;
                e[9] = c.x;
                e[10] = b.y;
                e[11] = c.z;
                e[12] = c.x;
                e[13] = c.y;
                e[14] = b.z;
                e[15] = b.x;
                e[16] = c.y;
                e[17] = b.z;
                e[18] = b.x;
                e[19] = b.y;
                e[20] = b.z;
                e[21] = c.x;
                e[22] = b.y;
                e[23] = b.z;
                d.needsUpdate = !0;
                this.geometry.computeBoundingSphere()
            }
        }
    }();
    var Md, ue;
    Fb.prototype = Object.create(x.prototype);
    Fb.prototype.constructor = Fb;
    Fb.prototype.setDirection = function () {
        var a = new q, b;
        return function (c) {
            .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1,
                0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
        }
    }();
    Fb.prototype.setLength = function (a, b, c) {
        void 0 === b && (b = .2 * a);
        void 0 === c && (c = .2 * b);
        this.line.scale.set(1, Math.max(0, a - b), 1);
        this.line.updateMatrix();
        this.cone.scale.set(c, b, c);
        this.cone.position.y = a;
        this.cone.updateMatrix()
    };
    Fb.prototype.setColor = function (a) {
        this.line.material.color.copy(a);
        this.cone.material.color.copy(a)
    };
    Nd.prototype = Object.create(ga.prototype);
    Nd.prototype.constructor = Nd;
    var Qd = new q,
        ye = new ve, ze = new ve, Ae = new ve;
    va.prototype = Object.create(ua.prototype);
    va.prototype.constructor = va;
    va.prototype.getPoint = function (a) {
        var b = this.points, c = b.length;
        2 > c && console.log("duh, you need at least 2 points");
        a *= c - (this.closed ? 0 : 1);
        var d = Math.floor(a);
        a -= d;
        this.closed ? d += 0 < d ? 0 : (Math.floor(Math.abs(d) / b.length) + 1) * b.length : 0 === a && d === c - 1 && (d = c - 2, a = 1);
        var e, f, g;
        this.closed || 0 < d ? e = b[(d - 1) % c] : (Qd.subVectors(b[0], b[1]).add(b[0]), e = Qd);
        f = b[d % c];
        g = b[(d + 1) % c];
        this.closed || d + 2 < c ? b = b[(d + 2) % c] : (Qd.subVectors(b[c -
        1], b[c - 2]).add(b[c - 1]), b = Qd);
        if (void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var h = "chordal" === this.type ? .5 : .25, c = Math.pow(e.distanceToSquared(f), h),
                d = Math.pow(f.distanceToSquared(g), h), h = Math.pow(g.distanceToSquared(b), h);
            1E-4 > d && (d = 1);
            1E-4 > c && (c = d);
            1E-4 > h && (h = d);
            ye.initNonuniformCatmullRom(e.x, f.x, g.x, b.x, c, d, h);
            ze.initNonuniformCatmullRom(e.y, f.y, g.y, b.y, c, d, h);
            Ae.initNonuniformCatmullRom(e.z, f.z, g.z, b.z, c, d, h)
        } else"catmullrom" === this.type && (c = void 0 !== this.tension ? this.tension :
            .5, ye.initCatmullRom(e.x, f.x, g.x, b.x, c), ze.initCatmullRom(e.y, f.y, g.y, b.y, c), Ae.initCatmullRom(e.z, f.z, g.z, b.z, c));
        return new q(ye.calc(a), ze.calc(a), Ae.calc(a))
    };
    id.prototype = Object.create(ua.prototype);
    id.prototype.constructor = id;
    id.prototype.getPoint = function (a) {
        var b = this.v0, c = this.v1, d = this.v2, e = this.v3;
        return new q(Bb(a, b.x, c.x, d.x, e.x), Bb(a, b.y, c.y, d.y, e.y), Bb(a, b.z, c.z, d.z, e.z))
    };
    jd.prototype = Object.create(ua.prototype);
    jd.prototype.constructor = jd;
    jd.prototype.getPoint = function (a) {
        var b = this.v0,
            c = this.v1, d = this.v2;
        return new q(Ab(a, b.x, c.x, d.x), Ab(a, b.y, c.y, d.y), Ab(a, b.z, c.z, d.z))
    };
    kd.prototype = Object.create(ua.prototype);
    kd.prototype.constructor = kd;
    kd.prototype.getPoint = function (a) {
        if (1 === a)return this.v2.clone();
        var b = new q;
        b.subVectors(this.v2, this.v1);
        b.multiplyScalar(a);
        b.add(this.v1);
        return b
    };
    Od.prototype = Object.create(Wa.prototype);
    Od.prototype.constructor = Od;
    ua.create = function (a, b) {
        console.log("THREE.Curve.create() has been deprecated");
        a.prototype = Object.create(ua.prototype);
        a.prototype.constructor =
            a;
        a.prototype.getPoint = b;
        return a
    };
    Xe.prototype = Object.create(va.prototype);
    Ye.prototype = Object.create(va.prototype);
    we.prototype = Object.create(va.prototype);
    Object.assign(we.prototype, {
        initFromArray: function (a) {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        }, getControlPointsArray: function (a) {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        }, reparametrizeByArcLength: function (a) {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    });
    fd.prototype.setColors = function () {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    };
    Object.assign(sc.prototype, {
        center: function (a) {
            console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
            return this.getCenter(a)
        }, empty: function () {
            console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
            return this.isEmpty()
        }, isIntersectionBox: function (a) {
            console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
            return this.intersectsBox(a)
        }, size: function (a) {
            console.warn("THREE.Box2: .size() has been renamed to .getSize().");
            return this.getSize(a)
        }
    });
    Object.assign(Pa.prototype, {
        center: function (a) {
            console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
            return this.getCenter(a)
        }, empty: function () {
            console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
            return this.isEmpty()
        }, isIntersectionBox: function (a) {
            console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
            return this.intersectsBox(a)
        }, isIntersectionSphere: function (a) {
            console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
            return this.intersectsSphere(a)
        }, size: function (a) {
            console.warn("THREE.Box3: .size() has been renamed to .getSize().");
            return this.getSize(a)
        }
    });
    hb.prototype.center = function (a) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(a)
    };
    N.random16 = function () {
        console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");
        return Math.random()
    };
    Object.assign(ya.prototype, {
        flattenToArrayOffset: function (a, b) {
            console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(a, b)
        }, multiplyVector3: function (a) {
            console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
            return a.applyMatrix3(this)
        }, multiplyVector3Array: function (a) {
            console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
            return this.applyToVector3Array(a)
        }, applyToBuffer: function (a, b, c) {
            console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
            return this.applyToBufferAttribute(a)
        }, applyToVector3Array: function (a, b, c) {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    });
    Object.assign(S.prototype, {
        extractPosition: function (a) {
            console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
            return this.copyPosition(a)
        },
        flattenToArrayOffset: function (a, b) {
            console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(a, b)
        }, getPosition: function () {
            var a;
            return function () {
                void 0 === a && (a = new q);
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                return a.setFromMatrixColumn(this, 3)
            }
        }(), setRotationFromQuaternion: function (a) {
            console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
            return this.makeRotationFromQuaternion(a)
        }, multiplyVector3: function (a) {
            console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        }, multiplyVector4: function (a) {
            console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        }, multiplyVector3Array: function (a) {
            console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
            return this.applyToVector3Array(a)
        }, rotateAxis: function (a) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
            a.transformDirection(this)
        }, crossVector: function (a) {
            console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        }, translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, applyToBuffer: function (a, b, c) {
            console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
            return this.applyToBufferAttribute(a)
        }, applyToVector3Array: function (a, b, c) {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function (a, b, c, d, e, f) {
            console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
            return this.makePerspective(a, b, d, c, e, f)
        }
    });
    la.prototype.isIntersectionLine = function (a) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(a)
    };
    ca.prototype.multiplyVector3 = function (a) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return a.applyQuaternion(this)
    };
    Object.assign(cb.prototype, {
        isIntersectionBox: function (a) {
            console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
            return this.intersectsBox(a)
        }, isIntersectionPlane: function (a) {
            console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
            return this.intersectsPlane(a)
        }, isIntersectionSphere: function (a) {
            console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
            return this.intersectsSphere(a)
        }
    });
    Object.assign(Db.prototype, {
        extrude: function (a) {
            console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
            return new La(this, a)
        }, makeGeometry: function (a) {
            console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
            return new Yb(this, a)
        }
    });
    Object.assign(D.prototype, {
        fromAttribute: function (a, b, c) {
            console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
            return this.fromBufferAttribute(a, b, c)
        }
    });
    Object.assign(q.prototype,
        {
            setEulerFromRotationMatrix: function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, setEulerFromQuaternion: function () {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, getPositionFromMatrix: function (a) {
            console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
            return this.setFromMatrixPosition(a)
        }, getScaleFromMatrix: function (a) {
            console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
            return this.setFromMatrixScale(a)
        }, getColumnFromMatrix: function (a, b) {
            console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
            return this.setFromMatrixColumn(b, a)
        }, applyProjection: function (a) {
            console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
            return this.applyMatrix4(a)
        }, fromAttribute: function (a, b, c) {
            console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
            return this.fromBufferAttribute(a,
                b, c)
        }
        });
    Object.assign(fa.prototype, {
        fromAttribute: function (a, b, c) {
            console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
            return this.fromBufferAttribute(a, b, c)
        }
    });
    T.prototype.computeTangents = function () {
        console.warn("THREE.Geometry: .computeTangents() has been removed.")
    };
    Object.assign(x.prototype, {
        getChildByName: function (a) {
            console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
            return this.getObjectByName(a)
        }, renderDepth: function () {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function (a, b) {
            console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
            return this.translateOnAxis(b, a)
        }
    });
    Object.defineProperties(x.prototype, {
        eulerOrder: {
            get: function () {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                return this.rotation.order
            }, set: function (a) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                this.rotation.order = a
            }
        }, useQuaternion: {
            get: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    });
    Object.defineProperties(Ec.prototype, {
        objects: {
            get: function () {
                console.warn("THREE.LOD: .objects has been renamed to .levels.");
                return this.levels
            }
        }
    });
    Fa.prototype.setLens = function (a, b) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        void 0 !== b && (this.filmGauge = b);
        this.setFocalLength(a)
    };
    Object.defineProperties(ma.prototype,
        {
            onlyShadow: {
                set: function () {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            }, shadowCameraFov: {
            set: function (a) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
                this.shadow.camera.fov = a
            }
        }, shadowCameraLeft: {
            set: function (a) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
                this.shadow.camera.left = a
            }
        }, shadowCameraRight: {
            set: function (a) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
                this.shadow.camera.right = a
            }
        }, shadowCameraTop: {
            set: function (a) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
                this.shadow.camera.top = a
            }
        }, shadowCameraBottom: {
            set: function (a) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
                this.shadow.camera.bottom = a
            }
        }, shadowCameraNear: {
            set: function (a) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
                this.shadow.camera.near = a
            }
        }, shadowCameraFar: {
            set: function (a) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
                this.shadow.camera.far = a
            }
        }, shadowCameraVisible: {
            set: function () {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
            shadowBias: {
                set: function (a) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
                    this.shadow.bias = a
                }
            }, shadowDarkness: {
            set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        }, shadowMapWidth: {
            set: function (a) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
                this.shadow.mapSize.width = a
            }
        }, shadowMapHeight: {
            set: function (a) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
                this.shadow.mapSize.height = a
            }
        }
        });
    Object.defineProperties(U.prototype,
        {
            length: {
                get: function () {
                    console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
                    return this.array.length
                }
            }
        });
    Object.assign(I.prototype, {
        addIndex: function (a) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
            this.setIndex(a)
        }, addDrawCall: function (a, b, c) {
            void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
            this.addGroup(a,
                b)
        }, clearDrawCalls: function () {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
            this.clearGroups()
        }, computeTangents: function () {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        }, computeOffsets: function () {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    });
    Object.defineProperties(I.prototype, {
        drawcalls: {
            get: function () {
                console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
                return this.groups
            }
        }, offsets: {
            get: function () {
                console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
                return this.groups
            }
        }
    });
    Object.defineProperties(Kd.prototype, {
        dynamic: {
            set: function () {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        }, onUpdate: {
            value: function () {
                console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
                return this
            }
        }
    });
    Object.defineProperties(X.prototype, {
        wrapAround: {
            get: function () {
                console.warn("THREE." + this.type + ": .wrapAround has been removed.")
            }, set: function () {
                console.warn("THREE." + this.type +
                    ": .wrapAround has been removed.")
            }
        }, wrapRGB: {
            get: function () {
                console.warn("THREE." + this.type + ": .wrapRGB has been removed.");
                return new J
            }
        }
    });
    Object.defineProperties(Ca.prototype, {
        metal: {
            get: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
                return !1
            }, set: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    });
    Object.defineProperties(Ha.prototype, {
        derivatives: {
            get: function () {
                console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                return this.extensions.derivatives
            }, set: function (a) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                this.extensions.derivatives = a
            }
        }
    });
    Object.assign(Yd.prototype, {
        supportsFloatTextures: function () {
            console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
            return this.extensions.get("OES_texture_float")
        }, supportsHalfFloatTextures: function () {
            console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
            return this.extensions.get("OES_texture_half_float")
        }, supportsStandardDerivatives: function () {
            console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
            return this.extensions.get("OES_standard_derivatives")
        }, supportsCompressedTextureS3TC: function () {
            console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
            return this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function () {
            console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
            return this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }, supportsBlendMinMax: function () {
            console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
            return this.extensions.get("EXT_blend_minmax")
        }, supportsVertexTextures: function () {
            console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
            return this.capabilities.vertexTextures
        }, supportsInstancedArrays: function () {
            console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
            return this.extensions.get("ANGLE_instanced_arrays")
        }, enableScissorTest: function (a) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
            this.setScissorTest(a)
        }, initMaterial: function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, addPrePlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, updateShadowMap: function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
    });
    Object.defineProperties(Yd.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            }, set: function (a) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
                this.shadowMap.enabled = a
            }
        }, shadowMapType: {
            get: function () {
                return this.shadowMap.type
            }, set: function (a) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
                this.shadowMap.type = a
            }
        }, shadowMapCullFace: {
            get: function () {
                return this.shadowMap.cullFace
            }, set: function (a) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
                this.shadowMap.cullFace = a
            }
        }
    });
    Object.defineProperties(Ke.prototype, {
        cullFace: {
            get: function () {
                return this.renderReverseSided ? 2 : 1
            }, set: function (a) {
                a = 1 !== a;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + ".");
                this.renderReverseSided = a
            }
        }
    });
    Object.defineProperties(Ya.prototype,
        {
            wrapS: {
                get: function () {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                    return this.texture.wrapS
                }, set: function (a) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                    this.texture.wrapS = a
                }
            }, wrapT: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                return this.texture.wrapT
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                this.texture.wrapT = a
            }
        }, magFilter: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                return this.texture.magFilter
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                this.texture.magFilter = a
            }
        }, minFilter: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                return this.texture.minFilter
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                this.texture.minFilter = a
            }
        }, anisotropy: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                return this.texture.anisotropy
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                this.texture.anisotropy = a
            }
        }, offset: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                return this.texture.offset
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                this.texture.offset = a
            }
        }, repeat: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                return this.texture.repeat
            },
            set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                this.texture.repeat = a
            }
        }, format: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                return this.texture.format
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                this.texture.format = a
            }
        }, type: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                return this.texture.type
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                this.texture.type = a
            }
        }, generateMipmaps: {
            get: function () {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                return this.texture.generateMipmaps
            }, set: function (a) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                this.texture.generateMipmaps = a
            }
        }
        });
    hc.prototype.load = function (a) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var b = this;
        (new ge).load(a, function (a) {
            b.setBuffer(a)
        });
        return this
    };
    le.prototype.getData = function () {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData()
    };
    l.WebGLRenderTargetCube = Gb;
    l.WebGLRenderTarget = Ya;
    l.WebGLRenderer = Yd;
    l.ShaderLib = bb;
    l.UniformsLib = V;
    l.UniformsUtils = Ja;
    l.ShaderChunk = Z;
    l.FogExp2 = Kb;
    l.Fog = Lb;
    l.Scene = mb;
    l.LensFlare = Zd;
    l.Sprite = Dc;
    l.LOD = Ec;
    l.SkinnedMesh = qd;
    l.Skeleton = od;
    l.Bone = pd;
    l.Mesh = Aa;
    l.LineSegments = ga;
    l.Line = Ua;
    l.Points = Mb;
    l.Group = Fc;
    l.VideoTexture = rd;
    l.DataTexture = eb;
    l.CompressedTexture =
        Nb;
    l.CubeTexture = Za;
    l.CanvasTexture = sd;
    l.DepthTexture = Gc;
    l.Texture = ea;
    l.CompressedTextureLoader = Re;
    l.DataTextureLoader = ae;
    l.CubeTextureLoader = be;
    l.TextureLoader = td;
    l.ObjectLoader = Se;
    l.MaterialLoader = Hd;
    l.BufferGeometryLoader = ce;
    l.DefaultLoadingManager = ta;
    l.LoadingManager = $d;
    l.JSONLoader = de;
    l.ImageLoader = Yc;
    l.FontLoader = Ue;
    l.FileLoader = sa;
    l.Loader = zb;
    l.Cache = ld;
    l.AudioLoader = ge;
    l.SpotLightShadow = vd;
    l.SpotLight = wd;
    l.PointLight = xd;
    l.RectAreaLight = he;
    l.HemisphereLight = ud;
    l.DirectionalLightShadow = yd;
    l.DirectionalLight =
        zd;
    l.AmbientLight = Ad;
    l.LightShadow = wb;
    l.Light = ma;
    l.StereoCamera = Ve;
    l.PerspectiveCamera = Fa;
    l.OrthographicCamera = Jb;
    l.CubeCamera = Id;
    l.Camera = ra;
    l.AudioListener = ie;
    l.PositionalAudio = ke;
    l.AudioContext = je;
    l.AudioAnalyser = le;
    l.Audio = hc;
    l.VectorKeyframeTrack = dc;
    l.StringKeyframeTrack = Ed;
    l.QuaternionKeyframeTrack = $c;
    l.NumberKeyframeTrack = ec;
    l.ColorKeyframeTrack = Gd;
    l.BooleanKeyframeTrack = Fd;
    l.PropertyMixer = Jd;
    l.PropertyBinding = ka;
    l.KeyframeTrack = yb;
    l.AnimationUtils = na;
    l.AnimationObjectGroup = me;
    l.AnimationMixer =
        cd;
    l.AnimationClip = qa;
    l.Uniform = Kd;
    l.InstancedBufferGeometry = Eb;
    l.BufferGeometry = I;
    l.GeometryIdCount = function () {
        return Vd++
    };
    l.Geometry = T;
    l.InterleavedBufferAttribute = oe;
    l.InstancedInterleavedBuffer = jc;
    l.InterleavedBuffer = ic;
    l.InstancedBufferAttribute = kc;
    l.Face3 = ha;
    l.Object3D = x;
    l.Raycaster = pe;
    l.Layers = nd;
    l.EventDispatcher = pa;
    l.Clock = re;
    l.QuaternionLinearInterpolant = Dd;
    l.LinearInterpolant = Zc;
    l.DiscreteInterpolant = Cd;
    l.CubicInterpolant = Bd;
    l.Interpolant = xa;
    l.Triangle = za;
    l.Math = N;
    l.Spherical = se;
    l.Cylindrical =
        te;
    l.Plane = la;
    l.Frustum = tc;
    l.Sphere = Na;
    l.Ray = cb;
    l.Matrix4 = S;
    l.Matrix3 = ya;
    l.Box3 = Pa;
    l.Box2 = sc;
    l.Line3 = hb;
    l.Euler = db;
    l.Vector4 = fa;
    l.Vector3 = q;
    l.Vector2 = D;
    l.Quaternion = ca;
    l.Color = J;
    l.MorphBlendMesh = oa;
    l.ImmediateRenderObject = dd;
    l.VertexNormalsHelper = ed;
    l.SpotLightHelper = lc;
    l.SkeletonHelper = mc;
    l.PointLightHelper = nc;
    l.RectAreaLightHelper = oc;
    l.HemisphereLightHelper = pc;
    l.GridHelper = fd;
    l.PolarGridHelper = Ld;
    l.FaceNormalsHelper = gd;
    l.DirectionalLightHelper = qc;
    l.CameraHelper = hd;
    l.BoxHelper = rc;
    l.ArrowHelper = Fb;
    l.AxisHelper = Nd;
    l.CatmullRomCurve3 = va;
    l.CubicBezierCurve3 = id;
    l.QuadraticBezierCurve3 = jd;
    l.LineCurve3 = kd;
    l.ArcCurve = Od;
    l.EllipseCurve = Wa;
    l.SplineCurve = Cb;
    l.CubicBezierCurve = fc;
    l.QuadraticBezierCurve = gc;
    l.LineCurve = Ta;
    l.Shape = Db;
    l.Path = bd;
    l.ShapePath = ee;
    l.Font = fe;
    l.CurvePath = ad;
    l.Curve = ua;
    l.ShapeUtils = Ia;
    l.SceneUtils = {
        createMultiMaterialObject: function (a, b) {
            for (var c = new Fc, d = 0, e = b.length; d < e; d++)c.add(new Aa(a, b[d]));
            return c
        }, detach: function (a, b, c) {
            a.applyMatrix(b.matrixWorld);
            b.remove(a);
            c.add(a)
        },
        attach: function (a, b, c) {
            var d = new S;
            d.getInverse(c.matrixWorld);
            a.applyMatrix(d);
            b.remove(a);
            c.add(a)
        }
    };
    l.WireframeGeometry = Ob;
    l.ParametricGeometry = Hc;
    l.ParametricBufferGeometry = Pb;
    l.TetrahedronGeometry = Jc;
    l.TetrahedronBufferGeometry = Qb;
    l.OctahedronGeometry = Kc;
    l.OctahedronBufferGeometry = ob;
    l.IcosahedronGeometry = Lc;
    l.IcosahedronBufferGeometry = Rb;
    l.DodecahedronGeometry = Mc;
    l.DodecahedronBufferGeometry = Sb;
    l.PolyhedronGeometry = Ic;
    l.PolyhedronBufferGeometry = Ba;
    l.TubeGeometry = Nc;
    l.TubeBufferGeometry = Tb;
    l.TorusKnotGeometry =
        Oc;
    l.TorusKnotBufferGeometry = Ub;
    l.TorusGeometry = Pc;
    l.TorusBufferGeometry = Vb;
    l.TextGeometry = Qc;
    l.SphereGeometry = Rc;
    l.SphereBufferGeometry = pb;
    l.RingGeometry = Sc;
    l.RingBufferGeometry = Wb;
    l.PlaneGeometry = Ac;
    l.PlaneBufferGeometry = lb;
    l.LatheGeometry = Tc;
    l.LatheBufferGeometry = Xb;
    l.ShapeGeometry = Yb;
    l.ShapeBufferGeometry = Zb;
    l.ExtrudeGeometry = La;
    l.EdgesGeometry = $b;
    l.ConeGeometry = Uc;
    l.ConeBufferGeometry = Vc;
    l.CylinderGeometry = qb;
    l.CylinderBufferGeometry = Va;
    l.CircleGeometry = Wc;
    l.CircleBufferGeometry = ac;
    l.BoxGeometry =
        Ib;
    l.BoxBufferGeometry = kb;
    l.ShadowMaterial = bc;
    l.SpriteMaterial = nb;
    l.RawShaderMaterial = cc;
    l.ShaderMaterial = Ha;
    l.PointsMaterial = Oa;
    l.MultiMaterial = Xc;
    l.MeshPhysicalMaterial = rb;
    l.MeshStandardMaterial = Qa;
    l.MeshPhongMaterial = Ca;
    l.MeshToonMaterial = sb;
    l.MeshNormalMaterial = tb;
    l.MeshLambertMaterial = ub;
    l.MeshDepthMaterial = ab;
    l.MeshBasicMaterial = Ka;
    l.LineDashedMaterial = vb;
    l.LineBasicMaterial = ia;
    l.Material = X;
    l.Float64BufferAttribute = zc;
    l.Float32BufferAttribute = z;
    l.Uint32BufferAttribute = jb;
    l.Int32BufferAttribute =
        yc;
    l.Uint16BufferAttribute = ib;
    l.Int16BufferAttribute = xc;
    l.Uint8ClampedBufferAttribute = wc;
    l.Uint8BufferAttribute = vc;
    l.Int8BufferAttribute = uc;
    l.BufferAttribute = U;
    l.REVISION = "84";
    l.MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2};
    l.CullFaceNone = 0;
    l.CullFaceBack = 1;
    l.CullFaceFront = 2;
    l.CullFaceFrontBack = 3;
    l.FrontFaceDirectionCW = 0;
    l.FrontFaceDirectionCCW = 1;
    l.BasicShadowMap = 0;
    l.PCFShadowMap = 1;
    l.PCFSoftShadowMap = 2;
    l.FrontSide = 0;
    l.BackSide = 1;
    l.DoubleSide = 2;
    l.FlatShading = 1;
    l.SmoothShading = 2;
    l.NoColors = 0;
    l.FaceColors = 1;
    l.VertexColors =
        2;
    l.NoBlending = 0;
    l.NormalBlending = 1;
    l.AdditiveBlending = 2;
    l.SubtractiveBlending = 3;
    l.MultiplyBlending = 4;
    l.CustomBlending = 5;
    l.AddEquation = 100;
    l.SubtractEquation = 101;
    l.ReverseSubtractEquation = 102;
    l.MinEquation = 103;
    l.MaxEquation = 104;
    l.ZeroFactor = 200;
    l.OneFactor = 201;
    l.SrcColorFactor = 202;
    l.OneMinusSrcColorFactor = 203;
    l.SrcAlphaFactor = 204;
    l.OneMinusSrcAlphaFactor = 205;
    l.DstAlphaFactor = 206;
    l.OneMinusDstAlphaFactor = 207;
    l.DstColorFactor = 208;
    l.OneMinusDstColorFactor = 209;
    l.SrcAlphaSaturateFactor = 210;
    l.NeverDepth =
        0;
    l.AlwaysDepth = 1;
    l.LessDepth = 2;
    l.LessEqualDepth = 3;
    l.EqualDepth = 4;
    l.GreaterEqualDepth = 5;
    l.GreaterDepth = 6;
    l.NotEqualDepth = 7;
    l.MultiplyOperation = 0;
    l.MixOperation = 1;
    l.AddOperation = 2;
    l.NoToneMapping = 0;
    l.LinearToneMapping = 1;
    l.ReinhardToneMapping = 2;
    l.Uncharted2ToneMapping = 3;
    l.CineonToneMapping = 4;
    l.UVMapping = 300;
    l.CubeReflectionMapping = 301;
    l.CubeRefractionMapping = 302;
    l.EquirectangularReflectionMapping = 303;
    l.EquirectangularRefractionMapping = 304;
    l.SphericalReflectionMapping = 305;
    l.CubeUVReflectionMapping = 306;
    l.CubeUVRefractionMapping = 307;
    l.RepeatWrapping = 1E3;
    l.ClampToEdgeWrapping = 1001;
    l.MirroredRepeatWrapping = 1002;
    l.NearestFilter = 1003;
    l.NearestMipMapNearestFilter = 1004;
    l.NearestMipMapLinearFilter = 1005;
    l.LinearFilter = 1006;
    l.LinearMipMapNearestFilter = 1007;
    l.LinearMipMapLinearFilter = 1008;
    l.UnsignedByteType = 1009;
    l.ByteType = 1010;
    l.ShortType = 1011;
    l.UnsignedShortType = 1012;
    l.IntType = 1013;
    l.UnsignedIntType = 1014;
    l.FloatType = 1015;
    l.HalfFloatType = 1016;
    l.UnsignedShort4444Type = 1017;
    l.UnsignedShort5551Type = 1018;
    l.UnsignedShort565Type =
        1019;
    l.UnsignedInt248Type = 1020;
    l.AlphaFormat = 1021;
    l.RGBFormat = 1022;
    l.RGBAFormat = 1023;
    l.LuminanceFormat = 1024;
    l.LuminanceAlphaFormat = 1025;
    l.RGBEFormat = 1023;
    l.DepthFormat = 1026;
    l.DepthStencilFormat = 1027;
    l.RGB_S3TC_DXT1_Format = 2001;
    l.RGBA_S3TC_DXT1_Format = 2002;
    l.RGBA_S3TC_DXT3_Format = 2003;
    l.RGBA_S3TC_DXT5_Format = 2004;
    l.RGB_PVRTC_4BPPV1_Format = 2100;
    l.RGB_PVRTC_2BPPV1_Format = 2101;
    l.RGBA_PVRTC_4BPPV1_Format = 2102;
    l.RGBA_PVRTC_2BPPV1_Format = 2103;
    l.RGB_ETC1_Format = 2151;
    l.LoopOnce = 2200;
    l.LoopRepeat = 2201;
    l.LoopPingPong =
        2202;
    l.InterpolateDiscrete = 2300;
    l.InterpolateLinear = 2301;
    l.InterpolateSmooth = 2302;
    l.ZeroCurvatureEnding = 2400;
    l.ZeroSlopeEnding = 2401;
    l.WrapAroundEnding = 2402;
    l.TrianglesDrawMode = 0;
    l.TriangleStripDrawMode = 1;
    l.TriangleFanDrawMode = 2;
    l.LinearEncoding = 3E3;
    l.sRGBEncoding = 3001;
    l.GammaEncoding = 3007;
    l.RGBEEncoding = 3002;
    l.LogLuvEncoding = 3003;
    l.RGBM7Encoding = 3004;
    l.RGBM16Encoding = 3005;
    l.RGBDEncoding = 3006;
    l.BasicDepthPacking = 3200;
    l.RGBADepthPacking = 3201;
    l.CubeGeometry = Ib;
    l.Face4 = function (a, b, c, d, e, f, g) {
        console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
        return new ha(a, b, c, e, f, g)
    };
    l.LineStrip = 0;
    l.LinePieces = 1;
    l.MeshFaceMaterial = function (a) {
        console.warn("THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.");
        return new Xc(a)
    };
    l.PointCloud = function (a, b) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        return new Mb(a, b)
    };
    l.Particle = function (a) {
        console.warn("THREE.Particle has been renamed to THREE.Sprite.");
        return new Dc(a)
    };
    l.ParticleSystem = function (a, b) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        return new Mb(a, b)
    };
    l.PointCloudMaterial = function (a) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        return new Oa(a)
    };
    l.ParticleBasicMaterial = function (a) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        return new Oa(a)
    };
    l.ParticleSystemMaterial = function (a) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        return new Oa(a)
    };
    l.Vertex = function (a, b, c) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        return new q(a, b, c)
    };
    l.DynamicBufferAttribute = function (a, b) {
        console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
        return (new U(a, b)).setDynamic(!0)
    };
    l.Int8Attribute = function (a, b) {
        console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
        return new uc(a, b)
    };
    l.Uint8Attribute = function (a, b) {
        console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
        return new vc(a,
            b)
    };
    l.Uint8ClampedAttribute = function (a, b) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
        return new wc(a, b)
    };
    l.Int16Attribute = function (a, b) {
        console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
        return new xc(a, b)
    };
    l.Uint16Attribute = function (a, b) {
        console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
        return new ib(a, b)
    };
    l.Int32Attribute =
        function (a, b) {
            console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
            return new yc(a, b)
        };
    l.Uint32Attribute = function (a, b) {
        console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
        return new jb(a, b)
    };
    l.Float32Attribute = function (a, b) {
        console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
        return new z(a, b)
    };
    l.Float64Attribute = function (a, b) {
        console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
        return new zc(a, b)
    };
    l.ClosedSplineCurve3 = Xe;
    l.SplineCurve3 = Ye;
    l.Spline = we;
    l.BoundingBoxHelper = function (a, b) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        return new rc(a, b)
    };
    l.EdgesHelper = function (a, b) {
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        return new ga(new $b(a.geometry), new ia({color: void 0 !== b ? b : 16777215}))
    };
    l.WireframeHelper = function (a, b) {
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        return new ga(new Ob(a.geometry), new ia({color: void 0 !== b ? b : 16777215}))
    };
    l.XHRLoader = function (a) {
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
        return new sa(a)
    };
    l.BinaryTextureLoader = function (a) {
        console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
        return new ae(a)
    };
    l.GeometryUtils = {
        merge: function (a, b, c) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var d;
            b.isMesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
            a.merge(b, d, c)
        }, center: function (a) {
            console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
            return a.center()
        }
    };
    l.ImageUtils = {
        crossOrigin: void 0, loadTexture: function (a, b, c, d) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var e = new td;
            e.setCrossOrigin(this.crossOrigin);
            a = e.load(a, c, void 0, d);
            b && (a.mapping = b);
            return a
        },
        loadTextureCube: function (a, b, c, d) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var e = new be;
            e.setCrossOrigin(this.crossOrigin);
            a = e.load(a, c, void 0, d);
            b && (a.mapping = b);
            return a
        }, loadCompressedTexture: function () {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, loadCompressedTextureCube: function () {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
    };
    l.Projector = function () {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
        this.projectVector = function (a, b) {
            console.warn("THREE.Projector: .projectVector() is now vector.project().");
            a.project(b)
        };
        this.unprojectVector = function (a, b) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
            a.unproject(b)
        };
        this.pickingRay = function () {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    };
    l.CanvasRenderer = function () {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        this.clear = function () {
        };
        this.render = function () {
        };
        this.setClearColor = function () {
        };
        this.setSize = function () {
        }
    };
    Object.defineProperty(l, "__esModule", {value: !0})
});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMTI2ZWFkNThkYjc1YmM3NTVhNzUiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL2NvbnN0LmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdXBwb3J0L3NlcnZpY2UvVXNlclNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3ZpZXdzL0Jhc2VWaWV3LmpzIiwid2VicGFjazovLy8uL34vZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3VwcG9ydC9yb3V0ZXIvUm91dGVyVXJscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZGlzcGxheS9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9XZWJHTE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9UZXh0dXJlLmpzIiwid2VicGFjazovLy8uL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9TaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL3V0aWxzL2J1aWxkTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tZW51L2VsZW1lbnRzL1Byb2dyZXNzQmFyLmpzIiwid2VicGFjazovLy8uL34vYml0LXR3aWRkbGUvdHdpZGRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL21hcFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL2Rpc3BsYXkvQm91bmRzLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L1RyYW5zZm9ybUJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL21hdGgvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL21hdGgvc2hhcGVzL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvc3ByaXRlcy9TcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL1JlbmRlclRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3RpY2tlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZS9vYmplY3QvVXNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3VwcG9ydC9odHRwL0h0dHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzbW9iaWxlanMvaXNNb2JpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL0dMVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGktZ2wtY29yZS9zcmMvc2V0VmVydGV4QXR0cmliQXJyYXlzLmpzIiwid2VicGFjazovLy8uL34vcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvY29tcGlsZVByb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9kZWZhdWx0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9leHRyYWN0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2V4dHJhY3RVbmlmb3Jtcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2dlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL21hcFNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9zZXRQcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL2F1dG9EZXRlY3RSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZGlzcGxheS9EaXNwbGF5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZGlzcGxheS9UcmFuc2Zvcm1TdGF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL21hdGgvR3JvdXBEOC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvbWF0aC9NYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy9TeXN0ZW1SZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNSZW5kZXJUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvRmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9RdWFkLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL2NhbnZhcy9DYW52YXNUaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHQvVGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9CYXNlUmVuZGVyVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvdGV4dHVyZXMvVGV4dHVyZVV2cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvdGV4dHVyZXMvVmlkZW9CYXNlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvdXRpbHMvY3JlYXRlSW5kaWNlc0ZvclF1YWRzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tZW51L2FjdGlvbnMvQ2hlY2tGaWVsZHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21lbnUvZWxlbWVudHMvRm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3VwcG9ydC9yb3V0ZXIvUm91dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9BcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2l6aXRvYXN0L2Rpc3QvanMvaXppVG9hc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL0dMQnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS1nbC1jb3JlL3NyYy9HTEZyYW1lYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS1nbC1jb3JlL3NyYy9HTFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGktZ2wtY29yZS9zcmMvVmVydGV4QXJyYXlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL2NyZWF0ZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvQXBwbGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy9jYW52YXMvQ2FudmFzR3JhcGhpY3NSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3MvdXRpbHMvYmV6aWVyQ3VydmVUby5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvR3JhcGhpY3NSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvV2ViR0xHcmFwaGljc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL3NoYWRlcnMvUHJpbWl0aXZlU2hhZGVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZENpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvdXRpbHMvYnVpbGRQb2x5LmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZFJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvdXRpbHMvYnVpbGRSb3VuZGVkUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL09ic2VydmFibGVQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvbWF0aC9zaGFwZXMvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL3NoYXBlcy9FbGxpcHNlLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL3NoYXBlcy9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc01hc2tNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL21hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9UZXh0dXJlR2FyYmFnZUNvbGxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1RleHR1cmVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvZXh0cmFjdFVuaWZvcm1zRnJvbVNyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvZmlsdGVyVHJhbnNmb3Jtcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL0ZpbHRlck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9NYXNrTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL1N0ZW5jaWxNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvY2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy92YWxpZGF0ZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3Nwcml0ZXMvY2FudmFzL0NhbnZhc1Nwcml0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL3dlYmdsL0JhdGNoQnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL3dlYmdsL1Nwcml0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL3dlYmdsL2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS90ZXh0L1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL1Nwcml0ZXNoZWV0LmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS90aWNrZXIvVGlja2VyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS91dGlscy9jYW5VcGxvYWRTYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vcGl4aS5qcy9saWIvY29yZS91dGlscy9kZXRlcm1pbmVDcm9zc09yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvdXRpbHMvbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvdXRpbHMvbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL3BsdWdpblRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BpeGkuanMvbGliL2NvcmUvdXRpbHMvdHJpbUNhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL34vcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91cmwvdXJsLmpzIiwid2VicGFjazovLy8uL34vdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZS9tb2R1bGVzL0dhbWVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lL21vZHVsZXMvR2FtZVNjZW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lL21vZHVsZXMvc3RyYXRlZ2llcy9NdWx0aXBsYXllci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZS9tb2R1bGVzL3N0cmF0ZWdpZXMvU2luZ2xlcGxheWVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tZW51L2VsZW1lbnRzL0J0bi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbWVudS9lbGVtZW50cy9EaWFtb25kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tZW51L2VsZW1lbnRzL0lucHV0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tZW51L3RlbXBsYXRlcy9MZWFkZXJCb2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3VwcG9ydC9hbmltL0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdmlld3MvZ2FtZS9HYW1lVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdmlld3MvbWVudS9BYm91dFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3ZpZXdzL21lbnUvTGVhZGVyQm9hcmRWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3cy9tZW51L0xvZ2luVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdmlld3MvbWVudS9NZW51Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdmlld3MvbWVudS9Qcm9maWxlVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdmlld3MvbWVudS9TaWduVXBWaWV3LmpzIiwid2VicGFjazovLy8uL3ZlbmRvci90aHJlZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ3pYQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjtBQUM3RixpQzs7Ozs7OztBQ3RGQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELFNBQVMsMEJBQTBCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxvQzs7Ozs7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDeEJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLGFBQWE7QUFDYjtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsaUJBQWlCO0FBQ2pCLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUEsd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7OztBQ25CQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGVBQWUsWUFBWTtBQUMzQjs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRCwrREFBK0Q7QUFDL0QsbUVBQW1FO0FBQ25FLHVFQUF1RTtBQUN2RTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsTUFBTTtBQUNqQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsTUFBTTtBQUNqQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7OztBQ3ZCQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakI7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixtQkFBbUI7QUFDbkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxnQkFBZ0IsT0FBTztBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdFQUFnRTtBQUNoRSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixtQkFBbUI7QUFDbkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZ0JBQWdCLG1CQUFtQjtBQUNuQzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixtQkFBbUI7QUFDbkM7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixnQkFBZ0I7QUFDakM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxPQUFPO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUEwQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEOzs7QUFHQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUN4bUJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EseURBQXlELDJCQUEyQjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sa0JBQWtCLHVCQUF1QjtBQUMvRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOzs7QUFHQTtBQUNBLDBDOzs7Ozs7O0FDeFRBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSx3Qzs7Ozs7OztBQ3JEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLE9BQU8sNkNBQTZDLHVCQUF1QjtBQUMxRixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU8sNkNBQTZDLHVCQUF1QjtBQUMxRixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxPQUFPLGtCQUFrQix1QkFBdUI7QUFDL0QsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSxPQUFPLDZDQUE2Qyx1QkFBdUI7QUFDMUYsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixpQkFBaUI7QUFDakM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHVDOzs7Ozs7O0FDN3VCQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU8sMEVBQTBFO0FBQ2hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTyw2Q0FBNkMsdUJBQXVCO0FBQzFGLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsYUFBYTtBQUM3Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGFBQWE7QUFDN0I7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLE9BQU8sNkNBQTZDLHVCQUF1QjtBQUMxRixnQkFBZ0IsYUFBYTtBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSxPQUFPLDZDQUE2Qyx1QkFBdUI7QUFDMUYsZ0JBQWdCLGFBQWE7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLDZDQUE2Qyx1QkFBdUI7QUFDMUYsZ0JBQWdCLGFBQWE7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixhQUFhO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsYUFBYTtBQUM3Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUMsa0NBQWtDO0FBQ2xDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7QUM5bUJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFD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QzNDLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNub0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQ3hJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0Esd0M7Ozs7Ozs7QUN4SEE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxRUFBcUU7QUFDM0c7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHNDQUFzQyxtRUFBbUU7QUFDekc7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esc0RBQXNEO0FBQ3RELHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBLDhDQUE4QztBQUM5QywwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUEsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTLHVCQUF1QjtBQUNwRixLQUFLO0FBQ0w7QUFDQSw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSiwwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7Ozs7Ozs7QUN6RkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQSwwQzs7Ozs7OztBQ2poQkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsZ0RBQWdELHdCQUF3Qiw2QkFBNkIseUNBQXlDLG9CQUFvQixlQUFlLDRDQUE0QywrQ0FBK0MsS0FBSzs7QUFFalI7QUFDQSwyQ0FBMkMsaUNBQWlDLCtCQUErQix3QkFBd0IsNkJBQTZCLGtDQUFrQywrQkFBK0Isc0JBQXNCLDJCQUEyQixvQkFBb0IsdUZBQXVGLHNDQUFzQyw4QkFBOEIscURBQXFELEdBQUc7QUFDemY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLDJFQUEyRTtBQUMzRSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0Q7Ozs7Ozs7QUM3REE7O0FBRUE7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUgsRUFBRTs7O0FBRzllO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0VBQXNFO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsc0JBQXNCO0FBQ3JDLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTs7QUFFQSwyQkFBMkIsa0JBQWtCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsdUJBQXVCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixVQUFVO0FBQzFCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLDZCQUE2QjtBQUM3Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQywyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7QUM3MkJBOztBQUVBOztBQUVBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQjs7QUFFQTs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEMsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0EsdUM7Ozs7Ozs7QUNuUUE7O0FBRUE7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQSxxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsbUJBQW1CO0FBQ3BDOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixtQkFBbUI7QUFDcEM7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsNENBQTRDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLG1CQUFtQjtBQUNwQzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQsb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQkFBK0I7QUFDdkMsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFLHNDQUFzQyxtQ0FBbUM7QUFDekUsc0RBQXNELDZCQUE2QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGtDOzs7Ozs7O0FDM1lBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQzs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEOzs7Ozs7O0FDdERBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0Q7Ozs7Ozs7QUNwQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDNURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7O0FDaEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOzs7Ozs7QUMxRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7OztzRENuTHRDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFj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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEZBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzdEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNyQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ3hEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrR0FBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7Ozs7QUFJTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsQzs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxDOzs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtB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QUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7O0FDOU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2T0E7QUFDQTtBQUNBLDJIQUFrTDtBQUNsTCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsK0VBQStFLHVCQUF1QjtBQUN0RztBQUNBLCtFQUErRSx1QkFBdUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUs7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLG1CQUFtQixRQUFRLGdCQUFnQixRQUFRO0FBQ25EO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxnQkFBZ0IsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLHlNQUF5TSxRQUFRO0FBQzVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsZ0JBQWdCLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLGdCQUFnQixRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLGdCQUFnQixRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTyxnQkFBZ0IsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0NBQStDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEMsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQiwyREFBMkQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNB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QUN0UyxxRUFBcUUsd0hBQXdIO0FBQzdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxzQkFBc0I7QUFDdEI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBLHVCQUF1QixZQUFZLGFBQWE7QUFDaEQscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLGVBQWU7QUFDL0MsU0FBUztBQUNULGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQSxxQkFBcUIsa0dBQWtHLE9BQU87QUFDOUgsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLE9BQU87QUFDbkQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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QUNiLDJCQUEyQixPQUFPO0FBQ2xDLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBOEQ7QUFDekY7QUFDQSxhQUFhLDBDQUEwQyxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEI7QUFDOUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxjQUFjO0FBQ2hGLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsT0FBTyxVQUFVO0FBQ3RGO0FBQ0EscUZBQXFGLE9BQU87QUFDNUYsNEJBQTRCO0FBQzVCLG1DQUFtQyxtQkFBbUI7QUFDdEQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrREFBK0QsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0RBQStELG9D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O0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPLG9EQUFvRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFDQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxzREFBc0Q7QUFDeEcsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRCx3R0FBd0csT0FBTztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0hBQWtIO0FBQy9ILGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLE9BQU87QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbUNBQW1DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQ0FBbUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQsQ0FBQyxFIiwiZmlsZSI6ImFwcC5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxODYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDEyNmVhZDU4ZGI3NWJjNzU1YTc1IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyoqXG4gKiBTdHJpbmcgb2YgdGhlIGN1cnJlbnQgUElYSSB2ZXJzaW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBuYW1lIFZFUlNJT05cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBWRVJTSU9OID0gZXhwb3J0cy5WRVJTSU9OID0gJzQuNC4zJztcblxuLyoqXG4gKiBUd28gUGkuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIFBJXzIgPSBleHBvcnRzLlBJXzIgPSBNYXRoLlBJICogMjtcblxuLyoqXG4gKiBDb252ZXJzaW9uIGZhY3RvciBmb3IgY29udmVydGluZyByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIFJBRF9UT19ERUcgPSBleHBvcnRzLlJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vKipcbiAqIENvbnZlcnNpb24gZmFjdG9yIGZvciBjb252ZXJ0aW5nIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgREVHX1RPX1JBRCA9IGV4cG9ydHMuREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuICogQ29uc3RhbnQgdG8gaWRlbnRpZnkgdGhlIFJlbmRlcmVyIFR5cGUuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyb2YgUElYSVxuICogQG5hbWUgUkVOREVSRVJfVFlQRVxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTktOT1dOIC0gVW5rbm93biByZW5kZXIgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBXRUJHTCAtIFdlYkdMIHJlbmRlciB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IENBTlZBUyAtIENhbnZhcyByZW5kZXIgdHlwZS5cbiAqL1xudmFyIFJFTkRFUkVSX1RZUEUgPSBleHBvcnRzLlJFTkRFUkVSX1RZUEUgPSB7XG4gIFVOS05PV046IDAsXG4gIFdFQkdMOiAxLFxuICBDQU5WQVM6IDJcbn07XG5cbi8qKlxuICogVmFyaW91cyBibGVuZCBtb2RlcyBzdXBwb3J0ZWQgYnkgUElYSS5cbiAqXG4gKiBJTVBPUlRBTlQgLSBUaGUgV2ViR0wgcmVuZGVyZXIgb25seSBzdXBwb3J0cyB0aGUgTk9STUFMLCBBREQsIE1VTFRJUExZIGFuZCBTQ1JFRU4gYmxlbmQgbW9kZXMuXG4gKiBBbnl0aGluZyBlbHNlIHdpbGwgc2lsZW50bHkgYWN0IGxpa2UgTk9STUFMLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBuYW1lIEJMRU5EX01PREVTXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PUk1BTFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEFERFxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1VTFRJUExZXG4gKiBAcHJvcGVydHkge251bWJlcn0gU0NSRUVOXG4gKiBAcHJvcGVydHkge251bWJlcn0gT1ZFUkxBWVxuICogQHByb3BlcnR5IHtudW1iZXJ9IERBUktFTlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJR0hURU5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0xPUl9ET0RHRVxuICogQHByb3BlcnR5IHtudW1iZXJ9IENPTE9SX0JVUk5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBIQVJEX0xJR0hUXG4gKiBAcHJvcGVydHkge251bWJlcn0gU09GVF9MSUdIVFxuICogQHByb3BlcnR5IHtudW1iZXJ9IERJRkZFUkVOQ0VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFWENMVVNJT05cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBIVUVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQVRVUkFUSU9OXG4gKiBAcHJvcGVydHkge251bWJlcn0gQ09MT1JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMVU1JTk9TSVRZXG4gKi9cbnZhciBCTEVORF9NT0RFUyA9IGV4cG9ydHMuQkxFTkRfTU9ERVMgPSB7XG4gIE5PUk1BTDogMCxcbiAgQUREOiAxLFxuICBNVUxUSVBMWTogMixcbiAgU0NSRUVOOiAzLFxuICBPVkVSTEFZOiA0LFxuICBEQVJLRU46IDUsXG4gIExJR0hURU46IDYsXG4gIENPTE9SX0RPREdFOiA3LFxuICBDT0xPUl9CVVJOOiA4LFxuICBIQVJEX0xJR0hUOiA5LFxuICBTT0ZUX0xJR0hUOiAxMCxcbiAgRElGRkVSRU5DRTogMTEsXG4gIEVYQ0xVU0lPTjogMTIsXG4gIEhVRTogMTMsXG4gIFNBVFVSQVRJT046IDE0LFxuICBDT0xPUjogMTUsXG4gIExVTUlOT1NJVFk6IDE2XG59O1xuXG4vKipcbiAqIFZhcmlvdXMgd2ViZ2wgZHJhdyBtb2Rlcy4gVGhlc2UgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB3aGljaCBHTCBkcmF3TW9kZSB0byB1c2VcbiAqIHVuZGVyIGNlcnRhaW4gc2l0dWF0aW9ucyBhbmQgcmVuZGVyZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBuYW1lIERSQVdfTU9ERVNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge251bWJlcn0gUE9JTlRTXG4gKiBAcHJvcGVydHkge251bWJlcn0gTElORVNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FX0xPT1BcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FX1NUUklQXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFJJQU5HTEVTXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFJJQU5HTEVfU1RSSVBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUklBTkdMRV9GQU5cbiAqL1xudmFyIERSQVdfTU9ERVMgPSBleHBvcnRzLkRSQVdfTU9ERVMgPSB7XG4gIFBPSU5UUzogMCxcbiAgTElORVM6IDEsXG4gIExJTkVfTE9PUDogMixcbiAgTElORV9TVFJJUDogMyxcbiAgVFJJQU5HTEVTOiA0LFxuICBUUklBTkdMRV9TVFJJUDogNSxcbiAgVFJJQU5HTEVfRkFOOiA2XG59O1xuXG4vKipcbiAqIFRoZSBzY2FsZSBtb2RlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgcGl4aS5cbiAqXG4gKiBUaGUge0BsaW5rIFBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERX0gc2NhbGUgbW9kZSBhZmZlY3RzIHRoZSBkZWZhdWx0IHNjYWxpbmcgbW9kZSBvZiBmdXR1cmUgb3BlcmF0aW9ucy5cbiAqIEl0IGNhbiBiZSByZS1hc3NpZ25lZCB0byBlaXRoZXIgTElORUFSIG9yIE5FQVJFU1QsIGRlcGVuZGluZyB1cG9uIHN1aXRhYmlsaXR5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBuYW1lIFNDQUxFX01PREVTXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVBUiBTbW9vdGggc2NhbGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE5FQVJFU1QgUGl4ZWxhdGluZyBzY2FsaW5nXG4gKi9cbnZhciBTQ0FMRV9NT0RFUyA9IGV4cG9ydHMuU0NBTEVfTU9ERVMgPSB7XG4gIExJTkVBUjogMCxcbiAgTkVBUkVTVDogMVxufTtcblxuLyoqXG4gKiBUaGUgd3JhcCBtb2RlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgcGl4aS5cbiAqXG4gKiBUaGUge0BsaW5rIFBJWEkuc2V0dGluZ3MuV1JBUF9NT0RFfSB3cmFwIG1vZGUgYWZmZWN0cyB0aGUgZGVmYXVsdCB3cmFwaW5nIG1vZGUgb2YgZnV0dXJlIG9wZXJhdGlvbnMuXG4gKiBJdCBjYW4gYmUgcmUtYXNzaWduZWQgdG8gZWl0aGVyIENMQU1QIG9yIFJFUEVBVCwgZGVwZW5kaW5nIHVwb24gc3VpdGFiaWxpdHkuXG4gKiBJZiB0aGUgdGV4dHVyZSBpcyBub24gcG93ZXIgb2YgdHdvIHRoZW4gY2xhbXAgd2lsbCBiZSB1c2VkIHJlZ2FyZGxlc3MgYXMgd2ViR0wgY2FuXG4gKiBvbmx5IHVzZSBSRVBFQVQgaWYgdGhlIHRleHR1cmUgaXMgcG8yLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgb25seSBhZmZlY3RzIFdlYkdMLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG5hbWUgV1JBUF9NT0RFU1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge251bWJlcn0gQ0xBTVAgLSBUaGUgdGV4dHVyZXMgdXZzIGFyZSBjbGFtcGVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gUkVQRUFUIC0gVGhlIHRleHR1cmUgdXZzIHRpbGUgYW5kIHJlcGVhdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1JUlJPUkVEX1JFUEVBVCAtIFRoZSB0ZXh0dXJlIHV2cyB0aWxlIGFuZCByZXBlYXQgd2l0aCBtaXJyb3JpbmdcbiAqL1xudmFyIFdSQVBfTU9ERVMgPSBleHBvcnRzLldSQVBfTU9ERVMgPSB7XG4gIENMQU1QOiAwLFxuICBSRVBFQVQ6IDEsXG4gIE1JUlJPUkVEX1JFUEVBVDogMlxufTtcblxuLyoqXG4gKiBUaGUgZ2MgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXG4gKlxuICogVGhlIHtAbGluayBQSVhJLnNldHRpbmdzLkdDX01PREV9IEdhcmJhZ2UgQ29sbGVjdGlvbiBtb2RlIGZvciBwaXhpIHRleHR1cmVzIGlzIEFVVE9cbiAqIElmIHNldCB0byBHQ19NT0RFLCB0aGUgcmVuZGVyZXIgd2lsbCBvY2Nhc2lvbmFsbHkgY2hlY2sgdGV4dHVyZXMgdXNhZ2UuIElmIHRoZXkgYXJlIG5vdFxuICogdXNlZCBmb3IgYSBzcGVjaWZpZWQgcGVyaW9kIG9mIHRpbWUgdGhleSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVLiBUaGV5IHdpbGwgb2YgY291cnNlXG4gKiBiZSB1cGxvYWRlZCBhZ2FpbiB3aGVuIHRoZXkgYXJlIHJlcXVpcmVkLiBUaGlzIGlzIGEgc2lsZW50IGJlaGluZCB0aGUgc2NlbmVzIHByb2Nlc3MgdGhhdFxuICogc2hvdWxkIGVuc3VyZSB0aGF0IHRoZSBHUFUgZG9lcyBub3QgIGdldCBmaWxsZWQgdXAuXG4gKlxuICogSGFuZHkgZm9yIG1vYmlsZSBkZXZpY2VzIVxuICogVGhpcyBwcm9wZXJ0eSBvbmx5IGFmZmVjdHMgV2ViR0wuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbmFtZSBHQ19NT0RFU1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge251bWJlcn0gQVVUTyAtIEdhcmJhZ2UgY29sbGVjdGlvbiB3aWxsIGhhcHBlbiBwZXJpb2RpY2FsbHkgYXV0b21hdGljYWxseVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1BTlVBTCAtIEdhcmJhZ2UgY29sbGVjdGlvbiB3aWxsIG5lZWQgdG8gYmUgY2FsbGVkIG1hbnVhbGx5XG4gKi9cbnZhciBHQ19NT0RFUyA9IGV4cG9ydHMuR0NfTU9ERVMgPSB7XG4gIEFVVE86IDAsXG4gIE1BTlVBTDogMVxufTtcblxuLyoqXG4gKiBSZWdleHAgZm9yIGltYWdlIHR5cGUgYnkgZXh0ZW5zaW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG1lbWJlcm9mIFBJWElcbiAqIEB0eXBlIHtSZWdFeHB8c3RyaW5nfVxuICogQGV4YW1wbGUgYGltYWdlLnBuZ2BcbiAqL1xudmFyIFVSTF9GSUxFX0VYVEVOU0lPTiA9IGV4cG9ydHMuVVJMX0ZJTEVfRVhURU5TSU9OID0gL1xcLihcXHd7Myw0fSkoPzokfFxcP3wjKS9pO1xuXG4vKipcbiAqIFJlZ2V4cCBmb3IgZGF0YSBVUkkuXG4gKiBCYXNlZCBvbjoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWdpbmd3aW5kL2RhdGEtdXJpLXJlZ2V4fVxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG5hbWUgREFUQV9VUklcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7UmVnRXhwfHN0cmluZ31cbiAqIEBleGFtcGxlIGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NFxuICovXG52YXIgREFUQV9VUkkgPSBleHBvcnRzLkRBVEFfVVJJID0gL15cXHMqZGF0YTooPzooW1xcdy1dKylcXC8oW1xcdysuLV0rKSk/KD86OyhjaGFyc2V0PVtcXHctXSt8YmFzZTY0KSk/LCguKikvaTtcblxuLyoqXG4gKiBSZWdleHAgZm9yIFNWRyBzaXplLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG5hbWUgU1ZHX1NJWkVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7UmVnRXhwfHN0cmluZ31cbiAqIEBleGFtcGxlICZsdDtzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiZndDsmbHQ7L3N2ZyZndDtcbiAqL1xudmFyIFNWR19TSVpFID0gZXhwb3J0cy5TVkdfU0laRSA9IC88c3ZnW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKj4vaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5cbi8qKlxuICogQ29uc3RhbnRzIHRoYXQgaWRlbnRpZnkgc2hhcGVzLCBtYWlubHkgdG8gcHJldmVudCBgaW5zdGFuY2VvZmAgY2FsbHMuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbmFtZSBTSEFQRVNcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFBPTFkgUG9seWdvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IFJFQ1QgUmVjdGFuZ2xlXG4gKiBAcHJvcGVydHkge251bWJlcn0gQ0lSQyBDaXJjbGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFTElQIEVsbGlwc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSUkVDIFJvdW5kZWQgUmVjdGFuZ2xlXG4gKi9cbnZhciBTSEFQRVMgPSBleHBvcnRzLlNIQVBFUyA9IHtcbiAgUE9MWTogMCxcbiAgUkVDVDogMSxcbiAgQ0lSQzogMixcbiAgRUxJUDogMyxcbiAgUlJFQzogNFxufTtcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiBzaGFkZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG5hbWUgUFJFQ0lTSU9OXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMT1c9J2xvd3AnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTUVESVVNPSdtZWRpdW1wJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IEhJR0g9J2hpZ2hwJ1xuICovXG52YXIgUFJFQ0lTSU9OID0gZXhwb3J0cy5QUkVDSVNJT04gPSB7XG4gIExPVzogJ2xvd3AnLFxuICBNRURJVU06ICdtZWRpdW1wJyxcbiAgSElHSDogJ2hpZ2hwJ1xufTtcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBzcGVjaWZ5IHRoZSB0cmFuc2Zvcm0gdHlwZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIFRSQU5TRk9STV9NT0RFXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVEFUSUNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEWU5BTUlDXG4gKi9cbnZhciBUUkFOU0ZPUk1fTU9ERSA9IGV4cG9ydHMuVFJBTlNGT1JNX01PREUgPSB7XG4gIFNUQVRJQzogMCxcbiAgRFlOQU1JQzogMVxufTtcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBkZWZpbmUgdGhlIHR5cGUgb2YgZ3JhZGllbnQgb24gdGV4dC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIFRFWFRfR1JBRElFTlRcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVBUl9WRVJUSUNBTCBWZXJ0aWNhbCBncmFkaWVudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVBUl9IT1JJWk9OVEFMIExpbmVhciBncmFkaWVudFxuICovXG52YXIgVEVYVF9HUkFESUVOVCA9IGV4cG9ydHMuVEVYVF9HUkFESUVOVCA9IHtcbiAgTElORUFSX1ZFUlRJQ0FMOiAwLFxuICBMSU5FQVJfSE9SSVpPTlRBTDogMVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQmFzZVRleHR1cmVDYWNoZSA9IGV4cG9ydHMuVGV4dHVyZUNhY2hlID0gZXhwb3J0cy5taXhpbnMgPSBleHBvcnRzLnBsdWdpblRhcmdldCA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5pc01vYmlsZSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMudWlkID0gdWlkO1xuZXhwb3J0cy5oZXgycmdiID0gaGV4MnJnYjtcbmV4cG9ydHMuaGV4MnN0cmluZyA9IGhleDJzdHJpbmc7XG5leHBvcnRzLnJnYjJoZXggPSByZ2IyaGV4O1xuZXhwb3J0cy5nZXRSZXNvbHV0aW9uT2ZVcmwgPSBnZXRSZXNvbHV0aW9uT2ZVcmw7XG5leHBvcnRzLmRlY29tcG9zZURhdGFVcmkgPSBkZWNvbXBvc2VEYXRhVXJpO1xuZXhwb3J0cy5nZXRVcmxGaWxlRXh0ZW5zaW9uID0gZ2V0VXJsRmlsZUV4dGVuc2lvbjtcbmV4cG9ydHMuZ2V0U3ZnU2l6ZSA9IGdldFN2Z1NpemU7XG5leHBvcnRzLnNraXBIZWxsbyA9IHNraXBIZWxsbztcbmV4cG9ydHMuc2F5SGVsbG8gPSBzYXlIZWxsbztcbmV4cG9ydHMuaXNXZWJHTFN1cHBvcnRlZCA9IGlzV2ViR0xTdXBwb3J0ZWQ7XG5leHBvcnRzLnNpZ24gPSBzaWduO1xuZXhwb3J0cy5yZW1vdmVJdGVtcyA9IHJlbW92ZUl0ZW1zO1xuZXhwb3J0cy5kZXN0cm95VGV4dHVyZUNhY2hlID0gZGVzdHJveVRleHR1cmVDYWNoZTtcbmV4cG9ydHMuY2xlYXJUZXh0dXJlQ2FjaGUgPSBjbGVhclRleHR1cmVDYWNoZTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50ZW1pdHRlcik7XG5cbnZhciBfcGx1Z2luVGFyZ2V0ID0gcmVxdWlyZSgnLi9wbHVnaW5UYXJnZXQnKTtcblxudmFyIF9wbHVnaW5UYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGx1Z2luVGFyZ2V0KTtcblxudmFyIF9taXhpbiA9IHJlcXVpcmUoJy4vbWl4aW4nKTtcblxudmFyIG1peGlucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9taXhpbik7XG5cbnZhciBfaXNtb2JpbGVqcyA9IHJlcXVpcmUoJ2lzbW9iaWxlanMnKTtcblxudmFyIGlzTW9iaWxlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2lzbW9iaWxlanMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbmV4dFVpZCA9IDA7XG52YXIgc2FpZEhlbGxvID0gZmFsc2U7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLnV0aWxzXG4gKi9cbmV4cG9ydHMuaXNNb2JpbGUgPSBpc01vYmlsZTtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gX2V2ZW50ZW1pdHRlcjIuZGVmYXVsdDtcbmV4cG9ydHMucGx1Z2luVGFyZ2V0ID0gX3BsdWdpblRhcmdldDIuZGVmYXVsdDtcbmV4cG9ydHMubWl4aW5zID0gbWl4aW5zO1xuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgdW5pcXVlIGlkZW50aWZpZXJcbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQGZ1bmN0aW9uIHVpZFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCB1bmlxdWUgaWRlbnRpZmllciB0byB1c2UuXG4gKi9cblxuZnVuY3Rpb24gdWlkKCkge1xuICAgIHJldHVybiArK25leHRVaWQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGFuIFtSLCBHLCBCXSBhcnJheVxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gaGV4MnJnYlxuICogQHBhcmFtIHtudW1iZXJ9IGhleCAtIFRoZSBudW1iZXIgdG8gY29udmVydFxuICogQHBhcmFtICB7bnVtYmVyW119IFtvdXQ9W11dIElmIHN1cHBsaWVkLCB0aGlzIGFycmF5IHdpbGwgYmUgdXNlZCByYXRoZXIgdGhhbiByZXR1cm5pbmcgYSBuZXcgb25lXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBbUiwgRywgQl0gb2YgdGhlIGNvbG9yLlxuICovXG5mdW5jdGlvbiBoZXgycmdiKGhleCwgb3V0KSB7XG4gICAgb3V0ID0gb3V0IHx8IFtdO1xuXG4gICAgb3V0WzBdID0gKGhleCA+PiAxNiAmIDB4RkYpIC8gMjU1O1xuICAgIG91dFsxXSA9IChoZXggPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgIG91dFsyXSA9IChoZXggJiAweEZGKSAvIDI1NTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gaGV4MnN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGhleCAtIE51bWJlciBpbiBoZXhcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyBjb2xvci5cbiAqL1xuZnVuY3Rpb24gaGV4MnN0cmluZyhoZXgpIHtcbiAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xuICAgIGhleCA9ICcwMDAwMDAnLnN1YnN0cigwLCA2IC0gaGV4Lmxlbmd0aCkgKyBoZXg7XG5cbiAgICByZXR1cm4gJyMnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5IHRvIGEgaGV4IG51bWJlclxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gcmdiMmhleFxuICogQHBhcmFtIHtudW1iZXJbXX0gcmdiIC0gcmdiIGFycmF5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb2xvciBudW1iZXJcbiAqL1xuZnVuY3Rpb24gcmdiMmhleChyZ2IpIHtcbiAgICByZXR1cm4gKHJnYlswXSAqIDI1NSA8PCAxNikgKyAocmdiWzFdICogMjU1IDw8IDgpICsgKHJnYlsyXSAqIDI1NSB8IDApO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiBhbiBhc3NldCBieSBsb29raW5nIGZvciB0aGUgcHJlZml4XG4gKiB1c2VkIGJ5IHNwcml0ZXNoZWV0cyBhbmQgaW1hZ2UgdXJsc1xuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbk9mVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIGltYWdlIHBhdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlPTFdIC0gdGhlIGRlZmF1bHRWYWx1ZSBpZiBubyBmaWxlbmFtZSBwcmVmaXggaXMgc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIGFuIGFzc2V0XG4gKi9cbmZ1bmN0aW9uIGdldFJlc29sdXRpb25PZlVybCh1cmwsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXNvbHV0aW9uID0gX3NldHRpbmdzMi5kZWZhdWx0LlJFVElOQV9QUkVGSVguZXhlYyh1cmwpO1xuXG4gICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzb2x1dGlvblsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogMTtcbn1cblxuLyoqXG4gKiBUeXBlZGVmIGZvciBkZWNvbXBvc2VEYXRhVXJpIHJldHVybiBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gRGVjb21wb3NlZERhdGFVcmlcbiAqIEBwcm9wZXJ0eSB7bWVkaWFUeXBlfSBNZWRpYSB0eXBlLCBlZy4gYGltYWdlYFxuICogQHByb3BlcnR5IHtzdWJUeXBlfSBTdWIgdHlwZSwgZWcuIGBwbmdgXG4gKiBAcHJvcGVydHkge2VuY29kaW5nfSBEYXRhIGVuY29kaW5nLCBlZy4gYGJhc2U2NGBcbiAqIEBwcm9wZXJ0eSB7ZGF0YX0gVGhlIGFjdHVhbCBkYXRhXG4gKi9cblxuLyoqXG4gKiBTcGxpdCBhIGRhdGEgVVJJIGludG8gY29tcG9uZW50cy4gUmV0dXJucyB1bmRlZmluZWQgaWZcbiAqIHBhcmFtZXRlciBgZGF0YVVyaWAgaXMgbm90IGEgdmFsaWQgZGF0YSBVUkkuXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBmdW5jdGlvbiBkZWNvbXBvc2VEYXRhVXJpXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIHRoZSBkYXRhIFVSSSB0byBjaGVja1xuICogQHJldHVybiB7RGVjb21wb3NlZERhdGFVcml8dW5kZWZpbmVkfSBUaGUgZGVjb21wb3NlZCBkYXRhIHVyaSBvciB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gZGVjb21wb3NlRGF0YVVyaShkYXRhVXJpKSB7XG4gICAgdmFyIGRhdGFVcmlNYXRjaCA9IF9jb25zdC5EQVRBX1VSSS5leGVjKGRhdGFVcmkpO1xuXG4gICAgaWYgKGRhdGFVcmlNYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVkaWFUeXBlOiBkYXRhVXJpTWF0Y2hbMV0gPyBkYXRhVXJpTWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN1YlR5cGU6IGRhdGFVcmlNYXRjaFsyXSA/IGRhdGFVcmlNYXRjaFsyXS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGRhdGFVcmlNYXRjaFszXSA/IGRhdGFVcmlNYXRjaFszXS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YTogZGF0YVVyaU1hdGNoWzRdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBHZXQgdHlwZSBvZiB0aGUgaW1hZ2UgYnkgcmVnZXhwIGZvciBleHRlbnNpb24uIFJldHVybnMgdW5kZWZpbmVkIGZvciB1bmtub3duIGV4dGVuc2lvbnMuXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBmdW5jdGlvbiBnZXRVcmxGaWxlRXh0ZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIGltYWdlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IGltYWdlIGV4dGVuc2lvblxuICovXG5mdW5jdGlvbiBnZXRVcmxGaWxlRXh0ZW5zaW9uKHVybCkge1xuICAgIHZhciBleHRlbnNpb24gPSBfY29uc3QuVVJMX0ZJTEVfRVhURU5TSU9OLmV4ZWModXJsKTtcblxuICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvblsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVHlwZWRlZiBmb3IgU2l6ZSBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gU2l6ZVxuICogQHByb3BlcnR5IHt3aWR0aH0gV2lkdGggY29tcG9uZW50XG4gKiBAcHJvcGVydHkge2hlaWdodH0gSGVpZ2h0IGNvbXBvbmVudFxuICovXG5cbi8qKlxuICogR2V0IHNpemUgZnJvbSBhbiBzdmcgc3RyaW5nIHVzaW5nIHJlZ2V4cC5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQGZ1bmN0aW9uIGdldFN2Z1NpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdmdTdHJpbmcgLSBhIHNlcmlhbGl6ZWQgc3ZnIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NpemV8dW5kZWZpbmVkfSBpbWFnZSBleHRlbnNpb25cbiAqL1xuZnVuY3Rpb24gZ2V0U3ZnU2l6ZShzdmdTdHJpbmcpIHtcbiAgICB2YXIgc2l6ZU1hdGNoID0gX2NvbnN0LlNWR19TSVpFLmV4ZWMoc3ZnU3RyaW5nKTtcbiAgICB2YXIgc2l6ZSA9IHt9O1xuXG4gICAgaWYgKHNpemVNYXRjaCkge1xuICAgICAgICBzaXplW3NpemVNYXRjaFsxXV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzNdKSk7XG4gICAgICAgIHNpemVbc2l6ZU1hdGNoWzVdXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChzaXplTWF0Y2hbN10pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbn1cblxuLyoqXG4gKiBTa2lwcyB0aGUgaGVsbG8gbWVzc2FnZSBvZiByZW5kZXJlcnMgdGhhdCBhcmUgY3JlYXRlZCBhZnRlciB0aGlzIGlzIHJ1bi5cbiAqXG4gKiBAZnVuY3Rpb24gc2tpcEhlbGxvXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICovXG5mdW5jdGlvbiBza2lwSGVsbG8oKSB7XG4gICAgc2FpZEhlbGxvID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBMb2dzIG91dCB0aGUgdmVyc2lvbiBhbmQgcmVuZGVyZXIgaW5mb3JtYXRpb24gZm9yIHRoaXMgcnVubmluZyBpbnN0YW5jZSBvZiBQSVhJLlxuICogSWYgeW91IGRvbid0IHdhbnQgdG8gc2VlIHRoaXMgbWVzc2FnZSB5b3UgY2FuIHJ1biBgUElYSS51dGlscy5za2lwSGVsbG8oKWAgYmVmb3JlXG4gKiBjcmVhdGluZyB5b3VyIHJlbmRlcmVyLiBLZWVwIGluIG1pbmQgdGhhdCBkb2luZyB0aGF0IHdpbGwgZm9yZXZlciBtYWtlcyB5b3UgYSBqZXJrIGZhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIHNheUhlbGxvXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgc3RyaW5nIHJlbmRlcmVyIHR5cGUgdG8gbG9nLlxuICovXG5mdW5jdGlvbiBzYXlIZWxsbyh0eXBlKSB7XG4gICAgaWYgKHNhaWRIZWxsbykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XG4gICAgICAgIHZhciBhcmdzID0gWydcXG4gJWMgJWMgJWMgUGl4aS5qcyAnICsgX2NvbnN0LlZFUlNJT04gKyAnIC0gXFx1MjczMCAnICsgdHlwZSArICcgXFx1MjczMCAgJWMgICVjICBodHRwOi8vd3d3LnBpeGlqcy5jb20vICAlYyAlYyBcXHUyNjY1JWNcXHUyNjY1JWNcXHUyNjY1IFxcblxcbicsICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsICdjb2xvcjogI2ZmNjZhNTsgYmFja2dyb3VuZDogIzAzMDMwNzsgcGFkZGluZzo1cHggMDsnLCAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLCAnYmFja2dyb3VuZDogI2ZmYzNkYzsgcGFkZGluZzo1cHggMDsnLCAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLCAnY29sb3I6ICNmZjI0MjQ7IGJhY2tncm91bmQ6ICNmZmY7IHBhZGRpbmc6NXB4IDA7JywgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmOyBwYWRkaW5nOjVweCAwOycsICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZjsgcGFkZGluZzo1cHggMDsnXTtcblxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1BpeGkuanMgJyArIF9jb25zdC5WRVJTSU9OICsgJyAtICcgKyB0eXBlICsgJyAtIGh0dHA6Ly93d3cucGl4aWpzLmNvbS8nKTtcbiAgICB9XG5cbiAgICBzYWlkSGVsbG8gPSB0cnVlO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgY2hlY2tpbmcgZm9yIHdlYmdsIHN1cHBvcnRcbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQGZ1bmN0aW9uIGlzV2ViR0xTdXBwb3J0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlzIHdlYmdsIHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBpc1dlYkdMU3VwcG9ydGVkKCkge1xuICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHsgc3RlbmNpbDogdHJ1ZSwgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZSB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGNvbnRleHRPcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBzdWNjZXNzID0gISEoZ2wgJiYgZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5zdGVuY2lsKTtcblxuICAgICAgICBpZiAoZ2wpIHtcbiAgICAgICAgICAgIHZhciBsb3NlQ29udGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG5cbiAgICAgICAgICAgIGlmIChsb3NlQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGxvc2VDb250ZXh0Lmxvc2VDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnbCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgc2lnbiBvZiBudW1iZXJcbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQGZ1bmN0aW9uIHNpZ25cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gdGhlIG51bWJlciB0byBjaGVjayB0aGUgc2lnbiBvZlxuICogQHJldHVybnMge251bWJlcn0gMCBpZiBgbmAgaXMgMCwgLTEgaWYgYG5gIGlzIG5lZ2F0aXZlLCAxIGlmIGBuYCBpcyBwb3NpdGl2ZVxuICovXG5mdW5jdGlvbiBzaWduKG4pIHtcbiAgICBpZiAobiA9PT0gMCkgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbiA8IDAgPyAtMSA6IDE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgcmFuZ2Ugb2YgaXRlbXMgZnJvbSBhbiBhcnJheVxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gcmVtb3ZlSXRlbXNcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyciBUaGUgdGFyZ2V0IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJZHggVGhlIGluZGV4IHRvIGJlZ2luIHJlbW92aW5nIGZyb20gKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmVDb3VudCBIb3cgbWFueSBpdGVtcyB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICAgIGlmIChzdGFydElkeCA+PSBsZW5ndGggfHwgcmVtb3ZlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZUNvdW50ID0gc3RhcnRJZHggKyByZW1vdmVDb3VudCA+IGxlbmd0aCA/IGxlbmd0aCAtIHN0YXJ0SWR4IDogcmVtb3ZlQ291bnQ7XG5cbiAgICB2YXIgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJZHg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgICB9XG5cbiAgICBhcnIubGVuZ3RoID0gbGVuO1xufVxuXG4vKipcbiAqIEB0b2RvIERlc2NyaWJlIHByb3BlcnR5IHVzYWdlXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBUZXh0dXJlQ2FjaGUgPSBleHBvcnRzLlRleHR1cmVDYWNoZSA9IHt9O1xuXG4vKipcbiAqIEB0b2RvIERlc2NyaWJlIHByb3BlcnR5IHVzYWdlXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBCYXNlVGV4dHVyZUNhY2hlID0gZXhwb3J0cy5CYXNlVGV4dHVyZUNhY2hlID0ge307XG5cbi8qKlxuICogRGVzdHJveXMgYWxsIHRleHR1cmUgaW4gdGhlIGNhY2hlXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBmdW5jdGlvbiBkZXN0cm95VGV4dHVyZUNhY2hlXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3lUZXh0dXJlQ2FjaGUoKSB7XG4gICAgdmFyIGtleSA9IHZvaWQgMDtcblxuICAgIGZvciAoa2V5IGluIFRleHR1cmVDYWNoZSkge1xuICAgICAgICBUZXh0dXJlQ2FjaGVba2V5XS5kZXN0cm95KCk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIEJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgQmFzZVRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgdGV4dHVyZXMgZnJvbSBjYWNoZSwgYnV0IGRvZXMgbm90IGRlc3Ryb3kgdGhlbVxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAZnVuY3Rpb24gY2xlYXJUZXh0dXJlQ2FjaGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJUZXh0dXJlQ2FjaGUoKSB7XG4gICAgdmFyIGtleSA9IHZvaWQgMDtcblxuICAgIGZvciAoa2V5IGluIFRleHR1cmVDYWNoZSkge1xuICAgICAgICBkZWxldGUgVGV4dHVyZUNhY2hlW2tleV07XG4gICAgfVxuICAgIGZvciAoa2V5IGluIEJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgZGVsZXRlIEJhc2VUZXh0dXJlQ2FjaGVba2V5XTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS91dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUG9pbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfT2JzZXJ2YWJsZVBvaW50ID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlUG9pbnQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdPYnNlcnZhYmxlUG9pbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYnNlcnZhYmxlUG9pbnQpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX01hdHJpeCA9IHJlcXVpcmUoJy4vTWF0cml4Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTWF0cml4Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWF0cml4KS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Hcm91cEQgPSByZXF1aXJlKCcuL0dyb3VwRDgnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdHcm91cEQ4Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR3JvdXBEKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DaXJjbGUgPSByZXF1aXJlKCcuL3NoYXBlcy9DaXJjbGUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDaXJjbGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0VsbGlwc2UgPSByZXF1aXJlKCcuL3NoYXBlcy9FbGxpcHNlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRWxsaXBzZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VsbGlwc2UpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1BvbHlnb24gPSByZXF1aXJlKCcuL3NoYXBlcy9Qb2x5Z29uJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUG9seWdvbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvbHlnb24pLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoJy4vc2hhcGVzL1JlY3RhbmdsZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1JlY3RhbmdsZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY3RhbmdsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfUm91bmRlZFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdSb3VuZGVkUmVjdGFuZ2xlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91bmRlZFJlY3RhbmdsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9tYXhSZWNvbW1lbmRlZFRleHR1cmVzID0gcmVxdWlyZSgnLi91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzJyk7XG5cbnZhciBfbWF4UmVjb21tZW5kZWRUZXh0dXJlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXhSZWNvbW1lbmRlZFRleHR1cmVzKTtcblxudmFyIF9jYW5VcGxvYWRTYW1lQnVmZmVyID0gcmVxdWlyZSgnLi91dGlscy9jYW5VcGxvYWRTYW1lQnVmZmVyJyk7XG5cbnZhciBfY2FuVXBsb2FkU2FtZUJ1ZmZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW5VcGxvYWRTYW1lQnVmZmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkuc2V0dGluZ3NcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuXG4gIC8qKlxuICAgKiBUYXJnZXQgZnJhbWVzIHBlciBtaWxsaXNlY29uZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjA2XG4gICAqL1xuICBUQVJHRVRfRlBNUzogMC4wNixcblxuICAvKipcbiAgICogSWYgc2V0IHRvIHRydWUgV2ViR0wgd2lsbCBhdHRlbXB0IG1ha2UgdGV4dHVyZXMgbWltcGFwZWQgYnkgZGVmYXVsdC5cbiAgICogTWlwbWFwcGluZyB3aWxsIG9ubHkgc3VjY2VlZCBpZiB0aGUgYmFzZSB0ZXh0dXJlIHVwbG9hZGVkIGhhcyBwb3dlciBvZiB0d28gZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgTUlQTUFQX1RFWFRVUkVTOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIFJFU09MVVRJT046IDEsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZmlsdGVyIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgRklMVEVSX1JFU09MVVRJT046IDEsXG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHRleHR1cmVzIHRoYXQgdGhpcyBkZXZpY2Ugc3VwcG9ydHMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMzJcbiAgICovXG4gIFNQUklURV9NQVhfVEVYVFVSRVM6ICgwLCBfbWF4UmVjb21tZW5kZWRUZXh0dXJlczIuZGVmYXVsdCkoMzIpLFxuXG4gIC8vIFRPRE86IG1heWJlIGNoYW5nZSB0byBTUFJJVEUuQkFUQ0hfU0laRTogMjAwMFxuICAvLyBUT0RPOiBtYXliZSBhZGQgUEFSVElDTEUuQkFUQ0hfU0laRTogMTUwMDBcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgc3ByaXRlIGJhdGNoIHNpemUuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGFpbXMgdG8gYmFsYW5jZSBkZXNrdG9wIGFuZCBtb2JpbGUgZGV2aWNlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA0MDk2XG4gICAqL1xuICBTUFJJVEVfQkFUQ0hfU0laRTogNDA5NixcblxuICAvKipcbiAgICogVGhlIHByZWZpeCB0aGF0IGRlbm90ZXMgYSBVUkwgaXMgZm9yIGEgcmV0aW5hIGFzc2V0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBleGFtcGxlIGBAMnhgXG4gICAqIEBkZWZhdWx0IC9AKFswLTlcXC5dKyl4L1xuICAgKi9cbiAgUkVUSU5BX1BSRUZJWDogL0AoWzAtOVxcLl0rKXgvLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCByZW5kZXIgb3B0aW9ucyBpZiBub25lIGFyZSBzdXBwbGllZCB0byB7QGxpbmsgUElYSS5XZWJHTFJlbmRlcmVyfVxuICAgKiBvciB7QGxpbmsgUElYSS5DYW52YXNSZW5kZXJlcn0uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQGNvbnN0YW50XG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IHZpZXc9bnVsbFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVzb2x1dGlvbj0xXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW50aWFsaWFzPWZhbHNlXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZm9yY2VGWEFBPWZhbHNlXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXV0b1Jlc2l6ZT1mYWxzZVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHRyYW5zcGFyZW50PWZhbHNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYWNrZ3JvdW5kQ29sb3I9MHgwMDAwMDBcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBjbGVhckJlZm9yZVJlbmRlcj10cnVlXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm91bmRQaXhlbHM9ZmFsc2VcbiAgICovXG4gIFJFTkRFUl9PUFRJT05TOiB7XG4gICAgdmlldzogbnVsbCxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIGZvcmNlRlhBQTogZmFsc2UsXG4gICAgYXV0b1Jlc2l6ZTogZmFsc2UsXG4gICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgIGJhY2tncm91bmRDb2xvcjogMHgwMDAwMDAsXG4gICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICByb3VuZFBpeGVsczogZmFsc2VcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCB0cmFuc2Zvcm0gdHlwZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5UUkFOU0ZPUk1fTU9ERX1cbiAgICogQGRlZmF1bHQgUElYSS5UUkFOU0ZPUk1fTU9ERS5TVEFUSUNcbiAgICovXG4gIFRSQU5TRk9STV9NT0RFOiAwLFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLkdDX01PREVTfVxuICAgKiBAZGVmYXVsdCBQSVhJLkdDX01PREVTLkFVVE9cbiAgICovXG4gIEdDX01PREU6IDAsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1heCBpZGxlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDM2MDBcbiAgICovXG4gIEdDX01BWF9JRExFOiA2MCAqIDYwLFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtYXhpbXVtIGNoZWNrIGNvdW50LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDYwMFxuICAgKi9cbiAgR0NfTUFYX0NIRUNLX0NPVU5UOiA2MCAqIDEwLFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHdyYXAgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuV1JBUF9NT0RFU31cbiAgICogQGRlZmF1bHQgUElYSS5XUkFQX01PREVTLkNMQU1QXG4gICAqL1xuICBXUkFQX01PREU6IDAsXG5cbiAgLyoqXG4gICAqIFRoZSBzY2FsZSBtb2RlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgcGl4aS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5TQ0FMRV9NT0RFU31cbiAgICogQGRlZmF1bHQgUElYSS5TQ0FMRV9NT0RFUy5MSU5FQVJcbiAgICovXG4gIFNDQUxFX01PREU6IDAsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc3BlY2lmeSBmbG9hdCBwcmVjaXNpb24gaW4gdmVydGV4IHNoYWRlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5QUkVDSVNJT059XG4gICAqIEBkZWZhdWx0IFBJWEkuUFJFQ0lTSU9OLkhJR0hcbiAgICovXG4gIFBSRUNJU0lPTl9WRVJURVg6ICdoaWdocCcsXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc3BlY2lmeSBmbG9hdCBwcmVjaXNpb24gaW4gZnJhZ21lbnQgc2hhZGVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLlBSRUNJU0lPTn1cbiAgICogQGRlZmF1bHQgUElYSS5QUkVDSVNJT04uTUVESVVNXG4gICAqL1xuICBQUkVDSVNJT05fRlJBR01FTlQ6ICdtZWRpdW1wJyxcblxuICAvKipcbiAgICogQ2FuIHdlIHVwbG9hZCB0aGUgc2FtZSBidWZmZXIgaW4gYSBzaW5nbGUgZnJhbWU/XG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQGNvbnN0YW50XG4gICAqIEBtZW1iZXJvZiBQSVhJXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUjogKDAsIF9jYW5VcGxvYWRTYW1lQnVmZmVyMi5kZWZhdWx0KSgpXG5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9zZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2wgPSB7XG4gICAgY3JlYXRlQ29udGV4dDogICAgICAgICAgcmVxdWlyZSgnLi9jcmVhdGVDb250ZXh0JyksXG4gICAgc2V0VmVydGV4QXR0cmliQXJyYXlzOiAgcmVxdWlyZSgnLi9zZXRWZXJ0ZXhBdHRyaWJBcnJheXMnKSxcbiAgICBHTEJ1ZmZlcjogICAgICAgICAgICAgICByZXF1aXJlKCcuL0dMQnVmZmVyJyksXG4gICAgR0xGcmFtZWJ1ZmZlcjogICAgICAgICAgcmVxdWlyZSgnLi9HTEZyYW1lYnVmZmVyJyksXG4gICAgR0xTaGFkZXI6ICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9HTFNoYWRlcicpLFxuICAgIEdMVGV4dHVyZTogICAgICAgICAgICAgIHJlcXVpcmUoJy4vR0xUZXh0dXJlJyksXG4gICAgVmVydGV4QXJyYXlPYmplY3Q6ICAgICAgcmVxdWlyZSgnLi9WZXJ0ZXhBcnJheU9iamVjdCcpLFxuICAgIHNoYWRlcjogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhZGVyJylcbn07XG5cbi8vIEV4cG9ydCBmb3IgTm9kZS1jb21wYXRpYmxlIGVudmlyb25tZW50c1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxue1xuICAgIC8vIEV4cG9ydCB0aGUgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbDtcbn1cblxuLy8gQWRkIHRvIHRoZSBicm93c2VyIHdpbmRvdyBwaXhpLmdsXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG57XG4gICAgLy8gYWRkIHRoZSB3aW5kb3cgb2JqZWN0XG4gICAgd2luZG93LlBJWEkgPSB3aW5kb3cuUElYSSB8fCB7fTtcbiAgICB3aW5kb3cuUElYSS5nbENvcmUgPSBnbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLWdsLWNvcmUvc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDA1LjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgSHR0cCBmcm9tICcuLi9odHRwL0h0dHAnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVc2VyU2VydmljZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmh0dHAgPSBuZXcgSHR0cCgpO1xyXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5odHRwLkJhc2VVcmw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VXNlcigpIHtcclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYCR7dGhpcy51cmx9L3VzZXIvZ2V0YDtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXF1ZXN0KGFkZHJlc3MsIG51bGwsICdHRVQnLCBudWxsKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UudXNlcik7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsb2dpbihib2R5KSB7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGAke3RoaXMudXJsfS91c2VyL2xvZ2luYDtcclxuICAgICAgICBsZXQgaGVhZGVycyA9IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nfTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXF1ZXN0KGFkZHJlc3MsIGhlYWRlcnMsICdQT1NUJywgYm9keSkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnVzZXIpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2lnbnVwKGJvZHkpIHtcclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYCR7dGhpcy51cmx9L3VzZXIvc2lnbnVwYDtcclxuICAgICAgICBsZXQgaGVhZGVycyA9IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nfTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXF1ZXN0KGFkZHJlc3MsIGhlYWRlcnMsICdQT1NUJywgYm9keSkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtyZXN1bHQ6ICdzdWNjZXNzJ30pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmKCFlKXtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe3Jlc3VsdDogJ25vLWNvbm4nfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7cmVzdWx0OiAnZXJyb3InfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldExlYWRlcnMoKSB7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGAke3RoaXMudXJsfS91c2VyL2xlYWRlcnNgO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlcXVlc3QoYWRkcmVzcywgbnVsbCwgJ0dFVCcsIG51bGwpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsb2dPdXRVc2VyKCkge1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBgJHt0aGlzLnVybH0vdXNlci9sb2dvdXRgO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlcXVlc3QoYWRkcmVzcywgbnVsbCwgJ0dFVCcsIG51bGwpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfY3JlYXRlUmVxdWVzdChhZGRyZXNzLCBoZWFkZXJzID0ge30sIHR5cGUgPSAnR0VUJywgYm9keSA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgaHR0cCA9IHRoaXMuaHR0cDtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBodHRwLnJlcXVlc3QoYWRkcmVzcywgaGVhZGVycywgdHlwZSwgYm9keSkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAnMjAwIE9LJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICByZWplY3Qoe30pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9zdXBwb3J0L3NlcnZpY2UvVXNlclNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAxNy4wMy4yMDE3LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVZpZXcge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JzQtdGC0L7QtCDQv9C+0LrQsNC30YvQstCw0LXRgiDQuNC70Lgg0L/RgNGP0YfQtdGCIFZpZXdcclxuICAgICAqL1xyXG4gICAgdG9nZ2xlVmlldygpIHtcclxuICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgnaGlkZGVuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveVZpZXcoKXtcclxuXHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy92aWV3cy9CYXNlVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhpc3RzIE9ubHkgY2hlY2sgaWYgdGhlcmUgYXJlIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtBcnJheXxCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQsIGV4aXN0cykge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgYXZhaWxhYmxlID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGV4aXN0cykgcmV0dXJuICEhYXZhaWxhYmxlO1xuICBpZiAoIWF2YWlsYWJsZSkgcmV0dXJuIFtdO1xuICBpZiAoYXZhaWxhYmxlLmZuKSByZXR1cm4gW2F2YWlsYWJsZS5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdmFpbGFibGUubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gYXZhaWxhYmxlW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCB0aGlzLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW3RoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcywgdHJ1ZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgdGhpcy5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIXRoaXMuX2V2ZW50c1tldnRdLmZuKSB0aGlzLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFt0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuXG4gICAgICAmJiAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpXG4gICAgICAmJiAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm5cbiAgICAgICAgfHwgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKVxuICAgICAgICB8fCAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBhcHBseSBhbnltb3JlLlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXZlbnRlbWl0dGVyMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAyNC4wMy4yMDE3LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyVXJsc3tcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgd2luZG93Lk1BSU4gPSAnLyc7XHJcbiAgICAgICAgd2luZG93LkxPR0lOID0gJy9sb2dpbic7XHJcbiAgICAgICAgd2luZG93LlNJR05VUCA9ICcvc2lnbnVwJztcclxuICAgICAgICB3aW5kb3cuTEVBREVSQk9BUkQgPSAnL2xlYWRlcmJvYXJkJztcclxuICAgICAgICB3aW5kb3cuQUJPVVQgPSAnL2Fib3V0JztcclxuICAgICAgICB3aW5kb3cuUFJPRklMRSA9ICcvcHJvZmlsZSc7XHJcblxyXG4gICAgICAgIHdpbmRvdy5TSU5HTEVQTEFZRVIgPSAnL3NnYW1lJztcclxuICAgICAgICB3aW5kb3cuTVVMVElQTEFZRVIgPSAnL21nYW1lJztcclxuICAgICAgICB3aW5kb3cuR0FNRVJFU1VMVCA9ICcvZ2FtZXJlc3VsdCc7XHJcblxyXG4gICAgICAgIHdpbmRvdy5TSU5HTEVQTEFZRVJfU1RSQVRFR1k9J1NJTkdMRVBMQVlFUlNUUkFURUdZJztcclxuICAgICAgICB3aW5kb3cuTVVMVElQTEFZRVJfU1RSQVRFR1k9J01VTFRJUExBWUVSU1RSQVRFR1knO1xyXG5cclxuICAgICAgICB3aW5kb3cuU1RBVEVXQUlUID0gJ1NUQVRFV0FJVCc7XHJcbiAgICAgICAgd2luZG93LlNUQVRFR0FNRSA9ICdTVEFURUdBTUUnO1xyXG4gICAgICAgIHdpbmRvdy5TVEFURVJFU1VMVCA9ICdTVEFURVJFU1VMVCc7XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9zdXBwb3J0L3JvdXRlci9Sb3V0ZXJVcmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgX0Rpc3BsYXlPYmplY3QyID0gcmVxdWlyZSgnLi9EaXNwbGF5T2JqZWN0Jyk7XG5cbnZhciBfRGlzcGxheU9iamVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwbGF5T2JqZWN0Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBBIENvbnRhaW5lciByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBkaXNwbGF5IG9iamVjdHMuXG4gKiBJdCBpcyB0aGUgYmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheSBvYmplY3RzIHRoYXQgYWN0IGFzIGEgY29udGFpbmVyIGZvciBvdGhlciBvYmplY3RzLlxuICpcbiAqYGBganNcbiAqIGxldCBjb250YWluZXIgPSBuZXcgUElYSS5Db250YWluZXIoKTtcbiAqIGNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuICogYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkRpc3BsYXlPYmplY3RcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBDb250YWluZXIgPSBmdW5jdGlvbiAoX0Rpc3BsYXlPYmplY3QpIHtcbiAgICBfaW5oZXJpdHMoQ29udGFpbmVyLCBfRGlzcGxheU9iamVjdCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRhaW5lcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0W119XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Rpc3BsYXlPYmplY3QuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGJ5IENvbnRhaW5lciBzdWJjbGFzc2VzIHdoZW5ldmVyIHRoZSBjaGlsZHJlbiBhcnJheSBpcyBtb2RpZmllZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5vbkNoaWxkcmVuQ2hhbmdlID0gZnVuY3Rpb24gb25DaGlsZHJlbkNoYW5nZSgpIHt9XG4gICAgLyogZW1wdHkgKi9cblxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBjaGlsZHJlbiB0byB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogTXVsdGlwbGUgaXRlbXMgY2FuIGJlIGFkZGVkIGxpa2Ugc286IGBteUNvbnRhaW5lci5hZGRDaGlsZCh0aGluZ09uZSwgdGhpbmdUd28sIHRoaW5nVGhyZWUpYFxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5QSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QocykgdG8gYWRkIHRvIHRoZSBjb250YWluZXJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAgICAgKi9cbiAgICA7XG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXNlZCBieSBKUyBydW50aW1lc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBoYXMgYSBwYXJlbnQgdGhlbiBsZXRzIHJlbW92ZSBpdCBhcyBQaXhpIG9iamVjdHMgY2FuIG9ubHkgZXhpc3QgaW4gb25lIHBsYWNlXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgICAgIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgICAgICAgLy8gZW5zdXJlIGJvdW5kcyB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcblxuICAgICAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgICAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjaGlsZC5lbWl0KCdhZGRlZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGNvbnRhaW5lciBhdCBhIHNwZWNpZmllZCBpbmRleC4gSWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBhZGRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdG8gcGxhY2UgdGhlIGNoaWxkIGluXG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNoaWxkICsgJ2FkZENoaWxkQXQ6IFRoZSBpbmRleCAnICsgaW5kZXggKyAnIHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJyArIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcblxuICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgICAgIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB0aGUgcG9zaXRpb24gb2YgMiBEaXNwbGF5IE9iamVjdHMgd2l0aGluIHRoaXMgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gRmlyc3QgZGlzcGxheSBvYmplY3QgdG8gc3dhcFxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZDIgLSBTZWNvbmQgZGlzcGxheSBvYmplY3QgdG8gc3dhcFxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLnN3YXBDaGlsZHJlbiA9IGZ1bmN0aW9uIHN3YXBDaGlsZHJlbihjaGlsZCwgY2hpbGQyKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gY2hpbGQyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpbmRleDJdID0gY2hpbGQ7XG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleDEgPCBpbmRleDIgPyBpbmRleDEgOiBpbmRleDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBwb3NpdGlvbiBvZiBhIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlIHRvIGlkZW50aWZ5XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0IHRvIGlkZW50aWZ5XG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIGdldENoaWxkSW5kZXgoY2hpbGQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdXBwbGllZCBEaXNwbGF5T2JqZWN0IG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgY2FsbGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBjaGlsZCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlIGZvciB3aGljaCB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGluZGV4IG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSByZXN1bHRpbmcgaW5kZXggbnVtYmVyIGZvciB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5zZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24gc2V0Q2hpbGRJbmRleChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3VwcGxpZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XG5cbiAgICAgICAgKDAsIF91dGlscy5yZW1vdmVJdGVtcykodGhpcy5jaGlsZHJlbiwgY3VycmVudEluZGV4LCAxKTsgLy8gcmVtb3ZlIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7IC8vIGFkZCBhdCBuZXcgcG9zaXRpb25cblxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBhdFxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgYW55LlxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldENoaWxkQXQgPSBmdW5jdGlvbiBnZXRDaGlsZEF0KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0Q2hpbGRBdDogSW5kZXggKCcgKyBpbmRleCArICcpIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uUElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBEaXNwbGF5T2JqZWN0KHMpIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBhcmd1bWVudCB3ZSBjYW4gYnlwYXNzIGxvb3BpbmcgdGhyb3VnaCB0aGUgdGhlbVxuICAgICAgICBpZiAoYXJndW1lbnRzTGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBhcmd1bWVudHMgcHJvcGVydHkgYW5kIGFkZCBhbGwgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHVzZSBpdCB0aGUgcmlnaHQgd2F5ICgubGVuZ3RoIGFuZCBbaV0pIHNvIHRoYXQgdGhpcyBmdW5jdGlvbiBjYW4gc3RpbGwgYmUgb3B0aW1pc2VkIGJ5IEpTIHJ1bnRpbWVzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICAgICAgICAoMCwgX3V0aWxzLnJlbW92ZUl0ZW1zKSh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcbiAgICAgICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgICAgICAgICBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXggcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBmcm9tXG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZEF0ID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaW5kZXgpO1xuXG4gICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWQuLlxuICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICAgICgwLCBfdXRpbHMucmVtb3ZlSXRlbXMpKHRoaXMuY2hpbGRyZW4sIGluZGV4LCAxKTtcblxuICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG5cbiAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgICAgICBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiZWdpbkluZGV4PTBdIC0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZEluZGV4PXRoaXMuY2hpbGRyZW4ubGVuZ3RoXSAtIFRoZSBlbmRpbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm5zIHtEaXNwbGF5T2JqZWN0W119IExpc3Qgb2YgcmVtb3ZlZCBjaGlsZHJlblxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oKSB7XG4gICAgICAgIHZhciBiZWdpbkluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgZW5kSW5kZXggPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIGJlZ2luID0gYmVnaW5JbmRleDtcbiAgICAgICAgdmFyIGVuZCA9IHR5cGVvZiBlbmRJbmRleCA9PT0gJ251bWJlcicgPyBlbmRJbmRleCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB2YXIgcmFuZ2UgPSBlbmQgLSBiZWdpbjtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHJhbmdlID4gMCAmJiByYW5nZSA8PSBlbmQpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0aGlzLmNoaWxkcmVuLnNwbGljZShiZWdpbiwgcmFuZ2UpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRbaV0udHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRbaV0udHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcblxuICAgICAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGJlZ2luSW5kZXgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmVtb3ZlZC5sZW5ndGg7ICsrX2kpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkW19pXS5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVtb3ZlQ2hpbGRyZW46IG51bWVyaWMgdmFsdWVzIGFyZSBvdXRzaWRlIHRoZSBhY2NlcHRhYmxlIHJhbmdlLicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gb24gYWxsIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyIGZvciByZW5kZXJpbmdcbiAgICAgKi9cblxuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSk7XG5cbiAgICAgICAgLy8gVE9ETzogY2hlY2sgcmVuZGVyIGZsYWdzLCBob3cgdG8gcHJvY2VzcyBzdHVmZiBoZXJlXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLmNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlQm91bmRzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQuY2FsY3VsYXRlQm91bmRzKCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbHRlcittYXNrLCBuZWVkIHRvIG1hc2sgYm90aCBzb21laG93XG4gICAgICAgICAgICBpZiAoY2hpbGQuX21hc2spIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fbWFzay5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzTWFzayhjaGlsZC5fYm91bmRzLCBjaGlsZC5fbWFzay5fYm91bmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQuZmlsdGVyQXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNBcmVhKGNoaWxkLl9ib3VuZHMsIGNoaWxkLmZpbHRlckFyZWEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzKGNoaWxkLl9ib3VuZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdEJvdW5kc0lEID0gdGhpcy5fYm91bmRzSUQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QuIE92ZXJyaWRlIHRoaXMgdG9cbiAgICAgKiBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGUgc3BlY2lmaWMgb2JqZWN0IChub3QgaW5jbHVkaW5nIGNoaWxkcmVuKS5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBDb250YWluZXIucHJvdG90eXBlLl9jYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiBfY2FsY3VsYXRlQm91bmRzKCkge31cbiAgICAvLyBGSUxMIElOLy9cblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgO1xuXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIHJlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gYSBxdWljayBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBhIG1hc2sgb3IgYSBmaWx0ZXIuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrIHx8IHRoaXMuX2ZpbHRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQWR2YW5jZWRXZWJHTChyZW5kZXJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJXZWJHTChyZW5kZXJlcik7XG5cbiAgICAgICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXJXZWJHTChyZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyIGFuZCBhZHZhbmNlZCBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyQWR2YW5jZWRXZWJHTCA9IGZ1bmN0aW9uIHJlbmRlckFkdmFuY2VkV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIuZmx1c2goKTtcblxuICAgICAgICB2YXIgZmlsdGVycyA9IHRoaXMuX2ZpbHRlcnM7XG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5fbWFzaztcblxuICAgICAgICAvLyBwdXNoIGZpbHRlciBmaXJzdCBhcyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgc3RlbmNpbCBidWZmZXIgaXMgY29ycmVjdCBmb3IgYW55IG1hc2tpbmdcbiAgICAgICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZW5hYmxlZEZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyc1tpXS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLnB1c2goZmlsdGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVyKHRoaXMsIHRoaXMuX2VuYWJsZWRGaWx0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICByZW5kZXJlci5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLCB0aGlzLl9tYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGlzIG9iamVjdCB0byB0aGUgYmF0Y2gsIG9ubHkgcmVuZGVyZWQgaWYgaXQgaGFzIGEgdGV4dHVyZS5cbiAgICAgICAgdGhpcy5fcmVuZGVyV2ViR0wocmVuZGVyZXIpO1xuXG4gICAgICAgIC8vIG5vdyBsb29wIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCBtYWtlIHN1cmUgdGhleSBnZXQgcmVuZGVyZWRcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBfaTIgPCBqOyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltfaTJdLnJlbmRlcldlYkdMKHJlbmRlcmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmZsdXNoKCk7XG5cbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnBvcE1hc2sodGhpcywgdGhpcy5fbWFzayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVG8gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3ViY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gX3JlbmRlcldlYkdMKHJlbmRlcmVyKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge31cbiAgICAvLyB0aGlzIGlzIHdoZXJlIGNvbnRlbnQgaXRzZWxmIGdldHMgcmVuZGVyZWQuLi5cblxuXG4gICAgLyoqXG4gICAgICogVG8gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3ViY2xhc3NcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIDtcblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB7fVxuICAgIC8vIHRoaXMgaXMgd2hlcmUgY29udGVudCBpdHNlbGYgZ2V0cyByZW5kZXJlZC4uLlxuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIDtcblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIGlmIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpc1xuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5fbWFzayk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlckNhbnZhcyhyZW5kZXJlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaW50ZXJuYWwgcmVmZXJlbmNlcyBhbmQgbGlzdGVuZXJzIGFzIHdlbGwgYXMgcmVtb3ZlcyBjaGlsZHJlbiBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuXG4gICAgICogRG8gbm90IHVzZSBhIENvbnRhaW5lciBhZnRlciBjYWxsaW5nIGBkZXN0cm95YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICovXG5cblxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBfRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBkZXN0cm95Q2hpbGRyZW4gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMgJiYgb3B0aW9ucy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgb2xkQ2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcblxuICAgICAgICBpZiAoZGVzdHJveUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgb2xkQ2hpbGRyZW5baV0uZGVzdHJveShvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbnRhaW5lciwgW3tcbiAgICAgICAga2V5OiAnd2lkdGgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAod2lkdGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnggPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGVpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb250YWluZXI7XG59KF9EaXNwbGF5T2JqZWN0My5kZWZhdWx0KTtcblxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbnRhaW5lcjtcbkNvbnRhaW5lci5wcm90b3R5cGUuY29udGFpbmVyVXBkYXRlVHJhbnNmb3JtID0gQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvZGlzcGxheS9Db250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TeXN0ZW1SZW5kZXJlcjIgPSByZXF1aXJlKCcuLi9TeXN0ZW1SZW5kZXJlcicpO1xuXG52YXIgX1N5c3RlbVJlbmRlcmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N5c3RlbVJlbmRlcmVyMik7XG5cbnZhciBfQ2FudmFzTWFza01hbmFnZXIgPSByZXF1aXJlKCcuL3V0aWxzL0NhbnZhc01hc2tNYW5hZ2VyJyk7XG5cbnZhciBfQ2FudmFzTWFza01hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzTWFza01hbmFnZXIpO1xuXG52YXIgX0NhbnZhc1JlbmRlclRhcmdldCA9IHJlcXVpcmUoJy4vdXRpbHMvQ2FudmFzUmVuZGVyVGFyZ2V0Jyk7XG5cbnZhciBfQ2FudmFzUmVuZGVyVGFyZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1JlbmRlclRhcmdldCk7XG5cbnZhciBfbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aSA9IHJlcXVpcmUoJy4vdXRpbHMvbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aScpO1xuXG52YXIgX21hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxudmFyIF9zZXR0aW5ncyA9IHJlcXVpcmUoJy4uLy4uL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhlIENhbnZhc1JlbmRlcmVyIGRyYXdzIHRoZSBzY2VuZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSAyZCBjYW52YXMuIFRoaXMgcmVuZGVyZXIgc2hvdWxkXG4gKiBiZSB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IFdlYkdMLiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSBDYW52YXNSZW5kZXJlci52aWV3IHRvXG4gKiB5b3VyIERPTSBvciB5b3Ugd2lsbCBub3Qgc2VlIGFueXRoaW5nIDopXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5TeXN0ZW1SZW5kZXJlclxuICovXG52YXIgQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoX1N5c3RlbVJlbmRlcmVyKSB7XG4gICAgX2luaGVyaXRzKENhbnZhc1JlbmRlcmVyLCBfU3lzdGVtUmVuZGVyZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY3JlZW5XaWR0aD04MDBdIC0gdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjcmVlbkhlaWdodD02MDBdIC0gdGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW29wdGlvbnMudmlld10gLSB0aGUgY2FudmFzIHRvIHVzZSBhcyBhIHZpZXcsIG9wdGlvbmFsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFuc3BhcmVudD1mYWxzZV0gLSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYW50aWFsaWFzPWZhbHNlXSAtIHNldHMgYW50aWFsaWFzIChvbmx5IGFwcGxpY2FibGUgaW4gY2hyb21lIGF0IHRoZSBtb21lbnQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuIFRoZVxuICAgICAqICByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIC0gVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3JcbiAgICAgKiAgICAgIG5vdCBiZWZvcmUgdGhlIG5ldyByZW5kZXIgcGFzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXSAtIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSByZW5kZXJlZCBhcmVhXG4gICAgICogIChzaG93biBpZiBub3QgdHJhbnNwYXJlbnQpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmRQaXhlbHM9ZmFsc2VdIC0gSWYgdHJ1ZSBQaXhpIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsXG4gICAgICogIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3lzdGVtUmVuZGVyZXIuY2FsbCh0aGlzLCAnQ2FudmFzJywgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCwgb3B0aW9ucykpO1xuXG4gICAgICAgIF90aGlzLnR5cGUgPSBfY29uc3QuUkVOREVSRVJfVFlQRS5DQU5WQVM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucm9vdENvbnRleHQgPSBfdGhpcy52aWV3LmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogX3RoaXMudHJhbnNwYXJlbnQgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvb2xlYW4gZmxhZyBjb250cm9sbGluZyBjYW52YXMgcmVmcmVzaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJlZnJlc2ggPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW5jZSBvZiBhIENhbnZhc01hc2tNYW5hZ2VyLCBoYW5kbGVzIG1hc2tpbmcgd2hlbiB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkNhbnZhc01hc2tNYW5hZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubWFza01hbmFnZXIgPSBuZXcgX0NhbnZhc01hc2tNYW5hZ2VyMi5kZWZhdWx0KF90aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbnZhcyBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgY2FudmFzIHNtb290aGluZyBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc21vb3RoUHJvcGVydHkgPSAnaW1hZ2VTbW9vdGhpbmdFbmFibGVkJztcblxuICAgICAgICBpZiAoIV90aGlzLnJvb3RDb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnJvb3RDb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNtb290aFByb3BlcnR5ID0gJ3dlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLnJvb3RDb250ZXh0Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNtb290aFByb3BlcnR5ID0gJ21vekltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLnJvb3RDb250ZXh0Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdvSW1hZ2VTbW9vdGhpbmdFbmFibGVkJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucm9vdENvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5pbml0UGx1Z2lucygpO1xuXG4gICAgICAgIF90aGlzLmJsZW5kTW9kZXMgPSAoMCwgX21hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGkyLmRlZmF1bHQpKCk7XG4gICAgICAgIF90aGlzLl9hY3RpdmVCbGVuZE1vZGUgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLnJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byB0aGlzIGNhbnZhcyB2aWV3XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIFRoZSBvYmplY3QgdG8gYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gW3JlbmRlclRleHR1cmVdIC0gQSByZW5kZXIgdGV4dHVyZSB0byBiZSByZW5kZXJlZCB0by5cbiAgICAgKiAgSWYgdW5zZXQsIGl0IHdpbGwgcmVuZGVyIHRvIHRoZSByb290IGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2xlYXI9ZmFsc2VdIC0gV2hldGhlciB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gW3RyYW5zZm9ybV0gLSBBIHRyYW5zZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwVXBkYXRlVHJhbnNmb3JtPWZhbHNlXSAtIFdoZXRoZXIgdG8gc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybVxuICAgICAqL1xuXG5cbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGRpc3BsYXlPYmplY3QsIHJlbmRlclRleHR1cmUsIGNsZWFyLCB0cmFuc2Zvcm0sIHNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbiBiZSBoYW5keSB0byBrbm93IVxuICAgICAgICB0aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gIXJlbmRlclRleHR1cmU7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwcmVyZW5kZXInKTtcblxuICAgICAgICB2YXIgcm9vdFJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG5cbiAgICAgICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHJlbmRlclRleHR1cmU7XG5cbiAgICAgICAgICAgIGlmICghcmVuZGVyVGV4dHVyZS5fY2FudmFzUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5fY2FudmFzUmVuZGVyVGFyZ2V0ID0gbmV3IF9DYW52YXNSZW5kZXJUYXJnZXQyLmRlZmF1bHQocmVuZGVyVGV4dHVyZS53aWR0aCwgcmVuZGVyVGV4dHVyZS5oZWlnaHQsIHJlbmRlclRleHR1cmUucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5zb3VyY2UgPSByZW5kZXJUZXh0dXJlLl9jYW52YXNSZW5kZXJUYXJnZXQuY2FudmFzO1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUudmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSByZW5kZXJUZXh0dXJlLl9jYW52YXNSZW5kZXJUYXJnZXQuY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlbmRlclRleHR1cmUuX2NhbnZhc1JlbmRlclRhcmdldC5yZXNvbHV0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5yb290Q29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgIGlmICghcmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gZGlzcGxheU9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBzY2VuZSBncmFwaFxuICAgICAgICAgICAgdmFyIGNhY2hlUGFyZW50ID0gZGlzcGxheU9iamVjdC5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgdGVtcFd0ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLmNvcHkodGVtcFd0KTtcblxuICAgICAgICAgICAgICAgIC8vIGxldHMgbm90IGZvcmdldCB0byBmbGFnIHRoZSBwYXJlbnQgdHJhbnNmb3JtIGFzIGRpcnR5Li4uXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtLl93b3JsZElEID0gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBXdC5pZGVudGl0eSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5wYXJlbnQgPSBjYWNoZVBhcmVudDtcbiAgICAgICAgICAgIC8vIGRpc3BsYXlPYmplY3QuaGl0QXJlYSA9IC8vVE9ETyBhZGQgYSB0ZW1wIGhpdCBhcmVhXG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5ibGVuZE1vZGVzW19jb25zdC5CTEVORF9NT0RFUy5OT1JNQUxdO1xuXG4gICAgICAgIGlmIChuYXZpZ2F0b3IuaXNDb2Nvb25KUyAmJiB0aGlzLnZpZXcuc2NyZWVuY2FudmFzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYXIgIT09IHVuZGVmaW5lZCA/IGNsZWFyIDogdGhpcy5jbGVhckJlZm9yZVJlbmRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyaW5nVG9TY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYmFja2dyb3VuZCBmb3IgQ2FudmFzUmVuZGVyVGFyZ2V0IG9yIFJlbmRlclRleHR1cmU/XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIFJFTkRFUiBUQVJHRVQgU1RVRkYgSEVSRS4uXG4gICAgICAgIHZhciB0ZW1wQ29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlckNhbnZhcyh0aGlzKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGVtcENvbnRleHQ7XG5cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcm9vdFJlc29sdXRpb247XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0cmVuZGVyJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYW52YXMgb2YgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NsZWFyQ29sb3JdIC0gQ2xlYXIgdGhlIGNhbnZhcyB3aXRoIHRoaXMgY29sb3IsIGV4Y2VwdCB0aGUgY2FudmFzIGlzIHRyYW5zcGFyZW50LlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihjbGVhckNvbG9yKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgIGNsZWFyQ29sb3IgPSBjbGVhckNvbG9yIHx8IHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZztcblxuICAgICAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnQgJiYgY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjbGVhckNvbG9yO1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYmxlbmQgbW9kZSBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxlbmRNb2RlIC0gU2VlIHtAbGluayBQSVhJLkJMRU5EX01PREVTfSBmb3IgdmFsaWQgdmFsdWVzLlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24gc2V0QmxlbmRNb2RlKGJsZW5kTW9kZSkge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlQmxlbmRNb2RlID09PSBibGVuZE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FjdGl2ZUJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuYmxlbmRNb2Rlc1tibGVuZE1vZGVdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlcyB0aGUgQ2FudmFzIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gLSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAgICovXG5cblxuICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShyZW1vdmVWaWV3KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpbnMoKTtcblxuICAgICAgICAvLyBjYWxsIHRoZSBiYXNlIGRlc3Ryb3lcbiAgICAgICAgX1N5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgcmVtb3ZlVmlldyk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNtb290aFByb3BlcnR5ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgY2FudmFzIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQGV4dGVuZHMgUElYSS5TeXN0ZW1SZW5kZXJlciNyZXNpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5XaWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5IZWlnaHQgLSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgc2NyZWVuXG4gICAgICovXG5cblxuICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xuICAgICAgICBfU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBzY2FsZSBtb2RlLi4gb2RkbHkgdGhpcyBzZWVtcyB0byBiZSByZXNldCB3aGVuIHRoZSBjYW52YXMgaXMgcmVzaXplZC5cbiAgICAgICAgLy8gc3VyZWx5IGEgYnJvd3NlciBidWc/PyBMZXQgcGl4aSBmaXggdGhhdCBmb3IgeW91Li5cbiAgICAgICAgaWYgKHRoaXMuc21vb3RoUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdENvbnRleHRbdGhpcy5zbW9vdGhQcm9wZXJ0eV0gPSBfc2V0dGluZ3MyLmRlZmF1bHQuU0NBTEVfTU9ERSA9PT0gX2NvbnN0LlNDQUxFX01PREVTLkxJTkVBUjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ2FudmFzUmVuZGVyZXI7XG59KF9TeXN0ZW1SZW5kZXJlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc1JlbmRlcmVyO1xuXG5cbl91dGlscy5wbHVnaW5UYXJnZXQubWl4aW4oQ2FudmFzUmVuZGVyZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzUmVuZGVyZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFdlYkdMTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgKi9cbiAgZnVuY3Rpb24gV2ViR0xNYW5hZ2VyKHJlbmRlcmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMTWFuYWdlcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuV2ViR0xSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICB0aGlzLnJlbmRlcmVyLm9uKCdjb250ZXh0JywgdGhpcy5vbkNvbnRleHRDaGFuZ2UsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgbWV0aG9kIGNhbGxlZCB3aGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2UuXG4gICAqXG4gICAqL1xuXG5cbiAgV2ViR0xNYW5hZ2VyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbiBvbkNvbnRleHRDaGFuZ2UoKSB7fVxuICAvLyBkbyBzb21lIGNvZGVzIGluaXQhXG5cblxuICAvKipcbiAgICogR2VuZXJpYyBkZXN0cm95IG1ldGhvZHMgdG8gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3ViY2xhc3NcbiAgICpcbiAgICovXG4gIDtcblxuICBXZWJHTE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIub2ZmKCdjb250ZXh0JywgdGhpcy5vbkNvbnRleHRDaGFuZ2UsIHRoaXMpO1xuXG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFdlYkdMTWFuYWdlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV2ViR0xNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViR0xNYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9XZWJHTE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50ZW1pdHRlcik7XG5cbnZhciBfZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4gPSByZXF1aXJlKCcuLi91dGlscy9kZXRlcm1pbmVDcm9zc09yaWdpbicpO1xuXG52YXIgX2RldGVybWluZUNyb3NzT3JpZ2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RldGVybWluZUNyb3NzT3JpZ2luKTtcblxudmFyIF9iaXRUd2lkZGxlID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKTtcblxudmFyIF9iaXRUd2lkZGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpdFR3aWRkbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQSB0ZXh0dXJlIHN0b3JlcyB0aGUgaW5mb3JtYXRpb24gdGhhdCByZXByZXNlbnRzIGFuIGltYWdlLiBBbGwgdGV4dHVyZXMgaGF2ZSBhIGJhc2UgdGV4dHVyZS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIEJhc2VUZXh0dXJlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoQmFzZVRleHR1cmUsIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBbc291cmNlXSAtIHRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJhc2VUZXh0dXJlKHNvdXJjZSwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVGV4dHVyZSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy51aWQgPSAoMCwgX3V0aWxzLnVpZCkoKTtcblxuICAgICAgICBfdGhpcy50b3VjaGVkID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHRleHR1cmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBfc2V0dGluZ3MyLmRlZmF1bHQuUkVTT0xVVElPTjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLndpZHRoID0gMTAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmhlaWdodCA9IDEwMDtcblxuICAgICAgICAvLyBUT0RPIGRvY3NcbiAgICAgICAgLy8gdXNlZCB0byBzdG9yZSB0aGUgYWN0dWFsIGRpbWVuc2lvbnMgb2YgdGhlIHNvdXJjZVxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBzdG9yZSB0aGUgYWN0dWFsIHdpZHRoIG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yZWFsV2lkdGggPSAxMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHN0b3JlIHRoZSBhY3R1YWwgaGVpZ2h0IG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yZWFsSGVpZ2h0ID0gMTAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXG4gICAgICAgICAqIEBzZWUgUElYSS5TQ0FMRV9NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlICE9PSB1bmRlZmluZWQgPyBzY2FsZU1vZGUgOiBfc2V0dGluZ3MyLmRlZmF1bHQuU0NBTEVfTU9ERTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIHRydWUgb25jZSB0aGUgYmFzZSB0ZXh0dXJlIGhhcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIG5ldmVyIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgc291cmNlIGZhaWxzIHRvIGxvYWQgb3IgaGFzIG5vIHRleHR1cmUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIHRydWUgaWYgdGhlIHNvdXJjZSBpcyBjdXJyZW50bHkgbG9hZGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYW4gSW1hZ2Ugc291cmNlIGlzIGxvYWRpbmcgdGhlICdsb2FkZWQnIG9yICdlcnJvcicgZXZlbnQgd2lsbCBiZVxuICAgICAgICAgKiBkaXNwYXRjaGVkIHdoZW4gdGhlIG9wZXJhdGlvbiBlbmRzLiBBbiB1bmRlcnlsaW5nIHNvdXJjZSB0aGF0IGlzXG4gICAgICAgICAqIGltbWVkaWF0ZWx5LWF2YWlsYWJsZSBieXBhc3NlcyBsb2FkaW5nIGVudGlyZWx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW1hZ2Ugc291cmNlIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRleHR1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IE1ha2UgdGhpcyBhIHNldHRlciB0aGF0IGNhbGxzIGxvYWRTb3VyY2UoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBudWxsOyAvLyBzZXQgaW4gbG9hZFNvdXJjZSwgaWYgYXQgYWxsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbWFnZSBzb3VyY2UgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZS4gVGhpcyBpcyB1c2VkIHRvXG4gICAgICAgICAqIHN0b3JlIHRoZSBvcmlnaW5hbCBTdmcgc291cmNlIHdoZW4gaXQgaXMgcmVwbGFjZWQgd2l0aCBhIGNhbnZhcyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBDdXJyZW50bHkgbm90IGluIHVzZSBidXQgY291bGQgYmUgdXNlZCB3aGVuIHJlLXNjYWxpbmcgc3ZnLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7SW1hZ2V9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vcmlnU291cmNlID0gbnVsbDsgLy8gc2V0IGluIGxvYWRTdmcsIGlmIGF0IGFsbFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlIG9mIGltYWdlIGRlZmluZWQgaW4gc291cmNlLCBlZy4gYHBuZ2Agb3IgYHN2Z2BcbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmltYWdlVHlwZSA9IG51bGw7IC8vIHNldCBpbiB1cGRhdGVJbWFnZVR5cGVcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGUgZm9yIHNvdXJjZSBpbWFnZS4gVXNlZCB3aXRoIFN2ZyBpbWFnZXMgdG8gc2NhbGUgdGhlbSBiZWZvcmUgcmFzdGVyaXphdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnNvdXJjZVNjYWxlID0gMS4wO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBpZiBSR0IgY2hhbm5lbHMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIGJ5IEFscGhhICAoV2ViR0wgb25seSlcbiAgICAgICAgICogQWxsIGJsZW5kIG1vZGVzLCBhbmQgc2hhZGVycyB3cml0dGVuIGZvciBkZWZhdWx0IHZhbHVlLiBDaGFuZ2UgaXQgb24geW91ciBvd24gcmlzay5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucHJlbXVsdGlwbGllZEFscGhhID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pbWFnZVVybCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0ZXh0dXJlIGlzIGEgcG93ZXIgb2YgdHdvLCB0cnkgdG8gdXNlIHBvd2VyIG9mIHR3byB0ZXh0dXJlcyBhcyBtdWNoXG4gICAgICAgICAqIGFzIHlvdSBjYW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlzUG93ZXJPZlR3byA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHVzZWQgZm9yIHdlYkdMXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgYSBtaXBtYXAgb2YgdGhpcyB0ZXh0dXJlIG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4gVGhpcyB2YWx1ZSBuZWVkc1xuICAgICAgICAgKiB0byBiZSBzZXQgYmVmb3JlIHRoZSB0ZXh0dXJlIGlzIHVzZWRcbiAgICAgICAgICogQWxzbyB0aGUgdGV4dHVyZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIHNpemUgdG8gd29ya1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAc2VlIFBJWEkuTUlQTUFQX1RFWFRVUkVTXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5taXBtYXAgPSBfc2V0dGluZ3MyLmRlZmF1bHQuTUlQTUFQX1RFWFRVUkVTO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBXZWJHTCBUZXh0dXJlIHdyYXAgbW9kZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBzZWUgUElYSS5XUkFQX01PREVTXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy53cmFwTW9kZSA9IF9zZXR0aW5nczIuZGVmYXVsdC5XUkFQX01PREU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHJlbmRlcmVyIElEcyB0byB3ZWJnbCB0ZXh0dXJlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBXZWJHTFRleHR1cmU+fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2dsVGV4dHVyZXMgPSB7fTtcblxuICAgICAgICBfdGhpcy5fZW5hYmxlZCA9IDA7XG4gICAgICAgIF90aGlzLl92aXJ0YWxCb3VuZElkID0gLTE7XG5cbiAgICAgICAgLy8gaWYgbm8gc291cmNlIHBhc3NlZCBkb24ndCB0cnkgdG8gbG9hZFxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2FkU291cmNlKHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQgdmlhIGRlc3Ryb3koKS4gSWYgdHJ1ZSwgaXQgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZpbmlzaGVzIGxvYWRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGV2ZW50IGxvYWRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5CYXNlVGV4dHVyZSNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBub3QtaW1tZWRpYXRlbHktYXZhaWxhYmxlIHNvdXJjZSBmYWlscyB0byBsb2FkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBldmVudCBlcnJvclxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5CYXNlVGV4dHVyZSNcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0ZXh0dXJlIG9uIGFsbCB0aGUgd2ViZ2wgcmVuZGVyZXJzLCB0aGlzIGFsc28gYXNzdW1lcyB0aGUgc3JjIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQGZpcmVzIHVwZGF0ZVxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAvLyBTdmcgc2l6ZSBpcyBoYW5kbGVkIGR1cmluZyBsb2FkXG4gICAgICAgIGlmICh0aGlzLmltYWdlVHlwZSAhPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbFdpZHRoID0gdGhpcy5zb3VyY2UubmF0dXJhbFdpZHRoIHx8IHRoaXMuc291cmNlLnZpZGVvV2lkdGggfHwgdGhpcy5zb3VyY2Uud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnJlYWxIZWlnaHQgPSB0aGlzLnNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHRoaXMuc291cmNlLnZpZGVvSGVpZ2h0IHx8IHRoaXMuc291cmNlLmhlaWdodDtcblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRpbWVuc2lvbnMgZnJvbSByZWFsIHZhbHVlc1xuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUuX3VwZGF0ZURpbWVuc2lvbnMgPSBmdW5jdGlvbiBfdXBkYXRlRGltZW5zaW9ucygpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmVhbFdpZHRoIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMucmVhbEhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcblxuICAgICAgICB0aGlzLmlzUG93ZXJPZlR3byA9IF9iaXRUd2lkZGxlMi5kZWZhdWx0LmlzUG93Mih0aGlzLnJlYWxXaWR0aCkgJiYgX2JpdFR3aWRkbGUyLmRlZmF1bHQuaXNQb3cyKHRoaXMucmVhbEhlaWdodCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc291cmNlIGlzIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUsIHN1Y2ggYXMgYW4gaW1hZ2UgdGhhdCBuZWVkcyB0byBiZVxuICAgICAqIGRvd25sb2FkZWQsIHRoZW4gdGhlICdsb2FkZWQnIG9yICdlcnJvcicgZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIGluIHRoZSBmdXR1cmVcbiAgICAgKiBhbmQgYGhhc0xvYWRlZGAgd2lsbCByZW1haW4gZmFsc2UgYWZ0ZXIgdGhpcyBjYWxsLlxuICAgICAqXG4gICAgICogVGhlIGxvZ2ljIHN0YXRlIGFmdGVyIGNhbGxpbmcgYGxvYWRTb3VyY2VgIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgKGVnLiBgZnJvbUltYWdlYCwgYG5ldyBCYXNlVGV4dHVyZWApIGlzOlxuICAgICAqXG4gICAgICogICAgIGlmICh0ZXh0dXJlLmhhc0xvYWRlZCkge1xuICAgICAqICAgICAgICAvLyB0ZXh0dXJlIHJlYWR5IGZvciB1c2VcbiAgICAgKiAgICAgfSBlbHNlIGlmICh0ZXh0dXJlLmlzTG9hZGluZykge1xuICAgICAqICAgICAgICAvLyBsaXN0ZW4gdG8gJ2xvYWRlZCcgYW5kL29yICdlcnJvcicgZXZlbnRzIG9uIHRleHR1cmVcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgLy8gbm90IGxvYWRpbmcsIG5vdCBnb2luZyB0byBsb2FkIFVOTEVTUyB0aGUgc291cmNlIGlzIHJlbG9hZGVkXG4gICAgICogICAgICAgIC8vIChpdCBtYXkgc3RpbGwgbWFrZSBzZW5zZSB0byBsaXN0ZW4gdG8gdGhlIGV2ZW50cylcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlIC0gdGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIHRleHR1cmUuXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnByb3RvdHlwZS5sb2FkU291cmNlID0gZnVuY3Rpb24gbG9hZFNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgdmFyIHdhc0xvYWRpbmcgPSB0aGlzLmlzTG9hZGluZztcblxuICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh3YXNMb2FkaW5nICYmIHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uub25lcnJvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3RTb3VyY2VMb2FkZWQgPSAhdGhpcy5zb3VyY2U7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAgICAgLy8gQXBwbHkgc291cmNlIGlmIGxvYWRlZC4gT3RoZXJ3aXNlIHNldHVwIGFwcHJvcHJpYXRlIGxvYWRpbmcgbW9uaXRvcnMuXG4gICAgICAgIGlmICgoc291cmNlLnNyYyAmJiBzb3VyY2UuY29tcGxldGUgfHwgc291cmNlLmdldENvbnRleHQpICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVJbWFnZVR5cGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2VUeXBlID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRTdmdTb3VyY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTG9hZGVkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdFNvdXJjZUxvYWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHNlbmQgbG9hZGVkIGV2ZW50IGlmIHByZXZpb3VzIHNvdXJjZSB3YXMgbnVsbCBhbmQgd2UgaGF2ZSBiZWVuIHBhc3NlZCBhIHByZS1sb2FkZWQgSU1HIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFzb3VyY2UuZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgLy8gSW1hZ2UgZmFpbCAvIG5vdCByZWFkeVxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNjb3BlLl91cGRhdGVJbWFnZVR5cGUoKTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25lcnJvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLmlzTG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NvcGUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2NvcGUuX3NvdXJjZUxvYWRlZCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLmltYWdlVHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuX2xvYWRTdmdTb3VyY2UoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NvcGUuZW1pdCgnbG9hZGVkJywgc2NvcGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNjb3BlLmVtaXQoJ2Vycm9yJywgc2NvcGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUGVyIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI3RoZS1pbWctZWxlbWVudFxuICAgICAgICAgICAgLy8gICBcIlRoZSB2YWx1ZSBvZiBgY29tcGxldGVgIGNhbiB0aHVzIGNoYW5nZSB3aGlsZSBhIHNjcmlwdCBpcyBleGVjdXRpbmcuXCJcbiAgICAgICAgICAgIC8vIFNvIGNvbXBsZXRlIG5lZWRzIHRvIGJlIHJlLWNoZWNrZWQgYWZ0ZXIgdGhlIGNhbGxiYWNrcyBoYXZlIGJlZW4gYWRkZWQuLlxuICAgICAgICAgICAgLy8gTk9URTogY29tcGxldGUgd2lsbCBiZSB0cnVlIGlmIHRoZSBpbWFnZSBoYXMgbm8gc3JjIHNvIGJlc3QgdG8gY2hlY2sgaWYgdGhlIHNyYyBpcyBzZXQuXG4gICAgICAgICAgICBpZiAoc291cmNlLmNvbXBsZXRlICYmIHNvdXJjZS5zcmMpIHtcbiAgICAgICAgICAgICAgICAvLyAuLmFuZCBpZiB3ZSdyZSBjb21wbGV0ZSBub3csIG5vIG5lZWQgZm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5pbWFnZVR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLl9sb2FkU3ZnU291cmNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLndpZHRoICYmIHNvdXJjZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTG9hZGVkKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW55IHByZXZpb3VzIHN1YnNjcmliZXJzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGFueSBwcmV2aW91cyBzdWJzY3JpYmVycyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdHlwZSBvZiB0aGUgc291cmNlIGltYWdlLlxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUuX3VwZGF0ZUltYWdlVHlwZSA9IGZ1bmN0aW9uIF91cGRhdGVJbWFnZVR5cGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbWFnZVVybCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFVcmkgPSAoMCwgX3V0aWxzLmRlY29tcG9zZURhdGFVcmkpKHRoaXMuaW1hZ2VVcmwpO1xuICAgICAgICB2YXIgaW1hZ2VUeXBlID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChkYXRhVXJpICYmIGRhdGFVcmkubWVkaWFUeXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igc3ViVHlwZSB2YWxpZGl0eVxuICAgICAgICAgICAgdmFyIGZpcnN0U3ViVHlwZSA9IGRhdGFVcmkuc3ViVHlwZS5zcGxpdCgnKycpWzBdO1xuXG4gICAgICAgICAgICBpbWFnZVR5cGUgPSAoMCwgX3V0aWxzLmdldFVybEZpbGVFeHRlbnNpb24pKCcuJyArIGZpcnN0U3ViVHlwZSk7XG5cbiAgICAgICAgICAgIGlmICghaW1hZ2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGltYWdlIHR5cGUgaW4gZGF0YSBVUkkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWFnZVR5cGUgPSAoMCwgX3V0aWxzLmdldFVybEZpbGVFeHRlbnNpb24pKHRoaXMuaW1hZ2VVcmwpO1xuXG4gICAgICAgICAgICBpZiAoIWltYWdlVHlwZSkge1xuICAgICAgICAgICAgICAgIGltYWdlVHlwZSA9ICdwbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWFnZVR5cGUgPSBpbWFnZVR5cGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc291cmNlYCBpcyBhbiBTVkcgaW1hZ2UgYW5kIHdoZXRoZXIgaXQncyBsb2FkZWQgdmlhIGEgVVJMIG9yIGEgZGF0YSBVUkkuIFRoZW4gY2FsbHNcbiAgICAgKiBgX2xvYWRTdmdTb3VyY2VVc2luZ0RhdGFVcmlgIG9yIGBfbG9hZFN2Z1NvdXJjZVVzaW5nWGhyYC5cbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLl9sb2FkU3ZnU291cmNlID0gZnVuY3Rpb24gX2xvYWRTdmdTb3VyY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlVHlwZSAhPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgc291cmNlIGlzIG5vdCBzdmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhVXJpID0gKDAsIF91dGlscy5kZWNvbXBvc2VEYXRhVXJpKSh0aGlzLmltYWdlVXJsKTtcblxuICAgICAgICBpZiAoZGF0YVVyaSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZFN2Z1NvdXJjZVVzaW5nRGF0YVVyaShkYXRhVXJpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhbiBVUkwsIHNvIHdlIG5lZWQgdG8gZG8gYW4gWEhSIHRvIGNoZWNrIHRoZSBzdmcgc2l6ZVxuICAgICAgICAgICAgdGhpcy5fbG9hZFN2Z1NvdXJjZVVzaW5nWGhyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gU1ZHIHN0cmluZyBmcm9tIGRhdGEgVVJJIGFuZCB0aGVuIGNhbGxzIGBfbG9hZFN2Z1NvdXJjZVVzaW5nU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJpIC0gVGhlIGRhdGEgdXJpIHRvIGxvYWQgZnJvbS5cbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLl9sb2FkU3ZnU291cmNlVXNpbmdEYXRhVXJpID0gZnVuY3Rpb24gX2xvYWRTdmdTb3VyY2VVc2luZ0RhdGFVcmkoZGF0YVVyaSkge1xuICAgICAgICB2YXIgc3ZnU3RyaW5nID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChkYXRhVXJpLmVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgaWYgKCFhdG9iKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgYmFzZTY0IGNvbnZlcnNpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ZnU3RyaW5nID0gYXRvYihkYXRhVXJpLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ZnU3RyaW5nID0gZGF0YVVyaS5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9hZFN2Z1NvdXJjZVVzaW5nU3RyaW5nKHN2Z1N0cmluZyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFuIFNWRyBzdHJpbmcgZnJvbSBgaW1hZ2VVcmxgIHVzaW5nIFhIUiBhbmQgdGhlbiBjYWxscyBgX2xvYWRTdmdTb3VyY2VVc2luZ1N0cmluZ2AuXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnByb3RvdHlwZS5fbG9hZFN2Z1NvdXJjZVVzaW5nWGhyID0gZnVuY3Rpb24gX2xvYWRTdmdTb3VyY2VVc2luZ1hocigpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHN2Z1hociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIC8vIFRoaXMgdGhyb3dzIGVycm9yIG9uIElFLCBzbyBTVkcgRG9jdW1lbnQgY2FuJ3QgYmUgdXNlZFxuICAgICAgICAvLyBzdmdYaHIucmVzcG9uc2VUeXBlID0gJ2RvY3VtZW50JztcblxuICAgICAgICAvLyBUaGlzIGlzIG5vdCBuZWVkZWQgc2luY2Ugd2UgbG9hZCB0aGUgc3ZnIGFzIHN0cmluZyAoYnJlYWtzIElFIHRvbylcbiAgICAgICAgLy8gYnV0IG92ZXJyaWRlTWltZVR5cGUoKSBjYW4gYmUgdXNlZCB0byBmb3JjZSB0aGUgcmVzcG9uc2UgdG8gYmUgcGFyc2VkIGFzIFhNTFxuICAgICAgICAvLyBzdmdYaHIub3ZlcnJpZGVNaW1lVHlwZSgnaW1hZ2Uvc3ZnK3htbCcpO1xuXG4gICAgICAgIHN2Z1hoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc3ZnWGhyLnJlYWR5U3RhdGUgIT09IHN2Z1hoci5ET05FIHx8IHN2Z1hoci5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgU1ZHIHVzaW5nIFhIUi4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMyLl9sb2FkU3ZnU291cmNlVXNpbmdTdHJpbmcoc3ZnWGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdmdYaHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuZW1pdCgnZXJyb3InLCBfdGhpczIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN2Z1hoci5vcGVuKCdHRVQnLCB0aGlzLmltYWdlVXJsLCB0cnVlKTtcbiAgICAgICAgc3ZnWGhyLnNlbmQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9hZHMgdGV4dHVyZSB1c2luZyBhbiBTVkcgc3RyaW5nLiBUaGUgb3JpZ2luYWwgU1ZHIEltYWdlIGlzIHN0b3JlZCBhcyBgb3JpZ1NvdXJjZWAgYW5kIHRoZVxuICAgICAqIGNyZWF0ZWQgY2FudmFzIGlzIHRoZSBuZXcgYHNvdXJjZWAuIFRoZSBTVkcgaXMgc2NhbGVkIHVzaW5nIGBzb3VyY2VTY2FsZWAuIENhbGxlZCBieVxuICAgICAqIGBfbG9hZFN2Z1NvdXJjZVVzaW5nWGhyYCBvciBgX2xvYWRTdmdTb3VyY2VVc2luZ0RhdGFVcmlgLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdmdTdHJpbmcgU1ZHIHNvdXJjZSBhcyBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBmaXJlcyBsb2FkZWRcbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLl9sb2FkU3ZnU291cmNlVXNpbmdTdHJpbmcgPSBmdW5jdGlvbiBfbG9hZFN2Z1NvdXJjZVVzaW5nU3RyaW5nKHN2Z1N0cmluZykge1xuICAgICAgICB2YXIgc3ZnU2l6ZSA9ICgwLCBfdXRpbHMuZ2V0U3ZnU2l6ZSkoc3ZnU3RyaW5nKTtcblxuICAgICAgICB2YXIgc3ZnV2lkdGggPSBzdmdTaXplLndpZHRoO1xuICAgICAgICB2YXIgc3ZnSGVpZ2h0ID0gc3ZnU2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFzdmdXaWR0aCB8fCAhc3ZnSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBTVkcgaW1hZ2UgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgZGVmaW5lZCAoaW4gcGl4ZWxzKSwgY2FudmFzIEFQSSBuZWVkcyB0aGVtLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NhbGUgcmVhbFdpZHRoIGFuZCByZWFsSGVpZ2h0XG4gICAgICAgIHRoaXMucmVhbFdpZHRoID0gTWF0aC5yb3VuZChzdmdXaWR0aCAqIHRoaXMuc291cmNlU2NhbGUpO1xuICAgICAgICB0aGlzLnJlYWxIZWlnaHQgPSBNYXRoLnJvdW5kKHN2Z0hlaWdodCAqIHRoaXMuc291cmNlU2NhbGUpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBjYW52YXMgZWxlbWVudFxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5yZWFsV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnJlYWxIZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5fcGl4aUlkID0gJ2NhbnZhc18nICsgKDAsIF91dGlscy51aWQpKCk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgU3ZnIHRvIHRoZSBjYW52YXNcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHRoaXMuc291cmNlLCAwLCAwLCBzdmdXaWR0aCwgc3ZnSGVpZ2h0LCAwLCAwLCB0aGlzLnJlYWxXaWR0aCwgdGhpcy5yZWFsSGVpZ2h0KTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcmlnaW5hbCBzb3VyY2UgaW1hZ2Ugd2l0aCB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMub3JpZ1NvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGNhbnZhcztcblxuICAgICAgICAvLyBBZGQgYWxzbyB0aGUgY2FudmFzIGluIGNhY2hlIChkZXN0cm95IGNsZWFycyBieSBgaW1hZ2VVcmxgIGFuZCBgc291cmNlLl9waXhpSWRgKVxuICAgICAgICBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtjYW52YXMuX3BpeGlJZF0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NvdXJjZUxvYWRlZCgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGludGVybmFsbHkgdG8gdXBkYXRlIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgc29tZSBvdGhlciB0cmFja2luZyB2YXJzIG9uY2VcbiAgICAgKiBhIHNvdXJjZSBoYXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnByb3RvdHlwZS5fc291cmNlTG9hZGVkID0gZnVuY3Rpb24gX3NvdXJjZUxvYWRlZCgpIHtcbiAgICAgICAgdGhpcy5oYXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGJhc2UgdGV4dHVyZVxuICAgICAqXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VVcmwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVt0aGlzLmltYWdlVXJsXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdXRpbHMuVGV4dHVyZUNhY2hlW3RoaXMuaW1hZ2VVcmxdO1xuXG4gICAgICAgICAgICB0aGlzLmltYWdlVXJsID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IuaXNDb2Nvb25KUykge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnNyYyA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFuIHN2ZyBzb3VyY2UgaGFzIGJvdGggYGltYWdlVXJsYCBhbmQgYF9fcGl4aUlkYCwgc28gbm8gYGVsc2UgaWZgIGhlcmVcbiAgICAgICAgaWYgKHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlLl9waXhpSWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVt0aGlzLnNvdXJjZS5fcGl4aUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGcmVlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMIG1lbW9yeSB3aXRob3V0IGRlc3Ryb3lpbmcgdGhpcyB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBUaGlzIG1lYW5zIHlvdSBjYW4gc3RpbGwgdXNlIHRoZSB0ZXh0dXJlIGxhdGVyIHdoaWNoIHdpbGwgdXBsb2FkIGl0IHRvIEdQVVxuICAgICAqIG1lbW9yeSBhZ2Fpbi5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzcG9zZScsIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzb3VyY2UgaW1hZ2Ugb2YgdGhlIHRleHR1cmUuXG4gICAgICogVGhlIG9yaWdpbmFsIHNvdXJjZSBtdXN0IGJlIGFuIEltYWdlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3U3JjIC0gdGhlIHBhdGggb2YgdGhlIGltYWdlXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLnByb3RvdHlwZS51cGRhdGVTb3VyY2VJbWFnZSA9IGZ1bmN0aW9uIHVwZGF0ZVNvdXJjZUltYWdlKG5ld1NyYykge1xuICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSBuZXdTcmM7XG5cbiAgICAgICAgdGhpcy5sb2FkU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGJhc2UgdGV4dHVyZSBmcm9tIHRoZSBnaXZlbiBpbWFnZSB1cmwuXG4gICAgICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVVybCAtIFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjcm9zc29yaWdpbj0oYXV0byldIC0gU2hvdWxkIHVzZSBhbm9ueW1vdXMgQ09SUz8gRGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgVVJMIGlzIG5vdCBhIGRhdGEtVVJJLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NvdXJjZVNjYWxlPShhdXRvKV0gLSBTY2FsZSBmb3IgdGhlIG9yaWdpbmFsIGltYWdlLCB1c2VkIHdpdGggU3ZnIGltYWdlcy5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkJhc2VUZXh0dXJlfSBUaGUgbmV3IGJhc2UgdGV4dHVyZS5cbiAgICAgKi9cblxuXG4gICAgQmFzZVRleHR1cmUuZnJvbUltYWdlID0gZnVuY3Rpb24gZnJvbUltYWdlKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlLCBzb3VyY2VTY2FsZSkge1xuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtpbWFnZVVybF07XG5cbiAgICAgICAgaWYgKCFiYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gbmV3IEltYWdlKCkgYnJlYWtzIHRleCBsb2FkaW5nIGluIHNvbWUgdmVyc2lvbnMgb2YgQ2hyb21lLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMzgwNzFcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICAgICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQgJiYgaW1hZ2VVcmwuaW5kZXhPZignZGF0YTonKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gKDAsIF9kZXRlcm1pbmVDcm9zc09yaWdpbjIuZGVmYXVsdCkoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShpbWFnZSwgc2NhbGVNb2RlKTtcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gaW1hZ2VVcmw7XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2VTY2FsZSkge1xuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLnNvdXJjZVNjYWxlID0gc291cmNlU2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIEAyeCBhdCB0aGUgZW5kIG9mIHRoZSB1cmwgd2UgYXJlIGdvaW5nIHRvIGFzc3VtZSBpdHMgYSBoaWdocmVzIGltYWdlXG4gICAgICAgICAgICBiYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gKDAsIF91dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwpKGltYWdlVXJsKTtcblxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VVcmw7IC8vIFNldHRpbmcgdGhpcyB0cmlnZ2VycyBsb2FkXG5cbiAgICAgICAgICAgIF91dGlscy5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXSA9IGJhc2VUZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGZyb20gdGhlIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVNb2RlIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHJldHVybiB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIG5ldyBiYXNlIHRleHR1cmUuXG4gICAgICovXG5cblxuICAgIEJhc2VUZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbiBmcm9tQ2FudmFzKGNhbnZhcywgc2NhbGVNb2RlKSB7XG4gICAgICAgIGlmICghY2FudmFzLl9waXhpSWQpIHtcbiAgICAgICAgICAgIGNhbnZhcy5fcGl4aUlkID0gJ2NhbnZhc18nICsgKDAsIF91dGlscy51aWQpKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtjYW52YXMuX3BpeGlJZF07XG5cbiAgICAgICAgaWYgKCFiYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoY2FudmFzLCBzY2FsZU1vZGUpO1xuICAgICAgICAgICAgX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbY2FudmFzLl9waXhpSWRdID0gYmFzZVRleHR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZVRleHR1cmU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBiYXNlIHRleHR1cmUgYmFzZWQgb24gdGhlIHNvdXJjZSB5b3UgcHJvdmlkZS5cbiAgICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGltYWdlIHVybCwgaW1hZ2UgZWxlbWVudCwgY2FudmFzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlIC0gVGhlIHNvdXJjZSB0byBjcmVhdGUgYmFzZSB0ZXh0dXJlIGZyb20uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc291cmNlU2NhbGU9KGF1dG8pXSAtIFNjYWxlIGZvciB0aGUgb3JpZ2luYWwgaW1hZ2UsIHVzZWQgd2l0aCBTdmcgaW1hZ2VzLlxuICAgICAqIEByZXR1cm4ge1BJWEkuQmFzZVRleHR1cmV9IFRoZSBuZXcgYmFzZSB0ZXh0dXJlLlxuICAgICAqL1xuXG5cbiAgICBCYXNlVGV4dHVyZS5mcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UsIHNjYWxlTW9kZSwgc291cmNlU2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFzZVRleHR1cmUuZnJvbUltYWdlKHNvdXJjZSwgdW5kZWZpbmVkLCBzY2FsZU1vZGUsIHNvdXJjZVNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VVcmwgPSBzb3VyY2Uuc3JjO1xuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuXG4gICAgICAgICAgICBpZiAoIWJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoc291cmNlLCBzY2FsZU1vZGUpO1xuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gaW1hZ2VVcmw7XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVRleHR1cmUuc291cmNlU2NhbGUgPSBzb3VyY2VTY2FsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBAMnggYXQgdGhlIGVuZCBvZiB0aGUgdXJsIHdlIGFyZSBnb2luZyB0byBhc3N1bWUgaXRzIGEgaGlnaHJlcyBpbWFnZVxuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSAoMCwgX3V0aWxzLmdldFJlc29sdXRpb25PZlVybCkoaW1hZ2VVcmwpO1xuXG4gICAgICAgICAgICAgICAgX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdID0gYmFzZVRleHR1cmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIEJhc2VUZXh0dXJlLmZyb21DYW52YXMoc291cmNlLCBzY2FsZU1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0cyBhc3N1bWUgaXRzIGEgYmFzZSB0ZXh0dXJlIVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQmFzZVRleHR1cmU7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VUZXh0dXJlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuL0Jhc2VUZXh0dXJlJyk7XG5cbnZhciBfQmFzZVRleHR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRleHR1cmUpO1xuXG52YXIgX1ZpZGVvQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuL1ZpZGVvQmFzZVRleHR1cmUnKTtcblxudmFyIF9WaWRlb0Jhc2VUZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZpZGVvQmFzZVRleHR1cmUpO1xuXG52YXIgX1RleHR1cmVVdnMgPSByZXF1aXJlKCcuL1RleHR1cmVVdnMnKTtcblxudmFyIF9UZXh0dXJlVXZzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmVVdnMpO1xuXG52YXIgX2V2ZW50ZW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgdGV4dHVyZSBzdG9yZXMgdGhlIGluZm9ybWF0aW9uIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZSBvciBwYXJ0IG9mIGFuIGltYWdlLiBJdCBjYW5ub3QgYmUgYWRkZWRcbiAqIHRvIHRoZSBkaXNwbGF5IGxpc3QgZGlyZWN0bHkuIEluc3RlYWQgdXNlIGl0IGFzIHRoZSB0ZXh0dXJlIGZvciBhIFNwcml0ZS4gSWYgbm8gZnJhbWUgaXMgcHJvdmlkZWRcbiAqIHRoZW4gdGhlIHdob2xlIGltYWdlIGlzIHVzZWQuXG4gKlxuICogWW91IGNhbiBkaXJlY3RseSBjcmVhdGUgYSB0ZXh0dXJlIGZyb20gYW4gaW1hZ2UgYW5kIHRoZW4gcmV1c2UgaXQgbXVsdGlwbGUgdGltZXMgbGlrZSB0aGlzIDpcbiAqXG4gKiBgYGBqc1xuICogbGV0IHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKCdhc3NldHMvaW1hZ2UucG5nJyk7XG4gKiBsZXQgc3ByaXRlMSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAqIGxldCBzcHJpdGUyID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuICogYGBgXG4gKlxuICogVGV4dHVyZXMgbWFkZSBmcm9tIFNWR3MsIGxvYWRlZCBvciBub3QsIGNhbm5vdCBiZSB1c2VkIGJlZm9yZSB0aGUgZmlsZSBmaW5pc2hlcyBwcm9jZXNzaW5nLlxuICogWW91IGNhbiBjaGVjayBmb3IgdGhpcyBieSBjaGVja2luZyB0aGUgc3ByaXRlJ3MgX3RleHR1cmVJRCBwcm9wZXJ0eS5cbiAqIGBgYGpzXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoJ2Fzc2V0cy9pbWFnZS5zdmcnKTtcbiAqIHZhciBzcHJpdGUxID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuICogLy9zcHJpdGUxLl90ZXh0dXJlSUQgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQgaWYgdGhlIHRleHR1cmUgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcgdGhlIFNWRyBmaWxlXG4gKiBgYGBcbiAqIFlvdSBjYW4gdXNlIGEgdGlja2VyIG9yIHJBRiB0byBlbnN1cmUgeW91ciBzcHJpdGVzIGxvYWQgdGhlIGZpbmlzaGVkIHRleHR1cmVzIGFmdGVyIHByb2Nlc3NpbmcuIFNlZSBpc3N1ZSAjMzA2OC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFRleHR1cmUgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhUZXh0dXJlLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBUaGUgYmFzZSB0ZXh0dXJlIHNvdXJjZSB0byBjcmVhdGUgdGhlIHRleHR1cmUgZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IFtmcmFtZV0gLSBUaGUgcmVjdGFuZ2xlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlIHRvIHNob3dcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbb3JpZ10gLSBUaGUgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW3RyaW1dIC0gVHJpbW1lZCByZWN0YW5nbGUgb2Ygb3JpZ2luYWwgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcm90YXRlXSAtIGluZGljYXRlcyBob3cgdGhlIHRleHR1cmUgd2FzIHJvdGF0ZWQgYnkgdGV4dHVyZSBwYWNrZXIuIFNlZSB7QGxpbmsgUElYSS5Hcm91cEQ4fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHR1cmUoYmFzZVRleHR1cmUsIGZyYW1lLCBvcmlnLCB0cmltLCByb3RhdGUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHR1cmUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICAgICAgX3RoaXMubm9GcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBmcmFtZSA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2YgdGhlIEJhc2VUZXh0dXJlIGltYWdlIHRvIGFjdHVhbGx5IGNvcHkgdG8gdGhlIENhbnZhcyAvIFdlYkdMIHdoZW4gcmVuZGVyaW5nLFxuICAgICAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2ZyYW1lID0gZnJhbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHRyaW1tZWQgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlLCBiZWZvcmUgaXQgd2FzIHB1dCBpbiBhdGxhc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRyaW0gPSB0cmltO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgbGV0IHRoZSByZW5kZXJlciBrbm93IGlmIHRoZSB0ZXh0dXJlIGlzIHZhbGlkLiBJZiBpdCdzIG5vdCB0aGVuIGl0IGNhbm5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd2lsbCBsZXQgYSByZW5kZXJlciBrbm93IHRoYXQgYSB0ZXh0dXJlIGhhcyBiZWVuIHVwZGF0ZWQgKHVzZWQgbWFpbmx5IGZvciB3ZWJHTCB1diB1cGRhdGVzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucmVxdWlyZXNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFdlYkdMIFVWIGRhdGEgY2FjaGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZVV2c31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl91dnMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIG9yaWdpbmFsIHRleHR1cmUsIGJlZm9yZSBpdCB3YXMgcHV0IGluIGF0bGFzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub3JpZyA9IG9yaWcgfHwgZnJhbWU7IC8vIG5ldyBSZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG5cbiAgICAgICAgX3RoaXMuX3JvdGF0ZSA9IE51bWJlcihyb3RhdGUgfHwgMCk7XG5cbiAgICAgICAgaWYgKHJvdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbGQgdGV4dHVyZXBhY2tlciBsZWdhY3ksIHNvbWUgZ2FtZXMvbGlicmFyaWVzIGFyZSBwYXNzaW5nIFwidHJ1ZVwiIGZvciByb3RhdGVkIHRleHR1cmVzXG4gICAgICAgICAgICBfdGhpcy5fcm90YXRlID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5fcm90YXRlICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0IHRvIHVzZSBkaWFtb25kLXNoYXBlZCBVVnMuIElmIHlvdSBhcmUgc3VyZSwgc2V0IHJvdGF0aW9uIG1hbnVhbGx5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmFzZVRleHR1cmUuaGFzTG9hZGVkKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMubm9GcmFtZSkge1xuICAgICAgICAgICAgICAgIGZyYW1lID0gbmV3IF9tYXRoLlJlY3RhbmdsZSgwLCAwLCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyYW1lIHdlIHNob3VsZCBtb25pdG9yIGZvciBhbnkgYmFzZSB0ZXh0dXJlIGNoYW5nZXMuLlxuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLm9uKCd1cGRhdGUnLCBfdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLm9uY2UoJ2xvYWRlZCcsIF90aGlzLm9uQmFzZVRleHR1cmVMb2FkZWQsIF90aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQuIFRoaXMgaGFwcGVucyBpZiB0aGUgZnJhbWUgb3IgdGhlIGJhc2VUZXh0dXJlIGlzIHVwZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCB1cGRhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuVGV4dHVyZSNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cblxuICAgICAgICBfdGhpcy5fdXBkYXRlSUQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYSBmaWVsZCBmb3IgZXh0cmEgcGx1Z2lucy4gTWF5IGNvbnRhaW4gY2xhbXAgc2V0dGluZ3MgYW5kIHNvbWUgbWF0cmljZXNcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoaXMgdGV4dHVyZSBvbiB0aGUgZ3B1LlxuICAgICAqXG4gICAgICovXG5cblxuICAgIFRleHR1cmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFRoZSBiYXNlIHRleHR1cmUuXG4gICAgICovXG5cblxuICAgIFRleHR1cmUucHJvdG90eXBlLm9uQmFzZVRleHR1cmVMb2FkZWQgPSBmdW5jdGlvbiBvbkJhc2VUZXh0dXJlTG9hZGVkKGJhc2VUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XG5cbiAgICAgICAgLy8gVE9ETyB0aGlzIGNvZGUgbG9va3MgY29uZnVzaW5nLi4gYm9vIHRvIGFidXNpbmcgZ2V0dGVycyBhbmQgc2V0dGVycyFcbiAgICAgICAgaWYgKHRoaXMubm9GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy5fZnJhbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyB1cGRhdGVkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBUaGUgYmFzZSB0ZXh0dXJlLlxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLnByb3RvdHlwZS5vbkJhc2VUZXh0dXJlVXBkYXRlZCA9IGZ1bmN0aW9uIG9uQmFzZVRleHR1cmVVcGRhdGVkKGJhc2VUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XG5cbiAgICAgICAgdGhpcy5fZnJhbWUud2lkdGggPSBiYXNlVGV4dHVyZS53aWR0aDtcbiAgICAgICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVzdHJveUJhc2U9ZmFsc2VdIFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koZGVzdHJveUJhc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgdGV4dHVyZSBpZiBpdCBleGlzdHMgaW4gdGhlIHRleHR1cmUgY2FjaGUuLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgb25seSBuZWVkcyB0byBiZSByZW1vdmVkIGlmIHRoZSBiYXNlIHRleHR1cmUgaXMgYWN0dWFsbHkgZGVzdHJveWVkIHRvby4uXG4gICAgICAgICAgICAgICAgaWYgKF91dGlscy5UZXh0dXJlQ2FjaGVbdGhpcy5iYXNlVGV4dHVyZS5pbWFnZVVybF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF91dGlscy5UZXh0dXJlQ2FjaGVbdGhpcy5iYXNlVGV4dHVyZS5pbWFnZVVybF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUub2ZmKCd1cGRhdGUnLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUub2ZmKCdsb2FkZWQnLCB0aGlzLm9uQmFzZVRleHR1cmVMb2FkZWQsIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXZzID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmltID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnID0gbnVsbDtcblxuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2UsIHRoaXMpO1xuICAgICAgICB0aGlzLm9mZigndXBkYXRlJywgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRleHR1cmUgb2JqZWN0IHRoYXQgYWN0cyB0aGUgc2FtZSBhcyB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ldyB0ZXh0dXJlXG4gICAgICovXG5cblxuICAgIFRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCB0aGlzLmZyYW1lLCB0aGlzLm9yaWcsIHRoaXMudHJpbSwgdGhpcy5yb3RhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5wcm90b3R5cGUuX3VwZGF0ZVV2cyA9IGZ1bmN0aW9uIF91cGRhdGVVdnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdXZzKSB7XG4gICAgICAgICAgICB0aGlzLl91dnMgPSBuZXcgX1RleHR1cmVVdnMyLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3V2cy5zZXQodGhpcy5fZnJhbWUsIHRoaXMuYmFzZVRleHR1cmUsIHRoaXMucm90YXRlKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgVGV4dHVyZSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gaW1hZ2UgdXJsLlxuICAgICAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSAgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVVybCAtIFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjcm9zc29yaWdpbl0gLSBXaGV0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3Nzb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc291cmNlU2NhbGU9KGF1dG8pXSAtIFNjYWxlIGZvciB0aGUgb3JpZ2luYWwgaW1hZ2UsIHVzZWQgd2l0aCBTVkcgaW1hZ2VzLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIGZyb21JbWFnZShpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSwgc291cmNlU2NhbGUpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBfdXRpbHMuVGV4dHVyZUNhY2hlW2ltYWdlVXJsXTtcblxuICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZShfQmFzZVRleHR1cmUyLmRlZmF1bHQuZnJvbUltYWdlKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlLCBzb3VyY2VTY2FsZSkpO1xuICAgICAgICAgICAgX3V0aWxzLlRleHR1cmVDYWNoZVtpbWFnZVVybF0gPSB0ZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVDYWNoZSBiYXNlZCBvbiB0aGUgZnJhbWVJZFxuICAgICAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyYW1lSWQgLSBUaGUgZnJhbWUgSWQgb2YgdGhlIHRleHR1cmUgaW4gdGhlIGNhY2hlXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAgICovXG5cblxuICAgIFRleHR1cmUuZnJvbUZyYW1lID0gZnVuY3Rpb24gZnJvbUZyYW1lKGZyYW1lSWQpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBfdXRpbHMuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuXG4gICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnJhbWVJZCBcIicgKyBmcmFtZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0ZXh0dXJlIGNhY2hlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSBnaXZlbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbiBmcm9tQ2FudmFzKGNhbnZhcywgc2NhbGVNb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShfQmFzZVRleHR1cmUyLmRlZmF1bHQuZnJvbUNhbnZhcyhjYW52YXMsIHNjYWxlTW9kZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFRleHR1cmUgYmFzZWQgb24gdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fHN0cmluZ30gdmlkZW8gLSBUaGUgVVJMIG9yIGFjdHVhbCBlbGVtZW50IG9mIHRoZSB2aWRlb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSBuZXdseSBjcmVhdGVkIHRleHR1cmVcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5mcm9tVmlkZW8gPSBmdW5jdGlvbiBmcm9tVmlkZW8odmlkZW8sIHNjYWxlTW9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuZnJvbVZpZGVvVXJsKHZpZGVvLCBzY2FsZU1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKF9WaWRlb0Jhc2VUZXh0dXJlMi5kZWZhdWx0LmZyb21WaWRlbyh2aWRlbywgc2NhbGVNb2RlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVGV4dHVyZSBiYXNlZCBvbiB0aGUgdmlkZW8gdXJsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb1VybCAtIFVSTCBvZiB0aGUgdmlkZW9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAgICovXG5cblxuICAgIFRleHR1cmUuZnJvbVZpZGVvVXJsID0gZnVuY3Rpb24gZnJvbVZpZGVvVXJsKHZpZGVvVXJsLCBzY2FsZU1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKF9WaWRlb0Jhc2VUZXh0dXJlMi5kZWZhdWx0LmZyb21VcmwodmlkZW9VcmwsIHNjYWxlTW9kZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFRleHR1cmUgYmFzZWQgb24gdGhlIHNvdXJjZSB5b3UgcHJvdmlkZS5cbiAgICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8UElYSS5CYXNlVGV4dHVyZX1cbiAgICAgKiAgICAgICAgc291cmNlIC0gU291cmNlIHRvIGNyZWF0ZSB0ZXh0dXJlIGZyb21cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSBuZXdseSBjcmVhdGVkIHRleHR1cmVcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5mcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UpIHtcbiAgICAgICAgLy8gVE9ETyBhdXRvIGRldGVjdCBjcm9zcyBvcmlnaW4uLlxuICAgICAgICAvLyBUT0RPIHBhc3MgaW4gc2NhbGUgbW9kZT9cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IF91dGlscy5UZXh0dXJlQ2FjaGVbc291cmNlXTtcblxuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXRzIGEgdmlkZW8uLlxuICAgICAgICAgICAgICAgIHZhciBpc1ZpZGVvID0gc291cmNlLm1hdGNoKC9cXC4obXA0fHdlYm18b2dnfGgyNjR8YXZpfG1vdikkLykgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNWaWRlbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5mcm9tVmlkZW9Vcmwoc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5mcm9tSW1hZ2Uoc291cmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKF9CYXNlVGV4dHVyZTIuZGVmYXVsdC5mcm9tKHNvdXJjZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5mcm9tQ2FudmFzKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuZnJvbVZpZGVvKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgX0Jhc2VUZXh0dXJlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHR1cmUoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldHMgYXNzdW1lIGl0cyBhIHRleHR1cmUhXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRleHR1cmUgZnJvbSBhIHNvdXJjZSBhbmQgYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAtIFRoZSBpbnB1dCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGltYWdlVXJsIC0gRmlsZSBuYW1lIG9mIHRleHR1cmUsIGZvciBjYWNoZSBhbmQgcmVzb2x2aW5nIHJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIEh1bWFuIHJlYWRpYmxlIG5hbWUgZm9yIHRoZSB0ZXh0dXJlIGNhY2hlLiBJZiBubyBuYW1lIGlzXG4gICAgICogICAgICAgIHNwZWNpZmllZCwgb25seSBgaW1hZ2VVcmxgIHdpbGwgYmUgdXNlZCBhcyB0aGUgY2FjaGUgSUQuXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBPdXRwdXQgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLmZyb21Mb2FkZXIgPSBmdW5jdGlvbiBmcm9tTG9hZGVyKHNvdXJjZSwgaW1hZ2VVcmwsIG5hbWUpIHtcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gbmV3IF9CYXNlVGV4dHVyZTIuZGVmYXVsdChzb3VyY2UsIHVuZGVmaW5lZCwgKDAsIF91dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwpKGltYWdlVXJsKSk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoYmFzZVRleHR1cmUpO1xuXG4gICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gaW1hZ2VVcmw7XG5cbiAgICAgICAgLy8gTm8gbmFtZSwgdXNlIGltYWdlVXJsIGluc3RlYWRcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gaW1hZ2VVcmw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXRzIGFsc28gYWRkIHRoZSBmcmFtZSB0byBwaXhpJ3MgZ2xvYmFsIGNhY2hlIGZvciBmcm9tRnJhbWUgYW5kIGZyb21JbWFnZSBmdWNudGlvbnNcbiAgICAgICAgX3V0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbbmFtZV0gPSBiYXNlVGV4dHVyZTtcbiAgICAgICAgX3V0aWxzLlRleHR1cmVDYWNoZVtuYW1lXSA9IHRleHR1cmU7XG5cbiAgICAgICAgLy8gYWxzbyBhZGQgcmVmZXJlbmNlcyBieSB1cmwgaWYgdGhleSBhcmUgZGlmZmVyZW50LlxuICAgICAgICBpZiAobmFtZSAhPT0gaW1hZ2VVcmwpIHtcbiAgICAgICAgICAgIF91dGlscy5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXSA9IGJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgX3V0aWxzLlRleHR1cmVDYWNoZVtpbWFnZVVybF0gPSB0ZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZXh0dXJlIHRvIHRoZSBnbG9iYWwgVGV4dHVyZUNhY2hlLiBUaGlzIGNhY2hlIGlzIHNoYXJlZCBhY3Jvc3MgdGhlIHdob2xlIFBJWEkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgdGV4dHVyZSB3aWxsIGJlIHN0b3JlZCBhZ2FpbnN0LlxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlLmFkZFRleHR1cmVUb0NhY2hlID0gZnVuY3Rpb24gYWRkVGV4dHVyZVRvQ2FjaGUodGV4dHVyZSwgaWQpIHtcbiAgICAgICAgX3V0aWxzLlRleHR1cmVDYWNoZVtpZF0gPSB0ZXh0dXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB0ZXh0dXJlIGZyb20gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSB0ZXh0dXJlIHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSB0ZXh0dXJlIHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZS5yZW1vdmVUZXh0dXJlRnJvbUNhY2hlID0gZnVuY3Rpb24gcmVtb3ZlVGV4dHVyZUZyb21DYWNoZShpZCkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IF91dGlscy5UZXh0dXJlQ2FjaGVbaWRdO1xuXG4gICAgICAgIGRlbGV0ZSBfdXRpbHMuVGV4dHVyZUNhY2hlW2lkXTtcbiAgICAgICAgZGVsZXRlIF91dGlscy5CYXNlVGV4dHVyZUNhY2hlW2lkXTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVGV4dHVyZSwgW3tcbiAgICAgICAga2V5OiAnZnJhbWUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZnJhbWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuXG4gICAgICAgICAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGZyYW1lLnggKyBmcmFtZS53aWR0aCA+IHRoaXMuYmFzZVRleHR1cmUud2lkdGggfHwgZnJhbWUueSArIGZyYW1lLmhlaWdodCA+IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9uczogJyArICgnWDogJyArIGZyYW1lLnggKyAnICsgJyArIGZyYW1lLndpZHRoICsgJyA+ICcgKyB0aGlzLmJhc2VUZXh0dXJlLndpZHRoICsgJyAnKSArICgnWTogJyArIGZyYW1lLnkgKyAnICsgJyArIGZyYW1lLmhlaWdodCArICcgPiAnICsgdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcy52YWxpZCA9IGZyYW1lICYmIGZyYW1lLndpZHRoICYmIGZyYW1lLmhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnNvdXJjZSAmJiB0aGlzLmJhc2VUZXh0dXJlLmhhc0xvYWRlZDtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZyA9IGZyYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVV2cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIGlzIHJvdGF0ZWQgaW5zaWRlIHRoZSBhdGxhc1xuICAgICAgICAgKiBzZXQgdG8gMiB0byBjb21wZW5zYXRlIGZvciB0ZXh0dXJlIHBhY2tlciByb3RhdGlvblxuICAgICAgICAgKiBzZXQgdG8gNiB0byBjb21wZW5zYXRlIGZvciBzcGluZSBwYWNrZXIgcm90YXRpb25cbiAgICAgICAgICogY2FuIGJlIHVzZWQgdG8gcm90YXRlIG9yIG1pcnJvciBzcHJpdGVzXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUElYSS5Hcm91cEQ4fSBmb3IgZXhwbGFuYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncm90YXRlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChyb3RhdGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGUgPSByb3RhdGU7XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVV2cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3dpZHRoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoZWlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWcuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRleHR1cmU7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0dXJlO1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVdoaXRlVGV4dHVyZSgpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBjYW52YXMud2lkdGggPSAxMDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTA7XG5cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgMTAsIDEwKTtcblxuICAgIHJldHVybiBuZXcgVGV4dHVyZShuZXcgX0Jhc2VUZXh0dXJlMi5kZWZhdWx0KGNhbnZhcykpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBbGxIYW5kbGVycyh0ZXgpIHtcbiAgICB0ZXguZGVzdHJveSA9IGZ1bmN0aW9uIF9lbXB0eURlc3Ryb3koKSB7LyogZW1wdHkgKi99O1xuICAgIHRleC5vbiA9IGZ1bmN0aW9uIF9lbXB0eU9uKCkgey8qIGVtcHR5ICovfTtcbiAgICB0ZXgub25jZSA9IGZ1bmN0aW9uIF9lbXB0eU9uY2UoKSB7LyogZW1wdHkgKi99O1xuICAgIHRleC5lbWl0ID0gZnVuY3Rpb24gX2VtcHR5RW1pdCgpIHsvKiBlbXB0eSAqL307XG59XG5cbi8qKlxuICogQW4gZW1wdHkgdGV4dHVyZSwgdXNlZCBvZnRlbiB0byBub3QgaGF2ZSB0byBjcmVhdGUgbXVsdGlwbGUgZW1wdHkgdGV4dHVyZXMuXG4gKiBDYW4gbm90IGJlIGRlc3Ryb3llZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqL1xuVGV4dHVyZS5FTVBUWSA9IG5ldyBUZXh0dXJlKG5ldyBfQmFzZVRleHR1cmUyLmRlZmF1bHQoKSk7XG5yZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLkVNUFRZKTtcblxuLyoqXG4gKiBBIHdoaXRlIHRleHR1cmUgb2YgMTB4MTAgc2l6ZSwgdXNlZCBmb3IgZ3JhcGhpY3MgYW5kIG90aGVyIHRoaW5nc1xuICogQ2FuIG5vdCBiZSBkZXN0cm95ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKi9cblRleHR1cmUuV0hJVEUgPSBjcmVhdGVXaGl0ZVRleHR1cmUoKTtcbnJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuV0hJVEUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9UZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgICAgfSwgdGhpcylcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcGl4aUdsQ29yZSA9IHJlcXVpcmUoJ3BpeGktZ2wtY29yZScpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBjaGVja1ByZWNpc2lvbihzcmMsIGRlZikge1xuICAgIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAoc3JjWzBdLnN1YnN0cmluZygwLCA5KSAhPT0gJ3ByZWNpc2lvbicpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gc3JjLnNsaWNlKDApO1xuXG4gICAgICAgICAgICBjb3B5LnVuc2hpZnQoJ3ByZWNpc2lvbiAnICsgZGVmICsgJyBmbG9hdDsnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNyYy5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKSB7XG4gICAgICAgIHJldHVybiAncHJlY2lzaW9uICcgKyBkZWYgKyAnIGZsb2F0O1xcbicgKyBzcmM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNyYztcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzLCB3ZWJHTCBTaGFkZXIgZm9yIFBpeGkuXG4gKiBBZGRzIHByZWNpc2lvbiBzdHJpbmcgaWYgdmVydGV4U3JjIG9yIGZyYWdtZW50U3JjIGhhdmUgbm8gbWVudGlvbiBvZiBpdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEdMU2hhZGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5cbnZhciBTaGFkZXIgPSBmdW5jdGlvbiAoX0dMU2hhZGVyKSB7XG4gICAgX2luaGVyaXRzKFNoYWRlciwgX0dMU2hhZGVyKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdmVydGV4U3JjIC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTaGFkZXIoZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWRlcik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9HTFNoYWRlci5jYWxsKHRoaXMsIGdsLCBjaGVja1ByZWNpc2lvbih2ZXJ0ZXhTcmMsIF9zZXR0aW5nczIuZGVmYXVsdC5QUkVDSVNJT05fVkVSVEVYKSwgY2hlY2tQcmVjaXNpb24oZnJhZ21lbnRTcmMsIF9zZXR0aW5nczIuZGVmYXVsdC5QUkVDSVNJT05fRlJBR01FTlQpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNoYWRlcjtcbn0oX3BpeGlHbENvcmUuR0xTaGFkZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTaGFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGFkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChncmFwaGljc0RhdGEsIHdlYkdMRGF0YSkge1xuICAgIGlmIChncmFwaGljc0RhdGEubmF0aXZlTGluZXMpIHtcbiAgICAgICAgYnVpbGROYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xuICAgIH1cbn07XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgnKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQnVpbGRzIGEgbGluZSB0byBkcmF3IHVzaW5nIHRoZSBwb2xpZ29uIG1ldGhvZC5cbiAqXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YSAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKSB7XG4gICAgLy8gVE9ETyBPUFRJTUlTRSFcbiAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgdGhlIGxpbmUgd2lkdGggaXMgYW4gb2RkIG51bWJlciBhZGQgMC41IHRvIGFsaWduIHRvIGEgd2hvbGUgcGl4ZWxcbiAgICAvLyBjb21tZW50aW5nIHRoaXMgb3V0IGZpeGVzICM3MTEgYW5kICMxNjIwXG4gICAgLy8gaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGglMilcbiAgICAvLyB7XG4gICAgLy8gICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAgIHBvaW50c1tpXSArPSAwLjU7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgdmFyIGZpcnN0UG9pbnQgPSBuZXcgX21hdGguUG9pbnQocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgIHZhciBsYXN0UG9pbnQgPSBuZXcgX21hdGguUG9pbnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cbiAgICAvLyBpZiB0aGUgZmlyc3QgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgLSBnb25uYSBoYXZlIGlzc3VlcyA6KVxuICAgIGlmIChmaXJzdFBvaW50LnggPT09IGxhc3RQb2ludC54ICYmIGZpcnN0UG9pbnQueSA9PT0gbGFzdFBvaW50LnkpIHtcbiAgICAgICAgLy8gbmVlZCB0byBjbG9uZSBhcyB3ZSBhcmUgZ29pbmcgdG8gc2xpZ2h0bHkgbW9kaWZ5IHRoZSBzaGFwZS4uXG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5zbGljZSgpO1xuXG4gICAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgICAgcG9pbnRzLnBvcCgpO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IG5ldyBfbWF0aC5Qb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblxuICAgICAgICB2YXIgbWlkUG9pbnRYID0gbGFzdFBvaW50LnggKyAoZmlyc3RQb2ludC54IC0gbGFzdFBvaW50LngpICogMC41O1xuICAgICAgICB2YXIgbWlkUG9pbnRZID0gbGFzdFBvaW50LnkgKyAoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpICogMC41O1xuXG4gICAgICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICAgICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgdmFyIGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleFN0YXJ0ID0gdmVydHMubGVuZ3RoIC8gNjtcblxuICAgIC8vIERSQVcgdGhlIExpbmVcbiAgICB2YXIgd2lkdGggPSBncmFwaGljc0RhdGEubGluZVdpZHRoIC8gMjtcblxuICAgIC8vIHNvcnQgY29sb3JcbiAgICB2YXIgY29sb3IgPSAoMCwgX3V0aWxzLmhleDJyZ2IpKGdyYXBoaWNzRGF0YS5saW5lQ29sb3IpO1xuICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5saW5lQWxwaGE7XG4gICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICB2YXIgcDF4ID0gcG9pbnRzWzBdO1xuICAgIHZhciBwMXkgPSBwb2ludHNbMV07XG4gICAgdmFyIHAyeCA9IHBvaW50c1syXTtcbiAgICB2YXIgcDJ5ID0gcG9pbnRzWzNdO1xuICAgIHZhciBwM3ggPSAwO1xuICAgIHZhciBwM3kgPSAwO1xuXG4gICAgdmFyIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgIHZhciBwZXJweSA9IHAxeCAtIHAyeDtcbiAgICB2YXIgcGVycDJ4ID0gMDtcbiAgICB2YXIgcGVycDJ5ID0gMDtcbiAgICB2YXIgcGVycDN4ID0gMDtcbiAgICB2YXIgcGVycDN5ID0gMDtcblxuICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KTtcblxuICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgcGVycHkgLz0gZGlzdDtcbiAgICBwZXJweCAqPSB3aWR0aDtcbiAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgIC8vIHN0YXJ0XG4gICAgdmVydHMucHVzaChwMXggLSBwZXJweCwgcDF5IC0gcGVycHksIHIsIGcsIGIsIGFscGhhKTtcblxuICAgIHZlcnRzLnB1c2gocDF4ICsgcGVycHgsIHAxeSArIHBlcnB5LCByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBwMXggPSBwb2ludHNbKGkgLSAxKSAqIDJdO1xuICAgICAgICBwMXkgPSBwb2ludHNbKGkgLSAxKSAqIDIgKyAxXTtcblxuICAgICAgICBwMnggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICBwMnkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgICBwM3ggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICBwM3kgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcblxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gICAgICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgICAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgICAgICBwZXJwMnggPSAtKHAyeSAtIHAzeSk7XG4gICAgICAgIHBlcnAyeSA9IHAyeCAtIHAzeDtcblxuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAyeCAqIHBlcnAyeCArIHBlcnAyeSAqIHBlcnAyeSk7XG4gICAgICAgIHBlcnAyeCAvPSBkaXN0O1xuICAgICAgICBwZXJwMnkgLz0gZGlzdDtcbiAgICAgICAgcGVycDJ4ICo9IHdpZHRoO1xuICAgICAgICBwZXJwMnkgKj0gd2lkdGg7XG5cbiAgICAgICAgdmFyIGExID0gLXBlcnB5ICsgcDF5IC0gKC1wZXJweSArIHAyeSk7XG4gICAgICAgIHZhciBiMSA9IC1wZXJweCArIHAyeCAtICgtcGVycHggKyBwMXgpO1xuICAgICAgICB2YXIgYzEgPSAoLXBlcnB4ICsgcDF4KSAqICgtcGVycHkgKyBwMnkpIC0gKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KTtcbiAgICAgICAgdmFyIGEyID0gLXBlcnAyeSArIHAzeSAtICgtcGVycDJ5ICsgcDJ5KTtcbiAgICAgICAgdmFyIGIyID0gLXBlcnAyeCArIHAyeCAtICgtcGVycDJ4ICsgcDN4KTtcbiAgICAgICAgdmFyIGMyID0gKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpIC0gKC1wZXJwMnggKyBwMngpICogKC1wZXJwMnkgKyBwM3kpO1xuXG4gICAgICAgIHZhciBkZW5vbSA9IGExICogYjIgLSBhMiAqIGIxO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkZW5vbSkgPCAwLjEpIHtcbiAgICAgICAgICAgIGRlbm9tICs9IDEwLjE7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4LCBwMnkgLSBwZXJweSwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4LCBwMnkgKyBwZXJweSwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBweCA9IChiMSAqIGMyIC0gYjIgKiBjMSkgLyBkZW5vbTtcbiAgICAgICAgdmFyIHB5ID0gKGEyICogYzEgLSBhMSAqIGMyKSAvIGRlbm9tO1xuICAgICAgICB2YXIgcGRpc3QgPSAocHggLSBwMngpICogKHB4IC0gcDJ4KSArIChweSAtIHAyeSkgKiAocHkgLSBwMnkpO1xuXG4gICAgICAgIGlmIChwZGlzdCA+IDE5NiAqIHdpZHRoICogd2lkdGgpIHtcbiAgICAgICAgICAgIHBlcnAzeCA9IHBlcnB4IC0gcGVycDJ4O1xuICAgICAgICAgICAgcGVycDN5ID0gcGVycHkgLSBwZXJwMnk7XG5cbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycDN4ICogcGVycDN4ICsgcGVycDN5ICogcGVycDN5KTtcbiAgICAgICAgICAgIHBlcnAzeCAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDN5IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJwM3ggKj0gd2lkdGg7XG4gICAgICAgICAgICBwZXJwM3kgKj0gd2lkdGg7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycDN4LCBwMnkgLSBwZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgcGVycDN4LCBwMnkgKyBwZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycDN4LCBwMnkgLSBwZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGluZGV4Q291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocHgsIHB5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChweCAtIHAyeCksIHAyeSAtIChweSAtIHAyeSkpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwMXggPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMl07XG4gICAgcDF5ID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDIgKyAxXTtcblxuICAgIHAyeCA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgICBwMnkgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMiArIDFdO1xuXG4gICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XG4gICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KTtcbiAgICBwZXJweCAvPSBkaXN0O1xuICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgcGVycHggKj0gd2lkdGg7XG4gICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4LCBwMnkgLSBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4LCBwMnkgKyBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5kZXhDb3VudDsgKytfaSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCsrKTtcbiAgICB9XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCAtIDEpO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUykgbWV0aG9kXG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cblxuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhd1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5mdW5jdGlvbiBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG5cbiAgICAvLyBzb3J0IGNvbG9yXG4gICAgdmFyIGNvbG9yID0gKDAsIF91dGlscy5oZXgycmdiKShncmFwaGljc0RhdGEubGluZUNvbG9yKTtcbiAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEubGluZUFscGhhO1xuICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwMXggPSBwb2ludHNbKGkgLSAxKSAqIDJdO1xuICAgICAgICB2YXIgcDF5ID0gcG9pbnRzWyhpIC0gMSkgKiAyICsgMV07XG5cbiAgICAgICAgdmFyIHAyeCA9IHBvaW50c1tpICogMl07XG4gICAgICAgIHZhciBwMnkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHAxeCwgcDF5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaChwMngsIHAyeSk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkTGluZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZExpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TeXN0ZW1SZW5kZXJlcjIgPSByZXF1aXJlKCcuLi9TeXN0ZW1SZW5kZXJlcicpO1xuXG52YXIgX1N5c3RlbVJlbmRlcmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N5c3RlbVJlbmRlcmVyMik7XG5cbnZhciBfTWFza01hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXJzL01hc2tNYW5hZ2VyJyk7XG5cbnZhciBfTWFza01hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWFza01hbmFnZXIpO1xuXG52YXIgX1N0ZW5jaWxNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9TdGVuY2lsTWFuYWdlcicpO1xuXG52YXIgX1N0ZW5jaWxNYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0ZW5jaWxNYW5hZ2VyKTtcblxudmFyIF9GaWx0ZXJNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9GaWx0ZXJNYW5hZ2VyJyk7XG5cbnZhciBfRmlsdGVyTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GaWx0ZXJNYW5hZ2VyKTtcblxudmFyIF9SZW5kZXJUYXJnZXQgPSByZXF1aXJlKCcuL3V0aWxzL1JlbmRlclRhcmdldCcpO1xuXG52YXIgX1JlbmRlclRhcmdldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZW5kZXJUYXJnZXQpO1xuXG52YXIgX09iamVjdFJlbmRlcmVyID0gcmVxdWlyZSgnLi91dGlscy9PYmplY3RSZW5kZXJlcicpO1xuXG52YXIgX09iamVjdFJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09iamVjdFJlbmRlcmVyKTtcblxudmFyIF9UZXh0dXJlTWFuYWdlciA9IHJlcXVpcmUoJy4vVGV4dHVyZU1hbmFnZXInKTtcblxudmFyIF9UZXh0dXJlTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0dXJlTWFuYWdlcik7XG5cbnZhciBfQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuLi8uLi90ZXh0dXJlcy9CYXNlVGV4dHVyZScpO1xuXG52YXIgX0Jhc2VUZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUZXh0dXJlKTtcblxudmFyIF9UZXh0dXJlR2FyYmFnZUNvbGxlY3RvciA9IHJlcXVpcmUoJy4vVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3InKTtcblxudmFyIF9UZXh0dXJlR2FyYmFnZUNvbGxlY3RvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0dXJlR2FyYmFnZUNvbGxlY3Rvcik7XG5cbnZhciBfV2ViR0xTdGF0ZSA9IHJlcXVpcmUoJy4vV2ViR0xTdGF0ZScpO1xuXG52YXIgX1dlYkdMU3RhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xTdGF0ZSk7XG5cbnZhciBfbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkgPSByZXF1aXJlKCcuL3V0aWxzL21hcFdlYkdMRHJhd01vZGVzVG9QaXhpJyk7XG5cbnZhciBfbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkpO1xuXG52YXIgX3ZhbGlkYXRlQ29udGV4dCA9IHJlcXVpcmUoJy4vdXRpbHMvdmFsaWRhdGVDb250ZXh0Jyk7XG5cbnZhciBfdmFsaWRhdGVDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkYXRlQ29udGV4dCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ09OVEVYVF9VSUQgPSAwO1xuXG4vKipcbiAqIFRoZSBXZWJHTFJlbmRlcmVyIGRyYXdzIHRoZSBzY2VuZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSB3ZWJHTCBlbmFibGVkIGNhbnZhcy4gVGhpcyByZW5kZXJlclxuICogc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB3ZWJHTC4gVGhpcyBSZW5kZXIgd29ya3MgYnkgYXV0b21hdGljYWxseSBtYW5hZ2luZyB3ZWJHTEJhdGNocy5cbiAqIFNvIG5vIG5lZWQgZm9yIFNwcml0ZSBCYXRjaGVzIG9yIFNwcml0ZSBDbG91ZHMuXG4gKiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSB2aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLlN5c3RlbVJlbmRlcmVyXG4gKi9cblxudmFyIFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoX1N5c3RlbVJlbmRlcmVyKSB7XG4gICAgX2luaGVyaXRzKFdlYkdMUmVuZGVyZXIsIF9TeXN0ZW1SZW5kZXJlcik7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NyZWVuV2lkdGg9ODAwXSAtIHRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY3JlZW5IZWlnaHQ9NjAwXSAtIHRoZSBoZWlnaHQgb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9uYWwgcmVuZGVyZXIgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtvcHRpb25zLnZpZXddIC0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSAtIElmIHRoZSByZW5kZXIgdmlldyBpcyBhdXRvbWF0aWNhbGx5IHJlc2l6ZWQsIGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0gLSBzZXRzIGFudGlhbGlhcy4gSWYgbm90IGF2YWlsYWJsZSBuYXRpdmVseSB0aGVuIEZYQUFcbiAgICAgKiAgYW50aWFsaWFzaW5nIGlzIHVzZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlRlhBQT1mYWxzZV0gLSBmb3JjZXMgRlhBQSBhbnRpYWxpYXNpbmcgdG8gYmUgdXNlZCBvdmVyIG5hdGl2ZS5cbiAgICAgKiAgRlhBQSBpcyBmYXN0ZXIsIGJ1dCBtYXkgbm90IGFsd2F5cyBsb29rIGFzIGdyZWF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICogIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIC0gVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyXG4gICAgICogIHRoZSBjYW52YXMgb3Igbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLiBJZiB5b3Ugd2lzaCB0byBzZXQgdGhpcyB0byBmYWxzZSwgeW91ICptdXN0KiBzZXRcbiAgICAgKiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyIHRvIGB0cnVlYC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0gLSBlbmFibGVzIGRyYXdpbmcgYnVmZmVyIHByZXNlcnZhdGlvbixcbiAgICAgKiAgZW5hYmxlIHRoaXMgaWYgeW91IG5lZWQgdG8gY2FsbCB0b0RhdGFVcmwgb24gdGhlIHdlYmdsIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0gLSBJZiB0cnVlIFBpeGkgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuXG4gICAgICogIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlZ2FjeT1mYWxzZV0gLSBJZiB0cnVlIFBpeGkgd2lsbCBhaW0gdG8gZW5zdXJlIGNvbXBhdGliaWxpdHlcbiAgICAgKiB3aXRoIG9sZGVyIC8gbGVzcyBhZHZhbmNlZCBkZXZpY2VzLiBJZiB5b3UgZXhwZXJpYW5jZSB1bmV4cGxhaW5lZCBmbGlja2VyaW5nIHRyeSBzZXR0aW5nIHRoaXMgdG8gdHJ1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJHTFJlbmRlcmVyKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTFJlbmRlcmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3lzdGVtUmVuZGVyZXIuY2FsbCh0aGlzLCAnV2ViR0wnLCBzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0LCBvcHRpb25zKSk7XG5cbiAgICAgICAgX3RoaXMubGVnYWN5ID0gISFvcHRpb25zLmxlZ2FjeTtcblxuICAgICAgICBpZiAoX3RoaXMubGVnYWN5KSB7XG4gICAgICAgICAgICBfcGl4aUdsQ29yZTIuZGVmYXVsdC5WZXJ0ZXhBcnJheU9iamVjdC5GT1JDRV9OQVRJVkUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgcmVuZGVyZXIgYXMgYSBzdGFuZGFyZGlzZWQgY29uc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIFBJWEkuUkVOREVSRVJfVFlQRVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudHlwZSA9IF9jb25zdC5SRU5ERVJFUl9UWVBFLldFQkdMO1xuXG4gICAgICAgIF90aGlzLmhhbmRsZUNvbnRleHRMb3N0ID0gX3RoaXMuaGFuZGxlQ29udGV4dExvc3QuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IF90aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZC5iaW5kKF90aGlzKTtcblxuICAgICAgICBfdGhpcy52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBfdGhpcy5oYW5kbGVDb250ZXh0TG9zdCwgZmFsc2UpO1xuICAgICAgICBfdGhpcy52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgX3RoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBpbiB0byBjcmVhdGUgYSBuZXcgd2ViZ2wgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2NvbnRleHRPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxwaGE6IF90aGlzLnRyYW5zcGFyZW50LFxuICAgICAgICAgICAgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogX3RoaXMudHJhbnNwYXJlbnQgJiYgX3RoaXMudHJhbnNwYXJlbnQgIT09ICdub3RNdWx0aXBsaWVkJyxcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX2JhY2tncm91bmRDb2xvclJnYmFbM10gPSBfdGhpcy50cmFuc3BhcmVudCA/IDAgOiAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBtYXNrcyB1c2luZyB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWFza01hbmFnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBfTWFza01hbmFnZXIyLmRlZmF1bHQoX3RoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBzdGVuY2lsIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGVuY2lsTWFuYWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnN0ZW5jaWxNYW5hZ2VyID0gbmV3IF9TdGVuY2lsTWFuYWdlcjIuZGVmYXVsdChfdGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVtcHR5IHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9iamVjdFJlbmRlcmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZW1wdHlSZW5kZXJlciA9IG5ldyBfT2JqZWN0UmVuZGVyZXIyLmRlZmF1bHQoX3RoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBPYmplY3RSZW5kZXJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYmplY3RSZW5kZXJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmN1cnJlbnRSZW5kZXJlciA9IF90aGlzLmVtcHR5UmVuZGVyZXI7XG5cbiAgICAgICAgX3RoaXMuaW5pdFBsdWdpbnMoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIGl0IGlzIGNyZWF0ZWQgaGVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBjb250ZXh0IHNvIGl0IGlzIHJlYWR5IGZvciB0aGUgbWFuYWdlcnMuXG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyB0byBzZWUgaWYgYSBjb250ZXh0IGlzIHZhbGlkLi5cbiAgICAgICAgICAgICgwLCBfdmFsaWRhdGVDb250ZXh0Mi5kZWZhdWx0KShvcHRpb25zLmNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZ2wgPSBvcHRpb25zLmNvbnRleHQgfHwgX3BpeGlHbENvcmUyLmRlZmF1bHQuY3JlYXRlQ29udGV4dChfdGhpcy52aWV3LCBfdGhpcy5fY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAgIF90aGlzLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSUQrKztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgT2JqZWN0UmVuZGVyZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuV2ViR0xTdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnN0YXRlID0gbmV3IF9XZWJHTFN0YXRlMi5kZWZhdWx0KF90aGlzLmdsKTtcblxuICAgICAgICBfdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRleHR1cmVzIGJvdW5kIHRvIHRoZSBHUFUuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJvdW5kVGV4dHVyZXMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyB0aGUgY3VycmVudCBzaGFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlbmRlclRhcmdldH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLl9pbml0Q29udGV4dCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBmaWx0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZpbHRlck1hbmFnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5maWx0ZXJNYW5hZ2VyID0gbmV3IF9GaWx0ZXJNYW5hZ2VyMi5kZWZhdWx0KF90aGlzKTtcbiAgICAgICAgLy8gbWFwIHNvbWUgd2ViR0wgYmxlbmQgYW5kIGRyYXdtb2Rlcy4uXG4gICAgICAgIF90aGlzLmRyYXdNb2RlcyA9ICgwLCBfbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkyLmRlZmF1bHQpKF90aGlzLmdsKTtcblxuICAgICAgICBfdGhpcy5fbmV4dFRleHR1cmVMb2NhdGlvbiA9IDA7XG5cbiAgICAgICAgX3RoaXMuc2V0QmxlbmRNb2RlKDApO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgV2ViR0wgY29udGV4dFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuX2luaXRDb250ZXh0ID0gZnVuY3Rpb24gX2luaXRDb250ZXh0KCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgYSBjb250ZXh0IGlmIGl0IHdhcyBwcmV2aW91c2x5IGxvc3RcbiAgICAgICAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSAmJiBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpKSB7XG4gICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpLnJlc3RvcmVDb250ZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuXG4gICAgICAgIHRoaXMuYm91bmRUZXh0dXJlcyA9IG5ldyBBcnJheShtYXhUZXh0dXJlcyk7XG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlcyA9IG5ldyBBcnJheShtYXhUZXh0dXJlcyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgdGV4dHVyZSBtYW5hZ2VyLi4uXG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgX1RleHR1cmVNYW5hZ2VyMi5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHR1cmVHQyA9IG5ldyBfVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3IyLmRlZmF1bHQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5yZXNldFRvRGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldCA9IG5ldyBfUmVuZGVyVGFyZ2V0Mi5kZWZhdWx0KGdsLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbnVsbCwgdGhpcy5yZXNvbHV0aW9uLCB0cnVlKTtcbiAgICAgICAgdGhpcy5yb290UmVuZGVyVGFyZ2V0LmNsZWFyQ29sb3IgPSB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhO1xuXG4gICAgICAgIHRoaXMuYmluZFJlbmRlclRhcmdldCh0aGlzLnJvb3RSZW5kZXJUYXJnZXQpO1xuXG4gICAgICAgIC8vIG5vdyBsZXRzIGZpbGwgdXAgdGhlIHRleHR1cmVzIHdpdGggZW1wdHkgb25lcyFcbiAgICAgICAgdmFyIGVtcHR5R0xUZXh0dXJlID0gbmV3IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMVGV4dHVyZS5mcm9tRGF0YShnbCwgbnVsbCwgMSwgMSk7XG5cbiAgICAgICAgdmFyIHRlbXBPYmogPSB7IF9nbFRleHR1cmVzOiB7fSB9O1xuXG4gICAgICAgIHRlbXBPYmouX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IG5ldyBfQmFzZVRleHR1cmUyLmRlZmF1bHQoKTtcblxuICAgICAgICAgICAgZW1wdHkuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gPSBlbXB0eUdMVGV4dHVyZTtcblxuICAgICAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gdGVtcE9iajtcbiAgICAgICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlc1tpXSA9IGVtcHR5O1xuICAgICAgICAgICAgdGhpcy5iaW5kVGV4dHVyZShudWxsLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29udGV4dCcsIGdsKTtcblxuICAgICAgICAvLyBzZXR1cCB0aGUgd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXMgYW5kIGdsIHZpZXdwb3J0XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMuc2NyZWVuLndpZHRoLCB0aGlzLnNjcmVlbi5oZWlnaHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gaXRzIHdlYkdMIHZpZXdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0IC0gdGhlIG9iamVjdCB0byBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSByZW5kZXJUZXh0dXJlIC0gVGhlIHJlbmRlciB0ZXh0dXJlIHRvIHJlbmRlciB0by5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhcl0gLSBTaG91bGQgdGhlIGNhbnZhcyBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgbmV3IHJlbmRlclxuICAgICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm19IFt0cmFuc2Zvcm1dIC0gQSB0cmFuc2Zvcm0gdG8gYXBwbHkgdG8gdGhlIHJlbmRlciB0ZXh0dXJlIGJlZm9yZSByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFVwZGF0ZVRyYW5zZm9ybV0gLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybSBwYXNzP1xuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoZGlzcGxheU9iamVjdCwgcmVuZGVyVGV4dHVyZSwgY2xlYXIsIHRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICAvLyBjYW4gYmUgaGFuZHkgdG8ga25vdyFcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9ICFyZW5kZXJUZXh0dXJlO1xuXG4gICAgICAgIHRoaXMuZW1pdCgncHJlcmVuZGVyJyk7XG5cbiAgICAgICAgLy8gbm8gcG9pbnQgcmVuZGVyaW5nIGlmIG91ciBjb250ZXh0IGhhcyBiZWVuIGJsb3duIHVwIVxuICAgICAgICBpZiAoIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX25leHRUZXh0dXJlTG9jYXRpb24gPSAwO1xuXG4gICAgICAgIGlmICghcmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gZGlzcGxheU9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBzY2VuZSBncmFwaFxuICAgICAgICAgICAgdmFyIGNhY2hlUGFyZW50ID0gZGlzcGxheU9iamVjdC5wYXJlbnQ7XG5cbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5wYXJlbnQgPSBjYWNoZVBhcmVudDtcbiAgICAgICAgICAgIC8vIGRpc3BsYXlPYmplY3QuaGl0QXJlYSA9IC8vVE9ETyBhZGQgYSB0ZW1wIGhpdCBhcmVhXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJpbmRSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUsIHRyYW5zZm9ybSk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcblxuICAgICAgICBpZiAoY2xlYXIgIT09IHVuZGVmaW5lZCA/IGNsZWFyIDogdGhpcy5jbGVhckJlZm9yZVJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0LmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcldlYkdMKHRoaXMpO1xuXG4gICAgICAgIC8vIGFwcGx5IHRyYW5zZm9ybS4uXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XG5cbiAgICAgICAgLy8gdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xuXG4gICAgICAgIHRoaXMudGV4dHVyZUdDLnVwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHJlbmRlcicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuT2JqZWN0UmVuZGVyZXJ9IG9iamVjdFJlbmRlcmVyIC0gVGhlIG9iamVjdCByZW5kZXJlciB0byB1c2UuXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldE9iamVjdFJlbmRlcmVyID0gZnVuY3Rpb24gc2V0T2JqZWN0UmVuZGVyZXIob2JqZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlbmRlcmVyID09PSBvYmplY3RSZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG9iamVjdFJlbmRlcmVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaWYgeW91IHdpc2ggdG8gZG8gc29tZSBjdXN0b20gcmVuZGVyaW5nXG4gICAgICogSXQgd2lsbCBiYXNpY2FsbHkgcmVuZGVyIGFueXRoaW5nIHRoYXQgbWF5IGJlIGJhdGNoZWQgdXAgc3VjaCBhcyBzcHJpdGVzXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSB3ZWJHTCB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5XaWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5IZWlnaHQgLSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgc2NyZWVuXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KSB7XG4gICAgICAgIC8vICBpZih3aWR0aCAqIHRoaXMucmVzb2x1dGlvbiA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb24gPT09IHRoaXMuaGVpZ2h0KXJldHVybjtcblxuICAgICAgICBfU3lzdGVtUmVuZGVyZXIzLmRlZmF1bHQucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuXG4gICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldC5yZXNpemUoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldCA9PT0gdGhpcy5yb290UmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RSZW5kZXJUYXJnZXQuYWN0aXZhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVNoYWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNoYWRlci51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5yb290UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSB3ZWJHTCB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibGVuZE1vZGUgLSB0aGUgZGVzaXJlZCBibGVuZCBtb2RlXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldEJsZW5kTW9kZSA9IGZ1bmN0aW9uIHNldEJsZW5kTW9kZShibGVuZE1vZGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRCbGVuZE1vZGUoYmxlbmRNb2RlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXJhc2VzIHRoZSBhY3RpdmUgcmVuZGVyIHRhcmdldCBhbmQgZmlsbHMgdGhlIGRyYXdpbmcgYXJlYSB3aXRoIGEgY29sb3VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NsZWFyQ29sb3JdIC0gVGhlIGNvbG91clxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKGNsZWFyQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0LmNsZWFyKGNsZWFyQ29sb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIGFjdGl2ZSByZW5kZXIgdGFyZ2V0IHRvIHRoZSBnaXZlbiBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gc2V0VHJhbnNmb3JtKG1hdHJpeCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQudHJhbnNmb3JtID0gbWF0cml4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFcmFzZXMgdGhlIHJlbmRlciB0ZXh0dXJlIGFuZCBmaWxscyB0aGUgZHJhd2luZyBhcmVhIHdpdGggYSBjb2xvdXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSByZW5kZXJUZXh0dXJlIC0gVGhlIHJlbmRlciB0ZXh0dXJlIHRvIGNsZWFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjbGVhckNvbG9yXSAtIFRoZSBjb2xvdXJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jbGVhclJlbmRlclRleHR1cmUgPSBmdW5jdGlvbiBjbGVhclJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSwgY2xlYXJDb2xvcikge1xuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gYmFzZVRleHR1cmUuX2dsUmVuZGVyVGFyZ2V0c1t0aGlzLkNPTlRFWFRfVUlEXTtcblxuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICByZW5kZXJUYXJnZXQuY2xlYXIoY2xlYXJDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgYSByZW5kZXIgdGV4dHVyZSBmb3IgcmVuZGVyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gcmVuZGVyVGV4dHVyZSAtIFRoZSByZW5kZXIgdGV4dHVyZSB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gLSBUaGUgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYmluZFJlbmRlclRleHR1cmUgPSBmdW5jdGlvbiBiaW5kUmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgICAgICAgICAgaWYgKCFiYXNlVGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzW3RoaXMuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICAgICAgLy8gYmluZCB0aGUgY3VycmVudCB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci51cGRhdGVUZXh0dXJlKGJhc2VUZXh0dXJlLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51bmJpbmRUZXh0dXJlKGJhc2VUZXh0dXJlKTtcblxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0ID0gYmFzZVRleHR1cmUuX2dsUmVuZGVyVGFyZ2V0c1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5zZXRGcmFtZShyZW5kZXJUZXh0dXJlLmZyYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldCA9IHRoaXMucm9vdFJlbmRlclRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclRhcmdldC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIHRoaXMuYmluZFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXQgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IHJlbmRlclRhcmdldCAtIHRoZSBuZXcgcmVuZGVyIHRhcmdldFxuICAgICAqIEByZXR1cm4ge1BJWEkuV2ViR0xSZW5kZXJlcn0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmJpbmRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiBiaW5kUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSByZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0ZW5jaWxNYW5hZ2VyLnNldE1hc2tTdGFjayhyZW5kZXJUYXJnZXQuc3RlbmNpbE1hc2tTdGFjayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBzaGFkZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5TaGFkZXJ9IHNoYWRlciAtIHRoZSBuZXcgc2hhZGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXV0b1Byb2plY3Q9dHJ1ZV0gLSBXaGV0aGVyIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqIEByZXR1cm4ge1BJWEkuV2ViR0xSZW5kZXJlcn0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmJpbmRTaGFkZXIgPSBmdW5jdGlvbiBiaW5kU2hhZGVyKHNoYWRlciwgYXV0b1Byb2plY3QpIHtcbiAgICAgICAgLy8gVE9ETyBjYWNoZVxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2hhZGVyICE9PSBzaGFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgICAgIHNoYWRlci5iaW5kKCk7XG5cbiAgICAgICAgICAgIC8vIGBhdXRvUHJvamVjdGAgbm9ybWFsbHkgd291bGQgYmUgYSBkZWZhdWx0IHBhcmFtZXRlciBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgLy8gYnV0IGJlY2F1c2Ugb2YgaG93IEJhYmVsIHRyYW5zcGlsZXMgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAvLyBpdCBoaW5kZXJzIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgIGlmIChhdXRvUHJvamVjdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHNldCB0aGUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldC5wcm9qZWN0aW9uTWF0cml4LnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIHRleHR1cmUuIFRoaXMgd2lsbCByZXR1cm4gdGhlIGxvY2F0aW9uIG9mIHRoZSBib3VuZCB0ZXh0dXJlLlxuICAgICAqIEl0IG1heSBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG9uZSB5b3UgcGFzcyBpbi4gVGhpcyBpcyBkdWUgdG8gb3B0aW1pc2F0aW9uIHRoYXQgcHJldmVudHNcbiAgICAgKiBuZWVkbGVzcyBiaW5kaW5nIG9mIHRleHR1cmVzLiBGb3IgZXhhbXBsZSBpZiB0aGUgdGV4dHVyZSBpcyBhbHJlYWR5IGJvdW5kIGl0IHdpbGwgcmV0dXJuIHRoZVxuICAgICAqIGN1cnJlbnQgbG9jYXRpb24gb2YgdGhlIHRleHR1cmUgaW5zdGVhZCBvZiB0aGUgb25lIHByb3ZpZGVkLiBUbyBieXBhc3MgdGhpcyB1c2UgZm9yY2UgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gdGhlIG5ldyB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvY2F0aW9uIC0gdGhlIHN1Z2dlc3RlZCB0ZXh0dXJlIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZUxvY2F0aW9uIC0gZm9yY2UgdGhlIGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYmluZFRleHR1cmUgPSBmdW5jdGlvbiBiaW5kVGV4dHVyZSh0ZXh0dXJlLCBsb2NhdGlvbiwgZm9yY2VMb2NhdGlvbikge1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZSB8fCB0aGlzLmVtcHR5VGV4dHVyZXNbbG9jYXRpb25dO1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xuICAgICAgICB0ZXh0dXJlLnRvdWNoZWQgPSB0aGlzLnRleHR1cmVHQy5jb3VudDtcblxuICAgICAgICBpZiAoIWZvcmNlTG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBtYXliZSBsb29rIGludG8gYWRkaW5nIGJvdW5kSWRzLi4gc2F2ZSB1cyB0aGUgbG9vcD9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFRleHR1cmVMb2NhdGlvbisrO1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRUZXh0dXJlTG9jYXRpb24gJT0gdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGggLSB0aGlzLl9uZXh0VGV4dHVyZUxvY2F0aW9uIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyBiaW5kIHRoZSB0ZXh0dXJlLi5cbiAgICAgICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIudXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCBsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gPSB0ZXh0dXJlO1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiB1bmJpbmRzIHRoZSB0ZXh0dXJlIC4uLlxuICAgICpcbiAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gdGhlIHRleHR1cmUgdG8gdW5iaW5kXG4gICAgKiBAcmV0dXJuIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxuICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnVuYmluZFRleHR1cmUgPSBmdW5jdGlvbiB1bmJpbmRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib3VuZFRleHR1cmVzW2ldID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gdGhpcy5lbXB0eVRleHR1cmVzW2ldO1xuXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuZW1wdHlUZXh0dXJlc1tpXS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS50ZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZBTyBmcm9tIHRoaXMgcmVuZGVyZXIncyBjb250ZXh0IGFuZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZlcnRleEFycmF5T2JqZWN0fSBUaGUgbmV3IFZBTy5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVmFvID0gZnVuY3Rpb24gY3JlYXRlVmFvKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9waXhpR2xDb3JlMi5kZWZhdWx0LlZlcnRleEFycmF5T2JqZWN0KHRoaXMuZ2wsIHRoaXMuc3RhdGUuYXR0cmliU3RhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IFZhbyB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlZlcnRleEFycmF5T2JqZWN0fSB2YW8gLSB0aGUgbmV3IFZhb1xuICAgICAqIEByZXR1cm4ge1BJWEkuV2ViR0xSZW5kZXJlcn0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmJpbmRWYW8gPSBmdW5jdGlvbiBiaW5kVmFvKHZhbykge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmFvID09PSB2YW8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbykge1xuICAgICAgICAgICAgdmFvLmJpbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hY3RpdmVWYW8pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYWx3YXlzIGJlIHRydWUgaSB0aGluaz9cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZhby51bmJpbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IHZhbztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBXZWJHTCBzdGF0ZSBzbyB5b3UgY2FuIHJlbmRlciB0aGluZ3MgaG93ZXZlciB5b3UgZmFuY3khXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gdGhpcy5yb290UmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIG1haW4gZnJhbWUgYnVmZmVyICh0aGUgc2NyZWVuKTtcbiAgICAgICAgdGhpcy5yb290UmVuZGVyVGFyZ2V0LmFjdGl2YXRlKCk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5yZXNldFRvRGVmYXVsdCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgbG9zdCB3ZWJnbCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7V2ViR0xDb250ZXh0RXZlbnR9IGV2ZW50IC0gVGhlIGNvbnRleHQgbG9zdCBldmVudC5cbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlQ29udGV4dExvc3QgPSBmdW5jdGlvbiBoYW5kbGVDb250ZXh0TG9zdChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgcmVzdG9yZWQgd2ViZ2wgY29udGV4dFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlQ29udGV4dFJlc3RvcmVkID0gZnVuY3Rpb24gaGFuZGxlQ29udGV4dFJlc3RvcmVkKCkge1xuICAgICAgICB0aGlzLl9pbml0Q29udGV4dCgpO1xuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbW92ZUFsbCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgKGV2ZW50IGxpc3RlbmVycywgc3ByaXRlYmF0Y2gsIGV0Yy4uLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZVZpZXc9ZmFsc2VdIC0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgICAqICBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9pc3N1ZXMvMjIzM1xuICAgICAqL1xuXG5cbiAgICBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShyZW1vdmVWaWV3KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpbnMoKTtcblxuICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCk7XG4gICAgICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcblxuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRlc3Ryb3koKTtcblxuICAgICAgICAvLyBjYWxsIGJhc2UgZGVzdHJveVxuICAgICAgICBfU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCByZW1vdmVWaWV3KTtcblxuICAgICAgICB0aGlzLnVpZCA9IDA7XG5cbiAgICAgICAgLy8gZGVzdHJveSB0aGUgbWFuYWdlcnNcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fY29udGV4dE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKSkge1xuICAgICAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgICAgICAvLyB0aGlzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdlYkdMUmVuZGVyZXI7XG59KF9TeXN0ZW1SZW5kZXJlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdlYkdMUmVuZGVyZXI7XG5cblxuX3V0aWxzLnBsdWdpblRhcmdldC5taXhpbihXZWJHTFJlbmRlcmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkdMUmVuZGVyZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9XZWJHTE1hbmFnZXIyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvV2ViR0xNYW5hZ2VyJyk7XG5cbnZhciBfV2ViR0xNYW5hZ2VyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dlYkdMTWFuYWdlcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQmFzZSBmb3IgYSBjb21tb24gb2JqZWN0IHJlbmRlcmVyIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBzeXN0ZW0gcmVuZGVyZXIgcGx1Z2luLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5XZWJHTE1hbmFnZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBPYmplY3RSZW5kZXJlciA9IGZ1bmN0aW9uIChfV2ViR0xNYW5hZ2VyKSB7XG4gIF9pbmhlcml0cyhPYmplY3RSZW5kZXJlciwgX1dlYkdMTWFuYWdlcik7XG5cbiAgZnVuY3Rpb24gT2JqZWN0UmVuZGVyZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFJlbmRlcmVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfV2ViR0xNYW5hZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcmVuZGVyZXIgYW5kIHNldHMgdGhlIHNoYWRlclxuICAgKlxuICAgKi9cbiAgT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7fVxuICAvLyBzZXQgdGhlIHNoYWRlci4uXG5cblxuICAvKipcbiAgICogU3RvcHMgdGhlIHJlbmRlcmVyXG4gICAqXG4gICAqL1xuICA7XG5cbiAgT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfTtcblxuICAvKipcbiAgICogU3R1YiBtZXRob2QgZm9yIHJlbmRlcmluZyBjb250ZW50IGFuZCBlbXB0eWluZyB0aGUgY3VycmVudCBiYXRjaC5cbiAgICpcbiAgICovXG5cblxuICBPYmplY3RSZW5kZXJlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHt9XG4gIC8vIGZsdXNoIVxuXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHJlbmRlci5cbiAgICovXG4gIDtcblxuICBPYmplY3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKG9iamVjdCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB7XG4gICAgLy8gcmVuZGVyIHRoZSBvYmplY3RcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0UmVuZGVyZXI7XG59KF9XZWJHTE1hbmFnZXIzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBPYmplY3RSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFJlbmRlcmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vLi4vLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfcGl4aUdsQ29yZSA9IHJlcXVpcmUoJ3BpeGktZ2wtY29yZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gdGhlIGhvcml6b250YWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIHRoZSB2ZXJ0aWNhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIC0gVGhlIGN1cnJlbnQgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpb1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyb290PWZhbHNlXSAtIFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgdGhlIHJvb3QgZWxlbWVudCBvciBub3RcbiAgICovXG4gIGZ1bmN0aW9uIFJlbmRlclRhcmdldChnbCwgd2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uLCByb290KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlclRhcmdldCk7XG5cbiAgICAvLyBUT0RPIFJlc29sdXRpb24gY291bGQgZ28gaGVyZSAoIGVnIGxvdyByZXMgYmx1cnMgKVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vIG5leHQgdGltZSB0byBjcmVhdGUgYSBmcmFtZSBidWZmZXIgYW5kIHRleHR1cmVcblxuICAgIC8qKlxuICAgICAqIEEgZnJhbWUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLmdsQ29yZS5HTEZyYW1lYnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuZ2xDb3JlLkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3VyIG9mIHRoaXMgcmVuZGVyIHRhcmdldCwgYXMgYW4gYXJyYXkgb2YgW3IsZyxiLGFdIHZhbHVlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICovXG4gICAgdGhpcy5jbGVhckNvbG9yID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgb2YgdGhlIG9iamVjdCBhcyBhIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgdGhpcy5zaXplID0gbmV3IF9tYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW9cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBfc2V0dGluZ3MyLmRlZmF1bHQuUkVTT0xVVElPTjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IF9tYXRoLk1hdHJpeCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCdzIHRyYW5zZm9ybVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RlbmNpbCBidWZmZXIgc3RvcmVzIG1hc2tpbmcgZGF0YSBmb3IgdGhlIHJlbmRlciB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2dsQ29yZS5HTEJ1ZmZlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRGcmFtZSA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuc291cmNlRnJhbWUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0ZW5jaWwgYnVmZmVyIHN0b3JlcyBtYXNraW5nIGRhdGEgZm9yIHRoZSByZW5kZXIgdGFyZ2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtnbENvcmUuR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIHN0ZW5jaWwgbWFza3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cbiAgICAgKi9cbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBmaWx0ZXIgZGF0YSBmb3IgdGhlIHJlbmRlciB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyRGF0YSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLlNDQUxFX01PREVcbiAgICAgKiBAc2VlIFBJWEkuU0NBTEVfTU9ERVNcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSAhPT0gdW5kZWZpbmVkID8gc2NhbGVNb2RlIDogX3NldHRpbmdzMi5kZWZhdWx0LlNDQUxFX01PREU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIHRoZSByb290IGVsZW1lbnQgb3Igbm90XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgdGhpcy5mcmFtZUJ1ZmZlciA9IF9waXhpR2xDb3JlLkdMRnJhbWVidWZmZXIuY3JlYXRlUkdCQShnbCwgMTAwLCAxMDApO1xuXG4gICAgICBpZiAodGhpcy5zY2FsZU1vZGUgPT09IF9jb25zdC5TQ0FMRV9NT0RFUy5ORUFSRVNUKSB7XG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIudGV4dHVyZS5lbmFibGVOZWFyZXN0U2NhbGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFtZUJ1ZmZlci50ZXh0dXJlLmVuYWJsZUxpbmVhclNjYWxpbmcoKTtcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgICAgQSBmcmFtZSBidWZmZXIgbmVlZHMgYSB0YXJnZXQgdG8gcmVuZGVyIHRvLi5cbiAgICAgICAgICBjcmVhdGUgYSB0ZXh0dXJlIGFuZCBiaW5kIGl0IGF0dGFjaCBpdCB0byB0aGUgZnJhbWVidWZmZXIuLlxuICAgICAgICovXG5cbiAgICAgIC8vIHRoaXMgaXMgdXNlZCBieSB0aGUgYmFzZSB0ZXh0dXJlXG4gICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLmZyYW1lQnVmZmVyLnRleHR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1ha2UgaXQgYSBudWxsIGZyYW1lYnVmZmVyLi5cbiAgICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBuZXcgX3BpeGlHbENvcmUuR0xGcmFtZWJ1ZmZlcihnbCwgMTAwLCAxMDApO1xuICAgICAgdGhpcy5mcmFtZUJ1ZmZlci5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRGcmFtZSgpO1xuXG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBmaWx0ZXIgdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gW2NsZWFyQ29sb3I9dGhpcy5jbGVhckNvbG9yXSAtIEFycmF5IG9mIFtyLGcsYixhXSB0byBjbGVhciB0aGUgZnJhbWVidWZmZXJcbiAgICovXG5cblxuICBSZW5kZXJUYXJnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoY2xlYXJDb2xvcikge1xuICAgIHZhciBjYyA9IGNsZWFyQ29sb3IgfHwgdGhpcy5jbGVhckNvbG9yO1xuXG4gICAgdGhpcy5mcmFtZUJ1ZmZlci5jbGVhcihjY1swXSwgY2NbMV0sIGNjWzJdLCBjY1szXSk7IC8vIHIsZyxiLGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAqXG4gICAqL1xuXG5cbiAgUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5hdHRhY2hTdGVuY2lsQnVmZmVyID0gZnVuY3Rpb24gYXR0YWNoU3RlbmNpbEJ1ZmZlcigpIHtcbiAgICAvLyBUT0RPIGNoZWNrIGlmIHN0ZW5jaWwgaXMgZG9uZT9cbiAgICAvKipcbiAgICAgKiBUaGUgc3RlbmNpbCBidWZmZXIgaXMgdXNlZCBmb3IgbWFza2luZyBpbiBwaXhpXG4gICAgICogbGV0cyBjcmVhdGUgb25lIGFuZCB0aGVuIGFkZCBhdHRhY2ggaXQgdG8gdGhlIGZyYW1lYnVmZmVyLi5cbiAgICAgKi9cbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgdGhpcy5mcmFtZUJ1ZmZlci5lbmFibGVTdGVuY2lsKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmcmFtZSBvZiB0aGUgcmVuZGVyIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWUgLSBUaGUgZGVzdGluYXRpb24gZnJhbWUuXG4gICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBzb3VyY2VGcmFtZSAtIFRoZSBzb3VyY2UgZnJhbWUuXG4gICAqL1xuXG5cbiAgUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIHNldEZyYW1lKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZWZhdWx0RnJhbWU7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IHNvdXJjZUZyYW1lIHx8IHRoaXMuc291cmNlRnJhbWUgfHwgZGVzdGluYXRpb25GcmFtZTtcbiAgfTtcblxuICAvKipcbiAgICogQmluZHMgdGhlIGJ1ZmZlcnMgYW5kIGluaXRpYWxpc2VzIHRoZSB2aWV3cG9ydC5cbiAgICpcbiAgICovXG5cblxuICBSZW5kZXJUYXJnZXQucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgLy8gVE9PRCByZWZhY3RvciB1c2FnZSBvZiBmcmFtZS4uXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGV4dHVyZSBpcyB1bmJvdW5kIVxuICAgIHRoaXMuZnJhbWVCdWZmZXIuYmluZCgpO1xuXG4gICAgdGhpcy5jYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuZGVzdGluYXRpb25GcmFtZSwgdGhpcy5zb3VyY2VGcmFtZSk7XG5cbiAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8gYWRkIGEgY2hlY2sgYXMgdGhlbSBtYXkgYmUgdGhlIHNhbWUhXG4gICAgaWYgKHRoaXMuZGVzdGluYXRpb25GcmFtZSAhPT0gdGhpcy5zb3VyY2VGcmFtZSkge1xuICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICBnbC5zY2lzc29yKHRoaXMuZGVzdGluYXRpb25GcmFtZS54IHwgMCwgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLnkgfCAwLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiB0aGlzLnJlc29sdXRpb24gfCAwLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uIHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gZG9lcyBub3QgbmVlZCB0byBiZSB1cGRhdGVkIGFsbCB0aGUgdGltZT8/XG4gICAgZ2wudmlld3BvcnQodGhpcy5kZXN0aW5hdGlvbkZyYW1lLnggfCAwLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueSB8IDAsIHRoaXMuZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIHRoaXMucmVzb2x1dGlvbiB8IDAsIHRoaXMuZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24gfCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggYmFzZWQgb24gYSBwcm9qZWN0aW9uIGZyYW1lICh3aGljaCBpcyBhIHJlY3RhbmdsZSlcbiAgICpcbiAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWUgLSBUaGUgZGVzdGluYXRpb24gZnJhbWUuXG4gICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBzb3VyY2VGcmFtZSAtIFRoZSBzb3VyY2UgZnJhbWUuXG4gICAqL1xuXG5cbiAgUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jYWxjdWxhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gY2FsY3VsYXRlUHJvamVjdGlvbihkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSkge1xuICAgIHZhciBwbSA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcblxuICAgIHNvdXJjZUZyYW1lID0gc291cmNlRnJhbWUgfHwgZGVzdGluYXRpb25GcmFtZTtcblxuICAgIHBtLmlkZW50aXR5KCk7XG5cbiAgICAvLyBUT0RPOiBtYWtlIGRlc3Qgc2NhbGUgc291cmNlXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgIHBtLmEgPSAxIC8gZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIDI7XG4gICAgICBwbS5kID0gMSAvIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogMjtcblxuICAgICAgcG0udHggPSAtMSAtIHNvdXJjZUZyYW1lLnggKiBwbS5hO1xuICAgICAgcG0udHkgPSAtMSAtIHNvdXJjZUZyYW1lLnkgKiBwbS5kO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbS5hID0gMSAvIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiAyO1xuICAgICAgcG0uZCA9IC0xIC8gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiAyO1xuXG4gICAgICBwbS50eCA9IC0xIC0gc291cmNlRnJhbWUueCAqIHBtLmE7XG4gICAgICBwbS50eSA9IDEgLSBzb3VyY2VGcmFtZS55ICogcG0uZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIHRleHR1cmUgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqL1xuXG5cbiAgUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHdpZHRoID0gd2lkdGggfCAwO1xuICAgIGhlaWdodCA9IGhlaWdodCB8IDA7XG5cbiAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSB3aWR0aCAmJiB0aGlzLnNpemUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNpemUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5kZWZhdWx0RnJhbWUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmRlZmF1bHRGcmFtZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmZyYW1lQnVmZmVyLnJlc2l6ZSh3aWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgIHZhciBwcm9qZWN0aW9uRnJhbWUgPSB0aGlzLmZyYW1lIHx8IHRoaXMuc2l6ZTtcblxuICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uRnJhbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcmVuZGVyIHRhcmdldC5cbiAgICpcbiAgICovXG5cblxuICBSZW5kZXJUYXJnZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuZnJhbWVCdWZmZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5mcmFtZUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUmVuZGVyVGFyZ2V0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJUYXJnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUYXJnZXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDA3LjAzLjIwMTcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NCYXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEVsZW0oKSB7XHJcbiAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2xvYWRlcicpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xyXG4gICAgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbWVudS9lbGVtZW50cy9Qcm9ncmVzc0Jhci5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBCaXQgdHdpZGRsaW5nIGhhY2tzIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEF1dGhvcjogTWlrb2xhIEx5c2Vua29cbiAqXG4gKiBQb3J0ZWQgZnJvbSBTdGFuZm9yZCBiaXQgdHdpZGRsaW5nIGhhY2sgbGlicmFyeTpcbiAqICAgIGh0dHA6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbFxuICovXG5cblwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG4vL051bWJlciBvZiBiaXRzIGluIGFuIGludGVnZXJcbnZhciBJTlRfQklUUyA9IDMyO1xuXG4vL0NvbnN0YW50c1xuZXhwb3J0cy5JTlRfQklUUyAgPSBJTlRfQklUUztcbmV4cG9ydHMuSU5UX01BWCAgID0gIDB4N2ZmZmZmZmY7XG5leHBvcnRzLklOVF9NSU4gICA9IC0xPDwoSU5UX0JJVFMtMSk7XG5cbi8vUmV0dXJucyAtMSwgMCwgKzEgZGVwZW5kaW5nIG9uIHNpZ24gb2YgeFxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKHYgPiAwKSAtICh2IDwgMCk7XG59XG5cbi8vQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgaW50ZWdlclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBtYXNrID0gdiA+PiAoSU5UX0JJVFMtMSk7XG4gIHJldHVybiAodiBeIG1hc2spIC0gbWFzaztcbn1cblxuLy9Db21wdXRlcyBtaW5pbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWluID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geSBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NvbXB1dGVzIG1heGltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB4IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXG5leHBvcnRzLmlzUG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICEodiAmICh2LTEpKSAmJiAoISF2KTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAyIG9mIHZcbmV4cG9ydHMubG9nMiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHIsIHNoaWZ0O1xuICByID0gICAgICh2ID4gMHhGRkZGKSA8PCA0OyB2ID4+Pj0gcjtcbiAgc2hpZnQgPSAodiA+IDB4RkYgICkgPDwgMzsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHhGICAgKSA8PCAyOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweDMgICApIDw8IDE7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCAodiA+PiAxKTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAxMCBvZiB2XG5leHBvcnRzLmxvZzEwID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gICh2ID49IDEwMDAwMDAwMDApID8gOSA6ICh2ID49IDEwMDAwMDAwMCkgPyA4IDogKHYgPj0gMTAwMDAwMDApID8gNyA6XG4gICAgICAgICAgKHYgPj0gMTAwMDAwMCkgPyA2IDogKHYgPj0gMTAwMDAwKSA/IDUgOiAodiA+PSAxMDAwMCkgPyA0IDpcbiAgICAgICAgICAodiA+PSAxMDAwKSA/IDMgOiAodiA+PSAxMDApID8gMiA6ICh2ID49IDEwKSA/IDEgOiAwO1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgYml0c1xuZXhwb3J0cy5wb3BDb3VudCA9IGZ1bmN0aW9uKHYpIHtcbiAgdiA9IHYgLSAoKHYgPj4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICByZXR1cm4gKCh2ICsgKHYgPj4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4+IDI0O1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcyh2KSB7XG4gIHZhciBjID0gMzI7XG4gIHYgJj0gLXY7XG4gIGlmICh2KSBjLS07XG4gIGlmICh2ICYgMHgwMDAwRkZGRikgYyAtPSAxNjtcbiAgaWYgKHYgJiAweDAwRkYwMEZGKSBjIC09IDg7XG4gIGlmICh2ICYgMHgwRjBGMEYwRikgYyAtPSA0O1xuICBpZiAodiAmIDB4MzMzMzMzMzMpIGMgLT0gMjtcbiAgaWYgKHYgJiAweDU1NTU1NTU1KSBjIC09IDE7XG4gIHJldHVybiBjO1xufVxuZXhwb3J0cy5jb3VudFRyYWlsaW5nWmVyb3MgPSBjb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8vUm91bmRzIHRvIG5leHQgcG93ZXIgb2YgMlxuZXhwb3J0cy5uZXh0UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiArPSB2ID09PSAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuXG4vL1JvdW5kcyBkb3duIHRvIHByZXZpb3VzIHBvd2VyIG9mIDJcbmV4cG9ydHMucHJldlBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgLSAodj4+PjEpO1xufVxuXG4vL0NvbXB1dGVzIHBhcml0eSBvZiB3b3JkXG5leHBvcnRzLnBhcml0eSA9IGZ1bmN0aW9uKHYpIHtcbiAgdiBePSB2ID4+PiAxNjtcbiAgdiBePSB2ID4+PiA4O1xuICB2IF49IHYgPj4+IDQ7XG4gIHYgJj0gMHhmO1xuICByZXR1cm4gKDB4Njk5NiA+Pj4gdikgJiAxO1xufVxuXG52YXIgUkVWRVJTRV9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4oZnVuY3Rpb24odGFiKSB7XG4gIGZvcih2YXIgaT0wOyBpPDI1NjsgKytpKSB7XG4gICAgdmFyIHYgPSBpLCByID0gaSwgcyA9IDc7XG4gICAgZm9yICh2ID4+Pj0gMTsgdjsgdiA+Pj49IDEpIHtcbiAgICAgIHIgPDw9IDE7XG4gICAgICByIHw9IHYgJiAxO1xuICAgICAgLS1zO1xuICAgIH1cbiAgICB0YWJbaV0gPSAociA8PCBzKSAmIDB4ZmY7XG4gIH1cbn0pKFJFVkVSU0VfVEFCTEUpO1xuXG4vL1JldmVyc2UgYml0cyBpbiBhIDMyIGJpdCB3b3JkXG5leHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKFJFVkVSU0VfVEFCTEVbIHYgICAgICAgICAmIDB4ZmZdIDw8IDI0KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDgpICAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDE2KSAmIDB4ZmZdIDw8IDgpICB8XG4gICAgICAgICAgIFJFVkVSU0VfVEFCTEVbKHYgPj4+IDI0KSAmIDB4ZmZdO1xufVxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAyIGNvb3JkaW5hdGVzIHdpdGggMTYgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBxdWFkdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCAmPSAweEZGRkY7XG4gIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgeSAmPSAweEZGRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy9FeHRyYWN0cyB0aGUgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudFxuZXhwb3J0cy5kZWludGVybGVhdmUyID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICYgMHg1NTU1NTU1NTtcbiAgdiA9ICh2IHwgKHYgPj4+IDEpKSAgJiAweDMzMzMzMzMzO1xuICB2ID0gKHYgfCAodiA+Pj4gMikpICAmIDB4MEYwRjBGMEY7XG4gIHYgPSAodiB8ICh2ID4+PiA0KSkgICYgMHgwMEZGMDBGRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDE2KSkgJiAweDAwMEZGRkY7XG4gIHJldHVybiAodiA8PCAxNikgPj4gMTY7XG59XG5cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMyBjb29yZGluYXRlcywgZWFjaCB3aXRoIDEwIGJpdHMuICBVc2VmdWwgZm9yIGZhc3Qgb2N0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB4ICY9IDB4M0ZGO1xuICB4ICA9ICh4IHwgKHg8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB4ICA9ICh4IHwgKHg8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHggID0gKHggfCAoeDw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHggID0gKHggfCAoeDw8MikpICAmIDEyMjcxMzM1MTM7XG5cbiAgeSAmPSAweDNGRjtcbiAgeSAgPSAoeSB8ICh5PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeSAgPSAoeSB8ICh5PDw4KSkgICYgMjUxNzE5Njk1O1xuICB5ICA9ICh5IHwgKHk8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB5ICA9ICh5IHwgKHk8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICB4IHw9ICh5IDw8IDEpO1xuICBcbiAgeiAmPSAweDNGRjtcbiAgeiAgPSAoeiB8ICh6PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeiAgPSAoeiB8ICh6PDw4KSkgICYgMjUxNzE5Njk1O1xuICB6ICA9ICh6IHwgKHo8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB6ICA9ICh6IHwgKHo8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICBcbiAgcmV0dXJuIHggfCAoeiA8PCAyKTtcbn1cblxuLy9FeHRyYWN0cyBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50IG9mIGEgMy10dXBsZVxuZXhwb3J0cy5kZWludGVybGVhdmUzID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICAgICAgICYgMTIyNzEzMzUxMztcbiAgdiA9ICh2IHwgKHY+Pj4yKSkgICAmIDMyNzIzNTYwMzU7XG4gIHYgPSAodiB8ICh2Pj4+NCkpICAgJiAyNTE3MTk2OTU7XG4gIHYgPSAodiB8ICh2Pj4+OCkpICAgJiA0Mjc4MTkwMzM1O1xuICB2ID0gKHYgfCAodj4+PjE2KSkgICYgMHgzRkY7XG4gIHJldHVybiAodjw8MjIpPj4yMjtcbn1cblxuLy9Db21wdXRlcyBuZXh0IGNvbWJpbmF0aW9uIGluIGNvbGV4aWNvZ3JhcGhpYyBvcmRlciAodGhpcyBpcyBtaXN0YWtlbmx5IGNhbGxlZCBuZXh0UGVybXV0YXRpb24gb24gdGhlIGJpdCB0d2lkZGxpbmcgaGFja3MgcGFnZSlcbmV4cG9ydHMubmV4dENvbWJpbmF0aW9uID0gZnVuY3Rpb24odikge1xuICB2YXIgdCA9IHYgfCAodiAtIDEpO1xuICByZXR1cm4gKHQgKyAxKSB8ICgoKH50ICYgLX50KSAtIDEpID4+PiAoY291bnRUcmFpbGluZ1plcm9zKHYpICsgMSkpO1xufVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYml0LXR3aWRkbGUvdHdpZGRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbnZhciBtYXBTaXplID0gZnVuY3Rpb24oZ2wsIHR5cGUpIFxue1xuICAgIGlmKCFHTF9UQUJMRSkgXG4gICAge1xuICAgICAgICB2YXIgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG5cbiAgICAgICAgR0xfVEFCTEUgPSB7fTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdHlwZU5hbWVzLmxlbmd0aDsgKytpKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRuID0gdHlwZU5hbWVzW2ldO1xuICAgICAgICAgICAgR0xfVEFCTEVbIGdsW3RuXSBdID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIEdMX1RBQkxFW3R5cGVdO1xufTtcblxudmFyIEdMX1RBQkxFID0gbnVsbDtcblxudmFyIEdMX1RPX0dMU0xfVFlQRVMgPSB7XG4gICdGTE9BVCc6ICAgICAgICdmbG9hdCcsXG4gICdGTE9BVF9WRUMyJzogICd2ZWMyJyxcbiAgJ0ZMT0FUX1ZFQzMnOiAgJ3ZlYzMnLFxuICAnRkxPQVRfVkVDNCc6ICAndmVjNCcsXG5cbiAgJ0lOVCc6ICAgICAgICAgJ2ludCcsXG4gICdJTlRfVkVDMic6ICAgICdpdmVjMicsXG4gICdJTlRfVkVDMyc6ICAgICdpdmVjMycsXG4gICdJTlRfVkVDNCc6ICAgICdpdmVjNCcsXG4gIFxuICAnQk9PTCc6ICAgICAgICAnYm9vbCcsXG4gICdCT09MX1ZFQzInOiAgICdidmVjMicsXG4gICdCT09MX1ZFQzMnOiAgICdidmVjMycsXG4gICdCT09MX1ZFQzQnOiAgICdidmVjNCcsXG4gIFxuICAnRkxPQVRfTUFUMic6ICAnbWF0MicsXG4gICdGTE9BVF9NQVQzJzogICdtYXQzJyxcbiAgJ0ZMT0FUX01BVDQnOiAgJ21hdDQnLFxuICBcbiAgJ1NBTVBMRVJfMkQnOiAgJ3NhbXBsZXIyRCcgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXBTaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL21hcFR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqICdCdWlsZGVyJyBwYXR0ZXJuIGZvciBib3VuZHMgcmVjdGFuZ2xlc1xuICogQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveFxuICogSXQgaXMgbm90IGEgc2hhcGUhIEl0cyBtdXRhYmxlIHRoaW5nLCBubyAnRU1QVFknIG9yIHRoYXQga2luZCBvZiBwcm9ibGVtc1xuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kcygpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJvdW5kcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgICB0aGlzLnJlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBib3VuZHMgYXJlIGVtcHR5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlbXB0eS5cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgYm91bmRzIGFuZCByZXNldHMuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUlEKys7XG5cbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHJldHVybiBSZWN0YW5nbGUuRU1QVFkgY29uc3RhbnQsIGVpdGhlciBjb25zdHJ1Y3QgbmV3IHJlY3RhbmdsZSwgZWl0aGVyIHVzZSB5b3VyIHJlY3RhbmdsZVxuICAgICAqIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgaXQgd2lsbCByZXR1cm4gdGVtcFJlY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSB0ZW1wb3Jhcnkgb2JqZWN0IHdpbGwgYmUgdXNlZCBpZiBBQUJCIGlzIG5vdCBlbXB0eVxuICAgICAqIEByZXR1cm5zIHtQSVhJLlJlY3RhbmdsZX0gQSByZWN0YW5nbGUgb2YgdGhlIGJvdW5kc1xuICAgICAqL1xuXG5cbiAgICBCb3VuZHMucHJvdG90eXBlLmdldFJlY3RhbmdsZSA9IGZ1bmN0aW9uIGdldFJlY3RhbmdsZShyZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLm1pblggPiB0aGlzLm1heFggfHwgdGhpcy5taW5ZID4gdGhpcy5tYXhZKSB7XG4gICAgICAgICAgICByZXR1cm4gX21hdGguUmVjdGFuZ2xlLkVNUFRZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgbmV3IF9tYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgICAgICByZWN0LnggPSB0aGlzLm1pblg7XG4gICAgICAgIHJlY3QueSA9IHRoaXMubWluWTtcbiAgICAgICAgcmVjdC53aWR0aCA9IHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIGFkZC5cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIGFkZFBvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcG9pbnQueCk7XG4gICAgICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgcG9pbnQueCk7XG4gICAgICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgcG9pbnQueSk7XG4gICAgICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcG9pbnQueSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBxdWFkLCBub3QgdHJhbnNmb3JtZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0aWNlcyAtIFRoZSB2ZXJ0cyB0byBhZGQuXG4gICAgICovXG5cblxuICAgIEJvdW5kcy5wcm90b3R5cGUuYWRkUXVhZCA9IGZ1bmN0aW9uIGFkZFF1YWQodmVydGljZXMpIHtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG5cbiAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgdmFyIHkgPSB2ZXJ0aWNlc1sxXTtcblxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB4ID0gdmVydGljZXNbMl07XG4gICAgICAgIHkgPSB2ZXJ0aWNlc1szXTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG5cbiAgICAgICAgeCA9IHZlcnRpY2VzWzRdO1xuICAgICAgICB5ID0gdmVydGljZXNbNV07XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuXG4gICAgICAgIHggPSB2ZXJ0aWNlc1s2XTtcbiAgICAgICAgeSA9IHZlcnRpY2VzWzddO1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtQmFzZX0gdHJhbnNmb3JtIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTAgLSBUT0RPXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRPRE9cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5hZGRGcmFtZSA9IGZ1bmN0aW9uIGFkZEZyYW1lKHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGEgPSBtYXRyaXguYTtcbiAgICAgICAgdmFyIGIgPSBtYXRyaXguYjtcbiAgICAgICAgdmFyIGMgPSBtYXRyaXguYztcbiAgICAgICAgdmFyIGQgPSBtYXRyaXguZDtcbiAgICAgICAgdmFyIHR4ID0gbWF0cml4LnR4O1xuICAgICAgICB2YXIgdHkgPSBtYXRyaXgudHk7XG5cbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG5cbiAgICAgICAgdmFyIHggPSBhICogeDAgKyBjICogeTAgKyB0eDtcbiAgICAgICAgdmFyIHkgPSBiICogeDAgKyBkICogeTAgKyB0eTtcblxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB4ID0gYSAqIHgxICsgYyAqIHkwICsgdHg7XG4gICAgICAgIHkgPSBiICogeDEgKyBkICogeTAgKyB0eTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG5cbiAgICAgICAgeCA9IGEgKiB4MCArIGMgKiB5MSArIHR4O1xuICAgICAgICB5ID0gYiAqIHgwICsgZCAqIHkxICsgdHk7XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuXG4gICAgICAgIHggPSBhICogeDEgKyBjICogeTEgKyB0eDtcbiAgICAgICAgeSA9IGIgKiB4MSArIGQgKiB5MSArIHR5O1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcblxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm1CYXNlfSB0cmFuc2Zvcm0gLSBUT0RPXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZlcnRpY2VzIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbk9mZnNldCAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IC0gVE9ET1xuICAgICAqL1xuXG5cbiAgICBCb3VuZHMucHJvdG90eXBlLmFkZFZlcnRpY2VzID0gZnVuY3Rpb24gYWRkVmVydGljZXModHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IG1hdHJpeC5hO1xuICAgICAgICB2YXIgYiA9IG1hdHJpeC5iO1xuICAgICAgICB2YXIgYyA9IG1hdHJpeC5jO1xuICAgICAgICB2YXIgZCA9IG1hdHJpeC5kO1xuICAgICAgICB2YXIgdHggPSBtYXRyaXgudHg7XG4gICAgICAgIHZhciB0eSA9IG1hdHJpeC50eTtcblxuICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xuICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcblxuICAgICAgICBmb3IgKHZhciBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIHJhd1ggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciByYXdZID0gdmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIHggPSBhICogcmF3WCArIGMgKiByYXdZICsgdHg7XG4gICAgICAgICAgICB2YXIgeSA9IGQgKiByYXdZICsgYiAqIHJhd1ggKyB0eTtcblxuICAgICAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gYm91bmRzIC0gVE9ET1xuICAgICAqL1xuXG5cbiAgICBCb3VuZHMucHJvdG90eXBlLmFkZEJvdW5kcyA9IGZ1bmN0aW9uIGFkZEJvdW5kcyhib3VuZHMpIHtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG5cbiAgICAgICAgdGhpcy5taW5YID0gYm91bmRzLm1pblggPCBtaW5YID8gYm91bmRzLm1pblggOiBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBib3VuZHMubWluWSA8IG1pblkgPyBib3VuZHMubWluWSA6IG1pblk7XG4gICAgICAgIHRoaXMubWF4WCA9IGJvdW5kcy5tYXhYID4gbWF4WCA/IGJvdW5kcy5tYXhYIDogbWF4WDtcbiAgICAgICAgdGhpcy5tYXhZID0gYm91bmRzLm1heFkgPiBtYXhZID8gYm91bmRzLm1heFkgOiBtYXhZO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQm91bmRzfSBib3VuZHMgLSBUT0RPXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gbWFzayAtIFRPRE9cbiAgICAgKi9cblxuXG4gICAgQm91bmRzLnByb3RvdHlwZS5hZGRCb3VuZHNNYXNrID0gZnVuY3Rpb24gYWRkQm91bmRzTWFzayhib3VuZHMsIG1hc2spIHtcbiAgICAgICAgdmFyIF9taW5YID0gYm91bmRzLm1pblggPiBtYXNrLm1pblggPyBib3VuZHMubWluWCA6IG1hc2subWluWDtcbiAgICAgICAgdmFyIF9taW5ZID0gYm91bmRzLm1pblkgPiBtYXNrLm1pblkgPyBib3VuZHMubWluWSA6IG1hc2subWluWTtcbiAgICAgICAgdmFyIF9tYXhYID0gYm91bmRzLm1heFggPCBtYXNrLm1heFggPyBib3VuZHMubWF4WCA6IG1hc2subWF4WDtcbiAgICAgICAgdmFyIF9tYXhZID0gYm91bmRzLm1heFkgPCBtYXNrLm1heFkgPyBib3VuZHMubWF4WSA6IG1hc2subWF4WTtcblxuICAgICAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuXG4gICAgICAgICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblg7XG4gICAgICAgICAgICB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblk7XG4gICAgICAgICAgICB0aGlzLm1heFggPSBfbWF4WCA+IG1heFggPyBfbWF4WCA6IG1heFg7XG4gICAgICAgICAgICB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBvdGhlciBCb3VuZHMsIG1hc2tlZCB3aXRoIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gYm91bmRzIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGFyZWEgLSBUT0RPXG4gICAgICovXG5cblxuICAgIEJvdW5kcy5wcm90b3R5cGUuYWRkQm91bmRzQXJlYSA9IGZ1bmN0aW9uIGFkZEJvdW5kc0FyZWEoYm91bmRzLCBhcmVhKSB7XG4gICAgICAgIHZhciBfbWluWCA9IGJvdW5kcy5taW5YID4gYXJlYS54ID8gYm91bmRzLm1pblggOiBhcmVhLng7XG4gICAgICAgIHZhciBfbWluWSA9IGJvdW5kcy5taW5ZID4gYXJlYS55ID8gYm91bmRzLm1pblkgOiBhcmVhLnk7XG4gICAgICAgIHZhciBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgYXJlYS54ICsgYXJlYS53aWR0aCA/IGJvdW5kcy5tYXhYIDogYXJlYS54ICsgYXJlYS53aWR0aDtcbiAgICAgICAgdmFyIF9tYXhZID0gYm91bmRzLm1heFkgPCBhcmVhLnkgKyBhcmVhLmhlaWdodCA/IGJvdW5kcy5tYXhZIDogYXJlYS55ICsgYXJlYS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XG4gICAgICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcblxuICAgICAgICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xuICAgICAgICAgICAgdGhpcy5taW5ZID0gX21pblkgPCBtaW5ZID8gX21pblkgOiBtaW5ZO1xuICAgICAgICAgICAgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYO1xuICAgICAgICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBCb3VuZHM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJvdW5kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvdW5kcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L0JvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi9tYXRoJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogR2VuZXJpYyBjbGFzcyB0byBkZWFsIHdpdGggdHJhZGl0aW9uYWwgMkQgbWF0cml4IHRyYW5zZm9ybXNcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUcmFuc2Zvcm1CYXNlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybUJhc2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybUJhc2UpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBtYXRyaXggdHJhbnNmb3JtLiBJdCBjYW4gYmUgc3dhcHBlZCB0ZW1wb3JhcmlseSBieSBzb21lIGZ1bmN0aW9ucyBsaWtlIGdldExvY2FsQm91bmRzKClcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgX21hdGguTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgbWF0cml4IHRyYW5zZm9ybVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbFRyYW5zZm9ybSA9IG5ldyBfbWF0aC5NYXRyaXgoKTtcblxuICAgIHRoaXMuX3dvcmxkSUQgPSAwO1xuICAgIHRoaXMuX3BhcmVudElEID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1CYXNlIGRvZXMgbm90IGhhdmUgZGVjb21wb3NpdGlvbiwgc28gdGhpcyBmdW5jdGlvbiB3b250IGRvIGFueXRoaW5nXG4gICAqL1xuXG5cbiAgVHJhbnNmb3JtQmFzZS5wcm90b3R5cGUudXBkYXRlTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHt9XG4gIC8vIGVtcHR5XG5cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QgYW5kIGFwcGxpZXMgdGhlIHBhcmVudCdzIHRyYW5zZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybUJhc2V9IHBhcmVudFRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gb2YgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdFxuICAgKi9cbiAgO1xuXG4gIFRyYW5zZm9ybUJhc2UucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIHVwZGF0ZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0pIHtcbiAgICB2YXIgcHQgPSBwYXJlbnRUcmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuXG4gICAgLy8gY29uY2F0IHRoZSBwYXJlbnQgbWF0cml4IHdpdGggdGhlIG9iamVjdHMgdHJhbnNmb3JtLlxuICAgIHd0LmEgPSBsdC5hICogcHQuYSArIGx0LmIgKiBwdC5jO1xuICAgIHd0LmIgPSBsdC5hICogcHQuYiArIGx0LmIgKiBwdC5kO1xuICAgIHd0LmMgPSBsdC5jICogcHQuYSArIGx0LmQgKiBwdC5jO1xuICAgIHd0LmQgPSBsdC5jICogcHQuYiArIGx0LmQgKiBwdC5kO1xuICAgIHd0LnR4ID0gbHQudHggKiBwdC5hICsgbHQudHkgKiBwdC5jICsgcHQudHg7XG4gICAgd3QudHkgPSBsdC50eCAqIHB0LmIgKyBsdC50eSAqIHB0LmQgKyBwdC50eTtcblxuICAgIHRoaXMuX3dvcmxkSUQrKztcbiAgfTtcblxuICByZXR1cm4gVHJhbnNmb3JtQmFzZTtcbn0oKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCBhbmQgYXBwbGllcyB0aGUgcGFyZW50J3MgdHJhbnNmb3JtLlxuICogQHBhcmFtICBwYXJlbnRUcmFuc2Zvcm0ge1BJWEkuVHJhbnNmb3JtfSBUaGUgdHJhbnNmb3JtIG9mIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3RcbiAqXG4gKi9cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2Zvcm1CYXNlO1xuVHJhbnNmb3JtQmFzZS5wcm90b3R5cGUudXBkYXRlV29ybGRUcmFuc2Zvcm0gPSBUcmFuc2Zvcm1CYXNlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm07XG5cblRyYW5zZm9ybUJhc2UuSURFTlRJVFkgPSBuZXcgVHJhbnNmb3JtQmFzZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtQmFzZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L1RyYW5zZm9ybUJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoZSBQb2ludCBvYmplY3QgcmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgdHdvLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUgc3lzdGVtLCB3aGVyZSB4IHJlcHJlc2VudHNcbiAqIHRoZSBob3Jpem9udGFsIGF4aXMgYW5kIHkgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludCgpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludCk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHg7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAgICpcbiAgICogQHJldHVybiB7UElYSS5Qb2ludH0gYSBjb3B5IG9mIHRoZSBwb2ludFxuICAgKi9cblxuXG4gIFBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgeCBhbmQgeSBmcm9tIHRoZSBnaXZlbiBwb2ludFxuICAgKlxuICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY29weS5cbiAgICovXG5cblxuICBQb2ludC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkocCkge1xuICAgIHRoaXMuc2V0KHAueCwgcC55KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAqXG4gICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgKi9cblxuXG4gIFBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMocCkge1xuICAgIHJldHVybiBwLnggPT09IHRoaXMueCAmJiBwLnkgPT09IHRoaXMueTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgeCBhbmQgeSBwb3NpdGlvbi5cbiAgICogSWYgeSBpcyBvbWl0dGVkLCBib3RoIHggYW5kIHkgd2lsbCBiZSBzZXQgdG8geC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICovXG5cblxuICBQb2ludC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAoeSAhPT0gMCA/IHRoaXMueCA6IDApO1xuICB9O1xuXG4gIHJldHVybiBQb2ludDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFJlY3RhbmdsZSBvYmplY3QgaXMgYW4gYXJlYSBkZWZpbmVkIGJ5IGl0cyBwb3NpdGlvbiwgYXMgaW5kaWNhdGVkIGJ5IGl0cyB0b3AtbGVmdCBjb3JuZXJcbiAqIHBvaW50ICh4LCB5KSBhbmQgYnkgaXRzIHdpZHRoIGFuZCBpdHMgaGVpZ2h0LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MF0gLSBUaGUgb3ZlcmFsbCB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTBdIC0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVjdGFuZ2xlKCkge1xuICAgICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdGFuZ2xlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlJFQ1RcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5SRUNUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGxlZnQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IGEgY29weSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW5vdGhlciByZWN0YW5nbGUgdG8gdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkuXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuXG5cbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHJlY3RhbmdsZSkge1xuICAgICAgICB0aGlzLnggPSByZWN0YW5nbGUueDtcbiAgICAgICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgICAgIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gICAgICovXG5cblxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyh4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPj0gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgdGhlIHJlY3RhbmdsZSBtYWtpbmcgaXQgZ3JvdyBpbiBhbGwgZGlyZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nWCAtIFRoZSBob3Jpem9udGFsIHBhZGRpbmcgYW1vdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cbiAgICAgKi9cblxuXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiBwYWQocGFkZGluZ1gsIHBhZGRpbmdZKSB7XG4gICAgICAgIHBhZGRpbmdYID0gcGFkZGluZ1ggfHwgMDtcbiAgICAgICAgcGFkZGluZ1kgPSBwYWRkaW5nWSB8fCAocGFkZGluZ1kgIT09IDAgPyBwYWRkaW5nWCA6IDApO1xuXG4gICAgICAgIHRoaXMueCAtPSBwYWRkaW5nWDtcbiAgICAgICAgdGhpcy55IC09IHBhZGRpbmdZO1xuXG4gICAgICAgIHRoaXMud2lkdGggKz0gcGFkZGluZ1ggKiAyO1xuICAgICAgICB0aGlzLmhlaWdodCArPSBwYWRkaW5nWSAqIDI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpdHMgdGhpcyByZWN0YW5nbGUgYXJvdW5kIHRoZSBwYXNzZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBmaXQuXG4gICAgICovXG5cblxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gZml0KHJlY3RhbmdsZSkge1xuICAgICAgICBpZiAodGhpcy54IDwgcmVjdGFuZ2xlLngpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggKz0gdGhpcy54O1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHJlY3RhbmdsZS54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueSA8IHJlY3RhbmdsZS55KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCArPSB0aGlzLnk7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy54ICsgdGhpcy53aWR0aCA+IHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gcmVjdGFuZ2xlLndpZHRoIC0gdGhpcy54O1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy55ICsgdGhpcy5oZWlnaHQgPiByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodCAtIHRoaXMueTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gaW5jbHVkZS5cbiAgICAgKi9cblxuXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5lbmxhcmdlID0gZnVuY3Rpb24gZW5sYXJnZShyZWN0YW5nbGUpIHtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgICAgIHZhciB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5taW4odGhpcy55LCByZWN0YW5nbGUueSk7XG4gICAgICAgIHZhciB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuXG4gICAgICAgIHRoaXMueCA9IHgxO1xuICAgICAgICB0aGlzLndpZHRoID0geDIgLSB4MTtcbiAgICAgICAgdGhpcy55ID0geTE7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0geTIgLSB5MTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFJlY3RhbmdsZSwgW3tcbiAgICAgICAga2V5OiAnbGVmdCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIHRoZSByaWdodCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9wJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYm90dG9tJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb25zdGFudCBlbXB0eSByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGNvbnN0YW50XG4gICAgICAgICAqL1xuXG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ0VNUFRZJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSZWN0YW5nbGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlY3RhbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL3NoYXBlcy9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBfVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1RleHR1cmUnKTtcblxudmFyIF9UZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHR1cmUpO1xuXG52YXIgX0NvbnRhaW5lcjIgPSByZXF1aXJlKCcuLi9kaXNwbGF5L0NvbnRhaW5lcicpO1xuXG52YXIgX0NvbnRhaW5lcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250YWluZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgdGVtcFBvaW50ID0gbmV3IF9tYXRoLlBvaW50KCk7XG5cbi8qKlxuICogVGhlIFNwcml0ZSBvYmplY3QgaXMgdGhlIGJhc2UgZm9yIGFsbCB0ZXh0dXJlZCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBzY3JlZW5cbiAqXG4gKiBBIHNwcml0ZSBjYW4gYmUgY3JlYXRlZCBkaXJlY3RseSBmcm9tIGFuIGltYWdlIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogbGV0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ2Fzc2V0cy9pbWFnZS5wbmcnKTtcbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cblxudmFyIFNwcml0ZSA9IGZ1bmN0aW9uIChfQ29udGFpbmVyKSB7XG4gICAgX2luaGVyaXRzKFNwcml0ZSwgX0NvbnRhaW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIGZvciB0aGlzIHNwcml0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNwcml0ZSh0ZXh0dXJlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcHJpdGUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgaXMgMCwwIHRoaXMgbWVhbnMgdGhlIHRleHR1cmUncyBvcmlnaW4gaXMgdGhlIHRvcCBsZWZ0XG4gICAgICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAwLjUsMC41IG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIGNlbnRlcmVkXG4gICAgICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAxLDEgd291bGQgbWVhbiB0aGUgdGV4dHVyZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbnRhaW5lci5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5fYW5jaG9yID0gbmV3IF9tYXRoLk9ic2VydmFibGVQb2ludChfdGhpcy5fb25BbmNob3JVcGRhdGUsIF90aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl90ZXh0dXJlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3dpZHRoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlICh0aGlzIGlzIGluaXRpYWxseSBzZXQgYnkgdGhlIHRleHR1cmUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9oZWlnaHQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdGludCA9IG51bGw7XG4gICAgICAgIF90aGlzLl90aW50UkdCID0gbnVsbDtcbiAgICAgICAgX3RoaXMudGludCA9IDB4RkZGRkZGO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIEFwcGx5IGEgdmFsdWUgb2YgYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgICAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJsZW5kTW9kZSA9IF9jb25zdC5CTEVORF9NT0RFUy5OT1JNQUw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaGFkZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBzcHJpdGUuIFNldCB0byBudWxsIHRvIHJlbW92ZSBhIGN1cnJlbnQgc2hhZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZpbHRlcnxQSVhJLlNoYWRlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIGNhY2hlZCB2YWx1ZSBvZiB0aGUgdGludC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xuXG4gICAgICAgIC8vIGNhbGwgdGV4dHVyZSBzZXR0ZXJcbiAgICAgICAgX3RoaXMudGV4dHVyZSA9IHRleHR1cmUgfHwgX1RleHR1cmUyLmRlZmF1bHQuRU1QVFk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgdmVydGV4IGRhdGEgb2YgdGhlIHNwcml0ZSAoYmFzaWNhbGx5IGEgcXVhZClcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0IElGIGl0IGlzIGEgdHJpbW1lZCBzcHJpdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudmVydGV4VHJpbW1lZERhdGEgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgICAgICBfdGhpcy5fdGV4dHVyZUlEID0gLTE7XG5cbiAgICAgICAgX3RoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IC0xO1xuICAgICAgICBfdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbHVnaW4gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICogQWxsb3dzIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3Mgd2l0aG91dCBvdmVycmlkaW5nICdfcmVuZGVyV2ViR0wnICYgJ19yZW5kZXJDYW52YXMnIG1ldGhvZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ3Nwcml0ZSdcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnBsdWdpbk5hbWUgPSAnc3ByaXRlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFNwcml0ZS5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uIF9vblRleHR1cmVVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgICAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG5cbiAgICAgICAgLy8gc28gaWYgX3dpZHRoIGlzIDAgdGhlbiB3aWR0aCB3YXMgbm90IHNldC4uXG4gICAgICAgIGlmICh0aGlzLl93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gKDAsIF91dGlscy5zaWduKSh0aGlzLnNjYWxlLngpICogdGhpcy5fd2lkdGggLyB0aGlzLnRleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9ICgwLCBfdXRpbHMuc2lnbikodGhpcy5zY2FsZS55KSAqIHRoaXMuX2hlaWdodCAvIHRoaXMudGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLl9vbkFuY2hvclVwZGF0ZSA9IGZ1bmN0aW9uIF9vbkFuY2hvclVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgd29ybGRUcmFuc2Zvcm0gKiB2ZXJ0aWNlcywgc3RvcmUgaXQgaW4gdmVydGV4RGF0YVxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLmNhbGN1bGF0ZVZlcnRpY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQgJiYgdGhpcy5fdGV4dHVyZUlEID09PSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5fdGV4dHVyZS5fdXBkYXRlSUQ7XG5cbiAgICAgICAgLy8gc2V0IHRoZSB2ZXJ0ZXggZGF0YVxuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgdmFyIHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciBhID0gd3QuYTtcbiAgICAgICAgdmFyIGIgPSB3dC5iO1xuICAgICAgICB2YXIgYyA9IHd0LmM7XG4gICAgICAgIHZhciBkID0gd3QuZDtcbiAgICAgICAgdmFyIHR4ID0gd3QudHg7XG4gICAgICAgIHZhciB0eSA9IHd0LnR5O1xuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcbiAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XG4gICAgICAgIHZhciBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fYW5jaG9yO1xuXG4gICAgICAgIHZhciB3MCA9IDA7XG4gICAgICAgIHZhciB3MSA9IDA7XG4gICAgICAgIHZhciBoMCA9IDA7XG4gICAgICAgIHZhciBoMSA9IDA7XG5cbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCBhbmQgaXMgbm90IGEgdGlsaW5nc3ByaXRlIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhXG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzcHJpdGUgY29vcmRzLlxuICAgICAgICAgICAgdzEgPSB0cmltLnggLSBhbmNob3IuX3ggKiBvcmlnLndpZHRoO1xuICAgICAgICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XG5cbiAgICAgICAgICAgIGgxID0gdHJpbS55IC0gYW5jaG9yLl95ICogb3JpZy5oZWlnaHQ7XG4gICAgICAgICAgICBoMCA9IGgxICsgdHJpbS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3MSA9IC1hbmNob3IuX3ggKiBvcmlnLndpZHRoO1xuICAgICAgICAgICAgdzAgPSB3MSArIG9yaWcud2lkdGg7XG5cbiAgICAgICAgICAgIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xuICAgICAgICAgICAgaDAgPSBoMSArIG9yaWcuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVswXSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzFdID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVsyXSA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzNdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzVdID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVs2XSA9IGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzddID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgd29ybGRUcmFuc2Zvcm0gKiB2ZXJ0aWNlcyBmb3IgYSBub24gdGV4dHVyZSB3aXRoIGEgdHJpbS4gc3RvcmUgaXQgaW4gdmVydGV4VHJpbW1lZERhdGFcbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHRydWUgd2lkdGggYW5kIGhlaWdodCBvZiBhIHRyaW1tZWQgdGV4dHVyZSBpcyByZXNwZWN0ZWRcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5jYWxjdWxhdGVUcmltbWVkVmVydGljZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID09PSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRDtcblxuICAgICAgICAvLyBsZXRzIGRvIHNvbWUgc3BlY2lhbCB0cmltIGNvZGUhXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleFRyaW1tZWREYXRhO1xuICAgICAgICB2YXIgb3JpZyA9IHRleHR1cmUub3JpZztcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcblxuICAgICAgICAvLyBsZXRzIGNhbGN1bGF0ZSB0aGUgbmV3IHVudHJpbW1lZCBib3VuZHMuLlxuICAgICAgICB2YXIgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGEgPSB3dC5hO1xuICAgICAgICB2YXIgYiA9IHd0LmI7XG4gICAgICAgIHZhciBjID0gd3QuYztcbiAgICAgICAgdmFyIGQgPSB3dC5kO1xuICAgICAgICB2YXIgdHggPSB3dC50eDtcbiAgICAgICAgdmFyIHR5ID0gd3QudHk7XG5cbiAgICAgICAgdmFyIHcxID0gLWFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgICAgIHZhciB3MCA9IHcxICsgb3JpZy53aWR0aDtcblxuICAgICAgICB2YXIgaDEgPSAtYW5jaG9yLl95ICogb3JpZy5oZWlnaHQ7XG4gICAgICAgIHZhciBoMCA9IGgxICsgb3JpZy5oZWlnaHQ7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVswXSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzFdID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVsyXSA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzNdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzVdID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgdmVydGV4RGF0YVs2XSA9IGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzddID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICpcbiAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHdlYmdsIHJlbmRlcmVyIHRvIHVzZS5cbiAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIF9yZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKTtcbiAgICAgICAgcmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcih0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICAgICpcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgKi9cblxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIHNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFNwcml0ZS5wcm90b3R5cGUuX2NhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHZhciB0cmltID0gdGhpcy5fdGV4dHVyZS50cmltO1xuICAgICAgICB2YXIgb3JpZyA9IHRoaXMuX3RleHR1cmUub3JpZztcblxuICAgICAgICAvLyBGaXJzdCBsZXRzIGNoZWNrIHRvIHNlZSBpZiB0aGUgY3VycmVudCB0ZXh0dXJlIGhhcyBhIHRyaW0uLlxuICAgICAgICBpZiAoIXRyaW0gfHwgdHJpbS53aWR0aCA9PT0gb3JpZy53aWR0aCAmJiB0cmltLmhlaWdodCA9PT0gb3JpZy5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIG5vIHRyaW0hIGxldHMgdXNlIHRoZSB1c3VhbCBjYWxjdWxhdGlvbnMuLlxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxldHMgY2FsY3VsYXRlIGEgc3BlY2lhbCB0cmltbWVkIGJvdW5kcy4uLlxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4VHJpbW1lZERhdGEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSBUaGUgb3V0cHV0IHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIGJvdW5kcy5cbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICAgICAgLy8gd2UgY2FuIGRvIGEgZmFzdCBsb2NhbCBib3VuZHMgaWYgdGhlIHNwcml0ZSBoYXMgbm8gY2hpbGRyZW4hXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAtdGhpcy5fYW5jaG9yLl94O1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogLXRoaXMuX2FuY2hvci5feTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5tYXhYID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuXG4gICAgICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgX21hdGguUmVjdGFuZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX0NvbnRhaW5lci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIHRlc3RcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcblxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgICAgICB2YXIgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgICAgICB2YXIgeTEgPSAwO1xuXG4gICAgICAgIGlmICh0ZW1wUG9pbnQueCA+IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCkge1xuICAgICAgICAgICAgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcblxuICAgICAgICAgICAgaWYgKHRlbXBQb2ludC55ID4geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZSBhbmQgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICAgICAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgX0NvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2FuY2hvciA9IG51bGw7XG5cbiAgICAgICAgdmFyIGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMudGV4dHVyZTtcblxuICAgICAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcbiAgICAgICAgICAgIHZhciBkZXN0cm95QmFzZVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMgJiYgb3B0aW9ucy5iYXNlVGV4dHVyZTtcblxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5kZXN0cm95KCEhZGVzdHJveUJhc2VUZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHNvbWUgaGVscGVyIGZ1bmN0aW9ucy4uXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlIHVybCwgdmlkZW8gdXJsLCBjYW52YXMgZWxlbWVudCwgdmlkZW8gZWxlbWVudCwgYmFzZSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfFBJWEkuQmFzZVRleHR1cmV8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gc291cmNlIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAgICogQHJldHVybiB7UElYSS5TcHJpdGV9IFRoZSBuZXdseSBjcmVhdGVkIHNwcml0ZVxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlKF9UZXh0dXJlMi5kZWZhdWx0LmZyb20oc291cmNlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVDYWNoZSBiYXNlZCBvbiB0aGUgZnJhbWVJZFxuICAgICAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyYW1lSWQgLSBUaGUgZnJhbWUgSWQgb2YgdGhlIHRleHR1cmUgaW4gdGhlIGNhY2hlXG4gICAgICogQHJldHVybiB7UElYSS5TcHJpdGV9IEEgbmV3IFNwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgZnJhbWVJZFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGUuZnJvbUZyYW1lID0gZnVuY3Rpb24gZnJvbUZyYW1lKGZyYW1lSWQpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBfdXRpbHMuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuXG4gICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnJhbWVJZCBcIicgKyBmcmFtZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0ZXh0dXJlIGNhY2hlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHNwcml0ZSB0aGF0IHdpbGwgY29udGFpbiBhIHRleHR1cmUgYmFzZWQgb24gYW4gaW1hZ2UgdXJsXG4gICAgICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGxvYWRlZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZUlkIC0gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Nyb3Nzb3JpZ2luPShhdXRvKV0gLSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSBjcm9zcy1vcmlnaW4gcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIHNjYWxlIG1vZGUsXG4gICAgICogIHNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge1BJWEkuU3ByaXRlfSBBIG5ldyBTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGltYWdlIGlkXG4gICAgICovXG5cblxuICAgIFNwcml0ZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbiBmcm9tSW1hZ2UoaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZShfVGV4dHVyZTIuZGVmYXVsdC5mcm9tSW1hZ2UoaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFNwcml0ZSwgW3tcbiAgICAgICAga2V5OiAnd2lkdGgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzID0gKDAsIF91dGlscy5zaWduKSh0aGlzLnNjYWxlLngpIHx8IDE7XG5cbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoZWlnaHQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcyA9ICgwLCBfdXRpbHMuc2lnbikodGhpcy5zY2FsZS55KSB8fCAxO1xuXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCB0aGlzIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdFxuICAgICAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMC41LDAuNSBtZWFucyB0aGUgdGV4dHVyZSdzIG9yaWdpbiBpcyBjZW50ZXJlZFxuICAgICAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMSwxIHdvdWxkIG1lYW4gdGhlIHRleHR1cmUncyBvcmlnaW4gcG9pbnQgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lclxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuY2hvcicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3IuY29weSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLlxuICAgICAgICAgKiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGludCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdGludCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdGludFJHQiA9ICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiAweGZmMDApICsgKCh2YWx1ZSAmIDB4ZmYpIDw8IDE2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBzcHJpdGUgaXMgdXNpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGV4dHVyZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcblxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSB0ZXh0dXJlIHRvIGxvYWRcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLm9uY2UoJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNwcml0ZTtcbn0oX0NvbnRhaW5lcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNwcml0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL1Nwcml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0Jhc2VSZW5kZXJUZXh0dXJlID0gcmVxdWlyZSgnLi9CYXNlUmVuZGVyVGV4dHVyZScpO1xuXG52YXIgX0Jhc2VSZW5kZXJUZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VSZW5kZXJUZXh0dXJlKTtcblxudmFyIF9UZXh0dXJlMiA9IHJlcXVpcmUoJy4vVGV4dHVyZScpO1xuXG52YXIgX1RleHR1cmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQSBSZW5kZXJUZXh0dXJlIGlzIGEgc3BlY2lhbCB0ZXh0dXJlIHRoYXQgYWxsb3dzIGFueSBQaXhpIGRpc3BsYXkgb2JqZWN0IHRvIGJlIHJlbmRlcmVkIHRvIGl0LlxuICpcbiAqIF9fSGludF9fOiBBbGwgRGlzcGxheU9iamVjdHMgKGkuZS4gU3ByaXRlcykgdGhhdCByZW5kZXIgdG8gYSBSZW5kZXJUZXh0dXJlIHNob3VsZCBiZSBwcmVsb2FkZWRcbiAqIG90aGVyd2lzZSBibGFjayByZWN0YW5nbGVzIHdpbGwgYmUgZHJhd24gaW5zdGVhZC5cbiAqXG4gKiBBIFJlbmRlclRleHR1cmUgdGFrZXMgYSBzbmFwc2hvdCBvZiBhbnkgRGlzcGxheSBPYmplY3QgZ2l2ZW4gdG8gaXRzIHJlbmRlciBtZXRob2QuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBsZXQgcmVuZGVyZXIgPSBQSVhJLmF1dG9EZXRlY3RSZW5kZXJlcigxMDI0LCAxMDI0LCB7IHZpZXc6IGNhbnZhcywgcmF0aW86IDEgfSk7XG4gKiBsZXQgcmVuZGVyVGV4dHVyZSA9IFBJWEkuUmVuZGVyVGV4dHVyZS5jcmVhdGUoODAwLCA2MDApO1xuICogbGV0IHNwcml0ZSA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcInNwaW5PYmpfMDEucG5nXCIpO1xuICpcbiAqIHNwcml0ZS5wb3NpdGlvbi54ID0gODAwLzI7XG4gKiBzcHJpdGUucG9zaXRpb24ueSA9IDYwMC8yO1xuICogc3ByaXRlLmFuY2hvci54ID0gMC41O1xuICogc3ByaXRlLmFuY2hvci55ID0gMC41O1xuICpcbiAqIHJlbmRlcmVyLnJlbmRlcihzcHJpdGUsIHJlbmRlclRleHR1cmUpO1xuICogYGBgXG4gKlxuICogVGhlIFNwcml0ZSBpbiB0aGlzIGNhc2Ugd2lsbCBiZSByZW5kZXJlZCB1c2luZyBpdHMgbG9jYWwgdHJhbnNmb3JtLiBUbyByZW5kZXIgdGhpcyBzcHJpdGUgYXQgMCwwXG4gKiB5b3UgY2FuIGNsZWFyIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBgYGBqc1xuICpcbiAqIHNwcml0ZS5zZXRUcmFuc2Zvcm0oKVxuICpcbiAqIGxldCByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZS5jcmVhdGUoMTAwLCAxMDApO1xuICpcbiAqIHJlbmRlcmVyLnJlbmRlcihzcHJpdGUsIHJlbmRlclRleHR1cmUpOyAgLy8gUmVuZGVycyB0byBjZW50ZXIgb2YgUmVuZGVyVGV4dHVyZVxuICogYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLlRleHR1cmVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBSZW5kZXJUZXh0dXJlID0gZnVuY3Rpb24gKF9UZXh0dXJlKSB7XG4gICAgX2luaGVyaXRzKFJlbmRlclRleHR1cmUsIF9UZXh0dXJlKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlUmVuZGVyVGV4dHVyZX0gYmFzZVJlbmRlclRleHR1cmUgLSBUaGUgcmVuZGVyZXIgdXNlZCBmb3IgdGhpcyBSZW5kZXJUZXh0dXJlXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW2ZyYW1lXSAtIFRoZSByZWN0YW5nbGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2hvd1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlclRleHR1cmUoYmFzZVJlbmRlclRleHR1cmUsIGZyYW1lKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXJUZXh0dXJlKTtcblxuICAgICAgICAvLyBzdXBwb3J0IGZvciBsZWdhY3kuLlxuICAgICAgICB2YXIgX2xlZ2FjeVJlbmRlcmVyID0gbnVsbDtcblxuICAgICAgICBpZiAoIShiYXNlUmVuZGVyVGV4dHVyZSBpbnN0YW5jZW9mIF9CYXNlUmVuZGVyVGV4dHVyZTIuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcywgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBzY2FsZU1vZGUgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50c1s0XTtcblxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbiBvbGQgcmVuZGVyIHRleHR1cmUuLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQbGVhc2UgdXNlIFJlbmRlclRleHR1cmUuY3JlYXRlKCcgKyB3aWR0aCArICcsICcgKyBoZWlnaHQgKyAnKSBpbnN0ZWFkIG9mIHRoZSBjdG9yIGRpcmVjdGx5LicpO1xuICAgICAgICAgICAgX2xlZ2FjeVJlbmRlcmVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMsIG5vLWNvbnNvbGUgKi9cblxuICAgICAgICAgICAgZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgYmFzZVJlbmRlclRleHR1cmUgPSBuZXcgX0Jhc2VSZW5kZXJUZXh0dXJlMi5kZWZhdWx0KHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhc2UgdGV4dHVyZSBvYmplY3QgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtCYXNlVGV4dHVyZX1cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHR1cmUuY2FsbCh0aGlzLCBiYXNlUmVuZGVyVGV4dHVyZSwgZnJhbWUpKTtcblxuICAgICAgICBfdGhpcy5sZWdhY3lSZW5kZXJlciA9IF9sZWdhY3lSZW5kZXJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB3aWxsIGxldCB0aGUgcmVuZGVyZXIga25vdyBpZiB0aGUgdGV4dHVyZSBpcyB2YWxpZC4gSWYgaXQncyBub3QgdGhlbiBpdCBjYW5ub3QgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52YWxpZCA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuX3VwZGF0ZVV2cygpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgUmVuZGVyVGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byByZXNpemUgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gcmVzaXplIHRvLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9Ob3RSZXNpemVCYXNlVGV4dHVyZSAtIFNob3VsZCB0aGUgYmFzZVRleHR1cmUud2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgYmUgcmVzaXplZCBhcyB3ZWxsP1xuICAgICAqL1xuXG5cbiAgICBSZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCwgZG9Ob3RSZXNpemVCYXNlVGV4dHVyZSkge1xuICAgICAgICAvLyBUT0RPIC0gY291bGQgYmUgbm90IHJlcXVpcmVkLi5cbiAgICAgICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xuXG4gICAgICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gdGhpcy5vcmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IHRoaXMub3JpZy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFkb05vdFJlc2l6ZUJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVV2cygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgcmVuZGVyIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTEwMF0gLSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MTAwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbj0xXSAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZFxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVuZGVyVGV4dHVyZX0gVGhlIG5ldyByZW5kZXIgdGV4dHVyZVxuICAgICAqL1xuXG5cbiAgICBSZW5kZXJUZXh0dXJlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKG5ldyBfQmFzZVJlbmRlclRleHR1cmUyLmRlZmF1bHQod2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZW5kZXJUZXh0dXJlO1xufShfVGV4dHVyZTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlclRleHR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUZXh0dXJlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL1JlbmRlclRleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVGlja2VyID0gZXhwb3J0cy5zaGFyZWQgPSB1bmRlZmluZWQ7XG5cbnZhciBfVGlja2VyID0gcmVxdWlyZSgnLi9UaWNrZXInKTtcblxudmFyIF9UaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGlja2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUaGUgc2hhcmVkIHRpY2tlciBpbnN0YW5jZSB1c2VkIGJ5IHtAbGluayBQSVhJLmV4dHJhcy5BbmltYXRlZFNwcml0ZX0uXG4gKiBhbmQgYnkge0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyfS5cbiAqIFRoZSBwcm9wZXJ0eSB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2F1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYFxuICogZm9yIHRoaXMgaW5zdGFuY2UuIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nXG4gKiBob3cgdG8gb3B0LW91dCBvZiBhdXRvLXN0YXJ0aW5nIHRoZSBzaGFyZWQgdGlja2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgdGlja2VyID0gUElYSS50aWNrZXIuc2hhcmVkO1xuICogLy8gU2V0IHRoaXMgdG8gcHJldmVudCBzdGFydGluZyB0aGlzIHRpY2tlciB3aGVuIGxpc3RlbmVycyBhcmUgYWRkZWQuXG4gKiAvLyBCeSBkZWZhdWx0IHRoaXMgaXMgdHJ1ZSBvbmx5IGZvciB0aGUgUElYSS50aWNrZXIuc2hhcmVkIGluc3RhbmNlLlxuICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICogLy8gRllJLCBjYWxsIHRoaXMgdG8gZW5zdXJlIHRoZSB0aWNrZXIgaXMgc3RvcHBlZC4gSXQgc2hvdWxkIGJlIHN0b3BwZWRcbiAqIC8vIGlmIHlvdSBoYXZlIG5vdCBhdHRlbXB0ZWQgdG8gcmVuZGVyIGFueXRoaW5nIHlldC5cbiAqIHRpY2tlci5zdG9wKCk7XG4gKiAvLyBDYWxsIHRoaXMgd2hlbiB5b3UgYXJlIHJlYWR5IGZvciBhIHJ1bm5pbmcgc2hhcmVkIHRpY2tlci5cbiAqIHRpY2tlci5zdGFydCgpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBZb3UgbWF5IHVzZSB0aGUgc2hhcmVkIHRpY2tlciB0byByZW5kZXIuLi5cbiAqIGxldCByZW5kZXJlciA9IFBJWEkuYXV0b0RldGVjdFJlbmRlcmVyKDgwMCwgNjAwKTtcbiAqIGxldCBzdGFnZSA9IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICogbGV0IGludGVyYWN0aW9uTWFuYWdlciA9IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyKHJlbmRlcmVyKTtcbiAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyZXIudmlldyk7XG4gKiB0aWNrZXIuYWRkKGZ1bmN0aW9uICh0aW1lKSB7XG4gKiAgICAgcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcbiAqIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBPciB5b3UgY2FuIGp1c3QgdXBkYXRlIGl0IG1hbnVhbGx5LlxuICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICogdGlja2VyLnN0b3AoKTtcbiAqIGZ1bmN0aW9uIGFuaW1hdGUodGltZSkge1xuICogICAgIHRpY2tlci51cGRhdGUodGltZSk7XG4gKiAgICAgcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcbiAqICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiB9XG4gKiBhbmltYXRlKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAqXG4gKiBAdHlwZSB7UElYSS50aWNrZXIuVGlja2VyfVxuICogQG1lbWJlcm9mIFBJWEkudGlja2VyXG4gKi9cbnZhciBzaGFyZWQgPSBuZXcgX1RpY2tlcjIuZGVmYXVsdCgpO1xuXG5zaGFyZWQuYXV0b1N0YXJ0ID0gdHJ1ZTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkudGlja2VyXG4gKi9cbmV4cG9ydHMuc2hhcmVkID0gc2hhcmVkO1xuZXhwb3J0cy5UaWNrZXIgPSBfVGlja2VyMi5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvdGlja2VyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwNi4wMy4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVzZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgaWYgKFVzZXIuX19pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVXNlci5fX2luc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBVc2VyLl9faW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBvYmoodXNlcikge1xyXG4gICAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xyXG4gICAgfVxyXG59XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9nYW1lL29iamVjdC9Vc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwNS4wMy4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh0dHAge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgaWYgKEh0dHAuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEh0dHAuaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9iYXNlVXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGknO1xyXG4gICAgICAgIC8vdGhpcy5fYmFzZVVybCA9ICdodHRwczovL3RwLXNlcnZlci1qYXZhLmhlcm9rdWFwcC5jb20vYXBpJztcclxuXHJcbiAgICAgICAgSHR0cC5pbnN0YW5jZSA9IHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IEJhc2VVcmwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VVcmw7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IEJhc2VVcmwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9iYXNlVXJsID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmVxdWVzdChhZGRyZXNzID0gJycsIGhlYWRlcnMgPSB7fSwgdHlwZSA9ICdHRVQnLCBib2R5ID0ge30pIHtcclxuICAgICAgICBsZXQgZmV0Y2hPYmogPSB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogdHlwZSxcclxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxyXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYm9keSkge1xyXG4gICAgICAgICAgICBmZXRjaE9iai5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmZXRjaChhZGRyZXNzLCBmZXRjaE9iaikudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICB9KS50aGVuKGpzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShqc29uKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCh7fSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyciB8fCBlcnIuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL3N1cHBvcnQvaHR0cC9IdHRwLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgc2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIHNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIHNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoc2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGVhciwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgICAgICBpZiAocG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSxcbiAgICAgICAgbWF4VFggPSBhLnggPiBiLnggPyAoYS54ID4gYy54ID8gYS54IDogYy54KSA6IChiLnggPiBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgc2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHZhciBwID0gZWFyLm5leHRaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHRaO1xuICAgIH1cblxuICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHAgPSBlYXIucHJldlo7XG5cbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBwO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHtcbiAgICAgICAgdmFyIGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICAgICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgfVxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcbiAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLnkpIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAubmV4dC55KSByZXR1cm4gcC5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoaHggPT09IHF4KSByZXR1cm4gbS5wcmV2OyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsb3dlciBlbmRwb2ludFxuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtLm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gc3RvcCkge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAoKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54KSkgJiYgbG9jYWxseUluc2lkZShwLCBob2xlKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocVNpemUgPT09IDAgfHwgIXEpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocC56IDw9IHEueikge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgc2l6ZSBvZiB0aGUgZGF0YSBib3VuZGluZyBib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgLyBzaXplO1xuICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgLyBzaXplO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmXG4gICAgICAgICAgIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYik7XG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgaWYgKChlcXVhbHMocDEsIHExKSAmJiBlcXVhbHMocDIsIHEyKSkgfHxcbiAgICAgICAgKGVxdWFscyhwMSwgcTIpICYmIGVxdWFscyhwMiwgcTEpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGFyZWEocDEsIHExLCBwMikgPiAwICE9PSBhcmVhKHAxLCBxMSwgcTIpID4gMCAmJlxuICAgICAgICAgICBhcmVhKHAyLCBxMiwgcDEpID4gMCAhPT0gYXJlYShwMiwgcTIsIHExKSA+IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IG51bGw7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VhcmN1dC9zcmMvZWFyY3V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGlzTW9iaWxlLmpzIHYwLjQuMVxuICpcbiAqIEEgc2ltcGxlIGxpYnJhcnkgdG8gZGV0ZWN0IEFwcGxlIHBob25lcyBhbmQgdGFibGV0cyxcbiAqIEFuZHJvaWQgcGhvbmVzIGFuZCB0YWJsZXRzLCBvdGhlciBtb2JpbGUgZGV2aWNlcyAobGlrZSBibGFja2JlcnJ5LCBtaW5pLW9wZXJhIGFuZCB3aW5kb3dzIHBob25lKSxcbiAqIGFuZCBhbnkga2luZCBvZiBzZXZlbiBpbmNoIGRldmljZSwgdmlhIHVzZXIgYWdlbnQgc25pZmZpbmcuXG4gKlxuICogQGF1dGhvcjogS2FpIE1hbGxlYSAoa21hbGxlYUBnbWFpbC5jb20pXG4gKlxuICogQGxpY2Vuc2U6IGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL3B1YmxpY2RvbWFpbi96ZXJvLzEuMC9cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwpIHtcblxuICAgIHZhciBhcHBsZV9waG9uZSAgICAgICAgID0gL2lQaG9uZS9pLFxuICAgICAgICBhcHBsZV9pcG9kICAgICAgICAgID0gL2lQb2QvaSxcbiAgICAgICAgYXBwbGVfdGFibGV0ICAgICAgICA9IC9pUGFkL2ksXG4gICAgICAgIGFuZHJvaWRfcGhvbmUgICAgICAgPSAvKD89LipcXGJBbmRyb2lkXFxiKSg/PS4qXFxiTW9iaWxlXFxiKS9pLCAvLyBNYXRjaCAnQW5kcm9pZCcgQU5EICdNb2JpbGUnXG4gICAgICAgIGFuZHJvaWRfdGFibGV0ICAgICAgPSAvQW5kcm9pZC9pLFxuICAgICAgICBhbWF6b25fcGhvbmUgICAgICAgID0gLyg/PS4qXFxiQW5kcm9pZFxcYikoPz0uKlxcYlNENDkzMFVSXFxiKS9pLFxuICAgICAgICBhbWF6b25fdGFibGV0ICAgICAgID0gLyg/PS4qXFxiQW5kcm9pZFxcYikoPz0uKlxcYig/OktGT1R8S0ZUVHxLRkpXSXxLRkpXQXxLRlNPV0l8S0ZUSFdJfEtGVEhXQXxLRkFQV0l8S0ZBUFdBfEtGQVJXSXxLRkFTV0l8S0ZTQVdJfEtGU0FXQSlcXGIpL2ksXG4gICAgICAgIHdpbmRvd3NfcGhvbmUgICAgICAgPSAvV2luZG93cyBQaG9uZS9pLFxuICAgICAgICB3aW5kb3dzX3RhYmxldCAgICAgID0gLyg/PS4qXFxiV2luZG93c1xcYikoPz0uKlxcYkFSTVxcYikvaSwgLy8gTWF0Y2ggJ1dpbmRvd3MnIEFORCAnQVJNJ1xuICAgICAgICBvdGhlcl9ibGFja2JlcnJ5ICAgID0gL0JsYWNrQmVycnkvaSxcbiAgICAgICAgb3RoZXJfYmxhY2tiZXJyeV8xMCA9IC9CQjEwL2ksXG4gICAgICAgIG90aGVyX29wZXJhICAgICAgICAgPSAvT3BlcmEgTWluaS9pLFxuICAgICAgICBvdGhlcl9jaHJvbWUgICAgICAgID0gLyhDcmlPU3xDaHJvbWUpKD89LipcXGJNb2JpbGVcXGIpL2ksXG4gICAgICAgIG90aGVyX2ZpcmVmb3ggICAgICAgPSAvKD89LipcXGJGaXJlZm94XFxiKSg/PS4qXFxiTW9iaWxlXFxiKS9pLCAvLyBNYXRjaCAnRmlyZWZveCcgQU5EICdNb2JpbGUnXG4gICAgICAgIHNldmVuX2luY2ggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJyg/OicgKyAgICAgICAgIC8vIE5vbi1jYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICAgICAgJ05leHVzIDcnICsgICAgIC8vIE5leHVzIDdcblxuICAgICAgICAgICAgJ3wnICsgICAgICAgICAgIC8vIE9SXG5cbiAgICAgICAgICAgICdCTlRWMjUwJyArICAgICAvLyBCJk4gTm9vayBUYWJsZXQgNyBpbmNoXG5cbiAgICAgICAgICAgICd8JyArICAgICAgICAgICAvLyBPUlxuXG4gICAgICAgICAgICAnS2luZGxlIEZpcmUnICsgLy8gS2luZGxlIEZpcmVcblxuICAgICAgICAgICAgJ3wnICsgICAgICAgICAgIC8vIE9SXG5cbiAgICAgICAgICAgICdTaWxrJyArICAgICAgICAvLyBLaW5kbGUgRmlyZSwgU2lsayBBY2NlbGVyYXRlZFxuXG4gICAgICAgICAgICAnfCcgKyAgICAgICAgICAgLy8gT1JcblxuICAgICAgICAgICAgJ0dULVAxMDAwJyArICAgIC8vIEdhbGF4eSBUYWIgNyBpbmNoXG5cbiAgICAgICAgICAgICcpJywgICAgICAgICAgICAvLyBFbmQgbm9uLWNhcHR1cmluZyBncm91cFxuXG4gICAgICAgICAgICAnaScpOyAgICAgICAgICAgLy8gQ2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZ1xuXG4gICAgdmFyIG1hdGNoID0gZnVuY3Rpb24ocmVnZXgsIHVzZXJBZ2VudCkge1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh1c2VyQWdlbnQpO1xuICAgIH07XG5cbiAgICB2YXIgSXNNb2JpbGVDbGFzcyA9IGZ1bmN0aW9uKHVzZXJBZ2VudCkge1xuICAgICAgICB2YXIgdWEgPSB1c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAgICAgICAvLyBGYWNlYm9vayBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIGFkZHMgYSBidW5jaCBvZiBzdHJpbmdzIHRoYXRcbiAgICAgICAgLy8gbWF0Y2ggZXZlcnl0aGluZy4gU3RyaXAgaXQgb3V0IGlmIGl0IGV4aXN0cy5cbiAgICAgICAgdmFyIHRtcCA9IHVhLnNwbGl0KCdbRkJBTicpO1xuICAgICAgICBpZiAodHlwZW9mIHRtcFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHVhID0gdG1wWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHdpdHRlciBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIG9uIGlQYWQgYWRkcyBhIFwiVHdpdHRlciBmb3JcbiAgICAgICAgLy8gaVBob25lXCIgc3RyaW5nLiBTYW1lIHByb2JhYmxlIGhhcHBlbnMgb24gb3RoZXIgdGFibGV0IHBsYXRmb3Jtcy5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGNvbmZ1c2UgZGV0ZWN0aW9uIHNvIHN0cmlwIGl0IG91dCBpZiBpdCBleGlzdHMuXG4gICAgICAgIHRtcCA9IHVhLnNwbGl0KCdUd2l0dGVyJyk7XG4gICAgICAgIGlmICh0eXBlb2YgdG1wWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdWEgPSB0bXBbMF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGxlID0ge1xuICAgICAgICAgICAgcGhvbmU6ICBtYXRjaChhcHBsZV9waG9uZSwgdWEpLFxuICAgICAgICAgICAgaXBvZDogICBtYXRjaChhcHBsZV9pcG9kLCB1YSksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaChhcHBsZV9waG9uZSwgdWEpICYmIG1hdGNoKGFwcGxlX3RhYmxldCwgdWEpLFxuICAgICAgICAgICAgZGV2aWNlOiBtYXRjaChhcHBsZV9waG9uZSwgdWEpIHx8IG1hdGNoKGFwcGxlX2lwb2QsIHVhKSB8fCBtYXRjaChhcHBsZV90YWJsZXQsIHVhKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFtYXpvbiA9IHtcbiAgICAgICAgICAgIHBob25lOiAgbWF0Y2goYW1hem9uX3Bob25lLCB1YSksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaChhbWF6b25fcGhvbmUsIHVhKSAmJiBtYXRjaChhbWF6b25fdGFibGV0LCB1YSksXG4gICAgICAgICAgICBkZXZpY2U6IG1hdGNoKGFtYXpvbl9waG9uZSwgdWEpIHx8IG1hdGNoKGFtYXpvbl90YWJsZXQsIHVhKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFuZHJvaWQgPSB7XG4gICAgICAgICAgICBwaG9uZTogIG1hdGNoKGFtYXpvbl9waG9uZSwgdWEpIHx8IG1hdGNoKGFuZHJvaWRfcGhvbmUsIHVhKSxcbiAgICAgICAgICAgIHRhYmxldDogIW1hdGNoKGFtYXpvbl9waG9uZSwgdWEpICYmICFtYXRjaChhbmRyb2lkX3Bob25lLCB1YSkgJiYgKG1hdGNoKGFtYXpvbl90YWJsZXQsIHVhKSB8fCBtYXRjaChhbmRyb2lkX3RhYmxldCwgdWEpKSxcbiAgICAgICAgICAgIGRldmljZTogbWF0Y2goYW1hem9uX3Bob25lLCB1YSkgfHwgbWF0Y2goYW1hem9uX3RhYmxldCwgdWEpIHx8IG1hdGNoKGFuZHJvaWRfcGhvbmUsIHVhKSB8fCBtYXRjaChhbmRyb2lkX3RhYmxldCwgdWEpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2luZG93cyA9IHtcbiAgICAgICAgICAgIHBob25lOiAgbWF0Y2god2luZG93c19waG9uZSwgdWEpLFxuICAgICAgICAgICAgdGFibGV0OiBtYXRjaCh3aW5kb3dzX3RhYmxldCwgdWEpLFxuICAgICAgICAgICAgZGV2aWNlOiBtYXRjaCh3aW5kb3dzX3Bob25lLCB1YSkgfHwgbWF0Y2god2luZG93c190YWJsZXQsIHVhKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm90aGVyID0ge1xuICAgICAgICAgICAgYmxhY2tiZXJyeTogICBtYXRjaChvdGhlcl9ibGFja2JlcnJ5LCB1YSksXG4gICAgICAgICAgICBibGFja2JlcnJ5MTA6IG1hdGNoKG90aGVyX2JsYWNrYmVycnlfMTAsIHVhKSxcbiAgICAgICAgICAgIG9wZXJhOiAgICAgICAgbWF0Y2gob3RoZXJfb3BlcmEsIHVhKSxcbiAgICAgICAgICAgIGZpcmVmb3g6ICAgICAgbWF0Y2gob3RoZXJfZmlyZWZveCwgdWEpLFxuICAgICAgICAgICAgY2hyb21lOiAgICAgICBtYXRjaChvdGhlcl9jaHJvbWUsIHVhKSxcbiAgICAgICAgICAgIGRldmljZTogICAgICAgbWF0Y2gob3RoZXJfYmxhY2tiZXJyeSwgdWEpIHx8IG1hdGNoKG90aGVyX2JsYWNrYmVycnlfMTAsIHVhKSB8fCBtYXRjaChvdGhlcl9vcGVyYSwgdWEpIHx8IG1hdGNoKG90aGVyX2ZpcmVmb3gsIHVhKSB8fCBtYXRjaChvdGhlcl9jaHJvbWUsIHVhKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldmVuX2luY2ggPSBtYXRjaChzZXZlbl9pbmNoLCB1YSk7XG4gICAgICAgIHRoaXMuYW55ID0gdGhpcy5hcHBsZS5kZXZpY2UgfHwgdGhpcy5hbmRyb2lkLmRldmljZSB8fCB0aGlzLndpbmRvd3MuZGV2aWNlIHx8IHRoaXMub3RoZXIuZGV2aWNlIHx8IHRoaXMuc2V2ZW5faW5jaDtcblxuICAgICAgICAvLyBleGNsdWRlcyAnb3RoZXInIGRldmljZXMgYW5kIGlwb2RzLCB0YXJnZXRpbmcgdG91Y2hzY3JlZW4gcGhvbmVzXG4gICAgICAgIHRoaXMucGhvbmUgPSB0aGlzLmFwcGxlLnBob25lIHx8IHRoaXMuYW5kcm9pZC5waG9uZSB8fCB0aGlzLndpbmRvd3MucGhvbmU7XG5cbiAgICAgICAgLy8gZXhjbHVkZXMgNyBpbmNoIGRldmljZXMsIGNsYXNzaWZ5aW5nIGFzIHBob25lIG9yIHRhYmxldCBpcyBsZWZ0IHRvIHRoZSB1c2VyXG4gICAgICAgIHRoaXMudGFibGV0ID0gdGhpcy5hcHBsZS50YWJsZXQgfHwgdGhpcy5hbmRyb2lkLnRhYmxldCB8fCB0aGlzLndpbmRvd3MudGFibGV0O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGluc3RhbnRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBJTSA9IG5ldyBJc01vYmlsZUNsYXNzKCk7XG4gICAgICAgIElNLkNsYXNzID0gSXNNb2JpbGVDbGFzcztcbiAgICAgICAgcmV0dXJuIElNO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy9ub2RlXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gSXNNb2JpbGVDbGFzcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vYnJvd3NlcmlmeVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGluc3RhbnRpYXRlKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy9BTURcbiAgICAgICAgZGVmaW5lKCdpc01vYmlsZScsIFtdLCBnbG9iYWwuaXNNb2JpbGUgPSBpbnN0YW50aWF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbG9iYWwuaXNNb2JpbGUgPSBpbnN0YW50aWF0ZSgpO1xuICAgIH1cblxufSkodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaXNtb2JpbGVqcy9pc01vYmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIFdlYkdMIFRleHR1cmVcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGZvcm1hdCB7bnVtYmVyfSB0aGUgcGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLiBkZWZhdWx0cyB0byBnbC5SR0JBXG4gKiBAcGFyYW0gdHlwZSB7bnVtYmVyfSB0aGUgZ2wgdHlwZSBvZiB0aGUgdGV4dHVyZS4gZGVmYXVsdHMgdG8gZ2wuVU5TSUdORURfQllURVxuICovXG52YXIgVGV4dHVyZSA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpXG57XG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKlxuXHQgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG5cdCAqL1xuXHR0aGlzLmdsID0gZ2w7XG5cblxuXHQvKipcblx0ICogVGhlIFdlYkdMIHRleHR1cmVcblx0ICpcblx0ICogQG1lbWJlciB7V2ViR0xUZXh0dXJlfVxuXHQgKi9cblx0dGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdC8qKlxuXHQgKiBJZiBtaXBtYXBwaW5nIHdhcyB1c2VkIGZvciB0aGlzIHRleHR1cmUsIGVuYWJsZSBhbmQgZGlzYWJsZSB3aXRoIGVuYWJsZU1pcG1hcCgpXG5cdCAqXG5cdCAqIEBtZW1iZXIge0Jvb2xlYW59XG5cdCAqL1xuXHQvLyBzb21lIHNldHRpbmdzLi5cblx0dGhpcy5taXBtYXAgPSBmYWxzZTtcblxuXG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgcHJlLW11bHRpcGxpZWQgYWxwaGFcblx0ICpcblx0ICogQG1lbWJlciB7Qm9vbGVhbn1cblx0ICovXG5cdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgd2lkdGggb2YgdGV4dHVyZVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtOdW1iZXJ9XG5cdCAqL1xuXHR0aGlzLndpZHRoID0gd2lkdGggfHwgLTE7XG5cdC8qKlxuXHQgKiBUaGUgaGVpZ2h0IG9mIHRleHR1cmVcblx0ICpcblx0ICogQG1lbWJlciB7TnVtYmVyfVxuXHQgKi9cblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgLTE7XG5cblx0LyoqXG5cdCAqIFRoZSBwaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIGRlZmF1bHRzIHRvIGdsLlJHQkFcblx0ICpcblx0ICogQG1lbWJlciB7TnVtYmVyfVxuXHQgKi9cblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgfHwgZ2wuUkdCQTtcblxuXHQvKipcblx0ICogVGhlIGdsIHR5cGUgb2YgdGhlIHRleHR1cmUuIGRlZmF1bHRzIHRvIGdsLlVOU0lHTkVEX0JZVEVcblx0ICpcblx0ICogQG1lbWJlciB7TnVtYmVyfVxuXHQgKi9cblx0dGhpcy50eXBlID0gdHlwZSB8fCBnbC5VTlNJR05FRF9CWVRFO1xuXG5cbn07XG5cbi8qKlxuICogVXBsb2FkcyB0aGlzIHRleHR1cmUgdG8gdGhlIEdQVVxuICogQHBhcmFtIHNvdXJjZSB7SFRNTEltYWdlRWxlbWVudHxJbWFnZURhdGF8SFRNTFZpZGVvRWxlbWVudH0gdGhlIHNvdXJjZSBpbWFnZSBvZiB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbihzb3VyY2UpXG57XG5cdHRoaXMuYmluZCgpO1xuXG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblxuXHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMucHJlbXVsdGlwbHlBbHBoYSk7XG5cblx0dmFyIG5ld1dpZHRoID0gc291cmNlLnZpZGVvV2lkdGggfHwgc291cmNlLndpZHRoO1xuXHR2YXIgbmV3SGVpZ2h0ID0gc291cmNlLnZpZGVvSGVpZ2h0IHx8IHNvdXJjZS5oZWlnaHQ7XG5cblx0aWYobmV3SGVpZ2h0ICE9PSB0aGlzLmhlaWdodCB8fCBuZXdXaWR0aCAhPT0gdGhpcy53aWR0aClcblx0e1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHNvdXJjZSk7XG5cdH1cblx0ZWxzZVxuXHR7XG4gICAgXHRnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHNvdXJjZSk7XG5cdH1cblxuXHQvLyBpZiB0aGUgc291cmNlIGlzIGEgdmlkZW8sIHdlIG5lZWQgdG8gdXNlIHRoZSB2aWRlb1dpZHRoIC8gdmlkZW9IZWlnaHQgcHJvcGVydGllcyBhcyB3aWR0aCAvIGhlaWdodCB3aWxsIGJlIGluY29ycmVjdC5cblx0dGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuXHR0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcblxufTtcblxudmFyIEZMT0FUSU5HX1BPSU5UX0FWQUlMQUJMRSA9IGZhbHNlO1xuXG4vKipcbiAqIFVzZSBhIGRhdGEgc291cmNlIGFuZCB1cGxvYWRzIHRoaXMgdGV4dHVyZSB0byB0aGUgR1BVXG4gKiBAcGFyYW0gZGF0YSB7VHlwZWRBcnJheX0gdGhlIGRhdGEgdG8gdXBsb2FkIHRvIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51cGxvYWREYXRhID0gZnVuY3Rpb24oZGF0YSwgd2lkdGgsIGhlaWdodClcbntcblx0dGhpcy5iaW5kKCk7XG5cblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXG5cdGlmKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpXG5cdHtcblx0XHRpZighRkxPQVRJTkdfUE9JTlRfQVZBSUxBQkxFKVxuXHRcdHtcblx0XHRcdHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKTtcblxuXHRcdFx0aWYoZXh0KVxuXHRcdFx0e1xuXHRcdFx0XHRGTE9BVElOR19QT0lOVF9BVkFJTEFCTEUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Zsb2F0aW5nIHBvaW50IHRleHR1cmVzIG5vdCBhdmFpbGFibGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnR5cGUgPSBnbC5GTE9BVDtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHQvLyBUT0RPIHN1cHBvcnQgZm9yIG90aGVyIHR5cGVzXG5cdFx0dGhpcy50eXBlID0gdGhpcy50eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG5cdH1cblxuXHQvLyB3aGF0IHR5cGUgb2YgZGF0YT9cblx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnByZW11bHRpcGx5QWxwaGEpO1xuXG5cblx0aWYod2lkdGggIT09IHRoaXMud2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLmhlaWdodClcblx0e1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsICB3aWR0aCwgaGVpZ2h0LCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBkYXRhIHx8IG51bGwpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGF0YSB8fCBudWxsKTtcblx0fVxuXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblxuLy9cdHRleFN1YkltYWdlMkRcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSAgbG9jYXRpb25cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGxvY2F0aW9uKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdGlmKGxvY2F0aW9uICE9PSB1bmRlZmluZWQpXG5cdHtcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuXHR9XG5cblx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gbGluZWFyIHtCb29sZWFufSBpZiB3ZSB3YW50IHRvIHVzZSBsaW5lYXIgZmlsdGVyaW5nIG9yIG5lYXJlc3QgbmVpZ2hib3VyIGludGVycG9sYXRpb25cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUubWluRmlsdGVyID0gZnVuY3Rpb24oIGxpbmVhciApXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0aWYodGhpcy5taXBtYXApXG5cdHtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbGluZWFyID8gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbGluZWFyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIGxpbmVhciB7Qm9vbGVhbn0gaWYgd2Ugd2FudCB0byB1c2UgbGluZWFyIGZpbHRlcmluZyBvciBuZWFyZXN0IG5laWdoYm91ciBpbnRlcnBvbGF0aW9uXG4gKi9cblRleHR1cmUucHJvdG90eXBlLm1hZ0ZpbHRlciA9IGZ1bmN0aW9uKCBsaW5lYXIgKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBsaW5lYXIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbn07XG5cbi8qKlxuICogRW5hYmxlcyBtaXBtYXBwaW5nXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZU1pcG1hcCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHR0aGlzLm1pcG1hcCA9IHRydWU7XG5cblx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgbGluZWFyIGZpbHRlcmluZ1xuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVMaW5lYXJTY2FsaW5nID0gZnVuY3Rpb24oKVxue1xuXHR0aGlzLm1pbkZpbHRlcih0cnVlKTtcblx0dGhpcy5tYWdGaWx0ZXIodHJ1ZSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgbmVhcmVzdCBuZWlnaGJvdXIgaW50ZXJwb2xhdGlvblxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVOZWFyZXN0U2NhbGluZyA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5taW5GaWx0ZXIoZmFsc2UpO1xuXHR0aGlzLm1hZ0ZpbHRlcihmYWxzZSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgY2xhbXBpbmcgb24gdGhlIHRleHR1cmUgc28gV2ViR0wgd2lsbCBub3QgcmVwZWF0IGl0XG4gKi9cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZVdyYXBDbGFtcCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRpbGluZyBvbiB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVXcmFwUmVwZWF0ID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZVdyYXBNaXJyb3JSZXBlYXQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuTUlSUk9SRURfUkVQRUFUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5NSVJST1JFRF9SRVBFQVQpO1xufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXHQvL1RPRE9cblx0Z2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dFxuICogQHBhcmFtIHNvdXJjZSB7SFRNTEltYWdlRWxlbWVudHxJbWFnZURhdGF9IHRoZSBzb3VyY2UgaW1hZ2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBwcmVtdWx0aXBseUFscGhhIHtCb29sZWFufSBJZiB3ZSB3YW50IHRvIHVzZSBwcmUtbXVsdGlwbGllZCBhbHBoYVxuICovXG5UZXh0dXJlLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihnbCwgc291cmNlLCBwcmVtdWx0aXBseUFscGhhKVxue1xuXHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsKTtcblx0dGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID0gcHJlbXVsdGlwbHlBbHBoYSB8fCBmYWxzZTtcblx0dGV4dHVyZS51cGxvYWQoc291cmNlKTtcblxuXHRyZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSBkYXRhIHtUeXBlZEFycmF5fSB0aGUgZGF0YSB0byB1cGxvYWQgdG8gdGhlIHRleHR1cmVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gKi9cblRleHR1cmUuZnJvbURhdGEgPSBmdW5jdGlvbihnbCwgZGF0YSwgd2lkdGgsIGhlaWdodClcbntcblx0Ly9jb25zb2xlLmxvZyhkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCk7XG5cdHRleHR1cmUudXBsb2FkRGF0YShkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRyZXR1cm4gdGV4dHVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGktZ2wtY29yZS9zcmMvR0xUZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB2YXIgR0xfTUFQID0ge307XG5cbi8qKlxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSBhdHRyaWJzIHsqfVxuICogQHBhcmFtIHN0YXRlIHsqfVxuICovXG52YXIgc2V0VmVydGV4QXR0cmliQXJyYXlzID0gZnVuY3Rpb24gKGdsLCBhdHRyaWJzLCBzdGF0ZSlcbntcbiAgICB2YXIgaTtcbiAgICBpZihzdGF0ZSlcbiAgICB7XG4gICAgICAgIHZhciB0ZW1wQXR0cmliU3RhdGUgPSBzdGF0ZS50ZW1wQXR0cmliU3RhdGUsXG4gICAgICAgICAgICBhdHRyaWJTdGF0ZSA9IHN0YXRlLmF0dHJpYlN0YXRlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wQXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRlbXBBdHRyaWJTdGF0ZVtpXSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBuZXcgYXR0cmlic1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGVtcEF0dHJpYlN0YXRlW2F0dHJpYnNbaV0uYXR0cmlidXRlLmxvY2F0aW9uXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJTdGF0ZVtpXSAhPT0gdGVtcEF0dHJpYlN0YXRlW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYlN0YXRlW2ldID0gdGVtcEF0dHJpYlN0YXRlW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYlN0YXRlW2ldKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGF0dHJpYiA9IGF0dHJpYnNbaV07XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWIuYXR0cmlidXRlLmxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VmVydGV4QXR0cmliQXJyYXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGktZ2wtY29yZS9zcmMvc2V0VmVydGV4QXR0cmliQXJyYXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCB7V2ViR0xQcm9ncmFtfVxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBmcmFnbWVudFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIGF0dHJpYnV0ZUxvY2F0aW9ucyB7T2JqZWN0fSBBbiBhdHRyaWJ1dGUgbG9jYXRpb24gbWFwIHRoYXQgbGV0cyB5b3UgbWFudWFsbHkgc2V0IHRoZSBhdHRyaWJ1dGUgbG9jYXRpb25zXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19IHRoZSBzaGFkZXIgcHJvZ3JhbVxuICovXG52YXIgY29tcGlsZVByb2dyYW0gPSBmdW5jdGlvbihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmlidXRlTG9jYXRpb25zKVxue1xuICAgIHZhciBnbFZlcnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTcmMpO1xuICAgIHZhciBnbEZyYWdTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U3JjKTtcblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsVmVydFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsRnJhZ1NoYWRlcik7XG5cbiAgICAvLyBvcHRpb25hbGx5LCBzZXQgdGhlIGF0dHJpYnV0ZXMgbWFudWFsbHkgZm9yIHRoZSBwcm9ncmFtIHJhdGhlciB0aGFuIGxldHRpbmcgV2ViR0wgZGVjaWRlLi5cbiAgICBpZihhdHRyaWJ1dGVMb2NhdGlvbnMpXG4gICAge1xuICAgICAgICBmb3IodmFyIGkgaW4gYXR0cmlidXRlTG9jYXRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlTG9jYXRpb25zW2ldLCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBpZiBsaW5raW5nIGZhaWxzLCB0aGVuIGxvZyBhbmQgY2xlYW51cFxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdQaXhpLmpzIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLmdldEVycm9yKCknLCBnbC5nZXRFcnJvcigpKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHByb2dyYW0gaW5mbyBsb2csIGxvZyBpdFxuICAgICAgICBpZiAoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkgIT09ICcnKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpeGkuanMgV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGNsZWFuIHVwIHNvbWUgc2hhZGVyc1xuICAgIGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRTaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdTaGFkZXIpO1xuXG4gICAgcmV0dXJuIHByb2dyYW07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCB7V2ViR0xQcm9ncmFtfVxuICogQHBhcmFtIHR5cGUge051bWJlcn0gdGhlIHR5cGUsIGNhbiBiZSBlaXRoZXIgVkVSVEVYX1NIQURFUiBvciBGUkFHTUVOVF9TSEFERVJcbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gdGhlIHNoYWRlclxuICovXG52YXIgY29tcGlsZVNoYWRlciA9IGZ1bmN0aW9uIChnbCwgdHlwZSwgc3JjKVxue1xuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZVByb2dyYW07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvY29tcGlsZVByb2dyYW0uanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSBUeXBlIG9mIHZhbHVlXG4gKiBAcGFyYW0gc2l6ZSB7TnVtYmVyfVxuICovXG52YXIgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkgXG57XG4gICAgc3dpdGNoICh0eXBlKVxuICAgIHtcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgY2FzZSAndmVjMic6IFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMiAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ3ZlYzQnOiAgICAgXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGNhc2UgJ2l2ZWMyJzogICBcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgyICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAnaXZlYzMnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDMgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdpdmVjNCc6IFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDQgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdib29sJzogICAgIFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgJ2J2ZWMyJzpcblxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSggMiAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ2J2ZWMzJzpcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuQXJyYXkoMyAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ2J2ZWM0JzpcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuQXJyYXkoNCAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ21hdDInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMV0pO1xuXG4gICAgICAgIGNhc2UgJ21hdDMnOiBcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMV0pO1xuXG4gICAgICAgIGNhc2UgJ21hdDQnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDFdKTtcbiAgICB9XG59O1xuXG52YXIgYm9vbGVhbkFycmF5ID0gZnVuY3Rpb24oc2l6ZSlcbntcbiAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBcbiAgICB7XG4gICAgICAgIGFycmF5W2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0VmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvZGVmYXVsdFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBtYXBUeXBlID0gcmVxdWlyZSgnLi9tYXBUeXBlJyk7XG52YXIgbWFwU2l6ZSA9IHJlcXVpcmUoJy4vbWFwU2l6ZScpO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBhdHRyaWJ1dGVzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHByb2dyYW0ge1dlYkdMUHJvZ3JhbX0gVGhlIHNoYWRlciBwcm9ncmFtIHRvIGdldCB0aGUgYXR0cmlidXRlcyBmcm9tXG4gKiBAcmV0dXJuIGF0dHJpYnV0ZXMge09iamVjdH1cbiAqL1xudmFyIGV4dHJhY3RBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pXG57XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHZhciB0b3RhbEF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxBdHRyaWJ1dGVzOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgYXR0cmliRGF0YSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXBUeXBlKGdsLCBhdHRyaWJEYXRhLnR5cGUpO1xuXG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmliRGF0YS5uYW1lXSA9IHtcbiAgICAgICAgICAgIHR5cGU6dHlwZSxcbiAgICAgICAgICAgIHNpemU6bWFwU2l6ZSh0eXBlKSxcbiAgICAgICAgICAgIGxvY2F0aW9uOmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYkRhdGEubmFtZSksXG4gICAgICAgICAgICAvL1RPRE8gLSBtYWtlIGFuIGF0dHJpYnV0ZSBvYmplY3RcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbnZhciBwb2ludGVyID0gZnVuY3Rpb24odHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBzdGFydCl7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5sb2NhdGlvbilcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMubG9jYXRpb24sdGhpcy5zaXplLCB0eXBlIHx8IGdsLkZMT0FULCBub3JtYWxpemVkIHx8IGZhbHNlLCBzdHJpZGUgfHwgMCwgc3RhcnQgfHwgMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dHJhY3RBdHRyaWJ1dGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2V4dHJhY3RBdHRyaWJ1dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWFwVHlwZSA9IHJlcXVpcmUoJy4vbWFwVHlwZScpO1xudmFyIGRlZmF1bHRWYWx1ZSA9IHJlcXVpcmUoJy4vZGVmYXVsdFZhbHVlJyk7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIHVuaWZvcm1zXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHByb2dyYW0ge1dlYkdMUHJvZ3JhbX0gVGhlIHNoYWRlciBwcm9ncmFtIHRvIGdldCB0aGUgdW5pZm9ybXMgZnJvbVxuICogQHJldHVybiB1bmlmb3JtcyB7T2JqZWN0fVxuICovXG52YXIgZXh0cmFjdFVuaWZvcm1zID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pXG57XG5cdHZhciB1bmlmb3JtcyA9IHt9O1xuXG4gICAgdmFyIHRvdGFsVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsVW5pZm9ybXM7IGkrKylcbiAgICB7XG4gICAgXHR2YXIgdW5pZm9ybURhdGEgPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpO1xuICAgIFx0dmFyIG5hbWUgPSB1bmlmb3JtRGF0YS5uYW1lLnJlcGxhY2UoL1xcWy4qP1xcXS8sIFwiXCIpO1xuICAgICAgICB2YXIgdHlwZSA9IG1hcFR5cGUoZ2wsIHVuaWZvcm1EYXRhLnR5cGUgKTtcblxuICAgIFx0dW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgXHRcdHR5cGU6dHlwZSxcbiAgICBcdFx0c2l6ZTp1bmlmb3JtRGF0YS5zaXplLFxuICAgIFx0XHRsb2NhdGlvbjpnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSksXG4gICAgXHRcdHZhbHVlOmRlZmF1bHRWYWx1ZSh0eXBlLCB1bmlmb3JtRGF0YS5zaXplKVxuICAgIFx0fTtcbiAgICB9XG5cblx0cmV0dXJuIHVuaWZvcm1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHRyYWN0VW5pZm9ybXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvZXh0cmFjdFVuaWZvcm1zLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEV4dHJhY3RzIHRoZSBhdHRyaWJ1dGVzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHVuaWZvcm1zIHtBcnJheX0gQG1hdCA/XG4gKiBAcmV0dXJuIGF0dHJpYnV0ZXMge09iamVjdH1cbiAqL1xudmFyIGdlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdCA9IGZ1bmN0aW9uKGdsLCB1bmlmb3JtRGF0YSlcbntcbiAgICAvLyB0aGlzIGlzIHRoZSBvYmplY3Qgd2Ugd2lsbCBiZSBzZW5kaW5nIGJhY2suXG4gICAgLy8gYW4gb2JqZWN0IGhpZXJhY2h5IHdpbGwgYmUgY3JlYXRlZCBmb3Igc3RydWN0c1xuICAgIHZhciB1bmlmb3JtcyA9IHtkYXRhOnt9fTtcblxuICAgIHVuaWZvcm1zLmdsID0gZ2w7XG5cbiAgICB2YXIgdW5pZm9ybUtleXM9IE9iamVjdC5rZXlzKHVuaWZvcm1EYXRhKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pZm9ybUtleXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgZnVsbE5hbWUgPSB1bmlmb3JtS2V5c1tpXTtcblxuICAgICAgICB2YXIgbmFtZVRva2VucyA9IGZ1bGxOYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZVRva2Vuc1tuYW1lVG9rZW5zLmxlbmd0aCAtIDFdO1xuXG5cbiAgICAgICAgdmFyIHVuaWZvcm1Hcm91cCA9IGdldFVuaWZvcm1Hcm91cChuYW1lVG9rZW5zLCB1bmlmb3Jtcyk7XG5cbiAgICAgICAgdmFyIHVuaWZvcm0gPSAgdW5pZm9ybURhdGFbZnVsbE5hbWVdO1xuICAgICAgICB1bmlmb3JtR3JvdXAuZGF0YVtuYW1lXSA9IHVuaWZvcm07XG5cbiAgICAgICAgdW5pZm9ybUdyb3VwLmdsID0gZ2w7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHVuaWZvcm1Hcm91cCwgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBnZW5lcmF0ZUdldHRlcihuYW1lKSxcbiAgICAgICAgICAgIHNldDogZ2VuZXJhdGVTZXR0ZXIobmFtZSwgdW5pZm9ybSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xufTtcblxudmFyIGdlbmVyYXRlR2V0dGVyID0gZnVuY3Rpb24obmFtZSlcbntcblx0dmFyIHRlbXBsYXRlID0gZ2V0dGVyVGVtcGxhdGUucmVwbGFjZSgnJSUnLCBuYW1lKTtcblx0cmV0dXJuIG5ldyBGdW5jdGlvbih0ZW1wbGF0ZSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxufTtcblxudmFyIGdlbmVyYXRlU2V0dGVyID0gZnVuY3Rpb24obmFtZSwgdW5pZm9ybSlcbntcbiAgICB2YXIgdGVtcGxhdGUgPSBzZXR0ZXJUZW1wbGF0ZS5yZXBsYWNlKC8lJS9nLCBuYW1lKTtcbiAgICB2YXIgc2V0VGVtcGxhdGU7XG5cbiAgICBpZih1bmlmb3JtLnNpemUgPT09IDEpXG4gICAge1xuICAgICAgICBzZXRUZW1wbGF0ZSA9IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNbdW5pZm9ybS50eXBlXTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgc2V0VGVtcGxhdGUgPSBHTFNMX1RPX0FSUkFZX1NFVFRFUlNbdW5pZm9ybS50eXBlXTtcbiAgICB9XG5cbiAgICBpZihzZXRUZW1wbGF0ZSlcbiAgICB7XG4gICAgICAgIHRlbXBsYXRlICs9IFwiXFxudGhpcy5nbC5cIiArIHNldFRlbXBsYXRlICsgXCI7XCI7XG4gICAgfVxuXG4gIFx0cmV0dXJuIG5ldyBGdW5jdGlvbigndmFsdWUnLCB0ZW1wbGF0ZSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxufTtcblxudmFyIGdldFVuaWZvcm1Hcm91cCA9IGZ1bmN0aW9uKG5hbWVUb2tlbnMsIHVuaWZvcm0pXG57XG4gICAgdmFyIGN1ciA9IHVuaWZvcm07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVUb2tlbnMubGVuZ3RoIC0gMTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIG8gPSBjdXJbbmFtZVRva2Vuc1tpXV0gfHwge2RhdGE6e319O1xuICAgICAgICBjdXJbbmFtZVRva2Vuc1tpXV0gPSBvO1xuICAgICAgICBjdXIgPSBvO1xuICAgIH1cblxuICAgIHJldHVybiBjdXI7XG59O1xuXG52YXIgZ2V0dGVyVGVtcGxhdGUgPSBbXG4gICAgJ3JldHVybiB0aGlzLmRhdGEuJSUudmFsdWU7Jyxcbl0uam9pbignXFxuJyk7XG5cbnZhciBzZXR0ZXJUZW1wbGF0ZSA9IFtcbiAgICAndGhpcy5kYXRhLiUlLnZhbHVlID0gdmFsdWU7JyxcbiAgICAndmFyIGxvY2F0aW9uID0gdGhpcy5kYXRhLiUlLmxvY2F0aW9uOydcbl0uam9pbignXFxuJyk7XG5cblxudmFyIEdMU0xfVE9fU0lOR0xFX1NFVFRFUlMgPSB7XG5cbiAgICAnZmxvYXQnOiAgICAndW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSknLFxuXG4gICAgJ3ZlYzInOiAgICAgJ3VuaWZvcm0yZihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdKScsXG4gICAgJ3ZlYzMnOiAgICAgJ3VuaWZvcm0zZihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSknLFxuICAgICd2ZWM0JzogICAgICd1bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzNdKScsXG5cbiAgICAnaW50JzogICAgICAndW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdpdmVjMic6ICAgICd1bmlmb3JtMmkobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSknLFxuICAgICdpdmVjMyc6ICAgICd1bmlmb3JtM2kobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0pJyxcbiAgICAnaXZlYzQnOiAgICAndW5pZm9ybTRpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSknLFxuXG4gICAgJ2Jvb2wnOiAgICAgJ3VuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnYnZlYzInOiAgICAndW5pZm9ybTJpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pJyxcbiAgICAnYnZlYzMnOiAgICAndW5pZm9ybTNpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdKScsXG4gICAgJ2J2ZWM0JzogICAgJ3VuaWZvcm00aShsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM10pJyxcblxuICAgICdtYXQyJzogICAgICd1bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpJyxcbiAgICAnbWF0Myc6ICAgICAndW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKScsXG4gICAgJ21hdDQnOiAgICAgJ3VuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSknLFxuXG4gICAgJ3NhbXBsZXIyRCc6J3VuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpJ1xufTtcblxudmFyIEdMU0xfVE9fQVJSQVlfU0VUVEVSUyA9IHtcblxuICAgICdmbG9hdCc6ICAgICd1bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSknLFxuXG4gICAgJ3ZlYzInOiAgICAgJ3VuaWZvcm0yZnYobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ3ZlYzMnOiAgICAgJ3VuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ3ZlYzQnOiAgICAgJ3VuaWZvcm00ZnYobG9jYXRpb24sIHZhbHVlKScsXG5cbiAgICAnaW50JzogICAgICAndW5pZm9ybTFpdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnaXZlYzInOiAgICAndW5pZm9ybTJpdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnaXZlYzMnOiAgICAndW5pZm9ybTNpdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnaXZlYzQnOiAgICAndW5pZm9ybTRpdihsb2NhdGlvbiwgdmFsdWUpJyxcblxuICAgICdib29sJzogICAgICd1bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdidmVjMic6ICAgICd1bmlmb3JtMml2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdidmVjMyc6ICAgICd1bmlmb3JtM2l2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdidmVjNCc6ICAgICd1bmlmb3JtNGl2KGxvY2F0aW9uLCB2YWx1ZSknLFxuXG4gICAgJ3NhbXBsZXIyRCc6J3VuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlKSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2dlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBtYXBTaXplID0gZnVuY3Rpb24odHlwZSkgXG57IFxuICAgIHJldHVybiBHTFNMX1RPX1NJWkVbdHlwZV07XG59O1xuXG5cbnZhciBHTFNMX1RPX1NJWkUgPSB7XG4gICAgJ2Zsb2F0JzogICAgMSxcbiAgICAndmVjMic6ICAgICAyLFxuICAgICd2ZWMzJzogICAgIDMsXG4gICAgJ3ZlYzQnOiAgICAgNCxcblxuICAgICdpbnQnOiAgICAgIDEsXG4gICAgJ2l2ZWMyJzogICAgMixcbiAgICAnaXZlYzMnOiAgICAzLFxuICAgICdpdmVjNCc6ICAgIDQsXG5cbiAgICAnYm9vbCc6ICAgICAxLFxuICAgICdidmVjMic6ICAgIDIsXG4gICAgJ2J2ZWMzJzogICAgMyxcbiAgICAnYnZlYzQnOiAgICA0LFxuXG4gICAgJ21hdDInOiAgICAgNCxcbiAgICAnbWF0Myc6ICAgICA5LFxuICAgICdtYXQ0JzogICAgIDE2LFxuXG4gICAgJ3NhbXBsZXIyRCc6ICAxXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFNpemU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvbWFwU2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBTZXRzIHRoZSBmbG9hdCBwcmVjaXNpb24gb24gdGhlIHNoYWRlci4gSWYgdGhlIHByZWNpc2lvbiBpcyBhbHJlYWR5IHByZXNlbnQgdGhpcyBmdW5jdGlvbiB3aWxsIGRvIG5vdGhpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgICAgICAgdGhlIHNoYWRlciBzb3VyY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVjaXNpb24gVGhlIGZsb2F0IHByZWNpc2lvbiBvZiB0aGUgc2hhZGVyLiBPcHRpb25zIGFyZSAnbG93cCcsICdtZWRpdW1wJyBvciAnaGlnaHAnLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gbW9kaWZpZWQgc2hhZGVyIHNvdXJjZVxuICovXG52YXIgc2V0UHJlY2lzaW9uID0gZnVuY3Rpb24oc3JjLCBwcmVjaXNpb24pXG57XG4gICAgaWYoc3JjLnN1YnN0cmluZygwLCA5KSAhPT0gJ3ByZWNpc2lvbicpXG4gICAge1xuICAgICAgICByZXR1cm4gJ3ByZWNpc2lvbiAnICsgcHJlY2lzaW9uICsgJyBmbG9hdDtcXG4nICsgc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBzcmM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFByZWNpc2lvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9zZXRQcmVjaXNpb24uanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYXV0b0RldGVjdFJlbmRlcmVyID0gYXV0b0RldGVjdFJlbmRlcmVyO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX0NhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyk7XG5cbnZhciBfQ2FudmFzUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzUmVuZGVyZXIpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyk7XG5cbnZhciBfV2ViR0xSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJHTFJlbmRlcmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoaWNoIHJlbmRlcmVyIHlvdSBzaG91bGQgYmUgdXNpbmcuXG4gKiBXZWJHTCBpcyB0aGUgcHJlZmVycmVkIHJlbmRlcmVyIGFzIGl0IGlzIGEgbG90IGZhc3Rlci4gSWYgd2ViR0wgaXMgbm90IHN1cHBvcnRlZCBieVxuICogdGhlIGJyb3dzZXIgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgY2FudmFzIHJlbmRlcmVyXG4gKlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBmdW5jdGlvbiBhdXRvRGV0ZWN0UmVuZGVyZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9ODAwXSAtIHRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTYwMF0gLSB0aGUgaGVpZ2h0IG9mIHRoZSByZW5kZXJlcnMgdmlld1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBbb3B0aW9ucy52aWV3XSAtIHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0gLSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdIC0gZW5hYmxlcyBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb24sIGVuYWJsZSB0aGlzIGlmIHlvdVxuICogICAgICBuZWVkIHRvIGNhbGwgdG9EYXRhVXJsIG9uIHRoZSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlciwgcmV0aW5hIHdvdWxkIGJlIDJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vV2ViR0w9ZmFsc2VdIC0gcHJldmVudHMgc2VsZWN0aW9uIG9mIFdlYkdMIHJlbmRlcmVyLCBldmVuIGlmIHN1Y2ggaXMgcHJlc2VudFxuICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfFBJWEkuQ2FudmFzUmVuZGVyZXJ9IFJldHVybnMgV2ViR0wgcmVuZGVyZXIgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgQ2FudmFzUmVuZGVyZXJcbiAqL1xuZnVuY3Rpb24gYXV0b0RldGVjdFJlbmRlcmVyKCkge1xuICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogODAwO1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDYwMDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgbm9XZWJHTCA9IGFyZ3VtZW50c1szXTtcblxuICAgIGlmICghbm9XZWJHTCAmJiB1dGlscy5pc1dlYkdMU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfV2ViR0xSZW5kZXJlcjIuZGVmYXVsdCh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IF9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdCh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RSZW5kZXJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9hdXRvRGV0ZWN0UmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50ZW1pdHRlcik7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfVHJhbnNmb3JtU3RhdGljID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1TdGF0aWMnKTtcblxudmFyIF9UcmFuc2Zvcm1TdGF0aWMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhbnNmb3JtU3RhdGljKTtcblxudmFyIF9UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG52YXIgX1RyYW5zZm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm0pO1xuXG52YXIgX0JvdW5kcyA9IHJlcXVpcmUoJy4vQm91bmRzJyk7XG5cbnZhciBfQm91bmRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JvdW5kcyk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgRGlzcGxheU9iamVjdCgpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCBvbiB0aGUgc2NyZWVuLlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIGl0cyBvd24gcmF0aGVyIGl0IHNob3VsZCBiZSBleHRlbmRlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQG1peGVzIFBJWEkuaW50ZXJhY3Rpb24uaW50ZXJhY3RpdmVUYXJnZXRcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBEaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoRGlzcGxheU9iamVjdCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpc3BsYXlPYmplY3QoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwbGF5T2JqZWN0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIHZhciBUcmFuc2Zvcm1DbGFzcyA9IF9zZXR0aW5nczIuZGVmYXVsdC5UUkFOU0ZPUk1fTU9ERSA9PT0gX2NvbnN0LlRSQU5TRk9STV9NT0RFLlNUQVRJQyA/IF9UcmFuc2Zvcm1TdGF0aWMyLmRlZmF1bHQgOiBfVHJhbnNmb3JtMi5kZWZhdWx0O1xuXG4gICAgICAgIF90aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbnVsbDtcblxuICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIGNyZWF0ZSBUcmFuc2Zvcm0gZnJvbSBmYWN0b3J5XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXb3JsZCB0cmFuc2Zvcm0gYW5kIGxvY2FsIHRyYW5zZm9ybSBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICogVGhpcyB3aWxsIGJlY29tZSByZWFkLW9ubHkgbGF0ZXIsIHBsZWFzZSBkbyBub3QgYXNzaWduIGFueXRoaW5nIHRoZXJlIHVubGVzcyB5b3Uga25vdyB3aGF0IGFyZSB5b3UgZG9pbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UcmFuc2Zvcm1CYXNlfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybUNsYXNzKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmFscGhhID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZpc2liaWxpdHkgb2YgdGhlIG9iamVjdC4gSWYgZmFsc2UgdGhlIG9iamVjdCB3aWxsIG5vdCBiZSBkcmF3biwgYW5kXG4gICAgICAgICAqIHRoZSB1cGRhdGVUcmFuc2Zvcm0gZnVuY3Rpb24gd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmx5IGFmZmVjdHMgcmVjdXJzaXZlIGNhbGxzIGZyb20gcGFyZW50LiBZb3UgY2FuIGFzayBmb3IgYm91bmRzIG9yIGNhbGwgdXBkYXRlVHJhbnNmb3JtIG1hbnVhbGx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHRoaXMgb2JqZWN0IGJlIHJlbmRlcmVkLCBpZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduIGJ1dCB0aGUgdXBkYXRlVHJhbnNmb3JtXG4gICAgICAgICAqIG1ldGhvZHMgd2lsbCBzdGlsbCBiZSBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgbWFudWFsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Db250YWluZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG11bHRpcGxpZWQgYWxwaGEgb2YgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLndvcmxkQWxwaGEgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJlYSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQgdG8uIFRoaXMgaXMgdXNlZCBhcyBtb3JlIG9mIGFuIG9wdGltaXNhdGlvblxuICAgICAgICAgKiByYXRoZXIgdGhhbiBmaWd1cmluZyBvdXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRpc3BsYXlPYmplY3QgZWFjaCBmcmFtZSB5b3UgY2FuIHNldCB0aGlzIHJlY3RhbmdsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBBbHNvIHdvcmtzIGFzIGFuIGludGVyYWN0aW9uIG1hc2tcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5fZmlsdGVycyA9IG51bGw7XG4gICAgICAgIF90aGlzLl9lbmFibGVkRmlsdGVycyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBib3VuZHMgb2JqZWN0LCB0aGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2JvdW5kcyA9IG5ldyBfQm91bmRzMi5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLl9ib3VuZHNJRCA9IDA7XG4gICAgICAgIF90aGlzLl9sYXN0Qm91bmRzSUQgPSAtMTtcbiAgICAgICAgX3RoaXMuX2JvdW5kc1JlY3QgPSBudWxsO1xuICAgICAgICBfdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9yaWdpbmFsLCBjYWNoZWQgbWFzayBvZiB0aGUgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3N8UElYSS5TcHJpdGV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbWFzayA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkIHZpYSBkZXN0cm95KCkuIElmIHRydWUsIGl0IHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gICAgICpcbiAgICAgKiBUT0RPIC0gT3B0aW1pemF0aW9uIHBhc3MhXG4gICAgICovXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgLy8gbXVsdGlwbHkgdGhlIGFscGhhcy4uXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kcy51cGRhdGVJRCsrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZWN1cnNpdmVseSB1cGRhdGVzIHRyYW5zZm9ybSBvZiBhbGwgb2JqZWN0cyBmcm9tIHRoZSByb290IHRvIHRoaXMgb25lXG4gICAgICogaW50ZXJuYWwgZnVuY3Rpb24gZm9yIHRvTG9jYWwoKVxuICAgICAqL1xuXG5cbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIHNldHRpbmcgdG8gdHJ1ZSB3aWxsIHN0b3AgdGhlIHRyYW5zZm9ybXMgb2YgdGhlIHNjZW5lIGdyYXBoIGZyb21cbiAgICAgKiAgYmVpbmcgdXBkYXRlZC4gVGhpcyBtZWFucyB0aGUgY2FsY3VsYXRpb24gcmV0dXJuZWQgTUFZIGJlIG91dCBvZiBkYXRlIEJVVCB3aWxsIGdpdmUgeW91IGFcbiAgICAgKiAgbmljZSBwZXJmb3JtYW5jZSBib29zdFxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSBPcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYm91bmRzIGNhbGN1bGF0aW9uXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kc0lEICE9PSB0aGlzLl9sYXN0Qm91bmRzSUQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm91bmRzUmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kc1JlY3QgPSBuZXcgX21hdGguUmVjdGFuZ2xlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9ib3VuZHNSZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW3JlY3RdIC0gT3B0aW9uYWwgcmVjdGFuZ2xlIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGJvdW5kcyBjYWxjdWxhdGlvblxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICAgICAqL1xuXG5cbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVJlZiA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybTtcblxuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHNSZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IF9tYXRoLlJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKGZhbHNlLCByZWN0KTtcblxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFJlZjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1SZWY7XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb21cbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtwb2ludF0gLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXG4gICAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFVwZGF0ZT1mYWxzZV0gLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBBIHBvaW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgb2JqZWN0XG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLnRvR2xvYmFsID0gZnVuY3Rpb24gdG9HbG9iYWwocG9zaXRpb24sIHBvaW50KSB7XG4gICAgICAgIHZhciBza2lwVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgd2UgbmVlZCB0byBnaXZlIGl0IGEgdGVtcG9yYXJ5IHBhcmVudCBzbyB0aGF0IGRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gd29ya3MgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1haW5seSB0byBhdm9pZCBhIHBhcmVudCBjaGVjayBpbiB0aGUgbWFpbiBsb29wLiBFdmVyeSBsaXR0bGUgaGVscHMgZm9yIHBlcmZvcm1hbmNlIDopXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIGxvdFxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseShwb3NpdGlvbiwgcG9pbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QgcmVsYXRpdmUgdG8gYW5vdGhlciBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb21cbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gW2Zyb21dIC0gVGhlIERpc3BsYXlPYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBnbG9iYWwgcG9zaXRpb24gZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW3BvaW50XSAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwVXBkYXRlPWZhbHNlXSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7UElYSS5Qb2ludH0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdFxuICAgICAqL1xuXG5cbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS50b0xvY2FsID0gZnVuY3Rpb24gdG9Mb2NhbChwb3NpdGlvbiwgZnJvbSwgcG9pbnQsIHNraXBVcGRhdGUpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgcGFyZW50IGNoZWNrIGlzIGZvciBqdXN0IGluIGNhc2UgdGhlIGl0ZW0gaXMgYSByb290IG9iamVjdC5cbiAgICAgICAgICAgIC8vIElmIGl0IGlzIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBwYXJlbnQgc28gdGhhdCBkaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtIHdvcmtzIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtYWlubHkgdG8gYXZvaWQgYSBwYXJlbnQgY2hlY2sgaW4gdGhlIG1haW4gbG9vcC4gRXZlcnkgbGl0dGxlIGhlbHBzIGZvciBwZXJmb3JtYW5jZSA6KVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbXBseSBhcHBseSB0aGUgbWF0cml4Li5cbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuXG5cbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIHJlbmRlcldlYkdMKHJlbmRlcmVyKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge31cbiAgICAvLyBPVkVSV1JJVEU7XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgO1xuXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUucmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge31cbiAgICAvLyBPVkVSV1JJVEU7XG5cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGFyZW50IENvbnRhaW5lciBvZiB0aGlzIERpc3BsYXlPYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBDb250YWluZXIgdG8gYWRkIHRoaXMgRGlzcGxheU9iamVjdCB0b1xuICAgICAqIEByZXR1cm4ge1BJWEkuQ29udGFpbmVyfSBUaGUgQ29udGFpbmVyIHRoYXQgdGhpcyBEaXNwbGF5T2JqZWN0IHdhcyBhZGRlZCB0b1xuICAgICAqL1xuICAgIDtcblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIHNldFBhcmVudChjb250YWluZXIpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5hZGRDaGlsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzZXQgdGhlIHBvc2l0aW9uLCBzY2FsZSwgc2tldyBhbmQgcGl2b3QgYXQgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSBYIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWD0xXSAtIFRoZSBYIHNjYWxlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVk9MV0gLSBUaGUgWSBzY2FsZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcm90YXRpb249MF0gLSBUaGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NrZXdYPTBdIC0gVGhlIFggc2tldyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tld1k9MF0gLSBUaGUgWSBza2V3IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXZvdFg9MF0gLSBUaGUgWCBwaXZvdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl2b3RZPTBdIC0gVGhlIFkgcGl2b3QgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlXG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIHNldFRyYW5zZm9ybSgpIHtcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICB2YXIgc2NhbGVYID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgICB2YXIgc2NhbGVZID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxO1xuICAgICAgICB2YXIgcm90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICAgIHZhciBza2V3WCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgICAgICAgdmFyIHNrZXdZID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAwO1xuICAgICAgICB2YXIgcGl2b3RYID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiAwO1xuICAgICAgICB2YXIgcGl2b3RZID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiAwO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHk7XG4gICAgICAgIHRoaXMuc2NhbGUueCA9ICFzY2FsZVggPyAxIDogc2NhbGVYO1xuICAgICAgICB0aGlzLnNjYWxlLnkgPSAhc2NhbGVZID8gMSA6IHNjYWxlWTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICB0aGlzLnNrZXcueCA9IHNrZXdYO1xuICAgICAgICB0aGlzLnNrZXcueSA9IHNrZXdZO1xuICAgICAgICB0aGlzLnBpdm90LnggPSBwaXZvdFg7XG4gICAgICAgIHRoaXMucGl2b3QueSA9IHBpdm90WTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBkZXN0cm95IG1ldGhvZCBmb3IgZ2VuZXJpYyBkaXNwbGF5IG9iamVjdHMuIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICogcmVtb3ZlIHRoZSBkaXNwbGF5IG9iamVjdCBmcm9tIGl0cyBwYXJlbnQgQ29udGFpbmVyIGFzIHdlbGwgYXMgcmVtb3ZlXG4gICAgICogYWxsIGN1cnJlbnQgZXZlbnQgbGlzdGVuZXJzIGFuZCBpbnRlcm5hbCByZWZlcmVuY2VzLiBEbyBub3QgdXNlIGEgRGlzcGxheU9iamVjdFxuICAgICAqIGFmdGVyIGNhbGxpbmcgYGRlc3Ryb3lgLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hc2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi54XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhEaXNwbGF5T2JqZWN0LCBbe1xuICAgICAgICBrZXk6ICdfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG5ldyBEaXNwbGF5T2JqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd4JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLnggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHkgYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgICAgICogQW4gYWxpYXMgdG8gcG9zaXRpb24ueVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd5JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd29ybGRUcmFuc2Zvcm0nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIGxvY2FsIGZhY3RvcnM6IHBvc2l0aW9uLCBzY2FsZSwgb3RoZXIgc3R1ZmZcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbG9jYWxUcmFuc2Zvcm0nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR8UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwb3NpdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fFBJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2NhbGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZS5jb3B5KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGl2b3QgcG9pbnQgb2YgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCBpdCByb3RhdGVzIGFyb3VuZFxuICAgICAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR8UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwaXZvdCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdm90O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBpdm90LmNvcHkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBza2V3IGZhY3RvciBmb3IgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2tldycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNrZXc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2tldy5jb3B5KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyb3RhdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBvYmplY3QgaXMgZ2xvYmFsbHkgdmlzaWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3b3JsZFZpc2libGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcztcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgICAgICAgICB9IHdoaWxlIChpdGVtKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuXG4gICAgICAgICAqIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC4gSW4gUElYSSBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGFcbiAgICAgICAgICogUElYSS5HcmFwaGljcyBvciBhIFBJWEkuU3ByaXRlIG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0XG4gICAgICAgICAqIHV0aWxpc2VzIHNoYXBlIGNsaXBwaW5nLiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdG9kbyBGb3IgdGhlIG1vbWVudCwgUElYSS5DYW52YXNSZW5kZXJlciBkb2Vzbid0IHN1cHBvcnQgUElYSS5TcHJpdGUgYXMgbWFzay5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21hc2snLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hc2sucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGZpbHRlcnMgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKiAqIElNUE9SVEFOVDogVGhpcyBpcyBhIHdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAgICAgICAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnbnVsbCdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJbXX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZpbHRlcnMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzICYmIHRoaXMuX2ZpbHRlcnMuc2xpY2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJzID0gdmFsdWUgJiYgdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEaXNwbGF5T2JqZWN0O1xufShfZXZlbnRlbWl0dGVyMi5kZWZhdWx0KTtcblxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3BsYXlPYmplY3Q7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtID0gRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlzcGxheU9iamVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9kaXNwbGF5L0Rpc3BsYXlPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG52YXIgX1RyYW5zZm9ybUJhc2UyID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1CYXNlJyk7XG5cbnZhciBfVHJhbnNmb3JtQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm1CYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBHZW5lcmljIGNsYXNzIHRvIGRlYWwgd2l0aCB0cmFkaXRpb25hbCAyRCBtYXRyaXggdHJhbnNmb3Jtc1xuICogbG9jYWwgdHJhbnNmb3JtYXRpb24gaXMgY2FsY3VsYXRlZCBmcm9tIHBvc2l0aW9uLHNjYWxlLHNrZXcgYW5kIHJvdGF0aW9uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLlRyYW5zZm9ybUJhc2VcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoX1RyYW5zZm9ybUJhc2UpIHtcbiAgX2luaGVyaXRzKFRyYW5zZm9ybSwgX1RyYW5zZm9ybUJhc2UpO1xuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm0pO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICpcbiAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgKi9cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhbnNmb3JtQmFzZS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnBvc2l0aW9uID0gbmV3IF9tYXRoLlBvaW50KDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgKi9cbiAgICBfdGhpcy5zY2FsZSA9IG5ldyBfbWF0aC5Qb2ludCgxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBza2V3IGFtb3VudCwgb24gdGhlIHggYW5kIHkgYXhpcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAqL1xuICAgIF90aGlzLnNrZXcgPSBuZXcgX21hdGguT2JzZXJ2YWJsZVBvaW50KF90aGlzLnVwZGF0ZVNrZXcsIF90aGlzLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgZGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqL1xuICAgIF90aGlzLnBpdm90ID0gbmV3IF9tYXRoLlBvaW50KDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvdGF0aW9uIHZhbHVlIG9mIHRoZSBvYmplY3QsIGluIHJhZGlhbnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9yb3RhdGlvbiA9IDA7XG5cbiAgICBfdGhpcy5fY3ggPSAxOyAvLyBjb3Mgcm90YXRpb24gKyBza2V3WTtcbiAgICBfdGhpcy5fc3ggPSAwOyAvLyBzaW4gcm90YXRpb24gKyBza2V3WTtcbiAgICBfdGhpcy5fY3kgPSAwOyAvLyBjb3Mgcm90YXRpb24gKyBNYXRoLlBJLzIgLSBza2V3WDtcbiAgICBfdGhpcy5fc3kgPSAxOyAvLyBzaW4gcm90YXRpb24gKyBNYXRoLlBJLzIgLSBza2V3WDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2tldyB2YWx1ZXMgd2hlbiB0aGUgc2tldyBvciByb3RhdGlvbiBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlU2tldyA9IGZ1bmN0aW9uIHVwZGF0ZVNrZXcoKSB7XG4gICAgdGhpcy5fY3ggPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy5feSk7XG4gICAgdGhpcy5fc3ggPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy5feSk7XG4gICAgdGhpcy5fY3kgPSAtTWF0aC5zaW4odGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcuX3gpOyAvLyBjb3MsIGFkZGVkIFBJLzJcbiAgICB0aGlzLl9zeSA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5za2V3Ll94KTsgLy8gc2luLCBhZGRlZCBQSS8yXG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgb25seSBsb2NhbCBtYXRyaXhcbiAgICovXG5cblxuICBUcmFuc2Zvcm0ucHJvdG90eXBlLnVwZGF0ZUxvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgdmFyIGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcblxuICAgIGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUueDtcbiAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLng7XG4gICAgbHQuYyA9IHRoaXMuX2N5ICogdGhpcy5zY2FsZS55O1xuICAgIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUueTtcblxuICAgIGx0LnR4ID0gdGhpcy5wb3NpdGlvbi54IC0gKHRoaXMucGl2b3QueCAqIGx0LmEgKyB0aGlzLnBpdm90LnkgKiBsdC5jKTtcbiAgICBsdC50eSA9IHRoaXMucG9zaXRpb24ueSAtICh0aGlzLnBpdm90LnggKiBsdC5iICsgdGhpcy5waXZvdC55ICogbHQuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0IGFuZCBhcHBsaWVzIHRoZSBwYXJlbnQncyB0cmFuc2Zvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm19IHBhcmVudFRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gb2YgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdFxuICAgKi9cblxuXG4gIFRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gdXBkYXRlVHJhbnNmb3JtKHBhcmVudFRyYW5zZm9ybSkge1xuICAgIHZhciBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG5cbiAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLng7XG4gICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS54O1xuICAgIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUueTtcbiAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLnk7XG5cbiAgICBsdC50eCA9IHRoaXMucG9zaXRpb24ueCAtICh0aGlzLnBpdm90LnggKiBsdC5hICsgdGhpcy5waXZvdC55ICogbHQuYyk7XG4gICAgbHQudHkgPSB0aGlzLnBvc2l0aW9uLnkgLSAodGhpcy5waXZvdC54ICogbHQuYiArIHRoaXMucGl2b3QueSAqIGx0LmQpO1xuXG4gICAgLy8gY29uY2F0IHRoZSBwYXJlbnQgbWF0cml4IHdpdGggdGhlIG9iamVjdHMgdHJhbnNmb3JtLlxuICAgIHZhciBwdCA9IHBhcmVudFRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgd3QgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgd3QuYSA9IGx0LmEgKiBwdC5hICsgbHQuYiAqIHB0LmM7XG4gICAgd3QuYiA9IGx0LmEgKiBwdC5iICsgbHQuYiAqIHB0LmQ7XG4gICAgd3QuYyA9IGx0LmMgKiBwdC5hICsgbHQuZCAqIHB0LmM7XG4gICAgd3QuZCA9IGx0LmMgKiBwdC5iICsgbHQuZCAqIHB0LmQ7XG4gICAgd3QudHggPSBsdC50eCAqIHB0LmEgKyBsdC50eSAqIHB0LmMgKyBwdC50eDtcbiAgICB3dC50eSA9IGx0LnR4ICogcHQuYiArIGx0LnR5ICogcHQuZCArIHB0LnR5O1xuXG4gICAgdGhpcy5fd29ybGRJRCsrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvbXBvc2VzIGEgbWF0cml4IGFuZCBzZXRzIHRoZSB0cmFuc2Zvcm1zIHByb3BlcnRpZXMgYmFzZWQgb24gaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gZGVjb21wb3NlXG4gICAqL1xuXG5cbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRGcm9tTWF0cml4ID0gZnVuY3Rpb24gc2V0RnJvbU1hdHJpeChtYXRyaXgpIHtcbiAgICBtYXRyaXguZGVjb21wb3NlKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybSwgW3tcbiAgICBrZXk6ICdyb3RhdGlvbicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAge1xuICAgICAgdGhpcy5fcm90YXRpb24gPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlU2tldygpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm07XG59KF9UcmFuc2Zvcm1CYXNlMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL2Rpc3BsYXkvVHJhbnNmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxudmFyIF9UcmFuc2Zvcm1CYXNlMiA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtQmFzZScpO1xuXG52YXIgX1RyYW5zZm9ybUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhbnNmb3JtQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoYXQgdGFrZXMgY2FyZSBhYm91dCBpdHMgdmVyc2lvbnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuVHJhbnNmb3JtQmFzZVxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFRyYW5zZm9ybVN0YXRpYyA9IGZ1bmN0aW9uIChfVHJhbnNmb3JtQmFzZSkge1xuICAgIF9pbmhlcml0cyhUcmFuc2Zvcm1TdGF0aWMsIF9UcmFuc2Zvcm1CYXNlKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGljKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtU3RhdGljKTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAgICAqXG4gICAgICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICovXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFuc2Zvcm1CYXNlLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gbmV3IF9tYXRoLk9ic2VydmFibGVQb2ludChfdGhpcy5vbkNoYW5nZSwgX3RoaXMsIDAsIDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc2NhbGUgPSBuZXcgX21hdGguT2JzZXJ2YWJsZVBvaW50KF90aGlzLm9uQ2hhbmdlLCBfdGhpcywgMSwgMSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgZGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucGl2b3QgPSBuZXcgX21hdGguT2JzZXJ2YWJsZVBvaW50KF90aGlzLm9uQ2hhbmdlLCBfdGhpcywgMCwgMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBza2V3IGFtb3VudCwgb24gdGhlIHggYW5kIHkgYXhpcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5za2V3ID0gbmV3IF9tYXRoLk9ic2VydmFibGVQb2ludChfdGhpcy51cGRhdGVTa2V3LCBfdGhpcywgMCwgMCk7XG5cbiAgICAgICAgX3RoaXMuX3JvdGF0aW9uID0gMDtcblxuICAgICAgICBfdGhpcy5fY3ggPSAxOyAvLyBjb3Mgcm90YXRpb24gKyBza2V3WTtcbiAgICAgICAgX3RoaXMuX3N4ID0gMDsgLy8gc2luIHJvdGF0aW9uICsgc2tld1k7XG4gICAgICAgIF90aGlzLl9jeSA9IDA7IC8vIGNvcyByb3RhdGlvbiArIE1hdGguUEkvMiAtIHNrZXdYO1xuICAgICAgICBfdGhpcy5fc3kgPSAxOyAvLyBzaW4gcm90YXRpb24gKyBNYXRoLlBJLzIgLSBza2V3WDtcblxuICAgICAgICBfdGhpcy5fbG9jYWxJRCA9IDA7XG4gICAgICAgIF90aGlzLl9jdXJyZW50TG9jYWxJRCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHZhbHVlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUcmFuc2Zvcm1TdGF0aWMucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gc2tldyBvciByb3RhdGlvbiBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUcmFuc2Zvcm1TdGF0aWMucHJvdG90eXBlLnVwZGF0ZVNrZXcgPSBmdW5jdGlvbiB1cGRhdGVTa2V3KCkge1xuICAgICAgICB0aGlzLl9jeCA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3Ll95KTtcbiAgICAgICAgdGhpcy5fc3ggPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy5feSk7XG4gICAgICAgIHRoaXMuX2N5ID0gLU1hdGguc2luKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5za2V3Ll94KTsgLy8gY29zLCBhZGRlZCBQSS8yXG4gICAgICAgIHRoaXMuX3N5ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcuX3gpOyAvLyBzaW4sIGFkZGVkIFBJLzJcblxuICAgICAgICB0aGlzLl9sb2NhbElEKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgb25seSBsb2NhbCBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgVHJhbnNmb3JtU3RhdGljLnByb3RvdHlwZS51cGRhdGVMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2FsVHJhbnNmb3JtKCkge1xuICAgICAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYXRyaXggdmFsdWVzIG9mIHRoZSBkaXNwbGF5b2JqZWN0IGJhc2VkIG9uIGl0cyB0cmFuc2Zvcm0gcHJvcGVydGllcy4uXG4gICAgICAgICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLl94O1xuICAgICAgICAgICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS5feDtcbiAgICAgICAgICAgIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUuX3k7XG4gICAgICAgICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLl95O1xuXG4gICAgICAgICAgICBsdC50eCA9IHRoaXMucG9zaXRpb24uX3ggLSAodGhpcy5waXZvdC5feCAqIGx0LmEgKyB0aGlzLnBpdm90Ll95ICogbHQuYyk7XG4gICAgICAgICAgICBsdC50eSA9IHRoaXMucG9zaXRpb24uX3kgLSAodGhpcy5waXZvdC5feCAqIGx0LmIgKyB0aGlzLnBpdm90Ll95ICogbHQuZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XG5cbiAgICAgICAgICAgIC8vIGZvcmNlIGFuIHVwZGF0ZS4uXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0IGFuZCBhcHBsaWVzIHRoZSBwYXJlbnQncyB0cmFuc2Zvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSBwYXJlbnRUcmFuc2Zvcm0gLSBUaGUgdHJhbnNmb3JtIG9mIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgVHJhbnNmb3JtU3RhdGljLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiB1cGRhdGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsSUQgIT09IHRoaXMuX2N1cnJlbnRMb2NhbElEKSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIG1hdHJpeCB2YWx1ZXMgb2YgdGhlIGRpc3BsYXlvYmplY3QgYmFzZWQgb24gaXRzIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLi5cbiAgICAgICAgICAgIGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUuX3g7XG4gICAgICAgICAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLl94O1xuICAgICAgICAgICAgbHQuYyA9IHRoaXMuX2N5ICogdGhpcy5zY2FsZS5feTtcbiAgICAgICAgICAgIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUuX3k7XG5cbiAgICAgICAgICAgIGx0LnR4ID0gdGhpcy5wb3NpdGlvbi5feCAtICh0aGlzLnBpdm90Ll94ICogbHQuYSArIHRoaXMucGl2b3QuX3kgKiBsdC5jKTtcbiAgICAgICAgICAgIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi5feSAtICh0aGlzLnBpdm90Ll94ICogbHQuYiArIHRoaXMucGl2b3QuX3kgKiBsdC5kKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbElEID0gdGhpcy5fbG9jYWxJRDtcblxuICAgICAgICAgICAgLy8gZm9yY2UgYW4gdXBkYXRlLi5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudElEID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcGFyZW50SUQgIT09IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCkge1xuICAgICAgICAgICAgLy8gY29uY2F0IHRoZSBwYXJlbnQgbWF0cml4IHdpdGggdGhlIG9iamVjdHMgdHJhbnNmb3JtLlxuICAgICAgICAgICAgdmFyIHB0ID0gcGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgICAgICAgICAgd3QuYSA9IGx0LmEgKiBwdC5hICsgbHQuYiAqIHB0LmM7XG4gICAgICAgICAgICB3dC5iID0gbHQuYSAqIHB0LmIgKyBsdC5iICogcHQuZDtcbiAgICAgICAgICAgIHd0LmMgPSBsdC5jICogcHQuYSArIGx0LmQgKiBwdC5jO1xuICAgICAgICAgICAgd3QuZCA9IGx0LmMgKiBwdC5iICsgbHQuZCAqIHB0LmQ7XG4gICAgICAgICAgICB3dC50eCA9IGx0LnR4ICogcHQuYSArIGx0LnR5ICogcHQuYyArIHB0LnR4O1xuICAgICAgICAgICAgd3QudHkgPSBsdC50eCAqIHB0LmIgKyBsdC50eSAqIHB0LmQgKyBwdC50eTtcblxuICAgICAgICAgICAgdGhpcy5fcGFyZW50SUQgPSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQ7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaWQgb2YgdGhlIHRyYW5zZm9ybS4uXG4gICAgICAgICAgICB0aGlzLl93b3JsZElEKys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb21wb3NlcyBhIG1hdHJpeCBhbmQgc2V0cyB0aGUgdHJhbnNmb3JtcyBwcm9wZXJ0aWVzIGJhc2VkIG9uIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBkZWNvbXBvc2VcbiAgICAgKi9cblxuXG4gICAgVHJhbnNmb3JtU3RhdGljLnByb3RvdHlwZS5zZXRGcm9tTWF0cml4ID0gZnVuY3Rpb24gc2V0RnJvbU1hdHJpeChtYXRyaXgpIHtcbiAgICAgICAgbWF0cml4LmRlY29tcG9zZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fbG9jYWxJRCsrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtU3RhdGljLCBbe1xuICAgICAgICBrZXk6ICdyb3RhdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNrZXcoKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUcmFuc2Zvcm1TdGF0aWM7XG59KF9UcmFuc2Zvcm1CYXNlMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNmb3JtU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtU3RhdGljLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL2Rpc3BsYXkvVHJhbnNmb3JtU3RhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBBIEdyYXBoaWNzRGF0YSBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgR3JhcGhpY3NEYXRhID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lQ29sb3IgLSB0aGUgY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZUFscGhhIC0gdGhlIGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpbGxDb2xvciAtIHRoZSBjb2xvciBvZiB0aGUgZmlsbFxuICAgKiBAcGFyYW0ge251bWJlcn0gZmlsbEFscGhhIC0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsbCAtIHdoZXRoZXIgb3Igbm90IHRoZSBzaGFwZSBpcyBmaWxsZWQgd2l0aCBhIGNvbG91clxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5hdGl2ZUxpbmVzIC0gdGhlIG1ldGhvZCBmb3IgZHJhd2luZyBsaW5lc1xuICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuUmVjdGFuZ2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb259IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICAgKi9cbiAgZnVuY3Rpb24gR3JhcGhpY3NEYXRhKGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsIGZpbGxDb2xvciwgZmlsbEFscGhhLCBmaWxsLCBuYXRpdmVMaW5lcywgc2hhcGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhpY3NEYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBpZiB0cnVlIHRoZSBsaWVucyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxuICAgICAqL1xuICAgIHRoaXMubmF0aXZlTGluZXMgPSBuYXRpdmVMaW5lcztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGNvbG9yIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVDb2xvciA9IGxpbmVDb2xvcjtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVBbHBoYSA9IGxpbmVBbHBoYTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gY2FjaGVkIHRpbnQgb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgICAqL1xuICAgIHRoaXMuX2xpbmVUaW50ID0gbGluZUNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAgICAgKi9cbiAgICB0aGlzLmZpbGxDb2xvciA9IGZpbGxDb2xvcjtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gICAgICovXG4gICAgdGhpcy5maWxsQWxwaGEgPSBmaWxsQWxwaGE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGNhY2hlZCB0aW50IG9mIHRoZSBmaWxsXG4gICAgICovXG4gICAgdGhpcy5fZmlsbFRpbnQgPSBmaWxsQ29sb3I7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgaXMgZmlsbGVkIHdpdGggYSBjb2xvdXJcbiAgICAgKi9cbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xuXG4gICAgdGhpcy5ob2xlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFRoZSB0eXBlIG9mIHRoZSBzaGFwZSwgc2VlIHRoZSBDb25zdC5TaGFwZXMgZmlsZSBmb3IgYWxsIHRoZSBleGlzdGluZyB0eXBlcyxcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3NEYXRhIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICpcbiAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0RhdGF9IENsb25lZCBHcmFwaGljc0RhdGEgb2JqZWN0XG4gICAqL1xuXG5cbiAgR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKHRoaXMubGluZVdpZHRoLCB0aGlzLmxpbmVDb2xvciwgdGhpcy5saW5lQWxwaGEsIHRoaXMuZmlsbENvbG9yLCB0aGlzLmZpbGxBbHBoYSwgdGhpcy5maWxsLCB0aGlzLm5hdGl2ZUxpbmVzLCB0aGlzLnNoYXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIGhvbGUgdG8gdGhlIHNoYXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfFBJWEkuQ2lyY2xlfSBzaGFwZSAtIFRoZSBzaGFwZSBvZiB0aGUgaG9sZS5cbiAgICovXG5cblxuICBHcmFwaGljc0RhdGEucHJvdG90eXBlLmFkZEhvbGUgPSBmdW5jdGlvbiBhZGRIb2xlKHNoYXBlKSB7XG4gICAgdGhpcy5ob2xlcy5wdXNoKHNoYXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIEdyYXBoaWNzIGRhdGEuXG4gICAqL1xuXG5cbiAgR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnNoYXBlID0gbnVsbDtcbiAgICB0aGlzLmhvbGVzID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gR3JhcGhpY3NEYXRhO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBHcmFwaGljc0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0RhdGEuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvZ3JhcGhpY3MvR3JhcGhpY3NEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmF1dG9EZXRlY3RSZW5kZXJlciA9IGV4cG9ydHMuQXBwbGljYXRpb24gPSBleHBvcnRzLkZpbHRlciA9IGV4cG9ydHMuU3ByaXRlTWFza0ZpbHRlciA9IGV4cG9ydHMuUXVhZCA9IGV4cG9ydHMuUmVuZGVyVGFyZ2V0ID0gZXhwb3J0cy5PYmplY3RSZW5kZXJlciA9IGV4cG9ydHMuV2ViR0xNYW5hZ2VyID0gZXhwb3J0cy5TaGFkZXIgPSBleHBvcnRzLkNhbnZhc1JlbmRlclRhcmdldCA9IGV4cG9ydHMuVGV4dHVyZVV2cyA9IGV4cG9ydHMuVmlkZW9CYXNlVGV4dHVyZSA9IGV4cG9ydHMuQmFzZVJlbmRlclRleHR1cmUgPSBleHBvcnRzLlJlbmRlclRleHR1cmUgPSBleHBvcnRzLkJhc2VUZXh0dXJlID0gZXhwb3J0cy5UZXh0dXJlID0gZXhwb3J0cy5TcHJpdGVzaGVldCA9IGV4cG9ydHMuQ2FudmFzR3JhcGhpY3NSZW5kZXJlciA9IGV4cG9ydHMuR3JhcGhpY3NSZW5kZXJlciA9IGV4cG9ydHMuR3JhcGhpY3NEYXRhID0gZXhwb3J0cy5HcmFwaGljcyA9IGV4cG9ydHMuVGV4dFN0eWxlID0gZXhwb3J0cy5UZXh0ID0gZXhwb3J0cy5TcHJpdGVSZW5kZXJlciA9IGV4cG9ydHMuQ2FudmFzVGludGVyID0gZXhwb3J0cy5DYW52YXNTcHJpdGVSZW5kZXJlciA9IGV4cG9ydHMuU3ByaXRlID0gZXhwb3J0cy5UcmFuc2Zvcm1CYXNlID0gZXhwb3J0cy5UcmFuc2Zvcm1TdGF0aWMgPSBleHBvcnRzLlRyYW5zZm9ybSA9IGV4cG9ydHMuQ29udGFpbmVyID0gZXhwb3J0cy5EaXNwbGF5T2JqZWN0ID0gZXhwb3J0cy5Cb3VuZHMgPSBleHBvcnRzLmdsQ29yZSA9IGV4cG9ydHMuV2ViR0xSZW5kZXJlciA9IGV4cG9ydHMuQ2FudmFzUmVuZGVyZXIgPSBleHBvcnRzLnRpY2tlciA9IGV4cG9ydHMudXRpbHMgPSBleHBvcnRzLnNldHRpbmdzID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuXG5PYmplY3Qua2V5cyhfY29uc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb25zdFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5cbk9iamVjdC5rZXlzKF9tYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfbWF0aFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9waXhpR2xDb3JlID0gcmVxdWlyZSgncGl4aS1nbC1jb3JlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2xDb3JlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGl4aUdsQ29yZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQm91bmRzID0gcmVxdWlyZSgnLi9kaXNwbGF5L0JvdW5kcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0JvdW5kcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JvdW5kcykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRGlzcGxheU9iamVjdCA9IHJlcXVpcmUoJy4vZGlzcGxheS9EaXNwbGF5T2JqZWN0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRGlzcGxheU9iamVjdCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Rpc3BsYXlPYmplY3QpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vZGlzcGxheS9Db250YWluZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDb250YWluZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250YWluZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZGlzcGxheS9UcmFuc2Zvcm0nKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUcmFuc2Zvcm0nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm0pLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RyYW5zZm9ybVN0YXRpYyA9IHJlcXVpcmUoJy4vZGlzcGxheS9UcmFuc2Zvcm1TdGF0aWMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUcmFuc2Zvcm1TdGF0aWMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm1TdGF0aWMpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1RyYW5zZm9ybUJhc2UgPSByZXF1aXJlKCcuL2Rpc3BsYXkvVHJhbnNmb3JtQmFzZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RyYW5zZm9ybUJhc2UnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2Zvcm1CYXNlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9TcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZXMvU3ByaXRlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3ByaXRlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3ByaXRlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYW52YXNTcHJpdGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vc3ByaXRlcy9jYW52YXMvQ2FudmFzU3ByaXRlUmVuZGVyZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDYW52YXNTcHJpdGVSZW5kZXJlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1Nwcml0ZVJlbmRlcmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYW52YXNUaW50ZXIgPSByZXF1aXJlKCcuL3Nwcml0ZXMvY2FudmFzL0NhbnZhc1RpbnRlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NhbnZhc1RpbnRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1RpbnRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfU3ByaXRlUmVuZGVyZXIgPSByZXF1aXJlKCcuL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTcHJpdGVSZW5kZXJlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Nwcml0ZVJlbmRlcmVyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9UZXh0ID0gcmVxdWlyZSgnLi90ZXh0L1RleHQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUZXh0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfVGV4dFN0eWxlID0gcmVxdWlyZSgnLi90ZXh0L1RleHRTdHlsZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RleHRTdHlsZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHRTdHlsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfR3JhcGhpY3MgPSByZXF1aXJlKCcuL2dyYXBoaWNzL0dyYXBoaWNzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnR3JhcGhpY3MnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HcmFwaGljcykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfR3JhcGhpY3NEYXRhID0gcmVxdWlyZSgnLi9ncmFwaGljcy9HcmFwaGljc0RhdGEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdHcmFwaGljc0RhdGEnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HcmFwaGljc0RhdGEpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0dyYXBoaWNzUmVuZGVyZXIgPSByZXF1aXJlKCcuL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdHcmFwaGljc1JlbmRlcmVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR3JhcGhpY3NSZW5kZXJlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQ2FudmFzR3JhcGhpY3NSZW5kZXJlciA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MvY2FudmFzL0NhbnZhc0dyYXBoaWNzUmVuZGVyZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDYW52YXNHcmFwaGljc1JlbmRlcmVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzR3JhcGhpY3NSZW5kZXJlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfU3ByaXRlc2hlZXQgPSByZXF1aXJlKCcuL3RleHR1cmVzL1Nwcml0ZXNoZWV0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3ByaXRlc2hlZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcHJpdGVzaGVldCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfVGV4dHVyZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvVGV4dHVyZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RleHR1cmUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0dXJlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9CYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvQmFzZVRleHR1cmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCYXNlVGV4dHVyZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUZXh0dXJlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9SZW5kZXJUZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9SZW5kZXJUZXh0dXJlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUmVuZGVyVGV4dHVyZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbmRlclRleHR1cmUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0Jhc2VSZW5kZXJUZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9CYXNlUmVuZGVyVGV4dHVyZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Jhc2VSZW5kZXJUZXh0dXJlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVJlbmRlclRleHR1cmUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1ZpZGVvQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuL3RleHR1cmVzL1ZpZGVvQmFzZVRleHR1cmUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdWaWRlb0Jhc2VUZXh0dXJlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmlkZW9CYXNlVGV4dHVyZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfVGV4dHVyZVV2cyA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvVGV4dHVyZVV2cycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RleHR1cmVVdnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZXh0dXJlVXZzKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYW52YXNSZW5kZXJUYXJnZXQgPSByZXF1aXJlKCcuL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzUmVuZGVyVGFyZ2V0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ2FudmFzUmVuZGVyVGFyZ2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzUmVuZGVyVGFyZ2V0KS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9TaGFkZXIgPSByZXF1aXJlKCcuL1NoYWRlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NoYWRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYWRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfV2ViR0xNYW5hZ2VyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvV2ViR0xNYW5hZ2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnV2ViR0xNYW5hZ2VyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xNYW5hZ2VyKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9PYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL09iamVjdFJlbmRlcmVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnT2JqZWN0UmVuZGVyZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYmplY3RSZW5kZXJlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvUmVuZGVyVGFyZ2V0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUmVuZGVyVGFyZ2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVuZGVyVGFyZ2V0KS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9RdWFkID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvUXVhZCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1F1YWQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9RdWFkKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9TcHJpdGVNYXNrRmlsdGVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTcHJpdGVNYXNrRmlsdGVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3ByaXRlTWFza0ZpbHRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRmlsdGVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9GaWx0ZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdGaWx0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GaWx0ZXIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0FwcGxpY2F0aW9uID0gcmVxdWlyZSgnLi9BcHBsaWNhdGlvbicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0FwcGxpY2F0aW9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBwbGljYXRpb24pLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2F1dG9EZXRlY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4vYXV0b0RldGVjdFJlbmRlcmVyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYXV0b0RldGVjdFJlbmRlcmVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2F1dG9EZXRlY3RSZW5kZXJlci5hdXRvRGV0ZWN0UmVuZGVyZXI7XG4gIH1cbn0pO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX3RpY2tlciA9IHJlcXVpcmUoJy4vdGlja2VyJyk7XG5cbnZhciB0aWNrZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGlja2VyKTtcblxudmFyIF9zZXR0aW5ncyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfQ2FudmFzUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcblxudmFyIF9DYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNSZW5kZXJlcik7XG5cbnZhciBfV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXInKTtcblxudmFyIF9XZWJHTFJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dlYkdMUmVuZGVyZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLnNldHRpbmdzID0gX3NldHRpbmdzMi5kZWZhdWx0O1xuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuZXhwb3J0cy50aWNrZXIgPSB0aWNrZXI7XG5leHBvcnRzLkNhbnZhc1JlbmRlcmVyID0gX0NhbnZhc1JlbmRlcmVyMi5kZWZhdWx0O1xuZXhwb3J0cy5XZWJHTFJlbmRlcmVyID0gX1dlYkdMUmVuZGVyZXIyLmRlZmF1bHQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lc3BhY2UgUElYSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9NYXRyaXggPSByZXF1aXJlKCcuL01hdHJpeCcpO1xuXG52YXIgX01hdHJpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXRyaXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdXggPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMV07IC8vIFlvdXIgZnJpZW5kbHkgbmVpZ2hib3VyIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RpaGVkcmFsX2dyb3VwIG9mIG9yZGVyIDE2XG5cbnZhciB1eSA9IFswLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbnZhciB2eCA9IFswLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbnZhciB2eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXTtcbnZhciB0ZW1wTWF0cmljZXMgPSBbXTtcblxudmFyIG11bCA9IFtdO1xuXG5mdW5jdGlvbiBzaWdudW0oeCkge1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IFtdO1xuXG4gICAgICAgIG11bC5wdXNoKHJvdyk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgX3V4ID0gc2lnbnVtKHV4W2ldICogdXhbal0gKyB2eFtpXSAqIHV5W2pdKTtcbiAgICAgICAgICAgIHZhciBfdXkgPSBzaWdudW0odXlbaV0gKiB1eFtqXSArIHZ5W2ldICogdXlbal0pO1xuICAgICAgICAgICAgdmFyIF92eCA9IHNpZ251bSh1eFtpXSAqIHZ4W2pdICsgdnhbaV0gKiB2eVtqXSk7XG4gICAgICAgICAgICB2YXIgX3Z5ID0gc2lnbnVtKHV5W2ldICogdnhbal0gKyB2eVtpXSAqIHZ5W2pdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAxNjsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV4W2tdID09PSBfdXggJiYgdXlba10gPT09IF91eSAmJiB2eFtrXSA9PT0gX3Z4ICYmIHZ5W2tdID09PSBfdnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCAxNjsgX2krKykge1xuICAgICAgICB2YXIgbWF0ID0gbmV3IF9NYXRyaXgyLmRlZmF1bHQoKTtcblxuICAgICAgICBtYXQuc2V0KHV4W19pXSwgdXlbX2ldLCB2eFtfaV0sIHZ5W19pXSwgMCwgMCk7XG4gICAgICAgIHRlbXBNYXRyaWNlcy5wdXNoKG1hdCk7XG4gICAgfVxufVxuXG5pbml0KCk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBEaWhlZHJhbCBHcm91cCBEXzgsIHNlZSBbZ3JvdXAgRDRde0BsaW5rIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vRGloZWRyYWxHcm91cEQ0Lmh0bWx9LFxuICogRDggaXMgdGhlIHNhbWUgYnV0IHdpdGggZGlhZ29uYWxzLiBVc2VkIGZvciB0ZXh0dXJlIHJvdGF0aW9ucy5cbiAqXG4gKiBWZWN0b3IgeFgoaSksIHhZKGkpIGlzIFUtYXhpcyBvZiBzcHJpdGUgd2l0aCByb3RhdGlvbiBpXG4gKiBWZWN0b3IgeVkoaSksIHlZKGkpIGlzIFYtYXhpcyBvZiBzcHJpdGUgd2l0aCByb3RhdGlvbiBpXG4gKiBSb3RhdGlvbnM6IDAgZ3JhZCAoMCksIDkwIGdyYWQgKDIpLCAxODAgZ3JhZCAoNCksIDI3MCBncmFkICg2KVxuICogTWlycm9yczogdmVydGljYWwgKDgpLCBtYWluIGRpYWdvbmFsICgxMCksIGhvcml6b250YWwgKDEyKSwgcmV2ZXJzZSBkaWFnb25hbCAoMTQpXG4gKiBUaGlzIGlzIHRoZSBzbWFsbCBwYXJ0IG9mIGdhbWVvZmJvbWJzLmNvbSBwb3J0YWwgc3lzdGVtLiBJdCB3b3Jrcy5cbiAqXG4gKiBAYXV0aG9yIEl2YW4gQGl2YW5wb3BlbHlzaGV2XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBHcm91cEQ4ID0ge1xuICAgIEU6IDAsXG4gICAgU0U6IDEsXG4gICAgUzogMixcbiAgICBTVzogMyxcbiAgICBXOiA0LFxuICAgIE5XOiA1LFxuICAgIE46IDYsXG4gICAgTkU6IDcsXG4gICAgTUlSUk9SX1ZFUlRJQ0FMOiA4LFxuICAgIE1JUlJPUl9IT1JJWk9OVEFMOiAxMixcbiAgICB1WDogZnVuY3Rpb24gdVgoaW5kKSB7XG4gICAgICAgIHJldHVybiB1eFtpbmRdO1xuICAgIH0sXG4gICAgdVk6IGZ1bmN0aW9uIHVZKGluZCkge1xuICAgICAgICByZXR1cm4gdXlbaW5kXTtcbiAgICB9LFxuICAgIHZYOiBmdW5jdGlvbiB2WChpbmQpIHtcbiAgICAgICAgcmV0dXJuIHZ4W2luZF07XG4gICAgfSxcbiAgICB2WTogZnVuY3Rpb24gdlkoaW5kKSB7XG4gICAgICAgIHJldHVybiB2eVtpbmRdO1xuICAgIH0sXG4gICAgaW52OiBmdW5jdGlvbiBpbnYocm90YXRpb24pIHtcbiAgICAgICAgaWYgKHJvdGF0aW9uICYgOCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0aW9uICYgMTU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLXJvdGF0aW9uICYgNztcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gYWRkKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSB7XG4gICAgICAgIHJldHVybiBtdWxbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdO1xuICAgIH0sXG4gICAgc3ViOiBmdW5jdGlvbiBzdWIocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIG11bFtyb3RhdGlvblNlY29uZF1bR3JvdXBEOC5pbnYocm90YXRpb25GaXJzdCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIDE4MCBkZWdyZWVzIHRvIHJvdGF0aW9uLiBDb21tdXRhdGl2ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5Hcm91cEQ4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gVGhlIG51bWJlciB0byByb3RhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gcm90YXRlZCBudW1iZXJcbiAgICAgKi9cbiAgICByb3RhdGUxODA6IGZ1bmN0aW9uIHJvdGF0ZTE4MChyb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gcm90YXRpb24gXiA0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJIGRvbnQga25vdyB3aHkgc29tZXRpbWVzIHdpZHRoIGFuZCBoZWlnaHRzIG5lZWRzIHRvIGJlIHN3YXBwZWQuIFdlJ2xsIGZpeCBpdCBsYXRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkdyb3VwRDhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gLSBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgd2lkdGgvaGVpZ2h0IHNob3VsZCBiZSBzd2FwcGVkLlxuICAgICAqL1xuICAgIGlzU3dhcFdpZHRoSGVpZ2h0OiBmdW5jdGlvbiBpc1N3YXBXaWR0aEhlaWdodChyb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gKHJvdGF0aW9uICYgMykgPT09IDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkdyb3VwRDhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHggLSBUT0RPXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gVE9ET1xuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUT0RPXG4gICAgICovXG4gICAgYnlEaXJlY3Rpb246IGZ1bmN0aW9uIGJ5RGlyZWN0aW9uKGR4LCBkeSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkpIHtcbiAgICAgICAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguUztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguTjtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkeSkgKiAyIDw9IE1hdGguYWJzKGR4KSkge1xuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LkU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Llc7XG4gICAgICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguU0U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LlNXO1xuICAgICAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguTkU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gR3JvdXBEOC5OVztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscHMgc3ByaXRlIHRvIGNvbXBlbnNhdGUgdGV4dHVyZSBwYWNrZXIgcm90YXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5Hcm91cEQ4XG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gc3ByaXRlIHdvcmxkIG1hdHJpeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBmYWN0b3IgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAtIHNwcml0ZSBhbmNob3JpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHkgLSBzcHJpdGUgYW5jaG9yaW5nXG4gICAgICovXG4gICAgbWF0cml4QXBwZW5kUm90YXRpb25JbnY6IGZ1bmN0aW9uIG1hdHJpeEFwcGVuZFJvdGF0aW9uSW52KG1hdHJpeCwgcm90YXRpb24pIHtcbiAgICAgICAgdmFyIHR4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICB2YXIgdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG5cbiAgICAgICAgLy8gUGFja2VyIHVzZWQgXCJyb3RhdGlvblwiLCB3ZSB1c2UgXCJpbnYocm90YXRpb24pXCJcbiAgICAgICAgdmFyIG1hdCA9IHRlbXBNYXRyaWNlc1tHcm91cEQ4Lmludihyb3RhdGlvbildO1xuXG4gICAgICAgIG1hdC50eCA9IHR4O1xuICAgICAgICBtYXQudHkgPSB0eTtcbiAgICAgICAgbWF0cml4LmFwcGVuZChtYXQpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdyb3VwRDg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hcm91cEQ4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL21hdGgvR3JvdXBEOC5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1BvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xuXG52YXIgX1BvaW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvaW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUaGUgcGl4aSBNYXRyaXggY2xhc3MgYXMgYW4gb2JqZWN0LCB3aGljaCBtYWtlcyBpdCBhIGxvdCBmYXN0ZXIsXG4gKiBoZXJlIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaXQgOlxuICogfCBhIHwgYiB8IHR4fFxuICogfCBjIHwgZCB8IHR5fFxuICogfCAwIHwgMCB8IDEgfFxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2E9MV0gLSB4IHNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiPTBdIC0geSBza2V3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjPTBdIC0geCBza2V3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkPTFdIC0geSBzY2FsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdHg9MF0gLSB4IHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0eT0wXSAtIHkgdHJhbnNsYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXRyaXgoKSB7XG4gICAgICAgIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgICB2YXIgYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciBkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxO1xuICAgICAgICB2YXIgdHggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICAgIHZhciB0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWF0cml4KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmEgPSBhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYiA9IGI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jID0gYztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmQgPSBkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHggPSB0eDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5ID0gdHk7XG5cbiAgICAgICAgdGhpcy5hcnJheSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYSA9IGFycmF5WzBdXG4gICAgICogYiA9IGFycmF5WzFdXG4gICAgICogYyA9IGFycmF5WzNdXG4gICAgICogZCA9IGFycmF5WzRdXG4gICAgICogdHggPSBhcnJheVsyXVxuICAgICAqIHR5ID0gYXJyYXlbNV1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIGFycmF5IHRoYXQgdGhlIG1hdHJpeCB3aWxsIGJlIHBvcHVsYXRlZCBmcm9tLlxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmZyb21BcnJheSA9IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICB0aGlzLmEgPSBhcnJheVswXTtcbiAgICAgICAgdGhpcy5iID0gYXJyYXlbMV07XG4gICAgICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgICAgICB0aGlzLmQgPSBhcnJheVs0XTtcbiAgICAgICAgdGhpcy50eCA9IGFycmF5WzJdO1xuICAgICAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIG1hdHJpeCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIE1hdHJpeCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYyAtIE1hdHJpeCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZCAtIE1hdHJpeCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHggLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gTWF0cml4IGNvbXBvbmVudFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgICAgICB0aGlzLmEgPSBhO1xuICAgICAgICB0aGlzLmIgPSBiO1xuICAgICAgICB0aGlzLmMgPSBjO1xuICAgICAgICB0aGlzLmQgPSBkO1xuICAgICAgICB0aGlzLnR4ID0gdHg7XG4gICAgICAgIHRoaXMudHkgPSB0eTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIHRoZSBjdXJyZW50IE1hdHJpeCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW291dD1uZXcgRmxvYXQzMkFycmF5KDkpXSAtIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGJlIGFzc2lnbmVkIHRvIG91dFxuICAgICAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheSB3aGljaCBjb250YWlucyB0aGUgbWF0cml4XG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodHJhbnNwb3NlLCBvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnJheSA9IG91dCB8fCB0aGlzLmFycmF5O1xuXG4gICAgICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgICAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmI7XG4gICAgICAgICAgICBhcnJheVsyXSA9IDA7XG4gICAgICAgICAgICBhcnJheVszXSA9IHRoaXMuYztcbiAgICAgICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgICAgICAgYXJyYXlbNV0gPSAwO1xuICAgICAgICAgICAgYXJyYXlbNl0gPSB0aGlzLnR4O1xuICAgICAgICAgICAgYXJyYXlbN10gPSB0aGlzLnR5O1xuICAgICAgICAgICAgYXJyYXlbOF0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgICAgICBhcnJheVsxXSA9IHRoaXMuYztcbiAgICAgICAgICAgIGFycmF5WzJdID0gdGhpcy50eDtcbiAgICAgICAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xuICAgICAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgICAgICBhcnJheVs1XSA9IHRoaXMudHk7XG4gICAgICAgICAgICBhcnJheVs2XSA9IDA7XG4gICAgICAgICAgICBhcnJheVs3XSA9IDA7XG4gICAgICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gZ28gZnJvbSBhIGNoaWxkJ3MgY29vcmRpbmF0ZSBzcGFjZSB0byB0aGUgd29ybGQgY29vcmRpbmF0ZSBzcGFjZS4gKGUuZy4gcmVuZGVyaW5nKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb3MgLSBUaGUgb3JpZ2luXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBbbmV3UG9zXSAtIFRoZSBwb2ludCB0aGF0IHRoZSBuZXcgcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gKGFsbG93ZWQgdG8gYmUgc2FtZSBhcyBpbnB1dClcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBUaGUgbmV3IHBvaW50LCB0cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseShwb3MsIG5ld1Bvcykge1xuICAgICAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IF9Qb2ludDIuZGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciB4ID0gcG9zLng7XG4gICAgICAgIHZhciB5ID0gcG9zLnk7XG5cbiAgICAgICAgbmV3UG9zLnggPSB0aGlzLmEgKiB4ICsgdGhpcy5jICogeSArIHRoaXMudHg7XG4gICAgICAgIG5ld1Bvcy55ID0gdGhpcy5iICogeCArIHRoaXMuZCAqIHkgKyB0aGlzLnR5O1xuXG4gICAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBpbnZlcnNlIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgd29ybGQgY29vcmRpbmF0ZSBzcGFjZSB0byBhIGNoaWxkJ3MgY29vcmRpbmF0ZSBzcGFjZS4gKGUuZy4gaW5wdXQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvcyAtIFRoZSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtuZXdQb3NdIC0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIGludmVyc2UtdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmFwcGx5SW52ZXJzZSA9IGZ1bmN0aW9uIGFwcGx5SW52ZXJzZShwb3MsIG5ld1Bvcykge1xuICAgICAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IF9Qb2ludDIuZGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBpZCA9IDEgLyAodGhpcy5hICogdGhpcy5kICsgdGhpcy5jICogLXRoaXMuYik7XG5cbiAgICAgICAgdmFyIHggPSBwb3MueDtcbiAgICAgICAgdmFyIHkgPSBwb3MueTtcblxuICAgICAgICBuZXdQb3MueCA9IHRoaXMuZCAqIGlkICogeCArIC10aGlzLmMgKiBpZCAqIHkgKyAodGhpcy50eSAqIHRoaXMuYyAtIHRoaXMudHggKiB0aGlzLmQpICogaWQ7XG4gICAgICAgIG5ld1Bvcy55ID0gdGhpcy5hICogaWQgKiB5ICsgLXRoaXMuYiAqIGlkICogeCArICgtdGhpcy50eSAqIHRoaXMuYSArIHRoaXMudHggKiB0aGlzLmIpICogaWQ7XG5cbiAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMudHggKz0geDtcbiAgICAgICAgdGhpcy50eSArPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBhbW91bnQgdG8gc2NhbGUgaG9yaXpvbnRhbGx5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzY2FsZSB2ZXJ0aWNhbGx5XG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh4LCB5KSB7XG4gICAgICAgIHRoaXMuYSAqPSB4O1xuICAgICAgICB0aGlzLmQgKj0geTtcbiAgICAgICAgdGhpcy5jICo9IHg7XG4gICAgICAgIHRoaXMuYiAqPSB5O1xuICAgICAgICB0aGlzLnR4ICo9IHg7XG4gICAgICAgIHRoaXMudHkgKj0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICAgICAgdmFyIHR4MSA9IHRoaXMudHg7XG5cbiAgICAgICAgdGhpcy5hID0gYTEgKiBjb3MgLSB0aGlzLmIgKiBzaW47XG4gICAgICAgIHRoaXMuYiA9IGExICogc2luICsgdGhpcy5iICogY29zO1xuICAgICAgICB0aGlzLmMgPSBjMSAqIGNvcyAtIHRoaXMuZCAqIHNpbjtcbiAgICAgICAgdGhpcy5kID0gYzEgKiBzaW4gKyB0aGlzLmQgKiBjb3M7XG4gICAgICAgIHRoaXMudHggPSB0eDEgKiBjb3MgLSB0aGlzLnR5ICogc2luO1xuICAgICAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG1hdHJpeCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLmQ7XG5cbiAgICAgICAgdGhpcy5hID0gbWF0cml4LmEgKiBhMSArIG1hdHJpeC5iICogYzE7XG4gICAgICAgIHRoaXMuYiA9IG1hdHJpeC5hICogYjEgKyBtYXRyaXguYiAqIGQxO1xuICAgICAgICB0aGlzLmMgPSBtYXRyaXguYyAqIGExICsgbWF0cml4LmQgKiBjMTtcbiAgICAgICAgdGhpcy5kID0gbWF0cml4LmMgKiBiMSArIG1hdHJpeC5kICogZDE7XG5cbiAgICAgICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgICAgICB0aGlzLnR5ID0gbWF0cml4LnR4ICogYjEgKyBtYXRyaXgudHkgKiBkMSArIHRoaXMudHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hdHJpeCBiYXNlZCBvbiBhbGwgdGhlIGF2YWlsYWJsZSBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFBvc2l0aW9uIG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFBvc2l0aW9uIG9uIHRoZSB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl2b3RYIC0gUGl2b3Qgb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXZvdFkgLSBQaXZvdCBvbiB0aGUgeSBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCAtIFNjYWxlIG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZIC0gU2NhbGUgb24gdGhlIHkgYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiAtIFJvdGF0aW9uIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2tld1ggLSBTa2V3IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2tld1kgLSBTa2V3IG9uIHRoZSB5IGF4aXNcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZKSB7XG4gICAgICAgIHZhciBzciA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICAgICAgdmFyIGNyID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgICAgICB2YXIgY3kgPSBNYXRoLmNvcyhza2V3WSk7XG4gICAgICAgIHZhciBzeSA9IE1hdGguc2luKHNrZXdZKTtcbiAgICAgICAgdmFyIG5zeCA9IC1NYXRoLnNpbihza2V3WCk7XG4gICAgICAgIHZhciBjeCA9IE1hdGguY29zKHNrZXdYKTtcblxuICAgICAgICB2YXIgYSA9IGNyICogc2NhbGVYO1xuICAgICAgICB2YXIgYiA9IHNyICogc2NhbGVYO1xuICAgICAgICB2YXIgYyA9IC1zciAqIHNjYWxlWTtcbiAgICAgICAgdmFyIGQgPSBjciAqIHNjYWxlWTtcblxuICAgICAgICB0aGlzLmEgPSBjeSAqIGEgKyBzeSAqIGM7XG4gICAgICAgIHRoaXMuYiA9IGN5ICogYiArIHN5ICogZDtcbiAgICAgICAgdGhpcy5jID0gbnN4ICogYSArIGN4ICogYztcbiAgICAgICAgdGhpcy5kID0gbnN4ICogYiArIGN4ICogZDtcblxuICAgICAgICB0aGlzLnR4ID0geCArIChwaXZvdFggKiBhICsgcGl2b3RZICogYyk7XG4gICAgICAgIHRoaXMudHkgPSB5ICsgKHBpdm90WCAqIGIgKyBwaXZvdFkgKiBkKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gcHJlcGVuZFxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKG1hdHJpeCkge1xuICAgICAgICB2YXIgdHgxID0gdGhpcy50eDtcblxuICAgICAgICBpZiAobWF0cml4LmEgIT09IDEgfHwgbWF0cml4LmIgIT09IDAgfHwgbWF0cml4LmMgIT09IDAgfHwgbWF0cml4LmQgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBhMSA9IHRoaXMuYTtcbiAgICAgICAgICAgIHZhciBjMSA9IHRoaXMuYztcblxuICAgICAgICAgICAgdGhpcy5hID0gYTEgKiBtYXRyaXguYSArIHRoaXMuYiAqIG1hdHJpeC5jO1xuICAgICAgICAgICAgdGhpcy5iID0gYTEgKiBtYXRyaXguYiArIHRoaXMuYiAqIG1hdHJpeC5kO1xuICAgICAgICAgICAgdGhpcy5jID0gYzEgKiBtYXRyaXguYSArIHRoaXMuZCAqIG1hdHJpeC5jO1xuICAgICAgICAgICAgdGhpcy5kID0gYzEgKiBtYXRyaXguYiArIHRoaXMuZCAqIG1hdHJpeC5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50eCA9IHR4MSAqIG1hdHJpeC5hICsgdGhpcy50eSAqIG1hdHJpeC5jICsgbWF0cml4LnR4O1xuICAgICAgICB0aGlzLnR5ID0gdHgxICogbWF0cml4LmIgKyB0aGlzLnR5ICogbWF0cml4LmQgKyBtYXRyaXgudHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgdGhlIG1hdHJpeCAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGFuZCByb3RhdGlvbikgYW5kIHNldHMgdGhlIHByb3BlcnRpZXMgb24gdG8gYSB0cmFuc2Zvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfFBJWEkuVHJhbnNmb3JtU3RhdGljfSB0cmFuc2Zvcm0gLSBUaGUgdHJhbnNmb3JtIHRvIGFwcGx5IHRoZSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVHJhbnNmb3JtfFBJWEkuVHJhbnNmb3JtU3RhdGljfSBUaGUgdHJhbnNmb3JtIHdpdGggdGhlIG5ld2x5IGFwcGxpZWQgcHJvcGVydGllc1xuICAgICAqL1xuXG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmRlY29tcG9zZSA9IGZ1bmN0aW9uIGRlY29tcG9zZSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgLy8gc29ydCBvdXQgcm90YXRpb24gLyBza2V3Li5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiID0gdGhpcy5iO1xuICAgICAgICB2YXIgYyA9IHRoaXMuYztcbiAgICAgICAgdmFyIGQgPSB0aGlzLmQ7XG5cbiAgICAgICAgdmFyIHNrZXdYID0gLU1hdGguYXRhbjIoLWMsIGQpO1xuICAgICAgICB2YXIgc2tld1kgPSBNYXRoLmF0YW4yKGIsIGEpO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGguYWJzKHNrZXdYICsgc2tld1kpO1xuXG4gICAgICAgIGlmIChkZWx0YSA8IDAuMDAwMDEpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiA9IHNrZXdZO1xuXG4gICAgICAgICAgICBpZiAoYSA8IDAgJiYgZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uICs9IHRyYW5zZm9ybS5yb3RhdGlvbiA8PSAwID8gTWF0aC5QSSA6IC1NYXRoLlBJO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy54ID0gdHJhbnNmb3JtLnNrZXcueSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy54ID0gc2tld1g7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy55ID0gc2tld1k7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IHNldCBzY2FsZVxuICAgICAgICB0cmFuc2Zvcm0uc2NhbGUueCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgICAgdHJhbnNmb3JtLnNjYWxlLnkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG5cbiAgICAgICAgLy8gbmV4dCBzZXQgcG9zaXRpb25cbiAgICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLnggPSB0aGlzLnR4O1xuICAgICAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueSA9IHRoaXMudHk7XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52ZXJ0cyB0aGlzIG1hdHJpeFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLmQ7XG4gICAgICAgIHZhciB0eDEgPSB0aGlzLnR4O1xuICAgICAgICB2YXIgbiA9IGExICogZDEgLSBiMSAqIGMxO1xuXG4gICAgICAgIHRoaXMuYSA9IGQxIC8gbjtcbiAgICAgICAgdGhpcy5iID0gLWIxIC8gbjtcbiAgICAgICAgdGhpcy5jID0gLWMxIC8gbjtcbiAgICAgICAgdGhpcy5kID0gYTEgLyBuO1xuICAgICAgICB0aGlzLnR4ID0gKGMxICogdGhpcy50eSAtIGQxICogdHgxKSAvIG47XG4gICAgICAgIHRoaXMudHkgPSAtKGExICogdGhpcy50eSAtIGIxICogdHgxKSAvIG47XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGlzIE1hdGl4IHRvIGFuIGlkZW50aXR5IChkZWZhdWx0KSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KCkge1xuICAgICAgICB0aGlzLmEgPSAxO1xuICAgICAgICB0aGlzLmIgPSAwO1xuICAgICAgICB0aGlzLmMgPSAwO1xuICAgICAgICB0aGlzLmQgPSAxO1xuICAgICAgICB0aGlzLnR4ID0gMDtcbiAgICAgICAgdGhpcy50eSA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWF0cml4IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBBIGNvcHkgb2YgdGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cblxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXG4gICAgICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgICAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICAgICAgbWF0cml4LmMgPSB0aGlzLmM7XG4gICAgICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgICAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgICAgICBtYXRyaXgudHkgPSB0aGlzLnR5O1xuXG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBvbmVzIGluIHRoaXMgbWF0cml4XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGNvcHkgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hdHJpeCBnaXZlbiBpbiBwYXJhbWV0ZXIgd2l0aCBpdHMgdmFsdWVzIHVwZGF0ZWQuXG4gICAgICovXG5cblxuICAgIE1hdHJpeC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkobWF0cml4KSB7XG4gICAgICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgICAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICAgICAgbWF0cml4LmMgPSB0aGlzLmM7XG4gICAgICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgICAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgICAgICBtYXRyaXgudHkgPSB0aGlzLnR5O1xuXG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCAoaWRlbnRpdHkpIG1hdHJpeFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTWF0cml4LCBudWxsLCBbe1xuICAgICAgICBrZXk6ICdJREVOVElUWScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRlbXAgbWF0cml4XG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdURU1QX01BVFJJWCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNYXRyaXg7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hdHJpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdHJpeC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL01hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIF9zZXR0aW5ncyA9IHJlcXVpcmUoJy4uL3NldHRpbmdzJyk7XG5cbnZhciBfc2V0dGluZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0dGluZ3MpO1xuXG52YXIgX0NvbnRhaW5lciA9IHJlcXVpcmUoJy4uL2Rpc3BsYXkvQ29udGFpbmVyJyk7XG5cbnZhciBfQ29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnRhaW5lcik7XG5cbnZhciBfUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1JlbmRlclRleHR1cmUnKTtcblxudmFyIF9SZW5kZXJUZXh0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbmRlclRleHR1cmUpO1xuXG52YXIgX2V2ZW50ZW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgdGVtcE1hdHJpeCA9IG5ldyBfbWF0aC5NYXRyaXgoKTtcblxuLyoqXG4gKiBUaGUgU3lzdGVtUmVuZGVyZXIgaXMgdGhlIGJhc2UgZm9yIGEgUGl4aSBSZW5kZXJlci4gSXQgaXMgZXh0ZW5kZWQgYnkgdGhlIHtAbGluayBQSVhJLkNhbnZhc1JlbmRlcmVyfVxuICogYW5kIHtAbGluayBQSVhJLldlYkdMUmVuZGVyZXJ9IHdoaWNoIGNhbiBiZSB1c2VkIGZvciByZW5kZXJpbmcgYSBQaXhpIHNjZW5lLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cblxudmFyIFN5c3RlbVJlbmRlcmVyID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFN5c3RlbVJlbmRlcmVyLCBfRXZlbnRFbWl0dGVyKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5c3RlbSAtIFRoZSBuYW1lIG9mIHRoZSBzeXN0ZW0gdGhpcyByZW5kZXJlciBpcyBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NyZWVuV2lkdGg9ODAwXSAtIHRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NyZWVuSGVpZ2h0PTYwMF0gLSB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JlZW5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtvcHRpb25zLnZpZXddIC0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYW5zcGFyZW50PWZhbHNlXSAtIElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdIC0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0gLSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci4gVGhlXG4gICAqICByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcj10cnVlXSAtIFRoaXMgc2V0cyBpZiB0aGUgQ2FudmFzUmVuZGVyZXIgd2lsbCBjbGVhciB0aGUgY2FudmFzIG9yXG4gICAqICAgICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXSAtIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSByZW5kZXJlZCBhcmVhXG4gICAqICAoc2hvd24gaWYgbm90IHRyYW5zcGFyZW50KS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0gLSBJZiB0cnVlIFBpeGkgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZyxcbiAgICogIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBTeXN0ZW1SZW5kZXJlcihzeXN0ZW0sIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3lzdGVtUmVuZGVyZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgICgwLCBfdXRpbHMuc2F5SGVsbG8pKHN5c3RlbSk7XG5cbiAgICAvLyBwcmVwYXJlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSBpbiBfc2V0dGluZ3MyLmRlZmF1bHQuUkVOREVSX09QVElPTlMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9wdGlvbnNbaV0gPSBfc2V0dGluZ3MyLmRlZmF1bHQuUkVOREVSX09QVElPTlNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IF9zZXR0aW5nczIuZGVmYXVsdC5SRU5ERVJfT1BUSU9OUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS5SRU5ERVJFUl9UWVBFLlVOS05PV05cbiAgICAgKiBAc2VlIFBJWEkuUkVOREVSRVJfVFlQRVxuICAgICAqL1xuICAgIF90aGlzLnR5cGUgPSBfY29uc3QuUkVOREVSRVJfVFlQRS5VTktOT1dOO1xuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZW1lbnRzIG9mIHRoZSBzY3JlZW4uICgwLCAwLCBzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KVxuICAgICAqXG4gICAgICogSXRzIHNhZmUgdG8gdXNlIGFzIGZpbHRlckFyZWEgb3IgaGl0QXJlYSBmb3Igd2hvbGUgc3RhZ2VcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIF90aGlzLnNjcmVlbiA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoMCwgMCwgc2NyZWVuV2lkdGggfHwgODAwLCBzY3JlZW5IZWlnaHQgfHwgNjAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIF90aGlzLnZpZXcgPSBvcHRpb25zLnZpZXcgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgX3RoaXMucmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbiB8fCBfc2V0dGluZ3MyLmRlZmF1bHQuUkVTT0xVVElPTjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLnRyYW5zcGFyZW50ID0gb3B0aW9ucy50cmFuc3BhcmVudDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY3NzIGRpbWVuc2lvbnMgb2YgY2FudmFzIHZpZXcgc2hvdWxkIGJlIHJlc2l6ZWQgdG8gc2NyZWVuIGRpbWVuc2lvbnMgYXV0b21hdGljYWxseVxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfdGhpcy5hdXRvUmVzaXplID0gb3B0aW9ucy5hdXRvUmVzaXplIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2tzIHRoZSBibGVuZCBtb2RlcyB1c2VmdWwgZm9yIHRoaXMgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8c3RyaW5nLCBtaXhlZD59XG4gICAgICovXG4gICAgX3RoaXMuYmxlbmRNb2RlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHByZXNlcnZlRHJhd2luZ0J1ZmZlciBmbGFnIGFmZmVjdHMgd2hldGhlciBvciBub3QgdGhlIGNvbnRlbnRzIG9mXG4gICAgICogdGhlIHN0ZW5jaWwgYnVmZmVyIGlzIHJldGFpbmVkIGFmdGVyIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgX3RoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNldHMgaWYgdGhlIENhbnZhc1JlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvciBub3QgYmVmb3JlIHRoZSBuZXcgcmVuZGVyIHBhc3MuXG4gICAgICogSWYgdGhlIHNjZW5lIGlzIE5PVCB0cmFuc3BhcmVudCBQaXhpIHdpbGwgdXNlIGEgY2FudmFzIHNpemVkIGZpbGxSZWN0IG9wZXJhdGlvbiBldmVyeVxuICAgICAqIGZyYW1lIHRvIHNldCB0aGUgY2FudmFzIGJhY2tncm91bmQgY29sb3IuIElmIHRoZSBzY2VuZSBpcyB0cmFuc3BhcmVudCBQaXhpIHdpbGwgdXNlIGNsZWFyUmVjdFxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgZXZlcnkgZnJhbWUuIERpc2FibGUgdGhpcyBieSBzZXR0aW5nIHRoaXMgdG8gZmFsc2UuIEZvciBleGFtcGxlIGlmXG4gICAgICogeW91ciBnYW1lIGhhcyBhIGNhbnZhcyBmaWxsaW5nIGJhY2tncm91bmQgaW1hZ2UgeW91IG9mdGVuIGRvbid0IG5lZWQgdGhpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX3RoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSBQaXhpIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAgICogSGFuZHkgZm9yIGNyaXNwIHBpeGVsIGFydCBhbmQgc3BlZWQgb24gbGVnYWN5IGRldmljZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLnJvdW5kUGl4ZWxzID0gb3B0aW9ucy5yb3VuZFBpeGVscztcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2JhY2tncm91bmRDb2xvciA9IDB4MDAwMDAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSA9IFswLCAwLCAwLCAwXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9ICcjMDAwMDAwJztcblxuICAgIF90aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yIHx8IF90aGlzLl9iYWNrZ3JvdW5kQ29sb3I7IC8vIHJ1biBiZyBjb2xvciBzZXR0ZXJcblxuICAgIC8qKlxuICAgICAqIFRoaXMgdGVtcG9yYXJ5IGRpc3BsYXkgb2JqZWN0IHVzZWQgYXMgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkIGl0ZW1cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG5ldyBfQ29udGFpbmVyMi5kZWZhdWx0KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCByb290IG9iamVjdCB0aGF0IHRoZSByZW5kZXJlciB0cmllZCB0byByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gX3RoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHZpZXcud2lkdGgsIGFjdHVhbCBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBjYW52YXMgYnkgaG9yaXpvbnRhbFxuICAgKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVmYXVsdCA4MDBcbiAgICovXG5cblxuICAvKipcbiAgICogUmVzaXplcyB0aGUgc2NyZWVuIGFuZCBjYW52YXMgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAqIENhbnZhcyBkaW1lbnNpb25zIGFyZSBtdWx0aXBsaWVkIGJ5IHJlc29sdXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcmVlbldpZHRoIC0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgc2NyZWVuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JlZW5IZWlnaHQgLSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgc2NyZWVuXG4gICAqL1xuICBTeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gcmVzaXplKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcbiAgICB0aGlzLnNjcmVlbi53aWR0aCA9IHNjcmVlbldpZHRoO1xuICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IHNjcmVlbkhlaWdodDtcblxuICAgIHRoaXMudmlldy53aWR0aCA9IHNjcmVlbldpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMudmlldy5oZWlnaHQgPSBzY3JlZW5IZWlnaHQgKiB0aGlzLnJlc29sdXRpb247XG5cbiAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSBzY3JlZW5XaWR0aCArICdweCc7XG4gICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcbiAgICogVGhpcyBjYW4gYmUgcXVpdGUgdXNlZnVsIGlmIHlvdXIgZGlzcGxheU9iamVjdCBpcyBjb21wbGljYXRlZCBhbmQgbmVlZHMgdG8gYmUgcmV1c2VkIG11bHRpcGxlIHRpbWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIFRoZSBkaXNwbGF5T2JqZWN0IHRoZSBvYmplY3Qgd2lsbCBiZSBnZW5lcmF0ZWQgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVNb2RlIC0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgc2NhbGVNb2RlIGNvbnN0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZFxuICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IGEgdGV4dHVyZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0XG4gICAqL1xuXG5cbiAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIGdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pIHtcbiAgICB2YXIgYm91bmRzID0gZGlzcGxheU9iamVjdC5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBfUmVuZGVyVGV4dHVyZTIuZGVmYXVsdC5jcmVhdGUoYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDAsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbik7XG5cbiAgICB0ZW1wTWF0cml4LnR4ID0gLWJvdW5kcy54O1xuICAgIHRlbXBNYXRyaXgudHkgPSAtYm91bmRzLnk7XG5cbiAgICB0aGlzLnJlbmRlcihkaXNwbGF5T2JqZWN0LCByZW5kZXJUZXh0dXJlLCBmYWxzZSwgdGVtcE1hdHJpeCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gcmVuZGVyVGV4dHVyZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gLSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqL1xuXG5cbiAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KHJlbW92ZVZpZXcpIHtcbiAgICBpZiAocmVtb3ZlVmlldyAmJiB0aGlzLnZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy52aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy52aWV3KTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBfY29uc3QuUkVOREVSRVJfVFlQRS5VTktOT1dOO1xuXG4gICAgdGhpcy52aWV3ID0gbnVsbDtcblxuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcblxuICAgIHRoaXMucmVzb2x1dGlvbiA9IDA7XG5cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1dG9SZXNpemUgPSBmYWxzZTtcblxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IG51bGw7XG5cbiAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBmYWxzZTtcblxuICAgIHRoaXMucm91bmRQaXhlbHMgPSBmYWxzZTtcblxuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDA7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSA9IG51bGw7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gbnVsbDtcblxuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gMDtcbiAgICB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCBpZiBub3QgdHJhbnNwYXJlbnRcbiAgICpcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTeXN0ZW1SZW5kZXJlciwgW3tcbiAgICBrZXk6ICd3aWR0aCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgdmlldy5oZWlnaHQsIGFjdHVhbCBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBjYW52YXMgYnkgdmVydGljYWxcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGVpZ2h0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuaGVpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIHtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gKDAsIF91dGlscy5oZXgyc3RyaW5nKSh2YWx1ZSk7XG4gICAgICAoMCwgX3V0aWxzLmhleDJyZ2IpKHZhbHVlLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3lzdGVtUmVuZGVyZXI7XG59KF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTeXN0ZW1SZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5c3RlbVJlbmRlcmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy9TeXN0ZW1SZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vLi4vLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50IG9mIHRoZSBnaXZlbiBzaXplLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENhbnZhc1JlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgY2FudmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzUmVuZGVyVGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBDYW52YXMgb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIENhbnZhc1JlbmRlclRhcmdldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IF9zZXR0aW5nczIuZGVmYXVsdC5SRVNPTFVUSU9OO1xuXG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBjYW52YXMgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGNsYXNzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhbnZhc1JlbmRlclRhcmdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgKi9cblxuXG4gIENhbnZhc1JlbmRlclRhcmdldC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBjYW52YXMuXG4gICAqXG4gICAqL1xuXG5cbiAgQ2FudmFzUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICpcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDYW52YXNSZW5kZXJUYXJnZXQsIFt7XG4gICAga2V5OiAnd2lkdGgnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICB7XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGVpZ2h0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIHtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZhbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FudmFzUmVuZGVyVGFyZ2V0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNSZW5kZXJUYXJnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZW5kZXJUYXJnZXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNSZW5kZXJUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXM7XG4vKipcbiAqIENyZWF0ZXMgYSBsaXR0bGUgY29sb3JlZCBjYW52YXNcbiAqXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBUaGUgY29sb3IgdG8gbWFrZSB0aGUgY2FudmFzXG4gKiBAcmV0dXJuIHtjYW52YXN9IGEgc21hbGwgY2FudmFzIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29sb3JlZENhbnZhcyhjb2xvcikge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGNhbnZhcy53aWR0aCA9IDY7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG5cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDYsIDEpO1xuXG4gICAgcmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgQ2FudmFzIEJsZW5kTW9kZXMgYXJlIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBicm93c2VyXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGV5IGFyZSBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlcygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG1hZ2VudGEgPSBjcmVhdGVDb2xvcmVkQ2FudmFzKCcjZmYwMGZmJyk7XG4gICAgdmFyIHllbGxvdyA9IGNyZWF0ZUNvbG9yZWRDYW52YXMoJyNmZmZmMDAnKTtcblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGNhbnZhcy53aWR0aCA9IDY7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG5cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKG1hZ2VudGEsIDAsIDApO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHllbGxvdywgMiwgMCk7XG5cbiAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMiwgMCwgMSwgMSk7XG5cbiAgICBpZiAoIWltYWdlRGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgIHJldHVybiBkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMCAmJiBkYXRhWzJdID09PSAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuVXNlTmV3Q2FudmFzQmxlbmRNb2Rlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9leHRyYWN0VW5pZm9ybXNGcm9tU3JjID0gcmVxdWlyZSgnLi9leHRyYWN0VW5pZm9ybXNGcm9tU3JjJyk7XG5cbnZhciBfZXh0cmFjdFVuaWZvcm1zRnJvbVNyYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRyYWN0VW5pZm9ybXNGcm9tU3JjKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vLi4vLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTT1VSQ0VfS0VZX01BUCA9IHt9O1xuXG4vLyBsZXQgbWF0aCA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgnKTtcbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5TaGFkZXJcbiAqL1xuXG52YXIgRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2ZXJ0ZXhTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcmFnbWVudFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbdW5pZm9ybXNdIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLlxuICAgKi9cbiAgZnVuY3Rpb24gRmlsdGVyKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGV4IHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBGaWx0ZXIuZGVmYXVsdFZlcnRleFNyYztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IEZpbHRlci5kZWZhdWx0RnJhZ21lbnRTcmM7XG5cbiAgICB0aGlzLmJsZW5kTW9kZSA9IF9jb25zdC5CTEVORF9NT0RFUy5OT1JNQUw7XG5cbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gdW5pZm9ybXMgfHwgKDAsIF9leHRyYWN0VW5pZm9ybXNGcm9tU3JjMi5kZWZhdWx0KSh0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYywgJ3Byb2plY3Rpb25NYXRyaXh8dVNhbXBsZXInKTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjdXJyZW50IHZhbHVlcyBvZiBjdXN0b20gdW5pZm9ybXMuXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+VXBkYXRpbmcgdGhlIHZhbHVlIG9mIGEgY3VzdG9tIHVuaWZvcm08L2NhcHRpb24+XG4gICAgICogZmlsdGVyLnVuaWZvcm1zLnRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnVuaWZvcm1zID0ge307XG5cbiAgICBmb3IgKHZhciBpIGluIHRoaXMudW5pZm9ybURhdGEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXNbaV0gPSB0aGlzLnVuaWZvcm1EYXRhW2ldLnZhbHVlO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgd2hlcmUgd2Ugc3RvcmUgc2hhZGVyIHJlZmVyZW5jZXMuLlxuICAgIC8vIFRPRE8gd2UgY291bGQgY2FjaGUgdGhpcyFcbiAgICB0aGlzLmdsU2hhZGVycyA9IHt9O1xuXG4gICAgLy8gdXNlZCBmb3IgY2FjaGVpbmcuLiBzdXJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheSFcbiAgICBpZiAoIVNPVVJDRV9LRVlfTUFQW3RoaXMudmVydGV4U3JjICsgdGhpcy5mcmFnbWVudFNyY10pIHtcbiAgICAgIFNPVVJDRV9LRVlfTUFQW3RoaXMudmVydGV4U3JjICsgdGhpcy5mcmFnbWVudFNyY10gPSAoMCwgX3V0aWxzLnVpZCkoKTtcbiAgICB9XG5cbiAgICB0aGlzLmdsU2hhZGVyS2V5ID0gU09VUkNFX0tFWV9NQVBbdGhpcy52ZXJ0ZXhTcmMgKyB0aGlzLmZyYWdtZW50U3JjXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYWRkaW5nIG9mIHRoZSBmaWx0ZXIuIFNvbWUgZmlsdGVycyByZXF1aXJlIGV4dHJhIHNwYWNlIHRvIGJyZWF0aCBzdWNoIGFzIGEgYmx1ci5cbiAgICAgKiBJbmNyZWFzaW5nIHRoaXMgd2lsbCBhZGQgZXh0cmEgd2lkdGggYW5kIGhlaWdodCB0byB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QgdGhhdCB0aGVcbiAgICAgKiBmaWx0ZXIgaXMgYXBwbGllZCB0by5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmcgPSA0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIGZpbHRlci4gU2V0dGluZyB0aGlzIHRvIGJlIGxvd2VyIHdpbGwgbG93ZXIgdGhlIHF1YWxpdHkgYnV0XG4gICAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gX3NldHRpbmdzMi5kZWZhdWx0LlJFU09MVVRJT047XG5cbiAgICAvKipcbiAgICAgKiBJZiBlbmFibGVkIGlzIHRydWUgdGhlIGZpbHRlciBpcyBhcHBsaWVkLCBpZiBmYWxzZSBpdCB3aWxsIG5vdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLkZpbHRlck1hbmFnZXJ9IGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nIHRvIGl0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3VycmVudFN0YXRlXSAtIEl0J3MgY3VycmVudCBzdGF0ZSBvZiBmaWx0ZXIuXG4gICAqICAgICAgICBUaGVyZSBhcmUgc29tZSB1c2VmdWwgcHJvcGVydGllcyBpbiB0aGUgY3VycmVudFN0YXRlIDpcbiAgICogICAgICAgIHRhcmdldCwgZmlsdGVycywgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUsIHJlbmRlclRhcmdldCwgcmVzb2x1dGlvblxuICAgKi9cblxuXG4gIEZpbHRlci5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhciwgY3VycmVudFN0YXRlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHtcbiAgICAvLyAtLS0gLy9cbiAgICAvLyAgdGhpcy51bmlmb3Jtcy5maWx0ZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0ZW1wTWF0cml4LCB3aW5kb3cucGFuZGEgKTtcblxuICAgIC8vIGRvIGFzIHlvdSBwbGVhc2UhXG5cbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcblxuICAgIC8vIG9yIGp1c3QgZG8gYSByZWd1bGFyIHJlbmRlci4uXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQGNvbnN0YW50XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEZpbHRlciwgbnVsbCwgW3tcbiAgICBrZXk6ICdkZWZhdWx0VmVydGV4U3JjJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLCAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLCAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JywgJ3VuaWZvcm0gbWF0MyBmaWx0ZXJNYXRyaXg7JywgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsICd2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkOycsICd2b2lkIG1haW4odm9pZCl7JywgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsICcgICB2RmlsdGVyQ29vcmQgPSAoIGZpbHRlck1hdHJpeCAqIHZlYzMoIGFUZXh0dXJlQ29vcmQsIDEuMCkgICkueHk7JywgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkIDsnLCAnfSddLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVmYXVsdEZyYWdtZW50U3JjJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsICd2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkOycsICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLCAndW5pZm9ybSBzYW1wbGVyMkQgZmlsdGVyU2FtcGxlcjsnLCAndm9pZCBtYWluKHZvaWQpeycsICcgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKGZpbHRlclNhbXBsZXIsIHZGaWx0ZXJDb29yZCk7JywgJyAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLCAnICAgdmVjNCBjb2xvcjsnLCAnICAgaWYobW9kKHZGaWx0ZXJDb29yZC54LCAxLjApID4gMC41KScsICcgICB7JywgJyAgICAgY29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7JywgJyAgIH0nLCAnICAgZWxzZScsICcgICB7JywgJyAgICAgY29sb3IgPSB2ZWM0KDAuMCwgMS4wLCAwLjAsIDEuMCk7JywgJyAgIH0nLFxuICAgICAgLy8gJyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobW9kKHZGaWx0ZXJDb29yZC54LCAxLjUpLCB2RmlsdGVyQ29vcmQueSwwLjAsMS4wKTsnLFxuICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IG1peChzYW1wbGUsIG1hc2t5LCAwLjUpOycsICcgICBnbF9GcmFnQ29sb3IgKj0gc2FtcGxlLmE7JywgJ30nXS5qb2luKCdcXG4nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsdGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfRmlsdGVyMiA9IHJlcXVpcmUoJy4uL0ZpbHRlcicpO1xuXG52YXIgX0ZpbHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GaWx0ZXIyKTtcblxudmFyIF9tYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vbWF0aCcpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGUgU3ByaXRlTWFza0ZpbHRlciBjbGFzc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBTcHJpdGVNYXNrRmlsdGVyID0gZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgICBfaW5oZXJpdHMoU3ByaXRlTWFza0ZpbHRlciwgX0ZpbHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgdGFyZ2V0IHNwcml0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNwcml0ZU1hc2tGaWx0ZXIoc3ByaXRlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcHJpdGVNYXNrRmlsdGVyKTtcblxuICAgICAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBfbWF0aC5NYXRyaXgoKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRmlsdGVyLmNhbGwodGhpcywgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyBvdGhlck1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdk1hc2tDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcbn1cXG4nLCAndmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCBhbHBoYTtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXNrO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgLy8gY2hlY2sgY2xpcCEgdGhpcyB3aWxsIHN0b3AgdGhlIG1hc2sgYmxlZWRpbmcgb3V0IGZyb20gdGhlIGVkZ2VzXFxuICAgIHZlYzIgdGV4dCA9IGFicyggdk1hc2tDb29yZCAtIDAuNSApO1xcbiAgICB0ZXh0ID0gc3RlcCgwLjUsIHRleHQpO1xcblxcbiAgICBmbG9hdCBjbGlwID0gMS4wIC0gbWF4KHRleHQueSwgdGV4dC54KTtcXG4gICAgdmVjNCBvcmlnaW5hbCA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIHZlYzQgbWFza3kgPSB0ZXh0dXJlMkQobWFzaywgdk1hc2tDb29yZCk7XFxuXFxuICAgIG9yaWdpbmFsICo9IChtYXNreS5yICogbWFza3kuYSAqIGFscGhhICogY2xpcCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IG9yaWdpbmFsO1xcbn1cXG4nKSk7XG5cbiAgICAgICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgICAgICBfdGhpcy5tYXNrTWF0cml4ID0gbWFza01hdHJpeDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkZpbHRlck1hbmFnZXJ9IGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGFyZ2V0fSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cbiAgICAgKi9cblxuXG4gICAgU3ByaXRlTWFza0ZpbHRlci5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBtYXNrU3ByaXRlID0gdGhpcy5tYXNrU3ByaXRlO1xuXG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFzayA9IG1hc2tTcHJpdGUuX3RleHR1cmU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMub3RoZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0aGlzLm1hc2tNYXRyaXgsIG1hc2tTcHJpdGUpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmFscGhhID0gbWFza1Nwcml0ZS53b3JsZEFscGhhO1xuXG4gICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTcHJpdGVNYXNrRmlsdGVyO1xufShfRmlsdGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3ByaXRlTWFza0ZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZU1hc2tGaWx0ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcGl4aUdsQ29yZSA9IHJlcXVpcmUoJ3BpeGktZ2wtY29yZScpO1xuXG52YXIgX3BpeGlHbENvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGl4aUdsQ29yZSk7XG5cbnZhciBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvY3JlYXRlSW5kaWNlc0ZvclF1YWRzJyk7XG5cbnZhciBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUluZGljZXNGb3JRdWFkcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHF1YWRcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBRdWFkID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIGdsIGNvbnRleHQgZm9yIHRoaXMgcXVhZCB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIFRPRE86IERlc2NyaXB0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBRdWFkKGdsLCBzdGF0ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWFkKTtcblxuICAgIC8qXG4gICAgICogdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAxLCAtMSwgMSwgMSwgLTEsIDFdKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBVdnMgb2YgdGhlIHF1YWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKTtcblxuICAgIHRoaXMuaW50ZXJsZWF2ZWQgPSBuZXcgRmxvYXQzMkFycmF5KDggKiAyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB0aGlzLmludGVybGVhdmVkW2kgKiA0XSA9IHRoaXMudmVydGljZXNbaSAqIDJdO1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZFtpICogNCArIDFdID0gdGhpcy52ZXJ0aWNlc1tpICogMiArIDFdO1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZFtpICogNCArIDJdID0gdGhpcy51dnNbaSAqIDJdO1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZFtpICogNCArIDNdID0gdGhpcy51dnNbaSAqIDIgKyAxXTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9ICgwLCBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzMi5kZWZhdWx0KSgxKTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7Z2xDb3JlLkdMQnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlclxuICAgICAqL1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlVmVydGV4QnVmZmVyKGdsLCB0aGlzLmludGVybGVhdmVkLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge2dsQ29yZS5HTEJ1ZmZlcn0gVGhlIGluZGV4IGJ1ZmZlclxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBfcGl4aUdsQ29yZTIuZGVmYXVsdC5HTEJ1ZmZlci5jcmVhdGVJbmRleEJ1ZmZlcihnbCwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge2dsQ29yZS5WZXJ0ZXhBcnJheU9iamVjdH0gVGhlIGluZGV4IGJ1ZmZlclxuICAgICAqL1xuICAgIHRoaXMudmFvID0gbmV3IF9waXhpR2xDb3JlMi5kZWZhdWx0LlZlcnRleEFycmF5T2JqZWN0KGdsLCBzdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGlzZXMgdGhlIHZhb3MgYW5kIHVzZXMgdGhlIHNoYWRlci5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIC0gdGhlIHNoYWRlciB0byB1c2VcbiAgICovXG5cblxuICBRdWFkLnByb3RvdHlwZS5pbml0VmFvID0gZnVuY3Rpb24gaW5pdFZhbyhzaGFkZXIpIHtcbiAgICB0aGlzLnZhby5jbGVhcigpLmFkZEluZGV4KHRoaXMuaW5kZXhCdWZmZXIpLmFkZEF0dHJpYnV0ZSh0aGlzLnZlcnRleEJ1ZmZlciwgc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgNCAqIDQsIDApLmFkZEF0dHJpYnV0ZSh0aGlzLnZlcnRleEJ1ZmZlciwgc2hhZGVyLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZCwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDQgKiA0LCAyICogNCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcHMgdHdvIFJlY3RhbmdsZSB0byB0aGUgcXVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gdGFyZ2V0VGV4dHVyZUZyYW1lIC0gdGhlIGZpcnN0IHJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lIC0gdGhlIHNlY29uZCByZWN0YW5nbGVcbiAgICogQHJldHVybiB7UElYSS5RdWFkfSBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG5cblxuICBRdWFkLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAodGFyZ2V0VGV4dHVyZUZyYW1lLCBkZXN0aW5hdGlvbkZyYW1lKSB7XG4gICAgdmFyIHggPSAwOyAvLyBkZXN0aW5hdGlvbkZyYW1lLnggLyB0YXJnZXRUZXh0dXJlRnJhbWUud2lkdGg7XG4gICAgdmFyIHkgPSAwOyAvLyBkZXN0aW5hdGlvbkZyYW1lLnkgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0O1xuXG4gICAgdGhpcy51dnNbMF0gPSB4O1xuICAgIHRoaXMudXZzWzFdID0geTtcblxuICAgIHRoaXMudXZzWzJdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggLyB0YXJnZXRUZXh0dXJlRnJhbWUud2lkdGg7XG4gICAgdGhpcy51dnNbM10gPSB5O1xuXG4gICAgdGhpcy51dnNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICB0aGlzLnV2c1s1XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQ7XG5cbiAgICB0aGlzLnV2c1s2XSA9IHg7XG4gICAgdGhpcy51dnNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0O1xuXG4gICAgeCA9IGRlc3RpbmF0aW9uRnJhbWUueDtcbiAgICB5ID0gZGVzdGluYXRpb25GcmFtZS55O1xuXG4gICAgdGhpcy52ZXJ0aWNlc1swXSA9IHg7XG4gICAgdGhpcy52ZXJ0aWNlc1sxXSA9IHk7XG5cbiAgICB0aGlzLnZlcnRpY2VzWzJdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgdGhpcy52ZXJ0aWNlc1szXSA9IHk7XG5cbiAgICB0aGlzLnZlcnRpY2VzWzRdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgdGhpcy52ZXJ0aWNlc1s1XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcblxuICAgIHRoaXMudmVydGljZXNbNl0gPSB4O1xuICAgIHRoaXMudmVydGljZXNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQmluZHMgdGhlIGJ1ZmZlciBhbmQgdXBsb2FkcyB0aGUgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJuIHtQSVhJLlF1YWR9IFJldHVybnMgaXRzZWxmLlxuICAgKi9cblxuXG4gIFF1YWQucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZFtpICogNF0gPSB0aGlzLnZlcnRpY2VzW2kgKiAyXTtcbiAgICAgIHRoaXMuaW50ZXJsZWF2ZWRbaSAqIDQgKyAxXSA9IHRoaXMudmVydGljZXNbaSAqIDIgKyAxXTtcbiAgICAgIHRoaXMuaW50ZXJsZWF2ZWRbaSAqIDQgKyAyXSA9IHRoaXMudXZzW2kgKiAyXTtcbiAgICAgIHRoaXMuaW50ZXJsZWF2ZWRbaSAqIDQgKyAzXSA9IHRoaXMudXZzW2kgKiAyICsgMV07XG4gICAgfVxuXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIudXBsb2FkKHRoaXMuaW50ZXJsZWF2ZWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhpcyBxdWFkIGZyb20gV2ViR0xcbiAgICovXG5cblxuICBRdWFkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlcik7XG4gIH07XG5cbiAgcmV0dXJuIFF1YWQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFF1YWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9RdWFkLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG52YXIgX2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMnKTtcblxudmFyIF9jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kcyBmb3IgU3ByaXRlL1RleHR1cmUgdGludGluZy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBDYW52YXNUaW50ZXIgPSB7XG4gICAgLyoqXG4gICAgICogQmFzaWNhbGx5IHRoaXMgbWV0aG9kIGp1c3QgbmVlZHMgYSBzcHJpdGUgYW5kIGEgY29sb3IgYW5kIHRpbnRzIHRoZSBzcHJpdGUgd2l0aCB0aGUgZ2l2ZW4gY29sb3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNUaW50ZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgc3ByaXRlIHRvIHRpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sb3IgLSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSB0aW50ZWQgY2FudmFzXG4gICAgICovXG4gICAgZ2V0VGludGVkVGV4dHVyZTogZnVuY3Rpb24gZ2V0VGludGVkVGV4dHVyZShzcHJpdGUsIGNvbG9yKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLnRleHR1cmU7XG5cbiAgICAgICAgY29sb3IgPSBDYW52YXNUaW50ZXIucm91bmRDb2xvcihjb2xvcik7XG5cbiAgICAgICAgdmFyIHN0cmluZ0NvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoY29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG5cbiAgICAgICAgdGV4dHVyZS50aW50Q2FjaGUgPSB0ZXh0dXJlLnRpbnRDYWNoZSB8fCB7fTtcblxuICAgICAgICBpZiAodGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xvbmUgdGV4dHVyZS4uXG4gICAgICAgIHZhciBjYW52YXMgPSBDYW52YXNUaW50ZXIuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICAgIC8vIENhbnZhc1RpbnRlci50aW50V2l0aFBlclBpeGVsKHRleHR1cmUsIHN0cmluZ0NvbG9yLCBjYW52YXMpO1xuICAgICAgICBDYW52YXNUaW50ZXIudGludE1ldGhvZCh0ZXh0dXJlLCBjb2xvciwgY2FudmFzKTtcblxuICAgICAgICBpZiAoQ2FudmFzVGludGVyLmNvbnZlcnRUaW50VG9JbWFnZSkge1xuICAgICAgICAgICAgLy8gaXMgdGhpcyBiZXR0ZXI/XG4gICAgICAgICAgICB2YXIgdGludEltYWdlID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgICAgIHRpbnRJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XG5cbiAgICAgICAgICAgIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSA9IHRpbnRJbWFnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSA9IGNhbnZhcztcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3QgY29udmVydGluZyB0aGUgdGV4dHVyZSB0byBhbiBpbWFnZSB0aGVuIHdlIG5lZWQgdG8gbG9zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXNcbiAgICAgICAgICAgIENhbnZhc1RpbnRlci5jYW52YXMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGludCBhIHRleHR1cmUgdXNpbmcgdGhlICdtdWx0aXBseScgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ2FudmFzVGludGVyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byB0aW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIC0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjdXJyZW50IGNhbnZhc1xuICAgICAqL1xuICAgIHRpbnRXaXRoTXVsdGlwbHk6IGZ1bmN0aW9uIHRpbnRXaXRoTXVsdGlwbHkodGV4dHVyZSwgY29sb3IsIGNhbnZhcykge1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgY3JvcCA9IHRleHR1cmUuX2ZyYW1lLmNsb25lKCk7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuXG4gICAgICAgIGNyb3AueCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLnkgKj0gcmVzb2x1dGlvbjtcbiAgICAgICAgY3JvcC53aWR0aCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLmhlaWdodCAqPSByZXNvbHV0aW9uO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbChjcm9wLndpZHRoKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChjcm9wLmhlaWdodCk7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArIChjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcblxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG5cbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsIGNyb3AueCwgY3JvcC55LCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCwgMCwgMCwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWF0b3AnO1xuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCBjcm9wLngsIGNyb3AueSwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQsIDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGludCBhIHRleHR1cmUgdXNpbmcgdGhlICdvdmVybGF5JyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNUaW50ZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sb3IgLSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGN1cnJlbnQgY2FudmFzXG4gICAgICovXG4gICAgdGludFdpdGhPdmVybGF5OiBmdW5jdGlvbiB0aW50V2l0aE92ZXJsYXkodGV4dHVyZSwgY29sb3IsIGNhbnZhcykge1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgY3JvcCA9IHRleHR1cmUuX2ZyYW1lLmNsb25lKCk7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuXG4gICAgICAgIGNyb3AueCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLnkgKj0gcmVzb2x1dGlvbjtcbiAgICAgICAgY3JvcC53aWR0aCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLmhlaWdodCAqPSByZXNvbHV0aW9uO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbChjcm9wLndpZHRoKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChjcm9wLmhlaWdodCk7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoY29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWF0b3AnO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSwgY3JvcC54LCBjcm9wLnksIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0LCAwLCAwLCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCk7XG5cbiAgICAgICAgLy8gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGludCBhIHRleHR1cmUgcGl4ZWwgcGVyIHBpeGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ2FudmFzVGludGVyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byB0aW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIC0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjdXJyZW50IGNhbnZhc1xuICAgICAqL1xuICAgIHRpbnRXaXRoUGVyUGl4ZWw6IGZ1bmN0aW9uIHRpbnRXaXRoUGVyUGl4ZWwodGV4dHVyZSwgY29sb3IsIGNhbnZhcykge1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgY3JvcCA9IHRleHR1cmUuX2ZyYW1lLmNsb25lKCk7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuXG4gICAgICAgIGNyb3AueCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLnkgKj0gcmVzb2x1dGlvbjtcbiAgICAgICAgY3JvcC53aWR0aCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBjcm9wLmhlaWdodCAqPSByZXNvbHV0aW9uO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbChjcm9wLndpZHRoKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChjcm9wLmhlaWdodCk7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCBjcm9wLngsIGNyb3AueSwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQsIDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgICAgICB2YXIgcmdiVmFsdWVzID0gKDAsIF91dGlscy5oZXgycmdiKShjb2xvcik7XG4gICAgICAgIHZhciByID0gcmdiVmFsdWVzWzBdO1xuICAgICAgICB2YXIgZyA9IHJnYlZhbHVlc1sxXTtcbiAgICAgICAgdmFyIGIgPSByZ2JWYWx1ZXNbMl07XG5cbiAgICAgICAgdmFyIHBpeGVsRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgICAgICB2YXIgcGl4ZWxzID0gcGl4ZWxEYXRhLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaXhlbHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgIHBpeGVsc1tpICsgMF0gKj0gcjtcbiAgICAgICAgICAgIHBpeGVsc1tpICsgMV0gKj0gZztcbiAgICAgICAgICAgIHBpeGVsc1tpICsgMl0gKj0gYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKHBpeGVsRGF0YSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdW5kcyB0aGUgc3BlY2lmaWVkIGNvbG9yIGFjY29yZGluZyB0byB0aGUgQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNUaW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sb3IgLSB0aGUgY29sb3IgdG8gcm91bmQsIHNob3VsZCBiZSBhIGhleCBjb2xvclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJvdW5kZWQgY29sb3IuXG4gICAgICovXG4gICAgcm91bmRDb2xvcjogZnVuY3Rpb24gcm91bmRDb2xvcihjb2xvcikge1xuICAgICAgICB2YXIgc3RlcCA9IENhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsO1xuXG4gICAgICAgIHZhciByZ2JWYWx1ZXMgPSAoMCwgX3V0aWxzLmhleDJyZ2IpKGNvbG9yKTtcblxuICAgICAgICByZ2JWYWx1ZXNbMF0gPSBNYXRoLm1pbigyNTUsIHJnYlZhbHVlc1swXSAvIHN0ZXAgKiBzdGVwKTtcbiAgICAgICAgcmdiVmFsdWVzWzFdID0gTWF0aC5taW4oMjU1LCByZ2JWYWx1ZXNbMV0gLyBzdGVwICogc3RlcCk7XG4gICAgICAgIHJnYlZhbHVlc1syXSA9IE1hdGgubWluKDI1NSwgcmdiVmFsdWVzWzJdIC8gc3RlcCAqIHN0ZXApO1xuXG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnJnYjJoZXgpKHJnYlZhbHVlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBzdGVwcyB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBjYXAgd2hlbiByb3VuZGluZyBjb2xvcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNUaW50ZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWw6IDgsXG5cbiAgICAvKipcbiAgICAgKiBUaW50IGNhY2hlIGJvb2xlYW4gZmxhZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc1RpbnRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnZlcnRUaW50VG9JbWFnZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgQ2FudmFzIEJsZW5kTW9kZXMgYXJlIHN1cHBvcnRlZCwgY29uc2VxdWVudGx5IHRoZSBhYmlsaXR5IHRvIHRpbnQgdXNpbmcgdGhlIG11bHRpcGx5IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc1RpbnRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhblVzZU11bHRpcGx5OiAoMCwgX2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMyLmRlZmF1bHQpKCksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGludGluZyBtZXRob2QgdGhhdCB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNUaW50ZXJcbiAgICAgKiBAdHlwZSB7dGludE1ldGhvZEZ1bmN0aW9uVHlwZX1cbiAgICAgKi9cbiAgICB0aW50TWV0aG9kOiAwXG59O1xuXG5DYW52YXNUaW50ZXIudGludE1ldGhvZCA9IENhbnZhc1RpbnRlci5jYW5Vc2VNdWx0aXBseSA/IENhbnZhc1RpbnRlci50aW50V2l0aE11bHRpcGx5IDogQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWw7XG5cbi8qKlxuICogVGhlIHRpbnRNZXRob2QgdHlwZS5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSS5DYW52YXNUaW50ZXJcbiAqIEBjYWxsYmFjayB0aW50TWV0aG9kRnVuY3Rpb25UeXBlXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige251bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjdXJyZW50IGNhbnZhc1xuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc1RpbnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RpbnRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL2NhbnZhcy9DYW52YXNUaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLy8gZGlzYWJsaW5nIGVzbGludCBmb3Igbm93LCBnb2luZyB0byByZXdyaXRlIHRoaXMgaW4gdjVcbi8qIGVzbGludC1kaXNhYmxlICovXG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlZmF1bHRTdHlsZSA9IHtcbiAgICBhbGlnbjogJ2xlZnQnLFxuICAgIGJyZWFrV29yZHM6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3c6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxuICAgIGRyb3BTaGFkb3dCbHVyOiAwLFxuICAgIGRyb3BTaGFkb3dDb2xvcjogJyMwMDAwMDAnLFxuICAgIGRyb3BTaGFkb3dEaXN0YW5jZTogNSxcbiAgICBmaWxsOiAnYmxhY2snLFxuICAgIGZpbGxHcmFkaWVudFR5cGU6IF9jb25zdC5URVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCxcbiAgICBmaWxsR3JhZGllbnRTdG9wczogW10sXG4gICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICBmb250U2l6ZTogMjYsXG4gICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICBmb250VmFyaWFudDogJ25vcm1hbCcsXG4gICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgbGV0dGVyU3BhY2luZzogMCxcbiAgICBsaW5lSGVpZ2h0OiAwLFxuICAgIGxpbmVKb2luOiAnbWl0ZXInLFxuICAgIG1pdGVyTGltaXQ6IDEwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgIHN0cm9rZVRoaWNrbmVzczogMCxcbiAgICB0ZXh0QmFzZWxpbmU6ICdhbHBoYWJldGljJyxcbiAgICB0cmltOiBmYWxzZSxcbiAgICB3b3JkV3JhcDogZmFsc2UsXG4gICAgd29yZFdyYXBXaWR0aDogMTAwXG59O1xuXG4vKipcbiAqIEEgVGV4dFN0eWxlIE9iamVjdCBkZWNvcmF0ZXMgYSBUZXh0IE9iamVjdC4gSXQgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuXG4gKiBtdWx0aXBsZSBUZXh0IG9iamVjdHMuIENoYW5naW5nIHRoZSBzdHlsZSB3aWxsIHVwZGF0ZSBhbGwgdGV4dCBvYmplY3RzIHVzaW5nIGl0LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuXG52YXIgVGV4dFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc3R5bGVdIC0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0eWxlLmFsaWduPSdsZWZ0J10gLSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLFxuICAgICAqICBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0eWxlLmJyZWFrV29yZHM9ZmFsc2VdIC0gSW5kaWNhdGVzIGlmIGxpbmVzIGNhbiBiZSB3cmFwcGVkIHdpdGhpbiB3b3JkcywgaXRcbiAgICAgKiAgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdHlsZS5kcm9wU2hhZG93PWZhbHNlXSAtIFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUuZHJvcFNoYWRvd0FscGhhPTFdIC0gU2V0IGFscGhhIGZvciB0aGUgZHJvcCBzaGFkb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmRyb3BTaGFkb3dBbmdsZT1NYXRoLlBJLzZdIC0gU2V0IGEgYW5nbGUgb2YgdGhlIGRyb3Agc2hhZG93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5kcm9wU2hhZG93Qmx1cj0wXSAtIFNldCBhIHNoYWRvdyBibHVyIHJhZGl1c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZHJvcFNoYWRvd0NvbG9yPScjMDAwMDAwJ10gLSBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlPTVdIC0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59IFtzdHlsZS5maWxsPSdibGFjayddIC0gQSBjYW52YXNcbiAgICAgKiAgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGUuZyAncmVkJywgJyMwMEZGMDAnLiBDYW4gYmUgYW4gYXJyYXkgdG8gY3JlYXRlIGEgZ3JhZGllbnRcbiAgICAgKiAgZWcgWycjMDAwMDAwJywnI0ZGRkZGRiddXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZmlsbFN0eWxlfE1ETn1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmZpbGxHcmFkaWVudFR5cGU9UElYSS5URVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTF0gLSBJZiBmaWxsIGlzIGFuIGFycmF5IG9mIGNvbG91cnNcbiAgICAgKiAgdG8gY3JlYXRlIGEgZ3JhZGllbnQsIHRoaXMgY2FuIGNoYW5nZSB0aGUgdHlwZS9kaXJlY3Rpb24gb2YgdGhlIGdyYWRpZW50LiBTZWUge0BsaW5rIFBJWEkuVEVYVF9HUkFESUVOVH1cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBbc3R5bGUuZmlsbEdyYWRpZW50U3RvcHNdIC0gSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGFycmF5IGNhbiBzZXRcbiAgICAgKiB0aGUgc3RvcCBwb2ludHMgKG51bWJlcnMgYmV0d2VlbiAwIGFuZCAxKSBmb3IgdGhlIGNvbG9yLCBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBldmVubHkgc3BhY2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbc3R5bGUuZm9udEZhbWlseT0nQXJpYWwnXSAtIFRoZSBmb250IGZhbWlseVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3N0eWxlLmZvbnRTaXplPTI2XSAtIFRoZSBmb250IHNpemUgKGFzIGEgbnVtYmVyIGl0IGNvbnZlcnRzIHRvIHB4LCBidXQgYXMgYSBzdHJpbmcsXG4gICAgICogIGVxdWl2YWxlbnRzIGFyZSAnMjZweCcsJzIwcHQnLCcxNjAlJyBvciAnMS42ZW0nKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZm9udFN0eWxlPSdub3JtYWwnXSAtIFRoZSBmb250IHN0eWxlICgnbm9ybWFsJywgJ2l0YWxpYycgb3IgJ29ibGlxdWUnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZm9udFZhcmlhbnQ9J25vcm1hbCddIC0gVGhlIGZvbnQgdmFyaWFudCAoJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuZm9udFdlaWdodD0nbm9ybWFsJ10gLSBUaGUgZm9udCB3ZWlnaHQgKCdub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicgYW5kICcxMDAnLFxuICAgICAqICAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc3MDAnLCA4MDAnIG9yICc5MDAnKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUubGV0dGVyU3BhY2luZz0wXSAtIFRoZSBhbW91bnQgb2Ygc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMsIGRlZmF1bHQgaXMgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUubGluZUhlaWdodF0gLSBUaGUgbGluZSBoZWlnaHQsIGEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgc3BhY2UgdGhhdCBhIGxldHRlciB1c2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHlsZS5saW5lSm9pbj0nbWl0ZXInXSAtIFRoZSBsaW5lSm9pbiBwcm9wZXJ0eSBzZXRzIHRoZSB0eXBlIG9mIGNvcm5lciBjcmVhdGVkLCBpdCBjYW4gcmVzb2x2ZVxuICAgICAqICAgICAgc3Bpa2VkIHRleHQgaXNzdWVzLiBEZWZhdWx0IGlzICdtaXRlcicgKGNyZWF0ZXMgYSBzaGFycCBjb3JuZXIpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUubWl0ZXJMaW1pdD0xMF0gLSBUaGUgbWl0ZXIgbGltaXQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdtaXRlcicgbGluZUpvaW4gbW9kZS4gVGhpcyBjYW4gcmVkdWNlXG4gICAgICogICAgICBvciBpbmNyZWFzZSB0aGUgc3Bpa2luZXNzIG9mIHJlbmRlcmVkIHRleHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5wYWRkaW5nPTBdIC0gT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQuIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbCBwcmV2ZW50IHRoaXMgZnJvbVxuICAgICAqICAgICBoYXBwZW5pbmcgYnkgYWRkaW5nIHBhZGRpbmcgdG8gYWxsIHNpZGVzIG9mIHRoZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3N0eWxlLnN0cm9rZT0nYmxhY2snXSAtIEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBzdHJva2VcbiAgICAgKiAgZS5nICdibHVlJywgJyNGQ0ZGMDAnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5zdHJva2VUaGlja25lc3M9MF0gLSBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLlxuICAgICAqICBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdHlsZS50cmltPWZhbHNlXSAtIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUudGV4dEJhc2VsaW5lPSdhbHBoYWJldGljJ10gLSBUaGUgYmFzZWxpbmUgb2YgdGhlIHRleHQgdGhhdCBpcyByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdHlsZS53b3JkV3JhcD1mYWxzZV0gLSBJbmRpY2F0ZXMgaWYgd29yZCB3cmFwIHNob3VsZCBiZSB1c2VkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS53b3JkV3JhcFdpZHRoPTEwMF0gLSBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXAsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dFN0eWxlKHN0eWxlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0U3R5bGUpO1xuXG4gICAgICAgIHRoaXMuc3R5bGVJRCA9IDA7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkZWZhdWx0U3R5bGUsIHN0eWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHRTdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dFN0eWxlfSBOZXcgY2xvbmVkIFRleHRTdHlsZSBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgVGV4dFN0eWxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICB2YXIgY2xvbmVkUHJvcGVydGllcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0U3R5bGUpIHtcbiAgICAgICAgICAgIGNsb25lZFByb3BlcnRpZXNba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGV4dFN0eWxlKGNsb25lZFByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIHByb3BlcnRpZXMgdG8gdGhlIGRlZmF1bHRzIHNwZWNpZmllZCBpbiBUZXh0U3R5bGUucHJvdG90eXBlLl9kZWZhdWx0XG4gICAgICovXG5cblxuICAgIFRleHRTdHlsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkZWZhdWx0U3R5bGUpO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGV4dFN0eWxlLCBbe1xuICAgICAgICBrZXk6ICdhbGlnbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhbGlnbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsaWduICE9PSBhbGlnbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JyZWFrV29yZHMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9icmVha1dvcmRzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChicmVha1dvcmRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYnJlYWtXb3JkcyAhPT0gYnJlYWtXb3Jkcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkcm9wU2hhZG93JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvdztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHJvcFNoYWRvdykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3cgIT09IGRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93ID0gZHJvcFNoYWRvdztcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHJvcFNoYWRvd0FscGhhJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FscGhhO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkcm9wU2hhZG93QWxwaGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93QWxwaGEgIT09IGRyb3BTaGFkb3dBbHBoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSA9IGRyb3BTaGFkb3dBbHBoYTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHJvcFNoYWRvd0FuZ2xlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkcm9wU2hhZG93QW5nbGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93QW5nbGUgIT09IGRyb3BTaGFkb3dBbmdsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSA9IGRyb3BTaGFkb3dBbmdsZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHJvcFNoYWRvd0JsdXInLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHJvcFNoYWRvd0JsdXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93Qmx1ciAhPT0gZHJvcFNoYWRvd0JsdXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkcm9wU2hhZG93Q29sb3InLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Q29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRyb3BTaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgdmFyIG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93Q29sb3IgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0NvbG9yID0gb3V0cHV0Q29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Ryb3BTaGFkb3dEaXN0YW5jZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlICE9PSBkcm9wU2hhZG93RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgPSBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZpbGwnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmaWxsKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihmaWxsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maWxsICE9PSBvdXRwdXRDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGwgPSBvdXRwdXRDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmlsbEdyYWRpZW50VHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZpbGxHcmFkaWVudFR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbEdyYWRpZW50VHlwZSA9IGZpbGxHcmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZpbGxHcmFkaWVudFN0b3BzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsbEdyYWRpZW50U3RvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZpbGxHcmFkaWVudFN0b3BzKSB7XG4gICAgICAgICAgICBpZiAoIWFyZUFycmF5c0VxdWFsKHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzLCBmaWxsR3JhZGllbnRTdG9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnRTdG9wcyA9IGZpbGxHcmFkaWVudFN0b3BzO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmb250RmFtaWx5JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udEZhbWlseTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm9udEZhbWlseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmb250U2l6ZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250U2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvbnRTaXplICE9PSBmb250U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZvbnRTdHlsZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm9udFN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9udFN0eWxlICE9PSBmb250U3R5bGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZvbnRWYXJpYW50JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udFZhcmlhbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZvbnRWYXJpYW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9udFZhcmlhbnQgIT09IGZvbnRWYXJpYW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udFZhcmlhbnQgPSBmb250VmFyaWFudDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZm9udFdlaWdodCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRXZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mb250V2VpZ2h0ICE9PSBmb250V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xldHRlclNwYWNpbmcnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gbGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsaW5lSGVpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZUhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGluZUhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmVIZWlnaHQgIT09IGxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGluZUpvaW4nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lSm9pbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGluZUpvaW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lSm9pbiAhPT0gbGluZUpvaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaXRlckxpbWl0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWl0ZXJMaW1pdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobWl0ZXJMaW1pdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGFkZGluZycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHBhZGRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0cm9rZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc3Ryb2tlKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihzdHJva2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cm9rZSAhPT0gb3V0cHV0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2UgPSBvdXRwdXRDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3Ryb2tlVGhpY2tuZXNzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHJva2VUaGlja25lc3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHJva2VUaGlja25lc3MgIT09IHN0cm9rZVRoaWNrbmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZVRoaWNrbmVzcyA9IHN0cm9rZVRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGV4dEJhc2VsaW5lJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEJhc2VsaW5lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndHJpbScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyaW07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRyaW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmltICE9PSB0cmltKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpbSA9IHRyaW07XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3dvcmRXcmFwJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29yZFdyYXA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHdvcmRXcmFwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHdvcmRXcmFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29yZFdyYXAgPSB3b3JkV3JhcDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd29yZFdyYXBXaWR0aCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3JkV3JhcFdpZHRoICE9PSB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29yZFdyYXBXaWR0aCA9IHdvcmRXcmFwV2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVGV4dFN0eWxlO1xufSgpO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29udmVydCBoZXhhZGVjaW1hbCBjb2xvcnMgdG8gc3RyaW5ncywgYW5kIHNpbXBseSByZXR1cm4gdGhlIGNvbG9yIGlmIGl0J3MgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IGNvbG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb2xvciBhcyBhIHN0cmluZy5cbiAqL1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHRTdHlsZTtcbmZ1bmN0aW9uIGdldFNpbmdsZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuaGV4MnN0cmluZykoY29sb3IpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY29sb3IuaW5kZXhPZignMHgnKSA9PT0gMCkge1xuICAgICAgICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKCcweCcsICcjJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb252ZXJ0IGhleGFkZWNpbWFsIGNvbG9ycyB0byBzdHJpbmdzLCBhbmQgc2ltcGx5IHJldHVybiB0aGUgY29sb3IgaWYgaXQncyBhIHN0cmluZy5cbiAqIFRoaXMgdmVyc2lvbiBjYW4gYWxzbyBjb252ZXJ0IGFycmF5IG9mIGNvbG9yc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBjb2xvclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29sb3IgYXMgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgICAgICByZXR1cm4gZ2V0U2luZ2xlQ29sb3IoY29sb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbG9yW2ldID0gZ2V0U2luZ2xlQ29sb3IoY29sb3JbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbnZlcnQgaGV4YWRlY2ltYWwgY29sb3JzIHRvIHN0cmluZ3MsIGFuZCBzaW1wbHkgcmV0dXJuIHRoZSBjb2xvciBpZiBpdCdzIGEgc3RyaW5nLlxuICogVGhpcyB2ZXJzaW9uIGNhbiBhbHNvIGNvbnZlcnQgYXJyYXkgb2YgY29sb3JzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkxIEZpcnN0IGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MiBTZWNvbmQgYXJyYXkgdG8gY29tcGFyZVxuICogQHJldHVybiB7Ym9vbGVhbn0gRG8gdGhlIGFycmF5cyBjb250YWluIHRoZSBzYW1lIHZhbHVlcyBpbiB0aGUgc2FtZSBvcmRlclxuICovXG5mdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhcnJheTEsIGFycmF5Mikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheTEpIHx8ICFBcnJheS5pc0FycmF5KGFycmF5MikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhcnJheTEubGVuZ3RoICE9PSBhcnJheTIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFN0eWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHQvVGV4dFN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfQmFzZVRleHR1cmUyID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpO1xuXG52YXIgX0Jhc2VUZXh0dXJlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUZXh0dXJlMik7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgQmFzZVJlbmRlclRleHR1cmUgaXMgYSBzcGVjaWFsIHRleHR1cmUgdGhhdCBhbGxvd3MgYW55IFBpeGkgZGlzcGxheSBvYmplY3QgdG8gYmUgcmVuZGVyZWQgdG8gaXQuXG4gKlxuICogX19IaW50X186IEFsbCBEaXNwbGF5T2JqZWN0cyAoaS5lLiBTcHJpdGVzKSB0aGF0IHJlbmRlciB0byBhIEJhc2VSZW5kZXJUZXh0dXJlIHNob3VsZCBiZSBwcmVsb2FkZWRcbiAqIG90aGVyd2lzZSBibGFjayByZWN0YW5nbGVzIHdpbGwgYmUgZHJhd24gaW5zdGVhZC5cbiAqXG4gKiBBIEJhc2VSZW5kZXJUZXh0dXJlIHRha2VzIGEgc25hcHNob3Qgb2YgYW55IERpc3BsYXkgT2JqZWN0IGdpdmVuIHRvIGl0cyByZW5kZXIgbWV0aG9kLiBUaGUgcG9zaXRpb25cbiAqIGFuZCByb3RhdGlvbiBvZiB0aGUgZ2l2ZW4gRGlzcGxheSBPYmplY3RzIGlzIGlnbm9yZWQuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBsZXQgcmVuZGVyZXIgPSBQSVhJLmF1dG9EZXRlY3RSZW5kZXJlcigxMDI0LCAxMDI0LCB7IHZpZXc6IGNhbnZhcywgcmF0aW86IDEgfSk7XG4gKiBsZXQgYmFzZVJlbmRlclRleHR1cmUgPSBuZXcgUElYSS5CYXNlUmVuZGVyVGV4dHVyZShyZW5kZXJlciwgODAwLCA2MDApO1xuICogbGV0IHNwcml0ZSA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcInNwaW5PYmpfMDEucG5nXCIpO1xuICpcbiAqIHNwcml0ZS5wb3NpdGlvbi54ID0gODAwLzI7XG4gKiBzcHJpdGUucG9zaXRpb24ueSA9IDYwMC8yO1xuICogc3ByaXRlLmFuY2hvci54ID0gMC41O1xuICogc3ByaXRlLmFuY2hvci55ID0gMC41O1xuICpcbiAqIGJhc2VSZW5kZXJUZXh0dXJlLnJlbmRlcihzcHJpdGUpO1xuICogYGBgXG4gKlxuICogVGhlIFNwcml0ZSBpbiB0aGlzIGNhc2Ugd2lsbCBiZSByZW5kZXJlZCB1c2luZyBpdHMgbG9jYWwgdHJhbnNmb3JtLiBUbyByZW5kZXIgdGhpcyBzcHJpdGUgYXQgMCwwXG4gKiB5b3UgY2FuIGNsZWFyIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBgYGBqc1xuICpcbiAqIHNwcml0ZS5zZXRUcmFuc2Zvcm0oKVxuICpcbiAqIGxldCBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLkJhc2VSZW5kZXJUZXh0dXJlKDEwMCwgMTAwKTtcbiAqIGxldCByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZShiYXNlUmVuZGVyVGV4dHVyZSk7XG4gKlxuICogcmVuZGVyZXIucmVuZGVyKHNwcml0ZSwgcmVuZGVyVGV4dHVyZSk7ICAvLyBSZW5kZXJzIHRvIGNlbnRlciBvZiBSZW5kZXJUZXh0dXJlXG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQmFzZVRleHR1cmVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBCYXNlUmVuZGVyVGV4dHVyZSA9IGZ1bmN0aW9uIChfQmFzZVRleHR1cmUpIHtcbiAgX2luaGVyaXRzKEJhc2VSZW5kZXJUZXh0dXJlLCBfQmFzZVRleHR1cmUpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTEwMF0gLSBUaGUgd2lkdGggb2YgdGhlIGJhc2UgcmVuZGVyIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MTAwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIGJhc2UgcmVuZGVyIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZSBiZWluZyBnZW5lcmF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIEJhc2VSZW5kZXJUZXh0dXJlKCkge1xuICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTAwO1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDtcbiAgICB2YXIgc2NhbGVNb2RlID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciByZXNvbHV0aW9uID0gYXJndW1lbnRzWzNdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VSZW5kZXJUZXh0dXJlKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlVGV4dHVyZS5jYWxsKHRoaXMsIG51bGwsIHNjYWxlTW9kZSkpO1xuXG4gICAgX3RoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgX3NldHRpbmdzMi5kZWZhdWx0LlJFU09MVVRJT047XG5cbiAgICBfdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIF90aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIF90aGlzLnJlYWxXaWR0aCA9IF90aGlzLndpZHRoICogX3RoaXMucmVzb2x1dGlvbjtcbiAgICBfdGhpcy5yZWFsSGVpZ2h0ID0gX3RoaXMuaGVpZ2h0ICogX3RoaXMucmVzb2x1dGlvbjtcblxuICAgIF90aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSAhPT0gdW5kZWZpbmVkID8gc2NhbGVNb2RlIDogX3NldHRpbmdzMi5kZWZhdWx0LlNDQUxFX01PREU7XG4gICAgX3RoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHJlbmRlcmVyIElEcyB0byB3ZWJnbCByZW5kZXJUYXJnZXRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIFdlYkdMVGV4dHVyZT59XG4gICAgICovXG4gICAgX3RoaXMuX2dsUmVuZGVyVGFyZ2V0cyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyByZW5kZXIgdGFyZ2V0ICh3ZSBvbmx5IG5lZWQgb25lIGFzIHRoaXMgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgcmVuZGVyZXJzKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBXZWJHTFRleHR1cmU+fVxuICAgICAqL1xuICAgIF90aGlzLl9jYW52YXNSZW5kZXJUYXJnZXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIGxldCB0aGUgcmVuZGVyZXIga25vdyBpZiB0aGUgdGV4dHVyZSBpcyB2YWxpZC4gSWYgaXQncyBub3QgdGhlbiBpdCBjYW5ub3QgYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIEJhc2VSZW5kZXJUZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggdG8gcmVzaXplIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byByZXNpemUgdG8uXG4gICAqL1xuXG5cbiAgQmFzZVJlbmRlclRleHR1cmUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnZhbGlkID0gd2lkdGggPiAwICYmIGhlaWdodCA+IDA7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnJlYWxXaWR0aCA9IHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5yZWFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb247XG5cbiAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICpcbiAgICovXG5cblxuICBCYXNlUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgX0Jhc2VUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VSZW5kZXJUZXh0dXJlO1xufShfQmFzZVRleHR1cmUzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlUmVuZGVyVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VSZW5kZXJUZXh0dXJlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL0Jhc2VSZW5kZXJUZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfR3JvdXBEID0gcmVxdWlyZSgnLi4vbWF0aC9Hcm91cEQ4Jyk7XG5cbnZhciBfR3JvdXBEMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyb3VwRCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBzdGFuZGFyZCBvYmplY3QgdG8gc3RvcmUgdGhlIFV2cyBvZiBhIHRleHR1cmVcbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgVGV4dHVyZVV2cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHR1cmVVdnMoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0dXJlVXZzKTtcblxuICAgICAgICB0aGlzLngwID0gMDtcbiAgICAgICAgdGhpcy55MCA9IDA7XG5cbiAgICAgICAgdGhpcy54MSA9IDE7XG4gICAgICAgIHRoaXMueTEgPSAwO1xuXG4gICAgICAgIHRoaXMueDIgPSAxO1xuICAgICAgICB0aGlzLnkyID0gMTtcblxuICAgICAgICB0aGlzLngzID0gMDtcbiAgICAgICAgdGhpcy55MyA9IDE7XG5cbiAgICAgICAgdGhpcy51dnNVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGV4dHVyZSBVdnMgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBmcmFtZSAtIFRoZSBmcmFtZSBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGJhc2VGcmFtZSAtIFRoZSBiYXNlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0ZSAtIFJvdGF0aW9uIG9mIGZyYW1lLCBzZWUge0BsaW5rIFBJWEkuR3JvdXBEOH1cbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZVV2cy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGZyYW1lLCBiYXNlRnJhbWUsIHJvdGF0ZSkge1xuICAgICAgICB2YXIgdHcgPSBiYXNlRnJhbWUud2lkdGg7XG4gICAgICAgIHZhciB0aCA9IGJhc2VGcmFtZS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHJvdGF0ZSkge1xuICAgICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBkaXYgMiBkaXYgYmFzZUZyYW1lIHNpemVcbiAgICAgICAgICAgIHZhciB3MiA9IGZyYW1lLndpZHRoIC8gMiAvIHR3O1xuICAgICAgICAgICAgdmFyIGgyID0gZnJhbWUuaGVpZ2h0IC8gMiAvIHRoO1xuXG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBvZiBjZW50ZXJcbiAgICAgICAgICAgIHZhciBjWCA9IGZyYW1lLnggLyB0dyArIHcyO1xuICAgICAgICAgICAgdmFyIGNZID0gZnJhbWUueSAvIHRoICsgaDI7XG5cbiAgICAgICAgICAgIHJvdGF0ZSA9IF9Hcm91cEQyLmRlZmF1bHQuYWRkKHJvdGF0ZSwgX0dyb3VwRDIuZGVmYXVsdC5OVyk7IC8vIE5XIGlzIHRvcC1sZWZ0IGNvcm5lclxuICAgICAgICAgICAgdGhpcy54MCA9IGNYICsgdzIgKiBfR3JvdXBEMi5kZWZhdWx0LnVYKHJvdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnkwID0gY1kgKyBoMiAqIF9Hcm91cEQyLmRlZmF1bHQudVkocm90YXRlKTtcblxuICAgICAgICAgICAgcm90YXRlID0gX0dyb3VwRDIuZGVmYXVsdC5hZGQocm90YXRlLCAyKTsgLy8gcm90YXRlIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXG4gICAgICAgICAgICB0aGlzLngxID0gY1ggKyB3MiAqIF9Hcm91cEQyLmRlZmF1bHQudVgocm90YXRlKTtcbiAgICAgICAgICAgIHRoaXMueTEgPSBjWSArIGgyICogX0dyb3VwRDIuZGVmYXVsdC51WShyb3RhdGUpO1xuXG4gICAgICAgICAgICByb3RhdGUgPSBfR3JvdXBEMi5kZWZhdWx0LmFkZChyb3RhdGUsIDIpO1xuICAgICAgICAgICAgdGhpcy54MiA9IGNYICsgdzIgKiBfR3JvdXBEMi5kZWZhdWx0LnVYKHJvdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnkyID0gY1kgKyBoMiAqIF9Hcm91cEQyLmRlZmF1bHQudVkocm90YXRlKTtcblxuICAgICAgICAgICAgcm90YXRlID0gX0dyb3VwRDIuZGVmYXVsdC5hZGQocm90YXRlLCAyKTtcbiAgICAgICAgICAgIHRoaXMueDMgPSBjWCArIHcyICogX0dyb3VwRDIuZGVmYXVsdC51WChyb3RhdGUpO1xuICAgICAgICAgICAgdGhpcy55MyA9IGNZICsgaDIgKiBfR3JvdXBEMi5kZWZhdWx0LnVZKHJvdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLngwID0gZnJhbWUueCAvIHR3O1xuICAgICAgICAgICAgdGhpcy55MCA9IGZyYW1lLnkgLyB0aDtcblxuICAgICAgICAgICAgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICAgICAgICB0aGlzLnkxID0gZnJhbWUueSAvIHRoO1xuXG4gICAgICAgICAgICB0aGlzLngyID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgICAgIHRoaXMueTIgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcblxuICAgICAgICAgICAgdGhpcy54MyA9IGZyYW1lLnggLyB0dztcbiAgICAgICAgICAgIHRoaXMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXZzVWludDMyWzBdID0gKHRoaXMueTAgKiA2NTUzNSAmIDB4RkZGRikgPDwgMTYgfCB0aGlzLngwICogNjU1MzUgJiAweEZGRkY7XG4gICAgICAgIHRoaXMudXZzVWludDMyWzFdID0gKHRoaXMueTEgKiA2NTUzNSAmIDB4RkZGRikgPDwgMTYgfCB0aGlzLngxICogNjU1MzUgJiAweEZGRkY7XG4gICAgICAgIHRoaXMudXZzVWludDMyWzJdID0gKHRoaXMueTIgKiA2NTUzNSAmIDB4RkZGRikgPDwgMTYgfCB0aGlzLngyICogNjU1MzUgJiAweEZGRkY7XG4gICAgICAgIHRoaXMudXZzVWludDMyWzNdID0gKHRoaXMueTMgKiA2NTUzNSAmIDB4RkZGRikgPDwgMTYgfCB0aGlzLngzICogNjU1MzUgJiAweEZGRkY7XG4gICAgfTtcblxuICAgIHJldHVybiBUZXh0dXJlVXZzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0dXJlVXZzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZVV2cy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9UZXh0dXJlVXZzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfQmFzZVRleHR1cmUyID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpO1xuXG52YXIgX0Jhc2VUZXh0dXJlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUZXh0dXJlMik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgX3RpY2tlciA9IHJlcXVpcmUoJy4uL3RpY2tlcicpO1xuXG52YXIgdGlja2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3RpY2tlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBBIHRleHR1cmUgb2YgYSBbcGxheWluZ10gVmlkZW8uXG4gKlxuICogVmlkZW8gYmFzZSB0ZXh0dXJlcyBtaW1pYyBQaXhpIEJhc2VUZXh0dXJlLmZyb20uLi4uIG1ldGhvZCBpbiB0aGVpciBjcmVhdGlvbiBwcm9jZXNzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gc2V2ZXJhbCB3YXlzLCBzdWNoIGFzOlxuICpcbiAqIGBgYGpzXG4gKiBsZXQgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsKCdodHRwOi8vbXlkb21haW4uY29tL3ZpZGVvLm1wNCcpO1xuICpcbiAqIGxldCB0ZXh0dXJlID0gUElYSS5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmwoeyBzcmM6ICdodHRwOi8vbXlkb21haW4uY29tL3ZpZGVvLm1wNCcsIG1pbWU6ICd2aWRlby9tcDQnIH0pO1xuICpcbiAqIGxldCB0ZXh0dXJlID0gUElYSS5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmxzKFsnL3ZpZGVvLndlYm0nLCAnL3ZpZGVvLm1wNCddKTtcbiAqXG4gKiBsZXQgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJscyhbXG4gKiAgICAgeyBzcmM6ICcvdmlkZW8ud2VibScsIG1pbWU6ICd2aWRlby93ZWJtJyB9LFxuICogICAgIHsgc3JjOiAnL3ZpZGVvLm1wNCcsIG1pbWU6ICd2aWRlby9tcDQnIH1cbiAqIF0pO1xuICogYGBgXG4gKlxuICogU2VlIHRoZSBbXCJkZXVzXCIgZGVtb10oaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vcGl4aWpzL2V4YW1wbGVzL2RldXMvKS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQmFzZVRleHR1cmVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBWaWRlb0Jhc2VUZXh0dXJlID0gZnVuY3Rpb24gKF9CYXNlVGV4dHVyZSkge1xuICAgIF9pbmhlcml0cyhWaWRlb0Jhc2VUZXh0dXJlLCBfQmFzZVRleHR1cmUpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgLSBWaWRlbyBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlkZW9CYXNlVGV4dHVyZShzb3VyY2UsIHNjYWxlTW9kZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9CYXNlVGV4dHVyZSk7XG5cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmlkZW8gc291cmNlIGVsZW1lbnQgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaG9vayBpbiBoZXJlIHRvIGNoZWNrIGlmIHZpZGVvIGlzIGFscmVhZHkgYXZhaWxhYmxlLlxuICAgICAgICAvLyBCYXNlVGV4dHVyZSBsb29rcyBmb3IgYSBzb3VyY2UuY29tcGxldGUgYm9vbGVhbiwgcGx1cyB3aWR0aCAmIGhlaWdodC5cblxuICAgICAgICBpZiAoKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICBzb3VyY2UuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Jhc2VUZXh0dXJlLmNhbGwodGhpcywgc291cmNlLCBzY2FsZU1vZGUpKTtcblxuICAgICAgICBfdGhpcy53aWR0aCA9IHNvdXJjZS52aWRlb1dpZHRoO1xuICAgICAgICBfdGhpcy5oZWlnaHQgPSBzb3VyY2UudmlkZW9IZWlnaHQ7XG5cbiAgICAgICAgX3RoaXMuX2F1dG9VcGRhdGUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBzZXQgdG8gdHJ1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgcGxheSB2aWRlb3MgdXNlZCBieSB0aGlzIHRleHR1cmUgb25jZVxuICAgICAgICAgKiB0aGV5IGFyZSBsb2FkZWQuIElmIGZhbHNlLCBpdCB3aWxsIG5vdCBtb2RpZnkgdGhlIHBsYXlpbmcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmF1dG9QbGF5ID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy51cGRhdGUgPSBfdGhpcy51cGRhdGUuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLl9vbkNhblBsYXkgPSBfdGhpcy5fb25DYW5QbGF5LmJpbmQoX3RoaXMpO1xuXG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgX3RoaXMuX29uUGxheVN0YXJ0LmJpbmQoX3RoaXMpKTtcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgX3RoaXMuX29uUGxheVN0b3AuYmluZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX19sb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIV90aGlzLl9pc1NvdXJjZVJlYWR5KCkpIHtcbiAgICAgICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgX3RoaXMuX29uQ2FuUGxheSk7XG4gICAgICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBfdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9vbkNhblBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyBwbGF5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHBsYXlpbmcuXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9pc1NvdXJjZVBsYXlpbmcgPSBmdW5jdGlvbiBfaXNTb3VyY2VQbGF5aW5nKCkge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5jdXJyZW50VGltZSA+IDAgJiYgc291cmNlLnBhdXNlZCA9PT0gZmFsc2UgJiYgc291cmNlLmVuZGVkID09PSBmYWxzZSAmJiBzb3VyY2UucmVhZHlTdGF0ZSA+IDI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBzb3VyY2UgaXMgcmVhZHkgZm9yIHBsYXlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcmVhZHkuXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9pc1NvdXJjZVJlYWR5ID0gZnVuY3Rpb24gX2lzU291cmNlUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZWFkeVN0YXRlID09PSAzIHx8IHRoaXMuc291cmNlLnJlYWR5U3RhdGUgPT09IDQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIHVwZGF0ZSBsb29wIHdoZW4gdGhlIHZpZGVvIGlzIHJlYWR5IHRvIHBsYXlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vblBsYXlTdGFydCA9IGZ1bmN0aW9uIF9vblBsYXlTdGFydCgpIHtcbiAgICAgICAgLy8gSnVzdCBpbiBjYXNlIHRoZSB2aWRlbyBoYXMgbm90IHJlY2VpdmVkIGl0cyBjYW4gcGxheSBldmVuIHlldC4uXG4gICAgICAgIGlmICghdGhpcy5oYXNMb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2FuUGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0F1dG9VcGRhdGluZyAmJiB0aGlzLmF1dG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgcGF1c2UgZXZlbnQgaXMgdHJpZ2dlcmVkLCBzdG9wcyB0aGUgdXBkYXRlIGxvb3BcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vblBsYXlTdG9wID0gZnVuY3Rpb24gX29uUGxheVN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgdGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHBsYXlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vbkNhblBsYXkgPSBmdW5jdGlvbiBfb25DYW5QbGF5KCkge1xuICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcblxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuc291cmNlLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuc291cmNlLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IG11bHRpcGxlIGxvYWRlZCBkaXNwYXRjaGVzLi5cbiAgICAgICAgICAgIGlmICghdGhpcy5fX2xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uUGxheVN0YXJ0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b1BsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgdGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlLl9waXhpSWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVt0aGlzLnNvdXJjZS5fcGl4aUlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZS5fcGl4aUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgX0Jhc2VUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1pbWljIFBpeGkgQmFzZVRleHR1cmUuZnJvbS4uLi4gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gdmlkZW8gLSBWaWRlbyB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge1BJWEkuVmlkZW9CYXNlVGV4dHVyZX0gTmV3bHkgY3JlYXRlZCBWaWRlb0Jhc2VUZXh0dXJlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUuZnJvbVZpZGVvID0gZnVuY3Rpb24gZnJvbVZpZGVvKHZpZGVvLCBzY2FsZU1vZGUpIHtcbiAgICAgICAgaWYgKCF2aWRlby5fcGl4aUlkKSB7XG4gICAgICAgICAgICB2aWRlby5fcGl4aUlkID0gJ3ZpZGVvXycgKyAoMCwgX3V0aWxzLnVpZCkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IF91dGlscy5CYXNlVGV4dHVyZUNhY2hlW3ZpZGVvLl9waXhpSWRdO1xuXG4gICAgICAgIGlmICghYmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IFZpZGVvQmFzZVRleHR1cmUodmlkZW8sIHNjYWxlTW9kZSk7XG4gICAgICAgICAgICBfdXRpbHMuQmFzZVRleHR1cmVDYWNoZVt2aWRlby5fcGl4aUlkXSA9IGJhc2VUZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IEJhc2VUZXh0dXJlIGJhc2VkIG9uIHRoZSBnaXZlbiB2aWRlbyBlbGVtZW50LlxuICAgICAqIFRoaXMgQmFzZVRleHR1cmUgY2FuIHRoZW4gYmUgdXNlZCB0byBjcmVhdGUgYSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fHN0cmluZ1tdfG9iamVjdFtdfSB2aWRlb1NyYyAtIFRoZSBVUkwocykgZm9yIHRoZSB2aWRlby5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZpZGVvU3JjLnNyY10gLSBPbmUgb2YgdGhlIHNvdXJjZSB1cmxzIGZvciB0aGUgdmlkZW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZpZGVvU3JjLm1pbWVdIC0gVGhlIG1pbWV0eXBlIG9mIHRoZSB2aWRlbyAoZS5nLiAndmlkZW8vbXA0JykuIElmIG5vdCBzcGVjaWZpZWRcbiAgICAgKiAgdGhlIHVybCdzIGV4dGVuc2lvbiB3aWxsIGJlIHVzZWQgYXMgdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBtaW1lIHR5cGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlTW9kZSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge1BJWEkuVmlkZW9CYXNlVGV4dHVyZX0gTmV3bHkgY3JlYXRlZCBWaWRlb0Jhc2VUZXh0dXJlXG4gICAgICovXG5cblxuICAgIFZpZGVvQmFzZVRleHR1cmUuZnJvbVVybCA9IGZ1bmN0aW9uIGZyb21VcmwodmlkZW9TcmMsIHNjYWxlTW9kZSkge1xuICAgICAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuXG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnd2Via2l0LXBsYXlzaW5saW5lJywgJycpO1xuICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJycpO1xuXG4gICAgICAgIC8vIGFycmF5IG9mIG9iamVjdHMgb3Igc3RyaW5nc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2aWRlb1NyYykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlkZW9TcmMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5hcHBlbmRDaGlsZChjcmVhdGVTb3VyY2UodmlkZW9TcmNbaV0uc3JjIHx8IHZpZGVvU3JjW2ldLCB2aWRlb1NyY1tpXS5taW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2luZ2xlIG9iamVjdCBvciBzdHJpbmdcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQoY3JlYXRlU291cmNlKHZpZGVvU3JjLnNyYyB8fCB2aWRlb1NyYywgdmlkZW9TcmMubWltZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHZpZGVvLmxvYWQoKTtcblxuICAgICAgICByZXR1cm4gVmlkZW9CYXNlVGV4dHVyZS5mcm9tVmlkZW8odmlkZW8sIHNjYWxlTW9kZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB0aGUgYmFzZSB0ZXh0dXJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlIGl0c2VsZiwgc2V0IHRvIHRydWUgYnkgZGVmYXVsdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFZpZGVvQmFzZVRleHR1cmUsIFt7XG4gICAgICAgIGtleTogJ2F1dG9VcGRhdGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYXV0b1VwZGF0ZSAmJiB0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmlkZW9CYXNlVGV4dHVyZTtcbn0oX0Jhc2VUZXh0dXJlMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVmlkZW9CYXNlVGV4dHVyZTtcblxuXG5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmxzID0gVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsO1xuXG5mdW5jdGlvbiBjcmVhdGVTb3VyY2UocGF0aCwgdHlwZSkge1xuICAgIGlmICghdHlwZSkge1xuICAgICAgICB0eXBlID0gJ3ZpZGVvLycgKyBwYXRoLnN1YnN0cihwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG5cbiAgICBzb3VyY2Uuc3JjID0gcGF0aDtcbiAgICBzb3VyY2UudHlwZSA9IHR5cGU7XG5cbiAgICByZXR1cm4gc291cmNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlkZW9CYXNlVGV4dHVyZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS90ZXh0dXJlcy9WaWRlb0Jhc2VUZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUluZGljZXNGb3JRdWFkcztcbi8qKlxuICogR2VuZXJpYyBNYXNrIFN0YWNrIGRhdGEgc3RydWN0dXJlXG4gKlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBmdW5jdGlvbiBjcmVhdGVJbmRpY2VzRm9yUXVhZHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIE51bWJlciBvZiBxdWFkc1xuICogQHJldHVybiB7VWludDE2QXJyYXl9IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHNpemUpIHtcbiAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIGluZGljZXMgaW4gb3VyIGFycmF5LCB0aGVyZSBhcmUgNiBwb2ludHMgcGVyIHF1YWQuXG5cbiAgICB2YXIgdG90YWxJbmRpY2VzID0gc2l6ZSAqIDY7XG5cbiAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0b3RhbEluZGljZXMpO1xuXG4gICAgLy8gZmlsbCB0aGUgaW5kaWNlcyB3aXRoIHRoZSBxdWFkcyB0byBkcmF3XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdG90YWxJbmRpY2VzOyBpICs9IDYsIGogKz0gNCkge1xuICAgICAgICBpbmRpY2VzW2kgKyAwXSA9IGogKyAwO1xuICAgICAgICBpbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICBpbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICBpbmRpY2VzW2kgKyAzXSA9IGogKyAwO1xuICAgICAgICBpbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICBpbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRpY2VzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlSW5kaWNlc0ZvclF1YWRzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL2NyZWF0ZUluZGljZXNGb3JRdWFkcy5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDMuMDMuMjAxNy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrRmllbGRzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgX2NoZWNrTGF0aW4odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWF0Y2goL1vQsC3Rj9CQLdCv0ZHQgV0rLykgPT09IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNoZWNrTG9naW4ob2JqKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tMYXRpbihvYmouZmllbGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGVycl90ZXh0OiAnT25seSBMYXRpbicsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmouZmllbGQudmFsdWUubGVuZ3RoIDwgNCkge1xyXG4gICAgICAgICAgICBhcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBlcnJfdGV4dDogJzQgLSBtaW4gbGVuZ3RoJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvYmouaGVscC50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgIGFyci5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkU2V0RXJyKG9iai5maWVsZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRSZW1vdmVPayhvYmouZmllbGQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9iai5oZWxwLnRleHRDb250ZW50ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgb2JqLmhlbHAudGV4dENvbnRlbnQgPSBpdGVtLmVycl90ZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2JqLmhlbHAudGV4dENvbnRlbnQgPSBgJHtvYmouaGVscC50ZXh0Q29udGVudH0sJHtpdGVtLmVycl90ZXh0fWA7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhvYmouaGVscC50ZXh0Q29udGVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkU2V0T2sob2JqLmZpZWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIubGVuZ3RoID09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIF9jaGVja1Bhc3NMZW5ndGgodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IDg7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIF9jaGVja1Bhc3NFcXVhbHModmFsdWUxLCB2YWx1ZTIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNoZWNrRW1wdHkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09IDA7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyBjaGVja1Bhc3N3b3JkKG9iajEsIG9iajIpIHtcclxuICAgICAgICBsZXQgYXJyID0gW107XHJcbiAgICAgICAgbGV0IGNoZWNrID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKGNoZWNrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tQYXNzTGVuZ3RoKG9iajEuZmllbGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyX3RleHQ6ICc4IC0gbWluIGxlbmd0aCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG9iajEuZmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVscDogb2JqMS5oZWxwXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tQYXNzRXF1YWxzKG9iajEuZmllbGQudmFsdWUsIG9iajIuZmllbGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyX3RleHQ6ICdQYXNzd29yZHMgbm90IGVxdWFscycsXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG9iajEuZmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVscDogb2JqMS5oZWxwXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJfdGV4dDogJ1Bhc3N3b3JkcyBub3QgZXF1YWxzJyxcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogb2JqMi5maWVsZCxcclxuICAgICAgICAgICAgICAgICAgICBoZWxwOiBvYmoyLmhlbHBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvYmoxLmhlbHAudGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICBvYmoyLmhlbHAudGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICBhcnIuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgdGhpcy5maWVsZFNldEVycihpdGVtLmZpZWxkKTtcclxuICAgICAgICAgICAgdGhpcy5maWVsZFJlbW92ZU9rKGl0ZW0uZmllbGQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW0uaGVscC50ZXh0Q29udGVudCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0uaGVscC50ZXh0Q29udGVudCA9IGl0ZW0uZXJyX3RleHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmhlbHAudGV4dENvbnRlbnQgPSBgJHtpdGVtLmhlbHAudGV4dENvbnRlbnR9LiR7aXRlbS5lcnJfdGV4dH1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5maWVsZFNldE9rKG9iajEuZmllbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkU2V0T2sob2JqMi5maWVsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnIubGVuZ3RoID09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGhlbHBTZXRUZXh0KGVsZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmaWVsZFNldFRleHQoZWxlbSwgdmFsdWUpIHtcclxuICAgICAgICBlbGVtLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZpZWxkU2V0RXJyKGVsZW0pIHtcclxuICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoJ2lucHV0X19lcnJvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmaWVsZFJlbW92ZUVycihlbGVtKSB7XHJcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCdpbnB1dF9fZXJyb3InKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZmllbGRTZXRPayhlbGVtKSB7XHJcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKCdpbnB1dF9fb2snKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZmllbGRSZW1vdmVPayhlbGVtKSB7XHJcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCdpbnB1dF9fb2snKTtcclxuICAgIH1cclxuXHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbWVudS9hY3Rpb25zL0NoZWNrRmllbGRzLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwMi4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IEJ1dHRvbiBmcm9tICcuL0J0bidcclxuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm0ge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHtkYXRhOiB7fX0pIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcclxuICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBfcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJzKHRoaXMuZGF0YS5mb3JtLmF0dHJzLCB0aGlzLmVsKTtcclxuICAgICAgICBsZXQgaDMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJzKHRoaXMuZGF0YS50aXRsZS5hdHRycywgaDMpO1xyXG4gICAgICAgIGgzLmlubmVySFRNTCA9IHRoaXMuZGF0YS50aXRsZS50ZXh0O1xyXG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoaDMpO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSB0aGlzLl9nZXRGaWVsZHMoKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzID0gdGhpcy5fZ2V0Q29udHJvbHMoKTtcclxuICAgICAgICB0aGlzLl9maWVsZHNBcHBlbmRUbyh0aGlzLmZpZWxkcywgdGhpcy5lbCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NvbnRyb2xzQXBwZW5kVG8odGhpcy5jb250cm9scywgdGhpcy5lbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RWxlbSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRGaWVsZHMoKSB7XHJcbiAgICAgICAgbGV0IHtmaWVsZHMgPSBbXX09dGhpcy5kYXRhO1xyXG4gICAgICAgIHJldHVybiBmaWVsZHMubWFwKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElucHV0KGRhdGEpLmdldEVsZW0oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0QXR0cnMoYXR0cnMsIGVsZW0pIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgX2ZpZWxkc0FwcGVuZFRvKGFycmF5LCBlbGVtKSB7XHJcbiAgICAgICAgYXJyYXkuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChpdGVtLmVsKTtcclxuICAgICAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChpdGVtLmhlbHBfZWwpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgX2NvbnRyb2xzQXBwZW5kVG8oYXJyYXksIGVsZW0pIHtcclxuICAgICAgICBhcnJheS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGl0ZW0uZWwpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgX2dldENvbnRyb2xzKCkge1xyXG4gICAgICAgIGxldCB7Y29udHJvbHMgPSBbXX09dGhpcy5kYXRhO1xyXG4gICAgICAgIHJldHVybiBjb250cm9scy5tYXAoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnV0dG9uKGRhdGEpLmdldEVsZW0oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vdXRlckhUTUw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Rm9ybURhdGEoKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gdGhpcy5lbC5lbGVtZW50cztcclxuICAgICAgICBsZXQgZmllbGRzID0ge307XHJcblxyXG4gICAgICAgIE9iamVjdC5rZXlzKGVsZW1lbnRzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnRzW2VsZW1lbnRdLm5hbWU7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnRzW2VsZW1lbnRdLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWVsZHM7XHJcbiAgICB9XHJcbn1cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL21lbnUvZWxlbWVudHMvRm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTcuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBNZW51VmlldyBmcm9tIFwiLi4vLi4vdmlld3MvbWVudS9NZW51Vmlld1wiO1xyXG5pbXBvcnQgTG9naW5WaWV3IGZyb20gXCIuLi8uLi92aWV3cy9tZW51L0xvZ2luVmlld1wiO1xyXG5pbXBvcnQgU2lnblVwVmlldyBmcm9tIFwiLi4vLi4vdmlld3MvbWVudS9TaWduVXBWaWV3XCI7XHJcbmltcG9ydCBBYm91dFZpZXcgZnJvbSBcIi4uLy4uL3ZpZXdzL21lbnUvQWJvdXRWaWV3XCI7XHJcbmltcG9ydCBMZWFkZXJCb2FyZFZpZXcgZnJvbSBcIi4uLy4uL3ZpZXdzL21lbnUvTGVhZGVyQm9hcmRWaWV3XCI7XHJcbmltcG9ydCBQcm9maWxlVmlldyBmcm9tIFwiLi4vLi4vdmlld3MvbWVudS9Qcm9maWxlVmlld1wiO1xyXG5pbXBvcnQgVXNlciBmcm9tIFwiLi4vLi4vZ2FtZS9vYmplY3QvVXNlclwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uL3NlcnZpY2UvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IEdhbWVWaWV3IGZyb20gXCIuLi8uLi92aWV3cy9nYW1lL0dhbWVWaWV3XCI7XHJcbmltcG9ydCBBbmltYXRpb24gZnJvbSBcIi4uL2FuaW0vQW5pbWF0aW9uXCI7XHJcbmltcG9ydCBSb3V0ZXJVcmxzIGZyb20gXCIuL1JvdXRlclVybHNcIjtcclxuaW1wb3J0IEdhbWVNYW5hZ2VyIGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZXMvR2FtZU1hbmFnZXJcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JrQvtC90YHRgtGA0YPQutGC0L7RgFxyXG4gICAgICogQHBhcmFtIG5vZGUgLSDQvtCx0LvQsNGB0YLRjCDQtNC10LnRgdGC0LLQuNGPXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMucm91dGVzID0ge307XHJcbiAgICAgICAgdGhpcy5jdXJyVmlldyA9IG51bGw7XHJcbiAgICAgICAgd2luZG93LnJvdXRlciA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICAgICAgd2luZG93Lm9ucG9wc3RhdGUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q3VyclZpZXcoZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUsIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JjQvdC40YbQuNCw0LvQuNC30LDRhtC40Y8g0LLRgdC10YUg0LLRjNGO0YjQtdC6XHJcbiAgICAgKi9cclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgbGV0IGdhbWVWaWV3ID0gbmV3IEdhbWVWaWV3KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lLXZpZXcnKSk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIod2luZG93Lk1BSU4sIG5ldyBNZW51Vmlldyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudS12aWV3JykpKTtcclxuICAgICAgICB0aGlzLl9yZWdpc3Rlcih3aW5kb3cuU0lOR0xFUExBWUVSLCBnYW1lVmlldyk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIod2luZG93Lk1VTFRJUExBWUVSLCBnYW1lVmlldyk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIod2luZG93LkxPR0lOLCBuZXcgTG9naW5WaWV3KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dpbi12aWV3JykpKTtcclxuICAgICAgICB0aGlzLl9yZWdpc3Rlcih3aW5kb3cuU0lHTlVQLCBuZXcgU2lnblVwVmlldyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lnbnVwLXZpZXcnKSkpO1xyXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyKHdpbmRvdy5MRUFERVJCT0FSRCwgbmV3IExlYWRlckJvYXJkVmlldyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVhZGVyYm9hcmQtdmlldycpKSk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIod2luZG93LkFCT1VULCBuZXcgQWJvdXRWaWV3KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhYm91dC12aWV3JykpKTtcclxuICAgICAgICB0aGlzLl9yZWdpc3Rlcih3aW5kb3cuUFJPRklMRSwgbmV3IFByb2ZpbGVWaWV3KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9maWxlLXZpZXcnKSkpO1xyXG4gICAgICAgIHRoaXMuX3NldEN1cnJWaWV3KGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lKTtcclxuICAgICAgICB0aGlzLl9zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KPRgdGC0LDQvdC+0LLQuNGC0Ywg0YLQtdC60YPRidGD0Y4g0LLRjNGO0YjQutGDXHJcbiAgICAgKiBAcGFyYW0gcGF0aFxyXG4gICAgICogQHBhcmFtIGlzVG9IaXN0b3J5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc2V0Q3VyclZpZXcocGF0aCwgaXNUb0hpc3RvcnkpIHtcclxuICAgICAgICBpZiAoaXNUb0hpc3RvcnkgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHtvcGE6ICdvcGEnfSwgJ3RpdGxlMScsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jaGVja1VzZXIocGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9GA0L7QstC10YDQutCwLCDQt9Cw0LvQvtCz0LjQvdC10L0g0LvQuCDRjtC30LXRgFxyXG4gICAgICogQHBhcmFtIHBhdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jaGVja1VzZXIocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoID09PSB3aW5kb3cuTE9HSU4gfHwgcGF0aCA9PT0gd2luZG93LlNJR05VUCkge1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRVc2VyKCkudGhlbih1c2VyID0+IHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5VU0VSID0gdXNlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dvKHdpbmRvdy5QUk9GSUxFKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dvKHBhdGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBhdGggPT09IHdpbmRvdy5QUk9GSUxFKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dldFVzZXIoKS50aGVuKHVzZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LlVTRVIgPSB1c2VyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ28ocGF0aCk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nbyh3aW5kb3cuTE9HSU4pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBhdGggPT09IHdpbmRvdy5TSU5HTEVQTEFZRVIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0VXNlcigpLnRoZW4odXNlciA9PiB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuVVNFUiA9IHVzZXI7XHJcbiAgICAgICAgICAgICAgICBuZXcgR2FtZU1hbmFnZXIodXNlciwgdGhpcy5nZXRWaWV3QnlSb3V0ZShwYXRoKSwgd2luZG93LlNJTkdMRVBMQVlFUl9TVFJBVEVHWSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nbyh3aW5kb3cuU0lOR0xFUExBWUVSKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dvKHdpbmRvdy5MT0dJTik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gd2luZG93Lk1VTFRJUExBWUVSKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dldFVzZXIoKS50aGVuKHVzZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LlVTRVIgPSB1c2VyO1xyXG4gICAgICAgICAgICAgICAgbmV3IEdhbWVNYW5hZ2VyKHVzZXIsIHRoaXMuZ2V0Vmlld0J5Um91dGUocGF0aCksIHdpbmRvdy5NVUxUSVBMQVlFUl9TVFJBVEVHWSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nbyh3aW5kb3cuTVVMVElQTEFZRVIpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ28od2luZG93LkxPR0lOKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZ28ocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J/QvtC70YPRh9C40YLRjCDRjtC30LXRgNCwXHJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2dldFVzZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5VU0VSKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdy5VU0VSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXcgVXNlclNlcnZpY2UoKS5nZXRVc2VyKCkudGhlbih1c2VyID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcik7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9C10YDQtdC50YLQuCDQv9C+INC80LDRgNGI0YDRg9GC0YMg0Lgg0L/QvtC80LXQvdGP0YLRjCDRgtC10LrRg9GJ0YPRjiDQstGM0Y7RiNC60YNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXHJcbiAgICAgKi9cclxuICAgIF9nbyhwYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VyclZpZXcgIT09IG51bGwgJiYgdGhpcy5jdXJyVmlldy5jb25zdHJ1Y3Rvci5uYW1lID09PSBHYW1lVmlldy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyclZpZXcuY2xlYXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJWaWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyclZpZXcudG9nZ2xlVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJWaWV3ID0gdGhpcy5nZXRWaWV3QnlSb3V0ZShwYXRoKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJWaWV3KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXRoID09PSB3aW5kb3cuUFJPRklMRSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJWaWV3LnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VyclZpZXcudG9nZ2xlVmlldygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KDQtdCz0LjRgdGC0YDQsNGG0LjRjyDQvNCw0YDRiNGA0YPRgtCwXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3XHJcbiAgICAgKi9cclxuICAgIF9yZWdpc3Rlcihyb3V0ZSwgdmlldykge1xyXG4gICAgICAgIHRoaXMucm91dGVzW3JvdXRlXSA9IHZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9C+0LvRg9GH0LXQvdC40LUg0LzQsNGA0YjRgNGD0YLQsFxyXG4gICAgICogQHBhcmFtIGhyZWZcclxuICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgKi9cclxuICAgIGdldFZpZXdCeVJvdXRlKGhyZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXNbaHJlZl07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQl9Cw0L/Rg9GB0YLQuNGC0Ywg0L/RgNC+0YbQtdGBINC80LDRgNGI0YDRg9GC0LjQt9Cw0YbQuNC4XHJcbiAgICAgKi9cclxuICAgIF9zdGFydCgpIHtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB0aGlzLl9vblJvdXRlQ2hhbmdlKGV2ZW50KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9GA0L7QstC10YDQutCwINC90LAg0YHQvNC10L3QtdC90L3Ri9C5INC80LDRgNGI0YDRg9GCXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9vblJvdXRlQ2hhbmdlKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnJWaWV3KGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQucGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnJWaWV3KGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvc3VwcG9ydC9yb3V0ZXIvUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwNC4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IFJvdXRlciBmcm9tICcuL3N1cHBvcnQvcm91dGVyL1JvdXRlcic7XHJcbmltcG9ydCBSb3V0ZXJVcmxzIGZyb20gXCIuL3N1cHBvcnQvcm91dGVyL1JvdXRlclVybHNcIjtcclxubmV3IFJvdXRlclVybHMoKTtcclxubmV3IFJvdXRlcih3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcclxuXHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvQXBwbGljYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcbiAqIGl6aVRvYXN0IHwgdjEuMS4wXHJcbiAqIGh0dHA6Ly9peml0b2FzdC5tYXJjZWxvZG9sY2UuY29tXHJcbiAqIGJ5IE1hcmNlbG8gRG9sY2UuXHJcbiAqLyBcclxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KHJvb3QpKTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyb290Lml6aVRvYXN0ID0gZmFjdG9yeShyb290KTtcclxuXHR9XHJcbn0pKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0aGlzLndpbmRvdyB8fCB0aGlzLmdsb2JhbCwgZnVuY3Rpb24gKHJvb3QpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHQvL1xyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdC8vXHJcblx0dmFyICRpemlUb2FzdCA9IHt9LFxyXG5cdFx0UExVR0lOX05BTUUgPSAnaXppVG9hc3QnLFxyXG5cdFx0Qk9EWSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSxcclxuXHRcdElTTU9CSUxFID0gKC9Nb2JpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSA/IHRydWUgOiBmYWxzZSxcclxuXHRcdElTQ0hST01FID0gL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvR29vZ2xlIEluYy8udGVzdChuYXZpZ2F0b3IudmVuZG9yKSxcclxuXHRcdElTRklSRUZPWCA9IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcsXHJcblx0XHRBQ0NFUFRTVE9VQ0ggPSAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblx0XHRQT1NJVElPTlMgPSBbJ2JvdHRvbVJpZ2h0JywnYm90dG9tTGVmdCcsJ2JvdHRvbUNlbnRlcicsJ3RvcFJpZ2h0JywndG9wTGVmdCcsJ3RvcENlbnRlcicsJ2NlbnRlciddLFxyXG5cdFx0VEhFTUVTID0ge1xyXG5cdFx0XHRpbmZvOiB7XHJcblx0XHRcdFx0Y29sb3I6IFwiYmx1ZVwiLFxyXG5cdFx0XHRcdGljb246IFwiaWNvLWluZm9cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzdWNjZXNzOiB7XHJcblx0XHRcdFx0Y29sb3I6IFwiZ3JlZW5cIixcclxuXHRcdFx0XHRpY29uOiBcImljby1jaGVja1wiLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHR3YXJuaW5nOiB7XHJcblx0XHRcdFx0Y29sb3I6IFwieWVsbG93XCIsXHJcblx0XHRcdFx0aWNvbjogXCJpY28td2FybmluZ1wiLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRlcnJvcjoge1xyXG5cdFx0XHRcdGNvbG9yOiBcInJlZFwiLFxyXG5cdFx0XHRcdGljb246IFwiaWNvLWVycm9yXCIsXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRNT0JJTEVXSURUSCA9IDU2OCxcclxuXHRcdENPTkZJRyA9IHt9O1xyXG5cclxuXHQvLyBEZWZhdWx0IHNldHRpbmdzXHJcblx0dmFyIGRlZmF1bHRzID0ge1xyXG5cdFx0Y2xhc3M6ICcnLFxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cdFx0dGl0bGVDb2xvcjogJycsXHJcblx0XHRtZXNzYWdlOiAnJyxcclxuXHRcdG1lc3NhZ2VDb2xvcjogJycsXHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICcnLFxyXG5cdFx0Y29sb3I6ICcnLCAvLyBibHVlLCByZWQsIGdyZWVuLCB5ZWxsb3dcclxuXHRcdGljb246ICcnLFxyXG5cdFx0aWNvblRleHQ6ICcnLFxyXG5cdFx0aWNvbkNvbG9yOiAnJyxcclxuXHRcdGltYWdlOiAnJyxcclxuXHRcdGltYWdlV2lkdGg6IDUwLFxyXG5cdFx0emluZGV4OiA5OTk5OSxcclxuXHRcdGxheW91dDogMSxcclxuXHRcdGJhbGxvb246IGZhbHNlLFxyXG5cdFx0Y2xvc2U6IHRydWUsXHJcblx0XHRydGw6IGZhbHNlLFxyXG5cdFx0cG9zaXRpb246ICdib3R0b21SaWdodCcsIC8vIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgdG9wTGVmdCwgdG9wQ2VudGVyLCBib3R0b21DZW50ZXIsIGNlbnRlclxyXG5cdFx0dGFyZ2V0OiAnJyxcclxuXHRcdHRhcmdldEZpcnN0OiB0cnVlLFxyXG5cdFx0dGltZW91dDogNTAwMCxcclxuXHRcdGRyYWc6IHRydWUsXHJcblx0XHRwYXVzZU9uSG92ZXI6IHRydWUsXHJcblx0XHRyZXNldE9uSG92ZXI6IGZhbHNlLFxyXG5cdFx0cHJvZ3Jlc3NCYXI6IHRydWUsXHJcblx0XHRwcm9ncmVzc0JhckNvbG9yOiAnJyxcclxuXHRcdGFuaW1hdGVJbnNpZGU6IHRydWUsXHJcblx0XHRidXR0b25zOiB7fSxcclxuXHRcdHRyYW5zaXRpb25JbjogJ2ZhZGVJblVwJywgLy8gYm91bmNlSW5MZWZ0LCBib3VuY2VJblJpZ2h0LCBib3VuY2VJblVwLCBib3VuY2VJbkRvd24sIGZhZGVJbiwgZmFkZUluRG93biwgZmFkZUluVXAsIGZhZGVJbkxlZnQsIGZhZGVJblJpZ2h0LCBmbGlwSW5YXHJcblx0XHR0cmFuc2l0aW9uT3V0OiAnZmFkZU91dCcsIC8vIGZhZGVPdXQsIGZhZGVPdXRVcCwgZmFkZU91dERvd24sIGZhZGVPdXRMZWZ0LCBmYWRlT3V0UmlnaHQsIGZsaXBPdXRYXHJcblx0XHR0cmFuc2l0aW9uSW5Nb2JpbGU6ICdmYWRlSW5VcCcsXHJcblx0XHR0cmFuc2l0aW9uT3V0TW9iaWxlOiAnZmFkZU91dERvd24nLFxyXG5cdFx0b25PcGVuOiBmdW5jdGlvbiAoKSB7fSxcclxuXHRcdG9uQ2xvc2U6IGZ1bmN0aW9uICgpIHt9XHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHQvLyBNZXRob2RzXHJcblx0Ly9cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBvbHlmaWxsIGZvciByZW1vdmUoKSBtZXRob2RcclxuXHQgKi9cclxuXHRpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuXHQgICAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQSBzaW1wbGUgZm9yRWFjaCgpIGltcGxlbWVudGF0aW9uIGZvciBBcnJheXMsIE9iamVjdHMgYW5kIE5vZGVMaXN0c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R8Tm9kZUxpc3R9IGNvbGxlY3Rpb24gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byBpdGVyYXRlXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlcmF0aW9uXHJcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R8Tm9kZUxpc3R9IHNjb3BlIE9iamVjdC9Ob2RlTGlzdC9BcnJheSB0aGF0IGZvckVhY2ggaXMgaXRlcmF0aW5nIG92ZXIgKGFrYSBgdGhpc2ApXHJcblx0ICovXHJcblx0dmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHNjb3BlKSB7XHJcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbGxlY3Rpb24pID09PSAnW29iamVjdCBPYmplY3RdJykge1xyXG5cdFx0XHRmb3IgKHZhciBwcm9wIGluIGNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIHByb3ApKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNjb3BlLCBjb2xsZWN0aW9uW3Byb3BdLCBwcm9wLCBjb2xsZWN0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmKGNvbGxlY3Rpb24pe1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2xsZWN0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNjb3BlLCBjb2xsZWN0aW9uW2ldLCBpLCBjb2xsZWN0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBNZXJnZSBkZWZhdWx0cyB3aXRoIHVzZXIgb3B0aW9uc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzIERlZmF1bHQgc2V0dGluZ3NcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBVc2VyIG9wdGlvbnNcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBNZXJnZWQgdmFsdWVzIG9mIGRlZmF1bHRzIGFuZCBvcHRpb25zXHJcblx0ICovXHJcblx0dmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cywgb3B0aW9ucykge1xyXG5cdFx0dmFyIGV4dGVuZGVkID0ge307XHJcblx0XHRmb3JFYWNoKGRlZmF1bHRzLCBmdW5jdGlvbiAodmFsdWUsIHByb3ApIHtcclxuXHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcclxuXHRcdH0pO1xyXG5cdFx0Zm9yRWFjaChvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIHByb3ApIHtcclxuXHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gZXh0ZW5kZWQ7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhIGZyYWdtZW50IERPTSBlbGVtZW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dmFyIGNyZWF0ZUZyYWdFbGVtID0gZnVuY3Rpb24oaHRtbFN0cikge1xyXG5cdFx0dmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcblx0XHRcdHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHRlbXAuaW5uZXJIVE1MID0gaHRtbFN0cjtcclxuXHRcdHdoaWxlICh0ZW1wLmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0ZnJhZy5hcHBlbmRDaGlsZCh0ZW1wLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZyYWc7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIGlzIGEgY29sb3JcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHZhciBpc0NvbG9yID0gZnVuY3Rpb24oY29sb3Ipe1xyXG5cdFx0aWYoIGNvbG9yLnN1YnN0cmluZygwLDEpID09IFwiI1wiIHx8IGNvbG9yLnN1YnN0cmluZygwLDMpID09IFwicmdiXCIgfHwgY29sb3Iuc3Vic3RyaW5nKDAsMykgPT0gXCJoc2xcIiApe1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRHJhZyBtZXRob2Qgb2YgdG9hc3RzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR2YXIgZHJhZyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgICBcclxuXHQgICAgcmV0dXJuIHtcclxuXHQgICAgICAgIG1vdmU6IGZ1bmN0aW9uKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIHhwb3MpIHtcclxuXHJcblx0ICAgICAgICBcdHZhciBvcGFjaXR5LFxyXG5cdCAgICAgICAgXHRcdG9wYWNpdHlSYW5nZSA9IDAuMyxcclxuXHQgICAgICAgIFx0XHRkaXN0YW5jZSA9IDE4MDtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB0b2FzdC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnK3hwb3MgKyAncHgpJztcclxuXHJcblx0ICAgICAgICAgICAgaWYoeHBvcyA+IDApe1xyXG5cdCAgICAgICAgICAgIFx0b3BhY2l0eSA9IChkaXN0YW5jZS14cG9zKSAvIGRpc3RhbmNlO1xyXG5cdCAgICAgICAgICAgIFx0aWYob3BhY2l0eSA8IG9wYWNpdHlSYW5nZSl7XHJcblx0XHRcdFx0XHRcdGluc3RhbmNlLmhpZGUoZXh0ZW5kKHNldHRpbmdzLCB7IHRyYW5zaXRpb25PdXQ6ICdmYWRlT3V0UmlnaHQnLCB0cmFuc2l0aW9uT3V0TW9iaWxlOiAnZmFkZU91dFJpZ2h0JyB9KSwgdG9hc3QsICdkcmFnJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBcdG9wYWNpdHkgPSAoZGlzdGFuY2UreHBvcykgLyBkaXN0YW5jZTtcclxuXHQgICAgICAgICAgICBcdGlmKG9wYWNpdHkgPCBvcGFjaXR5UmFuZ2Upe1xyXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5oaWRlKGV4dGVuZChzZXR0aW5ncywgeyB0cmFuc2l0aW9uT3V0OiAnZmFkZU91dExlZnQnLCB0cmFuc2l0aW9uT3V0TW9iaWxlOiAnZmFkZU91dExlZnQnIH0pLCB0b2FzdCwgJ2RyYWcnKTtcclxuXHRcdFx0XHRcdH1cclxuXHQgICAgICAgICAgICB9XHJcblx0XHRcdFx0dG9hc3Quc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRcclxuXHRcdFx0XHRpZihvcGFjaXR5IDwgb3BhY2l0eVJhbmdlKXtcclxuXHJcblx0XHRcdFx0XHRpZihJU0NIUk9NRSB8fCBJU0ZJUkVGT1gpXHJcblx0XHRcdFx0XHRcdHRvYXN0LnN0eWxlLmxlZnQgPSB4cG9zKydweCc7XHJcblxyXG5cdFx0XHRcdFx0dG9hc3QucGFyZW50Tm9kZS5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eVJhbmdlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdG9wTW92aW5nKHRvYXN0LCBudWxsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3RhcnRNb3Zpbmc6IGZ1bmN0aW9uKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIGUpIHtcclxuXHJcblx0ICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdCAgICAgICAgICAgIHZhciBwb3NYID0gKChBQ0NFUFRTVE9VQ0gpID8gZS50b3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFgpLFxyXG5cdCAgICAgICAgICAgICAgICB0b2FzdExlZnQgPSB0b2FzdC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgncHgpJywgJycpO1xyXG5cdCAgICAgICAgICAgICAgICB0b2FzdExlZnQgPSB0b2FzdExlZnQucmVwbGFjZSgndHJhbnNsYXRlWCgnLCAnJyk7XHJcblx0ICAgICAgICAgICAgdmFyIG9mZnNldFggPSBwb3NYIC0gdG9hc3RMZWZ0O1xyXG5cclxuXHRcdFx0XHR0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKHNldHRpbmdzLnRyYW5zaXRpb25Jbik7XHJcblx0XHRcdFx0dG9hc3QuY2xhc3NMaXN0LnJlbW92ZShzZXR0aW5ncy50cmFuc2l0aW9uSW5Nb2JpbGUpO1xyXG5cdFx0XHRcdHRvYXN0LnN0eWxlLnRyYW5zaXRpb24gPSBcIlwiO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoQUNDRVBUU1RPVUNIKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50Lm9udG91Y2htb3ZlID0gZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBvc1ggPSBlLnRvdWNoZXNbMF0uY2xpZW50WCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFggPSBwb3NYIC0gb2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZy5tb3ZlKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIGZpbmFsWCk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBmdW5jdGlvbihlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcG9zWCA9IGUuY2xpZW50WCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFggPSBwb3NYIC0gb2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZy5tb3ZlKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIGZpbmFsWCk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdG9wTW92aW5nOiBmdW5jdGlvbih0b2FzdCwgZSkge1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoQUNDRVBUU1RPVUNIKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50Lm9udG91Y2htb3ZlID0gZnVuY3Rpb24oKSB7fTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIFx0ZG9jdW1lbnQub25tb3VzZW1vdmUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcdFx0XHR0b2FzdC5zdHlsZS50cmFuc2l0aW9uID0gXCJ0cmFuc2Zvcm0gMC40cyBlYXNlLCBvcGFjaXR5IDAuNHMgZWFzZVwiO1xyXG5cdFx0XHRcdHRvYXN0LnN0eWxlLm9wYWNpdHkgPSBcIlwiO1xyXG5cdFx0XHRcdHRvYXN0LnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7XHJcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0b2FzdC5zdHlsZS50cmFuc2l0aW9uID0gXCJcIjtcclxuXHRcdFx0XHR9LCA0MDApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cclxuXHR9KCk7XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBEbyB0aGUgY2FsY3VsYXRpb24gdG8gbW92ZSB0aGUgcHJvZ3Jlc3MgYmFyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR2YXIgbW92ZVByb2dyZXNzID0gZnVuY3Rpb24odG9hc3QsIHNldHRpbmdzLCBjYWxsYmFjayl7XHJcblxyXG5cdFx0dmFyIGlzUGF1c2VkID0gZmFsc2U7XHJcblx0XHR2YXIgaXNSZXNldGVkID0gZmFsc2U7XHJcblx0XHR2YXIgaXNDbG9zZWQgPSBmYWxzZTtcclxuXHRcdHZhciB0aW1lclRpbWVvdXQgPSBudWxsO1xyXG5cdFx0dmFyIGVsZW0gPSB0b2FzdC5xdWVyeVNlbGVjdG9yKFwiLlwiK1BMVUdJTl9OQU1FK1wiLXByb2dyZXNzYmFyIGRpdlwiKTtcclxuXHRcdHZhciBwcm9ncmVzc0JhciA9IHtcclxuXHRcdFx0aGlkZUV0YTogbnVsbCxcclxuXHRcdFx0bWF4SGlkZVRpbWU6IG51bGwsXHJcblx0XHRcdGN1cnJlbnRUaW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcclxuXHRcdFx0dXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uKClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlzUGF1c2VkID0gdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKFBMVUdJTl9OQU1FKyctcGF1c2VkJykgPyB0cnVlIDogZmFsc2U7XHJcblx0XHRcdFx0aXNSZXNldGVkID0gdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKFBMVUdJTl9OQU1FKyctcmVzZXRlZCcpID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdFx0XHRcdGlzQ2xvc2VkID0gdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKFBMVUdJTl9OQU1FKyctY2xvc2VkJykgPyB0cnVlIDogZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmKGlzUmVzZXRlZCl7XHJcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcclxuXHRcdFx0XHRcdGVsZW0uc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblx0XHRcdFx0XHRtb3ZlUHJvZ3Jlc3ModG9hc3QsIHNldHRpbmdzLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0XHR0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKFBMVUdJTl9OQU1FKyctcmVzZXRlZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihpc0Nsb3NlZCl7XHJcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcclxuXHRcdFx0XHRcdHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoUExVR0lOX05BTUUrJy1jbG9zZWQnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKCFpc1BhdXNlZCAmJiAhaXNSZXNldGVkICYmICFpc0Nsb3NlZCl7XHJcblx0XHRcdFx0XHRwcm9ncmVzc0Jhci5jdXJyZW50VGltZSA9IHByb2dyZXNzQmFyLmN1cnJlbnRUaW1lKzEwO1xyXG5cdFx0XHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSAoKHByb2dyZXNzQmFyLmhpZGVFdGEgLSAocHJvZ3Jlc3NCYXIuY3VycmVudFRpbWUpKSAvIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lKSAqIDEwMDtcclxuXHRcdFx0XHRcdGVsZW0uc3R5bGUud2lkdGggPSBwZXJjZW50YWdlICsgJyUnO1xyXG5cclxuXHRcdFx0XHRcdGlmKE1hdGgucm91bmQocGVyY2VudGFnZSkgPCAwIHx8IHR5cGVvZiB0b2FzdCAhPSAnb2JqZWN0Jyl7XHJcblx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRpZiAoc2V0dGluZ3MudGltZW91dCA+IDApIHtcclxuXHRcdFx0cHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWUgPSBwYXJzZUZsb2F0KHNldHRpbmdzLnRpbWVvdXQpO1xyXG5cdFx0XHRwcm9ncmVzc0Jhci5oaWRlRXRhID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZTtcclxuXHRcdFx0dGltZXJUaW1lb3V0ID0gc2V0SW50ZXJ2YWwocHJvZ3Jlc3NCYXIudXBkYXRlUHJvZ3Jlc3MsIDEwKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEZXN0cm95IHRoZSBjdXJyZW50IGluaXRpYWxpemF0aW9uLlxyXG5cdCAqIEBwdWJsaWNcclxuXHQgKi9cclxuXHQkaXppVG9hc3QuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3JFYWNoKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nK1BMVUdJTl9OQU1FKyctd3JhcHBlcicpLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0XHRlbGVtZW50LnJlbW92ZSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zm9yRWFjaChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJytQTFVHSU5fTkFNRSksIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XHJcblx0XHRcdGVsZW1lbnQucmVtb3ZlKCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFBMVUdJTl9OQU1FKyctb3BlbicsIHt9LCBmYWxzZSk7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFBMVUdJTl9OQU1FKyctY2xvc2UnLCB7fSwgZmFsc2UpO1xyXG5cclxuXHRcdC8vIFJlc2V0IHZhcmlhYmxlc1xyXG5cdFx0Q09ORklHID0ge307XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSBQbHVnaW5cclxuXHQgKiBAcHVibGljXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVXNlciBzZXR0aW5nc1xyXG5cdCAqL1xyXG5cdCRpemlUb2FzdC5zZXR0aW5ncyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0Ly8gRGVzdHJveSBhbnkgZXhpc3RpbmcgaW5pdGlhbGl6YXRpb25zXHJcblx0XHQkaXppVG9hc3QuZGVzdHJveSgpO1xyXG5cclxuXHRcdENPTkZJRyA9IG9wdGlvbnM7XHJcblx0XHRkZWZhdWx0cyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJ1aWxkaW5nIHRoZW1lcyBmdW5jdGlvbnMuXHJcblx0ICogQHB1YmxpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFVzZXIgc2V0dGluZ3NcclxuXHQgKi9cclxuXHRmb3JFYWNoKFRIRU1FUywgZnVuY3Rpb24gKHRoZW1lLCBuYW1lKSB7XHJcblxyXG5cdFx0JGl6aVRvYXN0W25hbWVdID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRcdHZhciBzZXR0aW5ncyA9IGV4dGVuZChDT05GSUcsIG9wdGlvbnMgfHwge30pO1xyXG5cdFx0XHRzZXR0aW5ncyA9IGV4dGVuZCh0aGVtZSwgc2V0dGluZ3MgfHwge30pO1xyXG5cclxuXHRcdFx0dGhpcy5zaG93KHNldHRpbmdzKTtcclxuXHRcdH07XHJcblxyXG5cdH0pO1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQ2xvc2UgdGhlIHNwZWNpZmljIFRvYXN0XHJcblx0ICogQHB1YmxpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFVzZXIgc2V0dGluZ3NcclxuXHQgKi9cclxuXHQkaXppVG9hc3QuaGlkZSA9IGZ1bmN0aW9uIChvcHRpb25zLCAkdG9hc3QsIGNsb3NlZEJ5KSB7XHJcblxyXG5cdFx0dmFyIHNldHRpbmdzID0gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcclxuXHRcdFx0Y2xvc2VkQnkgPSBjbG9zZWRCeSB8fCBmYWxzZTtcclxuXHJcblx0XHRpZih0eXBlb2YgJHRvYXN0ICE9ICdvYmplY3QnKXtcclxuXHRcdFx0JHRvYXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigkdG9hc3QpO1xyXG5cdFx0fVxyXG5cdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1jbG9zZWQnKTtcclxuXHJcblx0XHRpZihzZXR0aW5ncy50cmFuc2l0aW9uSW4gfHwgc2V0dGluZ3MudHJhbnNpdGlvbkluTW9iaWxlKXtcclxuXHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoc2V0dGluZ3MudHJhbnNpdGlvbkluKTtcclxuXHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoc2V0dGluZ3MudHJhbnNpdGlvbkluTW9iaWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSBNT0JJTEVXSURUSCl7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25PdXRNb2JpbGUpXHJcblx0XHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoc2V0dGluZ3MudHJhbnNpdGlvbk91dE1vYmlsZSk7XHJcblx0XHR9IGVsc2V7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25PdXQpXHJcblx0XHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoc2V0dGluZ3MudHJhbnNpdGlvbk91dCk7XHJcblx0XHR9XHJcblx0XHR2YXIgSCA9ICR0b2FzdC5wYXJlbnROb2RlLm9mZnNldEhlaWdodDtcclxuXHRcdFx0XHQkdG9hc3QucGFyZW50Tm9kZS5zdHlsZS5oZWlnaHQgPSBIKydweCc7XHJcblx0XHRcdFx0JHRvYXN0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcblx0XHRcclxuXHRcdGlmKCFJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA+IE1PQklMRVdJRFRIKXtcclxuXHRcdFx0JHRvYXN0LnBhcmVudE5vZGUuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gJzAuMnMnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdCR0b2FzdC5wYXJlbnROb2RlLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xyXG5cdFx0XHQkdG9hc3QucGFyZW50Tm9kZS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xyXG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdCR0b2FzdC5wYXJlbnROb2RlLnJlbW92ZSgpO1xyXG5cdFx0XHR9LDEwMDApO1xyXG5cdFx0fSwyMDApO1xyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jbGFzcyl7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dmFyIGV2ZW50O1xyXG5cdFx0XHRcdGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcclxuXHRcdFx0XHRcdGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFBMVUdJTl9OQU1FKyctY2xvc2UnLCB7ZGV0YWlsOiB7Y2xhc3M6IHNldHRpbmdzLmNsYXNzfX0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG5cdFx0XHRcdFx0ZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFBMVUdJTl9OQU1FKyctY2xvc2UnLCB0cnVlLCB0cnVlLCB7Y2xhc3M6IHNldHRpbmdzLmNsYXNzfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdFx0XHR9IGNhdGNoKGV4KXtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodHlwZW9mIHNldHRpbmdzLm9uQ2xvc2UgIT09IFwidW5kZWZpbmVkXCIpe1xyXG5cdFx0XHRzZXR0aW5ncy5vbkNsb3NlLmFwcGx5KG51bGwsIFtzZXR0aW5ncywgJHRvYXN0LCBjbG9zZWRCeV0pO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhbmQgc2hvdyB0aGUgVG9hc3RcclxuXHQgKiBAcHVibGljXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVXNlciBzZXR0aW5nc1xyXG5cdCAqL1xyXG5cdCRpemlUb2FzdC5zaG93ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gTWVyZ2UgdXNlciBvcHRpb25zIHdpdGggZGVmYXVsdHNcclxuXHRcdHZhciBzZXR0aW5ncyA9IGV4dGVuZChDT05GSUcsIG9wdGlvbnMgfHwge30pO1xyXG5cdFx0XHRzZXR0aW5ncyA9IGV4dGVuZChkZWZhdWx0cywgc2V0dGluZ3MpO1xyXG5cclxuXHRcdHZhciAkdG9hc3RDYXBzdWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdFx0JHRvYXN0Q2Fwc3VsZS5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FK1wiLWNhcHN1bGVcIik7XHJcblxyXG5cdFx0dmFyICR0b2FzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FKTtcclxuXHJcblx0XHRpZihJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSBNT0JJTEVXSURUSCl7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25Jbk1vYmlsZS5sZW5ndGg+MClcclxuXHRcdFx0XHQkdG9hc3QuY2xhc3NMaXN0LmFkZChzZXR0aW5ncy50cmFuc2l0aW9uSW5Nb2JpbGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYoc2V0dGluZ3MudHJhbnNpdGlvbkluLmxlbmd0aD4wKVxyXG5cdFx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKHNldHRpbmdzLnRyYW5zaXRpb25Jbik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MucnRsKXtcclxuXHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUgKyAnLXJ0bCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jb2xvci5sZW5ndGggPiAwKSB7IC8vIywgcmdiLCByZ2JhLCBoc2xcclxuXHRcdFx0XHJcblx0XHRcdGlmKCBpc0NvbG9yKHNldHRpbmdzLmNvbG9yKSApe1xyXG5cdFx0XHRcdCR0b2FzdC5zdHlsZS5iYWNrZ3JvdW5kID0gc2V0dGluZ3MuY29sb3I7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1jb2xvci0nK3NldHRpbmdzLmNvbG9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHNldHRpbmdzLmJhY2tncm91bmRDb2xvci5sZW5ndGggPiAwKSB7XHJcblx0XHRcdCR0b2FzdC5zdHlsZS5iYWNrZ3JvdW5kID0gc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jbGFzcyl7XHJcblx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKHNldHRpbmdzLmNsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2V0dGluZ3MuaW1hZ2UpIHtcclxuXHRcdFx0dmFyICRjb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCRjb3Zlci5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FICsgJy1jb3ZlcicpO1xyXG5cdFx0XHQkY292ZXIuc3R5bGUud2lkdGggPSBzZXR0aW5ncy5pbWFnZVdpZHRoICsgXCJweFwiO1xyXG5cdFx0XHQkY292ZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgc2V0dGluZ3MuaW1hZ2UgKyAnKSc7XHJcblx0XHRcdCR0b2FzdC5hcHBlbmRDaGlsZCgkY292ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciAkYnV0dG9uQ2xvc2U7XHJcblx0XHRpZihzZXR0aW5ncy5jbG9zZSl7XHJcblx0XHRcdCRidXR0b25DbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcblx0XHRcdCRidXR0b25DbG9zZS5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FICsgJy1jbG9zZScpO1xyXG5cdFx0XHQkdG9hc3QuYXBwZW5kQ2hpbGQoJGJ1dHRvbkNsb3NlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmKHNldHRpbmdzLnJ0bCl7XHJcblx0XHRcdFx0JHRvYXN0LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIzMHB4XCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMzBweFwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNldHRpbmdzLnByb2dyZXNzQmFyKSB7XHJcblxyXG5cdFx0XHR2YXIgJHByb2dyZXNzQmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdFx0XHQkcHJvZ3Jlc3NCYXIuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRSArICctcHJvZ3Jlc3NiYXInKTtcclxuXHJcblx0XHRcdHZhciAkcHJvZ3Jlc3NCYXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0XHRcdCRwcm9ncmVzc0JhckRpdi5zdHlsZS5iYWNrZ3JvdW5kID0gc2V0dGluZ3MucHJvZ3Jlc3NCYXJDb2xvcjtcclxuXHJcblx0XHRcdCRwcm9ncmVzc0Jhci5hcHBlbmRDaGlsZCgkcHJvZ3Jlc3NCYXJEaXYpO1xyXG5cdFx0XHQkdG9hc3QuYXBwZW5kQ2hpbGQoJHByb2dyZXNzQmFyKTtcclxuXHRcdFx0XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bW92ZVByb2dyZXNzKCR0b2FzdCwgc2V0dGluZ3MsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHR0aGF0LmhpZGUoc2V0dGluZ3MsICR0b2FzdCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0sMzAwKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoIHNldHRpbmdzLnByb2dyZXNzQmFyID09PSBmYWxzZSAmJiBzZXR0aW5ncy50aW1lb3V0ID4gMCl7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhhdC5oaWRlKHNldHRpbmdzLCAkdG9hc3QpO1xyXG5cdFx0XHR9LCBzZXR0aW5ncy50aW1lb3V0KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgJHRvYXN0Qm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCR0b2FzdEJvZHkuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRSArICctYm9keScpO1xyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5pbWFnZSkge1xyXG5cdFx0XHRpZihzZXR0aW5ncy5ydGwpe1xyXG5cdFx0XHRcdCR0b2FzdEJvZHkuc3R5bGUubWFyZ2luUmlnaHQgPSAoc2V0dGluZ3MuaW1hZ2VXaWR0aCArIDEwKSArICdweCc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0Qm9keS5zdHlsZS5tYXJnaW5MZWZ0ID0gKHNldHRpbmdzLmltYWdlV2lkdGggKyAxMCkgKyAncHgnO1x0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2V0dGluZ3MuaWNvbikge1xyXG5cdFx0XHR2YXIgJGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuXHRcdFx0XHQkaWNvbi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBQTFVHSU5fTkFNRSArICctaWNvbiAnICsgc2V0dGluZ3MuaWNvbik7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuaWNvblRleHQpe1xyXG5cdFx0XHRcdCRpY29uLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNldHRpbmdzLmljb25UZXh0KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHNldHRpbmdzLnJ0bCl7XHJcblx0XHRcdFx0JHRvYXN0Qm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnMzNweCc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0Qm9keS5zdHlsZS5wYWRkaW5nTGVmdCA9ICczM3B4JztcdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuaWNvbkNvbG9yKXtcclxuXHRcdFx0XHQkaWNvbi5zdHlsZS5jb2xvciA9IHNldHRpbmdzLmljb25Db2xvcjtcclxuXHRcdFx0fVxyXG5cdFx0XHQkdG9hc3RCb2R5LmFwcGVuZENoaWxkKCRpY29uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgJHN0cm9uZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHJvbmdcIik7XHJcblx0XHRpZiAoc2V0dGluZ3MudGl0bGVDb2xvci5sZW5ndGggPiAwKSB7XHJcblx0XHRcdCRzdHJvbmcuc3R5bGUuY29sb3IgPSBzZXR0aW5ncy50aXRsZUNvbG9yO1xyXG5cdFx0fVxyXG5cdFx0JHN0cm9uZy5hcHBlbmRDaGlsZChjcmVhdGVGcmFnRWxlbShzZXR0aW5ncy50aXRsZSkpO1xyXG5cclxuXHRcdHZhciAkcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xyXG5cdFx0aWYgKHNldHRpbmdzLm1lc3NhZ2VDb2xvci5sZW5ndGggPiAwKSB7XHJcblx0XHRcdCRwLnN0eWxlLmNvbG9yID0gc2V0dGluZ3MubWVzc2FnZUNvbG9yO1xyXG5cdFx0fVxyXG5cdFx0JHAuYXBwZW5kQ2hpbGQoY3JlYXRlRnJhZ0VsZW0oc2V0dGluZ3MubWVzc2FnZSkpO1xyXG5cclxuXHRcdGlmKHNldHRpbmdzLmxheW91dCA+IDEpe1xyXG5cdFx0XHQkdG9hc3QuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRStcIi1sYXlvdXRcIitzZXR0aW5ncy5sYXlvdXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHNldHRpbmdzLmJhbGxvb24pe1xyXG5cdFx0XHQkdG9hc3QuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRStcIi1iYWxsb29uXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCR0b2FzdEJvZHkuYXBwZW5kQ2hpbGQoJHN0cm9uZyk7XHJcblx0XHQkdG9hc3RCb2R5LmFwcGVuZENoaWxkKCRwKTtcclxuXHJcblx0XHR2YXIgJGJ1dHRvbnM7XHJcblx0XHRpZiAoc2V0dGluZ3MuYnV0dG9ucy5sZW5ndGggPiAwKSB7XHJcblxyXG5cdFx0XHQkYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCRidXR0b25zLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUgKyAnLWJ1dHRvbnMnKTtcclxuXHJcblx0XHRcdCRwLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzE1cHgnO1xyXG5cclxuXHRcdFx0dmFyIGkgPSAwO1xyXG5cdFx0XHRmb3JFYWNoKHNldHRpbmdzLmJ1dHRvbnMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcclxuXHRcdFx0XHQkYnV0dG9ucy5hcHBlbmRDaGlsZChjcmVhdGVGcmFnRWxlbSh2YWx1ZVswXSkpO1xyXG5cclxuXHRcdFx0XHR2YXIgJGJ0bnMgPSAkYnV0dG9ucy5jaGlsZE5vZGVzO1xyXG5cclxuXHRcdFx0XHQkYnRuc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHR2YXIgdHMgPSB2YWx1ZVsxXTtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgdHModGhhdCwgJHRvYXN0KTsgXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0fSk7XHJcblx0XHRcdCR0b2FzdEJvZHkuYXBwZW5kQ2hpbGQoJGJ1dHRvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCR0b2FzdC5hcHBlbmRDaGlsZCgkdG9hc3RCb2R5KTtcclxuXHRcdCR0b2FzdENhcHN1bGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdFx0JHRvYXN0Q2Fwc3VsZS5hcHBlbmRDaGlsZCgkdG9hc3QpO1xyXG5cclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBIID0gJHRvYXN0Lm9mZnNldEhlaWdodDtcclxuXHRcdFx0dmFyIHN0eWxlID0gJHRvYXN0LmN1cnJlbnRTdHlsZSB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgkdG9hc3QpO1xyXG5cdFx0XHR2YXIgbWFyZ2luVG9wID0gc3R5bGUubWFyZ2luVG9wO1xyXG5cdFx0XHRcdG1hcmdpblRvcCA9IG1hcmdpblRvcC5zcGxpdChcInB4XCIpO1xyXG5cdFx0XHRcdG1hcmdpblRvcCA9IHBhcnNlSW50KG1hcmdpblRvcFswXSk7XHJcblx0XHRcdHZhciBtYXJnaW5Cb3R0b20gPSBzdHlsZS5tYXJnaW5Cb3R0b207XHJcblx0XHRcdFx0bWFyZ2luQm90dG9tID0gbWFyZ2luQm90dG9tLnNwbGl0KFwicHhcIik7XHJcblx0XHRcdFx0bWFyZ2luQm90dG9tID0gcGFyc2VJbnQobWFyZ2luQm90dG9tWzBdKTtcclxuXHJcblx0XHRcdCR0b2FzdENhcHN1bGUuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cdFx0XHQkdG9hc3RDYXBzdWxlLnN0eWxlLmhlaWdodCA9IChIK21hcmdpbkJvdHRvbSttYXJnaW5Ub3ApKydweCc7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JHRvYXN0Q2Fwc3VsZS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcblx0XHRcdFx0aWYoc2V0dGluZ3MudGFyZ2V0KXtcclxuXHRcdFx0XHRcdCR0b2FzdENhcHN1bGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LDEwMDApO1xyXG5cdFx0fSwgMTAwKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBzZXR0aW5ncy5wb3NpdGlvbixcclxuXHRcdFx0JHdyYXBwZXI7XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MudGFyZ2V0KXtcclxuXHJcblx0XHRcdCR3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZXR0aW5ncy50YXJnZXQpO1xyXG5cdFx0XHQkd3JhcHBlci5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FICsgJy10YXJnZXQnKTtcclxuXHJcblx0XHRcdGlmIChzZXR0aW5ncy50YXJnZXRGaXJzdCkge1xyXG5cdFx0XHRcdCR3cmFwcGVyLmluc2VydEJlZm9yZSgkdG9hc3RDYXBzdWxlLCAkd3JhcHBlci5maXJzdENoaWxkKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkd3JhcHBlci5hcHBlbmRDaGlsZCgkdG9hc3RDYXBzdWxlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiggUE9TSVRJT05TLmluZGV4T2Yoc2V0dGluZ3MucG9zaXRpb24pID09IC0xICl7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiW1wiK1BMVUdJTl9OQU1FK1wiXSBJbmNvcnJlY3QgcG9zaXRpb24uXFxuSXQgY2FuIGJlIOKAuiBcIiArIFBPU0lUSU9OUyk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSBNT0JJTEVXSURUSCl7XHJcblx0XHRcdFx0aWYoc2V0dGluZ3MucG9zaXRpb24gPT0gXCJib3R0b21MZWZ0XCIgfHwgc2V0dGluZ3MucG9zaXRpb24gPT0gXCJib3R0b21SaWdodFwiIHx8IHNldHRpbmdzLnBvc2l0aW9uID09IFwiYm90dG9tQ2VudGVyXCIpe1xyXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBQTFVHSU5fTkFNRSsnLXdyYXBwZXItYm90dG9tQ2VudGVyJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZihzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcExlZnRcIiB8fCBzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcFJpZ2h0XCIgfHwgc2V0dGluZ3MucG9zaXRpb24gPT0gXCJ0b3BDZW50ZXJcIil7XHJcblx0XHRcdFx0XHRwb3NpdGlvbiA9IFBMVUdJTl9OQU1FKyctd3JhcHBlci10b3BDZW50ZXInO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBQTFVHSU5fTkFNRSsnLXdyYXBwZXItY2VudGVyJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cG9zaXRpb24gPSBQTFVHSU5fTkFNRSsnLXdyYXBwZXItJytwb3NpdGlvbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQkd3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgUExVR0lOX05BTUUgKyAnLXdyYXBwZXIuJytwb3NpdGlvbik7XHJcblxyXG5cdFx0XHRpZiAoISR3cmFwcGVyKSB7XHJcblx0XHRcdFx0JHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0XHRcdCR3cmFwcGVyLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUgKyAnLXdyYXBwZXInKTtcclxuXHRcdFx0XHQkd3JhcHBlci5jbGFzc0xpc3QuYWRkKHBvc2l0aW9uKTtcclxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCR3cmFwcGVyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcExlZnRcIiB8fCBzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcENlbnRlclwiIHx8IHNldHRpbmdzLnBvc2l0aW9uID09IFwidG9wUmlnaHRcIil7XHJcblx0XHRcdFx0JHdyYXBwZXIuaW5zZXJ0QmVmb3JlKCR0b2FzdENhcHN1bGUsICR3cmFwcGVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCR3cmFwcGVyLmFwcGVuZENoaWxkKCR0b2FzdENhcHN1bGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc05hTihzZXR0aW5ncy56aW5kZXgpKSB7XHJcblx0XHRcdCR3cmFwcGVyLnN0eWxlLnpJbmRleCA9IHNldHRpbmdzLnppbmRleDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnNvbGUud2FybihcIltcIitQTFVHSU5fTkFNRStcIl0gSW52YWxpZCB6SW5kZXguXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNldHRpbmdzLm9uT3Blbi5hcHBseShudWxsLCBbc2V0dGluZ3MsICR0b2FzdF0pO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHZhciBldmVudDtcclxuXHRcdFx0aWYgKHdpbmRvdy5DdXN0b21FdmVudCkge1xyXG5cdFx0XHRcdGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFBMVUdJTl9OQU1FKyctb3BlbicsIHtkZXRhaWw6IHtjbGFzczogc2V0dGluZ3MuY2xhc3N9fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcclxuXHRcdFx0XHRldmVudC5pbml0Q3VzdG9tRXZlbnQoUExVR0lOX05BTUUrJy1vcGVuJywgdHJ1ZSwgdHJ1ZSwge2NsYXNzOiBzZXR0aW5ncy5jbGFzc30pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdFx0fSBjYXRjaChleCl7XHJcblx0XHRcdGNvbnNvbGUud2FybihleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MuYW5pbWF0ZUluc2lkZSl7XHJcblx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FKyctYW5pbWF0ZUluc2lkZScpO1xyXG5cdFx0XHJcblx0XHRcdHZhciB0aW1lQW5pbWF0aW9uMSA9IDIwMDtcclxuXHRcdFx0dmFyIHRpbWVBbmltYXRpb24yID0gMTAwO1xyXG5cdFx0XHR2YXIgdGltZUFuaW1hdGlvbjMgPSAzMDA7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25JbiA9PSBcImJvdW5jZUluTGVmdFwiKXtcclxuXHRcdFx0XHR0aW1lQW5pbWF0aW9uMSA9IDQwMDtcclxuXHRcdFx0XHR0aW1lQW5pbWF0aW9uMiA9IDIwMDtcclxuXHRcdFx0XHR0aW1lQW5pbWF0aW9uMyA9IDQwMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHQkc3Ryb25nLmNsYXNzTGlzdC5hZGQoJ3NsaWRlSW4nKTtcclxuXHRcdFx0fSx0aW1lQW5pbWF0aW9uMSk7XHJcblxyXG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdCRwLmNsYXNzTGlzdC5hZGQoJ3NsaWRlSW4nKTtcclxuXHRcdFx0fSx0aW1lQW5pbWF0aW9uMik7XHJcblxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuaWNvbikge1xyXG5cdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHQkaWNvbi5jbGFzc0xpc3QuYWRkKCdyZXZlYWxJbicpO1xyXG5cdFx0XHRcdH0sdGltZUFuaW1hdGlvbjMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuYnV0dG9ucy5sZW5ndGggPiAwICYmICRidXR0b25zKSB7XHJcblx0XHRcdFx0dmFyIGNvdW50ZXIgPSAxNTA7XHJcblx0XHRcdFx0Zm9yRWFjaCgkYnV0dG9ucy5jaGlsZE5vZGVzLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cclxuXHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncmV2ZWFsSW4nKTtcclxuXHRcdFx0XHRcdH0sY291bnRlcik7XHJcblx0XHRcdFx0XHRjb3VudGVyID0gY291bnRlciArIGNvdW50ZXI7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYoJGJ1dHRvbkNsb3NlKXtcclxuXHRcdFx0JGJ1dHRvbkNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR2YXIgYnV0dG9uID0gZS50YXJnZXQ7XHJcblx0XHRcdFx0dGhhdC5oaWRlKHNldHRpbmdzLCAkdG9hc3QsICdidXR0b24nKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MucGF1c2VPbkhvdmVyKXtcclxuXHRcdFx0XHJcblx0XHRcdCR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR0aGlzLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1wYXVzZWQnKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdCR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR0aGlzLmNsYXNzTGlzdC5yZW1vdmUoUExVR0lOX05BTUUrJy1wYXVzZWQnKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MucmVzZXRPbkhvdmVyKXtcclxuXHJcblx0XHRcdCR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR0aGlzLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1yZXNldGVkJyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0dGhpcy5jbGFzc0xpc3QucmVtb3ZlKFBMVUdJTl9OQU1FKyctcmVzZXRlZCcpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihzZXR0aW5ncy5kcmFnKXtcclxuXHJcblx0XHRcdGlmIChBQ0NFUFRTVE9VQ0gpIHtcclxuXHJcblx0XHRcdCAgICAkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0ICAgICAgICBkcmFnLnN0YXJ0TW92aW5nKHRoaXMsIHRoYXQsIHNldHRpbmdzLCBlKTtcclxuXHRcdFx0ICAgIH0sIGZhbHNlKTtcclxuXHJcblx0XHRcdCAgICAkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdCAgICAgICAgZHJhZy5zdG9wTW92aW5nKHRoaXMsIGUpO1xyXG5cdFx0XHQgICAgfSwgZmFsc2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ICAgICR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdCAgICBcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0ICAgICAgICBkcmFnLnN0YXJ0TW92aW5nKHRoaXMsIHRoYXQsIHNldHRpbmdzLCBlKTtcclxuXHRcdFx0ICAgIH0sIGZhbHNlKTtcclxuXHJcblx0XHRcdCAgICAkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0ICAgIFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHQgICAgICAgIGRyYWcuc3RvcE1vdmluZyh0aGlzLCBlKTtcclxuXHRcdFx0ICAgIH0sIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuICRpemlUb2FzdDtcclxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2l6aXRvYXN0L2Rpc3QvanMvaXppVG9hc3QuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRU1QVFlfQVJSQVlfQlVGRkVSID0gbmV3IEFycmF5QnVmZmVyKDApO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSB3ZWJHTCBidWZmZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gdHlwZSB7Z2wuQVJSQVlfQlVGRkVSIHwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJ9IEBtYXRcbiAqIEBwYXJhbSBkYXRhIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhbiBhcnJheSBvZiBkYXRhXG4gKiBAcGFyYW0gZHJhd1R5cGUge2dsLlNUQVRJQ19EUkFXfGdsLkRZTkFNSUNfRFJBV3xnbC5TVFJFQU1fRFJBV31cbiAqL1xudmFyIEJ1ZmZlciA9IGZ1bmN0aW9uKGdsLCB0eXBlLCBkYXRhLCBkcmF3VHlwZSlcbntcblxuXHQvKipcbiAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuXHR0aGlzLmdsID0gZ2w7XG5cblx0LyoqXG4gICAgICogVGhlIFdlYkdMIGJ1ZmZlciwgY3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb25cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMQnVmZmVyfVxuICAgICAqL1xuXHR0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2dsLkFSUkFZX0JVRkZFUnxnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUn1cbiAgICAgKi9cblx0dGhpcy50eXBlID0gdHlwZSB8fCBnbC5BUlJBWV9CVUZGRVI7XG5cblx0LyoqXG4gICAgICogVGhlIGRyYXcgdHlwZSBvZiB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtnbC5TVEFUSUNfRFJBV3xnbC5EWU5BTUlDX0RSQVd8Z2wuU1RSRUFNX0RSQVd9XG4gICAgICovXG5cdHRoaXMuZHJhd1R5cGUgPSBkcmF3VHlwZSB8fCBnbC5TVEFUSUNfRFJBVztcblxuXHQvKipcbiAgICAgKiBUaGUgZGF0YSBpbiB0aGUgYnVmZmVyLCBhcyBhIHR5cGVkIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fVxuICAgICAqL1xuXHR0aGlzLmRhdGEgPSBFTVBUWV9BUlJBWV9CVUZGRVI7XG5cblx0aWYoZGF0YSlcblx0e1xuXHRcdHRoaXMudXBsb2FkKGRhdGEpO1xuXHR9XG5cblx0dGhpcy5fdXBkYXRlSUQgPSAwO1xufTtcblxuLyoqXG4gKiBVcGxvYWRzIHRoZSBidWZmZXIgdG8gdGhlIEdQVVxuICogQHBhcmFtIGRhdGEge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGFuIGFycmF5IG9mIGRhdGEgdG8gdXBsb2FkXG4gKiBAcGFyYW0gb2Zmc2V0IHtOdW1iZXJ9IGlmIG9ubHkgYSBzdWJzZXQgb2YgdGhlIGRhdGEgc2hvdWxkIGJlIHVwbG9hZGVkLCB0aGlzIGlzIHRoZSBhbW91bnQgb2YgZGF0YSB0byBzdWJ0cmFjdFxuICogQHBhcmFtIGRvbnRCaW5kIHtCb29sZWFufSB3aGV0aGVyIHRvIGJpbmQgdGhlIGJ1ZmZlciBiZWZvcmUgdXBsb2FkaW5nIGl0XG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBkb250QmluZClcbntcblx0Ly8gdG9kbyAtIG5lZWRlZD9cblx0aWYoIWRvbnRCaW5kKSB0aGlzLmJpbmQoKTtcblxuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdGRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YTtcblx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cblx0aWYodGhpcy5kYXRhLmJ5dGVMZW5ndGggPj0gZGF0YS5ieXRlTGVuZ3RoKVxuXHR7XG5cdFx0Z2wuYnVmZmVyU3ViRGF0YSh0aGlzLnR5cGUsIG9mZnNldCwgZGF0YSk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0Z2wuYnVmZmVyRGF0YSh0aGlzLnR5cGUsIGRhdGEsIHRoaXMuZHJhd1R5cGUpO1xuXHR9XG5cblx0dGhpcy5kYXRhID0gZGF0YTtcbn07XG4vKipcbiAqIEJpbmRzIHRoZSBidWZmZXJcbiAqXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblx0Z2wuYmluZEJ1ZmZlcih0aGlzLnR5cGUsIHRoaXMuYnVmZmVyKTtcbn07XG5cbkJ1ZmZlci5jcmVhdGVWZXJ0ZXhCdWZmZXIgPSBmdW5jdGlvbihnbCwgZGF0YSwgZHJhd1R5cGUpXG57XG5cdHJldHVybiBuZXcgQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGRyYXdUeXBlKTtcbn07XG5cbkJ1ZmZlci5jcmVhdGVJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uKGdsLCBkYXRhLCBkcmF3VHlwZSlcbntcblx0cmV0dXJuIG5ldyBCdWZmZXIoZ2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCBkcmF3VHlwZSk7XG59O1xuXG5CdWZmZXIuY3JlYXRlID0gZnVuY3Rpb24oZ2wsIHR5cGUsIGRhdGEsIGRyYXdUeXBlKVxue1xuXHRyZXR1cm4gbmV3IEJ1ZmZlcihnbCwgdHlwZSwgZGF0YSwgZHJhd1R5cGUpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgYnVmZmVyXG4gKlxuICovXG5CdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuXHR0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLWdsLWNvcmUvc3JjL0dMQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgVGV4dHVyZSA9IHJlcXVpcmUoJy4vR0xUZXh0dXJlJyk7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHdlYkdMIEZyYW1lYnVmZmVyXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqL1xudmFyIEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEZyYW1lYnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmJ1ZmZlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0ZW5jaWwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLmdsQ29yZS5HTFRleHR1cmV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMTAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTAwO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdGV4dHVyZSB0byB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5nbENvcmUuR0xUZXh0dXJlfVxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuZW5hYmxlVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUgfHwgbmV3IFRleHR1cmUoZ2wpO1xuXG4gICAgdGhpcy50ZXh0dXJlLmJpbmQoKTtcblxuICAgIC8vZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGlzZXMgdGhlIHN0ZW5jaWwgYnVmZmVyXG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS5lbmFibGVTdGVuY2lsID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKHRoaXMuc3RlbmNpbClyZXR1cm47XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5zdGVuY2lsID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5zdGVuY2lsKTtcblxuICAgIC8vIFRPRE8uLiB0aGlzIGlzIGRlcHRoIEFORCBzdGVuY2lsP1xuICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5zdGVuY2lsKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgIHRoaXMud2lkdGggICwgdGhpcy5oZWlnaHQgKTtcblxuXG59O1xuXG4vKipcbiAqIEVyYXNlcyB0aGUgZHJhd2luZyBhcmVhIGFuZCBmaWxscyBpdCB3aXRoIGEgY29sb3VyXG4gKiBAcGFyYW0gIHIge051bWJlcn0gdGhlIHJlZCB2YWx1ZSBvZiB0aGUgY2xlYXJpbmcgY29sb3VyXG4gKiBAcGFyYW0gIGcge051bWJlcn0gdGhlIGdyZWVuIHZhbHVlIG9mIHRoZSBjbGVhcmluZyBjb2xvdXJcbiAqIEBwYXJhbSAgYiB7TnVtYmVyfSB0aGUgYmx1ZSB2YWx1ZSBvZiB0aGUgY2xlYXJpbmcgY29sb3VyXG4gKiBAcGFyYW0gIGEge051bWJlcn0gdGhlIGFscGhhIHZhbHVlIG9mIHRoZSBjbGVhcmluZyBjb2xvdXJcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oIHIsIGcsIGIsIGEgKVxue1xuICAgIHRoaXMuYmluZCgpO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGdsLmNsZWFyQ29sb3IociwgZywgYiwgYSk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgZnJhbWUgYnVmZmVyIHRvIHRoZSBXZWJHTCBjb250ZXh0XG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyICk7XG59O1xuXG4vKipcbiAqIFVuYmluZHMgdGhlIGZyYW1lIGJ1ZmZlciB0byB0aGUgV2ViR0wgY29udGV4dFxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG59O1xuLyoqXG4gKiBSZXNpemVzIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGJ1ZmZlciB0byB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICogQHBhcmFtICB3aWR0aCAge051bWJlcn0gdGhlIG5ldyB3aWR0aFxuICogQHBhcmFtICBoZWlnaHQge051bWJlcn0gdGhlIG5ldyBoZWlnaHRcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGlmICggdGhpcy50ZXh0dXJlIClcbiAgICB7XG4gICAgICAgIHRoaXMudGV4dHVyZS51cGxvYWREYXRhKG51bGwsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICggdGhpcy5zdGVuY2lsIClcbiAgICB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RlbmNpbCBidWZmZXIgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5zdGVuY2lsKTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyBidWZmZXJcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vVE9ET1xuICAgIGlmKHRoaXMudGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG5cbiAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgIHRoaXMuc3RlbmNpbCA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyYW1lIGJ1ZmZlciB3aXRoIGEgdGV4dHVyZSBjb250YWluaW5nIHRoZSBnaXZlbiBkYXRhXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXlCdWZmZXJ8IFNoYXJlZEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gYW4gYXJyYXkgb2YgZGF0YVxuICovXG5GcmFtZWJ1ZmZlci5jcmVhdGVSR0JBID0gZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIGRhdGEpXG57XG4gICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLmZyb21EYXRhKGdsLCBudWxsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0ZXh0dXJlLmVuYWJsZU5lYXJlc3RTY2FsaW5nKCk7XG4gICAgdGV4dHVyZS5lbmFibGVXcmFwQ2xhbXAoKTtcblxuICAgIC8vbm93IGNyZWF0ZSB0aGUgZnJhbWVidWZmZXIgb2JqZWN0IGFuZCBhdHRhY2ggdGhlIHRleHR1cmUgdG8gaXQuXG4gICAgdmFyIGZibyA9IG5ldyBGcmFtZWJ1ZmZlcihnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZmJvLmVuYWJsZVRleHR1cmUodGV4dHVyZSk7XG5cbiAgICAvL2Ziby5lbmFibGVTdGVuY2lsKCk7IC8vIGdldCB0aGlzIGJhY2sgb24gc29vbiFcblxuICAgIGZiby51bmJpbmQoKTtcblxuICAgIHJldHVybiBmYm87XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmcmFtZSBidWZmZXIgd2l0aCBhIHRleHR1cmUgY29udGFpbmluZyB0aGUgZ2l2ZW4gZGF0YVxuICogQHN0YXRpY1xuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICogQHBhcmFtIGRhdGEge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGFuIGFycmF5IG9mIGRhdGFcbiAqL1xuRnJhbWVidWZmZXIuY3JlYXRlRmxvYXQzMiA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBkYXRhKVxue1xuICAgIC8vIGNyZWF0ZSBhIG5ldyB0ZXh0dXJlLi5cbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlLmZyb21EYXRhKGdsLCBkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0ZXh0dXJlLmVuYWJsZU5lYXJlc3RTY2FsaW5nKCk7XG4gICAgdGV4dHVyZS5lbmFibGVXcmFwQ2xhbXAoKTtcblxuICAgIC8vbm93IGNyZWF0ZSB0aGUgZnJhbWVidWZmZXIgb2JqZWN0IGFuZCBhdHRhY2ggdGhlIHRleHR1cmUgdG8gaXQuXG4gICAgdmFyIGZibyA9IG5ldyBGcmFtZWJ1ZmZlcihnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZmJvLmVuYWJsZVRleHR1cmUodGV4dHVyZSk7XG5cbiAgICBmYm8udW5iaW5kKCk7XG5cbiAgICByZXR1cm4gZmJvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZWJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLWdsLWNvcmUvc3JjL0dMRnJhbWVidWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBjb21waWxlUHJvZ3JhbSA9IHJlcXVpcmUoJy4vc2hhZGVyL2NvbXBpbGVQcm9ncmFtJyksXG5cdGV4dHJhY3RBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9zaGFkZXIvZXh0cmFjdEF0dHJpYnV0ZXMnKSxcblx0ZXh0cmFjdFVuaWZvcm1zID0gcmVxdWlyZSgnLi9zaGFkZXIvZXh0cmFjdFVuaWZvcm1zJyksXG5cdHNldFByZWNpc2lvbiA9IHJlcXVpcmUoJy4vc2hhZGVyL3NldFByZWNpc2lvbicpLFxuXHRnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QgPSByZXF1aXJlKCcuL3NoYWRlci9nZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QnKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgd2ViR0wgU2hhZGVyXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBmcmFnbWVudFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIHByZWNpc2lvbiB7cHJlY2lzaW9uXX0gVGhlIGZsb2F0IHByZWNpc2lvbiBvZiB0aGUgc2hhZGVyLiBPcHRpb25zIGFyZSAnbG93cCcsICdtZWRpdW1wJyBvciAnaGlnaHAnLlxuICogQHBhcmFtIGF0dHJpYnV0ZUxvY2F0aW9ucyB7b2JqZWN0fSBBIGtleSB2YWx1ZSBwYWlyIHNob3dpbmcgd2hpY2ggbG9jYXRpb24gZWFjdCBhdHRyaWJ1dGUgc2hvdWxkIHNpdCBlZyB7cG9zaXRpb246MCwgdXZzOjF9XG4gKi9cbnZhciBTaGFkZXIgPSBmdW5jdGlvbihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgcHJlY2lzaW9uLCBhdHRyaWJ1dGVMb2NhdGlvbnMpXG57XG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKlxuXHQgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG5cdCAqL1xuXHR0aGlzLmdsID0gZ2w7XG5cblx0aWYocHJlY2lzaW9uKVxuXHR7XG5cdFx0dmVydGV4U3JjID0gc2V0UHJlY2lzaW9uKHZlcnRleFNyYywgcHJlY2lzaW9uKTtcblx0XHRmcmFnbWVudFNyYyA9IHNldFByZWNpc2lvbihmcmFnbWVudFNyYywgcHJlY2lzaW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgc2hhZGVyIHByb2dyYW1cblx0ICpcblx0ICogQG1lbWJlciB7V2ViR0xQcm9ncmFtfVxuXHQgKi9cblx0Ly8gRmlyc3QgY29tcGlsZSB0aGUgcHJvZ3JhbS4uXG5cdHRoaXMucHJvZ3JhbSA9IGNvbXBpbGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJ1dGVMb2NhdGlvbnMpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYXR0cmlidXRlcyBvZiB0aGUgc2hhZGVyIGFzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuXHQgKiB7XG5cdCAqIFx0dHlwZSxcblx0ICogXHRzaXplLFxuXHQgKiBcdGxvY2F0aW9uLFxuXHQgKiBcdHBvaW50ZXJcblx0ICogfVxuXHQgKiBAbWVtYmVyIHtPYmplY3R9XG5cdCAqL1xuXHQvLyBuZXh0IGV4dHJhY3QgdGhlIGF0dHJpYnV0ZXNcblx0dGhpcy5hdHRyaWJ1dGVzID0gZXh0cmFjdEF0dHJpYnV0ZXMoZ2wsIHRoaXMucHJvZ3JhbSk7XG5cbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gZXh0cmFjdFVuaWZvcm1zKGdsLCB0aGlzLnByb2dyYW0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgdW5pZm9ybXMgb2YgdGhlIHNoYWRlciBhcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcblx0ICoge1xuXHQgKiBcdGdsLFxuXHQgKiBcdGRhdGFcblx0ICogfVxuXHQgKiBAbWVtYmVyIHtPYmplY3R9XG5cdCAqL1xuXHR0aGlzLnVuaWZvcm1zID0gZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0KCBnbCwgdGhpcy51bmlmb3JtRGF0YSApO1xuXG59O1xuLyoqXG4gKiBVc2VzIHRoaXMgc2hhZGVyXG4gKi9cblNoYWRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgc2hhZGVyXG4gKiBUT0RPXG4gKi9cblNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcblx0dGhpcy51bmlmb3JtRGF0YSA9IG51bGw7XG5cdHRoaXMudW5pZm9ybXMgPSBudWxsO1xuXG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS1nbC1jb3JlL3NyYy9HTFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gc3RhdGUgb2JqZWN0Ly9cbnZhciBzZXRWZXJ0ZXhBdHRyaWJBcnJheXMgPSByZXF1aXJlKCAnLi9zZXRWZXJ0ZXhBdHRyaWJBcnJheXMnICk7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIHdvcmsgd2l0aCBXZWJHTCBWZXJ0ZXhBcnJheU9iamVjdHMgKHZhb3MpXG4gKiBPbmx5IHdvcmtzIGlmIFdlYkdMIGV4dGVuc2lvbnMgYXJlIGVuYWJsZWQgKHRoZXkgdXN1YWxseSBhcmUpXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICovXG5mdW5jdGlvbiBWZXJ0ZXhBcnJheU9iamVjdChnbCwgc3RhdGUpXG57XG4gICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24gPSBudWxsO1xuXG4gICAgaWYoIVZlcnRleEFycmF5T2JqZWN0LkZPUkNFX05BVElWRSlcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdNT1pfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCS0lUX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVTdGF0ZSA9IHN0YXRlO1xuXG4gICAgaWYodGhpcy5uYXRpdmVWYW9FeHRlbnNpb24pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhbyA9IHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7XG5cbiAgICAgICAgdmFyIG1heEF0dHJpYnMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTKTtcblxuICAgICAgICAvLyBWQU8gLSBvdmVyd3JpdGUgdGhlIHN0YXRlLi5cbiAgICAgICAgdGhpcy5uYXRpdmVTdGF0ZSA9IHtcbiAgICAgICAgICAgIHRlbXBBdHRyaWJTdGF0ZTogbmV3IEFycmF5KG1heEF0dHJpYnMpLFxuICAgICAgICAgICAgYXR0cmliU3RhdGU6IG5ldyBBcnJheShtYXhBdHRyaWJzKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtQSVhJLmdsQ29yZS5HTEJ1ZmZlcn1cbiAgICAgKi9cbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgYm9vbGVhbiBmbGFnXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbn1cblxuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmVydGV4QXJyYXlPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEFycmF5T2JqZWN0O1xuXG4vKipcbiogU29tZSBkZXZpY2VzIGJlaGF2ZSBhIGJpdCBmdW5ueSB3aGVuIHVzaW5nIHRoZSBuZXdlciBleHRlbnNpb25zIChpbSBsb29raW5nIGF0IHlvdSBpcGFkIDIhKVxuKiBJZiB5b3UgZmluZCBvbiBvbGRlciBkZXZpY2VzIHRoYXQgdGhpbmdzIGhhdmUgZ29uZSBhIGJpdCB3ZWlyZCB0aGVuIHNldCB0aGlzIHRvIHRydWUuXG4qL1xuLyoqXG4gKiBMZXRzIHRoZSBWQU8ga25vdyBpZiB5b3Ugc2hvdWxkIHVzZSB0aGUgV2ViR0wgZXh0ZW5zaW9uIG9yIHRoZSBuYXRpdmUgbWV0aG9kcy5cbiAqIFNvbWUgZGV2aWNlcyBiZWhhdmUgYSBiaXQgZnVubnkgd2hlbiB1c2luZyB0aGUgbmV3ZXIgZXh0ZW5zaW9ucyAoaW0gbG9va2luZyBhdCB5b3UgaXBhZCAyISlcbiAqIElmIHlvdSBmaW5kIG9uIG9sZGVyIGRldmljZXMgdGhhdCB0aGluZ3MgaGF2ZSBnb25lIGEgYml0IHdlaXJkIHRoZW4gc2V0IHRoaXMgdG8gdHJ1ZS5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gRk9SQ0VfTkFUSVZFXG4gKi9cblZlcnRleEFycmF5T2JqZWN0LkZPUkNFX05BVElWRSA9IGZhbHNlO1xuXG4vKipcbiAqIEJpbmRzIHRoZSBidWZmZXJcbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5uYXRpdmVWYW8pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModGhpcy5uYXRpdmVWYW8pO1xuXG4gICAgICAgIGlmKHRoaXMuZGlydHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGUgYnVmZmVyXG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5uYXRpdmVWYW8pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVzZXMgdGhpcyB2YW9cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKVxue1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgbGFzdEJ1ZmZlciA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWIgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG5cbiAgICAgICAgaWYobGFzdEJ1ZmZlciAhPT0gYXR0cmliLmJ1ZmZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgYXR0cmliLmJ1ZmZlci5iaW5kKCk7XG4gICAgICAgICAgICBsYXN0QnVmZmVyID0gYXR0cmliLmJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmliLmF0dHJpYnV0ZS5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWIuYXR0cmlidXRlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLnR5cGUgfHwgZ2wuRkxPQVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLm5vcm1hbGl6ZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLnN0cmlkZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYi5zdGFydCB8fCAwKTtcbiAgICB9XG5cbiAgICBzZXRWZXJ0ZXhBdHRyaWJBcnJheXMoZ2wsIHRoaXMuYXR0cmlidXRlcywgdGhpcy5uYXRpdmVTdGF0ZSk7XG5cbiAgICBpZih0aGlzLmluZGV4QnVmZmVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5iaW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyICAgICB7UElYSS5nbC5HTEJ1ZmZlcn1cbiAqIEBwYXJhbSBhdHRyaWJ1dGUgIHsqfVxuICogQHBhcmFtIHR5cGUgICAgICAge1N0cmluZ31cbiAqIEBwYXJhbSBub3JtYWxpemVkIHtCb29sZWFufVxuICogQHBhcmFtIHN0cmlkZSAgICAge051bWJlcn1cbiAqIEBwYXJhbSBzdGFydCAgICAgIHtOdW1iZXJ9XG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbihidWZmZXIsIGF0dHJpYnV0ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBzdGFydClcbntcbiAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgIGJ1ZmZlcjogICAgIGJ1ZmZlcixcbiAgICAgICAgYXR0cmlidXRlOiAgYXR0cmlidXRlLFxuXG4gICAgICAgIGxvY2F0aW9uOiAgIGF0dHJpYnV0ZS5sb2NhdGlvbixcbiAgICAgICAgdHlwZTogICAgICAgdHlwZSB8fCB0aGlzLmdsLkZMT0FULFxuICAgICAgICBub3JtYWxpemVkOiBub3JtYWxpemVkIHx8IGZhbHNlLFxuICAgICAgICBzdHJpZGU6ICAgICBzdHJpZGUgfHwgMCxcbiAgICAgICAgc3RhcnQ6ICAgICAgc3RhcnQgfHwgMFxuICAgIH0pO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBidWZmZXIgICB7UElYSS5nbC5HTEJ1ZmZlcn1cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmFkZEluZGV4ID0gZnVuY3Rpb24oYnVmZmVyLyosIG9wdGlvbnMqLylcbntcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gYnVmZmVyO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGlzIHZhbyBhbmQgZGlzYWJsZXMgaXRcbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyBUT0RPIC0gc2hvdWxkIHRoaXMgZnVuY3Rpb24gdW5iaW5kIGFmdGVyIGNsZWFyP1xuICAgIC8vIGZvciBub3csIG5vIGJ1dCBsZXRzIHNlZSB3aGF0IGhhcHBlbnMgaW4gdGhlIHJlYWwgd29ybGQhXG4gICAgaWYodGhpcy5uYXRpdmVWYW8pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModGhpcy5uYXRpdmVWYW8pO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB0eXBlICB7TnVtYmVyfVxuICogQHBhcmFtIHNpemUgIHtOdW1iZXJ9XG4gKiBAcGFyYW0gc3RhcnQge051bWJlcn1cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbih0eXBlLCBzaXplLCBzdGFydClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgaWYodGhpcy5pbmRleEJ1ZmZlcilcbiAgICB7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IHRoaXMuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAoc3RhcnQgfHwgMCkgKiAyICk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIFRPRE8gbmVlZCBhIGJldHRlciB3YXkgdG8gY2FsY3VsYXRlIHNpemUuLlxuICAgICAgICBnbC5kcmF3QXJyYXlzKHR5cGUsIHN0YXJ0LCBzaXplIHx8IHRoaXMuZ2V0U2l6ZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGlzIHZhb1xuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICAvLyBsb3NlIHJlZmVyZW5jZXNcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlU3RhdGUgPSBudWxsO1xuXG4gICAgaWYodGhpcy5uYXRpdmVWYW8pXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh0aGlzLm5hdGl2ZVZhbyk7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24gPSBudWxsO1xuICAgIHRoaXMubmF0aXZlVmFvID0gbnVsbDtcbn07XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBhdHRyaWIgPSB0aGlzLmF0dHJpYnV0ZXNbMF07XG4gICAgcmV0dXJuIGF0dHJpYi5idWZmZXIuZGF0YS5sZW5ndGggLyAoKCBhdHRyaWIuc3RyaWRlLzQgKSB8fCBhdHRyaWIuYXR0cmlidXRlLnNpemUpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLWdsLWNvcmUvc3JjL1ZlcnRleEFycmF5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSB3ZWJHTCBDb250ZXh0XG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGdldCB0aGUgY29udGV4dCBmcm9tXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IGdldHMgcGFzc2VkIGluIHRvIHRoZSBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250ZXh0IGF0dHJpYnV0ZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L2dldENvbnRleHQgZm9yIHRoZSBvcHRpb25zIGF2YWlsYWJsZVxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxuICovXG52YXIgY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcywgb3B0aW9ucylcbntcbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fCBcbiAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcblxuICAgIGlmICghZ2wpXG4gICAge1xuICAgICAgICAvLyBmYWlsLCBub3QgYWJsZSB0byBnZXQgYSBjb250ZXh0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd2ViR0wuIFRyeSB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDb250ZXh0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGktZ2wtY29yZS9zcmMvY3JlYXRlQ29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbXBpbGVQcm9ncmFtOiByZXF1aXJlKCcuL2NvbXBpbGVQcm9ncmFtJyksXG4gICAgZGVmYXVsdFZhbHVlOiByZXF1aXJlKCcuL2RlZmF1bHRWYWx1ZScpLFxuICAgIGV4dHJhY3RBdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2V4dHJhY3RBdHRyaWJ1dGVzJyksXG4gICAgZXh0cmFjdFVuaWZvcm1zOiByZXF1aXJlKCcuL2V4dHJhY3RVbmlmb3JtcycpLFxuICAgIGdlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdDogcmVxdWlyZSgnLi9nZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QnKSxcbiAgICBzZXRQcmVjaXNpb246IHJlcXVpcmUoJy4vc2V0UHJlY2lzaW9uJyksXG4gICAgbWFwU2l6ZTogcmVxdWlyZSgnLi9tYXBTaXplJyksXG4gICAgbWFwVHlwZTogcmVxdWlyZSgnLi9tYXBUeXBlJylcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2F1dG9EZXRlY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4vYXV0b0RldGVjdFJlbmRlcmVyJyk7XG5cbnZhciBfQ29udGFpbmVyID0gcmVxdWlyZSgnLi9kaXNwbGF5L0NvbnRhaW5lcicpO1xuXG52YXIgX0NvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250YWluZXIpO1xuXG52YXIgX3RpY2tlciA9IHJlcXVpcmUoJy4vdGlja2VyJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gY3JlYXRlIGEgbmV3IFBJWEkgYXBwbGljYXRpb24uXG4gKiBUaGlzIGNsYXNzIGF1dG9tYXRpY2FsbHkgY3JlYXRlcyB0aGUgcmVuZGVyZXIsIHRpY2tlclxuICogYW5kIHJvb3QgY29udGFpbmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgdGhlIGFwcGxpY2F0aW9uXG4gKiBjb25zdCBhcHAgPSBuZXcgUElYSS5BcHBsaWNhdGlvbigpO1xuICpcbiAqIC8vIEFkZCB0aGUgdmlldyB0byB0aGUgRE9NXG4gKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFwcC52aWV3KTtcbiAqXG4gKiAvLyBleCwgYWRkIGRpc3BsYXkgb2JqZWN0c1xuICogYXBwLnN0YWdlLmFkZENoaWxkKFBJWEkuU3ByaXRlLmZyb21JbWFnZSgnc29tZXRoaW5nLnBuZycpKTtcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9ODAwXSAtIHRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9NjAwXSAtIHRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlcmVycyB2aWV3XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9uYWwgcmVuZGVyZXIgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBbb3B0aW9ucy52aWV3XSAtIHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFuc3BhcmVudD1mYWxzZV0gLSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbnRpYWxpYXM9ZmFsc2VdIC0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdIC0gZW5hYmxlcyBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb24sIGVuYWJsZSB0aGlzIGlmIHlvdVxuICAgKiAgICAgIG5lZWQgdG8gY2FsbCB0b0RhdGFVcmwgb24gdGhlIHdlYmdsIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIsIHJldGluYSB3b3VsZCBiZSAyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vV2ViR0w9ZmFsc2VdIC0gcHJldmVudHMgc2VsZWN0aW9uIG9mIFdlYkdMIHJlbmRlcmVyLCBldmVuIGlmIHN1Y2ggaXMgcHJlc2VudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlZ2FjeT1mYWxzZV0gLSBJZiB0cnVlIFBpeGkgd2lsbCBhaW0gdG8gZW5zdXJlIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBvbGRlciAvIGxlc3MgYWR2YW5jZWQgZGV2aWNlcy4gSWYgeW91IGV4cGVyaWVuY2UgdW5leHBsYWluZWQgZmxpY2tlcmluZyB0cnkgc2V0dGluZyB0aGlzIHRvIHRydWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVNoYXJlZFRpY2tlcj1mYWxzZV0gLSBgdHJ1ZWAgdG8gdXNlIFBJWEkudGlja2VyLnNoYXJlZCwgYGZhbHNlYCB0byBjcmVhdGUgbmV3IHRpY2tlci5cbiAgICovXG4gIGZ1bmN0aW9uIEFwcGxpY2F0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMsIG5vV2ViR0wpIHtcbiAgICB2YXIgdXNlU2hhcmVkVGlja2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcHBsaWNhdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBXZWJHTCByZW5kZXJlciBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBDYW52YXNSZW5kZXJlclxuICAgICAqIEBtZW1iZXIge1BJWEkuV2ViR0xSZW5kZXJlcnxQSVhJLkNhbnZhc1JlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSAoMCwgX2F1dG9EZXRlY3RSZW5kZXJlci5hdXRvRGV0ZWN0UmVuZGVyZXIpKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMsIG5vV2ViR0wpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgZGlzcGxheSBjb250YWluZXIgdGhhdCdzIHJlbmRlcmVkLlxuICAgICAqIEBtZW1iZXIge1BJWEkuQ29udGFpbmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RhZ2UgPSBuZXcgX0NvbnRhaW5lcjIuZGVmYXVsdCgpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSB0aWNrZXJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLnRpY2tlci5UaWNrZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90aWNrZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGlja2VyIGZvciBkb2luZyByZW5kZXIgdXBkYXRlcy5cbiAgICAgKiBAbWVtYmVyIHtQSVhJLnRpY2tlci5UaWNrZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS50aWNrZXIuc2hhcmVkXG4gICAgICovXG4gICAgdGhpcy50aWNrZXIgPSB1c2VTaGFyZWRUaWNrZXIgPyBfdGlja2VyLnNoYXJlZCA6IG5ldyBfdGlja2VyLlRpY2tlcigpO1xuXG4gICAgLy8gU3RhcnQgdGhlIHJlbmRlcmluZ1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGN1cnJlbnQgc3RhZ2UuXG4gICAqL1xuICBBcHBsaWNhdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc3RhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHN0b3BwaW5nIHRoZSByZW5kZXIuXG4gICAqL1xuXG5cbiAgQXBwbGljYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHRoaXMuX3RpY2tlci5zdG9wKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc3RhcnRpbmcgdGhlIHJlbmRlci5cbiAgICovXG5cblxuICBBcHBsaWNhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICB0aGlzLl90aWNrZXIuc3RhcnQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlcidzIGNhbnZhcyBlbGVtZW50LlxuICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZW1vdmVWaWV3PWZhbHNlXSBBdXRvbWF0aWNhbGx5IHJlbW92ZSBjYW52YXMgZnJvbSBET00uXG4gICAqL1xuICBBcHBsaWNhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kocmVtb3ZlVmlldykge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMudGlja2VyID0gbnVsbDtcblxuICAgIHRoaXMuc3RhZ2UuZGVzdHJveSgpO1xuICAgIHRoaXMuc3RhZ2UgPSBudWxsO1xuXG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KHJlbW92ZVZpZXcpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBcHBsaWNhdGlvbiwgW3tcbiAgICBrZXk6ICd0aWNrZXInLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHRpY2tlcikgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAge1xuICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgdGlja2VyLmFkZCh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIHtcbiAgICAgIHJldHVybiB0aGlzLl90aWNrZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmlldycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci52aWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIncyBzY3JlZW4gcmVjdGFuZ2xlLiBJdHMgc2FmZSB0byB1c2UgYXMgZmlsdGVyQXJlYSBvciBoaXRBcmVhIGZvciB3aG9sZSBzY3JlZW5cbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2NyZWVuJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnNjcmVlbjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXBwbGljYXRpb247XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFwcGxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvQXBwbGljYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfQ29udGFpbmVyMiA9IHJlcXVpcmUoJy4uL2Rpc3BsYXkvQ29udGFpbmVyJyk7XG5cbnZhciBfQ29udGFpbmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnRhaW5lcjIpO1xuXG52YXIgX1JlbmRlclRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9SZW5kZXJUZXh0dXJlJyk7XG5cbnZhciBfUmVuZGVyVGV4dHVyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZW5kZXJUZXh0dXJlKTtcblxudmFyIF9UZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvVGV4dHVyZScpO1xuXG52YXIgX1RleHR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZSk7XG5cbnZhciBfR3JhcGhpY3NEYXRhID0gcmVxdWlyZSgnLi9HcmFwaGljc0RhdGEnKTtcblxudmFyIF9HcmFwaGljc0RhdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR3JhcGhpY3NEYXRhKTtcblxudmFyIF9TcHJpdGUgPSByZXF1aXJlKCcuLi9zcHJpdGVzL1Nwcml0ZScpO1xuXG52YXIgX1Nwcml0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcHJpdGUpO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi9tYXRoJyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIF9Cb3VuZHMgPSByZXF1aXJlKCcuLi9kaXNwbGF5L0JvdW5kcycpO1xuXG52YXIgX0JvdW5kczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Cb3VuZHMpO1xuXG52YXIgX2JlemllckN1cnZlVG8yID0gcmVxdWlyZSgnLi91dGlscy9iZXppZXJDdXJ2ZVRvJyk7XG5cbnZhciBfYmV6aWVyQ3VydmVUbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iZXppZXJDdXJ2ZVRvMik7XG5cbnZhciBfQ2FudmFzUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyk7XG5cbnZhciBfQ2FudmFzUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzUmVuZGVyZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjYW52YXNSZW5kZXJlciA9IHZvaWQgMDtcbnZhciB0ZW1wTWF0cml4ID0gbmV3IF9tYXRoLk1hdHJpeCgpO1xudmFyIHRlbXBQb2ludCA9IG5ldyBfbWF0aC5Qb2ludCgpO1xudmFyIHRlbXBDb2xvcjEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xudmFyIHRlbXBDb2xvcjIgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4vKipcbiAqIFRoZSBHcmFwaGljcyBjbGFzcyBjb250YWlucyBtZXRob2RzIHVzZWQgdG8gZHJhdyBwcmltaXRpdmUgc2hhcGVzIHN1Y2ggYXMgbGluZXMsIGNpcmNsZXMgYW5kXG4gKiByZWN0YW5nbGVzIHRvIHRoZSBkaXNwbGF5LCBhbmQgdG8gY29sb3IgYW5kIGZpbGwgdGhlbS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQ29udGFpbmVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5cbnZhciBHcmFwaGljcyA9IGZ1bmN0aW9uIChfQ29udGFpbmVyKSB7XG4gICAgX2luaGVyaXRzKEdyYXBoaWNzLCBfQ29udGFpbmVyKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbmF0aXZlTGluZXM9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgbGluZXMgd2lsbCBiZSBkcmF3IHVzaW5nIExJTkVTIGluc3RlYWQgb2YgVFJJQU5HTEVfU1RSSVBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHcmFwaGljcygpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUxpbmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhpY3MpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWxwaGEgdmFsdWUgdXNlZCB3aGVuIGZpbGxpbmcgdGhlIEdyYXBoaWNzIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29udGFpbmVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLmZpbGxBbHBoYSA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCAodGhpY2tuZXNzKSBvZiBhbnkgbGluZXMgZHJhd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGluZVdpZHRoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSB0aGUgbGluZXMgd2lsbCBiZSBkcmF3IHVzaW5nIExJTkVTIGluc3RlYWQgb2YgVFJJQU5HTEVfU1RSSVBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm5hdGl2ZUxpbmVzID0gbmF0aXZlTGluZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciBvZiBhbnkgbGluZXMgZHJhd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGluZUNvbG9yID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhpY3MgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzRGF0YVtdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEFwcGx5IGEgdmFsdWUgb2YgMHhGRkZGRkYgdG9cbiAgICAgICAgICogcmVzZXQgdGhlIHRpbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRpbnQgPSAweEZGRkZGRjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByZXZpb3VzIHRpbnQgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZS4gVXNlZCB0byBjb21wYXJlIHRvIHRoZSBjdXJyZW50IHRpbnQgYW5kXG4gICAgICAgICAqIGNoZWNrIGlmIHRoZXJlcyBjaGFuZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9wcmV2VGludCA9IDB4RkZGRkZGO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBBcHBseSBhIHZhbHVlIG9mXG4gICAgICAgICAqIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYmxlbmRNb2RlID0gX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBwYXRoXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NEYXRhfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY3VycmVudFBhdGggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcnJheSBjb250YWluaW5nIHNvbWUgV2ViR0wtcmVsYXRlZCBwcm9wZXJ0aWVzIHVzZWQgYnkgdGhlIFdlYkdMIHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBvYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyAtIF93ZWJnbCBzaG91bGQgdXNlIGEgcHJvdG90eXBlIG9iamVjdCwgbm90IGEgcmFuZG9tIHVuZG9jdW1lbnRlZCBvYmplY3QuLi5cbiAgICAgICAgX3RoaXMuX3dlYkdMID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBzaGFwZSBpcyBiZWluZyB1c2VkIGFzIGEgbWFzay5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlzTWFzayA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYm91bmRzJyBwYWRkaW5nIHVzZWQgZm9yIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYm91bmRzUGFkZGluZyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FjaGUgb2YgdGhlIGxvY2FsIGJvdW5kcyB0byBwcmV2ZW50IHJlY2FsY3VsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2xvY2FsQm91bmRzID0gbmV3IF9Cb3VuZHMyLmRlZmF1bHQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBoYXMgY2hhbmdlZC4gSWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSB0aGVuIHRoZSBncmFwaGljc1xuICAgICAgICAgKiBvYmplY3Qgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kaXJ0eSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlIG5lZWQgdG8gZG8gYSBmYXN0IHJlY3QgY2hlY2sgdXNpbmcgdGhlIGlkIGNvbXBhcmUgbWV0aG9kXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5mYXN0UmVjdERpcnR5ID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlIGNsZWFyIHRoZSBncmFwaGljcyB3ZWJHTCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jbGVhckRpcnR5ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBkZXRlY3QgaWYgd2Ugd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBsb2NhbCBib3VuZHNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJvdW5kc0RpcnR5ID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBjYWNoZWQgc3ByaXRlIG9iamVjdCBuZWVkcyB0byBiZSB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2FjaGVkU3ByaXRlRGlydHkgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5fc3ByaXRlUmVjdCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9mYXN0UmVjdCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGNhY2hlQXNCaXRtYXAgaXMgc2V0IHRvIHRydWUgdGhlIGdyYXBoaWNzIG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIGl0IHdhcyBhIHNwcml0ZS5cbiAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91ciBncmFwaGljcyBlbGVtZW50IGRvZXMgbm90IGNoYW5nZSBvZnRlbiwgYXMgaXQgd2lsbCBzcGVlZCB1cCB0aGUgcmVuZGVyaW5nXG4gICAgICAgICAqIG9mIHRoZSBvYmplY3QgaW4gZXhjaGFuZ2UgZm9yIHRha2luZyB1cCB0ZXh0dXJlIG1lbW9yeS4gSXQgaXMgYWxzbyB1c2VmdWwgaWYgeW91IG5lZWQgdGhlIGdyYXBoaWNzXG4gICAgICAgICAqIG9iamVjdCB0byBiZSBhbnRpLWFsaWFzZWQsIGJlY2F1c2UgaXQgd2lsbCBiZSByZW5kZXJlZCB1c2luZyBjYW52YXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkIGlmXG4gICAgICAgICAqIHlvdSBhcmUgY29uc3RhbnRseSByZWRyYXdpbmcgdGhlIGdyYXBoaWNzIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGNhY2hlQXNCaXRtYXBcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuR3JhcGhpY3MjXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljcyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IEEgY2xvbmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdFxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gbmV3IEdyYXBoaWNzKCk7XG5cbiAgICAgICAgY2xvbmUucmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICAgICAgY2xvbmUuZmlsbEFscGhhID0gdGhpcy5maWxsQWxwaGE7XG4gICAgICAgIGNsb25lLmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgICBjbG9uZS5saW5lQ29sb3IgPSB0aGlzLmxpbmVDb2xvcjtcbiAgICAgICAgY2xvbmUudGludCA9IHRoaXMudGludDtcbiAgICAgICAgY2xvbmUuYmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XG4gICAgICAgIGNsb25lLmlzTWFzayA9IHRoaXMuaXNNYXNrO1xuICAgICAgICBjbG9uZS5ib3VuZHNQYWRkaW5nID0gdGhpcy5ib3VuZHNQYWRkaW5nO1xuICAgICAgICBjbG9uZS5kaXJ0eSA9IDA7XG4gICAgICAgIGNsb25lLmNhY2hlZFNwcml0ZURpcnR5ID0gdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eTtcblxuICAgICAgICAvLyBjb3B5IGdyYXBoaWNzIGRhdGFcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2xvbmUuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5ncmFwaGljc0RhdGFbaV0uY2xvbmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZS5jdXJyZW50UGF0aCA9IGNsb25lLmdyYXBoaWNzRGF0YVtjbG9uZS5ncmFwaGljc0RhdGEubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgY2xvbmUudXBkYXRlTG9jYWxCb3VuZHMoKTtcblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbGluZSBzdHlsZSB1c2VkIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIEdyYXBoaWNzIG1ldGhvZHMgc3VjaCBhcyB0aGUgbGluZVRvKClcbiAgICAgKiBtZXRob2Qgb3IgdGhlIGRyYXdDaXJjbGUoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbmVXaWR0aD0wXSAtIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUubGluZVN0eWxlID0gZnVuY3Rpb24gbGluZVN0eWxlKCkge1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgY29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgIHZhciBhbHBoYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcblxuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5saW5lQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5saW5lQWxwaGEgPSBhbHBoYTtcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGhhbGZ3YXkgdGhyb3VnaCBhIGxpbmU/IHN0YXJ0IGEgbmV3IG9uZSFcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgX21hdGguUG9seWdvbih0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5zbGljZSgtMikpO1xuXG4gICAgICAgICAgICAgICAgc2hhcGUuY2xvc2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpdHMgZW1wdHkgc28gbGV0cyBqdXN0IHNldCB0aGUgbGluZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVDb2xvciA9IHRoaXMubGluZUNvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgubGluZUFscGhhID0gdGhpcy5saW5lQWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byB4LCB5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgWCBjb29yZGluYXRlIHRvIG1vdmUgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uIG1vdmVUbyh4LCB5KSB7XG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBfbWF0aC5Qb2x5Z29uKFt4LCB5XSk7XG5cbiAgICAgICAgc2hhcGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKHNoYXBlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBsaW5lIHVzaW5nIHRoZSBjdXJyZW50IGxpbmUgc3R5bGUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvICh4LCB5KTtcbiAgICAgKiBUaGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIGlzIHRoZW4gc2V0IHRvICh4LCB5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZSB0byBkcmF3IHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiBsaW5lVG8oeCwgeSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHgsIHkpO1xuICAgICAgICB0aGlzLmRpcnR5Kys7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAgICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uIHF1YWRyYXRpY0N1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMgPSBbMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gMjA7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcbiAgICAgICAgdmFyIHhhID0gMDtcbiAgICAgICAgdmFyIHlhID0gMDtcblxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSBpIC8gbjtcblxuICAgICAgICAgICAgeGEgPSBmcm9tWCArIChjcFggLSBmcm9tWCkgKiBqO1xuICAgICAgICAgICAgeWEgPSBmcm9tWSArIChjcFkgLSBmcm9tWSkgKiBqO1xuXG4gICAgICAgICAgICBwb2ludHMucHVzaCh4YSArIChjcFggKyAodG9YIC0gY3BYKSAqIGogLSB4YSkgKiBqLCB5YSArIChjcFkgKyAodG9ZIC0gY3BZKSAqIGogLSB5YSkgKiBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIGJlemllckN1cnZlVG8oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMgPSBbMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcblxuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHBvaW50cy5sZW5ndGggLT0gMjtcblxuICAgICAgICAoMCwgX2JlemllckN1cnZlVG8zLmRlZmF1bHQpKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZLCBwb2ludHMpO1xuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFyY1RvKCkgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlIGJldHdlZW4gdHdvIHRhbmdlbnRzIG9uIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBcImJvcnJvd2VkXCIgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Z4Y2FudmFzLyAtIHRoYW5rcyBnb29nbGUhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBhcmNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTIgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBhcmNcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5hcmNUbyA9IGZ1bmN0aW9uIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHgxLCB5MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgYTEgPSBmcm9tWSAtIHkxO1xuICAgICAgICB2YXIgYjEgPSBmcm9tWCAtIHgxO1xuICAgICAgICB2YXIgYTIgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgYjIgPSB4MiAtIHgxO1xuICAgICAgICB2YXIgbW0gPSBNYXRoLmFicyhhMSAqIGIyIC0gYjEgKiBhMik7XG5cbiAgICAgICAgaWYgKG1tIDwgMS4wZS04IHx8IHJhZGl1cyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gIT09IHgxIHx8IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gIT09IHkxKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goeDEsIHkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZCA9IGExICogYTEgKyBiMSAqIGIxO1xuICAgICAgICAgICAgdmFyIGNjID0gYTIgKiBhMiArIGIyICogYjI7XG4gICAgICAgICAgICB2YXIgdHQgPSBhMSAqIGEyICsgYjEgKiBiMjtcbiAgICAgICAgICAgIHZhciBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgICAgICAgICAgIHZhciBrMiA9IHJhZGl1cyAqIE1hdGguc3FydChjYykgLyBtbTtcbiAgICAgICAgICAgIHZhciBqMSA9IGsxICogdHQgLyBkZDtcbiAgICAgICAgICAgIHZhciBqMiA9IGsyICogdHQgLyBjYztcbiAgICAgICAgICAgIHZhciBjeCA9IGsxICogYjIgKyBrMiAqIGIxO1xuICAgICAgICAgICAgdmFyIGN5ID0gazEgKiBhMiArIGsyICogYTE7XG4gICAgICAgICAgICB2YXIgcHggPSBiMSAqIChrMiArIGoxKTtcbiAgICAgICAgICAgIHZhciBweSA9IGExICogKGsyICsgajEpO1xuICAgICAgICAgICAgdmFyIHF4ID0gYjIgKiAoazEgKyBqMik7XG4gICAgICAgICAgICB2YXIgcXkgPSBhMiAqIChrMSArIGoyKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMihweSAtIGN5LCBweCAtIGN4KTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXJjKGN4ICsgeDEsIGN5ICsgeTEsIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGIxICogYTIgPiBiMiAqIGExKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFyYyBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgKHVzZWQgdG8gY3JlYXRlIGNpcmNsZXMsIG9yIHBhcnRzIG9mIGNpcmNsZXMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3kgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucyAoMCBpcyBhdCB0aGUgMyBvJ2Nsb2NrIHBvc2l0aW9uXG4gICAgICogIG9mIHRoZSBhcmMncyBjaXJjbGUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FudGljbG9ja3dpc2U9ZmFsc2VdIC0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRyYXdpbmcgc2hvdWxkIGJlXG4gICAgICogIGNvdW50ZXItY2xvY2t3aXNlIG9yIGNsb2Nrd2lzZS4gRmFsc2UgaXMgZGVmYXVsdCwgYW5kIGluZGljYXRlcyBjbG9ja3dpc2UsIHdoaWxlIHRydWVcbiAgICAgKiAgaW5kaWNhdGVzIGNvdW50ZXItY2xvY2t3aXNlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uIGFyYyhjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID09PSBlbmRBbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFudGljbG9ja3dpc2UgJiYgZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoYW50aWNsb2Nrd2lzZSAmJiBzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN3ZWVwID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB2YXIgc2VncyA9IE1hdGguY2VpbChNYXRoLmFicyhzd2VlcCkgLyAoTWF0aC5QSSAqIDIpKSAqIDQwO1xuXG4gICAgICAgIGlmIChzd2VlcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICAgICAgdmFyIHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnRQYXRoIGV4aXN0cywgdGFrZSBpdHMgcG9pbnRzLiBPdGhlcndpc2UgY2FsbCBgbW92ZVRvYCB0byBzdGFydCBhIHBhdGguXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoID8gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMgOiBudWxsO1xuXG4gICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgIGlmIChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdICE9PSBzdGFydFggfHwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAhPT0gc3RhcnRZKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhldGEgPSBzd2VlcCAvIChzZWdzICogMik7XG4gICAgICAgIHZhciB0aGV0YTIgPSB0aGV0YSAqIDI7XG5cbiAgICAgICAgdmFyIGNUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgdmFyIHNUaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcblxuICAgICAgICB2YXIgc2VnTWludXMgPSBzZWdzIC0gMTtcblxuICAgICAgICB2YXIgcmVtYWluZGVyID0gc2VnTWludXMgJSAxIC8gc2VnTWludXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2VnTWludXM7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlYWwgPSBpICsgcmVtYWluZGVyICogaTtcblxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhldGEgKyBzdGFydEFuZ2xlICsgdGhldGEyICogcmVhbDtcblxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICB2YXIgcyA9IC1NYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKChjVGhldGEgKiBjICsgc1RoZXRhICogcykgKiByYWRpdXMgKyBjeCwgKGNUaGV0YSAqIC1zICsgc1RoZXRhICogYykgKiByYWRpdXMgKyBjeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5Kys7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhIHNpbXBsZSBvbmUtY29sb3IgZmlsbCB0aGF0IHN1YnNlcXVlbnQgY2FsbHMgdG8gb3RoZXIgR3JhcGhpY3MgbWV0aG9kc1xuICAgICAqIChzdWNoIGFzIGxpbmVUbygpIG9yIGRyYXdDaXJjbGUoKSkgdXNlIHdoZW4gZHJhd2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuYmVnaW5GaWxsID0gZnVuY3Rpb24gYmVnaW5GaWxsKCkge1xuICAgICAgICB2YXIgY29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciBhbHBoYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcblxuICAgICAgICB0aGlzLmZpbGxpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLmZpbGxBbHBoYSA9IGFscGhhO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmZpbGwgPSB0aGlzLmZpbGxpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5maWxsQ29sb3IgPSB0aGlzLmZpbGxDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmZpbGxBbHBoYSA9IHRoaXMuZmlsbEFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmaWxsIHRvIHRoZSBsaW5lcyBhbmQgc2hhcGVzIHRoYXQgd2VyZSBhZGRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBiZWdpbkZpbGwoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5lbmRGaWxsID0gZnVuY3Rpb24gZW5kRmlsbCgpIHtcbiAgICAgICAgdGhpcy5maWxsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuZHJhd1JlY3QgPSBmdW5jdGlvbiBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBfbWF0aC5SZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlIGNvcm5lcnNcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5kcmF3Um91bmRlZFJlY3QgPSBmdW5jdGlvbiBkcmF3Um91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBfbWF0aC5Sb3VuZGVkUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNpcmNsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiBkcmF3Q2lyY2xlKHgsIHksIHJhZGl1cykge1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShuZXcgX21hdGguQ2lyY2xlKHgsIHksIHJhZGl1cykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhbiBlbGxpcHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBoYWxmIHdpZHRoIG9mIHRoZSBlbGxpcHNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmRyYXdFbGxpcHNlID0gZnVuY3Rpb24gZHJhd0VsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShuZXcgX21hdGguRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgcG9seWdvbiB1c2luZyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118UElYSS5Qb2ludFtdfSBwYXRoIC0gVGhlIHBhdGggZGF0YSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcG9seWdvbi5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5kcmF3UG9seWdvbiA9IGZ1bmN0aW9uIGRyYXdQb2x5Z29uKHBhdGgpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgYXNzaWdubWVudCBkZW9wdFxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgICAgICB2YXIgcG9pbnRzID0gcGF0aDtcblxuICAgICAgICB2YXIgY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAocG9pbnRzIGluc3RhbmNlb2YgX21hdGguUG9seWdvbikge1xuICAgICAgICAgICAgY2xvc2VkID0gcG9pbnRzLmNsb3NlZDtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5wb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xuICAgICAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgbGVhayBkZW9wdFxuICAgICAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4yOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcbiAgICAgICAgICAgIHBvaW50cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBhcmd1bWVudHNbaV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhcGUgPSBuZXcgX21hdGguUG9seWdvbihwb2ludHMpO1xuXG4gICAgICAgIHNoYXBlLmNsb3NlZCA9IGNsb3NlZDtcblxuICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lV2lkdGggfHwgdGhpcy5maWxsaW5nIHx8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubGluZVdpZHRoID0gMDtcbiAgICAgICAgICAgIHRoaXMuZmlsbGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmJvdW5kc0RpcnR5ID0gLTE7XG4gICAgICAgICAgICB0aGlzLmRpcnR5Kys7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRGlydHkrKztcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3ByaXRlUmVjdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgZ3JhcGhpY3MgY29uc2lzdHMgb2Ygb25lIHJlY3RhbmdsZSwgYW5kIHRodXMsIGNhbiBiZSBkcmF3biBsaWtlIGEgU3ByaXRlIGFuZFxuICAgICAqIG1hc2tlZCB3aXRoIGdsLnNjaXNzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IDEgcmVjdC5cbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLmlzRmFzdFJlY3QgPSBmdW5jdGlvbiBpc0Zhc3RSZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID09PSAxICYmIHRoaXMuZ3JhcGhpY3NEYXRhWzBdLnNoYXBlLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUkVDVCAmJiAhdGhpcy5ncmFwaGljc0RhdGFbMF0ubGluZVdpZHRoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gX3JlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgIT09IHRoaXMuZmFzdFJlY3REaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5mYXN0UmVjdERpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RSZWN0ID0gdGhpcy5pc0Zhc3RSZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIHRoaXMgY2hlY2sgY2FuIGJlIG1vdmVkIHRvIGRpcnR5P1xuICAgICAgICBpZiAodGhpcy5fZmFzdFJlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclNwcml0ZVJlY3QocmVuZGVyZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcyk7XG4gICAgICAgICAgICByZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzLnJlbmRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc3ByaXRlIHJlY3RhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5fcmVuZGVyU3ByaXRlUmVjdCA9IGZ1bmN0aW9uIF9yZW5kZXJTcHJpdGVSZWN0KHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljc0RhdGFbMF0uc2hhcGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zcHJpdGVSZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVSZWN0ID0gbmV3IF9TcHJpdGUyLmRlZmF1bHQobmV3IF9UZXh0dXJlMi5kZWZhdWx0KF9UZXh0dXJlMi5kZWZhdWx0LldISVRFKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fc3ByaXRlUmVjdDtcblxuICAgICAgICBpZiAodGhpcy50aW50ID09PSAweGZmZmZmZikge1xuICAgICAgICAgICAgc3ByaXRlLnRpbnQgPSB0aGlzLmdyYXBoaWNzRGF0YVswXS5maWxsQ29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdDEgPSB0ZW1wQ29sb3IxO1xuICAgICAgICAgICAgdmFyIHQyID0gdGVtcENvbG9yMjtcblxuICAgICAgICAgICAgKDAsIF91dGlscy5oZXgycmdiKSh0aGlzLmdyYXBoaWNzRGF0YVswXS5maWxsQ29sb3IsIHQxKTtcbiAgICAgICAgICAgICgwLCBfdXRpbHMuaGV4MnJnYikodGhpcy50aW50LCB0Mik7XG5cbiAgICAgICAgICAgIHQxWzBdICo9IHQyWzBdO1xuICAgICAgICAgICAgdDFbMV0gKj0gdDJbMV07XG4gICAgICAgICAgICB0MVsyXSAqPSB0MlsyXTtcblxuICAgICAgICAgICAgc3ByaXRlLnRpbnQgPSAoMCwgX3V0aWxzLnJnYjJoZXgpKHQxKTtcbiAgICAgICAgfVxuICAgICAgICBzcHJpdGUuYWxwaGEgPSB0aGlzLmdyYXBoaWNzRGF0YVswXS5maWxsQWxwaGE7XG4gICAgICAgIHNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhICogc3ByaXRlLmFscGhhO1xuICAgICAgICBzcHJpdGUuYmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XG5cbiAgICAgICAgc3ByaXRlLnRleHR1cmUuX2ZyYW1lLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgc3ByaXRlLnRleHR1cmUuX2ZyYW1lLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHNwcml0ZS50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcblxuICAgICAgICBzcHJpdGUuYW5jaG9yLnNldCgtcmVjdC54IC8gcmVjdC53aWR0aCwgLXJlY3QueSAvIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgc3ByaXRlLl9vbkFuY2hvclVwZGF0ZSgpO1xuXG4gICAgICAgIHNwcml0ZS5fcmVuZGVyV2ViR0wocmVuZGVyZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgICBpZiAodGhpcy5pc01hc2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MucmVuZGVyKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZSBhcyBhIHJlY3RhbmdsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5fY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRzRGlydHkgIT09IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzRGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMb2NhbEJvdW5kcygpO1xuXG4gICAgICAgICAgICB0aGlzLmNhY2hlZFNwcml0ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYiA9IHRoaXMuX2xvY2FsQm91bmRzO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbGIubWluWCwgbGIubWluWSwgbGIubWF4WCwgbGIubWF4WSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgZ3JhcGhpY3Mgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcblxuICAgICAgICB2YXIgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3NEYXRhW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEuZmlsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbmx5IGRlYWwgd2l0aCBmaWxscy4uXG4gICAgICAgICAgICBpZiAoZGF0YS5zaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlLmNvbnRhaW5zKHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3MucHJvdG90eXBlLnVwZGF0ZUxvY2FsQm91bmRzID0gZnVuY3Rpb24gdXBkYXRlTG9jYWxCb3VuZHMoKSB7XG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuXG4gICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IDA7XG4gICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICB2YXIgaCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcblxuICAgICAgICAgICAgICAgIHNoYXBlID0gZGF0YS5zaGFwZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBfY29uc3QuU0hBUEVTLlJFQ1QgfHwgdHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SUkVDKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54IC0gbGluZVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHNoYXBlLnkgLSBsaW5lV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGggPSBzaGFwZS5oZWlnaHQgKyBsaW5lV2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBfY29uc3QuU0hBUEVTLkNJUkMpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUucmFkaXVzICsgbGluZVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLnJhZGl1cyArIGxpbmVXaWR0aCAvIDI7XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5FTElQKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLndpZHRoICsgbGluZVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLmhlaWdodCArIGxpbmVXaWR0aCAvIDI7XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBPTFlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ3ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiArIDIgPCBwb2ludHMubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gcG9pbnRzW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gcG9pbnRzW2ogKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoeDIgLSB4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gTWF0aC5hYnMoeTIgLSB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgPCAxZS05KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ3ID0gKGggLyB3ICogZHkgKyBkeCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmggPSAoaCAvIHcgKiBkeCArIGR5KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9ICh4MiArIHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gKHkyICsgeSkgLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5YID0gY3ggLSBydyA8IG1pblggPyBjeCAtIHJ3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSBjeCArIHJ3ID4gbWF4WCA/IGN4ICsgcncgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5ZID0gY3kgLSByaCA8IG1pblkgPyBjeSAtIHJoIDogbWluWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBjeSArIHJoID4gbWF4WSA/IGN5ICsgcmggOiBtYXhZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluWCA9IDA7XG4gICAgICAgICAgICBtYXhYID0gMDtcbiAgICAgICAgICAgIG1pblkgPSAwO1xuICAgICAgICAgICAgbWF4WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuYm91bmRzUGFkZGluZztcblxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcy5taW5YID0gbWluWCAtIHBhZGRpbmc7XG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzLm1heFggPSBtYXhYICsgcGFkZGluZyAqIDI7XG5cbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHMubWluWSA9IG1pblkgLSBwYWRkaW5nO1xuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcy5tYXhZID0gbWF4WSArIHBhZGRpbmcgKiAyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gc2hhcGUgdG8gdGhpcyBHcmFwaGljcyBvYmplY3QuIENhbiBiZSBhbnkgb2YgQ2lyY2xlLCBSZWN0YW5nbGUsIEVsbGlwc2UsIExpbmUgb3IgUG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NEYXRhfSBUaGUgZ2VuZXJhdGVkIEdyYXBoaWNzRGF0YSBvYmplY3QuXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbiBkcmF3U2hhcGUoc2hhcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGN1cnJlbnQgcGF0aCFcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgX0dyYXBoaWNzRGF0YTIuZGVmYXVsdCh0aGlzLmxpbmVXaWR0aCwgdGhpcy5saW5lQ29sb3IsIHRoaXMubGluZUFscGhhLCB0aGlzLmZpbGxDb2xvciwgdGhpcy5maWxsQWxwaGEsIHRoaXMuZmlsbGluZywgdGhpcy5uYXRpdmVMaW5lcywgc2hhcGUpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2goZGF0YSk7XG5cbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5QT0xZKSB7XG4gICAgICAgICAgICBkYXRhLnNoYXBlLmNsb3NlZCA9IGRhdGEuc2hhcGUuY2xvc2VkIHx8IHRoaXMuZmlsbGluZztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBjYW52YXMgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGUgLSBUaGUgc2NhbGUgbW9kZSBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ldyB0ZXh0dXJlLlxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuZ2VuZXJhdGVDYW52YXNUZXh0dXJlID0gZnVuY3Rpb24gZ2VuZXJhdGVDYW52YXNUZXh0dXJlKHNjYWxlTW9kZSkge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgICAgIHZhciBjYW52YXNCdWZmZXIgPSBfUmVuZGVyVGV4dHVyZTIuZGVmYXVsdC5jcmVhdGUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pO1xuXG4gICAgICAgIGlmICghY2FudmFzUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGNhbnZhc1JlbmRlcmVyID0gbmV3IF9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0uY29weSh0ZW1wTWF0cml4KTtcblxuICAgICAgICB0ZW1wTWF0cml4LmludmVydCgpO1xuXG4gICAgICAgIHRlbXBNYXRyaXgudHggLT0gYm91bmRzLng7XG4gICAgICAgIHRlbXBNYXRyaXgudHkgLT0gYm91bmRzLnk7XG5cbiAgICAgICAgY2FudmFzUmVuZGVyZXIucmVuZGVyKHRoaXMsIGNhbnZhc0J1ZmZlciwgdHJ1ZSwgdGVtcE1hdHJpeCk7XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBfVGV4dHVyZTIuZGVmYXVsdC5mcm9tQ2FudmFzKGNhbnZhc0J1ZmZlci5iYXNlVGV4dHVyZS5fY2FudmFzUmVuZGVyVGFyZ2V0LmNhbnZhcywgc2NhbGVNb2RlKTtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gY2xvc2VQYXRoKCkge1xuICAgICAgICAvLyBvayBzbyBjbG9zZSBwYXRoIGFzc3VtZXMgbmV4dCBvbmUgaXMgYSBob2xlIVxuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuXG4gICAgICAgIGlmIChjdXJyZW50UGF0aCAmJiBjdXJyZW50UGF0aC5zaGFwZSkge1xuICAgICAgICAgICAgY3VycmVudFBhdGguc2hhcGUuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgaG9sZSBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG5cblxuICAgIEdyYXBoaWNzLnByb3RvdHlwZS5hZGRIb2xlID0gZnVuY3Rpb24gYWRkSG9sZSgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGhvbGUhXG4gICAgICAgIHZhciBob2xlID0gdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZ3JhcGhpY3NEYXRhW3RoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGguYWRkSG9sZShob2xlLnNoYXBlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgICAqICBvcHRpb25zIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuXG5cbiAgICBHcmFwaGljcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBfQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gZGVzdHJveSBlYWNoIG9mIHRoZSBHcmFwaGljc0RhdGEgb2JqZWN0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVtpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgZWFjaCB3ZWJnbCBkYXRhIGVudHJ5LCBkZXN0cm95IHRoZSBXZWJHTEdyYXBoaWNzRGF0YVxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl93ZWJnbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl93ZWJnbFtpZF0uZGF0YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYmdsW2lkXS5kYXRhW2pdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zcHJpdGVSZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVSZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gbnVsbDtcblxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2ViZ2wgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBHcmFwaGljcztcbn0oX0NvbnRhaW5lcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdyYXBoaWNzO1xuXG5cbkdyYXBoaWNzLl9TUFJJVEVfVEVYVFVSRSA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy9HcmFwaGljcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9DYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcblxudmFyIF9DYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNSZW5kZXJlcik7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXlcbiAqIG5vdyBzaGFyZSA0IGJ5dGVzIG9uIHRoZSB2ZXJ0ZXggYnVmZmVyXG4gKlxuICogSGVhdmlseSBpbnNwaXJlZCBieSBMaWJHRFgncyBDYW52YXNHcmFwaGljc1JlbmRlcmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi8xLjAuMC9nZHgvc3JjL2NvbS9iYWRsb2dpYy9nZHgvZ3JhcGhpY3MvZ2x1dGlscy9TaGFwZVJlbmRlcmVyLmphdmFcbiAqL1xuXG4vKipcbiAqIFJlbmRlcmVyIGRlZGljYXRlZCB0byBkcmF3aW5nIGFuZCBiYXRjaGluZyBncmFwaGljcyBvYmplY3RzLlxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBDYW52YXNHcmFwaGljc1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgY3VycmVudCBQSVhJIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgR3JhcGhpY3Mgb2JqZWN0IHRvIGEgY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzfSBncmFwaGljcyAtIHRoZSBhY3R1YWwgZ3JhcGhpY3Mgb2JqZWN0IHRvIHJlbmRlclxuICAgICAqL1xuXG5cbiAgICBDYW52YXNHcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoZ3JhcGhpY3MpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuICAgICAgICB2YXIgd29ybGRBbHBoYSA9IGdyYXBoaWNzLndvcmxkQWxwaGE7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBncmFwaGljcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcblxuICAgICAgICAvLyBpZiB0aGUgdGludCBoYXMgY2hhbmdlZCwgc2V0IHRoZSBncmFwaGljcyBvYmplY3QgdG8gZGlydHkuXG4gICAgICAgIGlmICh0aGlzLl9wcmV2VGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLmIgKiByZXNvbHV0aW9uLCB0cmFuc2Zvcm0uYyAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS5kICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLnR4ICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLnR5ICogcmVzb2x1dGlvbik7XG5cbiAgICAgICAgaWYgKGdyYXBoaWNzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdyYXBoaWNzVGludChncmFwaGljcyk7XG4gICAgICAgICAgICBncmFwaGljcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0QmxlbmRNb2RlKGdyYXBoaWNzLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gZGF0YS5zaGFwZTtcblxuICAgICAgICAgICAgdmFyIGZpbGxDb2xvciA9IGRhdGEuX2ZpbGxUaW50O1xuICAgICAgICAgICAgdmFyIGxpbmVDb2xvciA9IGRhdGEuX2xpbmVUaW50O1xuXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGRhdGEubGluZVdpZHRoO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLlBPTFkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQb2x5Z29uKHNoYXBlLnBvaW50cywgc2hhcGUuY2xvc2VkLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5ob2xlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvbHlnb24oZGF0YS5ob2xlc1tqXS5wb2ludHMsIHRydWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArIChmaWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SRUNUKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbENvbG9yIHx8IGRhdGEuZmlsbENvbG9yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkNJUkMpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gbmVlZCB0byBiZSBVbmRlZmluZWQhXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAobGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkVMSVApIHtcbiAgICAgICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG5cbiAgICAgICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoICogMjtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHNoYXBlLmhlaWdodCAqIDI7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNoYXBlLnggLSB3IC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnkgLSBoIC8gMjtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDg7XG4gICAgICAgICAgICAgICAgdmFyIG94ID0gdyAvIDIgKiBrYXBwYTsgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgIHZhciBveSA9IGggLyAyICoga2FwcGE7IC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgdmFyIHhlID0geCArIHc7IC8vIHgtZW5kXG4gICAgICAgICAgICAgICAgdmFyIHllID0geSArIGg7IC8vIHktZW5kXG4gICAgICAgICAgICAgICAgdmFyIHhtID0geCArIHcgLyAyOyAvLyB4LW1pZGRsZVxuICAgICAgICAgICAgICAgIHZhciB5bSA9IHkgKyBoIC8gMjsgLy8geS1taWRkbGVcblxuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHltKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArIChmaWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SUkVDKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ4ID0gc2hhcGUueDtcbiAgICAgICAgICAgICAgICB2YXIgcnkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHNoYXBlLnJhZGl1cztcblxuICAgICAgICAgICAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIgfCAwO1xuXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzID4gbWF4UmFkaXVzID8gbWF4UmFkaXVzIDogcmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyeCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4LCByeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0LCByeCArIHdpZHRoLCByeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSwgcnggKyB3aWR0aCAtIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgcmFkaXVzLCByeSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbENvbG9yIHx8IGRhdGEuZmlsbENvbG9yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGludCBvZiBhIGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gdGhlIGdyYXBoaWNzIHRoYXQgd2lsbCBoYXZlIGl0cyB0aW50IHVwZGF0ZWRcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlR3JhcGhpY3NUaW50ID0gZnVuY3Rpb24gdXBkYXRlR3JhcGhpY3NUaW50KGdyYXBoaWNzKSB7XG4gICAgICAgIGdyYXBoaWNzLl9wcmV2VGludCA9IGdyYXBoaWNzLnRpbnQ7XG5cbiAgICAgICAgdmFyIHRpbnRSID0gKGdyYXBoaWNzLnRpbnQgPj4gMTYgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIHRpbnRHID0gKGdyYXBoaWNzLnRpbnQgPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgdGludEIgPSAoZ3JhcGhpY3MudGludCAmIDB4RkYpIC8gMjU1O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YVtpXTtcblxuICAgICAgICAgICAgdmFyIGZpbGxDb2xvciA9IGRhdGEuZmlsbENvbG9yIHwgMDtcbiAgICAgICAgICAgIHZhciBsaW5lQ29sb3IgPSBkYXRhLmxpbmVDb2xvciB8IDA7XG5cbiAgICAgICAgICAgIC8vIHN1cGVyIGlubGluZSBjb3MgaW0gYW4gb3B0aW1pemF0aW9uIE5BWkkgOilcbiAgICAgICAgICAgIGRhdGEuX2ZpbGxUaW50ID0gKChmaWxsQ29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NSAqIHRpbnRSICogMjU1IDw8IDE2KSArICgoZmlsbENvbG9yID4+IDggJiAweEZGKSAvIDI1NSAqIHRpbnRHICogMjU1IDw8IDgpICsgKGZpbGxDb2xvciAmIDB4RkYpIC8gMjU1ICogdGludEIgKiAyNTU7XG5cbiAgICAgICAgICAgIGRhdGEuX2xpbmVUaW50ID0gKChsaW5lQ29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NSAqIHRpbnRSICogMjU1IDw8IDE2KSArICgobGluZUNvbG9yID4+IDggJiAweEZGKSAvIDI1NSAqIHRpbnRHICogMjU1IDw8IDgpICsgKGxpbmVDb2xvciAmIDB4RkYpIC8gMjU1ICogdGludEIgKiAyNTU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHBvbHlnb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnRbXX0gcG9pbnRzIC0gVGhlIHBvaW50cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlIC0gU2hvdWxkIHRoZSBwb2x5Z29uIGJlIGNsb3NlZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIHJlbmRlcmluZyBjb250ZXh0IHRvIHVzZVxuICAgICAqL1xuXG5cbiAgICBDYW52YXNHcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJQb2x5Z29uID0gZnVuY3Rpb24gcmVuZGVyUG9seWdvbihwb2ludHMsIGNsb3NlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBvaW50cy5sZW5ndGggLyAyOyArK2opIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tqICogMl0sIHBvaW50c1tqICogMiArIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICovXG5cblxuICAgIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbnZhc0dyYXBoaWNzUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc0dyYXBoaWNzUmVuZGVyZXI7XG5cblxuX0NhbnZhc1JlbmRlcmVyMi5kZWZhdWx0LnJlZ2lzdGVyUGx1Z2luKCdncmFwaGljcycsIENhbnZhc0dyYXBoaWNzUmVuZGVyZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzR3JhcGhpY3NSZW5kZXJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy9jYW52YXMvQ2FudmFzR3JhcGhpY3NSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gYmV6aWVyQ3VydmVUbztcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tWCAtIFN0YXJ0aW5nIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tWSAtIFN0YXJ0aW5nIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxuICogQHBhcmFtIHtudW1iZXJ9IGNwWTIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyW119IFtwYXRoPVtdXSAtIFBhdGggYXJyYXkgdG8gcHVzaCBwb2ludHMgaW50b1xuICogQHJldHVybiB7bnVtYmVyW119IEFycmF5IG9mIHBvaW50cyBvZiB0aGUgY3VydmVcbiAqL1xuZnVuY3Rpb24gYmV6aWVyQ3VydmVUbyhmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkge1xuICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiBbXTtcblxuICAgIHZhciBuID0gMjA7XG4gICAgdmFyIGR0ID0gMDtcbiAgICB2YXIgZHQyID0gMDtcbiAgICB2YXIgZHQzID0gMDtcbiAgICB2YXIgdDIgPSAwO1xuICAgIHZhciB0MyA9IDA7XG5cbiAgICBwYXRoLnB1c2goZnJvbVgsIGZyb21ZKTtcblxuICAgIGZvciAodmFyIGkgPSAxLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgaiA9IGkgLyBuO1xuXG4gICAgICAgIGR0ID0gMSAtIGo7XG4gICAgICAgIGR0MiA9IGR0ICogZHQ7XG4gICAgICAgIGR0MyA9IGR0MiAqIGR0O1xuXG4gICAgICAgIHQyID0gaiAqIGo7XG4gICAgICAgIHQzID0gdDIgKiBqO1xuXG4gICAgICAgIHBhdGgucHVzaChkdDMgKiBmcm9tWCArIDMgKiBkdDIgKiBqICogY3BYICsgMyAqIGR0ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsIGR0MyAqIGZyb21ZICsgMyAqIGR0MiAqIGogKiBjcFkgKyAzICogZHQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZXppZXJDdXJ2ZVRvLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3V0aWxzL2JlemllckN1cnZlVG8uanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxudmFyIF9PYmplY3RSZW5kZXJlcjIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXInKTtcblxudmFyIF9PYmplY3RSZW5kZXJlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYmplY3RSZW5kZXJlcjIpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xSZW5kZXJlcik7XG5cbnZhciBfV2ViR0xHcmFwaGljc0RhdGEgPSByZXF1aXJlKCcuL1dlYkdMR3JhcGhpY3NEYXRhJyk7XG5cbnZhciBfV2ViR0xHcmFwaGljc0RhdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xHcmFwaGljc0RhdGEpO1xuXG52YXIgX1ByaW1pdGl2ZVNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVycy9QcmltaXRpdmVTaGFkZXInKTtcblxudmFyIF9QcmltaXRpdmVTaGFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHJpbWl0aXZlU2hhZGVyKTtcblxudmFyIF9idWlsZFBvbHkgPSByZXF1aXJlKCcuL3V0aWxzL2J1aWxkUG9seScpO1xuXG52YXIgX2J1aWxkUG9seTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZFBvbHkpO1xuXG52YXIgX2J1aWxkUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi91dGlscy9idWlsZFJlY3RhbmdsZScpO1xuXG52YXIgX2J1aWxkUmVjdGFuZ2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkUmVjdGFuZ2xlKTtcblxudmFyIF9idWlsZFJvdW5kZWRSZWN0YW5nbGUgPSByZXF1aXJlKCcuL3V0aWxzL2J1aWxkUm91bmRlZFJlY3RhbmdsZScpO1xuXG52YXIgX2J1aWxkUm91bmRlZFJlY3RhbmdsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZFJvdW5kZWRSZWN0YW5nbGUpO1xuXG52YXIgX2J1aWxkQ2lyY2xlID0gcmVxdWlyZSgnLi91dGlscy9idWlsZENpcmNsZScpO1xuXG52YXIgX2J1aWxkQ2lyY2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkQ2lyY2xlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIG9iamVjdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXG4gKi9cbnZhciBHcmFwaGljc1JlbmRlcmVyID0gZnVuY3Rpb24gKF9PYmplY3RSZW5kZXJlcikge1xuICAgIF9pbmhlcml0cyhHcmFwaGljc1JlbmRlcmVyLCBfT2JqZWN0UmVuZGVyZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgb2JqZWN0IHJlbmRlcmVyIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHcmFwaGljc1JlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFwaGljc1JlbmRlcmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcikpO1xuXG4gICAgICAgIF90aGlzLmdyYXBoaWNzRGF0YVBvb2wgPSBbXTtcblxuICAgICAgICBfdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLmdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgLy8gZWFzeSBhY2Nlc3MhXG4gICAgICAgIF90aGlzLkNPTlRFWFRfVUlEID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2VcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gb25Db250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyID0gbmV3IF9QcmltaXRpdmVTaGFkZXIyLmRlZmF1bHQodGhpcy5nbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIF9PYmplY3RSZW5kZXJlcjMuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGFQb29sLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2xbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdyYXBoaWNzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc30gZ3JhcGhpY3MgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIHJlbmRlci5cbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGdyYXBoaWNzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgICAgIHZhciB3ZWJHTERhdGEgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFt0aGlzLkNPTlRFWFRfVUlEXTtcblxuICAgICAgICBpZiAoIXdlYkdMIHx8IGdyYXBoaWNzLmRpcnR5ICE9PSB3ZWJHTC5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljcyhncmFwaGljcyk7XG5cbiAgICAgICAgICAgIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyAgY291bGQgYmUgc3BlZWRlZCB1cCBmb3Igc3VyZSFcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMucHJpbWl0aXZlU2hhZGVyO1xuXG4gICAgICAgIHJlbmRlcmVyLmJpbmRTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRNb2RlKGdyYXBoaWNzLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB3ZWJHTC5kYXRhLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtpXTtcbiAgICAgICAgICAgIHZhciBzaGFkZXJUZW1wID0gd2ViR0xEYXRhLnNoYWRlcjtcblxuICAgICAgICAgICAgcmVuZGVyZXIuYmluZFNoYWRlcihzaGFkZXJUZW1wKTtcbiAgICAgICAgICAgIHNoYWRlclRlbXAudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBncmFwaGljcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKTtcbiAgICAgICAgICAgIHNoYWRlclRlbXAudW5pZm9ybXMudGludCA9ICgwLCBfdXRpbHMuaGV4MnJnYikoZ3JhcGhpY3MudGludCk7XG4gICAgICAgICAgICBzaGFkZXJUZW1wLnVuaWZvcm1zLmFscGhhID0gZ3JhcGhpY3Mud29ybGRBbHBoYTtcblxuICAgICAgICAgICAgcmVuZGVyZXIuYmluZFZhbyh3ZWJHTERhdGEudmFvKTtcblxuICAgICAgICAgICAgaWYgKGdyYXBoaWNzLm5hdGl2ZUxpbmVzKSB7XG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgd2ViR0xEYXRhLnBvaW50cy5sZW5ndGggLyA2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2ViR0xEYXRhLnZhby5kcmF3KGdsLlRSSUFOR0xFX1NUUklQLCB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gVGhlIGdyYXBoaWNzIG9iamVjdCB0byB1cGRhdGVcbiAgICAgKi9cblxuXG4gICAgR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlR3JhcGhpY3MgPSBmdW5jdGlvbiB1cGRhdGVHcmFwaGljcyhncmFwaGljcykge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY29udGV4dHMgZ3JhcGhpY3Mgb2JqZWN0XG4gICAgICAgIHZhciB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFt0aGlzLkNPTlRFWFRfVUlEXTtcblxuICAgICAgICAvLyBpZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSB3ZWJHTCBjb250ZXh0IHRpbWUgdG8gY3JlYXRlIGl0IVxuICAgICAgICBpZiAoIXdlYkdMKSB7XG4gICAgICAgICAgICB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFt0aGlzLkNPTlRFWFRfVUlEXSA9IHsgbGFzdEluZGV4OiAwLCBkYXRhOiBbXSwgZ2w6IGdsLCBjbGVhckRpcnR5OiAtMSwgZGlydHk6IC0xIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmbGFnIHRoZSBncmFwaGljcyBhcyBub3QgZGlydHkgYXMgd2UgYXJlIGFib3V0IHRvIHVwZGF0ZSBpdC4uLlxuICAgICAgICB3ZWJHTC5kaXJ0eSA9IGdyYXBoaWNzLmRpcnR5O1xuXG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGNsZWFyZWQgdGhlIGdyYXBoaWNzIG9iamVjdCB3ZSB3aWxsIG5lZWQgdG8gY2xlYXIgZXZlcnkgb2JqZWN0XG4gICAgICAgIGlmIChncmFwaGljcy5jbGVhckRpcnR5ICE9PSB3ZWJHTC5jbGVhckRpcnR5KSB7XG4gICAgICAgICAgICB3ZWJHTC5jbGVhckRpcnR5ID0gZ3JhcGhpY3MuY2xlYXJEaXJ0eTtcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFuZCByZXR1cm4gYWxsIHRoZSB3ZWJHTERhdGFzIHRvIHRoZSBvYmplY3QgcG9vbCBzbyB0aGFuIGNhbiBiZSByZXVzZWQgbGF0ZXIgb25cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhUG9vbC5wdXNoKHdlYkdMLmRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGVhciB0aGUgYXJyYXkgYW5kIHJlc2V0IHRoZSBpbmRleC4uXG4gICAgICAgICAgICB3ZWJHTC5kYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB3ZWJHTC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdlYkdMRGF0YSA9IHZvaWQgMDtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGdyYXBoaWNzIGRhdGFzIGFuZCBjb25zdHJ1Y3QgZWFjaCBvbmUuLlxuICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgY29tcGxleCBmaWxsIHRoZW4gdGhlIG5ldyBzdGVuY2lsIGJ1ZmZlciB0ZWNobmlxdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgIC8vIG90aGVyIHdpc2UgZ3JhcGhpY3Mgb2JqZWN0cyB3aWxsIGJlIHB1c2hlZCBpbnRvIGEgYmF0Y2guLlxuICAgICAgICBmb3IgKHZhciBfaSA9IHdlYkdMLmxhc3RJbmRleDsgX2kgPCBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YVtfaV07XG5cbiAgICAgICAgICAgIC8vIFRPRE8gLSB0aGlzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLmdldFdlYkdMRGF0YSh3ZWJHTCwgMCk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUE9MWSkge1xuICAgICAgICAgICAgICAgICgwLCBfYnVpbGRQb2x5Mi5kZWZhdWx0KShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5SRUNUKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9idWlsZFJlY3RhbmdsZTIuZGVmYXVsdCkoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkNJUkMgfHwgZGF0YS50eXBlID09PSBfY29uc3QuU0hBUEVTLkVMSVApIHtcbiAgICAgICAgICAgICAgICAoMCwgX2J1aWxkQ2lyY2xlMi5kZWZhdWx0KShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUlJFQykge1xuICAgICAgICAgICAgICAgICgwLCBfYnVpbGRSb3VuZGVkUmVjdGFuZ2xlMi5kZWZhdWx0KShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ZWJHTC5sYXN0SW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYmluZFZhbyhudWxsKTtcblxuICAgICAgICAvLyB1cGxvYWQgYWxsIHRoZSBkaXJ0eSBkYXRhLi4uXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHdlYkdMLmRhdGEubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtfaTJdO1xuXG4gICAgICAgICAgICBpZiAod2ViR0xEYXRhLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgd2ViR0xEYXRhLnVwbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZSAtIFRPRE8gQEFsdmluXG4gICAgICogQHJldHVybiB7Kn0gVE9ET1xuICAgICAqL1xuXG5cbiAgICBHcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRXZWJHTERhdGEgPSBmdW5jdGlvbiBnZXRXZWJHTERhdGEoZ2wsIHR5cGUpIHtcbiAgICAgICAgdmFyIHdlYkdMRGF0YSA9IGdsLmRhdGFbZ2wuZGF0YS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoIXdlYkdMRGF0YSB8fCB3ZWJHTERhdGEucG9pbnRzLmxlbmd0aCA+IDMyMDAwMCkge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5ncmFwaGljc0RhdGFQb29sLnBvcCgpIHx8IG5ldyBfV2ViR0xHcmFwaGljc0RhdGEyLmRlZmF1bHQodGhpcy5yZW5kZXJlci5nbCwgdGhpcy5wcmltaXRpdmVTaGFkZXIsIHRoaXMucmVuZGVyZXIuc3RhdGUuYXR0cmlic1N0YXRlKTtcblxuICAgICAgICAgICAgd2ViR0xEYXRhLnJlc2V0KHR5cGUpO1xuICAgICAgICAgICAgZ2wuZGF0YS5wdXNoKHdlYkdMRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB3ZWJHTERhdGEuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB3ZWJHTERhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBHcmFwaGljc1JlbmRlcmVyO1xufShfT2JqZWN0UmVuZGVyZXIzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBHcmFwaGljc1JlbmRlcmVyO1xuXG5cbl9XZWJHTFJlbmRlcmVyMi5kZWZhdWx0LnJlZ2lzdGVyUGx1Z2luKCdncmFwaGljcycsIEdyYXBoaWNzUmVuZGVyZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NSZW5kZXJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC9HcmFwaGljc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIFdlYkdMIHNwZWNpZmljIHByb3BlcnRpZXMgdG8gYmUgdXNlZCBieSB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgV2ViR0xHcmFwaGljc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIC0gVGhlIHNoYWRlclxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlic1N0YXRlIC0gVGhlIHN0YXRlIGZvciB0aGUgVkFPXG4gICAqL1xuICBmdW5jdGlvbiBXZWJHTEdyYXBoaWNzRGF0YShnbCwgc2hhZGVyLCBhdHRyaWJzU3RhdGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xHcmFwaGljc0RhdGEpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLy8gVE9ETyBkb2VzIHRoaXMgbmVlZCB0byBiZSBzcGxpdCBiZWZvcmUgdXBsb2FkaW5nPz9cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBjb2xvciBjb21wb25lbnRzIChyLGcsYilcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gWzAsIDAsIDBdOyAvLyBjb2xvciBzcGxpdCFcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHBvaW50cyB0byBkcmF3XG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXNcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBidWZmZXJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlciA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlcihnbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggYnVmZmVyXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LkdMQnVmZmVyLmNyZWF0ZUluZGV4QnVmZmVyKGdsKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBncmFwaGljcyBpcyBkaXJ0eSBvciBub3RcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgdGhpcy5nbFBvaW50cyA9IG51bGw7XG4gICAgdGhpcy5nbEluZGljZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcblxuICAgIHRoaXMudmFvID0gbmV3IF9waXhpR2xDb3JlMi5kZWZhdWx0LlZlcnRleEFycmF5T2JqZWN0KGdsLCBhdHRyaWJzU3RhdGUpLmFkZEluZGV4KHRoaXMuaW5kZXhCdWZmZXIpLmFkZEF0dHJpYnV0ZSh0aGlzLmJ1ZmZlciwgc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAwKS5hZGRBdHRyaWJ1dGUodGhpcy5idWZmZXIsIHNoYWRlci5hdHRyaWJ1dGVzLmFDb2xvciwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogNiwgMiAqIDQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgdmVydGljZXMgYW5kIHRoZSBpbmRpY2VzXG4gICAqL1xuXG5cbiAgV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogQmluZHMgdGhlIGJ1ZmZlcnMgYW5kIHVwbG9hZHMgdGhlIGRhdGFcbiAgICovXG5cblxuICBXZWJHTEdyYXBoaWNzRGF0YS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgIHRoaXMuZ2xQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucG9pbnRzKTtcbiAgICB0aGlzLmJ1ZmZlci51cGxvYWQodGhpcy5nbFBvaW50cyk7XG5cbiAgICB0aGlzLmdsSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIudXBsb2FkKHRoaXMuZ2xJbmRpY2VzKTtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW1wdGllcyBhbGwgdGhlIGRhdGFcbiAgICovXG5cblxuICBXZWJHTEdyYXBoaWNzRGF0YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb2xvciA9IG51bGw7XG4gICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG5cbiAgICB0aGlzLnZhby5kZXN0cm95KCk7XG4gICAgdGhpcy5idWZmZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG5cbiAgICB0aGlzLmdsUG9pbnRzID0gbnVsbDtcbiAgICB0aGlzLmdsSW5kaWNlcyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFdlYkdMR3JhcGhpY3NEYXRhO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXZWJHTEdyYXBoaWNzRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkdMR3JhcGhpY3NEYXRhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL1dlYkdMR3JhcGhpY3NEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1NoYWRlcjIgPSByZXF1aXJlKCcuLi8uLi8uLi9TaGFkZXInKTtcblxudmFyIF9TaGFkZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhZGVyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGlzIHNoYWRlciBpcyB1c2VkIHRvIGRyYXcgc2ltcGxlIHByaW1pdGl2ZSBzaGFwZXMgZm9yIHtAbGluayBQSVhJLkdyYXBoaWNzfS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLlNoYWRlclxuICovXG52YXIgUHJpbWl0aXZlU2hhZGVyID0gZnVuY3Rpb24gKF9TaGFkZXIpIHtcbiAgICBfaW5oZXJpdHMoUHJpbWl0aXZlU2hhZGVyLCBfU2hhZGVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJpbWl0aXZlU2hhZGVyKGdsKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcmltaXRpdmVTaGFkZXIpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2hhZGVyLmNhbGwodGhpcywgZ2wsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgWydhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JywgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLCAndW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4OycsICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLCAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLCAndW5pZm9ybSB2ZWMzIHRpbnQ7JywgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JywgJ3ZvaWQgbWFpbih2b2lkKXsnLCAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsnLCAnICAgdkNvbG9yID0gYUNvbG9yICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLCAnfSddLmpvaW4oJ1xcbicpLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgWyd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsICd2b2lkIG1haW4odm9pZCl7JywgJyAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjsnLCAnfSddLmpvaW4oJ1xcbicpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByaW1pdGl2ZVNoYWRlcjtcbn0oX1NoYWRlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFByaW1pdGl2ZVNoYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByaW1pdGl2ZVNoYWRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC9zaGFkZXJzL1ByaW1pdGl2ZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkQ2lyY2xlO1xuXG52YXIgX2J1aWxkTGluZSA9IHJlcXVpcmUoJy4vYnVpbGRMaW5lJyk7XG5cbnZhciBfYnVpbGRMaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkTGluZSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCdWlsZHMgYSBjaXJjbGUgdG8gZHJhd1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgdG8gZHJhd1xuICogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YSAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRDaXJjbGUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpIHtcbiAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICB2YXIgY2lyY2xlRGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICB2YXIgeCA9IGNpcmNsZURhdGEueDtcbiAgICB2YXIgeSA9IGNpcmNsZURhdGEueTtcbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodCA9IHZvaWQgMDtcblxuICAgIC8vIFRPRE8gLSBiaXQgaGFja3k/P1xuICAgIGlmIChncmFwaGljc0RhdGEudHlwZSA9PT0gX2NvbnN0LlNIQVBFUy5DSVJDKSB7XG4gICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS5yYWRpdXM7XG4gICAgICAgIGhlaWdodCA9IGNpcmNsZURhdGEucmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsU2VncyA9IE1hdGguZmxvb3IoMzAgKiBNYXRoLnNxcnQoY2lyY2xlRGF0YS5yYWRpdXMpKSB8fCBNYXRoLmZsb29yKDE1ICogTWF0aC5zcXJ0KGNpcmNsZURhdGEud2lkdGggKyBjaXJjbGVEYXRhLmhlaWdodCkpO1xuXG4gICAgdmFyIHNlZyA9IE1hdGguUEkgKiAyIC8gdG90YWxTZWdzO1xuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5maWxsKSB7XG4gICAgICAgIHZhciBjb2xvciA9ICgwLCBfdXRpbHMuaGV4MnJnYikoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxTZWdzICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHgsIHksIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaCh4ICsgTWF0aC5zaW4oc2VnICogaSkgKiB3aWR0aCwgeSArIE1hdGguY29zKHNlZyAqIGkpICogaGVpZ2h0LCByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MrKywgdmVjUG9zKyspO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1BvcyAtIDEpO1xuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoKSB7XG4gICAgICAgIHZhciB0ZW1wUG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvdGFsU2VncyArIDE7IF9pKyspIHtcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMucHVzaCh4ICsgTWF0aC5zaW4oc2VnICogX2kpICogd2lkdGgsIHkgKyBNYXRoLmNvcyhzZWcgKiBfaSkgKiBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgKDAsIF9idWlsZExpbmUyLmRlZmF1bHQpKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZENpcmNsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZENpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkUG9seTtcblxudmFyIF9idWlsZExpbmUgPSByZXF1aXJlKCcuL2J1aWxkTGluZScpO1xuXG52YXIgX2J1aWxkTGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZExpbmUpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxudmFyIF9lYXJjdXQgPSByZXF1aXJlKCdlYXJjdXQnKTtcblxudmFyIF9lYXJjdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFyY3V0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCdWlsZHMgYSBwb2x5Z29uIHRvIGRyYXdcbiAqXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YSAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRQb2x5KGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKSB7XG4gICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IGdyYXBoaWNzRGF0YS5zaGFwZS5wb2ludHMuc2xpY2UoKTtcblxuICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5maWxsICYmIHBvaW50cy5sZW5ndGggPj0gNikge1xuICAgICAgICB2YXIgaG9sZUFycmF5ID0gW107XG4gICAgICAgIC8vIFByb2Nlc3MgaG9sZXMuLlxuICAgICAgICB2YXIgaG9sZXMgPSBncmFwaGljc0RhdGEuaG9sZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGhvbGUgPSBob2xlc1tpXTtcblxuICAgICAgICAgICAgaG9sZUFycmF5LnB1c2gocG9pbnRzLmxlbmd0aCAvIDIpO1xuXG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGhvbGUucG9pbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBmaXJzdCBhbmQgbGFzdCBwb2ludC4uIGZpZ3VyZSBvdXQgdGhlIG1pZGRsZSFcbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG5cbiAgICAgICAgLy8gc29ydCBjb2xvclxuICAgICAgICB2YXIgY29sb3IgPSAoMCwgX3V0aWxzLmhleDJyZ2IpKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIHZhciB0cmlhbmdsZXMgPSAoMCwgX2VhcmN1dDIuZGVmYXVsdCkocG9pbnRzLCBob2xlQXJyYXksIDIpO1xuXG4gICAgICAgIGlmICghdHJpYW5nbGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IF9pICs9IDMpIHtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbX2ldICsgdmVydFBvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW19pXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tfaSArIDFdICsgdmVydFBvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW19pICsgMl0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbX2kgKyAyXSArIHZlcnRQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmVydHMucHVzaChwb2ludHNbX2kyICogMl0sIHBvaW50c1tfaTIgKiAyICsgMV0sIHIsIGcsIGIsIGFscGhhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoID4gMCkge1xuICAgICAgICAoMCwgX2J1aWxkTGluZTIuZGVmYXVsdCkoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUG9seS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZFBvbHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBidWlsZFJlY3RhbmdsZTtcblxudmFyIF9idWlsZExpbmUgPSByZXF1aXJlKCcuL2J1aWxkTGluZScpO1xuXG52YXIgX2J1aWxkTGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZExpbmUpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCdWlsZHMgYSByZWN0YW5nbGUgdG8gZHJhd1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5mdW5jdGlvbiBidWlsZFJlY3RhbmdsZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSkge1xuICAgIC8vIC0tLSAvL1xuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgIC8vXG4gICAgdmFyIHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgIHZhciB4ID0gcmVjdERhdGEueDtcbiAgICB2YXIgeSA9IHJlY3REYXRhLnk7XG4gICAgdmFyIHdpZHRoID0gcmVjdERhdGEud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlY3REYXRhLmhlaWdodDtcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbCkge1xuICAgICAgICB2YXIgY29sb3IgPSAoMCwgX3V0aWxzLmhleDJyZ2IpKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgdmVydHMucHVzaCh4LCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgIC8vIGluc2VydCAyIGRlYWQgdHJpYW5nbGVzLi5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlcnRQb3MsIHZlcnRQb3MsIHZlcnRQb3MgKyAxLCB2ZXJ0UG9zICsgMiwgdmVydFBvcyArIDMsIHZlcnRQb3MgKyAzKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCkge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IFt4LCB5LCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCwgeCwgeV07XG5cbiAgICAgICAgKDAsIF9idWlsZExpbmUyLmRlZmF1bHQpKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZFJlY3RhbmdsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZFJlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcblxudmFyIF9lYXJjdXQgPSByZXF1aXJlKCdlYXJjdXQnKTtcblxudmFyIF9lYXJjdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFyY3V0KTtcblxudmFyIF9idWlsZExpbmUgPSByZXF1aXJlKCcuL2J1aWxkTGluZScpO1xuXG52YXIgX2J1aWxkTGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWlsZExpbmUpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCdWlsZHMgYSByb3VuZGVkIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUm91bmRlZFJlY3RhbmdsZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSkge1xuICAgIHZhciBycmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgdmFyIHggPSBycmVjdERhdGEueDtcbiAgICB2YXIgeSA9IHJyZWN0RGF0YS55O1xuICAgIHZhciB3aWR0aCA9IHJyZWN0RGF0YS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcnJlY3REYXRhLmhlaWdodDtcblxuICAgIHZhciByYWRpdXMgPSBycmVjdERhdGEucmFkaXVzO1xuXG4gICAgdmFyIHJlY1BvaW50cyA9IFtdO1xuXG4gICAgcmVjUG9pbnRzLnB1c2goeCwgeSArIHJhZGl1cyk7XG4gICAgcXVhZHJhdGljQmV6aWVyQ3VydmUoeCwgeSArIGhlaWdodCAtIHJhZGl1cywgeCwgeSArIGhlaWdodCwgeCArIHJhZGl1cywgeSArIGhlaWdodCwgcmVjUG9pbnRzKTtcbiAgICBxdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzLCByZWNQb2ludHMpO1xuICAgIHF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCwgeSArIHJhZGl1cywgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGggLSByYWRpdXMsIHksIHJlY1BvaW50cyk7XG4gICAgcXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHJhZGl1cywgeSwgeCwgeSwgeCwgeSArIHJhZGl1cyArIDAuMDAwMDAwMDAwMSwgcmVjUG9pbnRzKTtcblxuICAgIC8vIHRoaXMgdGlueSBudW1iZXIgZGVhbHMgd2l0aCB0aGUgaXNzdWUgdGhhdCBvY2N1cnMgd2hlbiBwb2ludHMgb3ZlcmxhcCBhbmQgZWFyY3V0IGZhaWxzIHRvIHRyaWFuZ3VsYXRlIHRoZSBpdGVtLlxuICAgIC8vIFRPRE8gLSBmaXggdGhpcyBwcm9wZXJseSwgdGhpcyBpcyBub3QgdmVyeSBlbGVnYW50Li4gYnV0IGl0IHdvcmtzIGZvciBub3cuXG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmZpbGwpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gKDAsIF91dGlscy5oZXgycmdiKShncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHZlY1BvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9ICgwLCBfZWFyY3V0Mi5kZWZhdWx0KShyZWNQb2ludHMsIG51bGwsIDIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGo7IGkgKz0gMykge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVjUG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2ogPSByZWNQb2ludHMubGVuZ3RoOyBfaSA8IF9qOyBfaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHJlY1BvaW50c1tfaV0sIHJlY1BvaW50c1srK19pXSwgciwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSByZWNQb2ludHM7XG5cbiAgICAgICAgKDAsIF9idWlsZExpbmUyLmRlZmF1bHQpKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGEgc2luZ2xlIHBvaW50IGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHVzZWQgYnkgcXVhZHJhdGljQmV6aWVyQ3VydmUuXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4xIC0gZmlyc3QgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gbjIgLSBzZWNvbmQgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyYyAtIHBlcmNlbnRhZ2VcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHJlc3VsdFxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0UHQobjEsIG4yLCBwZXJjKSB7XG4gICAgdmFyIGRpZmYgPSBuMiAtIG4xO1xuXG4gICAgcmV0dXJuIG4xICsgZGlmZiAqIHBlcmM7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS4gKGhlbHBlciBmdW5jdGlvbi4uKVxuICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVggLSBPcmlnaW4gcG9pbnQgeFxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21ZIC0gT3JpZ2luIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHBhcmFtIHtudW1iZXJbXX0gW291dD1bXV0gLSBUaGUgb3V0cHV0IGFycmF5IHRvIGFkZCBwb2ludHMgaW50by4gSWYgbm90IHBhc3NlZCwgYSBuZXcgYXJyYXkgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSBvZiBwb2ludHNcbiAqL1xuZnVuY3Rpb24gcXVhZHJhdGljQmV6aWVyQ3VydmUoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1kpIHtcbiAgICB2YXIgb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBbXTtcblxuICAgIHZhciBuID0gMjA7XG4gICAgdmFyIHBvaW50cyA9IG91dDtcblxuICAgIHZhciB4YSA9IDA7XG4gICAgdmFyIHlhID0gMDtcbiAgICB2YXIgeGIgPSAwO1xuICAgIHZhciB5YiA9IDA7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgaiA9IGkgLyBuO1xuXG4gICAgICAgIC8vIFRoZSBHcmVlbiBMaW5lXG4gICAgICAgIHhhID0gZ2V0UHQoZnJvbVgsIGNwWCwgaik7XG4gICAgICAgIHlhID0gZ2V0UHQoZnJvbVksIGNwWSwgaik7XG4gICAgICAgIHhiID0gZ2V0UHQoY3BYLCB0b1gsIGopO1xuICAgICAgICB5YiA9IGdldFB0KGNwWSwgdG9ZLCBqKTtcblxuICAgICAgICAvLyBUaGUgQmxhY2sgRG90XG4gICAgICAgIHggPSBnZXRQdCh4YSwgeGIsIGopO1xuICAgICAgICB5ID0gZ2V0UHQoeWEsIHliLCBqKTtcblxuICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRSb3VuZGVkUmVjdGFuZ2xlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL2dyYXBoaWNzL3dlYmdsL3V0aWxzL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoZSBQb2ludCBvYmplY3QgcmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgdHdvLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUgc3lzdGVtLCB3aGVyZSB4IHJlcHJlc2VudHNcbiAqIHRoZSBob3Jpem9udGFsIGF4aXMgYW5kIHkgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgYXhpcy5cbiAqIEFuIG9ic2VydmFibGUgcG9pbnQgaXMgYSBwb2ludCB0aGF0IHRyaWdnZXJzIGEgY2FsbGJhY2sgd2hlbiB0aGUgcG9pbnQncyBwb3NpdGlvbiBpcyBjaGFuZ2VkLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIE9ic2VydmFibGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIHdoZW4gY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzY29wZSAtIG93bmVyIG9mIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVQb2ludChjYiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYnNlcnZhYmxlUG9pbnQpO1xuXG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcblxuICAgICAgICB0aGlzLmNiID0gY2I7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyB4IGFuZCB5IHBvc2l0aW9uLlxuICAgICAqIElmIHkgaXMgb21pdHRlZCwgYm90aCB4IGFuZCB5IHdpbGwgYmUgc2V0IHRvIHguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAgICovXG5cblxuICAgIE9ic2VydmFibGVQb2ludC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHgsIHkpIHtcbiAgICAgICAgdmFyIF94ID0geCB8fCAwO1xuICAgICAgICB2YXIgX3kgPSB5IHx8ICh5ICE9PSAwID8gX3ggOiAwKTtcblxuICAgICAgICBpZiAodGhpcy5feCAhPT0gX3ggfHwgdGhpcy5feSAhPT0gX3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBfeDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBfeTtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIGRhdGEgZnJvbSBhbm90aGVyIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR8UElYSS5PYnNlcnZhYmxlUG9pbnR9IHBvaW50IC0gcG9pbnQgdG8gY29weSBmcm9tXG4gICAgICovXG5cblxuICAgIE9ic2VydmFibGVQb2ludC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IHBvaW50LnggfHwgdGhpcy5feSAhPT0gcG9pbnQueSkge1xuICAgICAgICAgICAgdGhpcy5feCA9IHBvaW50Lng7XG4gICAgICAgICAgICB0aGlzLl95ID0gcG9pbnQueTtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVQb2ludCwgW3tcbiAgICAgICAga2V5OiBcInhcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5feCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwieVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl95ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT2JzZXJ2YWJsZVBvaW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBPYnNlcnZhYmxlUG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlUG9pbnQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvbWF0aC9PYnNlcnZhYmxlUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcblxudmFyIF9SZWN0YW5nbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVjdGFuZ2xlKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhlIENpcmNsZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENpcmNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MF0gLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICovXG4gIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHg7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLkNJUkNcbiAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5DSVJDO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIENpcmNsZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJuIHtQSVhJLkNpcmNsZX0gYSBjb3B5IG9mIHRoZSBDaXJjbGVcbiAgICovXG5cblxuICBDaXJjbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIENpcmNsZVxuICAgKi9cblxuXG4gIENpcmNsZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMucmFkaXVzIDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIHZhciBkeCA9IHRoaXMueCAtIHg7XG4gICAgdmFyIGR5ID0gdGhpcy55IC0geTtcblxuICAgIGR4ICo9IGR4O1xuICAgIGR5ICo9IGR5O1xuXG4gICAgcmV0dXJuIGR4ICsgZHkgPD0gcjI7XG4gIH07XG5cbiAgLyoqXG4gICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGNpcmNsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgKlxuICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiAgKi9cblxuXG4gIENpcmNsZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gZ2V0Qm91bmRzKCkge1xuICAgIHJldHVybiBuZXcgX1JlY3RhbmdsZTIuZGVmYXVsdCh0aGlzLnggLSB0aGlzLnJhZGl1cywgdGhpcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyKTtcbiAgfTtcblxuICByZXR1cm4gQ2lyY2xlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaXJjbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvbWF0aC9zaGFwZXMvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XG5cbnZhciBfUmVjdGFuZ2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY3RhbmdsZSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoZSBFbGxpcHNlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgRWxsaXBzZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFRoZSBoYWxmIHdpZHRoIG9mIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGlzIGVsbGlwc2VcbiAgICovXG4gIGZ1bmN0aW9uIEVsbGlwc2UoKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxsaXBzZSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHg7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuRUxJUFxuICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBfY29uc3QuU0hBUEVTLkVMSVA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgRWxsaXBzZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJuIHtQSVhJLkVsbGlwc2V9IGEgY29weSBvZiB0aGUgZWxsaXBzZVxuICAgKi9cblxuXG4gIEVsbGlwc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZHMgYXJlIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICovXG5cblxuICBFbGxpcHNlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgdGhlIGNvb3JkcyB0byBhbiBlbGxpcHNlIHdpdGggY2VudGVyIDAsMFxuICAgIHZhciBub3JteCA9ICh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGg7XG4gICAgdmFyIG5vcm15ID0gKHkgLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHQ7XG5cbiAgICBub3JteCAqPSBub3JteDtcbiAgICBub3JteSAqPSBub3JteTtcblxuICAgIHJldHVybiBub3JteCArIG5vcm15IDw9IDE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuXG5cbiAgRWxsaXBzZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gZ2V0Qm91bmRzKCkge1xuICAgIHJldHVybiBuZXcgX1JlY3RhbmdsZTIuZGVmYXVsdCh0aGlzLnggLSB0aGlzLndpZHRoLCB0aGlzLnkgLSB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9O1xuXG4gIHJldHVybiBFbGxpcHNlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFbGxpcHNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxsaXBzZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9tYXRoL3NoYXBlcy9FbGxpcHNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BvaW50ID0gcmVxdWlyZSgnLi4vUG9pbnQnKTtcblxudmFyIF9Qb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2ludCk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFBvbHlnb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50W118bnVtYmVyW119IHBvaW50cyAtIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50c1xuICAgICAqICB0aGF0IGZvcm0gdGhlIHBvbHlnb24sIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzIHRoYXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBbeCx5LCB4LHksIC4uLl0sIG9yXG4gICAgICogIHRoZSBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBhbGwgdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvbiBlLmcuXG4gICAgICogIGBuZXcgUElYSS5Qb2x5Z29uKG5ldyBQSVhJLlBvaW50KCksIG5ldyBQSVhJLlBvaW50KCksIC4uLilgLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdFxuICAgICAqICB4LHkgdmFsdWVzIGUuZy4gYG5ldyBQb2x5Z29uKHgseSwgeCx5LCB4LHksIC4uLilgIHdoZXJlIGB4YCBhbmQgYHlgIGFyZSBOdW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwb2ludHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIHBvaW50c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5Z29uKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHNbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGFycmF5IG9mIHBvaW50cywgY29udmVydCBpdCB0byBhIGZsYXQgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAgICBpZiAocG9pbnRzWzBdIGluc3RhbmNlb2YgX1BvaW50Mi5kZWZhdWx0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgICAgIHAucHVzaChwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb2ludHMgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB0aGUgcG9pbnRzIG9mIHRoaXMgcG9seWdvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlBPTFlcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5QT0xZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9seWdvbn0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXG4gICAgICovXG5cblxuICAgIFBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLnBvaW50cy5zbGljZSgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBwb2x5Z29uLCBhZGRpbmcgcG9pbnRzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBQb2x5Z29uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICAgICAgLy8gY2xvc2UgdGhlIHBvbHkgaWYgdGhlIHZhbHVlIGlzIHRydWUhXG4gICAgICAgIGlmIChwb2ludHNbMF0gIT09IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gfHwgcG9pbnRzWzFdICE9PSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb25cbiAgICAgKi9cblxuXG4gICAgUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyh4LCB5KSB7XG4gICAgICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcblxuICAgICAgICAvLyB1c2Ugc29tZSByYXljYXN0aW5nIHRvIHRlc3QgaGl0c1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHZhciB4aSA9IHRoaXMucG9pbnRzW2kgKiAyXTtcbiAgICAgICAgICAgIHZhciB5aSA9IHRoaXMucG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgICAgICB2YXIgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICAgICAgICB2YXIgeWogPSB0aGlzLnBvaW50c1tqICogMiArIDFdO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IHlpID4geSAhPT0geWogPiB5ICYmIHggPCAoeGogLSB4aSkgKiAoKHkgLSB5aSkgLyAoeWogLSB5aSkpICsgeGk7XG5cbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBvbHlnb247XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBvbHlnb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL21hdGgvc2hhcGVzL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoZSBSb3VuZGVkIFJlY3RhbmdsZSBvYmplY3QgaXMgYW4gYXJlYSB0aGF0IGhhcyBuaWNlIHJvdW5kZWQgY29ybmVycywgYXMgaW5kaWNhdGVkIGJ5IGl0c1xuICogdG9wLWxlZnQgY29ybmVyIHBvaW50ICh4LCB5KSBhbmQgYnkgaXRzIHdpZHRoIGFuZCBpdHMgaGVpZ2h0IGFuZCBpdHMgcmFkaXVzLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFJvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGlzIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MjBdIC0gQ29udHJvbHMgdGhlIHJhZGl1cyBvZiB0aGUgcm91bmRlZCBjb3JuZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUm91bmRlZFJlY3RhbmdsZSgpIHtcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDIwO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3VuZGVkUmVjdGFuZ2xlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5SUkVDXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IF9jb25zdC5TSEFQRVMuUlJFQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICovXG5cblxuICAgIFJvdW5kZWRSZWN0YW5nbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqL1xuXG5cbiAgICBSb3VuZGVkUmVjdGFuZ2xlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+PSB0aGlzLnkgKyB0aGlzLnJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5yYWRpdXMgfHwgeCA+PSB0aGlzLnggKyB0aGlzLnJhZGl1cyAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggLSB0aGlzLnJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geSAtICh0aGlzLnkgKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1czIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gUm91bmRlZFJlY3RhbmdsZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91bmRlZFJlY3RhbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvdW5kZWRSZWN0YW5nbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvbWF0aC9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgdG8gaGFuZGxlIG1hc2tpbmcuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgQ2FudmFzTWFza01hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FudmFzTWFza01hbmFnZXIocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc01hc2tNYW5hZ2VyKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYWRkcyBpdCB0byB0aGUgY3VycmVudCBzdGFjayBvZiBtYXNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtYXNrRGF0YSAtIHRoZSBtYXNrRGF0YSB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gICAgICovXG5cblxuICAgIENhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoTWFzayA9IGZ1bmN0aW9uIHB1c2hNYXNrKG1hc2tEYXRhKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgICAgcmVuZGVyZXIuY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgdmFyIGNhY2hlQWxwaGEgPSBtYXNrRGF0YS5hbHBoYTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG1hc2tEYXRhLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLmIgKiByZXNvbHV0aW9uLCB0cmFuc2Zvcm0uYyAqIHJlc29sdXRpb24sIHRyYW5zZm9ybS5kICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLnR4ICogcmVzb2x1dGlvbiwgdHJhbnNmb3JtLnR5ICogcmVzb2x1dGlvbik7XG5cbiAgICAgICAgLy8gVE9ETyBzdXBvcnQgc3ByaXRlIGFscGhhIG1hc2tzPz9cbiAgICAgICAgLy8gbG90cyBvZiBlZmZvcnQgcmVxdWlyZWQuIElmIGRlbWFuZCBpcyBncmVhdCBlbm91Z2guLlxuICAgICAgICBpZiAoIW1hc2tEYXRhLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyYXBoaWNzU2hhcGUobWFza0RhdGEpO1xuICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrRGF0YS53b3JsZEFscGhhID0gY2FjaGVBbHBoYTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIFBJWEkuR3JhcGhpY3Mgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gVGhlIG9iamVjdCB0byByZW5kZXIuXG4gICAgICovXG5cblxuICAgIENhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXJHcmFwaGljc1NoYXBlID0gZnVuY3Rpb24gcmVuZGVyR3JhcGhpY3NTaGFwZShncmFwaGljcykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucmVuZGVyZXIuY29udGV4dDtcbiAgICAgICAgdmFyIGxlbiA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YVtpXTtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGU7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUE9MWSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG5cbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBvaW50cy5sZW5ndGggLyAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzW2ogKiAyICsgMV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcmUgdGhlIHNhbWUgY2xvc2UgdGhlIHBhdGggLSBtdWNoIG5lYXRlciA6KVxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbMF0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gJiYgcG9pbnRzWzFdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUkVDVCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuQ0lSQykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuRUxJUCkge1xuICAgICAgICAgICAgICAgIC8vIGVsbGlwc2UgY29kZSB0YWtlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcblxuICAgICAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggKiAyO1xuICAgICAgICAgICAgICAgIHZhciBoID0gc2hhcGUuaGVpZ2h0ICogMjtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueCAtIHcgLyAyO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueSAtIGggLyAyO1xuXG4gICAgICAgICAgICAgICAgdmFyIGthcHBhID0gMC41NTIyODQ4O1xuICAgICAgICAgICAgICAgIHZhciBveCA9IHcgLyAyICoga2FwcGE7IC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgICAgICAgICAgICB2YXIgb3kgPSBoIC8gMiAqIGthcHBhOyAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgIHZhciB4ZSA9IHggKyB3OyAvLyB4LWVuZFxuICAgICAgICAgICAgICAgIHZhciB5ZSA9IHkgKyBoOyAvLyB5LWVuZFxuICAgICAgICAgICAgICAgIHZhciB4bSA9IHggKyB3IC8gMjsgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICB2YXIgeW0gPSB5ICsgaCAvIDI7IC8vIHktbWlkZGxlXG5cbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5bSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IF9jb25zdC5TSEFQRVMuUlJFQykge1xuICAgICAgICAgICAgICAgIHZhciByeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgdmFyIHJ5ID0gc2hhcGUueTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBzaGFwZS5yYWRpdXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIHwgMDtcblxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IHJhZGl1cyA+IG1heFJhZGl1cyA/IG1heFJhZGl1cyA6IHJhZGl1cztcblxuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocngsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocngsIHJ5ICsgaGVpZ2h0LCByeCArIHJhZGl1cywgcnkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGggLSByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocnggKyB3aWR0aCwgcnkgKyBoZWlnaHQsIHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoLCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5LCByeCArIHdpZHRoIC0gcmFkaXVzLCByeSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyByYWRpdXMsIHJ5KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocngsIHJ5LCByeCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBjb250ZXh0IHRvIHRoZSBzdGF0ZSBpdCB3YXMgYmVmb3JlIHRoZSBtYXNrIHdhcyBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciBjb250ZXh0IHRvIHVzZS5cbiAgICAgKi9cblxuXG4gICAgQ2FudmFzTWFza01hbmFnZXIucHJvdG90eXBlLnBvcE1hc2sgPSBmdW5jdGlvbiBwb3BNYXNrKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGNhbnZhcyBtYXNrIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzTWFza01hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAvKiBlbXB0eSAqL1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FudmFzTWFza01hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc01hc2tNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzTWFza01hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNNYXNrTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG52YXIgX2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMgPSByZXF1aXJlKCcuL2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMnKTtcblxudmFyIF9jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIE1hcHMgYmxlbmQgY29tYmluYXRpb25zIHRvIENhbnZhcy5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGZ1bmN0aW9uIG1hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJyYXk9W11dIC0gVGhlIGFycmF5IHRvIG91dHB1dCBpbnRvLlxuICogQHJldHVybiB7c3RyaW5nW119IE1hcHBlZCBtb2Rlcy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aSgpIHtcbiAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgaWYgKCgwLCBfY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlczIuZGVmYXVsdCkoKSkge1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5BRERdID0gJ2xpZ2h0ZXInOyAvLyBJUyBUSElTIE9LPz8/XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5NVUxUSVBMWV0gPSAnbXVsdGlwbHknO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0NSRUVOXSA9ICdzY3JlZW4nO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gPSAnb3ZlcmxheSc7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5EQVJLRU5dID0gJ2Rhcmtlbic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5MSUdIVEVOXSA9ICdsaWdodGVuJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SX0RPREdFXSA9ICdjb2xvci1kb2RnZSc7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5DT0xPUl9CVVJOXSA9ICdjb2xvci1idXJuJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhBUkRfTElHSFRdID0gJ2hhcmQtbGlnaHQnO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gPSAnc29mdC1saWdodCc7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5ESUZGRVJFTkNFXSA9ICdkaWZmZXJlbmNlJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gPSAnZXhjbHVzaW9uJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhVRV0gPSAnaHVlJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLlNBVFVSQVRJT05dID0gJ3NhdHVyYXRlJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SXSA9ICdjb2xvcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSA9ICdsdW1pbm9zaXR5JztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY29vbCBuZXcgYmxlbmQgbW9kZXMgaW4gY2FudmFzICdjb3VnaCcgaWUgJ2NvdWdoJ1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5BRERdID0gJ2xpZ2h0ZXInOyAvLyBJUyBUSElTIE9LPz8/XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5NVUxUSVBMWV0gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0NSRUVOXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5PVkVSTEFZXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5EQVJLRU5dID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkxJR0hURU5dID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SX0RPREdFXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5DT0xPUl9CVVJOXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5TT0ZUX0xJR0hUXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5ESUZGRVJFTkNFXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5FWENMVVNJT05dID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhVRV0gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuQ09MT1JdID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkxVTUlOT1NJVFldID0gJ3NvdXJjZS1vdmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBDYW52YXNCbGVuZE1vZGVzVG9QaXhpLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvbWFwQ2FudmFzQmxlbmRNb2Rlc1RvUGl4aS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuLi8uLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUZXh0dXJlR2FyYmFnZUNvbGxlY3Rvci4gVGhpcyBjbGFzcyBtYW5hZ2VzIHRoZSBHUFUgYW5kIGVuc3VyZXMgdGhhdCBpdCBkb2VzIG5vdCBnZXQgY2xvZ2dlZFxuICogdXAgd2l0aCB0ZXh0dXJlcyB0aGF0IGFyZSBubyBsb25nZXIgYmVpbmcgdXNlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUZXh0dXJlR2FyYmFnZUNvbGxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0dXJlR2FyYmFnZUNvbGxlY3RvcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3IpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tYXhJZGxlID0gX3NldHRpbmdzMi5kZWZhdWx0LkdDX01BWF9JRExFO1xuICAgICAgICB0aGlzLmNoZWNrQ291bnRNYXggPSBfc2V0dGluZ3MyLmRlZmF1bHQuR0NfTUFYX0NIRUNLX0NPVU5UO1xuICAgICAgICB0aGlzLm1vZGUgPSBfc2V0dGluZ3MyLmRlZmF1bHQuR0NfTU9ERTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWRcbiAgICAgKiBpZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlR2FyYmFnZUNvbGxlY3Rvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmNvdW50Kys7XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gX2NvbnN0LkdDX01PREVTLk1BTlVBTCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja0NvdW50Kys7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDb3VudCA+IHRoaXMuY2hlY2tDb3VudE1heCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWRcbiAgICAgKiBpZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVVxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlR2FyYmFnZUNvbGxlY3Rvci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVNYW5hZ2VyO1xuICAgICAgICB2YXIgbWFuYWdlZFRleHR1cmVzID0gdG0uX21hbmFnZWRUZXh0dXJlcztcbiAgICAgICAgdmFyIHdhc1JlbW92ZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBtYW5hZ2VkVGV4dHVyZXNbaV07XG5cbiAgICAgICAgICAgIC8vIG9ubHkgc3VwcG9ydHMgbm9uIGdlbmVyYXRlZCB0ZXh0dXJlcyBhdCB0aGUgbW9tZW50IVxuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlLl9nbFJlbmRlclRhcmdldHMgJiYgdGhpcy5jb3VudCAtIHRleHR1cmUudG91Y2hlZCA+IHRoaXMubWF4SWRsZSkge1xuICAgICAgICAgICAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2FzUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2FzUmVtb3ZlZCkge1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VkVGV4dHVyZXNbX2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tqKytdID0gbWFuYWdlZFRleHR1cmVzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlcy5sZW5ndGggPSBqO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSB0ZXh0dXJlcyB3aXRoaW4gdGhlIHNwZWNpZmllZCBkaXNwbGF5T2JqZWN0IGFuZCBpdHMgY2hpbGRyZW4gZnJvbSB0aGUgR1BVXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIHRoZSBkaXNwbGF5T2JqZWN0IHRvIHJlbW92ZSB0aGUgdGV4dHVyZXMgZnJvbS5cbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3IucHJvdG90eXBlLnVubG9hZCA9IGZ1bmN0aW9uIHVubG9hZChkaXNwbGF5T2JqZWN0KSB7XG4gICAgICAgIHZhciB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZU1hbmFnZXI7XG5cbiAgICAgICAgLy8gb25seSBkZXN0cm95IG5vbiBnZW5lcmF0ZWQgdGV4dHVyZXNcbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuX3RleHR1cmUgJiYgZGlzcGxheU9iamVjdC5fdGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzKSB7XG4gICAgICAgICAgICB0bS5kZXN0cm95VGV4dHVyZShkaXNwbGF5T2JqZWN0Ll90ZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnVubG9hZChkaXNwbGF5T2JqZWN0LmNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3I7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHR1cmVHYXJiYWdlQ29sbGVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZUdhcmJhZ2VDb2xsZWN0b3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1RleHR1cmVHYXJiYWdlQ29sbGVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbnZhciBfUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi91dGlscy9SZW5kZXJUYXJnZXQnKTtcblxudmFyIF9SZW5kZXJUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVuZGVyVGFyZ2V0KTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHdlYkdMIFRleHR1cmVcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHR1cmVNYW5hZ2VyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0dXJlTWFuYWdlcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuV2ViR0xSZW5kZXJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFjayB0ZXh0dXJlcyBpbiB0aGUgcmVuZGVyZXIgc28gd2UgY2FuIG5vIGxvbmdlciBsaXN0ZW4gdG8gdGhlbSBvbiBkZXN0cnVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8Kj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIHRleHR1cmUuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmJpbmRUZXh0dXJlID0gZnVuY3Rpb24gYmluZFRleHR1cmUoKSB7fVxuICAgIC8vIGVtcHR5XG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSB0ZXh0dXJlLlxuICAgICAqXG4gICAgICovXG4gICAgO1xuXG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbiBnZXRUZXh0dXJlKCkge31cbiAgICAvLyBlbXB0eVxuXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuZC9vciBDcmVhdGVzIGEgV2ViR0wgdGV4dHVyZSBmb3IgdGhlIHJlbmRlcmVyJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9jYXRpb24gLSB0aGUgbG9jYXRpb24gdGhlIHRleHR1cmUgd2lsbCBiZSBib3VuZCB0by5cbiAgICAgKiBAcmV0dXJuIHtHTFRleHR1cmV9IFRoZSBnbCB0ZXh0dXJlLlxuICAgICAqL1xuICAgIDtcblxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gdXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCBsb2NhdGlvbikge1xuICAgICAgICAvLyBhc3N1bWUgaXQgZ29vZCFcbiAgICAgICAgLy8gdGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUgfHwgdGV4dHVyZTtcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIHZhciBpc1JlbmRlclRleHR1cmUgPSAhIXRleHR1cmUuX2dsUmVuZGVyVGFyZ2V0cztcblxuICAgICAgICBpZiAoIXRleHR1cmUuaGFzTG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZFRleHR1cmVzID0gdGhpcy5yZW5kZXJlci5ib3VuZFRleHR1cmVzO1xuXG4gICAgICAgIC8vIGlmIHRoZSBsb2NhdGlvbiBpcyB1bmRlZmluZWQgdGhlbiB0aGlzIG1heSBoYXZlIGJlZW4gY2FsbGVkIGJ5IG4gZXZlbnQuXG4gICAgICAgIC8vIHRoaXMgYmVpbmcgdGhlIGNhc2UgdGhlIHRleHR1cmUgbWF5IGFscmVhZHkgYmUgYm91bmQgdG8gYSBzbG90LiBBcyBhIHRleHR1cmUgY2FuIG9ubHkgYmUgYm91bmQgb25jZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZpbmQgaXRzIGN1cnJlbnQgbG9jYXRpb24gaWYgaXQgZXhpc3RzLlxuICAgICAgICBpZiAobG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSAwO1xuXG4gICAgICAgICAgICAvLyBUT0RPIG1heWJlIHdlIGNhbiB1c2UgdGV4dHVyZSBib3VuZCBpZHMgbGF0ZXIgb24uLi5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRleHR1cmUgaXMgYWxyZWFkeSBib3VuZC4uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kVGV4dHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRUZXh0dXJlc1tpXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gdGV4dHVyZTtcblxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuXG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAoaXNSZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IG5ldyBfUmVuZGVyVGFyZ2V0Mi5kZWZhdWx0KHRoaXMuZ2wsIHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCB0ZXh0dXJlLnNjYWxlTW9kZSwgdGV4dHVyZS5yZXNvbHV0aW9uKTtcblxuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldC5yZXNpemUodGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuX2dsUmVuZGVyVGFyZ2V0c1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSA9IHJlbmRlclRhcmdldDtcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlID0gbmV3IF9waXhpR2xDb3JlLkdMVGV4dHVyZSh0aGlzLmdsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUuYmluZChsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS51cGxvYWQodGV4dHVyZS5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xUZXh0dXJlO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLnVwZGF0ZVRleHR1cmUsIHRoaXMpO1xuICAgICAgICAgICAgdGV4dHVyZS5vbignZGlzcG9zZScsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcblxuICAgICAgICAgICAgaWYgKHRleHR1cmUuaXNQb3dlck9mVHdvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUubWlwbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVNaXBtYXAoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZS53cmFwTW9kZSA9PT0gX2NvbnN0LldSQVBfTU9ERVMuQ0xBTVApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xUZXh0dXJlLmVuYWJsZVdyYXBDbGFtcCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dHVyZS53cmFwTW9kZSA9PT0gX2NvbnN0LldSQVBfTU9ERVMuUkVQRUFUKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVXcmFwUmVwZWF0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xUZXh0dXJlLmVuYWJsZVdyYXBNaXJyb3JSZXBlYXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVXcmFwQ2xhbXAoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHR1cmUuc2NhbGVNb2RlID09PSBfY29uc3QuU0NBTEVfTU9ERVMuTkVBUkVTVCkge1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5lbmFibGVOZWFyZXN0U2NhbGluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUuZW5hYmxlTGluZWFyU2NhbGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSB0ZXh0dXJlIGFscmVhZHkgZXhpc3RzIHNvIHdlIG9ubHkgbmVlZCB0byB1cGRhdGUgaXQuLlxuICAgICAgICBlbHNlIGlmIChpc1JlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl9nbFJlbmRlclRhcmdldHNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0ucmVzaXplKHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlLnVwbG9hZCh0ZXh0dXJlLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsVGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gdGhlIHRleHR1cmUgdG8gZGVzdHJveVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmU9ZmFsc2VdIC0gV2hldGhlciB0byBza2lwIHJlbW92aW5nIHRoZSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVNYW5hZ2VyLlxuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveVRleHR1cmUgPSBmdW5jdGlvbiBkZXN0cm95VGV4dHVyZSh0ZXh0dXJlLCBza2lwUmVtb3ZlKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHRleHR1cmU7XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudW5iaW5kVGV4dHVyZSh0ZXh0dXJlKTtcblxuICAgICAgICAgICAgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0ZXh0dXJlLm9mZigndXBkYXRlJywgdGhpcy51cGRhdGVUZXh0dXJlLCB0aGlzKTtcbiAgICAgICAgICAgIHRleHR1cmUub2ZmKCdkaXNwb3NlJywgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgICAgICBpZiAoIXNraXBSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMuX21hbmFnZWRUZXh0dXJlcy5pbmRleE9mKHRleHR1cmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMucmVtb3ZlSXRlbXMpKHRoaXMuX21hbmFnZWRUZXh0dXJlcywgaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYWxsIHRoZSB0ZXh0dXJlcyBmcm9tIFdlYkdMXG4gICAgICovXG5cblxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICAgIC8vIGVtcHR5IGFsbCB0aGUgb2xkIGdsIHRleHR1cmVzIGFzIHRoZXkgYXJlIHVzZWxlc3Mgbm93XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX21hbmFnZWRUZXh0dXJlc1tpXTtcblxuICAgICAgICAgICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG1hbmFnZXIgYW5kIHJlbW92ZXMgYWxsIGl0cyB0ZXh0dXJlc1xuICAgICAqL1xuXG5cbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIGRlc3Ryb3kgbWFuYWdlZCB0ZXh0dXJlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21hbmFnZWRUZXh0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl9tYW5hZ2VkVGV4dHVyZXNbaV07XG5cbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVRleHR1cmUodGV4dHVyZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRleHR1cmUub2ZmKCd1cGRhdGUnLCB0aGlzLnVwZGF0ZVRleHR1cmUsIHRoaXMpO1xuICAgICAgICAgICAgdGV4dHVyZS5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hbmFnZWRUZXh0dXJlcyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBUZXh0dXJlTWFuYWdlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGV4dHVyZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlTWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvVGV4dHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpID0gcmVxdWlyZSgnLi91dGlscy9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGknKTtcblxudmFyIF9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJMRU5EID0gMDtcbnZhciBERVBUSF9URVNUID0gMTtcbnZhciBGUk9OVF9GQUNFID0gMjtcbnZhciBDVUxMX0ZBQ0UgPSAzO1xudmFyIEJMRU5EX0ZVTkMgPSA0O1xuXG4vKipcbiAqIEEgV2ViR0wgc3RhdGUgbWFjaGluZXNcbiAqXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGNsYXNzXG4gKi9cblxudmFyIFdlYkdMU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJHTFN0YXRlKGdsKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTFN0YXRlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzdGF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBibGVuZCBtb2RlLi5cbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGVbMF0gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBpbmRleCBpbiB0aGUgc3RhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFja0luZGV4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YWNrIGhvbGRpbmcgYWxsIHRoZSBkaWZmZXJlbnQgc3RhdGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PCo+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAgICAgdGhpcy5tYXhBdHRyaWJzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG5cbiAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZSA9IHtcbiAgICAgICAgICAgIHRlbXBBdHRyaWJTdGF0ZTogbmV3IEFycmF5KHRoaXMubWF4QXR0cmlicyksXG4gICAgICAgICAgICBhdHRyaWJTdGF0ZTogbmV3IEFycmF5KHRoaXMubWF4QXR0cmlicylcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmJsZW5kTW9kZXMgPSAoMCwgX21hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aTIuZGVmYXVsdCkoZ2wpO1xuXG4gICAgICAgIC8vIGNoZWNrIHdlIGhhdmUgdmFvLi5cbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdNT1pfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIG5ldyBhY3RpdmUgc3RhdGVcbiAgICAgKi9cblxuXG4gICAgV2ViR0xTdGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICAgIC8vIG5leHQgc3RhdGUuLlxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2tJbmRleF07XG5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2tJbmRleF0gPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuc3RhY2tJbmRleDtcblxuICAgICAgICAvLyBjb3B5IHN0YXRlLi5cbiAgICAgICAgLy8gc2V0IGFjdGl2ZSBzdGF0ZSBzbyB3ZSBjYW4gZm9yY2Ugb3ZlcnJpZGVzIG9mIGdsIHN0YXRlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVTdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RhdGVbaV0gPSB0aGlzLmFjdGl2ZVN0YXRlW2ldO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBvcHMgYSBzdGF0ZSBvdXRcbiAgICAgKi9cblxuXG4gICAgV2ViR0xTdGF0ZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YWNrWy0tdGhpcy5zdGFja0luZGV4XTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXQuXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZChzdGF0ZVtCTEVORF0pO1xuICAgICAgICB0aGlzLnNldERlcHRoVGVzdChzdGF0ZVtERVBUSF9URVNUXSk7XG4gICAgICAgIHRoaXMuc2V0RnJvbnRGYWNlKHN0YXRlW0ZST05UX0ZBQ0VdKTtcbiAgICAgICAgdGhpcy5zZXRDdWxsRmFjZShzdGF0ZVtDVUxMX0ZBQ0VdKTtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoc3RhdGVbQkxFTkRfRlVOQ10pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVkIGJsZW5kaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGJsZW5kaW5nLlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFN0YXRlLnByb3RvdHlwZS5zZXRCbGVuZCA9IGZ1bmN0aW9uIHNldEJsZW5kKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyAxIDogMDtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVTdGF0ZVtCTEVORF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW0JMRU5EXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuQkxFTkQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGJsZW5kIG1vZGUgdG8gc2V0IHRvLlxuICAgICAqL1xuXG5cbiAgICBXZWJHTFN0YXRlLnByb3RvdHlwZS5zZXRCbGVuZE1vZGUgPSBmdW5jdGlvbiBzZXRCbGVuZE1vZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLmFjdGl2ZVN0YXRlW0JMRU5EX0ZVTkNdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW0JMRU5EX0ZVTkNdID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5nbC5ibGVuZEZ1bmModGhpcy5ibGVuZE1vZGVzW3ZhbHVlXVswXSwgdGhpcy5ibGVuZE1vZGVzW3ZhbHVlXVsxXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBkZXB0aCB0ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGRlcHRoIHRlc3RpbmcuXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnNldERlcHRoVGVzdCA9IGZ1bmN0aW9uIHNldERlcHRoVGVzdCh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID8gMSA6IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU3RhdGVbREVQVEhfVEVTVF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW0RFUFRIX1RFU1RdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xbdmFsdWUgPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10odGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGN1bGwgZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBjdWxsIGZhY2UuXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnNldEN1bGxGYWNlID0gZnVuY3Rpb24gc2V0Q3VsbEZhY2UodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IDEgOiAwO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVN0YXRlW0NVTExfRkFDRV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW0NVTExfRkFDRV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdsIGZyb250IGZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gdHJ1ZSBpcyBjbG9ja3dpc2UgYW5kIGZhbHNlIGlzIGNvdW50ZXItY2xvY2t3aXNlXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnNldEZyb250RmFjZSA9IGZ1bmN0aW9uIHNldEZyb250RmFjZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID8gMSA6IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU3RhdGVbRlJPTlRfRkFDRV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW0ZST05UX0ZBQ0VdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2wuZnJvbnRGYWNlKHRoaXMuZ2xbdmFsdWUgPyAnQ1cnIDogJ0NDVyddKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYWxsIHRoZSB2YW9zIGluIHVzZVxuICAgICAqXG4gICAgICovXG5cblxuICAgIFdlYkdMU3RhdGUucHJvdG90eXBlLnJlc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHJlc2V0QXR0cmlidXRlcygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYlN0YXRlLnRlbXBBdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZS50ZW1wQXR0cmliU3RhdGVbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuYXR0cmliU3RhdGUuYXR0cmliU3RhdGUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYlN0YXRlLmF0dHJpYlN0YXRlW19pXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbSBnb2luZyB0byBhc3N1bWUgb25lIGlzIGFsd2F5cyBhY3RpdmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDE7IF9pMiA8IHRoaXMubWF4QXR0cmliczsgX2kyKyspIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KF9pMik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdXNlZFxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgdGhlIGxvZ2ljIGFuZCBkaXNhYmxlcyB0aGUgdmFvc1xuICAgICAqL1xuXG5cbiAgICBXZWJHTFN0YXRlLnByb3RvdHlwZS5yZXNldFRvRGVmYXVsdCA9IGZ1bmN0aW9uIHJlc2V0VG9EZWZhdWx0KCkge1xuICAgICAgICAvLyB1bmJpbmQgYW55IFZBTyBpZiB0aGV5IGV4aXN0Li5cbiAgICAgICAgaWYgKHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCBhbGwgYXR0cmlidXRlcy4uXG4gICAgICAgIHRoaXMucmVzZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgLy8gc2V0IGFjdGl2ZSBzdGF0ZSBzbyB3ZSBjYW4gZm9yY2Ugb3ZlcnJpZGVzIG9mIGdsIHN0YXRlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVTdGF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZVtpXSA9IDMyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdlYkdMU3RhdGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdlYkdMU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJHTFN0YXRlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9XZWJHTFN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXh0cmFjdFVuaWZvcm1zRnJvbVNyYztcblxudmFyIF9waXhpR2xDb3JlID0gcmVxdWlyZSgncGl4aS1nbC1jb3JlJyk7XG5cbnZhciBfcGl4aUdsQ29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waXhpR2xDb3JlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRWYWx1ZSA9IF9waXhpR2xDb3JlMi5kZWZhdWx0LnNoYWRlci5kZWZhdWx0VmFsdWU7XG5cbmZ1bmN0aW9uIGV4dHJhY3RVbmlmb3Jtc0Zyb21TcmModmVydGV4U3JjLCBmcmFnbWVudFNyYywgbWFzaykge1xuICAgIHZhciB2ZXJ0VW5pZm9ybXMgPSBleHRyYWN0VW5pZm9ybXNGcm9tU3RyaW5nKHZlcnRleFNyYywgbWFzayk7XG4gICAgdmFyIGZyYWdVbmlmb3JtcyA9IGV4dHJhY3RVbmlmb3Jtc0Zyb21TdHJpbmcoZnJhZ21lbnRTcmMsIG1hc2spO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odmVydFVuaWZvcm1zLCBmcmFnVW5pZm9ybXMpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VW5pZm9ybXNGcm9tU3RyaW5nKHN0cmluZykge1xuICAgIHZhciBtYXNrUmVnZXggPSBuZXcgUmVnRXhwKCdeKHByb2plY3Rpb25NYXRyaXh8dVNhbXBsZXJ8ZmlsdGVyQXJlYXxmaWx0ZXJDbGFtcCkkJyk7XG5cbiAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICB2YXIgbmFtZVNwbGl0ID0gdm9pZCAwO1xuXG4gICAgLy8gY2xlYW4gdGhlIGxpbmVzIGEgbGl0dGxlIC0gcmVtb3ZlIGV4dHJhIHNwYWNlcyAvIHRhYnMgZXRjXG4gICAgLy8gdGhlbiBzcGxpdCBhbG9uZyAnOydcbiAgICB2YXIgbGluZXMgPSBzdHJpbmcucmVwbGFjZSgvXFxzKy9nLCAnICcpLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaC4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcblxuICAgICAgICBpZiAobGluZS5pbmRleE9mKCd1bmlmb3JtJykgPiAtMSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0TGluZSA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc3BsaXRMaW5lWzFdO1xuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0TGluZVsyXTtcbiAgICAgICAgICAgIHZhciBzaXplID0gMTtcblxuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignWycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSFcbiAgICAgICAgICAgICAgICBuYW1lU3BsaXQgPSBuYW1lLnNwbGl0KC9cXFt8XS8pO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lU3BsaXRbMF07XG4gICAgICAgICAgICAgICAgc2l6ZSAqPSBOdW1iZXIobmFtZVNwbGl0WzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuYW1lLm1hdGNoKG1hc2tSZWdleCkpIHtcbiAgICAgICAgICAgICAgICB1bmlmb3Jtc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlZmF1bHRWYWx1ZSh0eXBlLCBzaXplKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5pZm9ybXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0VW5pZm9ybXNGcm9tU3JjLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL2V4dHJhY3RVbmlmb3Jtc0Zyb21TcmMuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4ID0gY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXg7XG5leHBvcnRzLmNhbGN1bGF0ZU5vcm1hbGl6ZWRTY3JlZW5TcGFjZU1hdHJpeCA9IGNhbGN1bGF0ZU5vcm1hbGl6ZWRTY3JlZW5TcGFjZU1hdHJpeDtcbmV4cG9ydHMuY2FsY3VsYXRlU3ByaXRlTWF0cml4ID0gY2FsY3VsYXRlU3ByaXRlTWF0cml4O1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbi8qXG4gKiBDYWxjdWxhdGVzIHRoZSBtYXBwZWQgbWF0cml4XG4gKiBAcGFyYW0gZmlsdGVyQXJlYSB7UmVjdGFuZ2xlfSBUaGUgZmlsdGVyIGFyZWFcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHRhcmdldCBzcHJpdGVcbiAqIEBwYXJhbSBvdXRwdXRNYXRyaXgge01hdHJpeH0gQGFsdmluXG4gKi9cbi8vIFRPRE8gcGxheWluZyBhcm91bmQgaGVyZS4uIHRoaXMgaXMgdGVtcG9yYXJ5IC0gKHdpbGwgZW5kIHVwIGluIHRoZSBzaGFkZXIpXG4vLyB0aGlzIHJldHVybnMgYSBtYXRyaXggdGhhdCB3aWxsIG5vcm1hbGlzZSBtYXAgZmlsdGVyIGNvcmRzIGluIHRoZSBmaWx0ZXIgdG8gc2NyZWVuIHNwYWNlXG5mdW5jdGlvbiBjYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgsIGZpbHRlckFyZWEsIHRleHR1cmVTaXplKSB7XG4gICAgLy8gbGV0IHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHkoTWF0cml4LlRFTVBfTUFUUklYKSxcbiAgICAvLyBsZXQgdGV4dHVyZSA9IHt3aWR0aDoxMTM2LCBoZWlnaHQ6NzAwfTsvL3Nwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgIC8vIFRPRE8gdW53cmFwP1xuICAgIHZhciBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguaWRlbnRpdHkoKTtcblxuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoZmlsdGVyQXJlYS54IC8gdGV4dHVyZVNpemUud2lkdGgsIGZpbHRlckFyZWEueSAvIHRleHR1cmVTaXplLmhlaWdodCk7XG5cbiAgICBtYXBwZWRNYXRyaXguc2NhbGUodGV4dHVyZVNpemUud2lkdGgsIHRleHR1cmVTaXplLmhlaWdodCk7XG5cbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxpemVkU2NyZWVuU3BhY2VNYXRyaXgob3V0cHV0TWF0cml4LCBmaWx0ZXJBcmVhLCB0ZXh0dXJlU2l6ZSkge1xuICAgIHZhciBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguaWRlbnRpdHkoKTtcblxuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoZmlsdGVyQXJlYS54IC8gdGV4dHVyZVNpemUud2lkdGgsIGZpbHRlckFyZWEueSAvIHRleHR1cmVTaXplLmhlaWdodCk7XG5cbiAgICB2YXIgdHJhbnNsYXRlU2NhbGVYID0gdGV4dHVyZVNpemUud2lkdGggLyBmaWx0ZXJBcmVhLndpZHRoO1xuICAgIHZhciB0cmFuc2xhdGVTY2FsZVkgPSB0ZXh0dXJlU2l6ZS5oZWlnaHQgLyBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgIG1hcHBlZE1hdHJpeC5zY2FsZSh0cmFuc2xhdGVTY2FsZVgsIHRyYW5zbGF0ZVNjYWxlWSk7XG5cbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xufVxuXG4vLyB0aGlzIHdpbGwgbWFwIHRoZSBmaWx0ZXIgY29vcmQgc28gdGhhdCBhIHRleHR1cmUgY2FuIGJlIHVzZWQgYmFzZWQgb24gdGhlIHRyYW5zZm9ybSBvZiBhIHNwcml0ZVxuZnVuY3Rpb24gY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgZmlsdGVyQXJlYSwgdGV4dHVyZVNpemUsIHNwcml0ZSkge1xuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHNwcml0ZS53b3JsZFRyYW5zZm9ybS5jb3B5KF9tYXRoLk1hdHJpeC5URU1QX01BVFJJWCk7XG4gICAgdmFyIHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG5cbiAgICAvLyBUT0RPIHVud3JhcD9cbiAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LmlkZW50aXR5KCk7XG5cbiAgICAvLyBzY2FsZS4uXG4gICAgdmFyIHJhdGlvID0gdGV4dHVyZVNpemUuaGVpZ2h0IC8gdGV4dHVyZVNpemUud2lkdGg7XG5cbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKGZpbHRlckFyZWEueCAvIHRleHR1cmVTaXplLndpZHRoLCBmaWx0ZXJBcmVhLnkgLyB0ZXh0dXJlU2l6ZS5oZWlnaHQpO1xuXG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKDEsIHJhdGlvKTtcblxuICAgIHZhciB0cmFuc2xhdGVTY2FsZVggPSB0ZXh0dXJlU2l6ZS53aWR0aCAvIHRleHR1cmUud2lkdGg7XG4gICAgdmFyIHRyYW5zbGF0ZVNjYWxlWSA9IHRleHR1cmVTaXplLmhlaWdodCAvIHRleHR1cmUuaGVpZ2h0O1xuXG4gICAgd29ybGRUcmFuc2Zvcm0udHggLz0gdGV4dHVyZS53aWR0aCAqIHRyYW5zbGF0ZVNjYWxlWDtcblxuICAgIC8vIHRoaXMuLi4/ICBmcmVlIGJlZXIgZm9yIGFueW9uZSB3aG8gY2FuIGV4cGxhaW4gd2h5IHRoaXMgbWFrZXMgc2Vuc2UhXG4gICAgd29ybGRUcmFuc2Zvcm0udHkgLz0gdGV4dHVyZS53aWR0aCAqIHRyYW5zbGF0ZVNjYWxlWDtcbiAgICAvLyB3b3JsZFRyYW5zZm9ybS50eSAvPSB0ZXh0dXJlLmhlaWdodCAqIHRyYW5zbGF0ZVNjYWxlWTtcblxuICAgIHdvcmxkVHJhbnNmb3JtLmludmVydCgpO1xuICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcblxuICAgIC8vIGFwcGx5IGludmVyc2Ugc2NhbGUuLlxuICAgIG1hcHBlZE1hdHJpeC5zY2FsZSgxLCAxIC8gcmF0aW8pO1xuXG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKHRyYW5zbGF0ZVNjYWxlWCwgdHJhbnNsYXRlU2NhbGVZKTtcblxuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoc3ByaXRlLmFuY2hvci54LCBzcHJpdGUuYW5jaG9yLnkpO1xuXG4gICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlclRyYW5zZm9ybXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvZmlsdGVyVHJhbnNmb3Jtcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9XZWJHTE1hbmFnZXIyID0gcmVxdWlyZSgnLi9XZWJHTE1hbmFnZXInKTtcblxudmFyIF9XZWJHTE1hbmFnZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xNYW5hZ2VyMik7XG5cbnZhciBfUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi4vdXRpbHMvUmVuZGVyVGFyZ2V0Jyk7XG5cbnZhciBfUmVuZGVyVGFyZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbmRlclRhcmdldCk7XG5cbnZhciBfUXVhZCA9IHJlcXVpcmUoJy4uL3V0aWxzL1F1YWQnKTtcblxudmFyIF9RdWFkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1F1YWQpO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbnZhciBfU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vU2hhZGVyJyk7XG5cbnZhciBfU2hhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYWRlcik7XG5cbnZhciBfZmlsdGVyVHJhbnNmb3JtcyA9IHJlcXVpcmUoJy4uL2ZpbHRlcnMvZmlsdGVyVHJhbnNmb3JtcycpO1xuXG52YXIgZmlsdGVyVHJhbnNmb3JtcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9maWx0ZXJUcmFuc2Zvcm1zKTtcblxudmFyIF9iaXRUd2lkZGxlID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKTtcblxudmFyIF9iaXRUd2lkZGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpdFR3aWRkbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQGlnbm9yZVxuICogQGNsYXNzXG4gKi9cbnZhciBGaWx0ZXJTdGF0ZSA9XG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIEZpbHRlclN0YXRlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWx0ZXJTdGF0ZSk7XG5cbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgX21hdGguUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG59O1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFBJWEkuV2ViR0xNYW5hZ2VyXG4gKi9cblxuXG52YXIgRmlsdGVyTWFuYWdlciA9IGZ1bmN0aW9uIChfV2ViR0xNYW5hZ2VyKSB7XG4gICAgX2luaGVyaXRzKEZpbHRlck1hbmFnZXIsIF9XZWJHTE1hbmFnZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgbWFuYWdlciB3b3JrcyBmb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRmlsdGVyTWFuYWdlcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsdGVyTWFuYWdlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1dlYkdMTWFuYWdlci5jYWxsKHRoaXMsIHJlbmRlcmVyKSk7XG5cbiAgICAgICAgX3RoaXMuZ2wgPSBfdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgLy8ga25vdyBhYm91dCBzcHJpdGVzIVxuICAgICAgICBfdGhpcy5xdWFkID0gbmV3IF9RdWFkMi5kZWZhdWx0KF90aGlzLmdsLCByZW5kZXJlci5zdGF0ZS5hdHRyaWJTdGF0ZSk7XG5cbiAgICAgICAgX3RoaXMuc2hhZGVyQ2FjaGUgPSB7fTtcbiAgICAgICAgLy8gdG9kbyBhZGQgZGVmYXVsdCFcbiAgICAgICAgX3RoaXMucG9vbCA9IHt9O1xuXG4gICAgICAgIF90aGlzLmZpbHRlckRhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBmaWx0ZXIgdG8gdGhlIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgZmlsdGVyIHRvIHJlbmRlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyW119IGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseS5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucHVzaEZpbHRlciA9IGZ1bmN0aW9uIHB1c2hGaWx0ZXIodGFyZ2V0LCBmaWx0ZXJzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgICAgdmFyIGZpbHRlckRhdGEgPSB0aGlzLmZpbHRlckRhdGE7XG5cbiAgICAgICAgaWYgKCFmaWx0ZXJEYXRhKSB7XG4gICAgICAgICAgICBmaWx0ZXJEYXRhID0gdGhpcy5yZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0LmZpbHRlclN0YWNrO1xuXG4gICAgICAgICAgICAvLyBhZGQgbmV3IHN0YWNrXG4gICAgICAgICAgICB2YXIgZmlsdGVyU3RhdGUgPSBuZXcgRmlsdGVyU3RhdGUoKTtcblxuICAgICAgICAgICAgZmlsdGVyU3RhdGUuc291cmNlRnJhbWUgPSBmaWx0ZXJTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lID0gdGhpcy5yZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0LnNpemU7XG4gICAgICAgICAgICBmaWx0ZXJTdGF0ZS5yZW5kZXJUYXJnZXQgPSByZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQuZmlsdGVyRGF0YSA9IGZpbHRlckRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgc3RhY2s6IFtmaWx0ZXJTdGF0ZV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgZmlsdGVyIHN0YXRlLi5cbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGZpbHRlckRhdGEuc3RhY2tbKytmaWx0ZXJEYXRhLmluZGV4XTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gZmlsdGVyRGF0YS5zdGFja1tmaWx0ZXJEYXRhLmluZGV4XSA9IG5ldyBGaWx0ZXJTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIG5vdyB3ZSBnbyBvZmYgdGhlIGZpbHRlciBvZiB0aGUgZmlyc3QgcmVzb2x1dGlvbi4uXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gZmlsdGVyc1swXS5yZXNvbHV0aW9uO1xuICAgICAgICB2YXIgcGFkZGluZyA9IGZpbHRlcnNbMF0ucGFkZGluZyB8IDA7XG4gICAgICAgIHZhciB0YXJnZXRCb3VuZHMgPSB0YXJnZXQuZmlsdGVyQXJlYSB8fCB0YXJnZXQuZ2V0Qm91bmRzKHRydWUpO1xuICAgICAgICB2YXIgc291cmNlRnJhbWUgPSBjdXJyZW50U3RhdGUuc291cmNlRnJhbWU7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbkZyYW1lID0gY3VycmVudFN0YXRlLmRlc3RpbmF0aW9uRnJhbWU7XG5cbiAgICAgICAgc291cmNlRnJhbWUueCA9ICh0YXJnZXRCb3VuZHMueCAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgIHNvdXJjZUZyYW1lLnkgPSAodGFyZ2V0Qm91bmRzLnkgKiByZXNvbHV0aW9uIHwgMCkgLyByZXNvbHV0aW9uO1xuICAgICAgICBzb3VyY2VGcmFtZS53aWR0aCA9ICh0YXJnZXRCb3VuZHMud2lkdGggKiByZXNvbHV0aW9uIHwgMCkgLyByZXNvbHV0aW9uO1xuICAgICAgICBzb3VyY2VGcmFtZS5oZWlnaHQgPSAodGFyZ2V0Qm91bmRzLmhlaWdodCAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG5cbiAgICAgICAgaWYgKGZpbHRlckRhdGEuc3RhY2tbMF0ucmVuZGVyVGFyZ2V0LnRyYW5zZm9ybSkgey8vXG5cbiAgICAgICAgICAgIC8vIFRPRE8gd2Ugc2hvdWxkIGZpdCB0aGUgcmVjdCBhcm91bmQgdGhlIHRyYW5zZm9ybS4uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VGcmFtZS5maXQoZmlsdGVyRGF0YS5zdGFja1swXS5kZXN0aW5hdGlvbkZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldHMgYXBwbHkgdGhlIHBhZGRpbmcgQWZ0ZXIgd2UgZml0IHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW4uXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIHN0b3AgdGhlIHN0cmFuZ2Ugc2lkZSBlZmZlY3RzIHRoYXQgY2FuIG9jY3VyIHdoZW4gY3JvcHBpbmcgdG8gdGhlIGVkZ2VzXG4gICAgICAgIHNvdXJjZUZyYW1lLnBhZChwYWRkaW5nKTtcblxuICAgICAgICBkZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gc291cmNlRnJhbWUud2lkdGg7XG4gICAgICAgIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gc291cmNlRnJhbWUuaGVpZ2h0O1xuXG4gICAgICAgIC8vIGxldHMgcGxheSB0aGUgcGFkZGluZyBhZnRlciB3ZSBmaXQgdGhlIGVsZW1lbnQgdG8gdGhlIHNjcmVlbi5cbiAgICAgICAgLy8gdGhpcyBzaG91bGQgc3RvcCB0aGUgc3RyYW5nZSBzaWRlIGVmZmVjdHMgdGhhdCBjYW4gb2NjdXIgd2hlbiBjcm9wcGluZyB0byB0aGUgZWRnZXNcblxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5nZXRQb3RSZW5kZXJUYXJnZXQocmVuZGVyZXIuZ2wsIHNvdXJjZUZyYW1lLndpZHRoLCBzb3VyY2VGcmFtZS5oZWlnaHQsIHJlc29sdXRpb24pO1xuXG4gICAgICAgIGN1cnJlbnRTdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgY3VycmVudFN0YXRlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIHJlbmRlciB0YXJnZXQgdG8gZHJhdyB0aGUgc2hhcGUgaW4gdGhlIHRvcCBjb3JuZXIuLlxuXG4gICAgICAgIHJlbmRlclRhcmdldC5zZXRGcmFtZShkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAgICByZW5kZXJlci5iaW5kUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgICAgIHJlbmRlclRhcmdldC5jbGVhcigpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb3BzIG9mZiB0aGUgZmlsdGVyIGFuZCBhcHBsaWVzIGl0LlxuICAgICAqXG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnBvcEZpbHRlciA9IGZ1bmN0aW9uIHBvcEZpbHRlcigpIHtcbiAgICAgICAgdmFyIGZpbHRlckRhdGEgPSB0aGlzLmZpbHRlckRhdGE7XG5cbiAgICAgICAgdmFyIGxhc3RTdGF0ZSA9IGZpbHRlckRhdGEuc3RhY2tbZmlsdGVyRGF0YS5pbmRleCAtIDFdO1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gZmlsdGVyRGF0YS5zdGFja1tmaWx0ZXJEYXRhLmluZGV4XTtcblxuICAgICAgICB0aGlzLnF1YWQubWFwKGN1cnJlbnRTdGF0ZS5yZW5kZXJUYXJnZXQuc2l6ZSwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lKS51cGxvYWQoKTtcblxuICAgICAgICB2YXIgZmlsdGVycyA9IGN1cnJlbnRTdGF0ZS5maWx0ZXJzO1xuXG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZmlsdGVyc1swXS5hcHBseSh0aGlzLCBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LCBsYXN0U3RhdGUucmVuZGVyVGFyZ2V0LCBmYWxzZSwgY3VycmVudFN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuZnJlZVBvdFJlbmRlclRhcmdldChjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmbGlwID0gY3VycmVudFN0YXRlLnJlbmRlclRhcmdldDtcbiAgICAgICAgICAgIHZhciBmbG9wID0gdGhpcy5nZXRQb3RSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJlci5nbCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0LCBjdXJyZW50U3RhdGUucmVzb2x1dGlvbik7XG5cbiAgICAgICAgICAgIGZsb3Auc2V0RnJhbWUoY3VycmVudFN0YXRlLmRlc3RpbmF0aW9uRnJhbWUsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZSk7XG5cbiAgICAgICAgICAgIC8vIGZpbmFsbHkgbGV0cyBjbGVhciB0aGUgcmVuZGVyIHRhcmdldCBiZWZvcmUgZHJhd2luZyB0byBpdC4uXG4gICAgICAgICAgICBmbG9wLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBmbG9wLCB0cnVlLCBjdXJyZW50U3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBmbGlwO1xuXG4gICAgICAgICAgICAgICAgZmxpcCA9IGZsb3A7XG4gICAgICAgICAgICAgICAgZmxvcCA9IHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgbGFzdFN0YXRlLnJlbmRlclRhcmdldCwgZmFsc2UsIGN1cnJlbnRTdGF0ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZnJlZVBvdFJlbmRlclRhcmdldChmbGlwKTtcbiAgICAgICAgICAgIHRoaXMuZnJlZVBvdFJlbmRlclRhcmdldChmbG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlckRhdGEuaW5kZXgtLTtcblxuICAgICAgICBpZiAoZmlsdGVyRGF0YS5pbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJ9IGZpbHRlciAtIFRoZSBmaWx0ZXIgdG8gZHJhdy5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGFyZ2V0fSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXRcbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiBhcHBseUZpbHRlcihmaWx0ZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgICAgIHZhciBzaGFkZXIgPSBmaWx0ZXIuZ2xTaGFkZXJzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXTtcblxuICAgICAgICAvLyBjYWNoZWluZy4uXG4gICAgICAgIGlmICghc2hhZGVyKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmdsU2hhZGVyS2V5KSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyID0gdGhpcy5zaGFkZXJDYWNoZVtmaWx0ZXIuZ2xTaGFkZXJLZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyID0gbmV3IF9TaGFkZXIyLmRlZmF1bHQodGhpcy5nbCwgZmlsdGVyLnZlcnRleFNyYywgZmlsdGVyLmZyYWdtZW50U3JjKTtcblxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZ2xTaGFkZXJzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXSA9IHRoaXMuc2hhZGVyQ2FjaGVbZmlsdGVyLmdsU2hhZGVyS2V5XSA9IHNoYWRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYWRlciA9IGZpbHRlci5nbFNoYWRlcnNbcmVuZGVyZXIuQ09OVEVYVF9VSURdID0gbmV3IF9TaGFkZXIyLmRlZmF1bHQodGhpcy5nbCwgZmlsdGVyLnZlcnRleFNyYywgZmlsdGVyLmZyYWdtZW50U3JjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyAtIHRoaXMgb25seSBuZWVkcyB0byBiZSBkb25lIG9uY2U/XG4gICAgICAgICAgICByZW5kZXJlci5iaW5kVmFvKG51bGwpO1xuXG4gICAgICAgICAgICB0aGlzLnF1YWQuaW5pdFZhbyhzaGFkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuYmluZFZhbyh0aGlzLnF1YWQudmFvKTtcblxuICAgICAgICByZW5kZXJlci5iaW5kUmVuZGVyVGFyZ2V0KG91dHB1dCk7XG5cbiAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgICAgICByZW5kZXJlci5jbGVhcigpOyAvLyBbMSwgMSwgMSwgMV0pO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBjYXNlIHRoZSByZW5kZXIgdGFyZ2V0IGlzIGJlaW5nIG1hc2tlZCB1c2luZyBhIHNjaXNzb3IgcmVjdFxuICAgICAgICBpZiAob3V0cHV0ID09PSByZW5kZXJlci5tYXNrTWFuYWdlci5zY2lzc29yUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICByZW5kZXJlci5tYXNrTWFuYWdlci5wdXNoU2Npc3Nvck1hc2sobnVsbCwgcmVuZGVyZXIubWFza01hbmFnZXIuc2Npc3NvckRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuYmluZFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIC8vIGZyZWUgdW5pdCAwIGZvciB1cywgZG9lc24ndCBtYXR0ZXIgd2hhdCB3YXMgdGhlcmVcbiAgICAgICAgLy8gZG9uJ3QgdHJ5IHRvIHJlc3RvcmUgaXQsIGJlY2F1c2Ugc3luY1VuaWZvcm1zIGNhbiB1cGxvYWQgaXQgdG8gYW5vdGhlciBzbG90XG4gICAgICAgIC8vIGFuZCBpdCdsbCBiZSBhIHByb2JsZW1cbiAgICAgICAgdmFyIHRleCA9IHRoaXMucmVuZGVyZXIuZW1wdHlUZXh0dXJlc1swXTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmJvdW5kVGV4dHVyZXNbMF0gPSB0ZXg7XG4gICAgICAgIC8vIHRoaXMgc3luY3MgdGhlIHBpeGkgZmlsdGVycyAgdW5pZm9ybXMgd2l0aCBnbHNsIHVuaWZvcm1zXG4gICAgICAgIHRoaXMuc3luY1VuaWZvcm1zKHNoYWRlciwgZmlsdGVyKTtcblxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRCbGVuZE1vZGUoZmlsdGVyLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0LnRleHR1cmUudGV4dHVyZSk7XG5cbiAgICAgICAgdGhpcy5xdWFkLnZhby5kcmF3KHRoaXMucmVuZGVyZXIuZ2wuVFJJQU5HTEVTLCA2LCAwKTtcblxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXguX2dsVGV4dHVyZXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0udGV4dHVyZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIHVuaWZvcm1zIG9mIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dMU2hhZGVyfSBzaGFkZXIgLSBUaGUgdW5kZXJseWluZyBnbCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtQSVhJLkZpbHRlcn0gZmlsdGVyIC0gVGhlIGZpbHRlciB3ZSBhcmUgc3luY2hyb25pemluZy5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuc3luY1VuaWZvcm1zID0gZnVuY3Rpb24gc3luY1VuaWZvcm1zKHNoYWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHZhciB1bmlmb3JtRGF0YSA9IGZpbHRlci51bmlmb3JtRGF0YTtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gZmlsdGVyLnVuaWZvcm1zO1xuXG4gICAgICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIHRoZSBwaXhpIHRleHR1cmUgc28gd2Ugc3RhcnQgYXQgMSFcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gZmlsdGVyQXJlYSBhbmQgZmlsdGVyQ2xhbXAgdGhhdCBhcmUgaGFuZGxlZCBieSBGaWx0ZXJNYW5hZ2VyIGRpcmVjdGx5XG4gICAgICAgIC8vIHRoZXkgbXVzdCBub3QgYXBwZWFyIGluIHVuaWZvcm1EYXRhXG5cbiAgICAgICAgaWYgKHNoYWRlci51bmlmb3Jtcy5maWx0ZXJBcmVhKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSB0aGlzLmZpbHRlckRhdGEuc3RhY2tbdGhpcy5maWx0ZXJEYXRhLmluZGV4XTtcblxuICAgICAgICAgICAgdmFyIGZpbHRlckFyZWEgPSBzaGFkZXIudW5pZm9ybXMuZmlsdGVyQXJlYTtcblxuICAgICAgICAgICAgZmlsdGVyQXJlYVswXSA9IGN1cnJlbnRTdGF0ZS5yZW5kZXJUYXJnZXQuc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGZpbHRlckFyZWFbMV0gPSBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgZmlsdGVyQXJlYVsyXSA9IGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZS54O1xuICAgICAgICAgICAgZmlsdGVyQXJlYVszXSA9IGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZS55O1xuXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMuZmlsdGVyQXJlYSA9IGZpbHRlckFyZWE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2UgdGhpcyB0byBjbGFtcCBkaXNwbGFjZWQgdGV4dHVyZSBjb29yZHMgc28gdGhleSBiZWxvbmcgdG8gZmlsdGVyQXJlYVxuICAgICAgICAvLyBzZWUgZGlzcGxhY2VtZW50RmlsdGVyIGZyYWdtZW50IHNoYWRlciBmb3IgYW4gZXhhbXBsZVxuICAgICAgICBpZiAoc2hhZGVyLnVuaWZvcm1zLmZpbHRlckNsYW1wKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUgfHwgdGhpcy5maWx0ZXJEYXRhLnN0YWNrW3RoaXMuZmlsdGVyRGF0YS5pbmRleF07XG5cbiAgICAgICAgICAgIHZhciBmaWx0ZXJDbGFtcCA9IHNoYWRlci51bmlmb3Jtcy5maWx0ZXJDbGFtcDtcblxuICAgICAgICAgICAgZmlsdGVyQ2xhbXBbMF0gPSAwO1xuICAgICAgICAgICAgZmlsdGVyQ2xhbXBbMV0gPSAwO1xuICAgICAgICAgICAgZmlsdGVyQ2xhbXBbMl0gPSAoY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLndpZHRoIC0gMSkgLyBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUud2lkdGg7XG4gICAgICAgICAgICBmaWx0ZXJDbGFtcFszXSA9IChjdXJyZW50U3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0IC0gMSkgLyBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMuZmlsdGVyQ2xhbXAgPSBmaWx0ZXJDbGFtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gQ2FjaGVpbmcgbGF5ZXIuLlxuICAgICAgICBmb3IgKHZhciBpIGluIHVuaWZvcm1EYXRhKSB7XG4gICAgICAgICAgICBpZiAodW5pZm9ybURhdGFbaV0udHlwZSA9PT0gJ3NhbXBsZXIyRCcgJiYgdW5pZm9ybXNbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pZm9ybXNbaV0uYmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zW2ldID0gdGhpcy5yZW5kZXJlci5iaW5kVGV4dHVyZSh1bmlmb3Jtc1tpXS5iYXNlVGV4dHVyZSwgdGV4dHVyZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIudW5pZm9ybXNbaV0gPSB0ZXh0dXJlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGhlbHBmdWwgYXMgcmVuZGVyVGFyZ2V0cyBjYW4gYWxzbyBiZSBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIHRoaW5raW5nIGFib3V0IGl0LCB3ZSBjb3VsZCBwcm9iYWJseVxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBmaWx0ZXIgdGV4dHVyZSBjYWNoZSByZXR1cm4gYSBSZW5kZXJUZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGEgcmVuZGVyVGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5ib3VuZFRleHR1cmVzW3RleHR1cmVDb3VudF0gPSB0aGlzLnJlbmRlcmVyLmVtcHR5VGV4dHVyZXNbdGV4dHVyZUNvdW50XTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVDb3VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNbaV0udGV4dHVyZS5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaWZvcm1EYXRhW2ldLnR5cGUgPT09ICdtYXQzJykge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0cyBwaXhpIG1hdHJpeC4uXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm1zW2ldLmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIudW5pZm9ybXNbaV0gPSB1bmlmb3Jtc1tpXS50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtc1tpXSA9IHVuaWZvcm1zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pZm9ybURhdGFbaV0udHlwZSA9PT0gJ3ZlYzInKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXRzIGEgcG9pbnQuLlxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3Jtc1tpXS54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHNoYWRlci51bmlmb3Jtc1tpXSB8fCBuZXcgRmxvYXQzMkFycmF5KDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhbFswXSA9IHVuaWZvcm1zW2ldLng7XG4gICAgICAgICAgICAgICAgICAgIHZhbFsxXSA9IHVuaWZvcm1zW2ldLnk7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtc1tpXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIudW5pZm9ybXNbaV0gPSB1bmlmb3Jtc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaWZvcm1EYXRhW2ldLnR5cGUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hhZGVyLnVuaWZvcm1zLmRhdGFbaV0udmFsdWUgIT09IHVuaWZvcm1EYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtc1tpXSA9IHVuaWZvcm1zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zW2ldID0gdW5pZm9ybXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJlbmRlciB0YXJnZXQgZnJvbSB0aGUgcG9vbCwgb3IgY3JlYXRlcyBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyIC0gU2hvdWxkIHdlIGNsZWFyIHRoZSByZW5kZXIgdGV4dHVyZSB3aGVuIHdlIGdldCBpdD9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0YXJnZXQuXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJUYXJnZXR9IFRoZSBuZXcgcmVuZGVyIHRhcmdldFxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXQoY2xlYXIsIHJlc29sdXRpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuZmlsdGVyRGF0YS5zdGFja1t0aGlzLmZpbHRlckRhdGEuaW5kZXhdO1xuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5nZXRQb3RSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJlci5nbCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0LCByZXNvbHV0aW9uIHx8IGN1cnJlbnRTdGF0ZS5yZXNvbHV0aW9uKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQuc2V0RnJhbWUoY3VycmVudFN0YXRlLmRlc3RpbmF0aW9uRnJhbWUsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclRhcmdldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlbmRlciB0YXJnZXQgdG8gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGFyZ2V0fSByZW5kZXJUYXJnZXQgLSBUaGUgcmVuZGVyIHRhcmdldCB0byByZXR1cm4uXG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnJldHVyblJlbmRlclRhcmdldCA9IGZ1bmN0aW9uIHJldHVyblJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5mcmVlUG90UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1hcHBlZCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUT0RPIHBsYXlpbmcgYXJvdW5kIGhlcmUuLiB0aGlzIGlzIHRlbXBvcmFyeSAtICh3aWxsIGVuZCB1cCBpbiB0aGUgc2hhZGVyKVxuICAgICAqIHRoaXMgcmV0dXJucyBhIG1hdHJpeCB0aGF0IHdpbGwgbm9ybWFsaXNlIG1hcCBmaWx0ZXIgY29yZHMgaW4gdGhlIGZpbHRlciB0byBzY3JlZW4gc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG91dHB1dE1hdHJpeCAtIHRoZSBtYXRyaXggdG8gb3V0cHV0IHRvLlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGUgbWFwcGVkIG1hdHJpeC5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXggPSBmdW5jdGlvbiBjYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuZmlsdGVyRGF0YS5zdGFja1t0aGlzLmZpbHRlckRhdGEuaW5kZXhdO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXJUcmFuc2Zvcm1zLmNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLCBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB2VGV4dHVyZUNvb3JkIHRvIHRoaXMgbWF0cml4IHRvIGFjaGlldmUgKDAsMCwxLDEpIGZvciBmaWx0ZXJBcmVhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBvdXRwdXRNYXRyaXggLSBUaGUgbWF0cml4IHRvIG91dHB1dCB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hcHBlZCBtYXRyaXguXG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNhbGN1bGF0ZU5vcm1hbGl6ZWRTY3JlZW5TcGFjZU1hdHJpeCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbGl6ZWRTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuZmlsdGVyRGF0YS5zdGFja1t0aGlzLmZpbHRlckRhdGEuaW5kZXhdO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXJUcmFuc2Zvcm1zLmNhbGN1bGF0ZU5vcm1hbGl6ZWRTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZSwgY3VycmVudFN0YXRlLnJlbmRlclRhcmdldC5zaXplLCBjdXJyZW50U3RhdGUuZGVzdGluYXRpb25GcmFtZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBtYXAgdGhlIGZpbHRlciBjb29yZCBzbyB0aGF0IGEgdGV4dHVyZSBjYW4gYmUgdXNlZCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIGEgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBvdXRwdXRNYXRyaXggLSBUaGUgbWF0cml4IHRvIG91dHB1dCB0by5cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSBUaGUgc3ByaXRlIHRvIG1hcCB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hcHBlZCBtYXRyaXguXG4gICAgICovXG5cblxuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNwcml0ZU1hdHJpeChvdXRwdXRNYXRyaXgsIHNwcml0ZSkge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5maWx0ZXJEYXRhLnN0YWNrW3RoaXMuZmlsdGVyRGF0YS5pbmRleF07XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlclRyYW5zZm9ybXMuY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLCBjdXJyZW50U3RhdGUucmVuZGVyVGFyZ2V0LnNpemUsIHNwcml0ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgRmlsdGVyIE1hbmFnZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5lbXB0eVBvb2woKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIFBvd2VyLW9mLVR3byByZW5kZXIgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIFRPRE8gbW92ZSB0byBhIHNlcGVyYXRlIGNsYXNzIGNvdWxkIGJlIG9uIHJlbmRlcmVyP1xuICAgICAqIGFsc28gLSBjb3VsZCBjYXVzZSBpc3N1ZSB3aXRoIG11bHRpcGxlIGNvbnRleHRzP1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgd2ViZ2wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluV2lkdGggLSBUaGUgbWluaW11bSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluSGVpZ2h0IC0gVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlciB0YXJnZXQuXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJUYXJnZXR9IFRoZSBuZXcgcmVuZGVyIHRhcmdldC5cbiAgICAgKi9cblxuXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZ2V0UG90UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gZ2V0UG90UmVuZGVyVGFyZ2V0KGdsLCBtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgICAgIC8vIFRPRE8geW91IGNvdWxkIHJldHVybiBhIGJpZ2dlciB0ZXh0dXJlIGlmIHRoZXJlIGlzIG5vdCBvbmUgaW4gdGhlIHBvb2w/XG4gICAgICAgIG1pbldpZHRoID0gX2JpdFR3aWRkbGUyLmRlZmF1bHQubmV4dFBvdzIobWluV2lkdGggKiByZXNvbHV0aW9uKTtcbiAgICAgICAgbWluSGVpZ2h0ID0gX2JpdFR3aWRkbGUyLmRlZmF1bHQubmV4dFBvdzIobWluSGVpZ2h0ICogcmVzb2x1dGlvbik7XG5cbiAgICAgICAgdmFyIGtleSA9IChtaW5XaWR0aCAmIDB4RkZGRikgPDwgMTYgfCBtaW5IZWlnaHQgJiAweEZGRkY7XG5cbiAgICAgICAgaWYgKCF0aGlzLnBvb2xba2V5XSkge1xuICAgICAgICAgICAgdGhpcy5wb29sW2tleV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnBvb2xba2V5XS5wb3AoKTtcblxuICAgICAgICAvLyBjcmVhdGluZyByZW5kZXIgdGFyZ2V0IHdpbGwgY2F1c2UgdGV4dHVyZSB0byBiZSBib3VuZCFcbiAgICAgICAgaWYgKCFyZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBieXBhc3MgY2FjaGUuLlxuICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMucmVuZGVyZXIuYm91bmRUZXh0dXJlc1swXTtcblxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAgICAgICAgIC8vIGludGVybmFsbHkgLSB0aGlzIHdpbGwgY2F1c2UgYSB0ZXh0dXJlIHRvIGJlIGJvdW5kLi5cbiAgICAgICAgICAgIHJlbmRlclRhcmdldCA9IG5ldyBfUmVuZGVyVGFyZ2V0Mi5kZWZhdWx0KGdsLCBtaW5XaWR0aCwgbWluSGVpZ2h0LCBudWxsLCAxKTtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IG9uZSBiYWNrXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXguX2dsVGV4dHVyZXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0udGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYW51YWxseSB0d2VhayB0aGUgcmVzb2x1dGlvbi4uLlxuICAgICAgICAvLyB0aGlzIHdpbGwgbm90IG1vZGlmeSB0aGUgc2l6ZSBvZiB0aGUgZnJhbWUgYnVmZmVyLCBqdXN0IGl0cyByZXNvbHV0aW9uLlxuICAgICAgICByZW5kZXJUYXJnZXQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIHJlbmRlclRhcmdldC5kZWZhdWx0RnJhbWUud2lkdGggPSByZW5kZXJUYXJnZXQuc2l6ZS53aWR0aCA9IG1pbldpZHRoIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmRlZmF1bHRGcmFtZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuc2l6ZS5oZWlnaHQgPSBtaW5IZWlnaHQgLyByZXNvbHV0aW9uO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJUYXJnZXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgdGhlIHRleHR1cmUgcG9vbC5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5lbXB0eVBvb2wgPSBmdW5jdGlvbiBlbXB0eVBvb2woKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5wb29sKSB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnBvb2xbaV07XG5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvb2wgPSB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnJlZXMgYSByZW5kZXIgdGFyZ2V0IGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUYXJnZXR9IHJlbmRlclRhcmdldCAtIFRoZSByZW5kZXJUYXJnZXQgdG8gZnJlZVxuICAgICAqL1xuXG5cbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5mcmVlUG90UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gZnJlZVBvdFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgdmFyIG1pbldpZHRoID0gcmVuZGVyVGFyZ2V0LnNpemUud2lkdGggKiByZW5kZXJUYXJnZXQucmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIG1pbkhlaWdodCA9IHJlbmRlclRhcmdldC5zaXplLmhlaWdodCAqIHJlbmRlclRhcmdldC5yZXNvbHV0aW9uO1xuICAgICAgICB2YXIga2V5ID0gKG1pbldpZHRoICYgMHhGRkZGKSA8PCAxNiB8IG1pbkhlaWdodCAmIDB4RkZGRjtcblxuICAgICAgICB0aGlzLnBvb2xba2V5XS5wdXNoKHJlbmRlclRhcmdldCk7XG4gICAgfTtcblxuICAgIHJldHVybiBGaWx0ZXJNYW5hZ2VyO1xufShfV2ViR0xNYW5hZ2VyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsdGVyTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlck1hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL0ZpbHRlck1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfV2ViR0xNYW5hZ2VyMiA9IHJlcXVpcmUoJy4vV2ViR0xNYW5hZ2VyJyk7XG5cbnZhciBfV2ViR0xNYW5hZ2VyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dlYkdMTWFuYWdlcjIpO1xuXG52YXIgX1Nwcml0ZU1hc2tGaWx0ZXIgPSByZXF1aXJlKCcuLi9maWx0ZXJzL3Nwcml0ZU1hc2svU3ByaXRlTWFza0ZpbHRlcicpO1xuXG52YXIgX1Nwcml0ZU1hc2tGaWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3ByaXRlTWFza0ZpbHRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuV2ViR0xNYW5hZ2VyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG52YXIgTWFza01hbmFnZXIgPSBmdW5jdGlvbiAoX1dlYkdMTWFuYWdlcikge1xuICAgIF9pbmhlcml0cyhNYXNrTWFuYWdlciwgX1dlYkdMTWFuYWdlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXNrTWFuYWdlcihyZW5kZXJlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFza01hbmFnZXIpO1xuXG4gICAgICAgIC8vIFRPRE8gLSB3ZSBkb24ndCBuZWVkIGJvdGghXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9XZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcikpO1xuXG4gICAgICAgIF90aGlzLnNjaXNzb3IgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2Npc3NvckRhdGEgPSBudWxsO1xuICAgICAgICBfdGhpcy5zY2lzc29yUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5lbmFibGVTY2lzc29yID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5hbHBoYU1hc2tQb29sID0gW107XG4gICAgICAgIF90aGlzLmFscGhhTWFza0luZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHB1c2ggdGhlIG1hc2sgdG9cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICAgKi9cblxuXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hNYXNrID0gZnVuY3Rpb24gcHVzaE1hc2sodGFyZ2V0LCBtYXNrRGF0YSkge1xuICAgICAgICAvLyBUT0RPIHRoZSByb290IGNoZWNrIG1lYW5zIHNjaXNzb3IgcmVjdCB3aWxsIG5vdFxuICAgICAgICAvLyBiZSB1c2VkIG9uIHJlbmRlciB0ZXh0dXJlcyBtb3JlIGluZm8gaGVyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL3B1bGwvMzU0NVxuXG4gICAgICAgIGlmIChtYXNrRGF0YS50ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTcHJpdGVNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZW5hYmxlU2Npc3NvciAmJiAhdGhpcy5zY2lzc29yICYmIHRoaXMucmVuZGVyZXIuX2FjdGl2ZVJlbmRlclRhcmdldC5yb290ICYmICF0aGlzLnJlbmRlcmVyLnN0ZW5jaWxNYW5hZ2VyLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoICYmIG1hc2tEYXRhLmlzRmFzdFJlY3QoKSkge1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IG1hc2tEYXRhLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgICAgICB2YXIgcm90ID0gTWF0aC5hdGFuMihtYXRyaXguYiwgbWF0cml4LmEpO1xuXG4gICAgICAgICAgICAvLyB1c2UgdGhlIG5lYXJlc3QgZGVncmVlIVxuICAgICAgICAgICAgcm90ID0gTWF0aC5yb3VuZChyb3QgKiAoMTgwIC8gTWF0aC5QSSkpO1xuXG4gICAgICAgICAgICBpZiAocm90ICUgOTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTdGVuY2lsTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNjaXNzb3JNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RlbmNpbE1hc2sobWFza0RhdGEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgbWFzayBmcm9tIHRoZSBtYXNrIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwb3AgdGhlIG1hc2sgZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV8UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxuICAgICAqL1xuXG5cbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wTWFzayA9IGZ1bmN0aW9uIHBvcE1hc2sodGFyZ2V0LCBtYXNrRGF0YSkge1xuICAgICAgICBpZiAobWFza0RhdGEudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5wb3BTcHJpdGVNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZW5hYmxlU2Npc3NvciAmJiAhdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3BTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9wU3RlbmNpbE1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGFyZ2V0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBzcHJpdGUgbWFzayB0b1xuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IG1hc2tEYXRhIC0gU3ByaXRlIHRvIGJlIHVzZWQgYXMgdGhlIG1hc2tcbiAgICAgKi9cblxuXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hTcHJpdGVNYXNrID0gZnVuY3Rpb24gcHVzaFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSkge1xuICAgICAgICB2YXIgYWxwaGFNYXNrRmlsdGVyID0gdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdO1xuXG4gICAgICAgIGlmICghYWxwaGFNYXNrRmlsdGVyKSB7XG4gICAgICAgICAgICBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF0gPSBbbmV3IF9TcHJpdGVNYXNrRmlsdGVyMi5kZWZhdWx0KG1hc2tEYXRhKV07XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYU1hc2tGaWx0ZXJbMF0ucmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgYWxwaGFNYXNrRmlsdGVyWzBdLm1hc2tTcHJpdGUgPSBtYXNrRGF0YTtcblxuICAgICAgICAvLyBUT0RPIC0gbWF5IGNhdXNlIGlzc3VlcyFcbiAgICAgICAgdGFyZ2V0LmZpbHRlckFyZWEgPSBtYXNrRGF0YS5nZXRCb3VuZHModHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnB1c2hGaWx0ZXIodGFyZ2V0LCBhbHBoYU1hc2tGaWx0ZXIpO1xuXG4gICAgICAgIHRoaXMuYWxwaGFNYXNrSW5kZXgrKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU3ByaXRlTWFzayA9IGZ1bmN0aW9uIHBvcFNwcml0ZU1hc2soKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyTWFuYWdlci5wb3BGaWx0ZXIoKTtcbiAgICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleC0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV8UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxuICAgICAqL1xuXG5cbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaFN0ZW5jaWxNYXNrID0gZnVuY3Rpb24gcHVzaFN0ZW5jaWxNYXNrKG1hc2tEYXRhKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wdXNoU3RlbmNpbChtYXNrRGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnBvcFN0ZW5jaWxNYXNrID0gZnVuY3Rpb24gcG9wU3RlbmNpbE1hc2soKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wb3BTdGVuY2lsKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHB1c2ggdGhlIG1hc2sgdG9cbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICAgKi9cblxuXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hTY2lzc29yTWFzayA9IGZ1bmN0aW9uIHB1c2hTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKSB7XG4gICAgICAgIG1hc2tEYXRhLnJlbmRlcmFibGUgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IG1hc2tEYXRhLmdldEJvdW5kcygpO1xuXG4gICAgICAgIGJvdW5kcy5maXQocmVuZGVyVGFyZ2V0LnNpemUpO1xuICAgICAgICBtYXNrRGF0YS5yZW5kZXJhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5lbmFibGUodGhpcy5yZW5kZXJlci5nbC5TQ0lTU09SX1RFU1QpO1xuXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuc2Npc3Nvcihib3VuZHMueCAqIHJlc29sdXRpb24sIChyZW5kZXJUYXJnZXQucm9vdCA/IHJlbmRlclRhcmdldC5zaXplLmhlaWdodCAtIGJvdW5kcy55IC0gYm91bmRzLmhlaWdodCA6IGJvdW5kcy55KSAqIHJlc29sdXRpb24sIGJvdW5kcy53aWR0aCAqIHJlc29sdXRpb24sIGJvdW5kcy5oZWlnaHQgKiByZXNvbHV0aW9uKTtcblxuICAgICAgICB0aGlzLnNjaXNzb3JSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgICAgIHRoaXMuc2Npc3NvckRhdGEgPSBtYXNrRGF0YTtcbiAgICAgICAgdGhpcy5zY2lzc29yID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU2Npc3Nvck1hc2sgPSBmdW5jdGlvbiBwb3BTY2lzc29yTWFzaygpIHtcbiAgICAgICAgdGhpcy5zY2lzc29yUmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY2lzc29yRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Npc3NvciA9IGZhbHNlO1xuXG4gICAgICAgIC8vIG11c3QgYmUgc2Npc3NvciFcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXNrTWFuYWdlcjtcbn0oX1dlYkdMTWFuYWdlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hc2tNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza01hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL01hc2tNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1dlYkdMTWFuYWdlcjIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpO1xuXG52YXIgX1dlYkdMTWFuYWdlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJHTE1hbmFnZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5XZWJHTE1hbmFnZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBTdGVuY2lsTWFuYWdlciA9IGZ1bmN0aW9uIChfV2ViR0xNYW5hZ2VyKSB7XG4gICAgX2luaGVyaXRzKFN0ZW5jaWxNYW5hZ2VyLCBfV2ViR0xNYW5hZ2VyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0ZW5jaWxNYW5hZ2VyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVuY2lsTWFuYWdlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1dlYkdMTWFuYWdlci5jYWxsKHRoaXMsIHJlbmRlcmVyKSk7XG5cbiAgICAgICAgX3RoaXMuc3RlbmNpbE1hc2tTdGFjayA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXNrIHN0YWNrIHRoYXQgaXMgdXNlZCBieSB0aGlzIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NbXX0gc3RlbmNpbE1hc2tTdGFjayAtIFRoZSBtYXNrIHN0YWNrXG4gICAgICovXG5cblxuICAgIFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5zZXRNYXNrU3RhY2sgPSBmdW5jdGlvbiBzZXRNYXNrU3RhY2soc3RlbmNpbE1hc2tTdGFjaykge1xuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBzdGVuY2lsTWFza1N0YWNrO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgaWYgKHN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay4gQGFsdmluXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gVGhlIG1hc2tcbiAgICAgKi9cblxuXG4gICAgU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLnB1c2hTdGVuY2lsID0gZnVuY3Rpb24gcHVzaFN0ZW5jaWwoZ3JhcGhpY3MpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcih0aGlzLnJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuX2FjdGl2ZVJlbmRlclRhcmdldC5hdHRhY2hTdGVuY2lsQnVmZmVyKCk7XG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIHNtcyA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjaztcblxuICAgICAgICBpZiAoc21zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuQUxXQVlTLCAxLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNtcy5wdXNoKGdyYXBoaWNzKTtcblxuICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuSU5DUik7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzLnJlbmRlcihncmFwaGljcyk7XG5cbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMCwgc21zLmxlbmd0aCk7XG4gICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVE9ETyBAYWx2aW5cbiAgICAgKi9cblxuXG4gICAgU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLnBvcFN0ZW5jaWwgPSBmdW5jdGlvbiBwb3BTdGVuY2lsKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHRoaXMucmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcyk7XG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIHNtcyA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjaztcblxuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBzbXMucG9wKCk7XG5cbiAgICAgICAgaWYgKHNtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayBpcyBlbXB0eSFcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuREVDUik7XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy5yZW5kZXIoZ3JhcGhpY3MpO1xuXG4gICAgICAgICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMCwgc21zLmxlbmd0aCk7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIG1hc2sgc3RhY2suXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBfV2ViR0xNYW5hZ2VyMy5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrLnN0ZW5jaWxTdGFjayA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBTdGVuY2lsTWFuYWdlcjtcbn0oX1dlYkdMTWFuYWdlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0ZW5jaWxNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RlbmNpbE1hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL1N0ZW5jaWxNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyO1xuXG52YXIgX3BpeGlHbENvcmUgPSByZXF1aXJlKCdwaXhpLWdsLWNvcmUnKTtcblxudmFyIF9waXhpR2xDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpeGlHbENvcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnJhZ1RlbXBsYXRlID0gWydwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLCAndm9pZCBtYWluKHZvaWQpeycsICdmbG9hdCB0ZXN0ID0gMC4xOycsICclZm9ybG9vcCUnLCAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsICd9J10uam9pbignXFxuJyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWF4SWZTdGF0bWVudHNJblNoYWRlcihtYXhJZnMsIGdsKSB7XG4gICAgdmFyIGNyZWF0ZVRlbXBDb250ZXh0ID0gIWdsO1xuXG4gICAgLy8gQGlmIERFQlVHXG4gICAgaWYgKG1heElmcyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgYDBgIHBhc3NlZCB0byBgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcmAnKTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICBpZiAoY3JlYXRlVGVtcENvbnRleHQpIHtcbiAgICAgICAgdmFyIHRpbnlDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgICB0aW55Q2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgdGlueUNhbnZhcy5oZWlnaHQgPSAxO1xuXG4gICAgICAgIGdsID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuY3JlYXRlQ29udGV4dCh0aW55Q2FudmFzKTtcbiAgICB9XG5cbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG5cbiAgICB3aGlsZSAodHJ1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB7XG4gICAgICAgIHZhciBmcmFnbWVudFNyYyA9IGZyYWdUZW1wbGF0ZS5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIGdlbmVyYXRlSWZUZXN0U3JjKG1heElmcykpO1xuXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICBtYXhJZnMgPSBtYXhJZnMgLyAyIHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZhbGlkIVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3JlYXRlVGVtcENvbnRleHQpIHtcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBjb250ZXh0XG4gICAgICAgIGlmIChnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpKSB7XG4gICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4SWZzO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpIHtcbiAgICB2YXIgc3JjID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heElmczsgKytpKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgc3JjICs9ICdcXG5lbHNlICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IG1heElmcyAtIDEpIHtcbiAgICAgICAgICAgIHNyYyArPSAnaWYodGVzdCA9PSAnICsgaSArICcuMCl7fSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3JjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9jaGVja01heElmU3RhdG1lbnRzSW5TaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIE1hcHMgZ2wgYmxlbmQgY29tYmluYXRpb25zIHRvIFdlYkdMLlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZnVuY3Rpb24gbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIHJlbmRlcmluZyBjb250ZXh0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2FycmF5PVtdXSAtIFRoZSBhcnJheSB0byBvdXRwdXQgaW50by5cbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBNYXBwZWQgbW9kZXMuXG4gKi9cbmZ1bmN0aW9uIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCkge1xuICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cbiAgICAvLyBUT0RPIC0gcHJlbXVsdGlwbHkgYWxwaGEgd291bGQgYmUgZGlmZmVyZW50LlxuICAgIC8vIGFkZCBhIGJvb2xlYW4gZm9yIHRoYXQhXG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLk5PUk1BTF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuQUREXSA9IFtnbC5PTkUsIGdsLkRTVF9BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLk1VTFRJUExZXSA9IFtnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5TQ1JFRU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUl07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLk9WRVJMQVldID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkRBUktFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTElHSFRFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkNPTE9SX0JVUk5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkhBUkRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLlNPRlRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgYXJyYXlbX2NvbnN0LkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuSFVFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5TQVRVUkFUSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgIGFycmF5W19jb25zdC5CTEVORF9NT0RFUy5DT0xPUl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICBhcnJheVtfY29uc3QuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcblxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIEdlbmVyaWMgTWFzayBTdGFjayBkYXRhIHN0cnVjdHVyZS5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGZ1bmN0aW9uIG1hcFdlYkdMRHJhd01vZGVzVG9QaXhpXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKiBAcGFyYW0ge29iamVjdH0gW29iamVjdD17fV0gLSBUaGUgb2JqZWN0IHRvIG1hcCBpbnRvXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBtYXBwZWQgZHJhdyBtb2Rlcy5cbiAqL1xuZnVuY3Rpb24gbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkoZ2wpIHtcbiAgdmFyIG9iamVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgb2JqZWN0W19jb25zdC5EUkFXX01PREVTLlBPSU5UU10gPSBnbC5QT0lOVFM7XG4gIG9iamVjdFtfY29uc3QuRFJBV19NT0RFUy5MSU5FU10gPSBnbC5MSU5FUztcbiAgb2JqZWN0W19jb25zdC5EUkFXX01PREVTLkxJTkVfTE9PUF0gPSBnbC5MSU5FX0xPT1A7XG4gIG9iamVjdFtfY29uc3QuRFJBV19NT0RFUy5MSU5FX1NUUklQXSA9IGdsLkxJTkVfU1RSSVA7XG4gIG9iamVjdFtfY29uc3QuRFJBV19NT0RFUy5UUklBTkdMRVNdID0gZ2wuVFJJQU5HTEVTO1xuICBvYmplY3RbX2NvbnN0LkRSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVBdID0gZ2wuVFJJQU5HTEVfU1RSSVA7XG4gIG9iamVjdFtfY29uc3QuRFJBV19NT0RFUy5UUklBTkdMRV9GQU5dID0gZ2wuVFJJQU5HTEVfRkFOO1xuXG4gIHJldHVybiBvYmplY3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBXZWJHTERyYXdNb2Rlc1RvUGl4aS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvbWFwV2ViR0xEcmF3TW9kZXNUb1BpeGkuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZUNvbnRleHQ7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHQoZ2wpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG5cbiAgICAvLyB0aGlzIGlzIGdvaW5nIHRvIGJlIGZhaXJseSBzaW1wbGUgZm9yIG5vdy4uIGJ1dCBhdCBsZWFzdCB3ZSBoYXZlIHJvb20gdG8gZ3JvdyFcbiAgICBpZiAoIWF0dHJpYnV0ZXMuc3RlbmNpbCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUud2FybignUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBoYXZlIGEgc3RlbmNpbCBidWZmZXIsIG1hc2tzIG1heSBub3QgcmVuZGVyIGNvcnJlY3RseScpO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZUNvbnRleHQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL3ZhbGlkYXRlQ29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9DYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcblxudmFyIF9DYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNSZW5kZXJlcik7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG52YXIgX21hdGggPSByZXF1aXJlKCcuLi8uLi9tYXRoJyk7XG5cbnZhciBfQ2FudmFzVGludGVyID0gcmVxdWlyZSgnLi9DYW52YXNUaW50ZXInKTtcblxudmFyIF9DYW52YXNUaW50ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzVGludGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGNhbnZhc1JlbmRlcldvcmxkVHJhbnNmb3JtID0gbmV3IF9tYXRoLk1hdHJpeCgpO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXkgbm93XG4gKiBzaGFyZSA0IGJ5dGVzIG9uIHRoZSB2ZXJ0ZXggYnVmZmVyXG4gKlxuICogSGVhdmlseSBpbnNwaXJlZCBieSBMaWJHRFgncyBDYW52YXNTcHJpdGVSZW5kZXJlcjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvQ2FudmFzU3ByaXRlUmVuZGVyZXIuamF2YVxuICovXG5cbi8qKlxuICogUmVuZGVyZXIgZGVkaWNhdGVkIHRvIGRyYXdpbmcgYW5kIGJhdGNoaW5nIHNwcml0ZXMuXG4gKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuXG52YXIgQ2FudmFzU3ByaXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC1UaGUgcmVuZGVyZXIgc3ByaXRlIHRoaXMgYmF0Y2ggd29ya3MgZm9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbnZhc1Nwcml0ZVJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNTcHJpdGVSZW5kZXJlcik7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcbiAgICAgKi9cblxuXG4gICAgQ2FudmFzU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzcHJpdGUpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHd0ID0gc3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGR4ID0gMDtcbiAgICAgICAgdmFyIGR5ID0gMDtcblxuICAgICAgICBpZiAodGV4dHVyZS5vcmlnLndpZHRoIDw9IDAgfHwgdGV4dHVyZS5vcmlnLmhlaWdodCA8PSAwIHx8ICF0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0QmxlbmRNb2RlKHNwcml0ZS5ibGVuZE1vZGUpO1xuXG4gICAgICAgIC8vICBJZ25vcmUgbnVsbCBzb3VyY2VzXG4gICAgICAgIGlmICh0ZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0Lmdsb2JhbEFscGhhID0gc3ByaXRlLndvcmxkQWxwaGE7XG5cbiAgICAgICAgICAgIC8vIElmIHNtb290aGluZ0VuYWJsZWQgaXMgc3VwcG9ydGVkIGFuZCB3ZSBuZWVkIHRvIGNoYW5nZSB0aGUgc21vb3RoaW5nIHByb3BlcnR5IGZvciBzcHJpdGUgdGV4dHVyZVxuICAgICAgICAgICAgdmFyIHNtb290aGluZ0VuYWJsZWQgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnNjYWxlTW9kZSA9PT0gX2NvbnN0LlNDQUxFX01PREVTLkxJTkVBUjtcblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLnNtb290aFByb3BlcnR5ICYmIHJlbmRlcmVyLmNvbnRleHRbcmVuZGVyZXIuc21vb3RoUHJvcGVydHldICE9PSBzbW9vdGhpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dFtyZW5kZXJlci5zbW9vdGhQcm9wZXJ0eV0gPSBzbW9vdGhpbmdFbmFibGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dHVyZS50cmltKSB7XG4gICAgICAgICAgICAgICAgZHggPSB0ZXh0dXJlLnRyaW0ud2lkdGggLyAyICsgdGV4dHVyZS50cmltLnggLSBzcHJpdGUuYW5jaG9yLnggKiB0ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgICAgICAgICAgICAgZHkgPSB0ZXh0dXJlLnRyaW0uaGVpZ2h0IC8gMiArIHRleHR1cmUudHJpbS55IC0gc3ByaXRlLmFuY2hvci55ICogdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHggPSAoMC41IC0gc3ByaXRlLmFuY2hvci54KSAqIHRleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgICAgICAgICBkeSA9ICgwLjUgLSBzcHJpdGUuYW5jaG9yLnkpICogdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHR1cmUucm90YXRlKSB7XG4gICAgICAgICAgICAgICAgd3QuY29weShjYW52YXNSZW5kZXJXb3JsZFRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgd3QgPSBjYW52YXNSZW5kZXJXb3JsZFRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBfbWF0aC5Hcm91cEQ4Lm1hdHJpeEFwcGVuZFJvdGF0aW9uSW52KHd0LCB0ZXh0dXJlLnJvdGF0ZSwgZHgsIGR5KTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgYW5jaG9yIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCBhYm92ZSwgc28gbGV0cyBzZXQgaXQgdG8gemVyb1xuICAgICAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR4IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIGR5IC09IGhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGZvciBwaXhlbCByb3VuZGluZ1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLnJvdW5kUGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0od3QuYSwgd3QuYiwgd3QuYywgd3QuZCwgd3QudHggKiByZW5kZXJlci5yZXNvbHV0aW9uIHwgMCwgd3QudHkgKiByZW5kZXJlci5yZXNvbHV0aW9uIHwgMCk7XG5cbiAgICAgICAgICAgICAgICBkeCA9IGR4IHwgMDtcbiAgICAgICAgICAgICAgICBkeSA9IGR5IHwgMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0od3QuYSwgd3QuYiwgd3QuYywgd3QuZCwgd3QudHggKiByZW5kZXJlci5yZXNvbHV0aW9uLCB3dC50eSAqIHJlbmRlcmVyLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcblxuICAgICAgICAgICAgaWYgKHNwcml0ZS50aW50ICE9PSAweEZGRkZGRikge1xuICAgICAgICAgICAgICAgIGlmIChzcHJpdGUuY2FjaGVkVGludCAhPT0gc3ByaXRlLnRpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmNhY2hlZFRpbnQgPSBzcHJpdGUudGludDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNsZWFuIHVwIGNhY2hpbmcgLSBob3cgdG8gY2xlYW4gdXAgdGhlIGNhY2hlcz9cbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnRpbnRlZFRleHR1cmUgPSBfQ2FudmFzVGludGVyMi5kZWZhdWx0LmdldFRpbnRlZFRleHR1cmUoc3ByaXRlLCBzcHJpdGUudGludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dC5kcmF3SW1hZ2Uoc3ByaXRlLnRpbnRlZFRleHR1cmUsIDAsIDAsIHdpZHRoICogcmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVzb2x1dGlvbiwgZHggKiByZW5kZXJlci5yZXNvbHV0aW9uLCBkeSAqIHJlbmRlcmVyLnJlc29sdXRpb24sIHdpZHRoICogcmVuZGVyZXIucmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVuZGVyZXIucmVzb2x1dGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCB0ZXh0dXJlLl9mcmFtZS54ICogcmVzb2x1dGlvbiwgdGV4dHVyZS5fZnJhbWUueSAqIHJlc29sdXRpb24sIHdpZHRoICogcmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVzb2x1dGlvbiwgZHggKiByZW5kZXJlci5yZXNvbHV0aW9uLCBkeSAqIHJlbmRlcmVyLnJlc29sdXRpb24sIHdpZHRoICogcmVuZGVyZXIucmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVuZGVyZXIucmVzb2x1dGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgc3ByaXRlIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBDYW52YXNTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FudmFzU3ByaXRlUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc1Nwcml0ZVJlbmRlcmVyO1xuXG5cbl9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdC5yZWdpc3RlclBsdWdpbignc3ByaXRlJywgQ2FudmFzU3ByaXRlUmVuZGVyZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzU3ByaXRlUmVuZGVyZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvc3ByaXRlcy9jYW52YXMvQ2FudmFzU3ByaXRlUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBCdWZmZXIoc2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXIpO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcblxuICAgIC8qKlxuICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgRmxvYXQzMkFycmF5IGZvciBwb3NpdGlvbnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRpY2VzKTtcblxuICAgIC8qKlxuICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgVWludDMyQXJyYXkgZm9yIHV2c1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMudWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZlcnRpY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgYnVmZmVyLlxuICAgKlxuICAgKi9cblxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IG51bGw7XG4gICAgdGhpcy5wb3NpdGlvbnMgPSBudWxsO1xuICAgIHRoaXMudXZzID0gbnVsbDtcbiAgICB0aGlzLmNvbG9ycyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hCdWZmZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvc3ByaXRlcy93ZWJnbC9CYXRjaEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9PYmplY3RSZW5kZXJlcjIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXInKTtcblxudmFyIF9PYmplY3RSZW5kZXJlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYmplY3RSZW5kZXJlcjIpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpO1xuXG52YXIgX1dlYkdMUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViR0xSZW5kZXJlcik7XG5cbnZhciBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY3JlYXRlSW5kaWNlc0ZvclF1YWRzJyk7XG5cbnZhciBfY3JlYXRlSW5kaWNlc0ZvclF1YWRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUluZGljZXNGb3JRdWFkcyk7XG5cbnZhciBfZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIgPSByZXF1aXJlKCcuL2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyJyk7XG5cbnZhciBfZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIpO1xuXG52YXIgX2NoZWNrTWF4SWZTdGF0bWVudHNJblNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC91dGlscy9jaGVja01heElmU3RhdG1lbnRzSW5TaGFkZXInKTtcblxudmFyIF9jaGVja01heElmU3RhdG1lbnRzSW5TaGFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hlY2tNYXhJZlN0YXRtZW50c0luU2hhZGVyKTtcblxudmFyIF9CYXRjaEJ1ZmZlciA9IHJlcXVpcmUoJy4vQmF0Y2hCdWZmZXInKTtcblxudmFyIF9CYXRjaEJ1ZmZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXRjaEJ1ZmZlcik7XG5cbnZhciBfc2V0dGluZ3MgPSByZXF1aXJlKCcuLi8uLi9zZXR0aW5ncycpO1xuXG52YXIgX3NldHRpbmdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldHRpbmdzKTtcblxudmFyIF9waXhpR2xDb3JlID0gcmVxdWlyZSgncGl4aS1nbC1jb3JlJyk7XG5cbnZhciBfcGl4aUdsQ29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waXhpR2xDb3JlKTtcblxudmFyIF9iaXRUd2lkZGxlID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKTtcblxudmFyIF9iaXRUd2lkZGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpdFR3aWRkbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUSUNLID0gMDtcbnZhciBURVhUVVJFX1RJQ0sgPSAwO1xuXG4vKipcbiAqIFJlbmRlcmVyIGRlZGljYXRlZCB0byBkcmF3aW5nIGFuZCBiYXRjaGluZyBzcHJpdGVzLlxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXG4gKi9cblxudmFyIFNwcml0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKF9PYmplY3RSZW5kZXJlcikge1xuICAgIF9pbmhlcml0cyhTcHJpdGVSZW5kZXJlciwgX09iamVjdFJlbmRlcmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UElYSS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIHNwcml0ZSBiYXRjaCB3b3JrcyBmb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3ByaXRlUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwcml0ZVJlbmRlcmVyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIHZhbHVlcyBzZW50IGluIHRoZSB2ZXJ0ZXggYnVmZmVyLlxuICAgICAgICAgKiBhVmVydGV4UG9zaXRpb24oMiksIGFUZXh0dXJlQ29vcmQoMSksIGFDb2xvcigxKSwgYVRleHR1cmVJZCgxKSA9IDVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX09iamVjdFJlbmRlcmVyLmNhbGwodGhpcywgcmVuZGVyZXIpKTtcblxuICAgICAgICBfdGhpcy52ZXJ0U2l6ZSA9IDU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSB2ZXJ0ZXggaW5mb3JtYXRpb24gaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZlcnRCeXRlU2l6ZSA9IF90aGlzLnZlcnRTaXplICogNDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgaW4gdGhlIFNwcml0ZVJlbmRlcmVyIGJlZm9yZSBpdCBmbHVzaGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zaXplID0gX3NldHRpbmdzMi5kZWZhdWx0LlNQUklURV9CQVRDSF9TSVpFOyAvLyAyMDAwIGlzIGEgbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIC8gZGVza3RvcFxuXG4gICAgICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gb3VyIGJhdGNoXG4gICAgICAgIC8vIGxldCBudW1WZXJ0cyA9IHRoaXMuc2l6ZSAqIDQgKiB0aGlzLnZlcnRCeXRlU2l6ZTtcblxuICAgICAgICBfdGhpcy5idWZmZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IF9iaXRUd2lkZGxlMi5kZWZhdWx0Lm5leHRQb3cyKF90aGlzLnNpemUpOyBpICo9IDIpIHtcbiAgICAgICAgICAgIF90aGlzLmJ1ZmZlcnMucHVzaChuZXcgX0JhdGNoQnVmZmVyMi5kZWZhdWx0KGkgKiA0ICogX3RoaXMudmVydEJ5dGVTaXplKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIGluZGljZXMgb2YgdGhlIGdlb21ldHJ5IChxdWFkcykgdG8gZHJhd1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluZGljZXMgPSAoMCwgX2NyZWF0ZUluZGljZXNGb3JRdWFkczIuZGVmYXVsdCkoX3RoaXMuc2l6ZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHNoYWRlcnMgdGhhdCBpcyB1c2VkIGlmIGEgc3ByaXRlIGRvZXNuJ3QgaGF2ZSBhIG1vcmUgc3BlY2lmaWMgb25lLlxuICAgICAgICAgKiB0aGVyZSBpcyBhIHNoYWRlciBmb3IgZWFjaCBudW1iZXIgb2YgdGV4dHVyZXMgdGhhdCBjYW4gYmUgcmVuZGVyZXJkLlxuICAgICAgICAgKiBUaGVzZSBzaGFkZXJzIHdpbGwgYWxzbyBiZSBnZW5lcmF0ZWQgb24gdGhlIGZseSBhcyByZXF1aXJlZC5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgX3RoaXMuZ3JvdXBzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBfdGhpcy5zaXplOyBrKyspIHtcbiAgICAgICAgICAgIF90aGlzLmdyb3Vwc1trXSA9IHsgdGV4dHVyZXM6IFtdLCB0ZXh0dXJlQ291bnQ6IDAsIGlkczogW10sIHNpemU6IDAsIHN0YXJ0OiAwLCBibGVuZDogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc3ByaXRlcyA9IFtdO1xuXG4gICAgICAgIF90aGlzLnZlcnRleEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgX3RoaXMudmFvcyA9IFtdO1xuXG4gICAgICAgIF90aGlzLnZhb01heCA9IDI7XG4gICAgICAgIF90aGlzLnZlcnRleENvdW50ID0gMDtcblxuICAgICAgICBfdGhpcy5yZW5kZXJlci5vbigncHJlcmVuZGVyJywgX3RoaXMub25QcmVyZW5kZXIsIF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uIG9uQ29udGV4dENoYW5nZSgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5sZWdhY3kpIHtcbiAgICAgICAgICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0ZXAgMTogZmlyc3QgY2hlY2sgbWF4IHRleHR1cmVzIHRoZSBHUFUgY2FuIGhhbmRsZS5cbiAgICAgICAgICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gTWF0aC5taW4oZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSwgX3NldHRpbmdzMi5kZWZhdWx0LlNQUklURV9NQVhfVEVYVFVSRVMpO1xuXG4gICAgICAgICAgICAvLyBzdGVwIDI6IGNoZWNrIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpZiBzdGF0ZW1lbnRzIHRoZSBzaGFkZXIgY2FuIGhhdmUgdG9vLi5cbiAgICAgICAgICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gKDAsIF9jaGVja01heElmU3RhdG1lbnRzSW5TaGFkZXIyLmRlZmF1bHQpKHRoaXMuTUFYX1RFWFRVUkVTLCBnbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5zaGFkZXIgPSAoMCwgX2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyMi5kZWZhdWx0KShnbCwgdGhpcy5NQVhfVEVYVFVSRVMpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGNvdXBsZSBvZiBidWZmZXJzXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBfcGl4aUdsQ29yZTIuZGVmYXVsdC5HTEJ1ZmZlci5jcmVhdGVJbmRleEJ1ZmZlcihnbCwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgLy8gd2UgdXNlIHRoZSBzZWNvbmQgc2hhZGVyIGFzIHRoZSBmaXJzdCBvbmUgZGVwZW5kaW5nIG9uIHlvdXIgYnJvd3NlciBtYXkgb21pdCBhVGV4dHVyZUlkXG4gICAgICAgIC8vIGFzIGl0IGlzIG5vdCB1c2VkIGJ5IHRoZSBzaGFkZXIgc28gaXMgb3B0aW1pemVkIG91dC5cblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmJpbmRWYW8obnVsbCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhb01heDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnNbaV0gPSBfcGl4aUdsQ29yZTIuZGVmYXVsdC5HTEJ1ZmZlci5jcmVhdGVWZXJ0ZXhCdWZmZXIoZ2wsIG51bGwsIGdsLlNUUkVBTV9EUkFXKTtcblxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICAgICAgICAvLyBidWlsZCB0aGUgdmFvIG9iamVjdCB0aGF0IHdpbGwgcmVuZGVyLi5cbiAgICAgICAgICAgIHRoaXMudmFvc1tpXSA9IHRoaXMucmVuZGVyZXIuY3JlYXRlVmFvKCkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcikuYWRkQXR0cmlidXRlKHRoaXMudmVydGV4QnVmZmVyc1tpXSwgc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMudmVydEJ5dGVTaXplLCAwKS5hZGRBdHRyaWJ1dGUodGhpcy52ZXJ0ZXhCdWZmZXJzW2ldLCBzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCBnbC5VTlNJR05FRF9TSE9SVCwgdHJ1ZSwgdGhpcy52ZXJ0Qnl0ZVNpemUsIDIgKiA0KS5hZGRBdHRyaWJ1dGUodGhpcy52ZXJ0ZXhCdWZmZXJzW2ldLCBzaGFkZXIuYXR0cmlidXRlcy5hQ29sb3IsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIHRoaXMudmVydEJ5dGVTaXplLCAzICogNCk7XG5cbiAgICAgICAgICAgIGlmIChzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YW9zW2ldLmFkZEF0dHJpYnV0ZSh0aGlzLnZlcnRleEJ1ZmZlcnNbaV0sIHNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlSWQsIGdsLkZMT0FULCBmYWxzZSwgdGhpcy52ZXJ0Qnl0ZVNpemUsIDQgKiA0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbyA9IHRoaXMudmFvc1swXTtcbiAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gOTk5OTk7XG5cbiAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzID0gbmV3IEFycmF5KHRoaXMuTUFYX1RFWFRVUkVTKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJlZm9yZSB0aGUgcmVuZGVyZXIgc3RhcnRzIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVSZW5kZXJlci5wcm90b3R5cGUub25QcmVyZW5kZXIgPSBmdW5jdGlvbiBvblByZXJlbmRlcigpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzcHJpdGUpIHtcbiAgICAgICAgLy8gVE9ETyBzZXQgYmxlbmQgbW9kZXMuLlxuICAgICAgICAvLyBjaGVjayB0ZXh0dXJlLi5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEluZGV4ID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB1dnMgZm9yIHRoZSB0ZXh0dXJlXG5cbiAgICAgICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgICAgICBpZiAoIXNwcml0ZS5fdGV4dHVyZS5fdXZzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdXNoIGEgdGV4dHVyZS5cbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNpemVcbiAgICAgICAgdGhpcy5zcHJpdGVzW3RoaXMuY3VycmVudEluZGV4KytdID0gc3ByaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIFNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciBNQVhfVEVYVFVSRVMgPSB0aGlzLk1BWF9URVhUVVJFUztcblxuICAgICAgICB2YXIgbnAyID0gX2JpdFR3aWRkbGUyLmRlZmF1bHQubmV4dFBvdzIodGhpcy5jdXJyZW50SW5kZXgpO1xuICAgICAgICB2YXIgbG9nMiA9IF9iaXRUd2lkZGxlMi5kZWZhdWx0LmxvZzIobnAyKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1tsb2cyXTtcblxuICAgICAgICB2YXIgc3ByaXRlcyA9IHRoaXMuc3ByaXRlcztcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG4gICAgICAgIHZhciBmbG9hdDMyVmlldyA9IGJ1ZmZlci5mbG9hdDMyVmlldztcbiAgICAgICAgdmFyIHVpbnQzMlZpZXcgPSBidWZmZXIudWludDMyVmlldztcblxuICAgICAgICB2YXIgYm91bmRUZXh0dXJlcyA9IHRoaXMuYm91bmRUZXh0dXJlcztcbiAgICAgICAgdmFyIHJlbmRlcmVyQm91bmRUZXh0dXJlcyA9IHRoaXMucmVuZGVyZXIuYm91bmRUZXh0dXJlcztcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG5leHRUZXh0dXJlID0gdm9pZCAwO1xuICAgICAgICB2YXIgY3VycmVudFRleHR1cmUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBncm91cENvdW50ID0gMTtcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBncm91cHNbMF07XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gdm9pZCAwO1xuICAgICAgICB2YXIgdXZzID0gdm9pZCAwO1xuICAgICAgICB2YXIgYmxlbmRNb2RlID0gc3ByaXRlc1swXS5ibGVuZE1vZGU7XG5cbiAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IDA7XG4gICAgICAgIGN1cnJlbnRHcm91cC5ibGVuZCA9IGJsZW5kTW9kZTtcblxuICAgICAgICBUSUNLKys7XG5cbiAgICAgICAgdmFyIGkgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gY29weSB0ZXh0dXJlcy4uXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBNQVhfVEVYVFVSRVM7ICsraSkge1xuICAgICAgICAgICAgYm91bmRUZXh0dXJlc1tpXSA9IHJlbmRlcmVyQm91bmRUZXh0dXJlc1tpXTtcbiAgICAgICAgICAgIGJvdW5kVGV4dHVyZXNbaV0uX3ZpcnRhbEJvdW5kSWQgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY3VycmVudEluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIC8vIHVwbG9hZCB0aGUgc3ByaXRlIGVsZW1ldG5zLi4uXG4gICAgICAgICAgICAvLyB0aGV5IGhhdmUgYWxsIHJlYWR5IGJlZW4gY2FsY3VsYXRlZCBzbyB3ZSBqdXN0IG5lZWQgdG8gcHVzaCB0aGVtIGludG8gdGhlIGJ1ZmZlci5cbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVzW2ldO1xuXG4gICAgICAgICAgICBuZXh0VGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgICAgICAgICAgaWYgKGJsZW5kTW9kZSAhPT0gc3ByaXRlLmJsZW5kTW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGZpbmlzaCBhIGdyb3VwLi5cbiAgICAgICAgICAgICAgICBibGVuZE1vZGUgPSBzcHJpdGUuYmxlbmRNb2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGJhdGNoIHRvIGJyZWFrIVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSBNQVhfVEVYVFVSRVM7XG4gICAgICAgICAgICAgICAgVElDSysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHR1cmUgIT09IG5leHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBuZXh0VGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0VGV4dHVyZS5fZW5hYmxlZCAhPT0gVElDSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZUNvdW50ID09PSBNQVhfVEVYVFVSRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRJQ0srKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSBpIC0gY3VycmVudEdyb3VwLnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBncm91cHNbZ3JvdXBDb3VudCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5ibGVuZCA9IGJsZW5kTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLnRvdWNoZWQgPSB0b3VjaDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRleHR1cmUuX3ZpcnRhbEJvdW5kSWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IE1BWF9URVhUVVJFUzsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRJbmRleCA9IChqICsgVEVYVFVSRV9USUNLKSAlIE1BWF9URVhUVVJFUztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYm91bmRUZXh0dXJlc1t0SW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuX2VuYWJsZWQgIT09IFRJQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEVYVFVSRV9USUNLKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5fdmlydGFsQm91bmRJZCA9IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLl92aXJ0YWxCb3VuZElkID0gdEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kVGV4dHVyZXNbdEluZGV4XSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5fZW5hYmxlZCA9IFRJQ0s7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuaWRzW3RleHR1cmVDb3VudF0gPSBuZXh0VGV4dHVyZS5fdmlydGFsQm91bmRJZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVzW3RleHR1cmVDb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVydGV4RGF0YSA9IHNwcml0ZS52ZXJ0ZXhEYXRhO1xuXG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgc3VtIGRvZXMgbm90IG5lZWQgdG8gYmUgc2V0IGVhY2ggZnJhbWUuLlxuICAgICAgICAgICAgdXZzID0gc3ByaXRlLl90ZXh0dXJlLl91dnMudXZzVWludDMyO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5yb3VuZFBpeGVscykge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgICAgICAgICAgLy8geHlcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSAodmVydGV4RGF0YVswXSAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxXSA9ICh2ZXJ0ZXhEYXRhWzFdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyA1XSA9ICh2ZXJ0ZXhEYXRhWzJdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDZdID0gKHZlcnRleERhdGFbM10gKiByZXNvbHV0aW9uIHwgMCkgLyByZXNvbHV0aW9uO1xuXG4gICAgICAgICAgICAgICAgLy8geHlcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDEwXSA9ICh2ZXJ0ZXhEYXRhWzRdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDExXSA9ICh2ZXJ0ZXhEYXRhWzVdICogcmVzb2x1dGlvbiB8IDApIC8gcmVzb2x1dGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxNV0gPSAodmVydGV4RGF0YVs2XSAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxNl0gPSAodmVydGV4RGF0YVs3XSAqIHJlc29sdXRpb24gfCAwKSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXhdID0gdmVydGV4RGF0YVswXTtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDFdID0gdmVydGV4RGF0YVsxXTtcblxuICAgICAgICAgICAgICAgIC8vIHh5XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyA1XSA9IHZlcnRleERhdGFbMl07XG4gICAgICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyA2XSA9IHZlcnRleERhdGFbM107XG5cbiAgICAgICAgICAgICAgICAvLyB4eVxuICAgICAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMTBdID0gdmVydGV4RGF0YVs0XTtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDExXSA9IHZlcnRleERhdGFbNV07XG5cbiAgICAgICAgICAgICAgICAvLyB4eVxuICAgICAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMTVdID0gdmVydGV4RGF0YVs2XTtcbiAgICAgICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDE2XSA9IHZlcnRleERhdGFbN107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyAyXSA9IHV2c1swXTtcbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyA3XSA9IHV2c1sxXTtcbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyAxMl0gPSB1dnNbMl07XG4gICAgICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgMTddID0gdXZzWzNdO1xuXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgM10gPSB1aW50MzJWaWV3W2luZGV4ICsgOF0gPSB1aW50MzJWaWV3W2luZGV4ICsgMTNdID0gdWludDMyVmlld1tpbmRleCArIDE4XSA9IHNwcml0ZS5fdGludFJHQiArIChNYXRoLm1pbihzcHJpdGUud29ybGRBbHBoYSwgMSkgKiAyNTUgPDwgMjQpO1xuXG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDRdID0gZmxvYXQzMlZpZXdbaW5kZXggKyA5XSA9IGZsb2F0MzJWaWV3W2luZGV4ICsgMTRdID0gZmxvYXQzMlZpZXdbaW5kZXggKyAxOV0gPSBuZXh0VGV4dHVyZS5fdmlydGFsQm91bmRJZDtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgICAgICAgICBpbmRleCArPSAyMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRHcm91cC5zaXplID0gaSAtIGN1cnJlbnRHcm91cC5zdGFydDtcblxuICAgICAgICBpZiAoIV9zZXR0aW5nczIuZGVmYXVsdC5DQU5fVVBMT0FEX1NBTUVfQlVGRkVSKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHN0aWxsIG5lZWRlZCBmb3IgSU9TIHBlcmZvcm1hbmNlLi5cbiAgICAgICAgICAgIC8vIGl0IHJlYWxseSBkb2VzIG5vdCBsaWtlIHVwbG9hZGluZyB0byB0aGUgc2FtZSBidWZmZXIgaW4gYSBzaW5nbGUgZnJhbWUhXG4gICAgICAgICAgICBpZiAodGhpcy52YW9NYXggPD0gdGhpcy52ZXJ0ZXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFvTWF4Kys7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzW3RoaXMudmVydGV4Q291bnRdID0gX3BpeGlHbENvcmUyLmRlZmF1bHQuR0xCdWZmZXIuY3JlYXRlVmVydGV4QnVmZmVyKGdsLCBudWxsLCBnbC5TVFJFQU1fRFJBVyk7XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbiAgICAgICAgICAgICAgICAvLyBidWlsZCB0aGUgdmFvIG9iamVjdCB0aGF0IHdpbGwgcmVuZGVyLi5cbiAgICAgICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0gPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZVZhbygpLmFkZEluZGV4KHRoaXMuaW5kZXhCdWZmZXIpLmFkZEF0dHJpYnV0ZSh0aGlzLnZlcnRleEJ1ZmZlcnNbdGhpcy52ZXJ0ZXhDb3VudF0sIHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMudmVydEJ5dGVTaXplLCAwKS5hZGRBdHRyaWJ1dGUodGhpcy52ZXJ0ZXhCdWZmZXJzW3RoaXMudmVydGV4Q291bnRdLCB0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsIGdsLlVOU0lHTkVEX1NIT1JULCB0cnVlLCB0aGlzLnZlcnRCeXRlU2l6ZSwgMiAqIDQpLmFkZEF0dHJpYnV0ZSh0aGlzLnZlcnRleEJ1ZmZlcnNbdGhpcy52ZXJ0ZXhDb3VudF0sIHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCB0aGlzLnZlcnRCeXRlU2l6ZSwgMyAqIDQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYVRleHR1cmVJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uYWRkQXR0cmlidXRlKHRoaXMudmVydGV4QnVmZmVyc1t0aGlzLnZlcnRleENvdW50XSwgdGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUlkLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMudmVydEJ5dGVTaXplLCA0ICogNCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYmluZFZhbyh0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0pO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnNbdGhpcy52ZXJ0ZXhDb3VudF0udXBsb2FkKGJ1ZmZlci52ZXJ0aWNlcywgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBsZXRzIHVzZSB0aGUgZmFzdGVyIG9wdGlvbiwgYWx3YXlzIHVzZSBidWZmZXIgbnVtYmVyIDBcbiAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVyc1t0aGlzLnZlcnRleENvdW50XS51cGxvYWQoYnVmZmVyLnZlcnRpY2VzLCAwLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBNQVhfVEVYVFVSRVM7ICsraSkge1xuICAgICAgICAgICAgcmVuZGVyZXJCb3VuZFRleHR1cmVzW2ldLl92aXJ0YWxCb3VuZElkID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW5kZXIgdGhlIGdyb3Vwcy4uXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIHZhciBncm91cFRleHR1cmVDb3VudCA9IGdyb3VwLnRleHR1cmVDb3VudDtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGdyb3VwVGV4dHVyZUNvdW50OyBfaisrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBncm91cC50ZXh0dXJlc1tfal07XG5cbiAgICAgICAgICAgICAgICAvLyByZXNldCB2aXJ0dWFsIGlkcy4uXG4gICAgICAgICAgICAgICAgLy8gbGV0cyBkbyBhIHF1aWNrIGNoZWNrLi5cbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXJCb3VuZFRleHR1cmVzW2dyb3VwLmlkc1tfal1dICE9PSBjdXJyZW50VGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmJpbmRUZXh0dXJlKGN1cnJlbnRUZXh0dXJlLCBncm91cC5pZHNbX2pdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgdmlydHVhbElkLi5cbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZS5fdmlydGFsQm91bmRJZCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIGJsZW5kIG1vZGUuLlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXRCbGVuZE1vZGUoZ3JvdXAuYmxlbmQpO1xuXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBncm91cC5zaXplICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIGdyb3VwLnN0YXJ0ICogNiAqIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgZWxlbWVudHMgZm9yIHRoZSBuZXh0IGZsdXNoXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHNwcml0ZSBiYXRjaC5cbiAgICAgKi9cblxuXG4gICAgU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYmluZFNoYWRlcih0aGlzLnNoYWRlcik7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5nczIuZGVmYXVsdC5DQU5fVVBMT0FEX1NBTUVfQlVGRkVSKSB7XG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlciAjMCwgd2UgZG9uJ3QgbmVlZCBvdGhlcnNcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYmluZFZhbyh0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0pO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnNbdGhpcy52ZXJ0ZXhDb3VudF0uYmluZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuZCBmbHVzaGVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIFNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgU3ByaXRlUmVuZGVyZXIuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmFvTWF4OyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleEJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnNbaV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmFvc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFvc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlcmVyLm9mZigncHJlcmVuZGVyJywgdGhpcy5vblByZXJlbmRlciwgdGhpcyk7XG5cbiAgICAgICAgX09iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnZhb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNwcml0ZXMgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyArK19pKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnNbX2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU3ByaXRlUmVuZGVyZXI7XG59KF9PYmplY3RSZW5kZXJlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNwcml0ZVJlbmRlcmVyO1xuXG5cbl9XZWJHTFJlbmRlcmVyMi5kZWZhdWx0LnJlZ2lzdGVyUGx1Z2luKCdzcHJpdGUnLCBTcHJpdGVSZW5kZXJlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGVSZW5kZXJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL3dlYmdsL1Nwcml0ZVJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXI7XG5cbnZhciBfU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vU2hhZGVyJyk7XG5cbnZhciBfU2hhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYWRlcik7XG5cbnZhciBfcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZyYWdUZW1wbGF0ZSA9IFsndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JywgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JywgJ3ZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDsnLCAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJzWyVjb3VudCVdOycsICd2b2lkIG1haW4odm9pZCl7JywgJ3ZlYzQgY29sb3I7JywgJ2Zsb2F0IHRleHR1cmVJZCA9IGZsb29yKHZUZXh0dXJlSWQrMC41KTsnLCAnJWZvcmxvb3AlJywgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yICogdkNvbG9yOycsICd9J10uam9pbignXFxuJyk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyKGdsLCBtYXhUZXh0dXJlcykge1xuICAgIHZhciB2ZXJ0ZXhTcmMgPSAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgYVRleHR1cmVJZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdlRleHR1cmVJZCA9IGFUZXh0dXJlSWQ7XFxuICAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxufVxcbic7XG4gICAgdmFyIGZyYWdtZW50U3JjID0gZnJhZ1RlbXBsYXRlO1xuXG4gICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lY291bnQlL2dpLCBtYXhUZXh0dXJlcyk7XG4gICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIGdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSk7XG5cbiAgICB2YXIgc2hhZGVyID0gbmV3IF9TaGFkZXIyLmRlZmF1bHQoZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xuXG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG4gICAgfVxuXG4gICAgc2hhZGVyLmJpbmQoKTtcbiAgICBzaGFkZXIudW5pZm9ybXMudVNhbXBsZXJzID0gc2FtcGxlVmFsdWVzO1xuXG4gICAgcmV0dXJuIHNoYWRlcjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpIHtcbiAgICB2YXIgc3JjID0gJyc7XG5cbiAgICBzcmMgKz0gJ1xcbic7XG4gICAgc3JjICs9ICdcXG4nO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgc3JjICs9ICdcXG5lbHNlICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IG1heFRleHR1cmVzIC0gMSkge1xuICAgICAgICAgICAgc3JjICs9ICdpZih0ZXh0dXJlSWQgPT0gJyArIGkgKyAnLjApJztcbiAgICAgICAgfVxuXG4gICAgICAgIHNyYyArPSAnXFxueyc7XG4gICAgICAgIHNyYyArPSAnXFxuXFx0Y29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXJzWycgKyBpICsgJ10sIHZUZXh0dXJlQ29vcmQpOyc7XG4gICAgICAgIHNyYyArPSAnXFxufSc7XG4gICAgfVxuXG4gICAgc3JjICs9ICdcXG4nO1xuICAgIHNyYyArPSAnXFxuJztcblxuICAgIHJldHVybiBzcmM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZU11bHRpVGV4dHVyZVNoYWRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS9zcHJpdGVzL3dlYmdsL2dlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1Nwcml0ZTIgPSByZXF1aXJlKCcuLi9zcHJpdGVzL1Nwcml0ZScpO1xuXG52YXIgX1Nwcml0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcHJpdGUyKTtcblxudmFyIF9UZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvVGV4dHVyZScpO1xuXG52YXIgX1RleHR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dHVyZSk7XG5cbnZhciBfbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfVGV4dFN0eWxlID0gcmVxdWlyZSgnLi9UZXh0U3R5bGUnKTtcblxudmFyIF9UZXh0U3R5bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dFN0eWxlKTtcblxudmFyIF90cmltQ2FudmFzID0gcmVxdWlyZSgnLi4vdXRpbHMvdHJpbUNhbnZhcycpO1xuXG52YXIgX3RyaW1DYW52YXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbUNhbnZhcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyogZXNsaW50IG1heC1kZXB0aDogWzIsIDhdICovXG5cblxudmFyIGRlZmF1bHREZXN0cm95T3B0aW9ucyA9IHtcbiAgICB0ZXh0dXJlOiB0cnVlLFxuICAgIGNoaWxkcmVuOiBmYWxzZSxcbiAgICBiYXNlVGV4dHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBBIFRleHQgT2JqZWN0IHdpbGwgY3JlYXRlIGEgbGluZSBvciBtdWx0aXBsZSBsaW5lcyBvZiB0ZXh0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicgaW4geW91ciB0ZXh0IHN0cmluZyxcbiAqIG9yIGFkZCBhIHdvcmRXcmFwIHByb3BlcnR5IHNldCB0byB0cnVlIGFuZCBhbmQgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eSB3aXRoIGEgdmFsdWUgaW4gdGhlIHN0eWxlIG9iamVjdC5cbiAqXG4gKiBBIFRleHQgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBhIHN0cmluZyBhbmQgYSBzdHlsZSBvYmplY3RcbiAqXG4gKiBgYGBqc1xuICogbGV0IHRleHQgPSBuZXcgUElYSS5UZXh0KCdUaGlzIGlzIGEgcGl4aSB0ZXh0Jyx7Zm9udEZhbWlseSA6ICdBcmlhbCcsIGZvbnRTaXplOiAyNCwgZmlsbCA6IDB4ZmYxMDEwLCBhbGlnbiA6ICdjZW50ZXInfSk7XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuU3ByaXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5cbnZhciBUZXh0ID0gZnVuY3Rpb24gKF9TcHJpdGUpIHtcbiAgICBfaW5oZXJpdHMoVGV4dCwgX1Nwcml0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSBzdHJpbmcgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gICAgICogQHBhcmFtIHtvYmplY3R8UElYSS5UZXh0U3R5bGV9IFtzdHlsZV0gLSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtjYW52YXNdIC0gVGhlIGNhbnZhcyBlbGVtZW50IGZvciBkcmF3aW5nIHRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0KHRleHQsIHN0eWxlLCBjYW52YXMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHQpO1xuXG4gICAgICAgIGNhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSAzO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMztcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IF9UZXh0dXJlMi5kZWZhdWx0LmZyb21DYW52YXMoY2FudmFzKTtcblxuICAgICAgICB0ZXh0dXJlLm9yaWcgPSBuZXcgX21hdGguUmVjdGFuZ2xlKCk7XG4gICAgICAgIHRleHR1cmUudHJpbSA9IG5ldyBfbWF0aC5SZWN0YW5nbGUoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0b1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TcHJpdGUuY2FsbCh0aGlzLCB0ZXh0dXJlKSk7XG5cbiAgICAgICAgX3RoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcbiAgICAgICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY29udGV4dCA9IF90aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLiBUaGlzIGlzIHNldCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yZXNvbHV0aW9uID0gX3NldHRpbmdzMi5kZWZhdWx0LlJFU09MVVRJT047XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgdGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3RleHQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSBsaXN0ZW5lciB0byB0cmFjayBzdHlsZSBjaGFuZ2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCBmb250LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fZm9udCA9ICcnO1xuXG4gICAgICAgIF90aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICBfdGhpcy5zdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgIF90aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IGFuZCB1cGRhdGVzIGl0IHdoZW4gbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3BlY3REaXJ0eSAtIFdoZXRoZXIgdG8gYWJvcnQgdXBkYXRpbmcgdGhlIHRleHQgaWYgdGhlIFRleHQgaXNuJ3QgZGlydHkgYW5kIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAgICovXG5cblxuICAgIFRleHQucHJvdG90eXBlLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiB1cGRhdGVUZXh0KHJlc3BlY3REaXJ0eSkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblxuICAgICAgICAvLyBjaGVjayBpZiBzdHlsZSBoYXMgY2hhbmdlZC4uXG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3R5bGVJRCAhPT0gc3R5bGUuc3R5bGVJRCkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IHN0eWxlLnN0eWxlSUQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZGlydHkgJiYgcmVzcGVjdERpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mb250ID0gVGV4dC5nZXRGb250U3R5bGUoc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5mb250ID0gdGhpcy5fZm9udDtcblxuICAgICAgICAvLyB3b3JkIHdyYXBcbiAgICAgICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgdGV4dFxuICAgICAgICB2YXIgb3V0cHV0VGV4dCA9IHN0eWxlLndvcmRXcmFwID8gdGhpcy53b3JkV3JhcCh0aGlzLl90ZXh0KSA6IHRoaXMuX3RleHQ7XG5cbiAgICAgICAgLy8gc3BsaXQgdGV4dCBpbnRvIGxpbmVzXG4gICAgICAgIHZhciBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0ZXh0IHdpZHRoXG4gICAgICAgIHZhciBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgICB2YXIgZm9udFByb3BlcnRpZXMgPSBUZXh0LmNhbGN1bGF0ZUZvbnRQcm9wZXJ0aWVzKHRoaXMuX2ZvbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoICsgKGxpbmVzW2ldLmxlbmd0aCAtIDEpICogc3R5bGUubGV0dGVyU3BhY2luZztcblxuICAgICAgICAgICAgbGluZVdpZHRoc1tpXSA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcblxuICAgICAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgICAgICAgd2lkdGggKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwoKHdpZHRoICsgc3R5bGUucGFkZGluZyAqIDIpICogdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGV4dCBoZWlnaHRcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcykgKyAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICAgICAgICBoZWlnaHQgKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKChoZWlnaHQgKyBzdHlsZS5wYWRkaW5nICogMikgKiB0aGlzLnJlc29sdXRpb24pO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5zY2FsZSh0aGlzLnJlc29sdXRpb24sIHRoaXMucmVzb2x1dGlvbik7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuZm9udCA9IHRoaXMuX2ZvbnQ7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICAgICAgdGhpcy5jb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmxpbmVKb2luID0gc3R5bGUubGluZUpvaW47XG4gICAgICAgIHRoaXMuY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdDtcblxuICAgICAgICB2YXIgbGluZVBvc2l0aW9uWCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxpbmVQb3NpdGlvblkgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5zaGFkb3dCbHVyID0gc3R5bGUuZHJvcFNoYWRvd0JsdXI7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBzdHlsZS5kcm9wU2hhZG93QWxwaGE7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5kcm9wU2hhZG93Qmx1ciA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2hhZG93Q29sb3IgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4U2hhZG93T2Zmc2V0ID0gTWF0aC5jb3Moc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgICAgIHZhciB5U2hhZG93T2Zmc2V0ID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxpbmVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgX2kgKiBsaW5lSGVpZ2h0ICsgZm9udFByb3BlcnRpZXMuYXNjZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tfaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tfaV0pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKGxpbmVzW19pXSwgbGluZVBvc2l0aW9uWCArIHhTaGFkb3dPZmZzZXQgKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgeVNoYWRvd09mZnNldCArIHN0eWxlLnBhZGRpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKGxpbmVzW19pXSwgbGluZVBvc2l0aW9uWCArIHhTaGFkb3dPZmZzZXQgKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgeVNoYWRvd09mZnNldCArIHN0eWxlLnBhZGRpbmcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIHNoYWRvdyBibHVyIGFuZCBhbHBoYSB0aGF0IHdhcyBzZXQgYnkgdGhlIGRyb3Agc2hhZG93LCBmb3IgdGhlIHJlZ3VsYXIgdGV4dFxuICAgICAgICB0aGlzLmNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAgICAgLy8gc2V0IGNhbnZhcyB0ZXh0IHN0eWxlc1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fZ2VuZXJhdGVGaWxsU3R5bGUoc3R5bGUsIGxpbmVzKTtcblxuICAgICAgICAvLyBkcmF3IGxpbmVzIGxpbmUgYnkgbGluZVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsaW5lcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgX2kyICogbGluZUhlaWdodCArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudDtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW19pMl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbX2kyXSkgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlICYmIHN0eWxlLnN0cm9rZVRoaWNrbmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbX2kyXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlLmZpbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKGxpbmVzW19pMl0sIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSB0ZXh0IHdpdGggbGV0dGVyLXNwYWNpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBkcmF3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFZlcnRpY2FsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cm9rZT1mYWxzZV0gLSBJcyB0aGlzIGRyYXdpbmcgZm9yIHRoZSBvdXRzaWRlIHN0cm9rZSBvZiB0aGVcbiAgICAgKiAgdGV4dD8gSWYgbm90LCBpdCdzIGZvciB0aGUgaW5zaWRlIGZpbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5kcmF3TGV0dGVyU3BhY2luZyA9IGZ1bmN0aW9uIGRyYXdMZXR0ZXJTcGFjaW5nKHRleHQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGlzU3Ryb2tlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblxuICAgICAgICAvLyBsZXR0ZXJTcGFjaW5nIG9mIDAgbWVhbnMgbm9ybWFsXG4gICAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcblxuICAgICAgICBpZiAobGV0dGVyU3BhY2luZyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQodGV4dCwgeCwgeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJhY3RlcnMgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LmNhbGwodGV4dCwgJycpO1xuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0geDtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAnJztcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGNoYXJhY3RlcnNbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dChjdXJyZW50LCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoY3VycmVudCwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoY3VycmVudCkud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGV4dHVyZSBzaXplIGJhc2VkIG9uIGNhbnZhcyBzaXplXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gdXBkYXRlVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlLnRyaW0pIHtcbiAgICAgICAgICAgIHZhciB0cmltbWVkID0gKDAsIF90cmltQ2FudmFzMi5kZWZhdWx0KSh0aGlzLmNhbnZhcyk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdHJpbW1lZC53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnB1dEltYWdlRGF0YSh0cmltbWVkLmRhdGEsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlYWxXaWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlYWxIZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHRleHR1cmUudHJpbS53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHRleHR1cmUudHJpbS5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG5cbiAgICAgICAgdGV4dHVyZS50cmltLnggPSAtc3R5bGUucGFkZGluZztcbiAgICAgICAgdGV4dHVyZS50cmltLnkgPSAtc3R5bGUucGFkZGluZztcblxuICAgICAgICB0ZXh0dXJlLm9yaWcud2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aCAtIHN0eWxlLnBhZGRpbmcgKiAyO1xuICAgICAgICB0ZXh0dXJlLm9yaWcuaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0IC0gc3R5bGUucGFkZGluZyAqIDI7XG5cbiAgICAgICAgLy8gY2FsbCBzcHJpdGUgb25UZXh0dXJlVXBkYXRlIHRvIHVwZGF0ZSBzY2FsZSBpZiBfd2lkdGggb3IgX2hlaWdodCB3ZXJlIHNldFxuICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUoKTtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmVtaXQoJ3VwZGF0ZScsIHRleHR1cmUuYmFzZVRleHR1cmUpO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIFRleHQucHJvdG90eXBlLnJlbmRlcldlYkdMID0gZnVuY3Rpb24gcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbiAhPT0gcmVuZGVyZXIucmVzb2x1dGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuXG4gICAgICAgIF9TcHJpdGUucHJvdG90eXBlLnJlbmRlcldlYkdMLmNhbGwodGhpcywgcmVuZGVyZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG5cblxuICAgIFRleHQucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcblxuICAgICAgICBfU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzLmNhbGwodGhpcywgcmVuZGVyZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXG4gICAgICogYm91bmRzIHNldCBieSB0aGUgVGV4dCBvYmplY3QncyB3b3JkV3JhcFdpZHRoIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFN0cmluZyB0byBhcHBseSB3b3JkIHdyYXBwaW5nIHRvXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBOZXcgc3RyaW5nIHdpdGggbmV3IGxpbmVzIGFwcGxpZWQgd2hlcmUgcmVxdWlyZWRcbiAgICAgKi9cblxuXG4gICAgVGV4dC5wcm90b3R5cGUud29yZFdyYXAgPSBmdW5jdGlvbiB3b3JkV3JhcCh0ZXh0KSB7XG4gICAgICAgIC8vIEdyZWVkeSB3cmFwcGluZyBhbGdvcml0aG0gdGhhdCB3aWxsIHdyYXAgd29yZHMgYXMgdGhlIGxpbmUgZ3Jvd3MgbG9uZ2VyXG4gICAgICAgIC8vIHRoYW4gaXRzIGhvcml6b250YWwgYm91bmRzLlxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHdvcmRXcmFwV2lkdGggPSBzdHlsZS53b3JkV3JhcFdpZHRoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzcGFjZUxlZnQgPSB3b3JkV3JhcFdpZHRoO1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gbGluZXNbaV0uc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3b3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciB3b3JkV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQod29yZHNbal0pLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmJyZWFrV29yZHMgJiYgd29yZFdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JkIHNob3VsZCBiZSBzcGxpdCBpbiB0aGUgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gd29yZHNbal0uc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hhcmFjdGVycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcldpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcnNbY10pLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyV2lkdGggPiBzcGFjZUxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbicgKyBjaGFyYWN0ZXJzW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlTGVmdCA9IHdvcmRXcmFwV2lkdGggLSBjaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hhcmFjdGVyc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUxlZnQgLT0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd29yZFdpZHRoV2l0aFNwYWNlID0gd29yZFdpZHRoICsgdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KCcgJykud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDAgfHwgd29yZFdpZHRoV2l0aFNwYWNlID4gc3BhY2VMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHByaW50aW5nIHRoZSBuZXdsaW5lIGlmIGl0J3MgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGxpbmUgdGhhdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGFuIHRoZSB3b3JkIHdyYXAgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd29yZHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUxlZnQgPSB3b3JkV3JhcFdpZHRoIC0gd29yZFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VMZWZ0IC09IHdvcmRXaWR0aFdpdGhTcGFjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICcgKyB3b3Jkc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSB0ZXh0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIG91dHB1dCByZWN0YW5nbGUuXG4gICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGUgYm91bmRzLlxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuXG4gICAgICAgIHJldHVybiBfU3ByaXRlLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIFRleHQgYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cbiAgICAgKi9cblxuXG4gICAgVGV4dC5wcm90b3R5cGUuX2NhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFscmVhZHkgZG9uZSB0aGlzIG9uIFRISVMgZnJhbWUuXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgdXBvbiBhIFRleHRTdHlsZSBjaGFuZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgVGV4dC5wcm90b3R5cGUuX29uU3R5bGVDaGFuZ2UgPSBmdW5jdGlvbiBfb25TdHlsZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgZmlsbCBzdHlsZS4gQ2FuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSBncmFkaWVudCBiYXNlZCBvbiB0aGUgZmlsbCBzdHlsZSBiZWluZyBhbiBhcnJheVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGUgLSBUaGUgc3R5bGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGluZXMgLSBUaGUgbGluZXMgb2YgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfENhbnZhc0dyYWRpZW50fSBUaGUgZmlsbCBzdHlsZVxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5fZ2VuZXJhdGVGaWxsU3R5bGUgPSBmdW5jdGlvbiBfZ2VuZXJhdGVGaWxsU3R5bGUoc3R5bGUsIGxpbmVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS5maWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlLmZpbGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb2Nvb24gb24gY2FudmFzKyBjYW5ub3QgZ2VuZXJhdGUgdGV4dHVyZXMsIHNvIHVzZSB0aGUgZmlyc3QgY29sb3VyIGluc3RlYWRcbiAgICAgICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuZmlsbFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBncmFkaWVudCB3aWxsIGJlIGV2ZW5seSBzcGFjZWQgb3V0IGFjY29yZGluZyB0byBob3cgbGFyZ2UgdGhlIGFycmF5IGlzLlxuICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gd291bGQgY3JlYXRlZCBzdG9wcyBhdCAwLjI1LCAwLjUgYW5kIDAuNzVcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gdm9pZCAwO1xuICAgICAgICB2YXIgdG90YWxJdGVyYXRpb25zID0gdm9pZCAwO1xuICAgICAgICB2YXIgY3VycmVudEl0ZXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHN0b3AgPSB2b2lkIDA7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG5cbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIHN0eWxlIHNldHRpbmdzLCBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSB0aGVtIGxhdGVyXG4gICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbC5zbGljZSgpO1xuICAgICAgICB2YXIgZmlsbEdyYWRpZW50U3RvcHMgPSBzdHlsZS5maWxsR3JhZGllbnRTdG9wcy5zbGljZSgpO1xuXG4gICAgICAgIC8vIHdhbnRpbmcgdG8gZXZlbmx5IGRpc3RyaWJ1dGUgdGhlIGZpbGxzLiBTbyBhbiBhcnJheSBvZiA0IGNvbG91cnMgc2hvdWxkIGdpdmUgZmlsbHMgb2YgMC4yNSwgMC41IGFuZCAwLjc1XG4gICAgICAgIGlmICghZmlsbEdyYWRpZW50U3RvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goaSAvIGxlbmd0aFBsdXMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgdGhlIGJsZWVkaW5nIG9mIHRoZSBsYXN0IGdyYWRpZW50IG9uIHRoZSBsaW5lIGFib3ZlIHRvIHRoZSB0b3AgZ3JhZGllbnQgb2YgdGhlIHRoaXMgbGluZVxuICAgICAgICAvLyBieSBoYXJkIGRlZmluaW5nIHRoZSBmaXJzdCBncmFkaWVudCBjb2xvdXIgYXQgcG9pbnQgMCwgYW5kIGxhc3QgZ3JhZGllbnQgY29sb3VyIGF0IHBvaW50IDFcbiAgICAgICAgZmlsbC51bnNoaWZ0KHN0eWxlLmZpbGxbMF0pO1xuICAgICAgICBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApO1xuXG4gICAgICAgIGZpbGwucHVzaChzdHlsZS5maWxsW3N0eWxlLmZpbGwubGVuZ3RoIC0gMV0pO1xuICAgICAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuXG4gICAgICAgIGlmIChzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBfY29uc3QuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBncmFkaWVudCBhdCB0aGUgdG9wIGNlbnRlciBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBib3R0b20gbWlkZGxlIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHdpZHRoIC8gMiwgMCwgd2lkdGggLyAyLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlcGVhdCB0aGUgZ3JhZGllbnQgc28gdGhhdCBlYWNoIGluZGl2aWR1YWwgbGluZSBvZiB0ZXh0IGhhcyB0aGUgc2FtZSB2ZXJ0aWNhbCBncmFkaWVudCBlZmZlY3RcbiAgICAgICAgICAgIC8vIFsnI0ZGMDAwMCcsICcjMDBGRjAwJywgJyMwMDAwRkYnXSBvdmVyIDIgbGluZXMgd291bGQgY3JlYXRlIHN0b3BzIGF0IDAuMTI1LCAwLjI1LCAwLjM3NSwgMC42MjUsIDAuNzUsIDAuODc1XG4gICAgICAgICAgICB0b3RhbEl0ZXJhdGlvbnMgPSAoZmlsbC5sZW5ndGggKyAxKSAqIGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbGluZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gKz0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxHcmFkaWVudFN0b3BzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbal0gLyBsaW5lcy5sZW5ndGggKyBfaTMgLyBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgZmlsbFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdGFydCB0aGUgZ3JhZGllbnQgYXQgdGhlIGNlbnRlciBsZWZ0IG9mIHRoZSBjYW52YXMsIGFuZCBlbmQgYXQgdGhlIGNlbnRlciByaWdodCBvZiB0aGUgY2FudmFzXG4gICAgICAgICAgICBncmFkaWVudCA9IHRoaXMuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBoZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIC8vIGNhbiBqdXN0IGV2ZW5seSBzcGFjZSBvdXQgdGhlIGdyYWRpZW50cyBpbiB0aGlzIGNhc2UsIGFzIG11bHRpcGxlIGxpbmVzIG1ha2VzIG5vIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIC8vIHRvIGFuIGV2ZW4gbGVmdCB0byByaWdodCBncmFkaWVudFxuICAgICAgICAgICAgdG90YWxJdGVyYXRpb25zID0gZmlsbC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbiA9IDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGZpbGwubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgICAgIGlmIChmaWxsR3JhZGllbnRTdG9wc1tfaTRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tfaTRdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBjdXJyZW50SXRlcmF0aW9uIC8gdG90YWxJdGVyYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgZmlsbFtfaTRdKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dCBvYmplY3QuXG4gICAgICogTm90ZSogVW5saWtlIGEgU3ByaXRlLCBhIFRleHQgb2JqZWN0IHdpbGwgYXV0b21hdGljYWxseSBkZXN0cm95IGl0cyBiYXNlVGV4dHVyZSBhbmQgdGV4dHVyZSBhc1xuICAgICAqIHRoZSBtYWpvcml0eSBvZiB0aGUgdGltZSB0aGUgdGV4dHVyZSB3aWxsIG5vdCBiZSBzaGFyZWQgd2l0aCBhbnkgb3RoZXIgU3ByaXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAgICAgKiAgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqL1xuXG5cbiAgICBUZXh0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgX1Nwcml0ZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCB0aGUgdGhlIGNvbnRleHQgYW5kIGNhbnZhcy4uIGRvbnQgd2FudCB0aGlzIGhhbmdpbmcgYXJvdW5kIGluIG1lbW9yeSFcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBmb250IHN0eWxlIHN0cmluZyB0byB1c2UgZm9yIFRleHQuY2FsY3VsYXRlRm9udFByb3BlcnRpZXMoKS4gVGFrZXMgdGhlIHNhbWUgcGFyYW1ldGVyXG4gICAgICogYXMgVGV4dC5zdHlsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29iamVjdHxUZXh0U3R5bGV9IHN0eWxlIC0gU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3R5bGUgb2YgdGhlIGZvbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZvbnQgc3R5bGUgc3RyaW5nLCBmb3IgcGFzc2luZyB0byBUZXh0LmNhbGN1bGF0ZUZvbnRQcm9wZXJ0aWVzKClcbiAgICAgKi9cbiAgICBUZXh0LmdldEZvbnRTdHlsZSA9IGZ1bmN0aW9uIGdldEZvbnRTdHlsZShzdHlsZSkge1xuICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuXG4gICAgICAgIGlmICghKHN0eWxlIGluc3RhbmNlb2YgX1RleHRTdHlsZTIuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIHN0eWxlID0gbmV3IF9UZXh0U3R5bGUyLmRlZmF1bHQoc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVpbGQgY2FudmFzIGFwaSBmb250IHNldHRpbmcgZnJvbSBpbmRpdmlkdWFsIGNvbXBvbmVudHMuIENvbnZlcnQgYSBudW1lcmljIHN0eWxlLmZvbnRTaXplIHRvIHB4XG4gICAgICAgIHZhciBmb250U2l6ZVN0cmluZyA9IHR5cGVvZiBzdHlsZS5mb250U2l6ZSA9PT0gJ251bWJlcicgPyBzdHlsZS5mb250U2l6ZSArICdweCcgOiBzdHlsZS5mb250U2l6ZTtcblxuICAgICAgICAvLyBDbGVhbi11cCBmb250RmFtaWx5IHByb3BlcnR5IGJ5IHF1b3RpbmcgZWFjaCBmb250IG5hbWVcbiAgICAgICAgLy8gdGhpcyB3aWxsIHN1cHBvcnQgZm9udCBuYW1lcyB3aXRoIHNwYWNlc1xuICAgICAgICB2YXIgZm9udEZhbWlsaWVzID0gc3R5bGUuZm9udEZhbWlseTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUuZm9udEZhbWlseSkpIHtcbiAgICAgICAgICAgIGZvbnRGYW1pbGllcyA9IHN0eWxlLmZvbnRGYW1pbHkuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBmb250RmFtaWxpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIC8vIFRyaW0gYW55IGV4dHJhIHdoaXRlLXNwYWNlXG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IGZvbnRGYW1pbGllc1tpXS50cmltKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbnQgYWxyZWFkeSBjb250YWlucyBzdHJpbmdzXG4gICAgICAgICAgICBpZiAoIS8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLy50ZXN0KGZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9ICdcIicgKyBmb250RmFtaWx5ICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGUuZm9udFN0eWxlICsgJyAnICsgc3R5bGUuZm9udFZhcmlhbnQgKyAnICcgKyBzdHlsZS5mb250V2VpZ2h0ICsgJyAnICsgZm9udFNpemVTdHJpbmcgKyAnICcgKyBmb250RmFtaWxpZXMuam9pbignLCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udFN0eWxlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTdHlsZSAtIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0eWxlIG9mIHRoZSBmb250XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBGb250IHByb3BlcnRpZXMgb2JqZWN0XG4gICAgICovXG5cblxuICAgIFRleHQuY2FsY3VsYXRlRm9udFByb3BlcnRpZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVGb250UHJvcGVydGllcyhmb250U3R5bGUpIHtcbiAgICAgICAgLy8gYXMgdGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcHJlcGFyaW5nIGFzc2V0cywgZG9uJ3QgcmVjYWxjdWxhdGUgdGhpbmdzIGlmIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgaWYgKFRleHQuZm9udFByb3BlcnRpZXNDYWNoZVtmb250U3R5bGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gVGV4dC5mb250UHJvcGVydGllc0NhY2hlW2ZvbnRTdHlsZV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FudmFzO1xuICAgICAgICB2YXIgY29udGV4dCA9IFRleHQuZm9udFByb3BlcnRpZXNDb250ZXh0O1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHlsZTtcblxuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dCgnfE3DiXEnKS53aWR0aCk7XG4gICAgICAgIHZhciBiYXNlbGluZSA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KCdNJykud2lkdGgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMiAqIGJhc2VsaW5lO1xuXG4gICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgKiAxLjQgfCAwO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmMDAnO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHlsZTtcblxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoJ3xNw4lxJywgMCwgYmFzZWxpbmUpO1xuXG4gICAgICAgIHZhciBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmUgPSB3aWR0aCAqIDQ7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIHN0b3AgPSBmYWxzZTtcblxuICAgICAgICAvLyBhc2NlbnQuIHNjYW4gZnJvbSB0b3AgdG8gYm90dG9tIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmU7IGogKz0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgICAgICAgICAgaWR4ICs9IGxpbmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5hc2NlbnQgPSBiYXNlbGluZSAtIGk7XG5cbiAgICAgICAgaWR4ID0gcGl4ZWxzIC0gbGluZTtcbiAgICAgICAgc3RvcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRlc2NlbnQuIHNjYW4gZnJvbSBib3R0b20gdG8gdG9wIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXG4gICAgICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyAtLWkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBsaW5lOyBfaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBfal0gIT09IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICAgICAgICBpZHggLT0gbGluZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzLmRlc2NlbnQgPSBpIC0gYmFzZWxpbmU7XG4gICAgICAgIHByb3BlcnRpZXMuZm9udFNpemUgPSBwcm9wZXJ0aWVzLmFzY2VudCArIHByb3BlcnRpZXMuZGVzY2VudDtcblxuICAgICAgICBUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FjaGVbZm9udFN0eWxlXSA9IHByb3BlcnRpZXM7XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhUZXh0LCBbe1xuICAgICAgICBrZXk6ICd3aWR0aCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBzID0gKDAsIF91dGlscy5zaWduKSh0aGlzLnNjYWxlLngpIHx8IDE7XG5cbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dCwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGVpZ2h0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBzID0gKDAsIF91dGlscy5zaWduKSh0aGlzLnNjYWxlLnkpIHx8IDE7XG5cbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHN0eWxlIG9mIHRoZSB0ZXh0LiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoZSBzdHlsZVxuICAgICAgICAgKiBvYmplY3QgYW5kIG1hcmsgdGhlIHRleHQgYXMgZGlydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdHxQSVhJLlRleHRTdHlsZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0eWxlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHN0eWxlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgX1RleHRTdHlsZTIuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gbmV3IF9UZXh0U3R5bGUyLmRlZmF1bHQoc3R5bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjb3B5IGZvciB0aGUgdGV4dCBvYmplY3QuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGV4dCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRleHQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQgPT09ICcnIHx8IHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkID8gJyAnIDogdGV4dCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUZXh0O1xufShfU3ByaXRlMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGV4dDtcblxuXG5UZXh0LmZvbnRQcm9wZXJ0aWVzQ2FjaGUgPSB7fTtcblRleHQuZm9udFByb3BlcnRpZXNDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblRleHQuZm9udFByb3BlcnRpZXNDb250ZXh0ID0gVGV4dC5mb250UHJvcGVydGllc0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS90ZXh0L1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfID0gcmVxdWlyZSgnLi4vJyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIG1haW50YWluaW5nIHJlZmVyZW5jZSB0byBhIGNvbGxlY3Rpb25cbiAqIG9mIFRleHR1cmVzIG9uIGEgc2luZ2xlIFNwcml0ZXNoZWV0LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIFNwcml0ZXNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICAgIF9jcmVhdGVDbGFzcyhTcHJpdGVzaGVldCwgbnVsbCwgW3tcbiAgICAgICAga2V5OiAnQkFUQ0hfU0laRScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBUZXh0dXJlcyB0byBidWlsZCBwZXIgcHJvY2Vzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTAwMFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIFJlZmVyZW5jZSB0byB0aGUgc291cmNlIEJhc2VUZXh0dXJlIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBTcHJpdGVzaGVldCBpbWFnZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Jlc29sdXRpb25GaWxlbmFtZV0gLSBUaGUgZmlsZW5hbWUgdG8gY29uc2lkZXIgd2hlbiBkZXRlcm1pbmluZ1xuICAgICAgICAgKiAgICAgICAgdGhlIHJlc29sdXRpb24gb2YgdGhlIHNwcml0ZXNoZWV0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBpbWFnZVVybCB3aWxsXG4gICAgICAgICAqICAgICAgICBiZSB1c2VkIG9uIHRoZSBCYXNlVGV4dHVyZS5cbiAgICAgICAgICovXG5cbiAgICB9XSk7XG5cbiAgICBmdW5jdGlvbiBTcHJpdGVzaGVldChiYXNlVGV4dHVyZSwgZGF0YSkge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbkZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcHJpdGVzaGVldCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aHMgc291cmNlIHRleHR1cmVcbiAgICAgICAgICogQHR5cGUge1BJWEkuQmFzZVRleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBvZiBzcHJpdGVzaGVldCB0ZXh0dXJlcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBKU09OIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgc3ByaXRlc2hlZXQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSB8fCB0aGlzLmJhc2VUZXh0dXJlLmltYWdlVXJsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIHNwcml0ZXNoZWV0IGZyYW1lcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZyYW1lcyA9IHRoaXMuZGF0YS5mcmFtZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgZnJhbWUgbmFtZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZyYW1lcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgYmF0Y2ggaW5kZXggYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHdoZW4gcGFyc2UgaXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIHJlc29sdXRpb24gZnJvbSB0aGUgZmlsZW5hbWUgb3IgZmFsbGJhY2tcbiAgICAgKiB0byB0aGUgbWV0YS5zY2FsZSBmaWVsZCBvZiB0aGUgSlNPTiBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb2x1dGlvbkZpbGVuYW1lIC0gVGhlIGZpbGVuYW1lIHRvIHVzZSBmb3IgcmVzb2x2aW5nXG4gICAgICogICAgICAgIHRoZSBkZWZhdWx0IHJlc29sdXRpb24uXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uIHRvIHVzZSBmb3Igc3ByaXRlc2hlZXQuXG4gICAgICovXG5cblxuICAgIFNwcml0ZXNoZWV0LnByb3RvdHlwZS5fdXBkYXRlUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIF91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmRhdGEubWV0YS5zY2FsZTtcblxuICAgICAgICAvLyBVc2UgYSBkZWZhdWx0VmFsdWUgb2YgYG51bGxgIHRvIGNoZWNrIGlmIGEgdXJsLWJhc2VkIHJlc29sdXRpb24gaXMgc2V0XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gKDAsIF91dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwpKHJlc29sdXRpb25GaWxlbmFtZSwgbnVsbCk7XG5cbiAgICAgICAgLy8gTm8gcmVzb2x1dGlvbiBmb3VuZCB2aWEgVVJMXG4gICAgICAgIGlmIChyZXNvbHV0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHNjYWxlIHZhbHVlIG9yIGRlZmF1bHQgdG8gMVxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBwYXJzZUZsb2F0KHNjYWxlKSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3Igbm9uLTEgcmVzb2x1dGlvbnMsIHVwZGF0ZSBiYXNlVGV4dHVyZVxuICAgICAgICBpZiAocmVzb2x1dGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUudXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VyIHNwcml0ZXNoZWV0IGZyb20gbG9hZGVkIGRhdGEuIFRoaXMgaXMgZG9uZSBhc3luY2hyb25vdXNseVxuICAgICAqIHRvIHByZXZlbnQgY3JlYXRpbmcgdG9vIG1hbnkgVGV4dHVyZSB3aXRoaW4gYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgd2hlbiBjb21wbGV0ZSByZXR1cm5zXG4gICAgICogICAgICAgIGEgbWFwIG9mIHRoZSBUZXh0dXJlcyBmb3IgdGhpcyBzcHJpdGVzaGVldC5cbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGggPD0gU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcygwKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQ29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRCYXRjaCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSBiYXRjaCBvZiBmcmFtZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluaXRpYWxGcmFtZUluZGV4IC0gVGhlIGluZGV4IG9mIGZyYW1lIHRvIHN0YXJ0LlxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVzaGVldC5wcm90b3R5cGUuX3Byb2Nlc3NGcmFtZXMgPSBmdW5jdGlvbiBfcHJvY2Vzc0ZyYW1lcyhpbml0aWFsRnJhbWVJbmRleCkge1xuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IGluaXRpYWxGcmFtZUluZGV4O1xuICAgICAgICB2YXIgbWF4RnJhbWVzID0gU3ByaXRlc2hlZXQuQkFUQ0hfU0laRTtcblxuICAgICAgICB3aGlsZSAoZnJhbWVJbmRleCAtIGluaXRpYWxGcmFtZUluZGV4IDwgbWF4RnJhbWVzICYmIGZyYW1lSW5kZXggPCB0aGlzLl9mcmFtZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX2ZyYW1lS2V5c1tmcmFtZUluZGV4XTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fZnJhbWVzW2ldLmZyYW1lO1xuXG4gICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHRyaW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnID0gbmV3IF8uUmVjdGFuZ2xlKDAsIDAsIHRoaXMuX2ZyYW1lc1tpXS5zb3VyY2VTaXplLncgLyB0aGlzLnJlc29sdXRpb24sIHRoaXMuX2ZyYW1lc1tpXS5zb3VyY2VTaXplLmggLyB0aGlzLnJlc29sdXRpb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZyYW1lc1tpXS5yb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gbmV3IF8uUmVjdGFuZ2xlKHJlY3QueCAvIHRoaXMucmVzb2x1dGlvbiwgcmVjdC55IC8gdGhpcy5yZXNvbHV0aW9uLCByZWN0LmggLyB0aGlzLnJlc29sdXRpb24sIHJlY3QudyAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgXy5SZWN0YW5nbGUocmVjdC54IC8gdGhpcy5yZXNvbHV0aW9uLCByZWN0LnkgLyB0aGlzLnJlc29sdXRpb24sIHJlY3QudyAvIHRoaXMucmVzb2x1dGlvbiwgcmVjdC5oIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAgQ2hlY2sgdG8gc2VlIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mcmFtZXNbaV0udHJpbW1lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmltID0gbmV3IF8uUmVjdGFuZ2xlKHRoaXMuX2ZyYW1lc1tpXS5zcHJpdGVTb3VyY2VTaXplLnggLyB0aGlzLnJlc29sdXRpb24sIHRoaXMuX2ZyYW1lc1tpXS5zcHJpdGVTb3VyY2VTaXplLnkgLyB0aGlzLnJlc29sdXRpb24sIHJlY3QudyAvIHRoaXMucmVzb2x1dGlvbiwgcmVjdC5oIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVzW2ldID0gbmV3IF8uVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCBmcmFtZSwgb3JpZywgdHJpbSwgdGhpcy5fZnJhbWVzW2ldLnJvdGF0ZWQgPyAyIDogMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBsZXRzIGFsc28gYWRkIHRoZSBmcmFtZSB0byBwaXhpJ3MgZ2xvYmFsIGNhY2hlIGZvciBmcm9tRnJhbWUgYW5kIGZyb21JbWFnZSBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBfdXRpbHMuVGV4dHVyZUNhY2hlW2ldID0gdGhpcy50ZXh0dXJlc1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJzZSBoYXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLl9wYXJzZUNvbXBsZXRlID0gZnVuY3Rpb24gX3BhcnNlQ29tcGxldGUoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy50ZXh0dXJlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJlZ2luIHRoZSBuZXh0IGJhdGNoIG9mIHRleHR1cmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgU3ByaXRlc2hlZXQucHJvdG90eXBlLl9uZXh0QmF0Y2ggPSBmdW5jdGlvbiBfbmV4dEJhdGNoKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIFNwcml0ZXNoZWV0LkJBVENIX1NJWkUpO1xuICAgICAgICB0aGlzLl9iYXRjaEluZGV4Kys7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9iYXRjaEluZGV4ICogU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSA8IF90aGlzLl9mcmFtZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25leHRCYXRjaCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFyc2VDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSBTcHJpdGVzaGVldCBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95QmFzZT1mYWxzZV0gV2hldGhlciB0byBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgYXMgd2VsbFxuICAgICAqL1xuXG5cbiAgICBTcHJpdGVzaGVldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBkZXN0cm95QmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcmFtZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9mcmFtZUtleXMgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgaWYgKGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNwcml0ZXNoZWV0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTcHJpdGVzaGVldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZXNoZWV0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3RleHR1cmVzL1Nwcml0ZXNoZWV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vc2V0dGluZ3MnKTtcblxudmFyIF9zZXR0aW5nczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXR0aW5ncyk7XG5cbnZhciBfZXZlbnRlbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xuXG52YXIgX2V2ZW50ZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudGVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBJbnRlcm5hbCBldmVudCB1c2VkIGJ5IGNvbXBvc2VkIGVtaXR0ZXJcbnZhciBUSUNLID0gJ3RpY2snO1xuXG4vKipcbiAqIEEgVGlja2VyIGNsYXNzIHRoYXQgcnVucyBhbiB1cGRhdGUgbG9vcCB0aGF0IG90aGVyIG9iamVjdHMgbGlzdGVuIHRvLlxuICogVGhpcyBjbGFzcyBpcyBjb21wb3NlZCBhcm91bmQgYW4gRXZlbnRFbWl0dGVyIG9iamVjdCB0byBhZGQgbGlzdGVuZXJzXG4gKiBtZWFudCBmb3IgZXhlY3V0aW9uIG9uIHRoZSBuZXh0IHJlcXVlc3RlZCBhbmltYXRpb24gZnJhbWUuXG4gKiBBbmltYXRpb24gZnJhbWVzIGFyZSByZXF1ZXN0ZWQgb25seSB3aGVuIG5lY2Vzc2FyeSxcbiAqIGUuZy4gV2hlbiB0aGUgdGlja2VyIGlzIHN0YXJ0ZWQgYW5kIHRoZSBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS50aWNrZXJcbiAqL1xuXG52YXIgVGlja2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGlja2VyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaWNrZXIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBlbWl0dGVyIHVzZWQgdG8gZmlyZSAndGljaycgZXZlbnRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgX2V2ZW50ZW1pdHRlcjIuZGVmYXVsdCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBjdXJyZW50IGZyYW1lIHJlcXVlc3QgSURcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHZhbHVlIG1hbmFnZWQgYnkgbWluRlBTIHByb3BlcnR5IHNldHRlciBhbmQgZ2V0dGVyLlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQgbWlsbGlzZWNvbmRzIGJldHdlZW4gdXBkYXRlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEwMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXG4gICAgICAgICAqIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjc3RhcnR9IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICogd2hlbiBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvU3RhcnQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGFyIHRpbWUgdmFsdWUgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNtaW5GUFN9XG4gICAgICAgICAqIGFuZCBpcyBzY2FsZWQgd2l0aCB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3NwZWVkfS5cbiAgICAgICAgICogKipOb3RlOioqIFRoZSBjYXAgbWF5IGJlIGV4Y2VlZGVkIGJ5IHNjYWxpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGVsYXBzZWQgaW4gbWlsbGlzZWNvbmRzIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxuICAgICAgICAgKiBPcHBvc2VkIHRvIHdoYXQgdGhlIHNjYWxhciB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX1cbiAgICAgICAgICogaXMgYmFzZWQsIHRoaXMgdmFsdWUgaXMgbmVpdGhlciBjYXBwZWQgbm9yIHNjYWxlZC5cbiAgICAgICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXG4gICAgICAgICAqIHRoaXMgdmFsdWUgd2lsbCBoYXZlIGEgcHJlY2lzaW9uIG9mIDEgwrVzLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0YXJnZXQgZnJhbWUgdGltZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDE2LjY2XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsYXBzZWRNUyA9IDEgLyBfc2V0dGluZ3MyLmRlZmF1bHQuVEFSR0VUX0ZQTVM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHRpbWUge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciN1cGRhdGV9IHdhcyBpbnZva2VkLlxuICAgICAgICAgKiBUaGlzIHZhbHVlIGlzIGFsc28gcmVzZXQgaW50ZXJuYWxseSBvdXRzaWRlIG9mIGludm9raW5nXG4gICAgICAgICAqIHVwZGF0ZSwgYnV0IG9ubHkgd2hlbiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkLlxuICAgICAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcbiAgICAgICAgICogdGhpcyB2YWx1ZSB3aWxsIGhhdmUgYSBwcmVjaXNpb24gb2YgMSDCtXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZhY3RvciBvZiBjdXJyZW50IHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjZGVsdGFUaW1lfS5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU2NhbGVzIHRpY2tlci5kZWx0YVRpbWUgdG8gd2hhdCB3b3VsZCBiZVxuICAgICAgICAgKiAvLyB0aGUgZXF1aXZhbGVudCBvZiBhcHByb3hpbWF0ZWx5IDEyMCBGUFNcbiAgICAgICAgICogdGlja2VyLnNwZWVkID0gMjtcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwZWVkID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZC5cbiAgICAgICAgICogYHRydWVgIGlmIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjc3RhcnR9IGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICogYGZhbHNlYCBpZiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3N0b3B9IGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICogV2hpbGUgYGZhbHNlYCwgdGhpcyB2YWx1ZSBtYXkgY2hhbmdlIHRvIGB0cnVlYCBpbiB0aGVcbiAgICAgICAgICogZXZlbnQgb2Yge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNhdXRvU3RhcnR9IGJlaW5nIGB0cnVlYFxuICAgICAgICAgKiBhbmQgYSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCB0aWNrIG1ldGhvZCBib3VuZCB0byB0aWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIFRoaXMgaXMgYmVjYXVzZSBpbiBlYXJseSAyMDE1LCBGdW5jdGlvbi5iaW5kXG4gICAgICAgICAqIGlzIHN0aWxsIDYwJSBzbG93ZXIgaW4gaGlnaCBwZXJmb3JtYW5jZSBzY2VuYXJpb3MuXG4gICAgICAgICAqIEFsc28gc2VwYXJhdGluZyBmcmFtZSByZXF1ZXN0cyBmcm9tIHVwZGF0ZSBtZXRob2RcbiAgICAgICAgICogc28gbGlzdGVuZXJzIG1heSBiZSBjYWxsZWQgYXQgYW55IHRpbWUgYW5kIHdpdGhcbiAgICAgICAgICogYW55IGFuaW1hdGlvbiBBUEksIGp1c3QgaW52b2tlIHRpY2tlci51cGRhdGUodGltZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIC0gVGltZSBzaW5jZSBsYXN0IHRpY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSBsaXN0ZW5lcnMgbm93XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKHRpbWUpO1xuICAgICAgICAgICAgICAgIC8vIExpc3RlbmVyIHNpZGUgZWZmZWN0cyBtYXkgaGF2ZSBtb2RpZmllZCB0aWNrZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0ZWQgJiYgX3RoaXMuX3JlcXVlc3RJZCA9PT0gbnVsbCAmJiBfdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoVElDSywgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy5fdGljayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFsbHkgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIElmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsXG4gICAgICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLl9yZXF1ZXN0SWZOZWVkZWQgPSBmdW5jdGlvbiBfcmVxdWVzdElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKFRJQ0ssIHRydWUpKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgY2FsbGJhY2tzIGdldCBjb3JyZWN0IGRlbHRhXG4gICAgICAgICAgICB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSBjYW5jZWxzIGEgcGVuZGluZyBhbmltYXRpb24gZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLl9jYW5jZWxJZk5lZWRlZCA9IGZ1bmN0aW9uIF9jYW5jZWxJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gICAgICogSWYgdGhlIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkIGl0IGNoZWNrcyBpZiBhIGZyYW1lIGhhcyBub3QgYWxyZWFkeVxuICAgICAqIGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsIGVtaXR0ZXIgaGFzIGxpc3RlbmVycy4gSWYgdGhlc2VcbiAgICAgKiBjb25kaXRpb25zIGFyZSBtZXQsIGEgbmV3IGZyYW1lIGlzIHJlcXVlc3RlZC4gSWYgdGhlIHRpY2tlciBoYXMgbm90XG4gICAgICogYmVlbiBzdGFydGVkLCBidXQgYXV0b1N0YXJ0IGlzIGB0cnVlYCwgdGhlbiB0aGUgdGlja2VyIHN0YXJ0cyBub3csXG4gICAgICogYW5kIGNvbnRpbnVlcyB3aXRoIHRoZSBwcmV2aW91cyBjb25kaXRpb25zIHRvIHJlcXVlc3QgYSBuZXcgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLl9zdGFydElmUG9zc2libGUgPSBmdW5jdGlvbiBfc3RhcnRJZlBvc3NpYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9TdGFydCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxzIHtAbGluayBtb2R1bGU6ZXZlbnRlbWl0dGVyMy5FdmVudEVtaXR0ZXIjb259IGludGVybmFsbHkgZm9yIHRoZVxuICAgICAqIGludGVybmFsICd0aWNrJyBldmVudC4gSXQgY2hlY2tzIGlmIHRoZSBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMsXG4gICAgICogYW5kIGlmIHNvIGl0IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBhdCB0aGlzIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIHVwZGF0ZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29udGV4dF0gLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgICAqIEByZXR1cm5zIHtQSVhJLnRpY2tlci5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICAgKi9cblxuXG4gICAgVGlja2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZW1pdHRlci5vbihUSUNLLCBmbiwgY29udGV4dCk7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRJZlBvc3NpYmxlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxzIHtAbGluayBtb2R1bGU6ZXZlbnRlbWl0dGVyMy5FdmVudEVtaXR0ZXIjb25jZX0gaW50ZXJuYWxseSBmb3IgdGhlXG4gICAgICogaW50ZXJuYWwgJ3RpY2snIGV2ZW50LiBJdCBjaGVja3MgaWYgdGhlIGVtaXR0ZXIgaGFzIGxpc3RlbmVycyxcbiAgICAgKiBhbmQgaWYgc28gaXQgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGF0IHRoaXMgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3Igb25lIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAgICogQHJldHVybnMge1BJWEkudGlja2VyLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLmFkZE9uY2UgPSBmdW5jdGlvbiBhZGRPbmNlKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2VtaXR0ZXIub25jZShUSUNLLCBmbiwgY29udGV4dCk7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRJZlBvc3NpYmxlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxzIHtAbGluayBtb2R1bGU6ZXZlbnRlbWl0dGVyMy5FdmVudEVtaXR0ZXIjb2ZmfSBpbnRlcm5hbGx5IGZvciAndGljaycgZXZlbnQuXG4gICAgICogSXQgY2hlY2tzIGlmIHRoZSBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMgZm9yICd0aWNrJyBldmVudC5cbiAgICAgKiBJZiBpdCBkb2VzLCB0aGVuIGl0IGNhbmNlbHMgdGhlIGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcmV0dXJucyB7UElYSS50aWNrZXIuVGlja2VyfSBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAgICovXG5cblxuICAgIFRpY2tlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2VtaXR0ZXIub2ZmKFRJQ0ssIGZuLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAoIXRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKFRJQ0ssIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnNcbiAgICAgKiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICovXG5cblxuICAgIFRpY2tlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyByZXF1ZXN0ZWRcbiAgICAgKiBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgKi9cblxuXG4gICAgVGlja2VyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcbiAgICAgKiBjdXJyZW50IHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjZWxhcHNlZE1TfSxcbiAgICAgKiB0aGUgY3VycmVudCB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX0sXG4gICAgICogaW52b2tpbmcgYWxsIGxpc3RlbmVycyB3aXRoIGN1cnJlbnQgZGVsdGFUaW1lLFxuICAgICAqIGFuZCB0aGVuIGZpbmFsbHkgc2V0dGluZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2xhc3RUaW1lfVxuICAgICAqIHdpdGggdGhlIHZhbHVlIG9mIGN1cnJlbnRUaW1lIHRoYXQgd2FzIHByb3ZpZGVkLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gICAgICogZnJhbWUgY2FsbGJhY2tzIGlmIHRoZSB0aWNrZXIgaW5zdGFuY2UgaGFzIGJlZW4gc3RhcnRlZFxuICAgICAqIGFuZCBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50VGltZT1wZXJmb3JtYW5jZS5ub3coKV0gLSB0aGUgY3VycmVudCB0aW1lIG9mIGV4ZWN1dGlvblxuICAgICAqL1xuXG5cbiAgICBUaWNrZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICB2YXIgZWxhcHNlZE1TID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIElmIHRoZSBkaWZmZXJlbmNlIGluIHRpbWUgaXMgemVybyBvciBuZWdhdGl2ZSwgd2UgaWdub3JlIG1vc3Qgb2YgdGhlIHdvcmsgZG9uZSBoZXJlLlxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyB2YWxpZCBkaWZmZXJlbmNlLCB0aGVuIHNob3VsZCBiZSBubyByZWFzb24gdG8gbGV0IGFueW9uZSBrbm93IGFib3V0IGl0LlxuICAgICAgICAvLyBBIHplcm8gZGVsdGEsIGlzIGV4YWN0bHkgdGhhdCwgbm90aGluZyBzaG91bGQgdXBkYXRlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGlmZmVyZW5jZSBpbiB0aW1lIGNhbiBiZSBuZWdhdGl2ZSwgYW5kIG5vIHRoaXMgZG9lcyBub3QgbWVhbiB0aW1lIHRyYXZlbGluZy5cbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBvZiBhIHJhY2UgY29uZGl0aW9uIGJldHdlZW4gd2hlbiBhbiBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkXG4gICAgICAgIC8vIG9uIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgZW5naW5lIGV2ZW50IGxvb3AsIGFuZCB3aGVuIHRoZSB0aWNrZXIncyBzdGFydCBtZXRob2QgaXMgaW52b2tlZFxuICAgICAgICAvLyAod2hpY2ggaW52b2tlcyB0aGUgaW50ZXJuYWwgX3JlcXVlc3RJZk5lZWRlZCBtZXRob2QpLiBJZiBhIGZyYW1lIGlzIHJlcXVlc3RlZCBiZWZvcmVcbiAgICAgICAgLy8gX3JlcXVlc3RJZk5lZWRlZCBpcyBpbnZva2VkLCB0aGVuIHRoZSBjYWxsYmFjayBmb3IgdGhlIGFuaW1hdGlvbiBmcmFtZSB0aGUgdGlja2VyIHJlcXVlc3RzLFxuICAgICAgICAvLyBjYW4gcmVjZWl2ZSBhIHRpbWUgYXJndW1lbnQgdGhhdCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsYXN0VGltZSB2YWx1ZSB0aGF0IHdhcyBzZXQgd2l0aGluXG4gICAgICAgIC8vIF9yZXF1ZXN0SWZOZWVkZWQuIFRoaXMgZGlmZmVyZW5jZSBpcyBpbiBtaWNyb3NlY29uZHMsIGJ1dCB0aGlzIGlzIGVub3VnaCB0byBjYXVzZSBwcm9ibGVtcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBjaGVjayBjb3ZlcnMgdGhpcyBicm93c2VyIGVuZ2luZSB0aW1pbmcgaXNzdWUsIGFzIHdlbGwgYXMgaWYgY29uc3VtZXJzIHBhc3MgYW4gaW52YWxpZFxuICAgICAgICAvLyBjdXJyZW50VGltZSB2YWx1ZS4gVGhpcyBtYXkgaGFwcGVuIGlmIGNvbnN1bWVycyBvcHQtb3V0IG9mIHRoZSBhdXRvU3RhcnQsIGFuZCB1cGRhdGUgdGhlbXNlbHZlcy5cblxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHVuY2FwcGVkIGVsYXBzZWRNUyBmb3IgbWVhc3VyZW1lbnRcbiAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuZWxhcHNlZE1TID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuXG4gICAgICAgICAgICAvLyBjYXAgdGhlIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHVzZWQgZm9yIGRlbHRhVGltZVxuICAgICAgICAgICAgaWYgKGVsYXBzZWRNUyA+IHRoaXMuX21heEVsYXBzZWRNUykge1xuICAgICAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSBlbGFwc2VkTVMgKiBfc2V0dGluZ3MyLmRlZmF1bHQuVEFSR0VUX0ZQTVMgKiB0aGlzLnNwZWVkO1xuXG4gICAgICAgICAgICAvLyBJbnZva2UgbGlzdGVuZXJzIGFkZGVkIHRvIGludGVybmFsIGVtaXR0ZXJcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChUSUNLLCB0aGlzLmRlbHRhVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhVGltZSA9IHRoaXMuZWxhcHNlZE1TID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lcyBwZXIgc2Vjb25kIGF0IHdoaWNoIHRoaXMgdGlja2VyIGlzIHJ1bm5pbmcuXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYXBwcm94aW1hdGVseSA2MCBpbiBtb3N0IG1vZGVybiBicm93c2Vycy5cbiAgICAgKiAqKk5vdGU6KiogVGhpcyBkb2VzIG5vdCBmYWN0b3IgaW4gdGhlIHZhbHVlIG9mXG4gICAgICoge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNzcGVlZH0sIHdoaWNoIGlzIHNwZWNpZmljXG4gICAgICogdG8gc2NhbGluZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhUaWNrZXIsIFt7XG4gICAgICAgIGtleTogJ0ZQUycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLmVsYXBzZWRNUztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xuICAgICAgICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3VwZGF0ZX0uXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgdXNlZCB0byBjYXAge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgICAgICAgKiBidXQgZG9lcyBub3QgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI0ZQU30uXG4gICAgICAgICAqIFdoZW4gc2V0dGluZyB0aGlzIHByb3BlcnR5IGl0IGlzIGNsYW1wZWQgdG8gYSB2YWx1ZSBiZXR3ZWVuXG4gICAgICAgICAqIGAwYCBhbmQgYFBJWEkuc2V0dGluZ3MuVEFSR0VUX0ZQTVMgKiAxMDAwYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWluRlBTJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZnBzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQ2xhbXA6IDAgdG8gVEFSR0VUX0ZQTVNcbiAgICAgICAgICAgIHZhciBtaW5GUE1TID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZnBzKSAvIDEwMDAsIF9zZXR0aW5nczIuZGVmYXVsdC5UQVJHRVRfRlBNUyk7XG5cbiAgICAgICAgICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEgLyBtaW5GUE1TO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpY2tlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3RpY2tlci9UaWNrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNhblVwbG9hZFNhbWVCdWZmZXI7XG5mdW5jdGlvbiBjYW5VcGxvYWRTYW1lQnVmZmVyKCkge1xuXHQvLyBVcGxvYWRpbmcgdGhlIHNhbWUgYnVmZmVyIG11bHRpcGxlIHRpbWVzIGluIGEgc2luZ2xlIGZyYW1lIGNhbiBjYXVzZSBwZXJmIGlzc3Vlcy5cblx0Ly8gQXBwYXJlbnQgb24gSU9TIHNvIG9ubHkgY2hlY2sgZm9yIHRoYXQgYXQgdGhlIG1vbWVudFxuXHQvLyB0aGlzIGNoZWNrIG1heSBiZWNvbWUgbW9yZSBjb21wbGV4IGlmIHRoaXMgaXNzdWUgcG9wcyB1cCBlbHNld2hlcmUuXG5cdHZhciBpb3MgPSAhIW5hdmlnYXRvci5wbGF0Zm9ybSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG5cdHJldHVybiAhaW9zO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuVXBsb2FkU2FtZUJ1ZmZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS91dGlscy9jYW5VcGxvYWRTYW1lQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW47XG5cbnZhciBfdXJsMiA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgX3VybDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91cmwyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHRlbXBBbmNob3IgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0cyB0aGUgYGNyb3NzT3JpZ2luYCBwcm9wZXJ0eSBmb3IgdGhpcyByZXNvdXJjZSBiYXNlZCBvbiBpZiB0aGUgdXJsXG4gKiBmb3IgdGhpcyByZXNvdXJjZSBpcyBjcm9zcy1vcmlnaW4uIElmIGNyb3NzT3JpZ2luIHdhcyBtYW51YWxseSBzZXQsIHRoaXNcbiAqIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cbiAqIE5pcHBlZCBmcm9tIHRoZSByZXNvdXJjZSBsb2FkZXIhXG4gKlxuICogQGlnbm9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB1cmwgdG8gdGVzdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbbG9jPXdpbmRvdy5sb2NhdGlvbl0gLSBUaGUgbG9jYXRpb24gb2JqZWN0IHRvIHRlc3QgYWdhaW5zdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNyb3NzT3JpZ2luIHZhbHVlIHRvIHVzZSAob3IgZW1wdHkgc3RyaW5nIGZvciBub25lKS5cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsKSB7XG4gICAgdmFyIGxvYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogd2luZG93LmxvY2F0aW9uO1xuXG4gICAgLy8gZGF0YTogYW5kIGphdmFzY3JpcHQ6IHVybHMgYXJlIGNvbnNpZGVyZWQgc2FtZS1vcmlnaW5cbiAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgaXMgd2luZG93LmxvY2F0aW9uXG4gICAgbG9jID0gbG9jIHx8IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgIGlmICghdGVtcEFuY2hvcikge1xuICAgICAgICB0ZW1wQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIH1cblxuICAgIC8vIGxldCB0aGUgYnJvd3NlciBkZXRlcm1pbmUgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIHVybCBvZiB0aGlzIHJlc291cmNlIGFuZCB0aGVuXG4gICAgLy8gcGFyc2Ugd2l0aCB0aGUgbm9kZSB1cmwgbGliLCB3ZSBjYW4ndCB1c2UgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGFuY2hvciBlbGVtZW50XG4gICAgLy8gYmVjYXVzZSB0aGV5IGRvbid0IHdvcmsgaW4gSUU5IDooXG4gICAgdGVtcEFuY2hvci5ocmVmID0gdXJsO1xuICAgIHVybCA9IF91cmwzLmRlZmF1bHQucGFyc2UodGVtcEFuY2hvci5ocmVmKTtcblxuICAgIHZhciBzYW1lUG9ydCA9ICF1cmwucG9ydCAmJiBsb2MucG9ydCA9PT0gJycgfHwgdXJsLnBvcnQgPT09IGxvYy5wb3J0O1xuXG4gICAgLy8gaWYgY3Jvc3Mgb3JpZ2luXG4gICAgaWYgKHVybC5ob3N0bmFtZSAhPT0gbG9jLmhvc3RuYW1lIHx8ICFzYW1lUG9ydCB8fCB1cmwucHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgICAgICByZXR1cm4gJ2Fub255bW91cyc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvdXRpbHMvZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXhSZWNvbW1lbmRlZFRleHR1cmVzO1xuXG52YXIgX2lzbW9iaWxlanMgPSByZXF1aXJlKCdpc21vYmlsZWpzJyk7XG5cbnZhciBfaXNtb2JpbGVqczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc21vYmlsZWpzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gbWF4UmVjb21tZW5kZWRUZXh0dXJlcyhtYXgpIHtcbiAgICBpZiAoX2lzbW9iaWxlanMyLmRlZmF1bHQudGFibGV0IHx8IF9pc21vYmlsZWpzMi5kZWZhdWx0LnBob25lKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZXMgaXMgaXBob25lIDYgb3IgaGlnaGVyLi5cbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuXG4gICAgLy8gZGVza3RvcCBzaG91bGQgYmUgb2tcbiAgICByZXR1cm4gbWF4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4UmVjb21tZW5kZWRUZXh0dXJlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGl4aS5qcy9saWIvY29yZS91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmRlbGF5TWl4aW4gPSBkZWxheU1peGluO1xuZXhwb3J0cy5wZXJmb3JtTWl4aW5zID0gcGVyZm9ybU1peGlucztcbi8qKlxuICogTWl4ZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHMubWl4aW5zXG4gKiBAZnVuY3Rpb24gbWl4aW5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIHByb3RvdHlwZSBvciBpbnN0YW5jZSB0aGF0IHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9mIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdG8gbWl4IGluLlxuICovXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghdGFyZ2V0IHx8ICFzb3VyY2UpIHJldHVybjtcbiAgICAvLyBpbiBFUzgvRVMyMDE3LCB0aGlzIHdvdWxkIGJlIHJlYWxseSBlYXN5OlxuICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG5cbiAgICAvLyBnZXQgYWxsIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IGtleXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggcHJvcGVydGllc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0ga2V5c1tpXTtcblxuICAgICAgICAvLyBTZXQgdGhlIHByb3BlcnR5IHVzaW5nIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIC0gdGhpcyB3b3JrcyBmb3IgYWNjZXNzb3JzIGFuZCBub3JtYWwgdmFsdWUgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wZXJ0eU5hbWUpKTtcbiAgICB9XG59XG5cbnZhciBtaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBRdWV1ZXMgYSBtaXhpbiB0byBiZSBoYW5kbGVkIHRvd2FyZHMgdGhlIGVuZCBvZiB0aGUgaW5pdGlhbGl6YXRpb24gb2YgUElYSSwgc28gdGhhdCBkZXByZWNhdGlvblxuICogY2FuIHRha2UgZWZmZWN0LlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzLm1peGluc1xuICogQGZ1bmN0aW9uIGRlbGF5TWl4aW5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRoZSBwcm90b3R5cGUgb3IgaW5zdGFuY2UgdGhhdCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNob3VsZCBiZSBhZGRlZCB0by5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvZiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRvIG1peCBpbi5cbiAqL1xuZnVuY3Rpb24gZGVsYXlNaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIG1peGlucy5wdXNoKHRhcmdldCwgc291cmNlKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFsbCBtaXhpbnMgcXVldWVkIHZpYSBkZWxheU1peGluKCkuXG4gKlxuICogQG1lbWJlcm9mIFBJWEkudXRpbHMubWl4aW5zXG4gKiBAZnVuY3Rpb24gcGVyZm9ybU1peGluc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGVyZm9ybU1peGlucygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBtaXhpbihtaXhpbnNbaV0sIG1peGluc1tpICsgMV0pO1xuICAgIH1cbiAgICBtaXhpbnMubGVuZ3RoID0gMDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1peGluLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL21peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKipcbiAqIE1peGlucyBmdW5jdGlvbmFsaXR5IHRvIG1ha2UgYW4gb2JqZWN0IGhhdmUgXCJwbHVnaW5zXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAgZnVuY3Rpb24gTXlPYmplY3QoKSB7fVxuICpcbiAqICAgICAgcGx1Z2luVGFyZ2V0Lm1peGluKE15T2JqZWN0KTtcbiAqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBtaXggaW50by5cbiAqL1xuZnVuY3Rpb24gcGx1Z2luVGFyZ2V0KG9iaikge1xuICAgIG9iai5fX3BsdWdpbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwbHVnaW4gdG8gYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGx1Z2luTmFtZSAtIFRoZSBldmVudHMgdGhhdCBzaG91bGQgYmUgbGlzdGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgLSBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBwbHVnaW4uXG4gICAgICovXG4gICAgb2JqLnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4ocGx1Z2luTmFtZSwgY3Rvcikge1xuICAgICAgICBvYmouX19wbHVnaW5zW3BsdWdpbk5hbWVdID0gY3RvcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFsbCB0aGUgcGx1Z2lucyBvZiB0aGlzIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgb2JqLnByb3RvdHlwZS5pbml0UGx1Z2lucyA9IGZ1bmN0aW9uIGluaXRQbHVnaW5zKCkge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMgfHwge307XG5cbiAgICAgICAgZm9yICh2YXIgbyBpbiBvYmouX19wbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbb10gPSBuZXcgb2JqLl9fcGx1Z2luc1tvXSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgcGx1Z2lucyBvZiB0aGlzIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgb2JqLnByb3RvdHlwZS5kZXN0cm95UGx1Z2lucyA9IGZ1bmN0aW9uIGRlc3Ryb3lQbHVnaW5zKCkge1xuICAgICAgICBmb3IgKHZhciBvIGluIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tvXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsdWdpbnMgPSBudWxsO1xuICAgIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBNaXhlcyBpbiB0aGUgcHJvcGVydGllcyBvZiB0aGUgcGx1Z2luVGFyZ2V0IGludG8gYW5vdGhlciBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqIHRvIG1peCBpbnRvXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uIG1peGluKG9iaikge1xuICAgICAgICBwbHVnaW5UYXJnZXQob2JqKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luVGFyZ2V0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9waXhpLmpzL2xpYi9jb3JlL3V0aWxzL3BsdWdpblRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRyaW1DYW52YXM7XG4vKipcbiAqIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVycyBmcm9tIGEgY2FudmFzXG4gKlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBmdW5jdGlvbiB0cmltQ2FudmFzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGNhbnZhcyB0byB0cmltXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUcmltIGRhdGFcbiAqL1xuZnVuY3Rpb24gdHJpbUNhbnZhcyhjYW52YXMpIHtcbiAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yZW15Lzc4NDUwOFxuXG4gICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuICAgIHZhciBsZW4gPSBwaXhlbHMubGVuZ3RoO1xuXG4gICAgdmFyIGJvdW5kID0ge1xuICAgICAgICB0b3A6IG51bGwsXG4gICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgIHJpZ2h0OiBudWxsLFxuICAgICAgICBib3R0b206IG51bGxcbiAgICB9O1xuICAgIHZhciBpID0gdm9pZCAwO1xuICAgIHZhciB4ID0gdm9pZCAwO1xuICAgIHZhciB5ID0gdm9pZCAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGlmIChwaXhlbHNbaSArIDNdICE9PSAwKSB7XG4gICAgICAgICAgICB4ID0gaSAvIDQgJSB3aWR0aDtcbiAgICAgICAgICAgIHkgPSB+fihpIC8gNCAvIHdpZHRoKTtcblxuICAgICAgICAgICAgaWYgKGJvdW5kLnRvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdW5kLnRvcCA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib3VuZC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm91bmQubGVmdCA9IHg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHggPCBib3VuZC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgYm91bmQubGVmdCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib3VuZC5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdW5kLnJpZ2h0ID0geCArIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdW5kLnJpZ2h0IDwgeCkge1xuICAgICAgICAgICAgICAgIGJvdW5kLnJpZ2h0ID0geCArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib3VuZC5ib3R0b20gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib3VuZC5ib3R0b20gPSB5O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChib3VuZC5ib3R0b20gPCB5KSB7XG4gICAgICAgICAgICAgICAgYm91bmQuYm90dG9tID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdpZHRoID0gYm91bmQucmlnaHQgLSBib3VuZC5sZWZ0O1xuICAgIGhlaWdodCA9IGJvdW5kLmJvdHRvbSAtIGJvdW5kLnRvcCArIDE7XG5cbiAgICB2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKGJvdW5kLmxlZnQsIGJvdW5kLnRvcCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW1DYW52YXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BpeGkuanMvbGliL2NvcmUvdXRpbHMvdHJpbUNhbnZhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wdW55Y29kZS9wdW55Y29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9xdWVyeXN0cmluZy1lczMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91cmwvdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VybC91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDIuMDQuMjAxNy5cclxuICovXHJcbmltcG9ydCBHYW1lU2NlbmUgZnJvbSBcIi4vR2FtZVNjZW5lXCI7XHJcbmltcG9ydCBTaW5nbGVQbGF5ZXJTdHJhdGVneSBmcm9tIFwiLi9zdHJhdGVnaWVzL1NpbmdsZXBsYXllclwiO1xyXG5pbXBvcnQgTXVsdGlQbGF5ZXJTdHJhdGVneSBmcm9tIFwiLi9zdHJhdGVnaWVzL011bHRpcGxheWVyXCI7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHVzZXIsIHZpZXcsIHN0cmF0ZWd5KSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlZCA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xyXG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneSA9PT0gd2luZG93LlNJTkdMRVBMQVlFUl9TVFJBVEVHWSA/IG5ldyBTaW5nbGVQbGF5ZXJTdHJhdGVneSgpIDogbmV3IE11bHRpUGxheWVyU3RyYXRlZ3koKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSB2aWV3Lm5vZGU7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuXHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBHYW1lU2NlbmUodmlldy5ub2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc3RhcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCd0LDRh9Cw0YLRjCDQuNCz0YDQvtCy0L7QuSDQv9GA0L7RhtC10YHRgVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3N0YXJ0KCl7XHJcbiAgICAgICAgLy9UT0RPIHN0YXJ0IHN0cmF0ZWd5XHJcbiAgICAgICAgdGhpcy5zY2VuZS5zZXRTdGF0ZSh3aW5kb3cuU1RBVEVXQUlUKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub3Bwb25lbnQgPSB0aGlzLl9nZXRPcHBvbmVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNldE5hbWVzKHRoaXMudXNlci5sb2dpbiwgdGhpcy5vcHBvbmVudC5sb2dpbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0U3RhdGUod2luZG93LlNUQVRFR0FNRSk7XHJcbiAgICAgICAgfSwgMTAwMCk7XHJcblxyXG4gICAgICAgLyogc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9wcG9uZW50ID0gdGhpcy5fZ2V0T3Bwb25lbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5zZXRVc2VyUmVzdWx0KHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogJ3dpbicsXHJcbiAgICAgICAgICAgICAgICBkaXZzY29yZTogMVxyXG4gICAgICAgICAgICB9LCB0aGlzLnVzZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNldFN0YXRlKHdpbmRvdy5TVEFURVJFU1VMVCk7XHJcbiAgICAgICAgfSwgMjAwMCk7Ki9cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7Qu9GD0YfQuNGC0Ywg0L/RgNC+0YLQuNCy0L3QuNC60LBcclxuICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0T3Bwb25lbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RyYXRlZ3kuY29uc3RydWN0b3IubmFtZSA9PT0gU2luZ2xlUGxheWVyU3RyYXRlZ3kubmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge2xvZ2luOiAnZGMuRFJFJ307XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9UT0RPIHNlYXJjaCBmb3Igb3Bwb25lbnQgaW4gZ2xvYmFsXHJcbiAgICAgICAgICAgIHJldHVybiB7bG9naW46ICdNVUxUSVBMQVlFUid9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWUvbW9kdWxlcy9HYW1lTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDI5LjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzL2xpYi9jb3JlL2luZGV4XCI7XHJcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCIuLi8uLi8uLi8uLi92ZW5kb3IvdGhyZWVcIjtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZVNjZW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuICAgICAgICB0aGlzLkhEaW0gPSAzNDtcclxuICAgICAgICB0aGlzLldEaW0gPSA1MDtcclxuXHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSB3aW5kb3cucm91dGVyO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcblxyXG4gICAgICAgIHRoaXMuX3NldFNpemUoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJDb250YWluZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0U2l6ZSgpe1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICB0aGlzLmZpZWxkU2l6ZSA9IChoZWlnaHQgLyB0aGlzLkhEaW0pIHwgMDtcclxuICAgICAgICB0aGlzLldJRFRIID0gdGhpcy5maWVsZFNpemUgKiB0aGlzLldEaW07XHJcbiAgICAgICAgdGhpcy5IRUdIVCA9IHRoaXMuZmllbGRTaXplIC8gMyAqIDIgKiB0aGlzLkhEaW1cclxuICAgIH1cclxuXHJcbiAgICBfcmVuZGVyQ29udGFpbmVyKCl7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweEVFRUVFRSwgMSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKCB0aGlzLldJRFRILCB0aGlzLkhFR0hUKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdnYW1lLWFyZWEnKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsICdnYW1lLWFyZWEnKTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXJGaWVsZCgpe1xyXG4gICAgICAgIGxldCBheGVzID0gbmV3IFRIUkVFLkF4aXNIZWxwZXIoIDIwICk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQoYXhlcyk7XHJcblxyXG4gICAgICAgIGxldCBwbGFuZUdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoNjAsMjAsMSwxKTtcclxuICAgICAgICBsZXQgcGxhbmVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6IDB4Y2NjY2NjfSk7XHJcbiAgICAgICAgbGV0IHBsYW5lID0gbmV3IFRIUkVFLk1lc2gocGxhbmVHZW9tZXRyeSxwbGFuZU1hdGVyaWFsKTtcclxuICAgICAgICBwbGFuZS5yb3RhdGlvbi54PS0wLjUqTWF0aC5QSTtcclxuICAgICAgICBwbGFuZS5wb3NpdGlvbi54ID0gMDtcclxuICAgICAgICBwbGFuZS5wb3NpdGlvbi55ID0gLTEwO1xyXG4gICAgICAgIHBsYW5lLnBvc2l0aW9uLnogPSAwO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHBsYW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBfcmVuZGVySGVscEZpZ3VyZSgpe1xyXG4gICAgICAgIGxldCBjdWJlR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDQsNCw0KTtcclxuICAgICAgICBsZXQgY3ViZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKFxyXG4gICAgICAgICAgICB7Y29sb3I6IDB4ZmYwMDAwLCB3aXJlZnJhbWU6IHRydWV9KTtcclxuICAgICAgICBsZXQgY3ViZSA9IG5ldyBUSFJFRS5NZXNoKGN1YmVHZW9tZXRyeSwgY3ViZU1hdGVyaWFsKTtcclxuICAgICAgICBjdWJlLnBvc2l0aW9uLnggPSAtNDtcclxuICAgICAgICBjdWJlLnBvc2l0aW9uLnkgPSAtNztcclxuICAgICAgICBjdWJlLnBvc2l0aW9uLnogPSAwO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKGN1YmUpO1xyXG5cclxuICAgICAgICBsZXQgc3BoZXJlR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoNCwyMCwyMCk7XHJcbiAgICAgICAgbGV0IHNwaGVyZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKFxyXG4gICAgICAgICAgICB7Y29sb3I6IDB4Nzc3N2ZmLCB3aXJlZnJhbWU6IHRydWV9KTtcclxuICAgICAgICBsZXQgc3BoZXJlID0gbmV3IFRIUkVFLk1lc2goc3BoZXJlR2VvbWV0cnksc3BoZXJlTWF0ZXJpYWwpO1xyXG4gICAgICAgIHNwaGVyZS5wb3NpdGlvbi54ID0gMjA7XHJcbiAgICAgICAgc3BoZXJlLnBvc2l0aW9uLnkgPSAtNjtcclxuICAgICAgICBzcGhlcmUucG9zaXRpb24ueiA9IDI7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQoc3BoZXJlKTtcclxuICAgIH1cclxuXHJcbiAgICByZWZyZXNoU2NlbmUoKXtcclxuICAgICAgICBsZXQgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1XHJcbiAgICAgICAgICAgICwgdGhpcy5XSURUSCAvIHRoaXMuSEVHSFQgLCAwLjEsIDEwMDApO1xyXG5cclxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueCA9IDA7IC8vINC60YDQsNGB0L3QsNGPXHJcbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgPSAyMDsgLy8g0LfQtdC70LXQvdCw0Y9cclxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IDM1OyAvLyDRgdC40L3Rj9GPXHJcbiAgICAgICAgY2FtZXJhLmxvb2tBdCh0aGlzLnNjZW5lLnBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgY2FtZXJhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCj0YHRgtCw0L3QvtCy0LjRgtGMINGC0LXQutGD0YnQtdC1INGB0L7RgdGC0L7Rj9C90LjQtVxyXG4gICAgICogQHBhcmFtIHN0YXRlIC0g0YHQvtGB0YLQvtGP0L3QuNC1XHJcbiAgICAgKi9cclxuICAgIHNldFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclN0YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAsINC+0YLQvdC+0YHQuNGC0LXQu9GM0L3QviDQstGF0L7QtNC90L7Qs9C+INGB0L7QsdGL0YLQuNGPXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyU3RhdGUoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2Ugd2luZG93LlNUQVRFV0FJVDoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyV2FpdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSB3aW5kb3cuU1RBVEVHQU1FOiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJHYW1lKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHdpbmRvdy5TVEFURVJFU1VMVDoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyUmVzdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQttC00YPRidC10LPQviDRgNC10LbQuNC80LBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9yZW5kZXJXYWl0KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAg0LjQs9GA0L7QstC+0LPQviDRgNC10LbQuNC80LBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9yZW5kZXJHYW1lKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAvL3RoaXMuX3Jlc2l6ZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyRmllbGQoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJIZWxwRmlndXJlKCk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoU2NlbmUoKTtcclxuICAgICAgICAvKnRoaXMuX3JlbmRlck5hbWVzKCk7XHJcbiAgICAgICAgLy90aGlzLl9yZW5kZXJBY3Rpb25Db250YWluZXIoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJIZWFsdGhCYXIoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJGaWVsZCgpOyovXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAg0LvQvtCz0LjQvdC+0LIg0LjQs9GA0L7QutC+0LIg0L/QviDRg9Cz0LvQsNC8XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICAvKl9yZW5kZXJOYW1lcygpIHtcclxuICAgICAgICBsZXQgbWVMb2dpbiA9IG5ldyBQSVhJLlRleHQodGhpcy5wbGF5ZXJzLm1lLCB7XHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdPcmJpdHJvbicsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNSxcclxuICAgICAgICAgICAgZmlsbDogJ2JsYWNrJyxcclxuICAgICAgICAgICAgYWxpZ246ICdsZWZ0J1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1lTG9naW4ueCA9IDEwO1xyXG4gICAgICAgIG1lTG9naW4ueSA9IDEwO1xyXG5cclxuICAgICAgICBsZXQgb3Bwb25lbnRMb2dpbiA9IG5ldyBQSVhJLlRleHQodGhpcy5wbGF5ZXJzLm9wcG9uZW50LCB7XHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdPcmJpdHJvbicsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNSxcclxuICAgICAgICAgICAgZmlsbDogJ2JsYWNrJyxcclxuICAgICAgICAgICAgYWxpZ246ICdyaWdodCdcclxuICAgICAgICB9KTtcclxuICAgICAgICBvcHBvbmVudExvZ2luLnggPSB0aGlzLmFwcC5yZW5kZXJlci53aWR0aCAtIG9wcG9uZW50TG9naW4ud2lkdGggLSAxMDtcclxuICAgICAgICBvcHBvbmVudExvZ2luLnkgPSAxMDtcclxuXHJcbiAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQobWVMb2dpbiwgb3Bwb25lbnRMb2dpbik7XHJcbiAgICB9Ki9cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQsdCw0LvQsNC90YHQsCDQt9C00L7RgNC+0LLRjNGPXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICAvKl9yZW5kZXJIZWFsdGhCYXIoKSB7XHJcbiAgICAgICAgLy9DcmVhdGUgdGhlIGhlYWx0aCBiYXJcclxuICAgICAgICB0aGlzLm9wcG9uZW50SGVhbHRoQmFyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5vcHBvbmVudEhlYWx0aEJhci5wb3NpdGlvbi5zZXQodGhpcy5hcHAucmVuZGVyZXIud2lkdGggLSAxMiwgNDApO1xyXG4gICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMub3Bwb25lbnRIZWFsdGhCYXIpO1xyXG5cclxuICAgICAgICB0aGlzLm15SGVhbHRoQmFyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5teUhlYWx0aEJhci5wb3NpdGlvbi5zZXQoMTIsIDQwKTtcclxuICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLm15SGVhbHRoQmFyKTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGUgdGhlIGZyb250IHJlZCByZWN0YW5nbGVcclxuICAgICAgICBsZXQgb3Bwb25lbnRPdXRlckJhciA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgb3Bwb25lbnRPdXRlckJhci5iZWdpbkZpbGwoMHgwODFiMzIpO1xyXG4gICAgICAgIG9wcG9uZW50T3V0ZXJCYXIuZHJhd1JlY3QoMCwgMCwgLTEwMCwgOCk7XHJcbiAgICAgICAgb3Bwb25lbnRPdXRlckJhci5lbmRGaWxsKCk7XHJcbiAgICAgICAgdGhpcy5vcHBvbmVudEhlYWx0aEJhci5hZGRDaGlsZChvcHBvbmVudE91dGVyQmFyKTtcclxuXHJcbiAgICAgICAgbGV0IG15T3V0ZXJCYXIgPSBuZXcgUElYSS5HcmFwaGljcygpO1xyXG4gICAgICAgIG15T3V0ZXJCYXIuYmVnaW5GaWxsKDB4MDgxYjMyKTtcclxuICAgICAgICBteU91dGVyQmFyLmRyYXdSZWN0KDAsIDAsIDEwMCwgOCk7XHJcbiAgICAgICAgbXlPdXRlckJhci5lbmRGaWxsKCk7XHJcbiAgICAgICAgdGhpcy5teUhlYWx0aEJhci5hZGRDaGlsZChteU91dGVyQmFyKTtcclxuXHJcbiAgICAgICAgdGhpcy5vcHBvbmVudEhlYWx0aEJhci5vdXRlciA9IG9wcG9uZW50T3V0ZXJCYXI7XHJcbiAgICAgICAgdGhpcy5teUhlYWx0aEJhci5vdXRlciA9IG15T3V0ZXJCYXI7XHJcbiAgICB9Ki9cclxuXHJcbiAgICAvKipcclxuICAgICAqINCj0YHRgtCw0L3QvtCy0LjRgtGMINGC0LXQutGD0YnQtdC1INC30LTQvtGA0L7QstGM0LVcclxuICAgICAqIEBwYXJhbSBoZWFsdGhcclxuICAgICAqL1xyXG4gICAgLypzZXRNeUhlYWx0aChoZWFsdGgpIHtcclxuICAgICAgICB0aGlzLm9wcG9uZW50SGVhbHRoQmFyLm91dGVyLndpZHRoID0gaGVhbHRoO1xyXG4gICAgfSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQo9GB0YLQsNC90L7QstC40YLRjCDRgtC10LrRg9GJ0LXQtSDQt9C00L7RgNC+0LLRjNC1INC/0YDQvtGC0LjQstC90LjQutCwXHJcbiAgICAgKiBAcGFyYW0gaGVhbHRoXHJcbiAgICAgKi9cclxuICAgIC8qc2V0T3Bwb25lbnRIZWFsdGgoaGVhbHRoKSB7XHJcbiAgICAgICAgdGhpcy5teUhlYWx0aEJhci5vdXRlci53aWR0aCA9IGhlYWx0aDtcclxuICAgIH0qL1xyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAg0L/QvtGB0LvQtdC40LPRgNC+0LLQvtCz0L4g0YDQtdC20LjQvNCwICjRgNC10LfRg9C70YzRgtCw0YLRiywg0LjRgtC+0LPQuClcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9yZW5kZXJSZXN1bHQoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRh9C40YHRgtC60LAg0L7RgdC90L7QstC90L7Qs9C+INC60L7QvdGC0LXQudC90LXRgNCwXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuY2hpbGRyZW4uc3BsaWNlKDAsIHRoaXMuc2NlbmUuY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hTY2VuZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KPRgdGC0LDQvdC+0LLQutCwINC40LzQtdC9INC40LPRgNC+0LrQvtCyXHJcbiAgICAgKiBAcGFyYW0gbWVcclxuICAgICAqIEBwYXJhbSBvcHBvbmVudFxyXG4gICAgICovXHJcbiAgICBzZXROYW1lcyhtZSwgb3Bwb25lbnQpIHtcclxuICAgICAgICB0aGlzLnBsYXllcnMgPSB7bWU6IG1lLCBvcHBvbmVudDogb3Bwb25lbnR9O1xyXG4gICAgfVxyXG5cclxuICAgIHNldFVzZXJSZXN1bHQob2JqUmVzdWx0LCB1c2VyKSB7XHJcbiAgICAgICAgdGhpcy5vYmpSZXN1bHQgPSBvYmpSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG5cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWUvbW9kdWxlcy9HYW1lU2NlbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwMi4wNC4yMDE3LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXVsdGlQbGF5ZXJTdHJhdGVneXtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNdWx0aVBsYXllclN0cmF0ZWd5LmMnKTtcclxuICAgIH1cclxuXHJcbiAgICBnYW1lTG9vcCgpe1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGFydEdhbWVMb29wKCkge1xyXG4gICAgICAgIHRoaXMuaW50ZXZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuZ2FtZUxvb3AoKSwgMTAwKTtcclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWUvbW9kdWxlcy9zdHJhdGVnaWVzL011bHRpcGxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDIuMDQuMjAxNy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbmdsZVBsYXllclN0cmF0ZWd5e1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdhbWVMb29wKCl7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0R2FtZUxvb3AoKSB7XHJcbiAgICAgICAgdGhpcy5pbnRldmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5nYW1lTG9vcCgpLCAxMDApO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9nYW1lL21vZHVsZXMvc3RyYXRlZ2llcy9TaW5nbGVwbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwMi4wMy4yMDE3LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XHJcbiAgICAgICAgdGhpcy5hdHRycyA9IG9wdGlvbnMuYXR0cnMgfHwgW107XHJcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQob3B0aW9ucy50eXBlKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0QXR0cnMoYXR0cnMpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RWxlbSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSB0aGlzLnRleHQ7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cnModGhpcy5hdHRycyk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwub3V0ZXJIVE1MO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL21lbnUvZWxlbWVudHMvQnRuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMjMuMDMuMjAxNy5cclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaWFtb25kIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbG9yLCBzdHJva2VXaWR0aCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcihjb2xvciB8fCAnd2hpdGUnLCBzdHJva2VXaWR0aCB8fCAnMicpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEVsZW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlbmRlcihjb2xvciwgc3Ryb2tlV2lkdGgpIHtcclxuICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzUwJyk7XHJcbiAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICc1MCcpO1xyXG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICdkaWFtb25kJyk7XHJcbiAgICAgICAgaWYodGhpcy5lbC5nZXRDb250ZXh0KXtcclxuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLmVsLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoPWAke3N0cm9rZVdpZHRofWA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGU9YCR7Y29sb3J9YDtcclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMTIsOCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDM4LDgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyg0NywxOSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDI1LDQ1KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMiwxOSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDEyLDgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygxNywxOSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDI1LDgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygzMiwxOSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDM4LDgpO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygyLDE5KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oNDcsMTkpO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygxNywxOSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDI1LDQ1KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMzIsMTkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL21lbnUvZWxlbWVudHMvRGlhbW9uZC5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDAyLjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgQ2hlY2tGaWVsZHMgZnJvbSAnLi4vYWN0aW9ucy9DaGVja0ZpZWxkcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xyXG4gICAgICAgIHRoaXMuYXR0cnMgPSBvcHRpb25zLmF0dHJzIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuaGVscF9hdHRycyA9IG9wdGlvbnMuaGVscF9hdHRycyB8fCBbXTtcclxuICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgICAgICB0aGlzLmhlbHBfZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldEF0dHJzKGF0dHJzLCBlbGVtKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cnModGhpcy5hdHRycywgdGhpcy5lbCk7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cnModGhpcy5oZWxwX2F0dHJzLCB0aGlzLmhlbHBfZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEVsZW0oKXtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vdXRlckhUTUw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsaWRhdGUocHJldikge1xyXG4gICAgICAgIGxldCBjaGVjayA9IHRydWU7XHJcbiAgICAgICAgaWYgKENoZWNrRmllbGRzLmNoZWNrRW1wdHkodGhpcy5lbC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRTZXRFcnIodGhpcy5lbCk7XHJcbiAgICAgICAgICAgIENoZWNrRmllbGRzLmhlbHBTZXRUZXh0KHRoaXMuaGVscF9lbCwgJ2VtcHR5IGZpZWxkJyk7XHJcbiAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRSZW1vdmVFcnIodGhpcy5lbCk7XHJcbiAgICAgICAgICAgIENoZWNrRmllbGRzLmhlbHBTZXRUZXh0KHRoaXMuaGVscF9lbCwgJycpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgndmFsaWQnKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkID09PSAnbG9naW4nKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gQ2hlY2tGaWVsZHMuY2hlY2tMb2dpbih7ZmllbGQ6IHRoaXMuZWwsIGhlbHA6IHRoaXMuaGVscF9lbH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWQgPT09ICdwYXNzd29yZCcpIHtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWQgPT09ICdyZXBlYXRwYXNzd29yZCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBDaGVja0ZpZWxkcy5jaGVja1Bhc3N3b3JkKFxyXG4gICAgICAgICAgICAgICAgICAgIHtmaWVsZDogcHJldi5lbCwgaGVscDogcHJldi5oZWxwX2VsfSxcclxuICAgICAgICAgICAgICAgICAgICB7ZmllbGQ6IHRoaXMuZWwsIGhlbHA6IHRoaXMuaGVscF9lbH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIENoZWNrRmllbGRzLmhlbHBTZXRUZXh0KHRoaXMuaGVscF9lbCwgJycpO1xyXG4gICAgICAgIENoZWNrRmllbGRzLmZpZWxkU2V0VGV4dCh0aGlzLmVsLCAnJyk7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRSZW1vdmVPayh0aGlzLmVsKTtcclxuICAgICAgICBDaGVja0ZpZWxkcy5maWVsZFJlbW92ZUVycih0aGlzLmVsKTtcclxuICAgIH1cclxuXHJcbiAgICAvL25vaW5zcGVjdGlvbiBKU0R1cGxpY2F0ZWREZWNsYXJhdGlvblxyXG4gICAgc2V0RXJyb3IoKSB7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRTZXRFcnIodGhpcy5lbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9ub2luc3BlY3Rpb24gSlNEdXBsaWNhdGVkRGVjbGFyYXRpb25cclxuICAgIHNldEVycm9yKHZhbHVlKSB7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRTZXRFcnIodGhpcy5lbCk7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuaGVscFNldFRleHQodGhpcy5oZWxwX2VsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbWVudS9lbGVtZW50cy9JbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDA0LjAzLjIwMTcuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gJy4uLy4uL3N1cHBvcnQvc2VydmljZS9Vc2VyU2VydmljZSc7XHJcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tICcuLi9lbGVtZW50cy9Qcm9ncmVzc0Jhcic7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlYWRlckJvYXJkIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXIoZGF0YSkge1xyXG4gICAgICAgIGxldCBsZWFkZXJCb2FyZFNvdXJjZSA9IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAge3sjd2l0aCB0aXRsZXN9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyPnt7dGl0bGV9fTwvaDI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7L3dpdGh9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInt7Y29udHJvbC5jbGFzc319XCIgaWQ9XCJ7e2NvbnRyb2wuaWR9fVwiPnt7Y29udHJvbC50ZXh0fX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7I2lmIGxlYWRlcmJvYXJkfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibGlzdC1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sjZWFjaCBsZWFkZXJib2FyZH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJsaXN0LWdyb3VwLWl0ZW1cIj57e2xvZ2lufX08c3BhbiBjbGFzcz1cImJhZGdlXCI+e3tyYXRpbmd9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicG9zaXRpb25cIj57e3Bvc2l0aW9ufX08L3NwYW4+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7L2VhY2h9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7ey9pZn19YDtcclxuICAgICAgICBsZXQgbGVhZGVyQm9hcmRUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShsZWFkZXJCb2FyZFNvdXJjZSk7XHJcbiAgICAgICAgcmV0dXJuIGxlYWRlckJvYXJkVGVtcGxhdGUoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaExlYWRlckJvYXJkKCkge1xyXG4gICAgICAgIHRoaXMuX3NldFByb2dyZXNzQmFyKHRoaXMubm9kZSk7XHJcblxyXG4gICAgICAgIG5ldyBVc2VyU2VydmljZSgpLmdldExlYWRlcnMoKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgbGV0IGFyciA9IHJlc3BvbnNlLmxlYWRlcnM7XHJcbiAgICAgICAgICAgIGxldCBpdGVyID0gMTtcclxuICAgICAgICAgICAgYXJyLmZvckVhY2goZWxlbT0+e1xyXG4gICAgICAgICAgICAgICBlbGVtLnBvc2l0aW9uID0gYCR7aXRlcn0uYDtcclxuICAgICAgICAgICAgICAgaXRlcisrO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuaW5uZXJIVE1MID0gdGhpcy5fcmVuZGVyKHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUb3AgcGxheWVyczonLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZGVyYm9hcmQ6IGFycixcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdSZWZyZXNoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdsaW5rX19yZWZyZXNoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZWZyZXNoLWxiJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFJlZnJlc2hMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmlubmVySFRNTCA9IHRoaXMuX3JlbmRlcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ05vIGNvbm5lY3Rpb24nLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycjoge30sXHJcbiAgICAgICAgICAgICAgICBjb250cm9sOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1JlZnJlc2gnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnbGluaycsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZWZyZXNoLWxiJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFJlZnJlc2hMaXN0ZW5lcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9pbml0UmVmcmVzaExpc3RlbmVyKCkge1xyXG4gICAgICAgIGxldCByZWZyZXNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlZnJlc2gtbGInKTtcclxuICAgICAgICBpZiAocmVmcmVzaCkge1xyXG4gICAgICAgICAgICByZWZyZXNoLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoTGVhZGVyQm9hcmQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9jbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgICAgICB3aGlsZSAoY29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfc2V0UHJvZ3Jlc3NCYXIoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJDb250YWluZXIoY29udGFpbmVyKTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmV3IFByb2dyZXNzQmFyKCkuZ2V0RWxlbSgpKTtcclxuICAgIH1cclxufVxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbWVudS90ZW1wbGF0ZXMvTGVhZGVyQm9hcmQuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAxMi4wMy4yMDE3LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHNob3coZWxlbSl7XHJcbiAgICAgICAgaWYoZWxlbSl7XHJcbiAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnZWxlbS1oaWRlJyk7XHJcbiAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZCgnZWxlbS1zaG93Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhpZGUoZWxlbSl7XHJcbiAgICAgICAgaWYoZWxlbSl7XHJcbiAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnZWxlbS1zaG93Jyk7XHJcbiAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZCgnZWxlbS1oaWRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvc3VwcG9ydC9hbmltL0FuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDE3LjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi4vQmFzZVZpZXcnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZVZpZXcgZXh0ZW5kcyBCYXNlVmlld3tcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpe1xyXG4gICAgICAgIHN1cGVyKG5vZGUpO1xyXG4gICAgICAgIHRoaXMucm91dGVyID0gd2luZG93LnJvdXRlcjtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KPQtNCw0LvRj9C10Lwg0LLRgdC1INGN0LvQtdC80LXQvdGC0Ysg0LjQtyDQstGM0Y7RiNC60LhcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKXtcclxuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy92aWV3cy9nYW1lL0dhbWVWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTkuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCYXNlVmlldyBmcm9tICcuLi9CYXNlVmlldyc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFib3V0VmlldyBleHRlbmRzIEJhc2VWaWV3e1xyXG4gICAgY29uc3RydWN0b3Iobm9kZSl7XHJcbiAgICAgICAgc3VwZXIobm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuXHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy92aWV3cy9tZW51L0Fib3V0Vmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDE5LjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi4vQmFzZVZpZXcnO1xyXG5pbXBvcnQgTGVhZGVyQm9hcmQgZnJvbSBcIi4uLy4uL21lbnUvdGVtcGxhdGVzL0xlYWRlckJvYXJkXCI7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlYWRlckJvYXJkVmlldyBleHRlbmRzIEJhc2VWaWV3e1xyXG4gICAgY29uc3RydWN0b3Iobm9kZSl7XHJcbiAgICAgICAgc3VwZXIobm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICBuZXcgTGVhZGVyQm9hcmQobm9kZSkucmVmcmVzaExlYWRlckJvYXJkKCk7XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy92aWV3cy9tZW51L0xlYWRlckJvYXJkVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDE5LjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi4vQmFzZVZpZXcnO1xyXG5pbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSBcIi4uLy4uL21lbnUvZWxlbWVudHMvUHJvZ3Jlc3NCYXJcIjtcclxuaW1wb3J0IEZvcm0gZnJvbSBcIi4uLy4uL21lbnUvZWxlbWVudHMvRm9ybVwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL3N1cHBvcnQvc2VydmljZS9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlciBmcm9tIFwiLi4vLi4vZ2FtZS9vYmplY3QvVXNlclwiO1xyXG5pbXBvcnQgUm91dGVyVXJscyBmcm9tIFwiLi4vLi4vc3VwcG9ydC9yb3V0ZXIvUm91dGVyVXJsc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9naW5WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xyXG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xyXG4gICAgICAgIHN1cGVyKG5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSB3aW5kb3cucm91dGVyO1xyXG4gICAgICAgIHRoaXMuX3Nob3dWaWV3UHJvZ3Jlc3NCYXIoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQstGM0Y7RiNC60LhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5sb2dpbkZvcm0gPSBuZXcgRm9ybSh7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0xvZyBJbicsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICd0ZXh0LWNlbnRlcidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZm9ybToge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZmNvbnRhaW5lci1jb2x1bW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZpZWxkczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnTG9naW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdsLWxvZ2luJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnaW5wdXQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xvZ2luJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwX2F0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2wtbG9naW4taGVscCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3BfX2Vycm9yJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1Bhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnbC1wYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2lucHV0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGFzc3dvcmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBfYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnbC1wYXNzd29yZC1oZWxwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAncF9fZXJyb3InXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgY29udHJvbHM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdFbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3VibWl0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnYnRuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYnRuLWxvZ2luJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnV0dG9uJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnU2lnbiB1cCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2xpbmsgcm91dGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYnRuLXRvLXNpZ251cCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cuU0lHTlVQXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmdldEVsZW0oKTtcclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGVWaWV3UHJvZ3Jlc3NCYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMubG9naW5Gb3JtLmVsKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9naW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1sb2dpbicpO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2wtcGFzc3dvcmQnKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dpbkhlbHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1sb2dpbi1oZWxwJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuTG9naW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLWxvZ2luJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuVG9TaWduVXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLXRvLXNpZ251cCcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5pdExpc3RlbmVyKCk7XHJcbiAgICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7QutCw0LfQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc2hvd1ZpZXdQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICBsZXQgcHJvZ3Jlc3NCYXIgPSBuZXcgUHJvZ3Jlc3NCYXIoKS5nZXRFbGVtKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHByb2dyZXNzQmFyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCh0L/RgNGP0YLQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfaGlkZVZpZXdQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9C+0LrQsNC30LDRgtGMINC/0YDQvtCz0YDQtdGB0YEg0LHQsNGAINGE0L7RgNC80YtcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9zaG93UHJvZ3Jlc3NCYXIoKSB7XHJcbiAgICAgICAgdGhpcy5idG5Mb2dpbi5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIGxldCBwcm9ncmVzc0JhciA9IG5ldyBQcm9ncmVzc0JhcigpLmdldEVsZW0oKTtcclxuICAgICAgICB0aGlzLmJ0bkxvZ2luLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHByb2dyZXNzQmFyLCB0aGlzLmJ0bkxvZ2luLm5leHRTaWJsaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCh0L/RgNGP0YLQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0YTQvtGA0LzRi1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2hpZGVQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idG5Mb2dpbi5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idG5Mb2dpbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYnRuTG9naW4ubmV4dEVsZW1lbnRTaWJsaW5nKTtcclxuICAgICAgICB9LCA1MDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JfQsNC/0YPRgdC6INGB0LvRg9GI0LDRgtC10LvQtdC5INC90LAg0YTQvtGA0LzRg1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2luaXRMaXN0ZW5lcigpIHtcclxuICAgICAgICAvL1N1Ym1pdCBmb3JtXHJcbiAgICAgICAgdGhpcy5sb2dpbkZvcm0uZWwuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tGaWVsZHMoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSB0aGlzLmxvZ2luRm9ybS5nZXRGb3JtRGF0YSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dQcm9ncmVzc0JhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ldyBVc2VyU2VydmljZSgpLmxvZ2luKGJvZHkpLnRoZW4odXNlciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJGaWVsZHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL25ldyBVc2VyKCkub2JqID0gdXNlcjtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuVVNFUiA9IHVzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3V0ZXIuX3NldEN1cnJWaWV3KHdpbmRvdy5QUk9GSUxFKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZVByb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2luRm9ybS5maWVsZHMuZm9yRWFjaChlbGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEVycm9yKCd3cm9uZyBkYXRhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZVByb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5idG5Ub1NpZ25VcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50PT57XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRmllbGRzKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRh9C40YHRgtC60LAg0L/QvtC70LXQuSDRhNC+0YDQvNGLXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfY2xlYXJGaWVsZHMoKSB7XHJcbiAgICAgICAgdGhpcy5sb2dpbkZvcm0uZmllbGRzLmZvckVhY2goZWxlbSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW0uY2xlYXIoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0YDQvtCy0LXRgNC60LAg0L/QvtC70LXQuSDRhNC+0YDQvNGLXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2NoZWNrRmllbGRzKCkge1xyXG4gICAgICAgIGxldCBjaGVjayA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMubG9naW5Gb3JtLmZpZWxkcy5mb3JFYWNoKGVsZW0gPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZWxlbS52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGVjaztcclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL3ZpZXdzL21lbnUvTG9naW5WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTkuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCYXNlVmlldyBmcm9tICcuLi9CYXNlVmlldyc7XHJcbmltcG9ydCBSb3V0ZXJVcmxzIGZyb20gXCIuLi8uLi9zdXBwb3J0L3JvdXRlci9Sb3V0ZXJVcmxzXCI7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbnVWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xyXG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xyXG4gICAgICAgIHN1cGVyKG5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoe1xyXG4gICAgICAgICAgICBlbGVtZW50czogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhJyxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cuTEVBREVSQk9BUkQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnYnRuX19wbGF5IHJvdXRlcidcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2gxJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0xFQURFUiBCT0FSRCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhJyxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cuTE9HSU4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnYnRuX19tYWluLXBsYXkgcm91dGVyJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaDEnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnUExBWSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhJyxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cuQUJPVVQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnYnRuX19wbGF5IHJvdXRlcidcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2gxJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0FCT1VUJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQvNC10L3RjlxyXG4gICAgICogQHBhcmFtIGluc3RyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcihpbnN0cikge1xyXG4gICAgICAgIGxldCBlbGVtQXJyYXkgPSB0aGlzLl9nZXRFbGVtcyhpbnN0ci5lbGVtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fZWxlbXNBcHBlbmRUbyhlbGVtQXJyYXksIHRoaXMubm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQo9GB0YLQsNC90L7QstC60LAg0LzQsNGB0YHQuNCyINCw0YLRgNC40LHQutGD0YLQvtCyXHJcbiAgICAgKiBAcGFyYW0gYXR0cnNcclxuICAgICAqIEBwYXJhbSBlbGVtXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc2V0QXR0cnMoYXR0cnMsIGVsZW0pIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JTQvtCx0LDQstC40YLRjCDQvNCw0YHRgdC40LIg0Y3Qu9C10LzQtdC90YLQvtCyXHJcbiAgICAgKiBAcGFyYW0gYXJyYXlcclxuICAgICAqIEBwYXJhbSBlbGVtXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZWxlbXNBcHBlbmRUbyhhcnJheSwgZWxlbSkge1xyXG4gICAgICAgIGFycmF5LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoaXRlbSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7Qu9GD0YfQuNGC0Ywg0LzQsNGB0YHQuNCyINGN0LvQtdC80LXQvdGC0L7QslxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRzIC0g0LjQvdGB0YLRgNGD0LrRhtC40Lgg0L/QviDRgdC+0LfQtNCw0L3QuNGOXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0RWxlbXMoZWxlbWVudHMpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGF0YS50eXBlKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cnMoZGF0YS5hdHRycywgZWxlbSk7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGF0YS5lbGVtZW50LnR5cGUpO1xyXG4gICAgICAgICAgICB0ZXh0RWxlbS50ZXh0Q29udGVudCA9IGRhdGEuZWxlbWVudC50ZXh0O1xyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKHRleHRFbGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvdmlld3MvbWVudS9NZW51Vmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDE5LjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi4vQmFzZVZpZXcnO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSAnLi4vLi4vc3VwcG9ydC9zZXJ2aWNlL1VzZXJTZXJ2aWNlJztcclxuaW1wb3J0IFVzZXIgZnJvbSAnLi4vLi4vZ2FtZS9vYmplY3QvVXNlcic7XHJcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tIFwiLi4vLi4vbWVudS9lbGVtZW50cy9Qcm9ncmVzc0JhclwiO1xyXG5pbXBvcnQgRGlhbW9uZCBmcm9tIFwiLi4vLi4vbWVudS9lbGVtZW50cy9EaWFtb25kXCI7XHJcbmltcG9ydCBSb3V0ZXJVcmxzIGZyb20gXCIuLi8uLi9zdXBwb3J0L3JvdXRlci9Sb3V0ZXJVcmxzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9maWxlVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuICAgICAgICBzdXBlcihub2RlKTtcclxuICAgICAgICB0aGlzLnJvdXRlciA9IHdpbmRvdy5yb3V0ZXI7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICAvL3RoaXMucmVmcmVzaFByb2ZpbGUoKTtcclxuICAgICAgICB0aGlzLl9zaG93Vmlld1Byb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9C+0LvRg9GH0LjRgtGMINGO0LfQtdGA0LBcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0VXNlcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBuZXcgVXNlclNlcnZpY2UoKS5nZXRVc2VyKCkudGhlbih1c2VyID0+IHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5VU0VSID0gdXNlcjtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcik7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3Qoe30pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQv9GA0L7RhNCw0LnQu9CwXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2dldFVzZXIoKS50aGVuKHVzZXIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2ZpbGUgPSB0aGlzLl9jcmVhdGVQcm9maWxlKHVzZXIpO1xyXG5cclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlVmlld1Byb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wcm9maWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2luID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2wtbG9naW4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFzc3dvcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1wYXNzd29yZCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dpbkhlbHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1sb2dpbi1oZWxwJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ0bkxvZ2luID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bi1sb2dpbicpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGVWaWV3UHJvZ3Jlc3NCYXIoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCX0LDQv9GD0YHQuiDRgdC70YPRiNCw0YLQtdC70LXQuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2luaXRMaXN0ZW5lcigpIHtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLWxvZ291dCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBuZXcgVXNlclNlcnZpY2UoKS5sb2dPdXRVc2VyKCkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5fc2V0Q3VyclZpZXcod2luZG93LkxPR0lOKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J/QvtC60LDQt9Cw0YLRjCDQv9GA0L7Qs9GA0LXRgdGBINCx0LDRgCDQstGM0Y7RiNC60LhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9zaG93Vmlld1Byb2dyZXNzQmFyKCkge1xyXG4gICAgICAgIGxldCBwcm9ncmVzc0JhciA9IG5ldyBQcm9ncmVzc0JhcigpLmdldEVsZW0oKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NCYXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KHQv9GA0Y/RgtCw0YLRjCDQv9GA0L7Qs9GA0LXRgdGBINCx0LDRgCDQstGM0Y7RiNC60LhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9oaWRlVmlld1Byb2dyZXNzQmFyKCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRh9C40YHRgtC60LAg0LrQvtC90YLQtdC50L3QtdGA0LBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jbGVhckNvbnRhaW5lcigpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0LHQvdC+0LLQuNGC0Ywg0LLRjNGO0YjQutGDXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2goKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLl9zaG93Vmlld1Byb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQodC+0LfQtNCw0L3QuNC1INGN0LvQtdC80LXQvdGC0L7QsiDQv9GA0L7RhNCw0LnQu9CwXHJcbiAgICAgKiBAcGFyYW0gdXNlclxyXG4gICAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jcmVhdGVQcm9maWxlKHVzZXIpIHtcclxuICAgICAgICBsZXQgcHJvZmlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHByb2ZpbGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdmY29udGFpbmVyLXJvdycpO1xyXG5cclxuICAgICAgICAvKiBjcmVhdGUgY29udHJvbGxlcnMgZGl2Ki9cclxuICAgICAgICBsZXQgY29udHJvbGxlcnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250cm9sbGVyc0Rpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3Byb2ZpbGVfX2NvbnRhaW5lciBmY29udGFpbmVyLXJvdycpO1xyXG5cclxuICAgICAgICBsZXQgaHJlZlBsYXlNID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIGhyZWZQbGF5TS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB3aW5kb3cuTVVMVElQTEFZRVIpO1xyXG4gICAgICAgIGhyZWZQbGF5TS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3JvdXRlciBidG5fX3Byb2ZpbGUnKTtcclxuICAgICAgICBsZXQgaDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xyXG4gICAgICAgIGgxLmlubmVySFRNTCA9ICdNdWx0aXBsYXllcic7XHJcbiAgICAgICAgaHJlZlBsYXlNLmFwcGVuZENoaWxkKGgxKTtcclxuXHJcbiAgICAgICAgbGV0IGhyZWZQbGF5UyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICBocmVmUGxheVMuc2V0QXR0cmlidXRlKCdocmVmJywgd2luZG93LlNJTkdMRVBMQVlFUik7XHJcbiAgICAgICAgaHJlZlBsYXlTLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncm91dGVyIGJ0bl9fcHJvZmlsZScpO1xyXG4gICAgICAgIGgxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcclxuICAgICAgICBoMS5pbm5lckhUTUwgPSAnU2luZ2xlIHBsYXknO1xyXG4gICAgICAgIGhyZWZQbGF5Uy5hcHBlbmRDaGlsZChoMSk7XHJcblxyXG4gICAgICAgIGNvbnRyb2xsZXJzRGl2LmFwcGVuZENoaWxkKGhyZWZQbGF5TSk7XHJcbiAgICAgICAgY29udHJvbGxlcnNEaXYuYXBwZW5kQ2hpbGQoaHJlZlBsYXlTKTtcclxuXHJcbiAgICAgICAgLypjcmVhdGUgdXNlciBkaXYqL1xyXG4gICAgICAgIGxldCB1c2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdXNlckRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2Zjb250YWluZXItY29sdW1uJyk7XHJcblxyXG4gICAgICAgIGxldCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcclxuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndGV4dF9fcHJvZmlsZS1sb2dpbicpO1xyXG4gICAgICAgIGVsZW0uaW5uZXJUZXh0ID0gYCR7dXNlci5sb2dpbn1gO1xyXG4gICAgICAgIHVzZXJEaXYuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcblxyXG4gICAgICAgIGxldCBhcnJWYWx1ZSA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1JhdGluZzonLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVzZXIucmF0aW5nXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdXaW5uaW5nczonLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVzZXIuZ2FtZV9jb3VudF93aW5cclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1RvdGFsIG1hdGNoZXM6ICcsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdXNlci5nYW1lX2NvdW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBhcnJWYWx1ZS5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XHJcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsICd0ZXh0X19wcm9maWxlLWl0ZW0nKTtcclxuICAgICAgICAgICAgZWxlbS5pbm5lclRleHQgPSBgJHtlbC5uYW1lfSAke2VsLnZhbHVlfWA7XHJcbiAgICAgICAgICAgIHVzZXJEaXYuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8qY3JlYXRlIHJlc291cmNlcyBkaXYqL1xyXG4gICAgICAgIGxldCByZXNvdXJjZXNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICByZXNvdXJjZXNEaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdmY29udGFpbmVyLWNvbHVtbicpO1xyXG5cclxuICAgICAgICBsZXQgYXJyQ3J5c3RhbHMgPSBbXHJcbiAgICAgICAgICAgIHt2YWx1ZTogdXNlci5jcnlzdGFsX2dyZWVuLCBjb2xvcjogJ3JnYigyOSwgMTQwLCAxMTQpJ30sXHJcbiAgICAgICAgICAgIHt2YWx1ZTogdXNlci5jcnlzdGFsX2JsdWUsIGNvbG9yOiAncmdiKDU3LCAxMDgsIDIxOSknfSxcclxuICAgICAgICAgICAge3ZhbHVlOiB1c2VyLmNyeXN0YWxfcmVkLCBjb2xvcjogJ3JnYigxMzgsIDM0LCA3NiknfSxcclxuICAgICAgICAgICAge3ZhbHVlOiB1c2VyLmNyeXN0YWxfcHVycGxlLCBjb2xvcjogJ3JnYig4MCwgMzUsIDE1MyknfV07XHJcbiAgICAgICAgYXJyQ3J5c3RhbHMuZm9yRWFjaChwYXJhbXMgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2Zjb250YWluZXItcm93Jyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZCA9IG5ldyBEaWFtb25kKGAke3BhcmFtcy5jb2xvcn1gKS5nZXRFbGVtKCkuZWw7XHJcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChkKTtcclxuXHJcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndGV4dF9fcHJvZmlsZS1kaWFtb25kJyk7XHJcbiAgICAgICAgICAgIGVsZW0uaW5uZXJUZXh0ID0gYCR7cGFyYW1zLnZhbHVlfWA7XHJcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgICAgICAgICAgcmVzb3VyY2VzRGl2LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHByb2ZpbGUuYXBwZW5kQ2hpbGQodXNlckRpdik7XHJcbiAgICAgICAgcHJvZmlsZS5hcHBlbmRDaGlsZChyZXNvdXJjZXNEaXYpO1xyXG4gICAgICAgIHByb2ZpbGUuYXBwZW5kQ2hpbGQoY29udHJvbGxlcnNEaXYpO1xyXG5cclxuICAgICAgICBsZXQgaHJlZkxvZ291dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICBocmVmTG9nb3V0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncm91dGVyIGxpbmtfX2xvZ291dCcpO1xyXG4gICAgICAgIGhyZWZMb2dvdXQuc2V0QXR0cmlidXRlKCdpZCcsICdidG4tbG9nb3V0Jyk7XHJcbiAgICAgICAgaHJlZkxvZ291dC5pbm5lclRleHQgPSAnTG9nIG91dCc7XHJcbiAgICAgICAgcHJvZmlsZS5hcHBlbmRDaGlsZChocmVmTG9nb3V0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGU7XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy92aWV3cy9tZW51L1Byb2ZpbGVWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTkuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCYXNlVmlldyBmcm9tICcuLi9CYXNlVmlldyc7XHJcbmltcG9ydCBGb3JtIGZyb20gXCIuLi8uLi9tZW51L2VsZW1lbnRzL0Zvcm1cIjtcclxuaW1wb3J0IFByb2dyZXNzQmFyIGZyb20gXCIuLi8uLi9tZW51L2VsZW1lbnRzL1Byb2dyZXNzQmFyXCI7XHJcbmltcG9ydCBDaGVja0ZpZWxkcyBmcm9tIFwiLi4vLi4vbWVudS9hY3Rpb25zL0NoZWNrRmllbGRzXCI7XHJcbmltcG9ydCBJemlUb2FzdCBmcm9tICdpeml0b2FzdCc7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vc3VwcG9ydC9zZXJ2aWNlL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBSb3V0ZXJVcmxzIGZyb20gXCIuLi8uLi9zdXBwb3J0L3JvdXRlci9Sb3V0ZXJVcmxzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaWduVXBWaWV3IGV4dGVuZHMgQmFzZVZpZXd7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlKXtcclxuICAgICAgICBzdXBlcihub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMucm91dGVyID0gd2luZG93LnJvdXRlcjtcclxuICAgICAgICB0aGlzLl9zaG93Vmlld1Byb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuc2lnbnVwRm9ybSA9IG5ldyBGb3JtKHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnU2lnbiB1cCcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICd0ZXh0LWNlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZvcm06IHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zjb250YWluZXItY29sdW1uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ0xvZ2luJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnci1sb2dpbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2lucHV0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsb2dpbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogJ2xvZ2luJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwX2F0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3ItbG9naW4taGVscCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3BfX2Vycm9yJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1Bhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnci1wYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2lucHV0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGFzc3dvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6ICdwYXNzd29yZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscF9hdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyLXBhc3N3b3JkLWhlbHAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdwX19lcnJvcidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdSZXBlYXQgcGFzc3dvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyLXJlcGVhdHBhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnaW5wdXQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZXBlYXRwYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogJ3JlcGVhdHBhc3N3b3JkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwX2F0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3ItcmVwZWF0cGFzc3dvcmQtaGVscCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3BfX2Vycm9yJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnUmVnaXN0cmF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3VibWl0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnYnRuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYnRuLXNpZ251cCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2J1dHRvbidcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0xvZyBJbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2xpbmsgcm91dGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYnRuLXRvLWxvZ2luJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHdpbmRvdy5MT0dJTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5nZXRFbGVtKCk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLl9oaWRlVmlld1Byb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLnNpZ251cEZvcm0uZWwpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sb2dpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyLWxvZ2luJyk7XHJcbiAgICAgICAgICAgIHRoaXMucGFzc3dvcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnci1wYXNzd29yZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdFBhc3N3b3JkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ItcmVwZWF0cGFzc3dvcmQnKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9naW5IZWxwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ItbG9naW4taGVscCcpO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkSGVscCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyLXBhc3N3b3JkLWhlbHAnKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRQYXNzd29yZEhlbHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnci1yZXBlYXRwYXNzd29yZC1oZWxwJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ0blNpZ25VcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG4tc2lnbnVwJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ0blRvTG9naW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLXRvLWxvZ2luJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRMaXN0ZW5lcigpO1xyXG4gICAgICAgIH0sIDUwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9C+0LrQsNC30LDRgtGMINC/0YDQvtCz0YDQtdGB0YEg0LHQsNGAINCy0YzRjtGI0LrQuFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3Nob3dWaWV3UHJvZ3Jlc3NCYXIoKSB7XHJcbiAgICAgICAgbGV0IHByb2dyZXNzQmFyID0gbmV3IFByb2dyZXNzQmFyKCkuZ2V0RWxlbSgpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChwcm9ncmVzc0Jhcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQodC/0YDRj9GC0LDRgtGMINC/0YDQvtCz0YDQtdGB0YEg0LHQsNGAINCy0YzRjtGI0LrQuFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2hpZGVWaWV3UHJvZ3Jlc3NCYXIoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J/QvtC60LDQt9Cw0YLRjCDQv9GA0L7Qs9GA0LXRgdGBINCx0LDRgCDRhNC+0YDQvNGLXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc2hvd1Byb2dyZXNzQmFyKCkge1xyXG4gICAgICAgIHRoaXMuYnRuU2lnblVwLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgbGV0IHByb2dyZXNzQmFyID0gbmV3IFByb2dyZXNzQmFyKCkuZ2V0RWxlbSgpO1xyXG4gICAgICAgIHRoaXMuYnRuU2lnblVwLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHByb2dyZXNzQmFyLCB0aGlzLmJ0blNpZ25VcC5uZXh0U2libGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQodC/0YDRj9GC0LDRgtGMINC/0YDQvtCz0YDQtdGB0YEg0LHQsNGAINGE0L7RgNC80YtcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9oaWRlUHJvZ3Jlc3NCYXIoKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuU2lnblVwLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJ0blNpZ25VcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYnRuU2lnblVwLm5leHRFbGVtZW50U2libGluZyk7XHJcbiAgICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCX0LDQv9GD0YHQuiDRgdC70YPRiNCw0YLQtdC70LXQuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2luaXRMaXN0ZW5lcigpIHtcclxuICAgICAgICAvL1N1Ym1pdCBmb3JtXHJcbiAgICAgICAgdGhpcy5zaWdudXBGb3JtLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja0ZpZWxkcygpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHRoaXMuc2lnbnVwRm9ybS5nZXRGb3JtRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Byb2dyZXNzQmFyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3IFVzZXJTZXJ2aWNlKCkuc2lnbnVwKGJvZHkpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyRmllbGRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZVByb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgSXppVG9hc3Quc3VjY2Vzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnU3VjY2Vzc2Z1bGx5IHJlZ2lzdHJhdGVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICd0b3BSaWdodCdcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5fc2V0Q3VyclZpZXcod2luZG93LkxPR0lOKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRSZW1vdmVPayh0aGlzLmxvZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICBDaGVja0ZpZWxkcy5maWVsZFNldEVycih0aGlzLmxvZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihlcnIucmVzdWx0ID09PSAnbm8tY29ubicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDaGVja0ZpZWxkcy5oZWxwU2V0VGV4dCh0aGlzLmxvZ2luSGVscCwgJ2NoZWNrIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDaGVja0ZpZWxkcy5oZWxwU2V0VGV4dCh0aGlzLmxvZ2luSGVscCwgJ2xvZ2luIHVzZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZVByb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmJ0blRvTG9naW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudD0+e1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhckZpZWxkcygpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9GA0L7QstC10YDQutCwINC/0L7Qu9C10Lkg0YTQvtGA0LzRi1xyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jaGVja0ZpZWxkcygpIHtcclxuICAgICAgICBsZXQgY2hlY2sgPSB0cnVlO1xyXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5zaWdudXBGb3JtLmZpZWxkcy5mb3JFYWNoKGVsZW0gPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZWxlbS52YWxpZGF0ZShwcmV2KTtcclxuICAgICAgICAgICAgcHJldiA9IGVsZW07XHJcbiAgICAgICAgICAgIGlmIChjaGVjayA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2sgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoZWNrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J7RgtGH0LjRgdGC0LrQsCDQv9C+0LvQtdC5INGE0L7RgNC80YtcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jbGVhckZpZWxkcygpIHtcclxuICAgICAgICB0aGlzLnNpZ251cEZvcm0uZmllbGRzLmZvckVhY2goZWxlbSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW0uY2xlYXIoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL3ZpZXdzL21lbnUvU2lnblVwVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRocmVlanMub3JnL2xpY2Vuc2VcclxuKGZ1bmN0aW9uIChsLCBwYSkge1xyXG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG1vZHVsZSA/IHBhKGV4cG9ydHMpIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgcGEpIDogcGEobC5USFJFRSA9IGwuVEhSRUUgfHwge30pXHJcbn0pKHRoaXMsIGZ1bmN0aW9uIChsKSB7XHJcbiAgICBmdW5jdGlvbiBwYSgpIHtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBEKGEsIGIpIHtcclxuICAgICAgICB0aGlzLnggPSBhIHx8IDA7XHJcbiAgICAgICAgdGhpcy55ID0gYiB8fCAwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZWEoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgbSwgaykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHt2YWx1ZTogWmUrK30pO1xyXG4gICAgICAgIHRoaXMudXVpZCA9IE4uZ2VuZXJhdGVVVUlEKCk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcclxuICAgICAgICB0aGlzLmltYWdlID0gdm9pZCAwICE9PSBhID8gYSA6IGVhLkRFRkFVTFRfSU1BR0U7XHJcbiAgICAgICAgdGhpcy5taXBtYXBzID0gW107XHJcbiAgICAgICAgdGhpcy5tYXBwaW5nID0gdm9pZCAwICE9PSBiID8gYiA6IGVhLkRFRkFVTFRfTUFQUElORztcclxuICAgICAgICB0aGlzLndyYXBTID0gdm9pZCAwICE9PSBjID8gYyA6IDEwMDE7XHJcbiAgICAgICAgdGhpcy53cmFwVCA9XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gZCA/IGQgOiAxMDAxO1xyXG4gICAgICAgIHRoaXMubWFnRmlsdGVyID0gdm9pZCAwICE9PSBlID8gZSA6IDEwMDY7XHJcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSB2b2lkIDAgIT09IGYgPyBmIDogMTAwODtcclxuICAgICAgICB0aGlzLmFuaXNvdHJvcHkgPSB2b2lkIDAgIT09IG0gPyBtIDogMTtcclxuICAgICAgICB0aGlzLmZvcm1hdCA9IHZvaWQgMCAhPT0gZyA/IGcgOiAxMDIzO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHZvaWQgMCAhPT0gaCA/IGggOiAxMDA5O1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gbmV3IEQoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5yZXBlYXQgPSBuZXcgRCgxLCAxKTtcclxuICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9ICEwO1xyXG4gICAgICAgIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9ICExO1xyXG4gICAgICAgIHRoaXMuZmxpcFkgPSAhMDtcclxuICAgICAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7XHJcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IHZvaWQgMCAhPT0gayA/IGsgOiAzRTM7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMDtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZhKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICB0aGlzLnggPSBhIHx8IDA7XHJcbiAgICAgICAgdGhpcy55ID0gYiB8fCAwO1xyXG4gICAgICAgIHRoaXMueiA9IGMgfHwgMDtcclxuICAgICAgICB0aGlzLncgPSB2b2lkIDAgIT09IGQgPyBkIDogMVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFlhKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLnV1aWQgPSBOLmdlbmVyYXRlVVVJRCgpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPVxyXG4gICAgICAgICAgICBhO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYjtcclxuICAgICAgICB0aGlzLnNjaXNzb3IgPSBuZXcgZmEoMCwgMCwgYSwgYik7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yVGVzdCA9ICExO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBuZXcgZmEoMCwgMCwgYSwgYik7XHJcbiAgICAgICAgYyA9IGMgfHwge307XHJcbiAgICAgICAgdm9pZCAwID09PSBjLm1pbkZpbHRlciAmJiAoYy5taW5GaWx0ZXIgPSAxMDA2KTtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBuZXcgZWEodm9pZCAwLCB2b2lkIDAsIGMud3JhcFMsIGMud3JhcFQsIGMubWFnRmlsdGVyLCBjLm1pbkZpbHRlciwgYy5mb3JtYXQsIGMudHlwZSwgYy5hbmlzb3Ryb3B5LCBjLmVuY29kaW5nKTtcclxuICAgICAgICB0aGlzLmRlcHRoQnVmZmVyID0gdm9pZCAwICE9PSBjLmRlcHRoQnVmZmVyID8gYy5kZXB0aEJ1ZmZlciA6ICEwO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHZvaWQgMCAhPT0gYy5zdGVuY2lsQnVmZmVyID8gYy5zdGVuY2lsQnVmZmVyIDogITA7XHJcbiAgICAgICAgdGhpcy5kZXB0aFRleHR1cmUgPSB2b2lkIDAgIT09IGMuZGVwdGhUZXh0dXJlID8gYy5kZXB0aFRleHR1cmUgOiBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gR2IoYSwgYiwgYykge1xyXG4gICAgICAgIFlhLmNhbGwodGhpcywgYSwgYiwgYyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVNaXBNYXBMZXZlbCA9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2EoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHRoaXMuX3ggPSBhIHx8IDA7XHJcbiAgICAgICAgdGhpcy5feSA9IGIgfHwgMDtcclxuICAgICAgICB0aGlzLl96ID0gYyB8fCAwO1xyXG4gICAgICAgIHRoaXMuX3cgPSB2b2lkIDAgIT09IGQgPyBkIDogMVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHEoYSwgYiwgYykge1xyXG4gICAgICAgIHRoaXMueCA9IGEgfHwgMDtcclxuICAgICAgICB0aGlzLnkgPSBiIHx8IDA7XHJcbiAgICAgICAgdGhpcy56ID0gYyB8fCAwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUygpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xyXG4gICAgICAgIDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLlwiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFphKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIG0sIGspIHtcclxuICAgICAgICBhID0gdm9pZCAwICE9PSBhID8gYSA6IFtdO1xyXG4gICAgICAgIGVhLmNhbGwodGhpcywgYSwgdm9pZCAwICE9PSBiID8gYiA6IDMwMSwgYywgZCwgZSwgZiwgZywgaCwgbSwgayk7XHJcbiAgICAgICAgdGhpcy5mbGlwWSA9ICExXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSGIoYSwgYiwgYykge1xyXG4gICAgICAgIHZhciBkID0gYVswXTtcclxuICAgICAgICBpZiAoMCA+PVxyXG4gICAgICAgICAgICBkIHx8IDAgPCBkKXJldHVybiBhO1xyXG4gICAgICAgIHZhciBlID0gYiAqIGMsIGYgPSBCZVtlXTtcclxuICAgICAgICB2b2lkIDAgPT09IGYgJiYgKGYgPSBuZXcgRmxvYXQzMkFycmF5KGUpLCBCZVtlXSA9IGYpO1xyXG4gICAgICAgIGlmICgwICE9PSBiKWZvciAoZC50b0FycmF5KGYsIDApLCBkID0gMSwgZSA9IDA7IGQgIT09IGI7ICsrZCllICs9IGMsIGFbZF0udG9BcnJheShmLCBlKTtcclxuICAgICAgICByZXR1cm4gZlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIENlKGEsIGIpIHtcclxuICAgICAgICB2YXIgYyA9IERlW2JdO1xyXG4gICAgICAgIHZvaWQgMCA9PT0gYyAmJiAoYyA9IG5ldyBJbnQzMkFycmF5KGIpLCBEZVtiXSA9IGMpO1xyXG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkICE9PSBiOyArK2QpY1tkXSA9IGEuYWxsb2NUZXh0dXJlVW5pdCgpO1xyXG4gICAgICAgIHJldHVybiBjXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gJGUoYSwgYikge1xyXG4gICAgICAgIGEudW5pZm9ybTFmKHRoaXMuYWRkciwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZihhLCBiKSB7XHJcbiAgICAgICAgYS51bmlmb3JtMWkodGhpcy5hZGRyLCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJmKGEsIGIpIHtcclxuICAgICAgICB2b2lkIDAgPT09IGIueCA/IGEudW5pZm9ybTJmdih0aGlzLmFkZHIsIGIpIDogYS51bmlmb3JtMmYodGhpcy5hZGRyLCBiLngsIGIueSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjZihhLCBiKSB7XHJcbiAgICAgICAgdm9pZCAwICE9PSBiLnggPyBhLnVuaWZvcm0zZih0aGlzLmFkZHIsXHJcbiAgICAgICAgICAgIGIueCwgYi55LCBiLnopIDogdm9pZCAwICE9PSBiLnIgPyBhLnVuaWZvcm0zZih0aGlzLmFkZHIsIGIuciwgYi5nLCBiLmIpIDogYS51bmlmb3JtM2Z2KHRoaXMuYWRkciwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZihhLCBiKSB7XHJcbiAgICAgICAgdm9pZCAwID09PSBiLnggPyBhLnVuaWZvcm00ZnYodGhpcy5hZGRyLCBiKSA6IGEudW5pZm9ybTRmKHRoaXMuYWRkciwgYi54LCBiLnksIGIueiwgYi53KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVmKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCAhMSwgYi5lbGVtZW50cyB8fCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZmKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm1NYXRyaXgzZnYodGhpcy5hZGRyLCAhMSwgYi5lbGVtZW50cyB8fCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdmKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCAhMSwgYi5lbGVtZW50cyB8fCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhmKGEsIGIsIGMpIHtcclxuICAgICAgICB2YXIgZCA9IGMuYWxsb2NUZXh0dXJlVW5pdCgpO1xyXG4gICAgICAgIGEudW5pZm9ybTFpKHRoaXMuYWRkciwgZCk7XHJcbiAgICAgICAgYy5zZXRUZXh0dXJlMkQoYiB8fCBFZSwgZClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBqZihhLCBiLCBjKSB7XHJcbiAgICAgICAgdmFyIGQgPSBjLmFsbG9jVGV4dHVyZVVuaXQoKTtcclxuICAgICAgICBhLnVuaWZvcm0xaSh0aGlzLmFkZHIsIGQpO1xyXG4gICAgICAgIGMuc2V0VGV4dHVyZUN1YmUoYiB8fCBGZSwgZClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHZShhLCBiKSB7XHJcbiAgICAgICAgYS51bmlmb3JtMml2KHRoaXMuYWRkciwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBIZShhLCBiKSB7XHJcbiAgICAgICAgYS51bmlmb3JtM2l2KHRoaXMuYWRkciwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJZShhLCBiKSB7XHJcbiAgICAgICAgYS51bmlmb3JtNGl2KHRoaXMuYWRkciwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZihhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhKSB7XHJcbiAgICAgICAgICAgIGNhc2UgNTEyNjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAkZTtcclxuICAgICAgICAgICAgY2FzZSAzNTY2NDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBiZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY2NTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY2NjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3NDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBlZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3NTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3NjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3ODpcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY4MDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqZjtcclxuICAgICAgICAgICAgY2FzZSA1MTI0OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjcwOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmO1xyXG4gICAgICAgICAgICBjYXNlIDM1NjY3OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjcxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdlO1xyXG4gICAgICAgICAgICBjYXNlIDM1NjY4OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjcyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlO1xyXG4gICAgICAgICAgICBjYXNlIDM1NjY5OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjczOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEllXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxmKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm0xZnYodGhpcy5hZGRyLCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1mKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm0xaXYodGhpcy5hZGRyLCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5mKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm0yZnYodGhpcy5hZGRyLCBIYihiLCB0aGlzLnNpemUsIDIpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9mKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm0zZnYodGhpcy5hZGRyLCBIYihiLCB0aGlzLnNpemUsIDMpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBmKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm00ZnYodGhpcy5hZGRyLCBIYihiLCB0aGlzLnNpemUsIDQpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHFmKGEsIGIpIHtcclxuICAgICAgICBhLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCAhMSwgSGIoYiwgdGhpcy5zaXplLCA0KSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZihhLCBiKSB7XHJcbiAgICAgICAgYS51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgITEsIEhiKGIsIHRoaXMuc2l6ZSwgOSkpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2YoYSwgYikge1xyXG4gICAgICAgIGEudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsICExLCBIYihiLCB0aGlzLnNpemUsIDE2KSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZihhLCBiLCBjKSB7XHJcbiAgICAgICAgdmFyIGQgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgZSA9IENlKGMsIGQpO1xyXG4gICAgICAgIGEudW5pZm9ybTFpdih0aGlzLmFkZHIsIGUpO1xyXG4gICAgICAgIGZvciAoYSA9IDA7IGEgIT09IGQ7ICsrYSljLnNldFRleHR1cmUyRChiW2FdIHx8IEVlLCBlW2FdKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVmKGEsIGIsIGMpIHtcclxuICAgICAgICB2YXIgZCA9IGIubGVuZ3RoLCBlID0gQ2UoYywgZCk7XHJcbiAgICAgICAgYS51bmlmb3JtMWl2KHRoaXMuYWRkciwgZSk7XHJcbiAgICAgICAgZm9yIChhID0gMDsgYSAhPT0gZDsgKythKWMuc2V0VGV4dHVyZUN1YmUoYlthXSB8fCBGZSwgZVthXSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2ZihhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhKSB7XHJcbiAgICAgICAgICAgIGNhc2UgNTEyNjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY2NDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY2NTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY2NjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3NDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBxZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3NTpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3NjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY3ODpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZjtcclxuICAgICAgICAgICAgY2FzZSAzNTY4MDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1ZjtcclxuICAgICAgICAgICAgY2FzZSA1MTI0OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjcwOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1mO1xyXG4gICAgICAgICAgICBjYXNlIDM1NjY3OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjcxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdlO1xyXG4gICAgICAgICAgICBjYXNlIDM1NjY4OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjcyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlO1xyXG4gICAgICAgICAgICBjYXNlIDM1NjY5OlxyXG4gICAgICAgICAgICBjYXNlIDM1NjczOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEllXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHdmKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLmlkID0gYTtcclxuICAgICAgICB0aGlzLmFkZHIgPSBjO1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWUgPSBrZihiLnR5cGUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geGYoYSwgYiwgYykge1xyXG4gICAgICAgIHRoaXMuaWQgPSBhO1xyXG4gICAgICAgIHRoaXMuYWRkciA9IGM7XHJcbiAgICAgICAgdGhpcy5zaXplID0gYi5zaXplO1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWUgPSB2ZihiLnR5cGUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSmUoYSkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBhO1xyXG4gICAgICAgIHRoaXMuc2VxID0gW107XHJcbiAgICAgICAgdGhpcy5tYXAgPSB7fVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uICRhKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLnNlcSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWFwID0ge307XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IGM7XHJcbiAgICAgICAgYyA9IGEuZ2V0UHJvZ3JhbVBhcmFtZXRlcihiLCBhLkFDVElWRV9VTklGT1JNUyk7XHJcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBjOyArK2QpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSBhLmdldEFjdGl2ZVVuaWZvcm0oYiwgZCksIGYgPSBhLmdldFVuaWZvcm1Mb2NhdGlvbihiLCBlLm5hbWUpLCBnID0gdGhpcywgaCA9IGUubmFtZSwgbSA9IGgubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKFJkLmxhc3RJbmRleCA9IDA7IDspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gUmQuZXhlYyhoKSwgdCA9IFJkLmxhc3RJbmRleCwgcCA9XHJcbiAgICAgICAgICAgICAgICAgICAga1sxXSwgbiA9IGtbM107XHJcbiAgICAgICAgICAgICAgICBcIl1cIiA9PT0ga1syXSAmJiAocCB8PSAwKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IG4gfHwgXCJbXCIgPT09IG4gJiYgdCArIDIgPT09IG0pIHtcclxuICAgICAgICAgICAgICAgICAgICBoID0gZztcclxuICAgICAgICAgICAgICAgICAgICBlID0gdm9pZCAwID09PSBuID8gbmV3IHdmKHAsIGUsIGYpIDogbmV3IHhmKHAsIGUsIGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGguc2VxLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaC5tYXBbZS5pZF0gPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgbiA9IGcubWFwW3BdLCB2b2lkIDAgPT09IG4gJiYgKG4gPSBuZXcgSmUocCksIHAgPSBnLCBnID0gbiwgcC5zZXEucHVzaChnKSwgcC5tYXBbZy5pZF0gPSBnKSwgZyA9IG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBKKGEsIGIsIGMpIHtcclxuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBiICYmIHZvaWQgMCA9PT0gYyA/IHRoaXMuc2V0KGEpIDogdGhpcy5zZXRSR0IoYSwgYiwgYylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlYihhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBtLCBrLCB0LCBwKSB7XHJcbiAgICAgICAgZWEuY2FsbCh0aGlzLCBudWxsLCBmLCBnLCBoLCBtLCBrLCBkLCBlLCB0LCBwKTtcclxuICAgICAgICB0aGlzLmltYWdlID0ge2RhdGE6IGEsIHdpZHRoOiBiLCBoZWlnaHQ6IGN9O1xyXG4gICAgICAgIHRoaXMubWFnRmlsdGVyID0gdm9pZCAwICE9PSBtID8gbSA6IDEwMDM7XHJcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSB2b2lkIDAgIT09IGsgPyBrIDogMTAwMztcclxuICAgICAgICB0aGlzLmZsaXBZID0gdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPVxyXG4gICAgICAgICAgICAhMTtcclxuICAgICAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IDFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYyhhLCBiKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSB2b2lkIDAgIT09IGEgPyBhIDogbmV3IEQoSW5maW5pdHksIEluZmluaXR5KTtcclxuICAgICAgICB0aGlzLm1heCA9IHZvaWQgMCAhPT0gYiA/IGIgOiBuZXcgRCgtSW5maW5pdHksIC1JbmZpbml0eSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB5ZihhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMsIGQsIGUsIGYsIGcsIGgsIG0sIGssIHQsIHAsIG4gPSBhLmNvbnRleHQsIHUgPSBhLnN0YXRlLCBsLCByLCBBLCB3LCB5LCBLO1xyXG4gICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKHYsIEUsIEwpIHtcclxuICAgICAgICAgICAgaWYgKDAgIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2ID0gbmV3IHE7XHJcbiAgICAgICAgICAgICAgICB2YXIgQyA9IEwudyAvIEwueiwgRiA9IC41ICogTC56LCBkYSA9IC41ICogTC53LCBIID0gMTYgLyBMLncsIGFhID0gbmV3IEQoSCAqIEMsIEgpLCBEYSA9IG5ldyBxKDEsIDEsIDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGZiID0gbmV3IEQoMSwgMSksIFNkID0gbmV3IHNjO1xyXG4gICAgICAgICAgICAgICAgU2QubWluLnNldChMLngsIEwueSk7XHJcbiAgICAgICAgICAgICAgICBTZC5tYXguc2V0KEwueCArIChMLnogLSAxNiksIEwueSArIChMLncgLSAxNikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBIID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAwLCAwLCAxLCAtMSwgMSwgMCwgMSwgMSwgMSwgMSwgLTEsIDEsIDAsIDFdKSwgUSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGwgPSBuLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBuLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4uYmluZEJ1ZmZlcihuLkFSUkFZX0JVRkZFUiwgbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5idWZmZXJEYXRhKG4uQVJSQVlfQlVGRkVSLCBILCBuLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICAgICAgICAgICAgICBuLmJpbmRCdWZmZXIobi5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5idWZmZXJEYXRhKG4uRUxFTUVOVF9BUlJBWV9CVUZGRVIsIFEsIG4uU1RBVElDX0RSQVcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBuLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBLID0gbi5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdS5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsIDAsIG4uUkdCLCAxNiwgMTYsIDAsIG4uUkdCLCBuLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsIG4uVEVYVFVSRV9XUkFQX1MsIG4uQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCwgbi5URVhUVVJFX1dSQVBfVCwgbi5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELCBuLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbi5ORUFSRVNUKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELCBuLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbi5ORUFSRVNUKTtcclxuICAgICAgICAgICAgICAgICAgICB1LmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCwgSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi50ZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCwgMCwgbi5SR0JBLCAxNiwgMTYsIDAsIG4uUkdCQSwgbi5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELCBuLlRFWFRVUkVfV1JBUF9TLCBuLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsIG4uVEVYVFVSRV9XUkFQX1QsIG4uQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCwgbi5URVhUVVJFX01BR19GSUxURVIsIG4uTkVBUkVTVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCwgbi5URVhUVVJFX01JTl9GSUxURVIsIG4uTkVBUkVTVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIEggPSBBID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcXG51bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XFxudW5pZm9ybSB2ZWMyIHNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgcm90YXRpb247XFxudW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcXG52b2lkIG1haW4oKSB7XFxudlVWID0gdXY7XFxudmVjMiBwb3MgPSBwb3NpdGlvbjtcXG5pZiAoIHJlbmRlclR5cGUgPT0gMiApIHtcXG52ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XFxudlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1xcbnZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcXG52VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XFxudlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1xcbnBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XFxucG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcXG59XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XFxufVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcXG52b2lkIG1haW4oKSB7XFxuaWYgKCByZW5kZXJUeXBlID09IDAgKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7XFxufSBlbHNlIGlmICggcmVuZGVyVHlwZSA9PSAxICkge1xcbmdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcXG59IGVsc2Uge1xcbnZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcXG50ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1xcbmdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XFxuZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcXG59XFxufVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFEgPSBuLmNyZWF0ZVByb2dyYW0oKSwgTSA9IG4uY3JlYXRlU2hhZGVyKG4uRlJBR01FTlRfU0hBREVSKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTyA9IG4uY3JlYXRlU2hhZGVyKG4uVkVSVEVYX1NIQURFUiksIFAgPSBcInByZWNpc2lvbiBcIiArIGEuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcclxuICAgICAgICAgICAgICAgICAgICBuLnNoYWRlclNvdXJjZShNLCBQICsgSC5mcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zaGFkZXJTb3VyY2UoTywgUCArIEgudmVydGV4U2hhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBuLmNvbXBpbGVTaGFkZXIoTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5jb21waWxlU2hhZGVyKE8pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4uYXR0YWNoU2hhZGVyKFEsIE0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4uYXR0YWNoU2hhZGVyKFEsIE8pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4ubGlua1Byb2dyYW0oUSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IFE7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IG4uZ2V0QXR0cmliTG9jYXRpb24odywgXCJwb3NpdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICBwID0gbi5nZXRBdHRyaWJMb2NhdGlvbih3LCBcInV2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBuLmdldFVuaWZvcm1Mb2NhdGlvbih3LCBcInJlbmRlclR5cGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IG4uZ2V0VW5pZm9ybUxvY2F0aW9uKHcsIFwibWFwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBuLmdldFVuaWZvcm1Mb2NhdGlvbih3LCBcIm9jY2x1c2lvbk1hcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBmID0gbi5nZXRVbmlmb3JtTG9jYXRpb24odywgXCJvcGFjaXR5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBuLmdldFVuaWZvcm1Mb2NhdGlvbih3LCBcImNvbG9yXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSBuLmdldFVuaWZvcm1Mb2NhdGlvbih3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNjYWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBuLmdldFVuaWZvcm1Mb2NhdGlvbih3LCBcInJvdGF0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSBuLmdldFVuaWZvcm1Mb2NhdGlvbih3LCBcInNjcmVlblBvc2l0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuLnVzZVByb2dyYW0odyk7XHJcbiAgICAgICAgICAgICAgICB1LmluaXRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgICAgICAgICB1LmVuYWJsZUF0dHJpYnV0ZSh0KTtcclxuICAgICAgICAgICAgICAgIHUuZW5hYmxlQXR0cmlidXRlKHApO1xyXG4gICAgICAgICAgICAgICAgdS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG4gICAgICAgICAgICAgICAgbi51bmlmb3JtMWkoZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBuLnVuaWZvcm0xaShkLCAxKTtcclxuICAgICAgICAgICAgICAgIG4uYmluZEJ1ZmZlcihuLkFSUkFZX0JVRkZFUiwgbCk7XHJcbiAgICAgICAgICAgICAgICBuLnZlcnRleEF0dHJpYlBvaW50ZXIodCwgMiwgbi5GTE9BVCwgITEsIDE2LCAwKTtcclxuICAgICAgICAgICAgICAgIG4udmVydGV4QXR0cmliUG9pbnRlcihwLCAyLCBuLkZMT0FULCAhMSwgMTYsIDgpO1xyXG4gICAgICAgICAgICAgICAgbi5iaW5kQnVmZmVyKG4uRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHIpO1xyXG4gICAgICAgICAgICAgICAgdS5kaXNhYmxlKG4uQ1VMTF9GQUNFKTtcclxuICAgICAgICAgICAgICAgIHUuc2V0RGVwdGhXcml0ZSghMSk7XHJcbiAgICAgICAgICAgICAgICBRID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoTSA9IGIubGVuZ3RoOyBRIDwgTTsgUSsrKWlmIChIID0gMTYgLyBMLncsIGFhLnNldChIICogQywgSCksIE8gPSBiW1FdLCB2LnNldChPLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTy5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sIE8ubWF0cml4V29ybGQuZWxlbWVudHNbMTRdKSwgdi5hcHBseU1hdHJpeDQoRS5tYXRyaXhXb3JsZEludmVyc2UpLCB2LmFwcGx5TWF0cml4NChFLnByb2plY3Rpb25NYXRyaXgpLCBEYS5jb3B5KHYpLCBmYi54ID0gTC54ICsgRGEueCAqIEYgKyBGIC0gOCwgZmIueSA9IEwueSArIERhLnkgKiBkYSArIGRhIC0gOCwgITAgPT09IFNkLmNvbnRhaW5zUG9pbnQoZmIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdS5hY3RpdmVUZXh0dXJlKG4uVEVYVFVSRTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuYmluZFRleHR1cmUobi5URVhUVVJFXzJELCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB1LmFjdGl2ZVRleHR1cmUobi5URVhUVVJFMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdS5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4uY29weVRleEltYWdlMkQobi5URVhUVVJFXzJELCAwLCBuLlJHQiwgZmIueCwgZmIueSwgMTYsIDE2LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnVuaWZvcm0xaShjLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnVuaWZvcm0yZihoLCBhYS54LCBhYS55KTtcclxuICAgICAgICAgICAgICAgICAgICBuLnVuaWZvcm0zZihrLCBEYS54LCBEYS55LCBEYS56KTtcclxuICAgICAgICAgICAgICAgICAgICB1LmRpc2FibGUobi5CTEVORCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdS5lbmFibGUobi5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgICAgICAgICBuLmRyYXdFbGVtZW50cyhuLlRSSUFOR0xFUyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNiwgbi5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdS5hY3RpdmVUZXh0dXJlKG4uVEVYVFVSRTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuYmluZFRleHR1cmUobi5URVhUVVJFXzJELCBLKTtcclxuICAgICAgICAgICAgICAgICAgICBuLmNvcHlUZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCwgMCwgbi5SR0JBLCBmYi54LCBmYi55LCAxNiwgMTYsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIG4udW5pZm9ybTFpKGMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuZGlzYWJsZShuLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuYWN0aXZlVGV4dHVyZShuLlRFWFRVUkUxKTtcclxuICAgICAgICAgICAgICAgICAgICB1LmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5kcmF3RWxlbWVudHMobi5UUklBTkdMRVMsIDYsIG4uVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIE8ucG9zaXRpb25TY3JlZW4uY29weShEYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTy5jdXN0b21VcGRhdGVDYWxsYmFjayA/IE8uY3VzdG9tVXBkYXRlQ2FsbGJhY2soTykgOiBPLnVwZGF0ZUxlbnNGbGFyZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnVuaWZvcm0xaShjLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB1LmVuYWJsZShuLkJMRU5EKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBQID0gMCwgd2EgPSBPLmxlbnNGbGFyZXMubGVuZ3RoOyBQIDwgd2E7IFArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgVyA9IE8ubGVuc0ZsYXJlc1tQXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLjAwMSA8IFcub3BhY2l0eSAmJiAuMDAxIDxcclxuICAgICAgICAgICAgICAgICAgICAgICAgVy5zY2FsZSAmJiAoRGEueCA9IFcueCwgRGEueSA9IFcueSwgRGEueiA9IFcueiwgSCA9IFcuc2l6ZSAqIFcuc2NhbGUgLyBMLncsIGFhLnggPSBIICogQywgYWEueSA9IEgsIG4udW5pZm9ybTNmKGssIERhLngsIERhLnksIERhLnopLCBuLnVuaWZvcm0yZihoLCBhYS54LCBhYS55KSwgbi51bmlmb3JtMWYobSwgVy5yb3RhdGlvbiksIG4udW5pZm9ybTFmKGYsIFcub3BhY2l0eSksIG4udW5pZm9ybTNmKGcsIFcuY29sb3IuciwgVy5jb2xvci5nLCBXLmNvbG9yLmIpLCB1LnNldEJsZW5kaW5nKFcuYmxlbmRpbmcsIFcuYmxlbmRFcXVhdGlvbiwgVy5ibGVuZFNyYywgVy5ibGVuZERzdCksIGEuc2V0VGV4dHVyZTJEKFcudGV4dHVyZSwgMSksIG4uZHJhd0VsZW1lbnRzKG4uVFJJQU5HTEVTLCA2LCBuLlVOU0lHTkVEX1NIT1JULCAwKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1LmVuYWJsZShuLkNVTExfRkFDRSk7XHJcbiAgICAgICAgICAgICAgICB1LmVuYWJsZShuLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgICAgICAgICAgdS5zZXREZXB0aFdyaXRlKCEwKTtcclxuICAgICAgICAgICAgICAgIGEucmVzZXRHTFN0YXRlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB6ZihhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMsIGQsIGUsIGYsIGcsIGgsIG0sIGssIHQsIHAsIG4sIHUsIGwsIHIsXHJcbiAgICAgICAgICAgIEEsIHcsIHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEsoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciA/IGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyIDogYS56ICE9PSBiLnogPyBiLnogLSBhLnogOiBiLmlkIC0gYS5pZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHYgPSBhLmNvbnRleHQsIEUgPSBhLnN0YXRlLCBMLCBDLCBGLCBkYSwgSCA9IG5ldyBxLCBhYSA9IG5ldyBjYSwgRGEgPSBuZXcgcTtcclxuICAgICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChxLCBEKSB7XHJcbiAgICAgICAgICAgIGlmICgwICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gRikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBRID0gbmV3IEZsb2F0MzJBcnJheShbLS41LCAtLjUsIDAsIDAsIC41LCAtLjUsIDEsIDAsIC41LCAuNSwgMSwgMSwgLS41LCAuNSwgMCwgMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTCA9IHYuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQyA9IHYuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5iaW5kQnVmZmVyKHYuQVJSQVlfQlVGRkVSLCBMKTtcclxuICAgICAgICAgICAgICAgICAgICB2LmJ1ZmZlckRhdGEodi5BUlJBWV9CVUZGRVIsIFEsIHYuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYmluZEJ1ZmZlcih2LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBDKTtcclxuICAgICAgICAgICAgICAgICAgICB2LmJ1ZmZlckRhdGEodi5FTEVNRU5UX0FSUkFZX0JVRkZFUixcclxuICAgICAgICAgICAgICAgICAgICAgICAgTSwgdi5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIFEgPSB2LmNyZWF0ZVByb2dyYW0oKSwgTSA9IHYuY3JlYXRlU2hhZGVyKHYuVkVSVEVYX1NIQURFUiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE8gPSB2LmNyZWF0ZVNoYWRlcih2LkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5zaGFkZXJTb3VyY2UoTSwgW1wicHJlY2lzaW9uIFwiICsgYS5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1wiLCBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcXG51bmlmb3JtIHZlYzIgc2NhbGU7XFxudW5pZm9ybSB2ZWMyIHV2T2Zmc2V0O1xcbnVuaWZvcm0gdmVjMiB1dlNjYWxlO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudm9pZCBtYWluKCkge1xcbnZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlO1xcbnZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTtcXG52ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcXG5yb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxucm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcbnZlYzQgZmluYWxQb3NpdGlvbjtcXG5maW5hbFBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XFxuZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247XFxuZmluYWxQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBmaW5hbFBvc2l0aW9uO1xcbmdsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjtcXG59XCJdLmpvaW4oXCJcXG5cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuc2hhZGVyU291cmNlKE8sIFtcInByZWNpc2lvbiBcIiArIGEuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcIiwgXCJ1bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGludCBmb2dUeXBlO1xcbnVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG51bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxudW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcbnVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcbnVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0O1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudm9pZCBtYWluKCkge1xcbnZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcXG5pZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IgKiB0ZXh0dXJlLnh5eiwgdGV4dHVyZS5hICogb3BhY2l0eSApO1xcbmlmICggZm9nVHlwZSA+IDAgKSB7XFxuZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1xcbmZsb2F0IGZvZ0ZhY3RvciA9IDAuMDtcXG5pZiAoIGZvZ1R5cGUgPT0gMSApIHtcXG5mb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxufSBlbHNlIHtcXG5jb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7XFxuZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7XFxuZm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTtcXG59XFxuZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTtcXG59XFxufVwiXS5qb2luKFwiXFxuXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICB2LmNvbXBpbGVTaGFkZXIoTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5jb21waWxlU2hhZGVyKE8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0YWNoU2hhZGVyKFEsIE0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0YWNoU2hhZGVyKFEsIE8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHYubGlua1Byb2dyYW0oUSk7XHJcbiAgICAgICAgICAgICAgICAgICAgRiA9IFE7XHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IHYuZ2V0QXR0cmliTG9jYXRpb24oRiwgXCJwb3NpdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gdi5nZXRBdHRyaWJMb2NhdGlvbihGLCBcInV2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSB2LmdldFVuaWZvcm1Mb2NhdGlvbihGLCBcInV2T2Zmc2V0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPSB2LmdldFVuaWZvcm1Mb2NhdGlvbihGLCBcInV2U2NhbGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IHYuZ2V0VW5pZm9ybUxvY2F0aW9uKEYsIFwicm90YXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IHYuZ2V0VW5pZm9ybUxvY2F0aW9uKEYsIFwic2NhbGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IHYuZ2V0VW5pZm9ybUxvY2F0aW9uKEYsIFwiY29sb3JcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IHYuZ2V0VW5pZm9ybUxvY2F0aW9uKEYsIFwibWFwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB2LmdldFVuaWZvcm1Mb2NhdGlvbihGLCBcIm9wYWNpdHlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IHYuZ2V0VW5pZm9ybUxvY2F0aW9uKEYsIFwibW9kZWxWaWV3TWF0cml4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB2LmdldFVuaWZvcm1Mb2NhdGlvbihGLCBcInByb2plY3Rpb25NYXRyaXhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuZ2V0VW5pZm9ybUxvY2F0aW9uKEYsIFwiZm9nVHlwZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gdi5nZXRVbmlmb3JtTG9jYXRpb24oRiwgXCJmb2dEZW5zaXR5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHUgPSB2LmdldFVuaWZvcm1Mb2NhdGlvbihGLCBcImZvZ05lYXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IHYuZ2V0VW5pZm9ybUxvY2F0aW9uKEYsIFwiZm9nRmFyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSB2LmdldFVuaWZvcm1Mb2NhdGlvbihGLCBcImZvZ0NvbG9yXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIEEgPSB2LmdldFVuaWZvcm1Mb2NhdGlvbihGLCBcImFscGhhVGVzdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBRID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBRLndpZHRoID0gODtcclxuICAgICAgICAgICAgICAgICAgICBRLmhlaWdodCA9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgTSA9IFEuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIE0uZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIE0uZmlsbFJlY3QoMCwgMCwgOCwgOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGEgPSBuZXcgZWEoUSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGEubmVlZHNVcGRhdGUgPSAhMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdi51c2VQcm9ncmFtKEYpO1xyXG4gICAgICAgICAgICAgICAgRS5pbml0QXR0cmlidXRlcygpO1xyXG4gICAgICAgICAgICAgICAgRS5lbmFibGVBdHRyaWJ1dGUodyk7XHJcbiAgICAgICAgICAgICAgICBFLmVuYWJsZUF0dHJpYnV0ZSh5KTtcclxuICAgICAgICAgICAgICAgIEUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICAgICAgICAgIEUuZGlzYWJsZSh2LkNVTExfRkFDRSk7XHJcbiAgICAgICAgICAgICAgICBFLmVuYWJsZSh2LkJMRU5EKTtcclxuICAgICAgICAgICAgICAgIHYuYmluZEJ1ZmZlcih2LkFSUkFZX0JVRkZFUiwgTCk7XHJcbiAgICAgICAgICAgICAgICB2LnZlcnRleEF0dHJpYlBvaW50ZXIodywgMiwgdi5GTE9BVCwgITEsIDE2LCAwKTtcclxuICAgICAgICAgICAgICAgIHYudmVydGV4QXR0cmliUG9pbnRlcih5LCAyLCB2LkZMT0FULCAhMSwgMTYsIDgpO1xyXG4gICAgICAgICAgICAgICAgdi5iaW5kQnVmZmVyKHYuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIEMpO1xyXG4gICAgICAgICAgICAgICAgdi51bmlmb3JtTWF0cml4NGZ2KHQsICExLCBELnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgRS5hY3RpdmVUZXh0dXJlKHYuVEVYVFVSRTApO1xyXG4gICAgICAgICAgICAgICAgdi51bmlmb3JtMWkoaCwgMCk7XHJcbiAgICAgICAgICAgICAgICBNID0gUSA9IDA7XHJcbiAgICAgICAgICAgICAgICAoTyA9IHEuZm9nKSA/ICh2LnVuaWZvcm0zZihyLCBPLmNvbG9yLnIsIE8uY29sb3IuZywgTy5jb2xvci5iKSwgTy5pc0ZvZyA/ICh2LnVuaWZvcm0xZih1LCBPLm5lYXIpLCB2LnVuaWZvcm0xZihsLCBPLmZhciksIHYudW5pZm9ybTFpKHAsIDEpLCBNID0gUSA9IDEpIDogTy5pc0ZvZ0V4cDIgJiYgKHYudW5pZm9ybTFmKG4sIE8uZGVuc2l0eSksIHYudW5pZm9ybTFpKHAsIDIpLCBNID0gUSA9IDIpKSA6ICh2LnVuaWZvcm0xaShwLFxyXG4gICAgICAgICAgICAgICAgICAgIDApLCBNID0gUSA9IDApO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgTyA9IDAsIFAgPSBiLmxlbmd0aDsgTyA8IFA7IE8rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YSA9IGJbT107XHJcbiAgICAgICAgICAgICAgICAgICAgd2EubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoRC5tYXRyaXhXb3JsZEludmVyc2UsIHdhLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgICAgICB3YS56ID0gLXdhLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sxNF1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGIuc29ydChLKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIFcgPSBbXSwgTyA9IDAsIFAgPSBiLmxlbmd0aDsgTyA8IFA7IE8rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YSA9IGJbT10sIHggPSB3YS5tYXRlcmlhbDtcclxuICAgICAgICAgICAgICAgICAgICAhMSAhPT0geC52aXNpYmxlICYmICh2LnVuaWZvcm0xZihBLCB4LmFscGhhVGVzdCksIHYudW5pZm9ybU1hdHJpeDRmdihrLCAhMSwgd2EubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzKSwgd2EubWF0cml4V29ybGQuZGVjb21wb3NlKEgsIGFhLCBEYSksIFdbMF0gPSBEYS54LCBXWzFdID0gRGEueSwgd2EgPSAwLCBxLmZvZyAmJiB4LmZvZyAmJiAod2EgPSBNKSwgUSAhPT0gd2EgJiYgKHYudW5pZm9ybTFpKHAsIHdhKSwgUSA9IHdhKSwgbnVsbCAhPT0geC5tYXAgPyAodi51bmlmb3JtMmYoYywgeC5tYXAub2Zmc2V0LngsIHgubWFwLm9mZnNldC55KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi51bmlmb3JtMmYoZCwgeC5tYXAucmVwZWF0LngsIHgubWFwLnJlcGVhdC55KSkgOiAodi51bmlmb3JtMmYoYywgMCwgMCksIHYudW5pZm9ybTJmKGQsIDEsIDEpKSwgdi51bmlmb3JtMWYobSwgeC5vcGFjaXR5KSwgdi51bmlmb3JtM2YoZywgeC5jb2xvci5yLCB4LmNvbG9yLmcsIHguY29sb3IuYiksIHYudW5pZm9ybTFmKGUsIHgucm90YXRpb24pLCB2LnVuaWZvcm0yZnYoZiwgVyksIEUuc2V0QmxlbmRpbmcoeC5ibGVuZGluZywgeC5ibGVuZEVxdWF0aW9uLCB4LmJsZW5kU3JjLCB4LmJsZW5kRHN0KSwgRS5zZXREZXB0aFRlc3QoeC5kZXB0aFRlc3QpLCBFLnNldERlcHRoV3JpdGUoeC5kZXB0aFdyaXRlKSwgeC5tYXAgPyBhLnNldFRleHR1cmUyRCh4Lm1hcCwgMCkgOiBhLnNldFRleHR1cmUyRChkYSwgMCksIHYuZHJhd0VsZW1lbnRzKHYuVFJJQU5HTEVTLCA2LCB2LlVOU0lHTkVEX1NIT1JULCAwKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEUuZW5hYmxlKHYuQ1VMTF9GQUNFKTtcclxuICAgICAgICAgICAgICAgIGEucmVzZXRHTFN0YXRlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBYKCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFxyXG4gICAgICAgICAgICBcImlkXCIsIHt2YWx1ZTogQWYrK30pO1xyXG4gICAgICAgIHRoaXMudXVpZCA9IE4uZ2VuZXJhdGVVVUlEKCk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIk1hdGVyaWFsXCI7XHJcbiAgICAgICAgdGhpcy5saWdodHMgPSB0aGlzLmZvZyA9ICEwO1xyXG4gICAgICAgIHRoaXMuYmxlbmRpbmcgPSAxO1xyXG4gICAgICAgIHRoaXMuc2lkZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zaGFkaW5nID0gMjtcclxuICAgICAgICB0aGlzLnZlcnRleENvbG9ycyA9IDA7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gITE7XHJcbiAgICAgICAgdGhpcy5ibGVuZFNyYyA9IDIwNDtcclxuICAgICAgICB0aGlzLmJsZW5kRHN0ID0gMjA1O1xyXG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IDEwMDtcclxuICAgICAgICB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHRoaXMuYmxlbmREc3RBbHBoYSA9IHRoaXMuYmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSAzO1xyXG4gICAgICAgIHRoaXMuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhUZXN0ID0gITA7XHJcbiAgICAgICAgdGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jbGlwU2hhZG93cyA9IHRoaXMuY2xpcEludGVyc2VjdGlvbiA9ICExO1xyXG4gICAgICAgIHRoaXMuY29sb3JXcml0ZSA9ICEwO1xyXG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPVxyXG4gICAgICAgICAgICAhMTtcclxuICAgICAgICB0aGlzLmFscGhhVGVzdCA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcclxuICAgICAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9ICExO1xyXG4gICAgICAgIHRoaXMub3ZlcmRyYXcgPSAwO1xyXG4gICAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdGhpcy52aXNpYmxlID0gITBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBIYShhKSB7XHJcbiAgICAgICAgWC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiU2hhZGVyTWF0ZXJpYWxcIjtcclxuICAgICAgICB0aGlzLmRlZmluZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59XCI7XHJcbiAgICAgICAgdGhpcy5saW5ld2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lID0gITE7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzID1cclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMgPSB0aGlzLnNraW5uaW5nID0gdGhpcy5jbGlwcGluZyA9IHRoaXMubGlnaHRzID0gdGhpcy5mb2cgPSAhMTtcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB7ZGVyaXZhdGl2ZXM6ICExLCBmcmFnRGVwdGg6ICExLCBkcmF3QnVmZmVyczogITEsIHNoYWRlclRleHR1cmVMT0Q6ICExfTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSB7Y29sb3I6IFsxLCAxLCAxXSwgdXY6IFswLCAwXSwgdXYyOiBbMCwgMF19O1xyXG4gICAgICAgIHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHZvaWQgMDtcclxuICAgICAgICB2b2lkIDAgIT09IGEgJiYgKHZvaWQgMCAhPT0gYS5hdHRyaWJ1dGVzICYmIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC5cIiksIHRoaXMuc2V0VmFsdWVzKGEpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFiKGEpIHtcclxuICAgICAgICBYLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJNZXNoRGVwdGhNYXRlcmlhbFwiO1xyXG4gICAgICAgIHRoaXMuZGVwdGhQYWNraW5nID0gMzIwMDtcclxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9XHJcbiAgICAgICAgICAgIHRoaXMuc2tpbm5pbmcgPSAhMTtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuYWxwaGFNYXAgPSB0aGlzLm1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZSA9ICExO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuICAgICAgICB0aGlzLmxpZ2h0cyA9IHRoaXMuZm9nID0gITE7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZXMoYSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBQYShhLCBiKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSB2b2lkIDAgIT09IGEgPyBhIDogbmV3IHEoSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSk7XHJcbiAgICAgICAgdGhpcy5tYXggPSB2b2lkIDAgIT09IGIgPyBiIDogbmV3IHEoLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBOYShhLCBiKSB7XHJcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB2b2lkIDAgIT09IGEgPyBhIDogbmV3IHE7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB2b2lkIDAgIT09IGIgPyBiIDogMFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHlhKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXSk7XHJcbiAgICAgICAgMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgY29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGEoYSwgYikge1xyXG4gICAgICAgIHRoaXMubm9ybWFsID0gdm9pZCAwICE9PSBhID8gYSA6IG5ldyBxKDEsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSB2b2lkIDAgIT09IGIgPyBiIDogMFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRjKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICB0aGlzLnBsYW5lcyA9IFt2b2lkIDAgIT09IGEgPyBhIDogbmV3IGxhLCB2b2lkIDAgIT09IGIgPyBiIDogbmV3IGxhLCB2b2lkIDAgIT09IGMgPyBjIDogbmV3IGxhLCB2b2lkIDAgIT09IGQgPyBkIDogbmV3IGxhLCB2b2lkIDAgIT09IGUgPyBlIDogbmV3IGxhLCB2b2lkIDAgIT09IGYgPyBmIDogbmV3IGxhXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEtlKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICBmdW5jdGlvbiBlKGIsIGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBiLmdlb21ldHJ5LCBnO1xyXG4gICAgICAgICAgICBnID0gQTtcclxuICAgICAgICAgICAgdmFyIGggPSBiLmN1c3RvbURlcHRoTWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIGQgJiYgKGcgPSB3LCBoID0gYi5jdXN0b21EaXN0YW5jZU1hdGVyaWFsKTtcclxuICAgICAgICAgICAgaCA/IGcgPSBoIDogKGggPSAhMSwgYy5tb3JwaFRhcmdldHMgJiYgKGYgJiYgZi5pc0J1ZmZlckdlb21ldHJ5ID8gaCA9IGYubW9ycGhBdHRyaWJ1dGVzICYmIGYubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICYmIDAgPCBmLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGggOlxyXG4gICAgICAgICAgICAgICAgZiAmJiBmLmlzR2VvbWV0cnkgJiYgKGggPSBmLm1vcnBoVGFyZ2V0cyAmJiAwIDwgZi5tb3JwaFRhcmdldHMubGVuZ3RoKSksIGIgPSBiLmlzU2tpbm5lZE1lc2ggJiYgYy5za2lubmluZywgZiA9IDAsIGggJiYgKGYgfD0gMSksIGIgJiYgKGYgfD0gMiksIGcgPSBnW2ZdKTtcclxuICAgICAgICAgICAgYS5sb2NhbENsaXBwaW5nRW5hYmxlZCAmJiAhMCA9PT0gYy5jbGlwU2hhZG93cyAmJiAwICE9PSBjLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAmJiAoZiA9IGcudXVpZCwgaCA9IGMudXVpZCwgYiA9IHlbZl0sIHZvaWQgMCA9PT0gYiAmJiAoYiA9IHt9LCB5W2ZdID0gYiksIGYgPSBiW2hdLCB2b2lkIDAgPT09IGYgJiYgKGYgPSBnLmNsb25lKCksIGJbaF0gPSBmKSwgZyA9IGYpO1xyXG4gICAgICAgICAgICBnLnZpc2libGUgPSBjLnZpc2libGU7XHJcbiAgICAgICAgICAgIGcud2lyZWZyYW1lID0gYy53aXJlZnJhbWU7XHJcbiAgICAgICAgICAgIGggPSBjLnNpZGU7XHJcbiAgICAgICAgICAgIGFhLnJlbmRlclNpbmdsZVNpZGVkICYmIDIgPT0gaCAmJiAoaCA9IDApO1xyXG4gICAgICAgICAgICBhYS5yZW5kZXJSZXZlcnNlU2lkZWQgJiYgKDAgPT09IGggPyBoID0gMSA6IDEgPT09IGggJiYgKGggPSAwKSk7XHJcbiAgICAgICAgICAgIGcuc2lkZSA9IGg7XHJcbiAgICAgICAgICAgIGcuY2xpcFNoYWRvd3MgPSBjLmNsaXBTaGFkb3dzO1xyXG4gICAgICAgICAgICBnLmNsaXBwaW5nUGxhbmVzID0gYy5jbGlwcGluZ1BsYW5lcztcclxuICAgICAgICAgICAgZy53aXJlZnJhbWVMaW5ld2lkdGggPVxyXG4gICAgICAgICAgICAgICAgYy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcbiAgICAgICAgICAgIGcubGluZXdpZHRoID0gYy5saW5ld2lkdGg7XHJcbiAgICAgICAgICAgIGQgJiYgdm9pZCAwICE9PSBnLnVuaWZvcm1zLmxpZ2h0UG9zICYmIGcudW5pZm9ybXMubGlnaHRQb3MudmFsdWUuY29weShlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGYoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBpZiAoITEgIT09IGEudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgMCAhPT0gKGEubGF5ZXJzLm1hc2sgJiBiLmxheWVycy5tYXNrKSAmJiAoYS5pc01lc2ggfHwgYS5pc0xpbmUgfHwgYS5pc1BvaW50cykgJiYgYS5jYXN0U2hhZG93ICYmICghMSA9PT0gYS5mcnVzdHVtQ3VsbGVkIHx8ICEwID09PSBtLmludGVyc2VjdHNPYmplY3QoYSkpICYmICEwID09PSBhLm1hdGVyaWFsLnZpc2libGUgJiYgKGEubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoYy5tYXRyaXhXb3JsZEludmVyc2UsIGEubWF0cml4V29ybGQpLCByLnB1c2goYSkpO1xyXG4gICAgICAgICAgICAgICAgYSA9IGEuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMCwgZSA9IGEubGVuZ3RoOyBkIDwgZTsgZCsrKWYoYVtkXSwgYiwgYylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGcgPSBhLmNvbnRleHQsIGggPSBhLnN0YXRlLCBtID0gbmV3IHRjLCBrID0gbmV3IFMsXHJcbiAgICAgICAgICAgIHQgPSBiLnNoYWRvd3MsIHAgPSBuZXcgRCwgbiA9IG5ldyBEKGQubWF4VGV4dHVyZVNpemUsIGQubWF4VGV4dHVyZVNpemUpLCB1ID0gbmV3IHEsIGwgPSBuZXcgcSwgciA9IFtdLFxyXG4gICAgICAgICAgICBBID0gQXJyYXkoNCksIHcgPSBBcnJheSg0KSwgeSA9IHt9LFxyXG4gICAgICAgICAgICBLID0gW25ldyBxKDEsIDAsIDApLCBuZXcgcSgtMSwgMCwgMCksIG5ldyBxKDAsIDAsIDEpLCBuZXcgcSgwLCAwLCAtMSksIG5ldyBxKDAsIDEsIDApLCBuZXcgcSgwLCAtMSwgMCldLFxyXG4gICAgICAgICAgICB2ID0gW25ldyBxKDAsIDEsIDApLCBuZXcgcSgwLCAxLCAwKSwgbmV3IHEoMCwgMSwgMCksIG5ldyBxKDAsIDEsIDApLCBuZXcgcSgwLCAwLCAxKSwgbmV3IHEoMCwgMCwgLTEpXSxcclxuICAgICAgICAgICAgRSA9IFtuZXcgZmEsIG5ldyBmYSwgbmV3IGZhLCBuZXcgZmEsIG5ldyBmYSwgbmV3IGZhXTtcclxuICAgICAgICBiID0gbmV3IGFiO1xyXG4gICAgICAgIGIuZGVwdGhQYWNraW5nID0gMzIwMTtcclxuICAgICAgICBiLmNsaXBwaW5nID0gITA7XHJcbiAgICAgICAgZCA9IGJiLmRpc3RhbmNlUkdCQTtcclxuICAgICAgICBmb3IgKHZhciBMID0gSmEuY2xvbmUoZC51bmlmb3JtcyksIEMgPSAwOyA0ICE9PSBDOyArK0MpIHtcclxuICAgICAgICAgICAgdmFyIEYgPSAwICE9PSAoQyAmIDEpLCBkYSA9IDAgIT09IChDICYgMiksIEggPSBiLmNsb25lKCk7XHJcbiAgICAgICAgICAgIEgubW9ycGhUYXJnZXRzID0gRjtcclxuICAgICAgICAgICAgSC5za2lubmluZyA9XHJcbiAgICAgICAgICAgICAgICBkYTtcclxuICAgICAgICAgICAgQVtDXSA9IEg7XHJcbiAgICAgICAgICAgIEYgPSBuZXcgSGEoe1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lczoge1VTRV9TSEFET1dNQVA6IFwiXCJ9LFxyXG4gICAgICAgICAgICAgICAgdW5pZm9ybXM6IEwsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGQudmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGQuZnJhZ21lbnRTaGFkZXIsXHJcbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHM6IEYsXHJcbiAgICAgICAgICAgICAgICBza2lubmluZzogZGEsXHJcbiAgICAgICAgICAgICAgICBjbGlwcGluZzogITBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHdbQ10gPSBGXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhYSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gITE7XHJcbiAgICAgICAgdGhpcy5hdXRvVXBkYXRlID0gITA7XHJcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9ICExO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IDE7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTaW5nbGVTaWRlZCA9IHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID0gITA7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoYiwgZCkge1xyXG4gICAgICAgICAgICBpZiAoITEgIT09IGFhLmVuYWJsZWQgJiYgKCExICE9PSBhYS5hdXRvVXBkYXRlIHx8ICExICE9PSBhYS5uZWVkc1VwZGF0ZSkgJiYgMCAhPT0gdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGguYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLCAxLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgIGguZGlzYWJsZShnLkJMRU5EKTtcclxuICAgICAgICAgICAgICAgIGguc2V0RGVwdGhUZXN0KCEwKTtcclxuICAgICAgICAgICAgICAgIGguc2V0U2Npc3NvclRlc3QoITEpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHEsIEEgPSAwLCBDID0gdC5sZW5ndGg7IEEgPCBDOyBBKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHRbQV0sIEwgPSB3LnNoYWRvdztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBMKSBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFNoYWRvd01hcDpcIiwgdywgXCJoYXMgbm8gc2hhZG93LlwiKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBGID0gTC5jYW1lcmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY29weShMLm1hcFNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLm1pbihuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgJiYgdy5pc1BvaW50TGlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9ICEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEggPSBwLngsIGRhID0gcC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRVswXS5zZXQoMiAqIEgsIGRhLCBILCBkYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFWzFdLnNldCgwLCBkYSwgSCwgZGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRVsyXS5zZXQoMyAqIEgsIGRhLCBILCBkYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFWzNdLnNldChILCBkYSwgSCwgZGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRVs0XS5zZXQoMyAqIEgsIDAsIEgsIGRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVbNV0uc2V0KEgsIDAsIEgsIGRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAueCAqPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC55ICo9IDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHkgPSAxLCBxID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT09IEwubWFwICYmIChMLm1hcCA9IG5ldyBZYShwLngsIHAueSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyOiAxMDAzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFnRmlsdGVyOiAxMDAzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAxMDIzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBGLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEwuaXNTcG90TGlnaHRTaGFkb3cgJiYgTC51cGRhdGUodyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEwgJiYgTC5pc1JlY3RBcmVhTGlnaHRTaGFkb3cgJiYgTC51cGRhdGUodyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEggPSBMLm1hcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTCA9IEwubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsLnNldEZyb21NYXRyaXhQb3NpdGlvbih3Lm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRi5wb3NpdGlvbi5jb3B5KGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnNldFJlbmRlclRhcmdldChIKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKEggPSAwOyBIIDwgeTsgSCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID8gKHUuY29weShGLnBvc2l0aW9uKSwgdS5hZGQoS1tIXSksIEYudXAuY29weSh2W0hdKSwgRi5sb29rQXQodSksIGgudmlld3BvcnQoRVtIXSkpIDogKHUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHcudGFyZ2V0Lm1hdHJpeFdvcmxkKSwgRi5sb29rQXQodSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRi51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRi5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZShGLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwuc2V0KC41LCAwLCAwLCAuNSwgMCwgLjUsIDAsIC41LCAwLCAwLCAuNSwgLjUsIDAsIDAsIDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTC5tdWx0aXBseShGLnByb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTC5tdWx0aXBseShGLm1hdHJpeFdvcmxkSW52ZXJzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLm11bHRpcGx5TWF0cmljZXMoRi5wcm9qZWN0aW9uTWF0cml4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEYubWF0cml4V29ybGRJbnZlcnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uc2V0RnJvbU1hdHJpeChrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYoYiwgZCwgRik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkYSA9IDAsIHggPSByLmxlbmd0aDsgZGEgPCB4OyBkYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEQgPSByW2RhXSwgVGQgPSBjLnVwZGF0ZShEKSwgU2EgPSBELm1hdGVyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTYSAmJiBTYS5pc011bHRpTWF0ZXJpYWwpZm9yICh2YXIgTGUgPSBUZC5ncm91cHMsIFNhID0gU2EubWF0ZXJpYWxzLCB6ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVhID0gTGUubGVuZ3RoOyB6IDwgRWE7IHorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgSSA9IExlW3pdLCBKID0gU2FbSS5tYXRlcmlhbEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgITAgPT09IEoudmlzaWJsZSAmJiAoSiA9IGUoRCwgSiwgcSwgbCksIGEucmVuZGVyQnVmZmVyRGlyZWN0KEYsIG51bGwsIFRkLCBKLCBELCBJKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgSiA9IGUoRCwgU2EsIHEsIGwpLCBhLnJlbmRlckJ1ZmZlckRpcmVjdChGLCBudWxsLCBUZCwgSiwgRCwgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHkgPSBhLmdldENsZWFyQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgIHEgPSBhLmdldENsZWFyQWxwaGEoKTtcclxuICAgICAgICAgICAgICAgIGEuc2V0Q2xlYXJDb2xvcih5LCBxKTtcclxuICAgICAgICAgICAgICAgIGFhLm5lZWRzVXBkYXRlID0gITFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYihhLCBiKSB7XHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPVxyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEgPyBhIDogbmV3IHE7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB2b2lkIDAgIT09IGIgPyBiIDogbmV3IHFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkYihhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdGhpcy5feCA9IGEgfHwgMDtcclxuICAgICAgICB0aGlzLl95ID0gYiB8fCAwO1xyXG4gICAgICAgIHRoaXMuX3ogPSBjIHx8IDA7XHJcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBkIHx8IGRiLkRlZmF1bHRPcmRlclxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5kKCkge1xyXG4gICAgICAgIHRoaXMubWFzayA9IDFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB4KCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHt2YWx1ZTogQmYrK30pO1xyXG4gICAgICAgIHRoaXMudXVpZCA9IE4uZ2VuZXJhdGVVVUlEKCk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIk9iamVjdDNEXCI7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLnVwID0geC5EZWZhdWx0VXAuY2xvbmUoKTtcclxuICAgICAgICB2YXIgYSA9IG5ldyBxLCBiID0gbmV3IGRiLCBjID0gbmV3IGNhLCBkID0gbmV3IHEoMSwgMSwgMSk7XHJcbiAgICAgICAgYi5vbkNoYW5nZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGMuc2V0RnJvbUV1bGVyKGIsICExKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGMub25DaGFuZ2UoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBiLnNldEZyb21RdWF0ZXJuaW9uKGMsIHZvaWQgMCwgITEpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtlbnVtZXJhYmxlOiAhMCwgdmFsdWU6IGF9LFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHtlbnVtZXJhYmxlOiAhMCwgdmFsdWU6IGJ9LFxyXG4gICAgICAgICAgICAgICAgcXVhdGVybmlvbjoge2VudW1lcmFibGU6ICEwLCB2YWx1ZTogY30sXHJcbiAgICAgICAgICAgICAgICBzY2FsZToge2VudW1lcmFibGU6ICEwLCB2YWx1ZTogZH0sXHJcbiAgICAgICAgICAgICAgICBtb2RlbFZpZXdNYXRyaXg6IHt2YWx1ZTogbmV3IFN9LFxyXG4gICAgICAgICAgICAgICAgbm9ybWFsTWF0cml4OiB7dmFsdWU6IG5ldyB5YX1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgUztcclxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFM7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0geC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcclxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSAhMTtcclxuICAgICAgICB0aGlzLmxheWVycyA9IG5ldyBuZDtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSAhMDtcclxuICAgICAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3cgPSAhMTtcclxuICAgICAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSAhMDtcclxuICAgICAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcclxuICAgICAgICB0aGlzLnVzZXJEYXRhID0ge307XHJcbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25BZnRlclJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGIoYSwgYikge1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSB2b2lkIDAgIT09IGEgPyBhIDogbmV3IHE7XHJcbiAgICAgICAgdGhpcy5lbmQgPSB2b2lkIDAgIT09IGIgPyBiIDogbmV3IHFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB6YShhLCBiLCBjKSB7XHJcbiAgICAgICAgdGhpcy5hID0gdm9pZCAwICE9PSBhID8gYSA6IG5ldyBxO1xyXG4gICAgICAgIHRoaXMuYiA9IHZvaWQgMCAhPT0gYiA/IGIgOiBuZXcgcTtcclxuICAgICAgICB0aGlzLmMgPSB2b2lkIDAgIT09IGMgPyBjIDogbmV3IHFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYShhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYyA9IGM7XHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBkICYmIGQuaXNWZWN0b3IzID8gZCA6IG5ldyBxO1xyXG4gICAgICAgIHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoZCkgPyBkIDogW107XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGUgJiYgZS5pc0NvbG9yID8gZSA6IG5ldyBKO1xyXG4gICAgICAgIHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheShlKSA/IGUgOiBbXTtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsSW5kZXggPSB2b2lkIDAgIT09IGYgPyBmIDogMFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEthKGEpIHtcclxuICAgICAgICBYLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJNZXNoQmFzaWNNYXRlcmlhbFwiO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgSigxNjc3NzIxNSk7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcCA9XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmFvTWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmVudk1hcCA9IHRoaXMuYWxwaGFNYXAgPSB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbWJpbmUgPSAwO1xyXG4gICAgICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcclxuICAgICAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IC45ODtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZSA9ICExO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gXCJyb3VuZFwiO1xyXG4gICAgICAgIHRoaXMubGlnaHRzID0gdGhpcy5tb3JwaFRhcmdldHMgPSB0aGlzLnNraW5uaW5nID0gITE7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZXMoYSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBVKGEsIGIsIGMpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS5cIik7XHJcbiAgICAgICAgdGhpcy51dWlkID0gTi5nZW5lcmF0ZVVVSUQoKTtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYTtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gYjtcclxuICAgICAgICB0aGlzLmNvdW50ID0gdm9pZCAwICE9PSBhID8gYS5sZW5ndGggLyBiIDogMDtcclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSAhMCA9PT0gYztcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSAhMTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlID0ge29mZnNldDogMCwgY291bnQ6IC0xfTtcclxuICAgICAgICB0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdWMoYSwgYikge1xyXG4gICAgICAgIFUuY2FsbCh0aGlzLCBuZXcgSW50OEFycmF5KGEpLCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHZjKGEsIGIpIHtcclxuICAgICAgICBVLmNhbGwodGhpcywgbmV3IFVpbnQ4QXJyYXkoYSksIGIpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2MoYSwgYikge1xyXG4gICAgICAgIFUuY2FsbCh0aGlzLCBuZXcgVWludDhDbGFtcGVkQXJyYXkoYSksIGIpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geGMoYSwgYikge1xyXG4gICAgICAgIFUuY2FsbCh0aGlzLCBuZXcgSW50MTZBcnJheShhKSwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpYihhLCBiKSB7XHJcbiAgICAgICAgVS5jYWxsKHRoaXMsIG5ldyBVaW50MTZBcnJheShhKSwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB5YyhhLCBiKSB7XHJcbiAgICAgICAgVS5jYWxsKHRoaXMsIG5ldyBJbnQzMkFycmF5KGEpLCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGpiKGEsIGIpIHtcclxuICAgICAgICBVLmNhbGwodGhpcyxcclxuICAgICAgICAgICAgbmV3IFVpbnQzMkFycmF5KGEpLCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHooYSwgYikge1xyXG4gICAgICAgIFUuY2FsbCh0aGlzLCBuZXcgRmxvYXQzMkFycmF5KGEpLCBiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHpjKGEsIGIpIHtcclxuICAgICAgICBVLmNhbGwodGhpcywgbmV3IEZsb2F0NjRBcnJheShhKSwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBNZSgpIHtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gW107XHJcbiAgICAgICAgdGhpcy5ub3JtYWxzID0gW107XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnV2cyA9IFtdO1xyXG4gICAgICAgIHRoaXMudXZzMiA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XHJcbiAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcclxuICAgICAgICB0aGlzLnNraW5XZWlnaHRzID0gW107XHJcbiAgICAgICAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSB0aGlzLnV2c05lZWRVcGRhdGUgPSB0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSAhMVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFVkKGEpIHtcclxuICAgICAgICBmb3IgKHZhciBiID0gYS5sZW5ndGgsIGMgPSAtSW5maW5pdHk7IGItLTspYVtiXSA+XHJcbiAgICAgICAgYyAmJiAoYyA9IGFbYl0pO1xyXG4gICAgICAgIHJldHVybiBjXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVCgpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7dmFsdWU6IFZkKyt9KTtcclxuICAgICAgICB0aGlzLnV1aWQgPSBOLmdlbmVyYXRlVVVJRCgpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZmFjZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbW11dO1xyXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRzID0gW107XHJcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcclxuICAgICAgICB0aGlzLnNraW5XZWlnaHRzID0gW107XHJcbiAgICAgICAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSB0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRoaXMudXZzTmVlZFVwZGF0ZSA9IHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPVxyXG4gICAgICAgICAgICAhMVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEkoKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge3ZhbHVlOiBWZCsrfSk7XHJcbiAgICAgICAgdGhpcy51dWlkID0gTi5nZW5lcmF0ZVVVSUQoKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQnVmZmVyR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHJhd1JhbmdlID0ge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHl9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQWEoYSwgYikge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIk1lc2hcIjtcclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gdm9pZCAwICE9PSBhID8gYSA6IG5ldyBJO1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSB2b2lkIDAgIT09IGIgPyBiIDogbmV3IEthKHtjb2xvcjogMTY3NzcyMTUgKiBNYXRoLnJhbmRvbSgpfSk7XHJcbiAgICAgICAgdGhpcy5kcmF3TW9kZSA9IDA7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEliKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJCb3hHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHt3aWR0aDogYSwgaGVpZ2h0OiBiLCBkZXB0aDogYywgd2lkdGhTZWdtZW50czogZCwgaGVpZ2h0U2VnbWVudHM6IGUsIGRlcHRoU2VnbWVudHM6IGZ9O1xyXG4gICAgICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBrYihhLCBiLCBjLCBkLCBlLCBmKSk7XHJcbiAgICAgICAgdGhpcy5tZXJnZVZlcnRpY2VzKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrYihhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBsLCBMLCBDLCBGKSB7XHJcbiAgICAgICAgICAgIHZhciBkYSA9IGYgLyBMLCBIID0gZyAvIEMsIGFhID0gZiAvIDIsIHggPSBnIC8gMiwgRCA9IGwgLyAyO1xyXG4gICAgICAgICAgICBnID0gTCArIDE7XHJcbiAgICAgICAgICAgIHZhciB6ID0gQyArIDEsIFEgPSBmID0gMCwgTSwgTywgUCA9IG5ldyBxO1xyXG4gICAgICAgICAgICBmb3IgKE8gPSAwOyBPIDwgejsgTysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgSiA9IE8gKiBIIC0geDtcclxuICAgICAgICAgICAgICAgIGZvciAoTSA9IDA7IE0gPCBnOyBNKyspUFthXSA9IChNICogZGEgLSBhYSkgKiBkLCBQW2JdID0gSiAqIGUsIFBbY10gPSBELCBrLnB1c2goUC54LCBQLnksIFAueiksIFBbYV0gPSAwLCBQW2JdID0gMCwgUFtjXSA9IDAgPCBsID8gMSA6IC0xLCB0LnB1c2goUC54LCBQLnksIFAueiksIHAucHVzaChNIC8gTCksIHAucHVzaCgxIC0gTyAvIEMpLCBmICs9IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKE8gPSAwOyBPIDwgQzsgTysrKWZvciAoTSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDsgTSA8IEw7IE0rKylhID0gbiArIE0gKyBnICogKE8gKyAxKSwgYiA9IG4gKyAoTSArIDEpICsgZyAqIChPICsgMSksIGMgPSBuICsgKE0gKyAxKSArIGcgKiBPLCBtLnB1c2gobiArIE0gKyBnICogTywgYSwgYyksIG0ucHVzaChhLCBiLCBjKSwgUSArPSA2O1xyXG4gICAgICAgICAgICBoLmFkZEdyb3VwKHUsIFEsIEYpO1xyXG4gICAgICAgICAgICB1ICs9IFE7XHJcbiAgICAgICAgICAgIG4gKz0gZlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQm94QnVmZmVyR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7d2lkdGg6IGEsIGhlaWdodDogYiwgZGVwdGg6IGMsIHdpZHRoU2VnbWVudHM6IGQsIGhlaWdodFNlZ21lbnRzOiBlLCBkZXB0aFNlZ21lbnRzOiBmfTtcclxuICAgICAgICB2YXIgaCA9IHRoaXM7XHJcbiAgICAgICAgZCA9IE1hdGguZmxvb3IoZCkgfHwgMTtcclxuICAgICAgICBlID0gTWF0aC5mbG9vcihlKSB8fCAxO1xyXG4gICAgICAgIGYgPSBNYXRoLmZsb29yKGYpIHx8IDE7XHJcbiAgICAgICAgdmFyIG0gPSBbXSwgayA9IFtdLCB0ID0gW10sIHAgPSBbXSwgbiA9IDAsIHUgPSAwO1xyXG4gICAgICAgIGcoXCJ6XCIsIFwieVwiLCBcInhcIiwgLTEsIC0xLCBjLCBiLCBhLCBmLCBlLCAwKTtcclxuICAgICAgICBnKFwielwiLCBcInlcIiwgXCJ4XCIsIDEsIC0xLCBjLCBiLCAtYSwgZiwgZSwgMSk7XHJcbiAgICAgICAgZyhcInhcIiwgXCJ6XCIsIFwieVwiLCAxLCAxLCBhLCBjLCBiLCBkLCBmLCAyKTtcclxuICAgICAgICBnKFwieFwiLCBcInpcIiwgXCJ5XCIsIDEsIC0xLCBhLCBjLCAtYiwgZCwgZiwgMyk7XHJcbiAgICAgICAgZyhcInhcIiwgXCJ5XCIsIFwielwiLFxyXG4gICAgICAgICAgICAxLCAtMSwgYSwgYiwgYywgZCwgZSwgNCk7XHJcbiAgICAgICAgZyhcInhcIiwgXCJ5XCIsIFwielwiLCAtMSwgLTEsIGEsIGIsIC1jLCBkLCBlLCA1KTtcclxuICAgICAgICB0aGlzLnNldEluZGV4KG0pO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IHooaywgMykpO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwibm9ybWFsXCIsIG5ldyB6KHQsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInV2XCIsIG5ldyB6KHAsIDIpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEFjKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJQbGFuZUdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3dpZHRoOiBhLCBoZWlnaHQ6IGIsIHdpZHRoU2VnbWVudHM6IGMsIGhlaWdodFNlZ21lbnRzOiBkfTtcclxuICAgICAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeShuZXcgbGIoYSwgYiwgYywgZCkpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGIoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIEkuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlBsYW5lQnVmZmVyR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7d2lkdGg6IGEsIGhlaWdodDogYiwgd2lkdGhTZWdtZW50czogYywgaGVpZ2h0U2VnbWVudHM6IGR9O1xyXG4gICAgICAgIHZhciBlID0gYSAvIDIsIGYgPSBiIC9cclxuICAgICAgICAgICAgMjtcclxuICAgICAgICBjID0gTWF0aC5mbG9vcihjKSB8fCAxO1xyXG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQpIHx8IDE7XHJcbiAgICAgICAgdmFyIGcgPSBjICsgMSwgaCA9IGQgKyAxLCBtID0gYSAvIGMsIGsgPSBiIC8gZCwgdCA9IFtdLCBwID0gW10sIG4gPSBbXSwgdSA9IFtdO1xyXG4gICAgICAgIGZvciAoYSA9IDA7IGEgPCBoOyBhKyspIHtcclxuICAgICAgICAgICAgdmFyIGwgPSBhICogayAtIGY7XHJcbiAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCBnOyBiKyspcC5wdXNoKGIgKiBtIC0gZSwgLWwsIDApLCBuLnB1c2goMCwgMCwgMSksIHUucHVzaChiIC8gYyksIHUucHVzaCgxIC0gYSAvIGQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoYSA9IDA7IGEgPCBkOyBhKyspZm9yIChiID0gMDsgYiA8IGM7IGIrKyllID0gYiArIGcgKiAoYSArIDEpLCBmID0gYiArIDEgKyBnICogKGEgKyAxKSwgaCA9IGIgKyAxICsgZyAqIGEsIHQucHVzaChiICsgZyAqIGEsIGUsIGgpLCB0LnB1c2goZSwgZiwgaCk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0KTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KHAsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgeihuLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgeih1LCAyKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByYSgpIHtcclxuICAgICAgICB4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJDYW1lcmFcIjtcclxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBTO1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9XHJcbiAgICAgICAgICAgIG5ldyBTXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRmEoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHJhLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJQZXJzcGVjdGl2ZUNhbWVyYVwiO1xyXG4gICAgICAgIHRoaXMuZm92ID0gdm9pZCAwICE9PSBhID8gYSA6IDUwO1xyXG4gICAgICAgIHRoaXMuem9vbSA9IDE7XHJcbiAgICAgICAgdGhpcy5uZWFyID0gdm9pZCAwICE9PSBjID8gYyA6IC4xO1xyXG4gICAgICAgIHRoaXMuZmFyID0gdm9pZCAwICE9PSBkID8gZCA6IDJFMztcclxuICAgICAgICB0aGlzLmZvY3VzID0gMTA7XHJcbiAgICAgICAgdGhpcy5hc3BlY3QgPSB2b2lkIDAgIT09IGIgPyBiIDogMTtcclxuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmlsbUdhdWdlID0gMzU7XHJcbiAgICAgICAgdGhpcy5maWxtT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEpiKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICByYS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiT3J0aG9ncmFwaGljQ2FtZXJhXCI7XHJcbiAgICAgICAgdGhpcy56b29tID0gMTtcclxuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGE7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IGI7XHJcbiAgICAgICAgdGhpcy50b3AgPSBjO1xyXG4gICAgICAgIHRoaXMuYm90dG9tID0gZDtcclxuICAgICAgICB0aGlzLm5lYXIgPSB2b2lkIDAgIT09IGUgPyBlIDogLjE7XHJcbiAgICAgICAgdGhpcy5mYXIgPSB2b2lkIDAgIT09IGYgPyBmIDogMkUzO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQ2YoYSwgYiwgYykge1xyXG4gICAgICAgIHZhciBkLCBlLCBmO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldE1vZGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBkID0gYVxyXG4gICAgICAgICAgICB9LCBzZXRJbmRleDogZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIGMuYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBiLmdldChcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIikgPyAoZSA9IGEuVU5TSUdORURfSU5ULCBmID0gNCkgOiBjLmFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgPyAoZSA9IGEuVU5TSUdORURfU0hPUlQsIGYgPSAyKSA6IChlID0gYS5VTlNJR05FRF9CWVRFLCBmID0gMSlcclxuICAgICAgICAgICAgfSwgcmVuZGVyOiBmdW5jdGlvbiAoYiwgaCkge1xyXG4gICAgICAgICAgICAgICAgYS5kcmF3RWxlbWVudHMoZCwgaCwgZSwgYiAqIGYpO1xyXG4gICAgICAgICAgICAgICAgYy5jYWxscysrO1xyXG4gICAgICAgICAgICAgICAgYy52ZXJ0aWNlcyArPSBoO1xyXG4gICAgICAgICAgICAgICAgZCA9PT0gYS5UUklBTkdMRVMgJiYgKGMuZmFjZXMgKz0gaCAvIDMpXHJcbiAgICAgICAgICAgIH0sIHJlbmRlckluc3RhbmNlczogZnVuY3Rpb24gKGcsIGgsIG0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gYi5nZXQoXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xyXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gayA/IGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy5cIikgOlxyXG4gICAgICAgICAgICAgICAgICAgIChrLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKGQsIG0sIGUsIGggKiBmLCBnLm1heEluc3RhbmNlZENvdW50KSwgYy5jYWxscysrLCBjLnZlcnRpY2VzICs9IG0gKiBnLm1heEluc3RhbmNlZENvdW50LCBkID09PSBhLlRSSUFOR0xFUyAmJiAoYy5mYWNlcyArPSBnLm1heEluc3RhbmNlZENvdW50ICogbSAvIDMpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIERmKGEsIGIsIGMpIHtcclxuICAgICAgICB2YXIgZDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXRNb2RlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgZCA9IGFcclxuICAgICAgICAgICAgfSwgcmVuZGVyOiBmdW5jdGlvbiAoYiwgZikge1xyXG4gICAgICAgICAgICAgICAgYS5kcmF3QXJyYXlzKGQsIGIsIGYpO1xyXG4gICAgICAgICAgICAgICAgYy5jYWxscysrO1xyXG4gICAgICAgICAgICAgICAgYy52ZXJ0aWNlcyArPSBmO1xyXG4gICAgICAgICAgICAgICAgZCA9PT0gYS5UUklBTkdMRVMgJiYgKGMuZmFjZXMgKz0gZiAvIDMpXHJcbiAgICAgICAgICAgIH0sIHJlbmRlckluc3RhbmNlczogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gYi5nZXQoXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGYpIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy5cIik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGUuYXR0cmlidXRlcy5wb3NpdGlvbiwgZyA9IGcuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGcuZGF0YS5jb3VudCA6IGcuY291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoZCwgMCwgZywgZS5tYXhJbnN0YW5jZWRDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxscysrO1xyXG4gICAgICAgICAgICAgICAgICAgIGMudmVydGljZXMgKz0gZyAqIGUubWF4SW5zdGFuY2VkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9PT0gYS5UUklBTkdMRVMgJiYgKGMuZmFjZXMgKz0gZS5tYXhJbnN0YW5jZWRDb3VudCAqIGcgLyAzKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEVmKCkge1xyXG4gICAgICAgIHZhciBhID0ge307XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYVtiLmlkXSlyZXR1cm4gYVtiLmlkXTtcclxuICAgICAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChiLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRGlyZWN0aW9uYWxMaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBuZXcgcSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgSixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvdzogITEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dCaWFzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93UmFkaXVzOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93TWFwU2l6ZTogbmV3IERcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNwb3RMaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBuZXcgcSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgSixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZUNvczogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbnVtYnJhQ29zOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjYXk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3c6ICExLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93QmlhczogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1JhZGl1czogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd01hcFNpemU6IG5ldyBEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludExpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbmV3IHEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogbmV3IEosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2F5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93OiAhMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0JpYXM6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSYWRpdXM6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dNYXBTaXplOiBuZXcgRFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSGVtaXNwaGVyZUxpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7ZGlyZWN0aW9uOiBuZXcgcSwgc2t5Q29sb3I6IG5ldyBKLCBncm91bmRDb2xvcjogbmV3IEp9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUmVjdEFyZWFMaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0ge2NvbG9yOiBuZXcgSiwgcG9zaXRpb246IG5ldyBxLCBoYWxmV2lkdGg6IG5ldyBxLCBoYWxmSGVpZ2h0OiBuZXcgcX1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhW2IuaWRdID0gY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEZmKGEpIHtcclxuICAgICAgICBhID0gYS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGEubGVuZ3RoOyBiKyspYVtiXSA9XHJcbiAgICAgICAgICAgIGIgKyAxICsgXCI6IFwiICsgYVtiXTtcclxuICAgICAgICByZXR1cm4gYS5qb2luKFwiXFxuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTmUoYSwgYiwgYykge1xyXG4gICAgICAgIHZhciBkID0gYS5jcmVhdGVTaGFkZXIoYik7XHJcbiAgICAgICAgYS5zaGFkZXJTb3VyY2UoZCwgYyk7XHJcbiAgICAgICAgYS5jb21waWxlU2hhZGVyKGQpO1xyXG4gICAgICAgICExID09PSBhLmdldFNoYWRlclBhcmFtZXRlcihkLCBhLkNPTVBJTEVfU1RBVFVTKSAmJiBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG4ndCBjb21waWxlLlwiKTtcclxuICAgICAgICBcIlwiICE9PSBhLmdldFNoYWRlckluZm9Mb2coZCkgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xTaGFkZXI6IGdsLmdldFNoYWRlckluZm9Mb2coKVwiLCBiID09PSBhLlZFUlRFWF9TSEFERVIgPyBcInZlcnRleFwiIDogXCJmcmFnbWVudFwiLCBhLmdldFNoYWRlckluZm9Mb2coZCksIEZmKGMpKTtcclxuICAgICAgICByZXR1cm4gZFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE9lKGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGEpIHtcclxuICAgICAgICAgICAgY2FzZSAzRTM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiTGluZWFyXCIsIFwiKCB2YWx1ZSApXCJdO1xyXG4gICAgICAgICAgICBjYXNlIDMwMDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wic1JHQlwiLCBcIiggdmFsdWUgKVwiXTtcclxuICAgICAgICAgICAgY2FzZSAzMDAyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIlJHQkVcIixcclxuICAgICAgICAgICAgICAgICAgICBcIiggdmFsdWUgKVwiXTtcclxuICAgICAgICAgICAgY2FzZSAzMDA0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIlJHQk1cIiwgXCIoIHZhbHVlLCA3LjAgKVwiXTtcclxuICAgICAgICAgICAgY2FzZSAzMDA1OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIlJHQk1cIiwgXCIoIHZhbHVlLCAxNi4wIClcIl07XHJcbiAgICAgICAgICAgIGNhc2UgMzAwNjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJSR0JEXCIsIFwiKCB2YWx1ZSwgMjU2LjAgKVwiXTtcclxuICAgICAgICAgICAgY2FzZSAzMDA3OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIkdhbW1hXCIsIFwiKCB2YWx1ZSwgZmxvYXQoIEdBTU1BX0ZBQ1RPUiApIClcIl07XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIiArIGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBXZChhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMgPSBPZShiKTtcclxuICAgICAgICByZXR1cm4gXCJ2ZWM0IFwiICsgYSArIFwiKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gXCIgKyBjWzBdICsgXCJUb0xpbmVhclwiICsgY1sxXSArIFwiOyB9XCJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHZihhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMgPSBPZShiKTtcclxuICAgICAgICByZXR1cm4gXCJ2ZWM0IFwiICsgYSArIFwiKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG9cIiArIGNbMF0gKyBjWzFdICsgXCI7IH1cIlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEhmKGEsIGIpIHtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICBzd2l0Y2ggKGIpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYyA9IFwiTGluZWFyXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYyA9IFwiUmVpbmhhcmRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBjID0gXCJVbmNoYXJ0ZWQyXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgYyA9IFwiT3B0aW1pemVkQ2luZW9uXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6IFwiICsgYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcInZlYzMgXCIgKyBhICsgXCIoIHZlYzMgY29sb3IgKSB7IHJldHVybiBcIiArIGMgKyBcIlRvbmVNYXBwaW5nKCBjb2xvciApOyB9XCJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJZihhLCBiLCBjKSB7XHJcbiAgICAgICAgYSA9IGEgfHwge307XHJcbiAgICAgICAgcmV0dXJuIFthLmRlcml2YXRpdmVzIHx8IGIuZW52TWFwQ3ViZVVWIHx8IGIuYnVtcE1hcCB8fCBiLm5vcm1hbE1hcCB8fCBiLmZsYXRTaGFkaW5nID8gXCIjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVwiIDogXCJcIiwgKGEuZnJhZ0RlcHRoIHx8IGIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcikgJiYgYy5nZXQoXCJFWFRfZnJhZ19kZXB0aFwiKSA/IFwiI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVwiIDogXCJcIiwgYS5kcmF3QnVmZmVycyAmJiBjLmdldChcIldFQkdMX2RyYXdfYnVmZmVyc1wiKSA/XHJcbiAgICAgICAgICAgIFwiI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZVwiIDogXCJcIiwgKGEuc2hhZGVyVGV4dHVyZUxPRCB8fCBiLmVudk1hcCkgJiYgYy5nZXQoXCJFWFRfc2hhZGVyX3RleHR1cmVfbG9kXCIpID8gXCIjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcIiA6IFwiXCJdLmZpbHRlcihCYykuam9pbihcIlxcblwiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEpmKGEpIHtcclxuICAgICAgICB2YXIgYiA9IFtdLCBjO1xyXG4gICAgICAgIGZvciAoYyBpbiBhKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gYVtjXTtcclxuICAgICAgICAgICAgITEgIT09IGQgJiYgYi5wdXNoKFwiI2RlZmluZSBcIiArIGMgKyBcIiBcIiArIGQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiLmpvaW4oXCJcXG5cIilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBCYyhhKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgIT09IGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBQZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEucmVwbGFjZSgvTlVNX0RJUl9MSUdIVFMvZywgYi5udW1EaXJMaWdodHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUUy9nLCBiLm51bVNwb3RMaWdodHMpLnJlcGxhY2UoL05VTV9SRUNUX0FSRUFfTElHSFRTL2csIGIubnVtUmVjdEFyZWFMaWdodHMpLnJlcGxhY2UoL05VTV9QT0lOVF9MSUdIVFMvZyxcclxuICAgICAgICAgICAgYi5udW1Qb2ludExpZ2h0cykucmVwbGFjZSgvTlVNX0hFTUlfTElHSFRTL2csIGIubnVtSGVtaUxpZ2h0cylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBYZChhKSB7XHJcbiAgICAgICAgcmV0dXJuIGEucmVwbGFjZSgvI2luY2x1ZGUgKzwoW1xcd1xcZC5dKyk+L2csIGZ1bmN0aW9uIChhLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gWltjXTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZCl0aHJvdyBFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8XCIgKyBjICsgXCI+XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gWGQoZClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFFlKGEpIHtcclxuICAgICAgICByZXR1cm4gYS5yZXBsYWNlKC9mb3IgXFwoIGludCBpIFxcPSAoXFxkKylcXDsgaSA8IChcXGQrKVxcOyBpIFxcK1xcKyBcXCkgXFx7KFtcXHNcXFNdKz8pKD89XFx9KVxcfS9nLCBmdW5jdGlvbiAoYSwgYywgZCwgZSkge1xyXG4gICAgICAgICAgICBhID0gXCJcIjtcclxuICAgICAgICAgICAgZm9yIChjID0gcGFyc2VJbnQoYyk7IGMgPCBwYXJzZUludChkKTsgYysrKWEgKz0gZS5yZXBsYWNlKC9cXFsgaSBcXF0vZywgXCJbIFwiICsgYyArIFwiIF1cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBLZihhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdmFyIGUgPSBhLmNvbnRleHQsIGYgPSBjLmV4dGVuc2lvbnMsIGcgPSBjLmRlZmluZXMsIGggPSBjLl9fd2ViZ2xTaGFkZXIudmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgICBtID0gYy5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyLCBrID0gXCJTSEFET1dNQVBfVFlQRV9CQVNJQ1wiO1xyXG4gICAgICAgIDEgPT09IGQuc2hhZG93TWFwVHlwZSA/IGsgPSBcIlNIQURPV01BUF9UWVBFX1BDRlwiIDogMiA9PT0gZC5zaGFkb3dNYXBUeXBlICYmIChrID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVFwiKTtcclxuICAgICAgICB2YXIgdCA9IFwiRU5WTUFQX1RZUEVfQ1VCRVwiLCBwID0gXCJFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXCIsIG4gPSBcIkVOVk1BUF9CTEVORElOR19NVUxUSVBMWVwiO1xyXG4gICAgICAgIGlmIChkLmVudk1hcCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGMuZW52TWFwLm1hcHBpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDI6XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IFwiRU5WTUFQX1RZUEVfQ1VCRVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDY6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwNzpcclxuICAgICAgICAgICAgICAgICAgICB0ID0gXCJFTlZNQVBfVFlQRV9DVUJFX1VWXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwMzpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBcIkVOVk1BUF9UWVBFX0VRVUlSRUNcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBcIkVOVk1BUF9UWVBFX1NQSEVSRVwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChjLmVudk1hcC5tYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBcIkVOVk1BUF9NT0RFX1JFRlJBQ1RJT05cIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYy5jb21iaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IFwiRU5WTUFQX0JMRU5ESU5HX01JWFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBcIkVOVk1BUF9CTEVORElOR19BRERcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1ID0gMCA8IGEuZ2FtbWFGYWN0b3IgPyBhLmdhbW1hRmFjdG9yIDogMSwgZiA9IElmKGYsIGQsIGEuZXh0ZW5zaW9ucyksIGwgPSBKZihnKSwgciA9IGUuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGMuaXNSYXdTaGFkZXJNYXRlcmlhbCA/IChnID0gW2wsIFwiXFxuXCJdLmZpbHRlcihCYykuam9pbihcIlxcblwiKSwgayA9IFtmLCBsLCBcIlxcblwiXS5maWx0ZXIoQmMpLmpvaW4oXCJcXG5cIikpIDogKGcgPSBbXCJwcmVjaXNpb24gXCIgKyBkLnByZWNpc2lvbiArIFwiIGZsb2F0O1wiLCBcInByZWNpc2lvbiBcIiArIGQucHJlY2lzaW9uICsgXCIgaW50O1wiLCBcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIgKyBjLl9fd2ViZ2xTaGFkZXIubmFtZSwgbCwgZC5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gXCIjZGVmaW5lIFZFUlRFWF9URVhUVVJFU1wiIDogXCJcIiwgXCIjZGVmaW5lIEdBTU1BX0ZBQ1RPUiBcIiArIHUsIFwiI2RlZmluZSBNQVhfQk9ORVMgXCIgK1xyXG4gICAgICAgIGQubWF4Qm9uZXMsIGQudXNlRm9nICYmIGQuZm9nID8gXCIjZGVmaW5lIFVTRV9GT0dcIiA6IFwiXCIsIGQudXNlRm9nICYmIGQuZm9nRXhwID8gXCIjZGVmaW5lIEZPR19FWFAyXCIgOiBcIlwiLCBkLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLCBkLmVudk1hcCA/IFwiI2RlZmluZSBVU0VfRU5WTUFQXCIgOiBcIlwiLCBkLmVudk1hcCA/IFwiI2RlZmluZSBcIiArIHAgOiBcIlwiLCBkLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIiwgZC5hb01hcCA/IFwiI2RlZmluZSBVU0VfQU9NQVBcIiA6IFwiXCIsIGQuZW1pc3NpdmVNYXAgPyBcIiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQXCIgOiBcIlwiLCBkLmJ1bXBNYXAgPyBcIiNkZWZpbmUgVVNFX0JVTVBNQVBcIiA6IFwiXCIsIGQubm9ybWFsTWFwID8gXCIjZGVmaW5lIFVTRV9OT1JNQUxNQVBcIiA6IFwiXCIsIGQuZGlzcGxhY2VtZW50TWFwICYmIGQuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/IFwiI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQXCIgOiBcIlwiLCBkLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIiwgZC5yb3VnaG5lc3NNYXAgPyBcIiNkZWZpbmUgVVNFX1JPVUdITkVTU01BUFwiIDpcclxuICAgICAgICAgICAgXCJcIiwgZC5tZXRhbG5lc3NNYXAgPyBcIiNkZWZpbmUgVVNFX01FVEFMTkVTU01BUFwiIDogXCJcIiwgZC5hbHBoYU1hcCA/IFwiI2RlZmluZSBVU0VfQUxQSEFNQVBcIiA6IFwiXCIsIGQudmVydGV4Q29sb3JzID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIiwgZC5mbGF0U2hhZGluZyA/IFwiI2RlZmluZSBGTEFUX1NIQURFRFwiIDogXCJcIiwgZC5za2lubmluZyA/IFwiI2RlZmluZSBVU0VfU0tJTk5JTkdcIiA6IFwiXCIsIGQudXNlVmVydGV4VGV4dHVyZSA/IFwiI2RlZmluZSBCT05FX1RFWFRVUkVcIiA6IFwiXCIsIGQubW9ycGhUYXJnZXRzID8gXCIjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFNcIiA6IFwiXCIsIGQubW9ycGhOb3JtYWxzICYmICExID09PSBkLmZsYXRTaGFkaW5nID8gXCIjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFNcIiA6IFwiXCIsIGQuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLCBkLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLCBcIiNkZWZpbmUgTlVNX0NMSVBQSU5HX1BMQU5FUyBcIiArIGQubnVtQ2xpcHBpbmdQbGFuZXMsIGQuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOlxyXG4gICAgICAgICAgICBcIlwiLCBkLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgXCIgKyBrIDogXCJcIiwgZC5zaXplQXR0ZW51YXRpb24gPyBcIiNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTlwiIDogXCJcIiwgZC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gXCIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRlwiIDogXCJcIiwgZC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIGEuZXh0ZW5zaW9ucy5nZXQoXCJFWFRfZnJhZ19kZXB0aFwiKSA/IFwiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUXCIgOiBcIlwiLCBcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcIiwgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1wiLCBcInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1wiLCBcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLCBcInVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XCIsIFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIiwgXCJhdHRyaWJ1dGUgdmVjMiB1djtcIiwgXCIjaWZkZWYgVVNFX0NPTE9SXCIsXHJcbiAgICAgICAgICAgIFwiXFx0YXR0cmlidXRlIHZlYzMgY29sb3I7XCIsIFwiI2VuZGlmXCIsIFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcIiwgXCJcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7XCIsIFwiXFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxO1wiLCBcIlxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjtcIiwgXCJcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7XCIsIFwiXFx0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIiwgXCJcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7XCIsIFwiXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxO1wiLCBcIlxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjtcIiwgXCJcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7XCIsIFwiXFx0I2Vsc2VcIiwgXCJcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7XCIsIFwiXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1O1wiLCBcIlxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjtcIiwgXCJcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7XCIsXHJcbiAgICAgICAgICAgIFwiXFx0I2VuZGlmXCIsIFwiI2VuZGlmXCIsIFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLCBcIlxcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDtcIiwgXCJcXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0O1wiLCBcIiNlbmRpZlwiLCBcIlxcblwiXS5maWx0ZXIoQmMpLmpvaW4oXCJcXG5cIiksIGsgPSBbZiwgXCJwcmVjaXNpb24gXCIgKyBkLnByZWNpc2lvbiArIFwiIGZsb2F0O1wiLCBcInByZWNpc2lvbiBcIiArIGQucHJlY2lzaW9uICsgXCIgaW50O1wiLCBcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIgKyBjLl9fd2ViZ2xTaGFkZXIubmFtZSwgbCwgZC5hbHBoYVRlc3QgPyBcIiNkZWZpbmUgQUxQSEFURVNUIFwiICsgZC5hbHBoYVRlc3QgOiBcIlwiLCBcIiNkZWZpbmUgR0FNTUFfRkFDVE9SIFwiICsgdSwgZC51c2VGb2cgJiYgZC5mb2cgPyBcIiNkZWZpbmUgVVNFX0ZPR1wiIDogXCJcIiwgZC51c2VGb2cgJiYgZC5mb2dFeHAgPyBcIiNkZWZpbmUgRk9HX0VYUDJcIiA6IFwiXCIsIGQubWFwID8gXCIjZGVmaW5lIFVTRV9NQVBcIiA6IFwiXCIsIGQuZW52TWFwID8gXCIjZGVmaW5lIFVTRV9FTlZNQVBcIiA6IFwiXCIsIGQuZW52TWFwID8gXCIjZGVmaW5lIFwiICsgdCA6IFwiXCIsIGQuZW52TWFwID9cclxuICAgICAgICAgICAgXCIjZGVmaW5lIFwiICsgcCA6IFwiXCIsIGQuZW52TWFwID8gXCIjZGVmaW5lIFwiICsgbiA6IFwiXCIsIGQubGlnaHRNYXAgPyBcIiNkZWZpbmUgVVNFX0xJR0hUTUFQXCIgOiBcIlwiLCBkLmFvTWFwID8gXCIjZGVmaW5lIFVTRV9BT01BUFwiIDogXCJcIiwgZC5lbWlzc2l2ZU1hcCA/IFwiI2RlZmluZSBVU0VfRU1JU1NJVkVNQVBcIiA6IFwiXCIsIGQuYnVtcE1hcCA/IFwiI2RlZmluZSBVU0VfQlVNUE1BUFwiIDogXCJcIiwgZC5ub3JtYWxNYXAgPyBcIiNkZWZpbmUgVVNFX05PUk1BTE1BUFwiIDogXCJcIiwgZC5zcGVjdWxhck1hcCA/IFwiI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVBcIiA6IFwiXCIsIGQucm91Z2huZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVBcIiA6IFwiXCIsIGQubWV0YWxuZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVBcIiA6IFwiXCIsIGQuYWxwaGFNYXAgPyBcIiNkZWZpbmUgVVNFX0FMUEhBTUFQXCIgOiBcIlwiLCBkLnZlcnRleENvbG9ycyA/IFwiI2RlZmluZSBVU0VfQ09MT1JcIiA6IFwiXCIsIGQuZ3JhZGllbnRNYXAgPyBcIiNkZWZpbmUgVVNFX0dSQURJRU5UTUFQXCIgOiBcIlwiLCBkLmZsYXRTaGFkaW5nID8gXCIjZGVmaW5lIEZMQVRfU0hBREVEXCIgOlxyXG4gICAgICAgICAgICBcIlwiLCBkLmRvdWJsZVNpZGVkID8gXCIjZGVmaW5lIERPVUJMRV9TSURFRFwiIDogXCJcIiwgZC5mbGlwU2lkZWQgPyBcIiNkZWZpbmUgRkxJUF9TSURFRFwiIDogXCJcIiwgXCIjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgXCIgKyBkLm51bUNsaXBwaW5nUGxhbmVzLCBcIiNkZWZpbmUgVU5JT05fQ0xJUFBJTkdfUExBTkVTIFwiICsgKGQubnVtQ2xpcHBpbmdQbGFuZXMgLSBkLm51bUNsaXBJbnRlcnNlY3Rpb24pLCBkLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgVVNFX1NIQURPV01BUFwiIDogXCJcIiwgZC5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFwiICsgayA6IFwiXCIsIGQucHJlbXVsdGlwbGllZEFscGhhID8gXCIjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEFcIiA6IFwiXCIsIGQucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPyBcIiNkZWZpbmUgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1wiIDogXCJcIiwgZC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gXCIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRlwiIDogXCJcIiwgZC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIGEuZXh0ZW5zaW9ucy5nZXQoXCJFWFRfZnJhZ19kZXB0aFwiKSA/XHJcbiAgICAgICAgICAgIFwiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUXCIgOiBcIlwiLCBkLmVudk1hcCAmJiBhLmV4dGVuc2lvbnMuZ2V0KFwiRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFwiKSA/IFwiI2RlZmluZSBURVhUVVJFX0xPRF9FWFRcIiA6IFwiXCIsIFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsIFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLCAwICE9PSBkLnRvbmVNYXBwaW5nID8gXCIjZGVmaW5lIFRPTkVfTUFQUElOR1wiIDogXCJcIiwgMCAhPT0gZC50b25lTWFwcGluZyA/IFoudG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCA6IFwiXCIsIDAgIT09IGQudG9uZU1hcHBpbmcgPyBIZihcInRvbmVNYXBwaW5nXCIsIGQudG9uZU1hcHBpbmcpIDogXCJcIiwgZC5vdXRwdXRFbmNvZGluZyB8fCBkLm1hcEVuY29kaW5nIHx8IGQuZW52TWFwRW5jb2RpbmcgfHwgZC5lbWlzc2l2ZU1hcEVuY29kaW5nID8gWi5lbmNvZGluZ3NfcGFyc19mcmFnbWVudCA6IFwiXCIsIGQubWFwRW5jb2RpbmcgPyBXZChcIm1hcFRleGVsVG9MaW5lYXJcIiwgZC5tYXBFbmNvZGluZykgOiBcIlwiLCBkLmVudk1hcEVuY29kaW5nID8gV2QoXCJlbnZNYXBUZXhlbFRvTGluZWFyXCIsXHJcbiAgICAgICAgICAgIGQuZW52TWFwRW5jb2RpbmcpIDogXCJcIiwgZC5lbWlzc2l2ZU1hcEVuY29kaW5nID8gV2QoXCJlbWlzc2l2ZU1hcFRleGVsVG9MaW5lYXJcIiwgZC5lbWlzc2l2ZU1hcEVuY29kaW5nKSA6IFwiXCIsIGQub3V0cHV0RW5jb2RpbmcgPyBHZihcImxpbmVhclRvT3V0cHV0VGV4ZWxcIiwgZC5vdXRwdXRFbmNvZGluZykgOiBcIlwiLCBkLmRlcHRoUGFja2luZyA/IFwiI2RlZmluZSBERVBUSF9QQUNLSU5HIFwiICsgYy5kZXB0aFBhY2tpbmcgOiBcIlwiLCBcIlxcblwiXS5maWx0ZXIoQmMpLmpvaW4oXCJcXG5cIikpO1xyXG4gICAgICAgIGggPSBYZChoLCBkKTtcclxuICAgICAgICBoID0gUGUoaCwgZCk7XHJcbiAgICAgICAgbSA9IFhkKG0sIGQpO1xyXG4gICAgICAgIG0gPSBQZShtLCBkKTtcclxuICAgICAgICBjLmlzU2hhZGVyTWF0ZXJpYWwgfHwgKGggPSBRZShoKSwgbSA9IFFlKG0pKTtcclxuICAgICAgICBtID0gayArIG07XHJcbiAgICAgICAgaCA9IE5lKGUsIGUuVkVSVEVYX1NIQURFUiwgZyArIGgpO1xyXG4gICAgICAgIG0gPSBOZShlLCBlLkZSQUdNRU5UX1NIQURFUiwgbSk7XHJcbiAgICAgICAgZS5hdHRhY2hTaGFkZXIociwgaCk7XHJcbiAgICAgICAgZS5hdHRhY2hTaGFkZXIociwgbSk7XHJcbiAgICAgICAgdm9pZCAwICE9PSBjLmluZGV4MEF0dHJpYnV0ZU5hbWUgPyBlLmJpbmRBdHRyaWJMb2NhdGlvbihyLCAwLCBjLmluZGV4MEF0dHJpYnV0ZU5hbWUpIDpcclxuICAgICAgICAgICAgITAgPT09IGQubW9ycGhUYXJnZXRzICYmIGUuYmluZEF0dHJpYkxvY2F0aW9uKHIsIDAsIFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgZS5saW5rUHJvZ3JhbShyKTtcclxuICAgICAgICBkID0gZS5nZXRQcm9ncmFtSW5mb0xvZyhyKTtcclxuICAgICAgICB0ID0gZS5nZXRTaGFkZXJJbmZvTG9nKGgpO1xyXG4gICAgICAgIHAgPSBlLmdldFNoYWRlckluZm9Mb2cobSk7XHJcbiAgICAgICAgdSA9IG4gPSAhMDtcclxuICAgICAgICBpZiAoITEgPT09IGUuZ2V0UHJvZ3JhbVBhcmFtZXRlcihyLCBlLkxJTktfU1RBVFVTKSkgbiA9ICExLCBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBzaGFkZXIgZXJyb3I6IFwiLCBlLmdldEVycm9yKCksIFwiZ2wuVkFMSURBVEVfU1RBVFVTXCIsIGUuZ2V0UHJvZ3JhbVBhcmFtZXRlcihyLCBlLlZBTElEQVRFX1NUQVRVUyksIFwiZ2wuZ2V0UHJvZ3JhbUluZm9Mb2dcIiwgZCwgdCwgcCk7IGVsc2UgaWYgKFwiXCIgIT09IGQpIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUHJvZ3JhbTogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKVwiLCBkKTsgZWxzZSBpZiAoXCJcIiA9PT0gdCB8fCBcIlwiID09PSBwKSB1ID0gITE7XHJcbiAgICAgICAgdSAmJiAodGhpcy5kaWFnbm9zdGljcyA9IHtcclxuICAgICAgICAgICAgcnVubmFibGU6IG4sXHJcbiAgICAgICAgICAgIG1hdGVyaWFsOiBjLCBwcm9ncmFtTG9nOiBkLCB2ZXJ0ZXhTaGFkZXI6IHtsb2c6IHQsIHByZWZpeDogZ30sIGZyYWdtZW50U2hhZGVyOiB7bG9nOiBwLCBwcmVmaXg6IGt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZS5kZWxldGVTaGFkZXIoaCk7XHJcbiAgICAgICAgZS5kZWxldGVTaGFkZXIobSk7XHJcbiAgICAgICAgdmFyIHE7XHJcbiAgICAgICAgdGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBxICYmIChxID0gbmV3ICRhKGUsIHIsIGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB3O1xyXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IHt9LCBiID0gZS5nZXRQcm9ncmFtUGFyYW1ldGVyKHIsIGUuQUNUSVZFX0FUVFJJQlVURVMpLCBjID0gMDsgYyA8IGI7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gZS5nZXRBY3RpdmVBdHRyaWIociwgYykubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBhW2RdID0gZS5nZXRBdHRyaWJMb2NhdGlvbihyLCBkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdyA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gd1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBlLmRlbGV0ZVByb2dyYW0ocik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IHZvaWQgMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pZCA9IExmKys7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gYjtcclxuICAgICAgICB0aGlzLnVzZWRUaW1lcyA9IDE7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcjtcclxuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IGg7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IG07XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBNZihhLCBiKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYyhhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICBhID8gYS5pc1RleHR1cmUgPyBjID0gYS5lbmNvZGluZyA6IGEuaXNXZWJHTFJlbmRlclRhcmdldCAmJiAoY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xQcm9ncmFtcy5nZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlwiKSwgYyA9XHJcbiAgICAgICAgICAgICAgICAgICAgYS50ZXh0dXJlLmVuY29kaW5nKSA6IGMgPSAzRTM7XHJcbiAgICAgICAgICAgIDNFMyA9PT0gYyAmJiBiICYmIChjID0gMzAwNyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZCA9IFtdLCBlID0ge1xyXG4gICAgICAgICAgICAgICAgTWVzaERlcHRoTWF0ZXJpYWw6IFwiZGVwdGhcIixcclxuICAgICAgICAgICAgICAgIE1lc2hOb3JtYWxNYXRlcmlhbDogXCJub3JtYWxcIixcclxuICAgICAgICAgICAgICAgIE1lc2hCYXNpY01hdGVyaWFsOiBcImJhc2ljXCIsXHJcbiAgICAgICAgICAgICAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiBcImxhbWJlcnRcIixcclxuICAgICAgICAgICAgICAgIE1lc2hQaG9uZ01hdGVyaWFsOiBcInBob25nXCIsXHJcbiAgICAgICAgICAgICAgICBNZXNoVG9vbk1hdGVyaWFsOiBcInBob25nXCIsXHJcbiAgICAgICAgICAgICAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogXCJwaHlzaWNhbFwiLFxyXG4gICAgICAgICAgICAgICAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6IFwicGh5c2ljYWxcIixcclxuICAgICAgICAgICAgICAgIExpbmVCYXNpY01hdGVyaWFsOiBcImJhc2ljXCIsXHJcbiAgICAgICAgICAgICAgICBMaW5lRGFzaGVkTWF0ZXJpYWw6IFwiZGFzaGVkXCIsXHJcbiAgICAgICAgICAgICAgICBQb2ludHNNYXRlcmlhbDogXCJwb2ludHNcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmID0gXCJwcmVjaXNpb24gc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyBtYXAgbWFwRW5jb2RpbmcgZW52TWFwIGVudk1hcE1vZGUgZW52TWFwRW5jb2RpbmcgbGlnaHRNYXAgYW9NYXAgZW1pc3NpdmVNYXAgZW1pc3NpdmVNYXBFbmNvZGluZyBidW1wTWFwIG5vcm1hbE1hcCBkaXNwbGFjZW1lbnRNYXAgc3BlY3VsYXJNYXAgcm91Z2huZXNzTWFwIG1ldGFsbmVzc01hcCBncmFkaWVudE1hcCBhbHBoYU1hcCBjb21iaW5lIHZlcnRleENvbG9ycyBmb2cgdXNlRm9nIGZvZ0V4cCBmbGF0U2hhZGluZyBzaXplQXR0ZW51YXRpb24gbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciBza2lubmluZyBtYXhCb25lcyB1c2VWZXJ0ZXhUZXh0dXJlIG1vcnBoVGFyZ2V0cyBtb3JwaE5vcm1hbHMgbWF4TW9ycGhUYXJnZXRzIG1heE1vcnBoTm9ybWFscyBwcmVtdWx0aXBsaWVkQWxwaGEgbnVtRGlyTGlnaHRzIG51bVBvaW50TGlnaHRzIG51bVNwb3RMaWdodHMgbnVtSGVtaUxpZ2h0cyBudW1SZWN0QXJlYUxpZ2h0cyBzaGFkb3dNYXBFbmFibGVkIHNoYWRvd01hcFR5cGUgdG9uZU1hcHBpbmcgcGh5c2ljYWxseUNvcnJlY3RMaWdodHMgYWxwaGFUZXN0IGRvdWJsZVNpZGVkIGZsaXBTaWRlZCBudW1DbGlwcGluZ1BsYW5lcyBudW1DbGlwSW50ZXJzZWN0aW9uIGRlcHRoUGFja2luZ1wiLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICB0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZCwgZiwgbSwgaywgdCwgcCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IGVbZC50eXBlXSwgdTtcclxuICAgICAgICAgICAgYi5mbG9hdFZlcnRleFRleHR1cmVzICYmIHAgJiYgcC5za2VsZXRvbiAmJiBwLnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgPyB1ID0gMTAyNCA6ICh1ID0gTWF0aC5mbG9vcigoYi5tYXhWZXJ0ZXhVbmlmb3JtcyAtIDIwKSAvIDQpLCB2b2lkIDAgIT09IHAgJiYgcCAmJiBwLmlzU2tpbm5lZE1lc2ggJiYgKHUgPSBNYXRoLm1pbihwLnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgdSksIHUgPCBwLnNrZWxldG9uLmJvbmVzLmxlbmd0aCAmJiBjb25zb2xlLndhcm4oXCJXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtIFwiICsgcC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyBcIiwgdGhpcyBHUFUgc3VwcG9ydHMganVzdCBcIiArIHUgKyBcIiAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKVwiKSkpO1xyXG4gICAgICAgICAgICB2YXIgbCA9IGEuZ2V0UHJlY2lzaW9uKCk7XHJcbiAgICAgICAgICAgIG51bGwgIT09IGQucHJlY2lzaW9uICYmIChsID0gYi5nZXRNYXhQcmVjaXNpb24oZC5wcmVjaXNpb24pLCBsICE9PSBkLnByZWNpc2lvbiAmJlxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczpcIiwgZC5wcmVjaXNpb24sIFwibm90IHN1cHBvcnRlZCwgdXNpbmdcIiwgbCwgXCJpbnN0ZWFkLlwiKSk7XHJcbiAgICAgICAgICAgIHZhciByID0gYS5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzaGFkZXJJRDogbixcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbCxcclxuICAgICAgICAgICAgICAgIHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGIudmVydGV4VGV4dHVyZXMsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZzogYyhyID8gci50ZXh0dXJlIDogbnVsbCwgYS5nYW1tYU91dHB1dCksXHJcbiAgICAgICAgICAgICAgICBtYXA6ICEhZC5tYXAsXHJcbiAgICAgICAgICAgICAgICBtYXBFbmNvZGluZzogYyhkLm1hcCwgYS5nYW1tYUlucHV0KSxcclxuICAgICAgICAgICAgICAgIGVudk1hcDogISFkLmVudk1hcCxcclxuICAgICAgICAgICAgICAgIGVudk1hcE1vZGU6IGQuZW52TWFwICYmIGQuZW52TWFwLm1hcHBpbmcsXHJcbiAgICAgICAgICAgICAgICBlbnZNYXBFbmNvZGluZzogYyhkLmVudk1hcCwgYS5nYW1tYUlucHV0KSxcclxuICAgICAgICAgICAgICAgIGVudk1hcEN1YmVVVjogISFkLmVudk1hcCAmJiAoMzA2ID09PSBkLmVudk1hcC5tYXBwaW5nIHx8IDMwNyA9PT0gZC5lbnZNYXAubWFwcGluZyksXHJcbiAgICAgICAgICAgICAgICBsaWdodE1hcDogISFkLmxpZ2h0TWFwLFxyXG4gICAgICAgICAgICAgICAgYW9NYXA6ICEhZC5hb01hcCxcclxuICAgICAgICAgICAgICAgIGVtaXNzaXZlTWFwOiAhIWQuZW1pc3NpdmVNYXAsXHJcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZU1hcEVuY29kaW5nOiBjKGQuZW1pc3NpdmVNYXAsIGEuZ2FtbWFJbnB1dCksXHJcbiAgICAgICAgICAgICAgICBidW1wTWFwOiAhIWQuYnVtcE1hcCxcclxuICAgICAgICAgICAgICAgIG5vcm1hbE1hcDogISFkLm5vcm1hbE1hcCxcclxuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudE1hcDogISFkLmRpc3BsYWNlbWVudE1hcCxcclxuICAgICAgICAgICAgICAgIHJvdWdobmVzc01hcDogISFkLnJvdWdobmVzc01hcCxcclxuICAgICAgICAgICAgICAgIG1ldGFsbmVzc01hcDogISFkLm1ldGFsbmVzc01hcCxcclxuICAgICAgICAgICAgICAgIHNwZWN1bGFyTWFwOiAhIWQuc3BlY3VsYXJNYXAsXHJcbiAgICAgICAgICAgICAgICBhbHBoYU1hcDogISFkLmFscGhhTWFwLFxyXG4gICAgICAgICAgICAgICAgZ3JhZGllbnRNYXA6ICEhZC5ncmFkaWVudE1hcCxcclxuICAgICAgICAgICAgICAgIGNvbWJpbmU6IGQuY29tYmluZSxcclxuICAgICAgICAgICAgICAgIHZlcnRleENvbG9yczogZC52ZXJ0ZXhDb2xvcnMsXHJcbiAgICAgICAgICAgICAgICBmb2c6ICEhbSxcclxuICAgICAgICAgICAgICAgIHVzZUZvZzogZC5mb2csXHJcbiAgICAgICAgICAgICAgICBmb2dFeHA6IG0gJiYgbS5pc0ZvZ0V4cDIsXHJcbiAgICAgICAgICAgICAgICBmbGF0U2hhZGluZzogMSA9PT0gZC5zaGFkaW5nLFxyXG4gICAgICAgICAgICAgICAgc2l6ZUF0dGVudWF0aW9uOiBkLnNpemVBdHRlbnVhdGlvbixcclxuICAgICAgICAgICAgICAgIGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcclxuICAgICAgICAgICAgICAgIHNraW5uaW5nOiBkLnNraW5uaW5nLFxyXG4gICAgICAgICAgICAgICAgbWF4Qm9uZXM6IHUsXHJcbiAgICAgICAgICAgICAgICB1c2VWZXJ0ZXhUZXh0dXJlOiBiLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgcCAmJiBwLnNrZWxldG9uICYmIHAuc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcclxuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0czogZC5tb3JwaFRhcmdldHMsXHJcbiAgICAgICAgICAgICAgICBtb3JwaE5vcm1hbHM6IGQubW9ycGhOb3JtYWxzLFxyXG4gICAgICAgICAgICAgICAgbWF4TW9ycGhUYXJnZXRzOiBhLm1heE1vcnBoVGFyZ2V0cyxcclxuICAgICAgICAgICAgICAgIG1heE1vcnBoTm9ybWFsczogYS5tYXhNb3JwaE5vcm1hbHMsXHJcbiAgICAgICAgICAgICAgICBudW1EaXJMaWdodHM6IGYuZGlyZWN0aW9uYWwubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbnVtUG9pbnRMaWdodHM6IGYucG9pbnQubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbnVtU3BvdExpZ2h0czogZi5zcG90Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG51bVJlY3RBcmVhTGlnaHRzOiBmLnJlY3RBcmVhLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG51bUhlbWlMaWdodHM6IGYuaGVtaS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBudW1DbGlwcGluZ1BsYW5lczogayxcclxuICAgICAgICAgICAgICAgIG51bUNsaXBJbnRlcnNlY3Rpb246IHQsXHJcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXBFbmFibGVkOiBhLnNoYWRvd01hcC5lbmFibGVkICYmIHAucmVjZWl2ZVNoYWRvdyAmJiAwIDwgZi5zaGFkb3dzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHNoYWRvd01hcFR5cGU6IGEuc2hhZG93TWFwLnR5cGUsXHJcbiAgICAgICAgICAgICAgICB0b25lTWFwcGluZzogYS50b25lTWFwcGluZyxcclxuICAgICAgICAgICAgICAgIHBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzOiBhLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzLFxyXG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBkLnByZW11bHRpcGxpZWRBbHBoYSxcclxuICAgICAgICAgICAgICAgIGFscGhhVGVzdDogZC5hbHBoYVRlc3QsXHJcbiAgICAgICAgICAgICAgICBkb3VibGVTaWRlZDogMiA9PT0gZC5zaWRlLFxyXG4gICAgICAgICAgICAgICAgZmxpcFNpZGVkOiAxID09PSBkLnNpZGUsXHJcbiAgICAgICAgICAgICAgICBkZXB0aFBhY2tpbmc6IHZvaWQgMCAhPT0gZC5kZXB0aFBhY2tpbmcgPyBkLmRlcHRoUGFja2luZyA6ICExXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0UHJvZ3JhbUNvZGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IFtdO1xyXG4gICAgICAgICAgICBiLnNoYWRlcklEID8gYy5wdXNoKGIuc2hhZGVySUQpIDogKGMucHVzaChhLmZyYWdtZW50U2hhZGVyKSwgYy5wdXNoKGEudmVydGV4U2hhZGVyKSk7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGEuZGVmaW5lcylmb3IgKHZhciBkIGluIGEuZGVmaW5lcyljLnB1c2goZCksIGMucHVzaChhLmRlZmluZXNbZF0pO1xyXG4gICAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgZi5sZW5ndGg7IGQrKyljLnB1c2goYltmW2RdXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjLmpvaW4oKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hY3F1aXJlUHJvZ3JhbSA9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChiLCBjLCBlKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmLCB0ID0gMCwgcCA9IGQubGVuZ3RoOyB0IDwgcDsgdCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBkW3RdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLmNvZGUgPT09IGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrZi51c2VkVGltZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBmICYmIChmID0gbmV3IEtmKGEsIGUsIGIsIGMpLCBkLnB1c2goZikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlbGVhc2VQcm9ncmFtID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKDAgPT09IC0tYS51c2VkVGltZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gZC5pbmRleE9mKGEpO1xyXG4gICAgICAgICAgICAgICAgZFtiXSA9IGRbZC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBhLmRlc3Ryb3koKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnByb2dyYW1zID0gZFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE5mKGEsIGIsIGMpIHtcclxuICAgICAgICBmdW5jdGlvbiBkKGEpIHtcclxuICAgICAgICAgICAgdmFyIGggPSBhLnRhcmdldDtcclxuICAgICAgICAgICAgYSA9IGZbaC5pZF07XHJcbiAgICAgICAgICAgIG51bGwgIT09IGEuaW5kZXggJiYgZShhLmluZGV4KTtcclxuICAgICAgICAgICAgdmFyIG0gPSBhLmF0dHJpYnV0ZXMsIGs7XHJcbiAgICAgICAgICAgIGZvciAoayBpbiBtKWUobVtrXSk7XHJcbiAgICAgICAgICAgIGgucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIiwgZCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBmW2guaWRdO1xyXG4gICAgICAgICAgICBrID0gYi5nZXQoaCk7XHJcbiAgICAgICAgICAgIGsud2lyZWZyYW1lICYmIGUoay53aXJlZnJhbWUpO1xyXG4gICAgICAgICAgICBiW1wiZGVsZXRlXCJdKGgpO1xyXG4gICAgICAgICAgICBoID0gYi5nZXQoYSk7XHJcbiAgICAgICAgICAgIGgud2lyZWZyYW1lICYmIGUoaC53aXJlZnJhbWUpO1xyXG4gICAgICAgICAgICBiW1wiZGVsZXRlXCJdKGEpO1xyXG4gICAgICAgICAgICBjLm1lbW9yeS5nZW9tZXRyaWVzLS1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGUoYykge1xyXG4gICAgICAgICAgICB2YXIgZDtcclxuICAgICAgICAgICAgZCA9IGMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGIuZ2V0KGMuZGF0YSkuX193ZWJnbEJ1ZmZlciA6IGIuZ2V0KGMpLl9fd2ViZ2xCdWZmZXI7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gZCAmJiAoYS5kZWxldGVCdWZmZXIoZCksIGMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGJbXCJkZWxldGVcIl0oYy5kYXRhKSA6IGJbXCJkZWxldGVcIl0oYykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZiA9IHt9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYS5nZW9tZXRyeTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZbYi5pZF0pcmV0dXJuIGZbYi5pZF07XHJcbiAgICAgICAgICAgICAgICBiLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIGQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGU7XHJcbiAgICAgICAgICAgICAgICBiLmlzQnVmZmVyR2VvbWV0cnkgPyBlID0gYiA6IGIuaXNHZW9tZXRyeSAmJiAodm9pZCAwID09PSBiLl9idWZmZXJHZW9tZXRyeSAmJiAoYi5fYnVmZmVyR2VvbWV0cnkgPSAobmV3IEkpLnNldEZyb21PYmplY3QoYSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gYi5fYnVmZmVyR2VvbWV0cnkpO1xyXG4gICAgICAgICAgICAgICAgZltiLmlkXSA9IGU7XHJcbiAgICAgICAgICAgICAgICBjLm1lbW9yeS5nZW9tZXRyaWVzKys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE9mKGEsIGIsIGMpIHtcclxuICAgICAgICBmdW5jdGlvbiBkKGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSBjLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPyBjLmRhdGEgOiBjLCBtID0gYi5nZXQoZSk7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IG0uX193ZWJnbEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgbS5fX3dlYmdsQnVmZmVyID0gYS5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIGEuYmluZEJ1ZmZlcihkLCBtLl9fd2ViZ2xCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgYS5idWZmZXJEYXRhKGQsIGUuYXJyYXksIGUuZHluYW1pYyA/IGEuRFlOQU1JQ19EUkFXIDogYS5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IGEuRkxPQVQsIHQgPSBlLmFycmF5O1xyXG4gICAgICAgICAgICAgICAgdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IGsgPSBhLkZMT0FUIDogdCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSA/IGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIGRhdGEgYnVmZmVyIGZvcm1hdDogRmxvYXQ2NEFycmF5XCIpIDogdCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ID8gayA9IGEuVU5TSUdORURfU0hPUlQgOlxyXG4gICAgICAgICAgICAgICAgICAgIHQgaW5zdGFuY2VvZiBJbnQxNkFycmF5ID8gayA9IGEuU0hPUlQgOiB0IGluc3RhbmNlb2YgVWludDMyQXJyYXkgPyBrID0gYS5VTlNJR05FRF9JTlQgOiB0IGluc3RhbmNlb2YgSW50MzJBcnJheSA/IGsgPSBhLklOVCA6IHQgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgPyBrID0gYS5CWVRFIDogdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgKGsgPSBhLlVOU0lHTkVEX0JZVEUpO1xyXG4gICAgICAgICAgICAgICAgbS5ieXRlc1BlckVsZW1lbnQgPSB0LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgbS50eXBlID0gaztcclxuICAgICAgICAgICAgICAgIG0udmVyc2lvbiA9IGUudmVyc2lvbjtcclxuICAgICAgICAgICAgICAgIGUub25VcGxvYWRDYWxsYmFjaygpXHJcbiAgICAgICAgICAgIH0gZWxzZSBtLnZlcnNpb24gIT09IGUudmVyc2lvbiAmJiAoYS5iaW5kQnVmZmVyKGQsIG0uX193ZWJnbEJ1ZmZlciksICExID09PSBlLmR5bmFtaWMgPyBhLmJ1ZmZlckRhdGEoZCwgZS5hcnJheSwgYS5TVEFUSUNfRFJBVykgOiAtMSA9PT0gZS51cGRhdGVSYW5nZS5jb3VudCA/IGEuYnVmZmVyU3ViRGF0YShkLCAwLCBlLmFycmF5KSA6IDAgPT09IGUudXBkYXRlUmFuZ2UuY291bnQgPyBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xPYmplY3RzLnVwZGF0ZUJ1ZmZlcjogZHluYW1pYyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCB1cGRhdGVSYW5nZS5jb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS5cIikgOlxyXG4gICAgICAgICAgICAgICAgKGEuYnVmZmVyU3ViRGF0YShkLCBlLnVwZGF0ZVJhbmdlLm9mZnNldCAqIGUuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIGUuYXJyYXkuc3ViYXJyYXkoZS51cGRhdGVSYW5nZS5vZmZzZXQsIGUudXBkYXRlUmFuZ2Uub2Zmc2V0ICsgZS51cGRhdGVSYW5nZS5jb3VudCkpLCBlLnVwZGF0ZVJhbmdlLmNvdW50ID0gMCksIG0udmVyc2lvbiA9IGUudmVyc2lvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBlID0gbmV3IE5mKGEsIGIsIGMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldEF0dHJpYnV0ZUJ1ZmZlcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPyBiLmdldChhLmRhdGEpLl9fd2ViZ2xCdWZmZXIgOiBiLmdldChhKS5fX3dlYmdsQnVmZmVyXHJcbiAgICAgICAgICAgIH0sIGdldEF0dHJpYnV0ZVByb3BlcnRpZXM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gYi5nZXQoYS5kYXRhKSA6IGIuZ2V0KGEpXHJcbiAgICAgICAgICAgIH0sIGdldFdpcmVmcmFtZUF0dHJpYnV0ZTogZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gYi5nZXQoYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBlLndpcmVmcmFtZSlyZXR1cm4gZS53aXJlZnJhbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IFtdLCBtID0gYy5pbmRleDtcclxuICAgICAgICAgICAgICAgIGMgPSBjLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBtLmFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBtLmxlbmd0aDsgYyA8IGs7IGMgKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG1bYyArIDBdLCBwID0gbVtjICsgMV0sIG4gPSBtW2MgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaC5wdXNoKHQsIHAsIHAsIG4sIG4sIHQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGZvciAobSA9IGMucG9zaXRpb24uYXJyYXksIGMgPSAwLCBrID0gbS5sZW5ndGggLyAzIC0gMTsgYyA8IGs7IGMgKz0gMyl0ID0gYyArIDAsIHAgPSBjICsgMSwgbiA9IGMgKyAyLCBoLnB1c2godCwgcCwgcCwgbiwgbiwgdCk7XHJcbiAgICAgICAgICAgICAgICBoID0gbmV3ICg2NTUzNSA8IFVkKGgpID8gamIgOiBpYikoaCwgMSk7XHJcbiAgICAgICAgICAgICAgICBkKGgsIGEuRUxFTUVOVF9BUlJBWV9CVUZGRVIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUud2lyZWZyYW1lID0gaFxyXG4gICAgICAgICAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGUuZ2V0KGIpO1xyXG4gICAgICAgICAgICAgICAgYi5nZW9tZXRyeS5pc0dlb21ldHJ5ICYmIGMudXBkYXRlRnJvbU9iamVjdChiKTtcclxuICAgICAgICAgICAgICAgIGIgPSBjLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBjLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICBudWxsICE9PSBiICYmIGQoYiwgYS5FTEVNRU5UX0FSUkFZX0JVRkZFUik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIGgpZChoW21dLCBhLkFSUkFZX0JVRkZFUik7XHJcbiAgICAgICAgICAgICAgICBiID0gYy5tb3JwaEF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKG0gaW4gYilmb3IgKHZhciBoID0gYlttXSwgayA9IDAsIHQgPSBoLmxlbmd0aDsgayA8IHQ7IGsrKylkKGhba10sIGEuQVJSQVlfQlVGRkVSKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUGYoYSwgYiwgYywgZCwgZSwgZiwgZykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGgoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAoYS53aWR0aCA+IGIgfHwgYS5oZWlnaHQgPiBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGIgLyBNYXRoLm1heChhLndpZHRoLCBhLmhlaWdodCksXHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJjYW52YXNcIik7XHJcbiAgICAgICAgICAgICAgICBkLndpZHRoID0gTWF0aC5mbG9vcihhLndpZHRoICogYyk7XHJcbiAgICAgICAgICAgICAgICBkLmhlaWdodCA9IE1hdGguZmxvb3IoYS5oZWlnaHQgKiBjKTtcclxuICAgICAgICAgICAgICAgIGQuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZShhLCAwLCAwLCBhLndpZHRoLCBhLmhlaWdodCwgMCwgMCwgZC53aWR0aCwgZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgdG9vIGJpZyAoXCIgKyBhLndpZHRoICsgXCJ4XCIgKyBhLmhlaWdodCArIFwiKS4gUmVzaXplZCB0byBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgZC53aWR0aCArIFwieFwiICsgZC5oZWlnaHQsIGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbShhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOLmlzUG93ZXJPZlR3byhhLndpZHRoKSAmJiBOLmlzUG93ZXJPZlR3byhhLmhlaWdodClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGsoYikge1xyXG4gICAgICAgICAgICByZXR1cm4gMTAwMyA9PT0gYiB8fCAxMDA0ID09PSBiIHx8IDEwMDUgPT09IGIgPyBhLk5FQVJFU1QgOiBhLkxJTkVBUlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdChiKSB7XHJcbiAgICAgICAgICAgIGIgPSBiLnRhcmdldDtcclxuICAgICAgICAgICAgYi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCB0KTtcclxuICAgICAgICAgICAgYTp7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGQuZ2V0KGIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGIuaW1hZ2UgJiYgYy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlKSBhLmRlbGV0ZVRleHR1cmUoYy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYy5fX3dlYmdsSW5pdClicmVhayBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZGVsZXRlVGV4dHVyZShjLl9fd2ViZ2xUZXh0dXJlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZFtcImRlbGV0ZVwiXShiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHEudGV4dHVyZXMtLVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcChiKSB7XHJcbiAgICAgICAgICAgIGIgPSBiLnRhcmdldDtcclxuICAgICAgICAgICAgYi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLFxyXG4gICAgICAgICAgICAgICAgcCk7XHJcbiAgICAgICAgICAgIHZhciBjID0gZC5nZXQoYiksIGUgPSBkLmdldChiLnRleHR1cmUpO1xyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBlLl9fd2ViZ2xUZXh0dXJlICYmIGEuZGVsZXRlVGV4dHVyZShlLl9fd2ViZ2xUZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIGIuZGVwdGhUZXh0dXJlICYmIGIuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChiLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlKWZvciAoZSA9IDA7IDYgPiBlOyBlKyspYS5kZWxldGVGcmFtZWJ1ZmZlcihjLl9fd2ViZ2xGcmFtZWJ1ZmZlcltlXSksIGMuX193ZWJnbERlcHRoYnVmZmVyICYmIGEuZGVsZXRlUmVuZGVyYnVmZmVyKGMuX193ZWJnbERlcHRoYnVmZmVyW2VdKTsgZWxzZSBhLmRlbGV0ZUZyYW1lYnVmZmVyKGMuX193ZWJnbEZyYW1lYnVmZmVyKSwgYy5fX3dlYmdsRGVwdGhidWZmZXIgJiYgYS5kZWxldGVSZW5kZXJidWZmZXIoYy5fX3dlYmdsRGVwdGhidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgZFtcImRlbGV0ZVwiXShiLnRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgZFtcImRlbGV0ZVwiXShiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHEudGV4dHVyZXMtLVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbihiLCBnKSB7XHJcbiAgICAgICAgICAgIHZhciBrID0gZC5nZXQoYik7XHJcbiAgICAgICAgICAgIGlmICgwIDxcclxuICAgICAgICAgICAgICAgIGIudmVyc2lvbiAmJiBrLl9fdmVyc2lvbiAhPT0gYi52ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGIuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBuKSBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWRcIiwgYik7IGVsc2UgaWYgKCExID09PSBuLmNvbXBsZXRlKSBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlXCIsIGIpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGsuX193ZWJnbEluaXQgJiYgKGsuX193ZWJnbEluaXQgPSAhMCwgYi5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCB0KSwgay5fX3dlYmdsVGV4dHVyZSA9IGEuY3JlYXRlVGV4dHVyZSgpLCBxLnRleHR1cmVzKyspO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuYWN0aXZlVGV4dHVyZShhLlRFWFRVUkUwICsgZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5iaW5kVGV4dHVyZShhLlRFWFRVUkVfMkQsIGsuX193ZWJnbFRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEucGl4ZWxTdG9yZWkoYS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmZsaXBZKTtcclxuICAgICAgICAgICAgICAgICAgICBhLnBpeGVsU3RvcmVpKGEuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiLnByZW11bHRpcGx5QWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEucGl4ZWxTdG9yZWkoYS5VTlBBQ0tfQUxJR05NRU5ULCBiLnVucGFja0FsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBoKGIuaW1hZ2UsIGUubWF4VGV4dHVyZVNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMTAwMSAhPT0gYi53cmFwUyB8fCAxMDAxICE9PSBiLndyYXBUIHx8IDEwMDMgIT09IGIubWluRmlsdGVyICYmIDEwMDYgIT09IGIubWluRmlsdGVyKSAmJiAhMSA9PT0gbShwKSlpZiAobiA9IHAsIG4gaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IG4gaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJjYW52YXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwud2lkdGggPSBOLm5lYXJlc3RQb3dlck9mVHdvKG4ud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsLmhlaWdodCA9IE4ubmVhcmVzdFBvd2VyT2ZUd28obi5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UobiwgMCwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwud2lkdGgsIGwuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgbm90IHBvd2VyIG9mIHR3byAoXCIgKyBuLndpZHRoICsgXCJ4XCIgKyBuLmhlaWdodCArIFwiKS4gUmVzaXplZCB0byBcIiArIGwud2lkdGggKyBcInhcIiArIGwuaGVpZ2h0LCBuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGxcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcCA9IG47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBtKHApLCBsID0gZihiLmZvcm1hdCksIEcgPSBmKGIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdShhLlRFWFRVUkVfMkQsIGIsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gYi5taXBtYXBzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLmlzRGVwdGhUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBhLkRFUFRIX0NPTVBPTkVOVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDEwMTUgPT09IGIudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3KXRocm93IEVycm9yKFwiRmxvYXQgRGVwdGggVGV4dHVyZSBvbmx5IHN1cHBvcnRlZCBpbiBXZWJHTDIuMFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBhLkRFUFRIX0NPTVBPTkVOVDMyRlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdyAmJiAociA9IGEuREVQVEhfQ09NUE9ORU5UMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDI2ID09PSBiLmZvcm1hdCAmJiByID09PSBhLkRFUFRIX0NPTVBPTkVOVCAmJiAxMDEyICE9PSBiLnR5cGUgJiYgMTAxNCAhPT0gYi50eXBlICYmIChjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBVc2UgVW5zaWduZWRTaG9ydFR5cGUgb3IgVW5zaWduZWRJbnRUeXBlIGZvciBEZXB0aEZvcm1hdCBEZXB0aFRleHR1cmUuXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi50eXBlID0gMTAxMiwgRyA9IGYoYi50eXBlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMjcgPT09IGIuZm9ybWF0ICYmIChyID0gYS5ERVBUSF9TVEVOQ0lMLCAxMDIwICE9PSBiLnR5cGUgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZEludDI0OFR5cGUgZm9yIERlcHRoU3RlbmNpbEZvcm1hdCBEZXB0aFRleHR1cmUuXCIpLCBiLnR5cGUgPSAxMDIwLCBHID0gZihiLnR5cGUpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMudGV4SW1hZ2UyRChhLlRFWFRVUkVfMkQsIDAsIHIsIHAud2lkdGgsIHAuaGVpZ2h0LCAwLCBsLCBHLCBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5pc0RhdGFUZXh0dXJlKWlmICgwIDwgci5sZW5ndGggJiYgbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBIID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWEgPSByLmxlbmd0aDsgSCA8IGFhOyBIKyspcCA9IHJbSF0sIGMudGV4SW1hZ2UyRChhLlRFWFRVUkVfMkQsIEgsIGwsIHAud2lkdGgsIHAuaGVpZ2h0LCAwLCBsLCBHLCBwLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmdlbmVyYXRlTWlwbWFwcyA9ICExXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGMudGV4SW1hZ2UyRChhLlRFWFRVUkVfMkQsIDAsIGwsIHAud2lkdGgsIHAuaGVpZ2h0LCAwLCBsLCBHLCBwLmRhdGEpOyBlbHNlIGlmIChiLmlzQ29tcHJlc3NlZFRleHR1cmUpZm9yIChIID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCBhYSA9IHIubGVuZ3RoOyBIIDwgYWE7IEgrKylwID0gcltIXSwgMTAyMyAhPT0gYi5mb3JtYXQgJiYgMTAyMiAhPT0gYi5mb3JtYXQgPyAtMSA8IGMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZihsKSA/IGMuY29tcHJlc3NlZFRleEltYWdlMkQoYS5URVhUVVJFXzJELCBILCBsLCBwLndpZHRoLCBwLmhlaWdodCwgMCwgcC5kYXRhKSA6IGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKClcIikgOiBjLnRleEltYWdlMkQoYS5URVhUVVJFXzJELCBILCBsLCBwLndpZHRoLCBwLmhlaWdodCwgMCwgbCwgRywgcC5kYXRhKTsgZWxzZSBpZiAoMCA8IHIubGVuZ3RoICYmIG4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgSCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYWEgPSByLmxlbmd0aDsgSCA8IGFhOyBIKyspcCA9IHJbSF0sIGMudGV4SW1hZ2UyRChhLlRFWFRVUkVfMkQsIEgsIGwsIGwsIEcsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmdlbmVyYXRlTWlwbWFwcyA9ICExXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGMudGV4SW1hZ2UyRChhLlRFWFRVUkVfMkQsIDAsIGwsIGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEcsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuZ2VuZXJhdGVNaXBtYXBzICYmIG4gJiYgYS5nZW5lcmF0ZU1pcG1hcChhLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsuX192ZXJzaW9uID0gYi52ZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLm9uVXBkYXRlKSBiLm9uVXBkYXRlKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGMuYWN0aXZlVGV4dHVyZShhLlRFWFRVUkUwICsgZyk7XHJcbiAgICAgICAgICAgIGMuYmluZFRleHR1cmUoYS5URVhUVVJFXzJELCBrLl9fd2ViZ2xUZXh0dXJlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdShjLCBnLCBoKSB7XHJcbiAgICAgICAgICAgIGggPyAoYS50ZXhQYXJhbWV0ZXJpKGMsIGEuVEVYVFVSRV9XUkFQX1MsIGYoZy53cmFwUykpLCBhLnRleFBhcmFtZXRlcmkoYywgYS5URVhUVVJFX1dSQVBfVCwgZihnLndyYXBUKSksIGEudGV4UGFyYW1ldGVyaShjLCBhLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZihnLm1hZ0ZpbHRlcikpLCBhLnRleFBhcmFtZXRlcmkoYywgYS5URVhUVVJFX01JTl9GSUxURVIsIGYoZy5taW5GaWx0ZXIpKSkgOiAoYS50ZXhQYXJhbWV0ZXJpKGMsIGEuVEVYVFVSRV9XUkFQX1MsIGEuQ0xBTVBfVE9fRURHRSksIGEudGV4UGFyYW1ldGVyaShjLCBhLlRFWFRVUkVfV1JBUF9ULFxyXG4gICAgICAgICAgICAgICAgYS5DTEFNUF9UT19FREdFKSwgMTAwMSA9PT0gZy53cmFwUyAmJiAxMDAxID09PSBnLndyYXBUIHx8IGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuXCIsIGcpLCBhLnRleFBhcmFtZXRlcmkoYywgYS5URVhUVVJFX01BR19GSUxURVIsIGsoZy5tYWdGaWx0ZXIpKSwgYS50ZXhQYXJhbWV0ZXJpKGMsIGEuVEVYVFVSRV9NSU5fRklMVEVSLCBrKGcubWluRmlsdGVyKSksIDEwMDMgIT09IGcubWluRmlsdGVyICYmIDEwMDYgIT09IGcubWluRmlsdGVyICYmIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci5cIiwgZykpO1xyXG4gICAgICAgICAgICAhKGggPSBiLmdldChcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSkgfHxcclxuICAgICAgICAgICAgMTAxNSA9PT0gZy50eXBlICYmIG51bGwgPT09IGIuZ2V0KFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpIHx8IDEwMTYgPT09IGcudHlwZSAmJiBudWxsID09PSBiLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpIHx8ICEoMSA8IGcuYW5pc290cm9weSB8fCBkLmdldChnKS5fX2N1cnJlbnRBbmlzb3Ryb3B5KSB8fCAoYS50ZXhQYXJhbWV0ZXJmKGMsIGguVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKGcuYW5pc290cm9weSwgZS5nZXRNYXhBbmlzb3Ryb3B5KCkpKSwgZC5nZXQoZykuX19jdXJyZW50QW5pc290cm9weSA9IGcuYW5pc290cm9weSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGwoYiwgZSwgZywgaCkge1xyXG4gICAgICAgICAgICB2YXIgbSA9IGYoZS50ZXh0dXJlLmZvcm1hdCksIGsgPSBmKGUudGV4dHVyZS50eXBlKTtcclxuICAgICAgICAgICAgYy50ZXhJbWFnZTJEKGgsIDAsIG0sIGUud2lkdGgsIGUuaGVpZ2h0LCAwLCBtLCBrLCBudWxsKTtcclxuICAgICAgICAgICAgYS5iaW5kRnJhbWVidWZmZXIoYS5GUkFNRUJVRkZFUiwgYik7XHJcbiAgICAgICAgICAgIGEuZnJhbWVidWZmZXJUZXh0dXJlMkQoYS5GUkFNRUJVRkZFUiwgZywgaCwgZC5nZXQoZS50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSxcclxuICAgICAgICAgICAgICAgIDApO1xyXG4gICAgICAgICAgICBhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLCBudWxsKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcihiLCBjKSB7XHJcbiAgICAgICAgICAgIGEuYmluZFJlbmRlcmJ1ZmZlcihhLlJFTkRFUkJVRkZFUiwgYik7XHJcbiAgICAgICAgICAgIGMuZGVwdGhCdWZmZXIgJiYgIWMuc3RlbmNpbEJ1ZmZlciA/IChhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsIGEuREVQVEhfQ09NUE9ORU5UMTYsIGMud2lkdGgsIGMuaGVpZ2h0KSwgYS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihhLkZSQU1FQlVGRkVSLCBhLkRFUFRIX0FUVEFDSE1FTlQsIGEuUkVOREVSQlVGRkVSLCBiKSkgOiBjLmRlcHRoQnVmZmVyICYmIGMuc3RlbmNpbEJ1ZmZlciA/IChhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsIGEuREVQVEhfU1RFTkNJTCwgYy53aWR0aCwgYy5oZWlnaHQpLCBhLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGEuRlJBTUVCVUZGRVIsIGEuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBhLlJFTkRFUkJVRkZFUiwgYikpIDogYS5yZW5kZXJidWZmZXJTdG9yYWdlKGEuUkVOREVSQlVGRkVSLFxyXG4gICAgICAgICAgICAgICAgYS5SR0JBNCwgYy53aWR0aCwgYy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBhLmJpbmRSZW5kZXJidWZmZXIoYS5SRU5ERVJCVUZGRVIsIG51bGwpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcSA9IGcubWVtb3J5LCB3ID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgJiYgYSBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlMkQgPSBuO1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBmdW5jdGlvbiAoYiwgZykge1xyXG4gICAgICAgICAgICB2YXIgayA9IGQuZ2V0KGIpO1xyXG4gICAgICAgICAgICBpZiAoNiA9PT0gYi5pbWFnZS5sZW5ndGgpaWYgKDAgPCBiLnZlcnNpb24gJiYgay5fX3ZlcnNpb24gIT09IGIudmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgay5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlIHx8IChiLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIHQpLCBrLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgPSBhLmNyZWF0ZVRleHR1cmUoKSwgcS50ZXh0dXJlcysrKTtcclxuICAgICAgICAgICAgICAgIGMuYWN0aXZlVGV4dHVyZShhLlRFWFRVUkUwICsgZyk7XHJcbiAgICAgICAgICAgICAgICBjLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV9DVUJFX01BUCwgay5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlKTtcclxuICAgICAgICAgICAgICAgIGEucGl4ZWxTdG9yZWkoYS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBiLmZsaXBZKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBiICYmIGIuaXNDb21wcmVzc2VkVGV4dHVyZSwgcCA9IGIuaW1hZ2VbMF0gJiYgYi5pbWFnZVswXS5pc0RhdGFUZXh0dXJlLCBsID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICByID0gMDsgNiA+IHI7IHIrKylsW3JdID0gbiB8fCBwID8gcCA/IGIuaW1hZ2Vbcl0uaW1hZ2UgOiBiLmltYWdlW3JdIDogaChiLmltYWdlW3JdLCBlLm1heEN1YmVtYXBTaXplKTtcclxuICAgICAgICAgICAgICAgIHZhciBHID0gbShsWzBdKSwgdyA9IGYoYi5mb3JtYXQpLCBhYSA9IGYoYi50eXBlKTtcclxuICAgICAgICAgICAgICAgIHUoYS5URVhUVVJFX0NVQkVfTUFQLCBiLCBHKTtcclxuICAgICAgICAgICAgICAgIGZvciAociA9IDA7IDYgPiByOyByKyspaWYgKG4pZm9yICh2YXIgeCwgRCA9IGxbcl0ubWlwbWFwcywgeiA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEgPSBELmxlbmd0aDsgeiA8IFE7IHorKyl4ID0gRFt6XSwgMTAyMyAhPT0gYi5mb3JtYXQgJiYgMTAyMiAhPT0gYi5mb3JtYXQgPyAtMSA8IGMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZih3KSA/IGMuY29tcHJlc3NlZFRleEltYWdlMkQoYS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyByLCB6LCB3LCB4LndpZHRoLCB4LmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAwLCB4LmRhdGEpIDogY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKClcIikgOiBjLnRleEltYWdlMkQoYS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyByLCB6LCB3LCB4LndpZHRoLCB4LmhlaWdodCwgMCwgdywgYWEsIHguZGF0YSk7IGVsc2UgcCA/IGMudGV4SW1hZ2UyRChhLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHIsIDAsIHcsIGxbcl0ud2lkdGgsIGxbcl0uaGVpZ2h0LCAwLCB3LCBhYSwgbFtyXS5kYXRhKSA6IGMudGV4SW1hZ2UyRChhLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHIsIDAsIHcsIHcsIGFhLCBsW3JdKTtcclxuICAgICAgICAgICAgICAgIGIuZ2VuZXJhdGVNaXBtYXBzICYmIEcgJiYgYS5nZW5lcmF0ZU1pcG1hcChhLlRFWFRVUkVfQ1VCRV9NQVApO1xyXG4gICAgICAgICAgICAgICAgay5fX3ZlcnNpb24gPSBiLnZlcnNpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoYi5vblVwZGF0ZSkgYi5vblVwZGF0ZShiKVxyXG4gICAgICAgICAgICB9IGVsc2UgYy5hY3RpdmVUZXh0dXJlKGEuVEVYVFVSRTAgK1xyXG4gICAgICAgICAgICAgICAgZyksIGMuYmluZFRleHR1cmUoYS5URVhUVVJFX0NVQkVfTUFQLCBrLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmVDdWJlRHluYW1pYyA9IGZ1bmN0aW9uIChiLCBlKSB7XHJcbiAgICAgICAgICAgIGMuYWN0aXZlVGV4dHVyZShhLlRFWFRVUkUwICsgZSk7XHJcbiAgICAgICAgICAgIGMuYmluZFRleHR1cmUoYS5URVhUVVJFX0NVQkVfTUFQLCBkLmdldChiKS5fX3dlYmdsVGV4dHVyZSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2V0dXBSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICB2YXIgZSA9IGQuZ2V0KGIpLCBmID0gZC5nZXQoYi50ZXh0dXJlKTtcclxuICAgICAgICAgICAgYi5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCBwKTtcclxuICAgICAgICAgICAgZi5fX3dlYmdsVGV4dHVyZSA9IGEuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICBxLnRleHR1cmVzKys7XHJcbiAgICAgICAgICAgIHZhciBnID0gITAgPT09IGIuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUsIGggPSBtKGIpO1xyXG4gICAgICAgICAgICBpZiAoZykge1xyXG4gICAgICAgICAgICAgICAgZS5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyA2ID4gazsgaysrKWUuX193ZWJnbEZyYW1lYnVmZmVyW2tdID0gYS5jcmVhdGVGcmFtZWJ1ZmZlcigpXHJcbiAgICAgICAgICAgIH0gZWxzZSBlLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9XHJcbiAgICAgICAgICAgICAgICBhLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChnKSB7XHJcbiAgICAgICAgICAgICAgICBjLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV9DVUJFX01BUCwgZi5fX3dlYmdsVGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB1KGEuVEVYVFVSRV9DVUJFX01BUCwgYi50ZXh0dXJlLCBoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IDYgPiBrOyBrKyspbChlLl9fd2ViZ2xGcmFtZWJ1ZmZlcltrXSwgYiwgYS5DT0xPUl9BVFRBQ0hNRU5UMCwgYS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBrKTtcclxuICAgICAgICAgICAgICAgIGIudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaCAmJiBhLmdlbmVyYXRlTWlwbWFwKGEuVEVYVFVSRV9DVUJFX01BUCk7XHJcbiAgICAgICAgICAgICAgICBjLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV9DVUJFX01BUCwgbnVsbClcclxuICAgICAgICAgICAgfSBlbHNlIGMuYmluZFRleHR1cmUoYS5URVhUVVJFXzJELCBmLl9fd2ViZ2xUZXh0dXJlKSwgdShhLlRFWFRVUkVfMkQsIGIudGV4dHVyZSwgaCksIGwoZS5fX3dlYmdsRnJhbWVidWZmZXIsIGIsIGEuQ09MT1JfQVRUQUNITUVOVDAsIGEuVEVYVFVSRV8yRCksIGIudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaCAmJiBhLmdlbmVyYXRlTWlwbWFwKGEuVEVYVFVSRV8yRCksXHJcbiAgICAgICAgICAgICAgICBjLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgICAgICAgIGlmIChiLmRlcHRoQnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gZC5nZXQoYik7XHJcbiAgICAgICAgICAgICAgICBmID0gITAgPT09IGIuaXNXZWJHTFJlbmRlclRhcmdldEN1YmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYi5kZXB0aFRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZil0aHJvdyBFcnJvcihcInRhcmdldC5kZXB0aFRleHR1cmUgbm90IHN1cHBvcnRlZCBpbiBDdWJlIHJlbmRlciB0YXJnZXRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiICYmIGIuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUpdGhyb3cgRXJyb3IoXCJEZXB0aCBUZXh0dXJlIHdpdGggY3ViZSByZW5kZXIgdGFyZ2V0cyBpcyBub3Qgc3VwcG9ydGVkIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLCBlLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiLmRlcHRoVGV4dHVyZSB8fCAhYi5kZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUpdGhyb3cgRXJyb3IoXCJyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRGVwdGhUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0KGIuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGIuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID09PSBiLndpZHRoICYmIGIuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9PT0gYi5oZWlnaHQgfHwgKGIuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gYi53aWR0aCwgYi5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gYi5oZWlnaHQsIGIuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlID0gITApO1xyXG4gICAgICAgICAgICAgICAgICAgIG4oYi5kZXB0aFRleHR1cmUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBkLmdldChiLmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEwMjYgPT09IGIuZGVwdGhUZXh0dXJlLmZvcm1hdCkgYS5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLkZSQU1FQlVGRkVSLCBhLkRFUFRIX0FUVEFDSE1FTlQsIGEuVEVYVFVSRV8yRCwgZSwgMCk7IGVsc2UgaWYgKDEwMjcgPT09IGIuZGVwdGhUZXh0dXJlLmZvcm1hdCkgYS5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLkZSQU1FQlVGRkVSLCBhLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgYS5URVhUVVJFXzJELCBlLCAwKTsgZWxzZSB0aHJvdyBFcnJvcihcIlVua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdFwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZilmb3IgKGUuX193ZWJnbERlcHRoYnVmZmVyID0gW10sIGYgPSAwOyA2ID4gZjsgZisrKWEuYmluZEZyYW1lYnVmZmVyKGEuRlJBTUVCVUZGRVIsIGUuX193ZWJnbEZyYW1lYnVmZmVyW2ZdKSwgZS5fX3dlYmdsRGVwdGhidWZmZXJbZl0gPSBhLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLCByKGUuX193ZWJnbERlcHRoYnVmZmVyW2ZdLCBiKTsgZWxzZSBhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLCBlLl9fd2ViZ2xGcmFtZWJ1ZmZlciksIGUuX193ZWJnbERlcHRoYnVmZmVyID0gYS5jcmVhdGVSZW5kZXJidWZmZXIoKSwgcihlLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgYik7XHJcbiAgICAgICAgICAgICAgICBhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLCBudWxsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gYi50ZXh0dXJlO1xyXG4gICAgICAgICAgICBlLmdlbmVyYXRlTWlwbWFwcyAmJiBtKGIpICYmIDEwMDMgIT09IGUubWluRmlsdGVyICYmIDEwMDYgIT09IGUubWluRmlsdGVyICYmIChiID0gYiAmJiBiLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID9cclxuICAgICAgICAgICAgICAgIGEuVEVYVFVSRV9DVUJFX01BUCA6IGEuVEVYVFVSRV8yRCwgZSA9IGQuZ2V0KGUpLl9fd2ViZ2xUZXh0dXJlLCBjLmJpbmRUZXh0dXJlKGIsIGUpLCBhLmdlbmVyYXRlTWlwbWFwKGIpLCBjLmJpbmRUZXh0dXJlKGIsIG51bGwpKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBRZigpIHtcclxuICAgICAgICB2YXIgYSA9IHt9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiLnV1aWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGFbYl07XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGMgJiYgKGMgPSB7fSwgYVtiXSA9IGMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNcclxuICAgICAgICAgICAgfSwgXCJkZWxldGVcIjogZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhW2IudXVpZF1cclxuICAgICAgICAgICAgfSwgY2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGEgPSB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFJmKGEsIGIsIGMpIHtcclxuICAgICAgICBmdW5jdGlvbiBkKGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgVWludDhBcnJheSg0KSwgZiA9IGEuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICBhLmJpbmRUZXh0dXJlKGIsIGYpO1xyXG4gICAgICAgICAgICBhLnRleFBhcmFtZXRlcmkoYiwgYS5URVhUVVJFX01JTl9GSUxURVIsIGEuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIGEudGV4UGFyYW1ldGVyaShiLCBhLlRFWFRVUkVfTUFHX0ZJTFRFUiwgYS5ORUFSRVNUKTtcclxuICAgICAgICAgICAgZm9yIChiID0gMDsgYiA8IGQ7IGIrKylhLnRleEltYWdlMkQoYyArXHJcbiAgICAgICAgICAgICAgICBiLCAwLCBhLlJHQkEsIDEsIDEsIDAsIGEuUkdCQSwgYS5VTlNJR05FRF9CWVRFLCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGUoYikge1xyXG4gICAgICAgICAgICAhMCAhPT0geVtiXSAmJiAoYS5lbmFibGUoYiksIHlbYl0gPSAhMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGYoYikge1xyXG4gICAgICAgICAgICAhMSAhPT0geVtiXSAmJiAoYS5kaXNhYmxlKGIpLCB5W2JdID0gITEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnKGIsIGQsIGcsIGgsIG0sIGssIG4sIHQpIHtcclxuICAgICAgICAgICAgMCAhPT0gYiA/IGUoYS5CTEVORCkgOiBmKGEuQkxFTkQpO1xyXG4gICAgICAgICAgICBpZiAoYiAhPT0gdiB8fCB0ICE9PSB4KSAyID09PSBiID8gdCA/IChhLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShhLkZVTkNfQURELCBhLkZVTkNfQUREKSwgYS5ibGVuZEZ1bmNTZXBhcmF0ZShhLk9ORSwgYS5PTkUsIGEuT05FLCBhLk9ORSkpIDogKGEuYmxlbmRFcXVhdGlvbihhLkZVTkNfQUREKSwgYS5ibGVuZEZ1bmMoYS5TUkNfQUxQSEEsIGEuT05FKSkgOiAzID09PSBiID8gdCA/IChhLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShhLkZVTkNfQURELCBhLkZVTkNfQUREKSwgYS5ibGVuZEZ1bmNTZXBhcmF0ZShhLlpFUk8sIGEuWkVSTywgYS5PTkVfTUlOVVNfU1JDX0NPTE9SLCBhLk9ORV9NSU5VU19TUkNfQUxQSEEpKSA6XHJcbiAgICAgICAgICAgICAgICAoYS5ibGVuZEVxdWF0aW9uKGEuRlVOQ19BREQpLCBhLmJsZW5kRnVuYyhhLlpFUk8sIGEuT05FX01JTlVTX1NSQ19DT0xPUikpIDogNCA9PT0gYiA/IHQgPyAoYS5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoYS5GVU5DX0FERCwgYS5GVU5DX0FERCksIGEuYmxlbmRGdW5jU2VwYXJhdGUoYS5aRVJPLCBhLlNSQ19DT0xPUiwgYS5aRVJPLCBhLlNSQ19BTFBIQSkpIDogKGEuYmxlbmRFcXVhdGlvbihhLkZVTkNfQUREKSwgYS5ibGVuZEZ1bmMoYS5aRVJPLCBhLlNSQ19DT0xPUikpIDogdCA/IChhLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShhLkZVTkNfQURELCBhLkZVTkNfQUREKSwgYS5ibGVuZEZ1bmNTZXBhcmF0ZShhLk9ORSwgYS5PTkVfTUlOVVNfU1JDX0FMUEhBLCBhLk9ORSwgYS5PTkVfTUlOVVNfU1JDX0FMUEhBKSkgOiAoYS5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoYS5GVU5DX0FERCwgYS5GVU5DX0FERCksIGEuYmxlbmRGdW5jU2VwYXJhdGUoYS5TUkNfQUxQSEEsIGEuT05FX01JTlVTX1NSQ19BTFBIQSwgYS5PTkUsIGEuT05FX01JTlVTX1NSQ19BTFBIQSkpLFxyXG4gICAgICAgICAgICAgICAgdiA9IGIsIHggPSB0O1xyXG4gICAgICAgICAgICBpZiAoNSA9PT0gYikge1xyXG4gICAgICAgICAgICAgICAgbSA9IG0gfHwgZDtcclxuICAgICAgICAgICAgICAgIGsgPSBrIHx8IGc7XHJcbiAgICAgICAgICAgICAgICBuID0gbiB8fCBoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgIT09IEUgfHwgbSAhPT0gRikgYS5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoYyhkKSwgYyhtKSksIEUgPSBkLCBGID0gbTtcclxuICAgICAgICAgICAgICAgIGlmIChnICE9PSBMIHx8IGggIT09IEMgfHwgayAhPT0gZGEgfHwgbiAhPT0gSCkgYS5ibGVuZEZ1bmNTZXBhcmF0ZShjKGcpLCBjKGgpLCBjKGspLCBjKG4pKSwgTCA9IGcsIEMgPSBoLCBkYSA9IGssIEggPSBuXHJcbiAgICAgICAgICAgIH0gZWxzZSBIID0gZGEgPSBGID0gQyA9IEwgPSBFID0gbnVsbFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaChhKSB7XHJcbiAgICAgICAgICAgIG4uc2V0RnVuYyhhKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbShiKSB7XHJcbiAgICAgICAgICAgIEQgIT09IGIgJiYgKGIgPyBhLmZyb250RmFjZShhLkNXKSA6IGEuZnJvbnRGYWNlKGEuQ0NXKSwgRCA9IGIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBrKGIpIHtcclxuICAgICAgICAgICAgMCAhPT0gYiA/IChlKGEuQ1VMTF9GQUNFKSwgYiAhPT0geiAmJiAoMSA9PT0gYiA/IGEuY3VsbEZhY2UoYS5CQUNLKSA6IDIgPT09IGIgPyBhLmN1bGxGYWNlKGEuRlJPTlQpIDogYS5jdWxsRmFjZShhLkZST05UX0FORF9CQUNLKSkpIDogZihhLkNVTExfRkFDRSk7XHJcbiAgICAgICAgICAgIHogPSBiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB0KGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gYS5URVhUVVJFMCArIFAgLSAxKTtcclxuICAgICAgICAgICAgVyAhPT0gYiAmJiAoYS5hY3RpdmVUZXh0dXJlKGIpLFxyXG4gICAgICAgICAgICAgICAgVyA9IGIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcCA9IG5ldyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9ICExLCBjID0gbmV3IGZhLCBkID0gbnVsbCwgZSA9IG5ldyBmYTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TWFzazogZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9PT0gYyB8fCBiIHx8IChhLmNvbG9yTWFzayhjLCBjLCBjLCBjKSwgZCA9IGMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgc2V0TG9ja2VkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHNldENsZWFyOiBmdW5jdGlvbiAoYiwgZCwgZiwgZywgaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAhMCA9PT0gaCAmJiAoYiAqPSBnLCBkICo9IGcsIGYgKj0gZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuc2V0KGIsIGQsIGYsIGcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAhMSA9PT0gZS5lcXVhbHMoYykgJiYgKGEuY2xlYXJDb2xvcihiLCBkLCBmLCBnKSwgZS5jb3B5KGMpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0KDAsIDAsIDAsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBuID0gbmV3IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gITEsIGMgPSBudWxsLCBkID0gbnVsbCwgZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRlc3Q6IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPyBlKGEuREVQVEhfVEVTVCkgOiBmKGEuREVQVEhfVEVTVClcclxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRNYXNrOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID09PSBkIHx8IGIgfHwgKGEuZGVwdGhNYXNrKGQpLCBjID0gZClcclxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRGdW5jOiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKXN3aXRjaCAoYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZXB0aEZ1bmMoYS5ORVZFUik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZXB0aEZ1bmMoYS5BTFdBWVMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGVwdGhGdW5jKGEuTEVTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZXB0aEZ1bmMoYS5MRVFVQUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGVwdGhGdW5jKGEuRVFVQUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGVwdGhGdW5jKGEuR0VRVUFMKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmRlcHRoRnVuYyhhLkdSRUFURVIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGVwdGhGdW5jKGEuTk9URVFVQUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmRlcHRoRnVuYyhhLkxFUVVBTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBhLmRlcHRoRnVuYyhhLkxFUVVBTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgc2V0TG9ja2VkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHNldENsZWFyOiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnICE9PSBiICYmIChhLmNsZWFyRGVwdGgoYiksIGcgPSBiKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGQgPSBjID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdSA9IG5ldyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9ICExLCBjID1cclxuICAgICAgICAgICAgICAgICAgICBudWxsLCBkID0gbnVsbCwgZyA9IG51bGwsIGggPSBudWxsLCBtID0gbnVsbCwgayA9IG51bGwsIG4gPSBudWxsLCB0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGVzdDogZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA/IGUoYS5TVEVOQ0lMX1RFU1QpIDogZihhLlNURU5DSUxfVEVTVClcclxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRNYXNrOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID09PSBkIHx8IGIgfHwgKGEuc3RlbmNpbE1hc2soZCksIGMgPSBkKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHNldEZ1bmM6IGZ1bmN0aW9uIChiLCBjLCBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkICE9PSBiIHx8IGcgIT09IGMgfHwgaCAhPT0gZSkgYS5zdGVuY2lsRnVuYyhiLCBjLCBlKSwgZCA9IGIsIGcgPSBjLCBoID0gZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHNldE9wOiBmdW5jdGlvbiAoYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobSAhPT0gYiB8fCBrICE9PSBjIHx8IG4gIT09IGQpIGEuc3RlbmNpbE9wKGIsIGMsIGQpLCBtID0gYiwgayA9IGMsIG4gPSBkXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgc2V0TG9ja2VkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHNldENsZWFyOiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ICE9PSBiICYmIChhLmNsZWFyU3RlbmNpbChiKSwgdCA9IGIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gbiA9IGsgPSBtID0gaCA9IGcgPSBkID0gYyA9IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGwgPSBhLmdldFBhcmFtZXRlcihhLk1BWF9WRVJURVhfQVRUUklCUyksIHIgPSBuZXcgVWludDhBcnJheShsKSxcclxuICAgICAgICAgICAgcSA9IG5ldyBVaW50OEFycmF5KGwpLCB3ID0gbmV3IFVpbnQ4QXJyYXkobCksIHkgPSB7fSwgSyA9IG51bGwsIHYgPSBudWxsLCBFID0gbnVsbCwgTCA9IG51bGwsIEMgPSBudWxsLFxyXG4gICAgICAgICAgICBGID0gbnVsbCwgZGEgPSBudWxsLCBIID0gbnVsbCwgeCA9ICExLCBEID0gbnVsbCwgeiA9IG51bGwsIEogPSBudWxsLCBRID0gbnVsbCwgTSA9IG51bGwsIE8gPSBudWxsLFxyXG4gICAgICAgICAgICBQID0gYS5nZXRQYXJhbWV0ZXIoYS5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXHJcbiAgICAgICAgICAgIGwgPSBwYXJzZUZsb2F0KC9eV2ViR0xcXCAoWzAtOV0pLy5leGVjKGEuZ2V0UGFyYW1ldGVyKGEuVkVSU0lPTikpWzFdKSwgSSA9IDEgPD0gcGFyc2VGbG9hdChsKSwgVyA9IG51bGwsXHJcbiAgICAgICAgICAgIFMgPSB7fSwgUiA9IG5ldyBmYSwgVCA9IG5ldyBmYSwgTiA9IHt9O1xyXG4gICAgICAgIE5bYS5URVhUVVJFXzJEXSA9IGQoYS5URVhUVVJFXzJELCBhLlRFWFRVUkVfMkQsIDEpO1xyXG4gICAgICAgIE5bYS5URVhUVVJFX0NVQkVfTUFQXSA9IGQoYS5URVhUVVJFX0NVQkVfTUFQLCBhLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgNik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYnVmZmVyczoge2NvbG9yOiBwLCBkZXB0aDogbiwgc3RlbmNpbDogdX0sIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHAuc2V0Q2xlYXIoMCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAxKTtcclxuICAgICAgICAgICAgICAgIG4uc2V0Q2xlYXIoMSk7XHJcbiAgICAgICAgICAgICAgICB1LnNldENsZWFyKDApO1xyXG4gICAgICAgICAgICAgICAgZShhLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgICAgICAgICAgaCgzKTtcclxuICAgICAgICAgICAgICAgIG0oITEpO1xyXG4gICAgICAgICAgICAgICAgaygxKTtcclxuICAgICAgICAgICAgICAgIGUoYS5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICAgICAgZShhLkJMRU5EKTtcclxuICAgICAgICAgICAgICAgIGcoMSlcclxuICAgICAgICAgICAgfSwgaW5pdEF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBiID0gci5sZW5ndGg7IGEgPCBiOyBhKyspclthXSA9IDBcclxuICAgICAgICAgICAgfSwgZW5hYmxlQXR0cmlidXRlOiBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgcltjXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAwID09PSBxW2NdICYmIChhLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGMpLCBxW2NdID0gMSk7XHJcbiAgICAgICAgICAgICAgICAwICE9PSB3W2NdICYmIChiLmdldChcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIikudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGMsIDApLCB3W2NdID0gMClcclxuICAgICAgICAgICAgfSwgZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcjogZnVuY3Rpb24gKGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgIHJbYl0gPSAxO1xyXG4gICAgICAgICAgICAgICAgMCA9PT0gcVtiXSAmJiAoYS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShiKSwgcVtiXSA9IDEpO1xyXG4gICAgICAgICAgICAgICAgd1tiXSAhPT0gYyAmJiAoZC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYiwgYyksIHdbYl0gPSBjKVxyXG4gICAgICAgICAgICB9LCBkaXNhYmxlVW51c2VkQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9XHJcbiAgICAgICAgICAgICAgICAgICAgMCwgYyA9IHEubGVuZ3RoOyBiICE9PSBjOyArK2IpcVtiXSAhPT0gcltiXSAmJiAoYS5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYiksIHFbYl0gPSAwKVxyXG4gICAgICAgICAgICB9LCBlbmFibGU6IGUsIGRpc2FibGU6IGYsIGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IEsgJiYgKEsgPSBbXSwgYi5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIikgfHwgYi5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSB8fCBiLmdldChcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXCIpKSlmb3IgKHZhciBjID0gYS5nZXRQYXJhbWV0ZXIoYS5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAwOyBkIDwgYy5sZW5ndGg7IGQrKylLLnB1c2goY1tkXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gS1xyXG4gICAgICAgICAgICB9LCBzZXRCbGVuZGluZzogZywgc2V0Q29sb3JXcml0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHAuc2V0TWFzayhhKVxyXG4gICAgICAgICAgICB9LCBzZXREZXB0aFRlc3Q6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBuLnNldFRlc3QoYSlcclxuICAgICAgICAgICAgfSwgc2V0RGVwdGhXcml0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIG4uc2V0TWFzayhhKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXREZXB0aEZ1bmM6IGgsIHNldFN0ZW5jaWxUZXN0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgdS5zZXRUZXN0KGEpXHJcbiAgICAgICAgICAgIH0sIHNldFN0ZW5jaWxXcml0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHUuc2V0TWFzayhhKVxyXG4gICAgICAgICAgICB9LCBzZXRTdGVuY2lsRnVuYzogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIHUuc2V0RnVuYyhhLCBiLCBjKVxyXG4gICAgICAgICAgICB9LCBzZXRTdGVuY2lsT3A6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICB1LnNldE9wKGEsIGIsIGMpXHJcbiAgICAgICAgICAgIH0sIHNldEZsaXBTaWRlZDogbSwgc2V0Q3VsbEZhY2U6IGssIHNldExpbmVXaWR0aDogZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIGIgIT09IEogJiYgKEkgJiYgYS5saW5lV2lkdGgoYiksIEogPSBiKVxyXG4gICAgICAgICAgICB9LCBzZXRQb2x5Z29uT2Zmc2V0OiBmdW5jdGlvbiAoYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZShhLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLCBRICE9PSBjIHx8IE0gIT09IGQpIGEucG9seWdvbk9mZnNldChjLCBkKSwgUSA9IGMsIE0gPSBkXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgZihhLlBPTFlHT05fT0ZGU0VUX0ZJTEwpXHJcbiAgICAgICAgICAgIH0sIGdldFNjaXNzb3JUZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT1xyXG4gICAgICAgICAgICB9LCBzZXRTY2lzc29yVGVzdDogZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIChPID0gYikgPyBlKGEuU0NJU1NPUl9URVNUKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZihhLlNDSVNTT1JfVEVTVClcclxuICAgICAgICAgICAgfSwgYWN0aXZlVGV4dHVyZTogdCwgYmluZFRleHR1cmU6IGZ1bmN0aW9uIChiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICBudWxsID09PSBXICYmIHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gU1tXXTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZCAmJiAoZCA9IHt0eXBlOiB2b2lkIDAsIHRleHR1cmU6IHZvaWQgMH0sIFNbV10gPSBkKTtcclxuICAgICAgICAgICAgICAgIGlmIChkLnR5cGUgIT09IGIgfHwgZC50ZXh0dXJlICE9PSBjKSBhLmJpbmRUZXh0dXJlKGIsIGMgfHwgTltiXSksIGQudHlwZSA9IGIsIGQudGV4dHVyZSA9IGNcclxuICAgICAgICAgICAgfSwgY29tcHJlc3NlZFRleEltYWdlMkQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseShhLCBhcmd1bWVudHMpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0ZXhJbWFnZTJEOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEudGV4SW1hZ2UyRC5hcHBseShhLCBhcmd1bWVudHMpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBzY2lzc29yOiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgITEgPT09IFIuZXF1YWxzKGIpICYmIChhLnNjaXNzb3IoYi54LCBiLnksIGIueiwgYi53KSwgUi5jb3B5KGIpKVxyXG4gICAgICAgICAgICB9LCB2aWV3cG9ydDogZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgICExID09PVxyXG4gICAgICAgICAgICAgICAgVC5lcXVhbHMoYikgJiYgKGEudmlld3BvcnQoYi54LCBiLnksIGIueiwgYi53KSwgVC5jb3B5KGIpKVxyXG4gICAgICAgICAgICB9LCByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBxLmxlbmd0aDsgYisrKTEgPT09IHFbYl0gJiYgKGEuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGIpLCBxW2JdID0gMCk7XHJcbiAgICAgICAgICAgICAgICB5ID0ge307XHJcbiAgICAgICAgICAgICAgICBXID0gSyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBTID0ge307XHJcbiAgICAgICAgICAgICAgICB6ID0gRCA9IHYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcC5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgbi5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdS5yZXNldCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gU2YoYSwgYiwgYykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGQoYikge1xyXG4gICAgICAgICAgICBpZiAoXCJoaWdocFwiID09PSBiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA8IGEuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGEuVkVSVEVYX1NIQURFUiwgYS5ISUdIX0ZMT0FUKS5wcmVjaXNpb24gJiYgMCA8IGEuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGEuRlJBR01FTlRfU0hBREVSLCBhLkhJR0hfRkxPQVQpLnByZWNpc2lvbilyZXR1cm4gXCJoaWdocFwiO1xyXG4gICAgICAgICAgICAgICAgYiA9IFwibWVkaXVtcFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwibWVkaXVtcFwiID09PSBiICYmIDAgPCBhLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChhLlZFUlRFWF9TSEFERVIsIGEuTUVESVVNX0ZMT0FUKS5wcmVjaXNpb24gJiZcclxuICAgICAgICAgICAgMCA8IGEuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGEuRlJBR01FTlRfU0hBREVSLCBhLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uID8gXCJtZWRpdW1wXCIgOiBcImxvd3BcIlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGUsIGYgPSB2b2lkIDAgIT09IGMucHJlY2lzaW9uID8gYy5wcmVjaXNpb24gOiBcImhpZ2hwXCIsIGcgPSBkKGYpO1xyXG4gICAgICAgIGcgIT09IGYgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6XCIsIGYsIFwibm90IHN1cHBvcnRlZCwgdXNpbmdcIiwgZywgXCJpbnN0ZWFkLlwiKSwgZiA9IGcpO1xyXG4gICAgICAgIGMgPSAhMCA9PT0gYy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmICEhYi5nZXQoXCJFWFRfZnJhZ19kZXB0aFwiKTtcclxuICAgICAgICB2YXIgZyA9IGEuZ2V0UGFyYW1ldGVyKGEuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLCBoID0gYS5nZXRQYXJhbWV0ZXIoYS5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxyXG4gICAgICAgICAgICBtID0gYS5nZXRQYXJhbWV0ZXIoYS5NQVhfVEVYVFVSRV9TSVpFKSwgayA9IGEuZ2V0UGFyYW1ldGVyKGEuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSksXHJcbiAgICAgICAgICAgIHQgPSBhLmdldFBhcmFtZXRlcihhLk1BWF9WRVJURVhfQVRUUklCUyksXHJcbiAgICAgICAgICAgIHAgPSBhLmdldFBhcmFtZXRlcihhLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSwgbiA9IGEuZ2V0UGFyYW1ldGVyKGEuTUFYX1ZBUllJTkdfVkVDVE9SUyksXHJcbiAgICAgICAgICAgIHUgPSBhLmdldFBhcmFtZXRlcihhLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLCBsID0gMCA8IGgsIHIgPSAhIWIuZ2V0KFwiT0VTX3RleHR1cmVfZmxvYXRcIik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0TWF4QW5pc290cm9weTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSlyZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gYi5nZXQoXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA9IG51bGwgIT09IGMgPyBhLmdldFBhcmFtZXRlcihjLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCkgOiAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldE1heFByZWNpc2lvbjogZCxcclxuICAgICAgICAgICAgcHJlY2lzaW9uOiBmLFxyXG4gICAgICAgICAgICBsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjLFxyXG4gICAgICAgICAgICBtYXhUZXh0dXJlczogZyxcclxuICAgICAgICAgICAgbWF4VmVydGV4VGV4dHVyZXM6IGgsXHJcbiAgICAgICAgICAgIG1heFRleHR1cmVTaXplOiBtLFxyXG4gICAgICAgICAgICBtYXhDdWJlbWFwU2l6ZTogayxcclxuICAgICAgICAgICAgbWF4QXR0cmlidXRlczogdCxcclxuICAgICAgICAgICAgbWF4VmVydGV4VW5pZm9ybXM6IHAsXHJcbiAgICAgICAgICAgIG1heFZhcnlpbmdzOiBuLFxyXG4gICAgICAgICAgICBtYXhGcmFnbWVudFVuaWZvcm1zOiB1LFxyXG4gICAgICAgICAgICB2ZXJ0ZXhUZXh0dXJlczogbCxcclxuICAgICAgICAgICAgZmxvYXRGcmFnbWVudFRleHR1cmVzOiByLFxyXG4gICAgICAgICAgICBmbG9hdFZlcnRleFRleHR1cmVzOiBsICYmIHJcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVGYoYSkge1xyXG4gICAgICAgIHZhciBiID0ge307XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYltjXSlyZXR1cm4gYltjXTtcclxuICAgICAgICAgICAgICAgIHZhciBkO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIldFQkdMX2RlcHRoX3RleHR1cmVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGEuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKSB8fCBhLmdldEV4dGVuc2lvbihcIk1PWl9XRUJHTF9kZXB0aF90ZXh0dXJlXCIpIHx8IGEuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2RlcHRoX3RleHR1cmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGEuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpIHx8IGEuZ2V0RXh0ZW5zaW9uKFwiTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5nZXRFeHRlbnNpb24oXCJXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGEuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIikgfHwgYS5nZXRFeHRlbnNpb24oXCJNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIikgfHwgYS5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGEuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpIHx8IGEuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBhLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gYS5nZXRFeHRlbnNpb24oYylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG51bGwgPT09IGQgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogXCIgKyBjICsgXCIgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJbY10gPSBkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVWYoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYSgpIHtcclxuICAgICAgICAgICAgay52YWx1ZSAhPT0gZCAmJiAoay52YWx1ZSA9IGQsIGsubmVlZHNVcGRhdGUgPSAwIDwgZSk7XHJcbiAgICAgICAgICAgIGMubnVtUGxhbmVzID0gZTtcclxuICAgICAgICAgICAgYy5udW1JbnRlcnNlY3Rpb24gPSAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBiKGEsIGIsIGQsIGUpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBudWxsICE9PSBhID8gYS5sZW5ndGggOiAwLCBnID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKDAgIT09IGYpIHtcclxuICAgICAgICAgICAgICAgIGcgPSBrLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEwICE9PSBlIHx8IG51bGwgPT09IGcpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gZCArIDQgKiBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBiLm1hdHJpeFdvcmxkSW52ZXJzZTtcclxuICAgICAgICAgICAgICAgICAgICBtLmdldE5vcm1hbE1hdHJpeChiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gZyB8fCBnLmxlbmd0aCA8IGUpIGcgPSBuZXcgRmxvYXQzMkFycmF5KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IDA7IGUgIT09IGY7ICsrZSwgZCArPSA0KWguY29weShhW2VdKS5hcHBseU1hdHJpeDQoYiwgbSksIGgubm9ybWFsLnRvQXJyYXkoZywgZCksIGdbZCArXHJcbiAgICAgICAgICAgICAgICAgICAgM10gPSBoLmNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBrLnZhbHVlID0gZztcclxuICAgICAgICAgICAgICAgIGsubmVlZHNVcGRhdGUgPSAhMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGMubnVtUGxhbmVzID0gZjtcclxuICAgICAgICAgICAgcmV0dXJuIGdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjID0gdGhpcywgZCA9IG51bGwsIGUgPSAwLCBmID0gITEsIGcgPSAhMSwgaCA9IG5ldyBsYSwgbSA9IG5ldyB5YSwgayA9IHt2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6ICExfTtcclxuICAgICAgICB0aGlzLnVuaWZvcm0gPSBrO1xyXG4gICAgICAgIHRoaXMubnVtSW50ZXJzZWN0aW9uID0gdGhpcy5udW1QbGFuZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChhLCBjLCBnKSB7XHJcbiAgICAgICAgICAgIHZhciBoID0gMCAhPT0gYS5sZW5ndGggfHwgYyB8fCAwICE9PSBlIHx8IGY7XHJcbiAgICAgICAgICAgIGYgPSBjO1xyXG4gICAgICAgICAgICBkID0gYihhLCBnLCAwKTtcclxuICAgICAgICAgICAgZSA9IGEubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gaFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iZWdpblNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGcgPSAhMDtcclxuICAgICAgICAgICAgYihudWxsKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5lbmRTaGFkb3dzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBnID0gITE7XHJcbiAgICAgICAgICAgIGEoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChjLCBoLCBtLCBsLCBHLCByKSB7XHJcbiAgICAgICAgICAgIGlmICghZiB8fCBudWxsID09PSBjIHx8IDAgPT09IGMubGVuZ3RoIHx8IGcgJiYgIW0pIGcgPyBiKG51bGwpIDogYSgpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG0gPSBnID8gMCA6IGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcSA9IDQgKiBtLCB3ID0gRy5jbGlwcGluZ1N0YXRlIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICBrLnZhbHVlID0gdztcclxuICAgICAgICAgICAgICAgIHcgPSBiKGMsIGwsIHEsIHIpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjID0gMDsgYyAhPT0gcTsgKytjKXdbY10gPSBkW2NdO1xyXG4gICAgICAgICAgICAgICAgRy5jbGlwcGluZ1N0YXRlID0gdztcclxuICAgICAgICAgICAgICAgIHRoaXMubnVtSW50ZXJzZWN0aW9uID0gaCA/IHRoaXMubnVtUGxhbmVzIDogMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubnVtUGxhbmVzICs9IG1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBZZChhKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYigpIHtcclxuICAgICAgICAgICAgWS5pbml0KCk7XHJcbiAgICAgICAgICAgIFkuc2Npc3NvcihYLmNvcHkoZ2EpLm11bHRpcGx5U2NhbGFyKFJhKSk7XHJcbiAgICAgICAgICAgIFkudmlld3BvcnQoWi5jb3B5KGlhKS5tdWx0aXBseVNjYWxhcihSYSkpO1xyXG4gICAgICAgICAgICBZLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoRWEuciwgRWEuZywgRWEuYiwgZ2IsIEYpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjKCkge1xyXG4gICAgICAgICAgICBVID0gd2EgPSBudWxsO1xyXG4gICAgICAgICAgICBWID0gXCJcIjtcclxuICAgICAgICAgICAgUiA9IC0xO1xyXG4gICAgICAgICAgICBZLnJlc2V0KClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGQoYSkge1xyXG4gICAgICAgICAgICBhLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGMoKTtcclxuICAgICAgICAgICAgYigpO1xyXG4gICAgICAgICAgICBoYS5jbGVhcigpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBlKGEpIHtcclxuICAgICAgICAgICAgYSA9IGEudGFyZ2V0O1xyXG4gICAgICAgICAgICBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIGUpO1xyXG4gICAgICAgICAgICBmKGEpO1xyXG4gICAgICAgICAgICBoYVtcImRlbGV0ZVwiXShhKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZihhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gaGEuZ2V0KGEpLnByb2dyYW07XHJcbiAgICAgICAgICAgIGEucHJvZ3JhbSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBiICYmIHlhLnJlbGVhc2VQcm9ncmFtKGIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGJbMF0pIC0gTWF0aC5hYnMoYVswXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGgoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyID8gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlciA6IGEubWF0ZXJpYWwucHJvZ3JhbSAmJiBiLm1hdGVyaWFsLnByb2dyYW0gJiYgYS5tYXRlcmlhbC5wcm9ncmFtICE9PSBiLm1hdGVyaWFsLnByb2dyYW0gPyBhLm1hdGVyaWFsLnByb2dyYW0uaWQgLSBiLm1hdGVyaWFsLnByb2dyYW0uaWQgOiBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkID8gYS5tYXRlcmlhbC5pZCAtIGIubWF0ZXJpYWwuaWQgOiBhLnogIT09IGIueiA/IGEueiAtIGIueiA6IGEuaWQgLSBiLmlkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBtKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciA/IGEub2JqZWN0LnJlbmRlck9yZGVyIC1cclxuICAgICAgICAgICAgICAgIGIub2JqZWN0LnJlbmRlck9yZGVyIDogYS56ICE9PSBiLnogPyBiLnogLSBhLnogOiBhLmlkIC0gYi5pZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gayhhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIHZhciBmO1xyXG4gICAgICAgICAgICBjLnRyYW5zcGFyZW50ID8gKGQgPSB6LCBmID0gKytUKSA6IChkID0gYWEsIGYgPSArK0QpO1xyXG4gICAgICAgICAgICBmID0gZFtmXTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBmID8gKGYuaWQgPSBhLmlkLCBmLm9iamVjdCA9IGEsIGYuZ2VvbWV0cnkgPSBiLCBmLm1hdGVyaWFsID0gYywgZi56ID0gR2EueiwgZi5ncm91cCA9IGUpIDogKGYgPSB7XHJcbiAgICAgICAgICAgICAgICBpZDogYS5pZCxcclxuICAgICAgICAgICAgICAgIG9iamVjdDogYSxcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBiLFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWw6IGMsXHJcbiAgICAgICAgICAgICAgICB6OiBHYS56LFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGVcclxuICAgICAgICAgICAgfSwgZC5wdXNoKGYpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdChhKSB7XHJcbiAgICAgICAgICAgIGlmICghbWEuaW50ZXJzZWN0c1NwaGVyZShhKSlyZXR1cm4gITE7XHJcbiAgICAgICAgICAgIHZhciBiID0gY2EubnVtUGxhbmVzO1xyXG4gICAgICAgICAgICBpZiAoMCA9PT0gYilyZXR1cm4gITA7XHJcbiAgICAgICAgICAgIHZhciBjID0gUC5jbGlwcGluZ1BsYW5lcywgZCA9IGEuY2VudGVyO1xyXG4gICAgICAgICAgICBhID0gLWEucmFkaXVzO1xyXG4gICAgICAgICAgICB2YXIgZSA9IDA7XHJcbiAgICAgICAgICAgIGRvIGlmIChjW2VdLmRpc3RhbmNlVG9Qb2ludChkKSA8IGEpcmV0dXJuICExOyB3aGlsZSAoKytlICE9PSBiKTtcclxuICAgICAgICAgICAgcmV0dXJuICEwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKCExICE9PVxyXG4gICAgICAgICAgICAgICAgYS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gKGEubGF5ZXJzLm1hc2sgJiBiLmxheWVycy5tYXNrKSlpZiAoYS5pc0xpZ2h0KSBILnB1c2goYSk7IGVsc2UgaWYgKGEuaXNTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYztcclxuICAgICAgICAgICAgICAgICAgICAoYyA9ICExID09PSBhLmZydXN0dW1DdWxsZWQpIHx8IChuYS5jZW50ZXIuc2V0KDAsIDAsIDApLCBuYS5yYWRpdXMgPSAuNzA3MTA2NzgxMTg2NTQ3NiwgbmEuYXBwbHlNYXRyaXg0KGEubWF0cml4V29ybGQpLCBjID0gITAgPT09IHQobmEpKTtcclxuICAgICAgICAgICAgICAgICAgICBjICYmIE0ucHVzaChhKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhLmlzTGVuc0ZsYXJlKSBPLnB1c2goYSk7IGVsc2UgaWYgKGEuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QpICEwID09PSBQLnNvcnRPYmplY3RzICYmIChHYS5zZXRGcm9tTWF0cml4UG9zaXRpb24oYS5tYXRyaXhXb3JsZCksIEdhLmFwcGx5TWF0cml4NCh1YSkpLCBrKGEsIG51bGwsIGEubWF0ZXJpYWwsIEdhLnosIG51bGwpOyBlbHNlIGlmIChhLmlzTWVzaCB8fCBhLmlzTGluZSB8fCBhLmlzUG9pbnRzKWlmIChhLmlzU2tpbm5lZE1lc2ggJiYgYS5za2VsZXRvbi51cGRhdGUoKSwgKGMgPSAhMSA9PT0gYS5mcnVzdHVtQ3VsbGVkKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChjID0gYS5nZW9tZXRyeSwgbnVsbCA9PT0gYy5ib3VuZGluZ1NwaGVyZSAmJiBjLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLCBuYS5jb3B5KGMuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChhLm1hdHJpeFdvcmxkKSwgYyA9ICEwID09PSB0KG5hKSksIGMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGEubWF0ZXJpYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBkLnZpc2libGUpaWYgKCEwID09PSBQLnNvcnRPYmplY3RzICYmIChHYS5zZXRGcm9tTWF0cml4UG9zaXRpb24oYS5tYXRyaXhXb3JsZCksIEdhLmFwcGx5TWF0cml4NCh1YSkpLCBjID0gcWEudXBkYXRlKGEpLCBkLmlzTXVsdGlNYXRlcmlhbClmb3IgKHZhciBlID0gYy5ncm91cHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gZC5tYXRlcmlhbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBlLmxlbmd0aDsgZCA8IGc7IGQrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGVbZF0sIG0gPSBmW2gubWF0ZXJpYWxJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICEwID09PSBtLnZpc2libGUgJiYgayhhLCBjLCBtLCBHYS56LCBoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBrKGEsIGMsIGQsIEdhLnosIG51bGwpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjID0gYS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChnID0gYy5sZW5ndGg7IGQgPCBnOyBkKyspcChjW2RdLCBiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBuKGEsIGIsIGMsXHJcbiAgICAgICAgICAgICAgICAgICBkKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gYS5sZW5ndGg7IGUgPCBmOyBlKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gYVtlXSwgaCA9IGcub2JqZWN0LCBtID0gZy5nZW9tZXRyeSwgayA9IHZvaWQgMCA9PT0gZCA/IGcubWF0ZXJpYWwgOiBkLCBnID0gZy5ncm91cDtcclxuICAgICAgICAgICAgICAgIGgubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoYy5tYXRyaXhXb3JsZEludmVyc2UsIGgubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICAgICAgaC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KGgubW9kZWxWaWV3TWF0cml4KTtcclxuICAgICAgICAgICAgICAgIGgub25CZWZvcmVSZW5kZXIoUCwgYiwgYywgbSwgaywgZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaC5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGwoayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBHKGMsIGIuZm9nLCBrLCBoKTtcclxuICAgICAgICAgICAgICAgICAgICBWID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBoLnJlbmRlcihmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQLnJlbmRlckJ1ZmZlckltbWVkaWF0ZShhLCBuLCBrKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgUC5yZW5kZXJCdWZmZXJEaXJlY3QoYywgYi5mb2csIG0sIGssIGgsIGcpO1xyXG4gICAgICAgICAgICAgICAgaC5vbkFmdGVyUmVuZGVyKFAsIGIsIGMsIG0sIGssIGcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGwoYSkge1xyXG4gICAgICAgICAgICAyID09PSBhLnNpZGUgPyBZLmRpc2FibGUoQi5DVUxMX0ZBQ0UpIDogWS5lbmFibGUoQi5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICBZLnNldEZsaXBTaWRlZCgxID09PSBhLnNpZGUpO1xyXG4gICAgICAgICAgICAhMCA9PT0gYS50cmFuc3BhcmVudCA/IFkuc2V0QmxlbmRpbmcoYS5ibGVuZGluZywgYS5ibGVuZEVxdWF0aW9uLCBhLmJsZW5kU3JjLCBhLmJsZW5kRHN0LCBhLmJsZW5kRXF1YXRpb25BbHBoYSwgYS5ibGVuZFNyY0FscGhhLCBhLmJsZW5kRHN0QWxwaGEsIGEucHJlbXVsdGlwbGllZEFscGhhKSA6IFkuc2V0QmxlbmRpbmcoMCk7XHJcbiAgICAgICAgICAgIFkuc2V0RGVwdGhGdW5jKGEuZGVwdGhGdW5jKTtcclxuICAgICAgICAgICAgWS5zZXREZXB0aFRlc3QoYS5kZXB0aFRlc3QpO1xyXG4gICAgICAgICAgICBZLnNldERlcHRoV3JpdGUoYS5kZXB0aFdyaXRlKTtcclxuICAgICAgICAgICAgWS5zZXRDb2xvcldyaXRlKGEuY29sb3JXcml0ZSk7XHJcbiAgICAgICAgICAgIFkuc2V0UG9seWdvbk9mZnNldChhLnBvbHlnb25PZmZzZXQsIGEucG9seWdvbk9mZnNldEZhY3RvciwgYS5wb2x5Z29uT2Zmc2V0VW5pdHMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBHKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgZWEgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZyA9IGhhLmdldChjKTtcclxuICAgICAgICAgICAgb2EgJiYgKHJhIHx8IGEgIT09IFUpICYmIGNhLnNldFN0YXRlKGMuY2xpcHBpbmdQbGFuZXMsIGMuY2xpcEludGVyc2VjdGlvbixcclxuICAgICAgICAgICAgICAgIGMuY2xpcFNoYWRvd3MsIGEsIGcsIGEgPT09IFUgJiYgYy5pZCA9PT0gUik7XHJcbiAgICAgICAgICAgICExID09PSBjLm5lZWRzVXBkYXRlICYmICh2b2lkIDAgPT09IGcucHJvZ3JhbSA/IGMubmVlZHNVcGRhdGUgPSAhMCA6IGMuZm9nICYmIGcuZm9nICE9PSBiID8gYy5uZWVkc1VwZGF0ZSA9ICEwIDogYy5saWdodHMgJiYgZy5saWdodHNIYXNoICE9PSBiYS5oYXNoID8gYy5uZWVkc1VwZGF0ZSA9ICEwIDogdm9pZCAwID09PSBnLm51bUNsaXBwaW5nUGxhbmVzIHx8IGcubnVtQ2xpcHBpbmdQbGFuZXMgPT09IGNhLm51bVBsYW5lcyAmJiBnLm51bUludGVyc2VjdGlvbiA9PT0gY2EubnVtSW50ZXJzZWN0aW9uIHx8IChjLm5lZWRzVXBkYXRlID0gITApKTtcclxuICAgICAgICAgICAgaWYgKGMubmVlZHNVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGE6e1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gaGEuZ2V0KGMpLCBtID0geWEuZ2V0UGFyYW1ldGVycyhjLCBiYSwgYiwgY2EubnVtUGxhbmVzLCBjYS5udW1JbnRlcnNlY3Rpb24sIGQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrID0geWEuZ2V0UHJvZ3JhbUNvZGUoYywgbSksIG4gPSBoLnByb2dyYW0sIHQgPSAhMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBuKSBjLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIGUpOyBlbHNlIGlmIChuLmNvZGUgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGspIGYoYyk7IGVsc2UgaWYgKHZvaWQgMCAhPT0gbS5zaGFkZXJJRClicmVhayBhOyBlbHNlIHQgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICB0ICYmIChtLnNoYWRlcklEID8gKG4gPSBiYlttLnNoYWRlcklEXSwgaC5fX3dlYmdsU2hhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBKYS5jbG9uZShuLnVuaWZvcm1zKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBuLnZlcnRleFNoYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IG4uZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAgICAgICAgICAgICB9KSA6IGguX193ZWJnbFNoYWRlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtczogYy51bmlmb3JtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBjLnZlcnRleFNoYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGMuZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAgICAgICAgICAgICB9LCBjLl9fd2ViZ2xTaGFkZXIgPSBoLl9fd2ViZ2xTaGFkZXIsIG4gPSB5YS5hY3F1aXJlUHJvZ3JhbShjLCBtLCBrKSwgaC5wcm9ncmFtID0gbiwgYy5wcm9ncmFtID0gbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IG4uZ2V0QXR0cmlidXRlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLm1vcnBoVGFyZ2V0cylmb3IgKGsgPSBjLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7IGsgPCBQLm1heE1vcnBoVGFyZ2V0czsgaysrKTAgPD1cclxuICAgICAgICAgICAgICAgICAgICBtW1wibW9ycGhUYXJnZXRcIiArIGtdICYmIGMubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMubW9ycGhOb3JtYWxzKWZvciAoayA9IGMubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDsgayA8IFAubWF4TW9ycGhOb3JtYWxzOyBrKyspMCA8PSBtW1wibW9ycGhOb3JtYWxcIiArIGtdICYmIGMubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IGguX193ZWJnbFNoYWRlci51bmlmb3JtcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWMuaXNTaGFkZXJNYXRlcmlhbCAmJiAhYy5pc1Jhd1NoYWRlck1hdGVyaWFsIHx8ICEwID09PSBjLmNsaXBwaW5nKSBoLm51bUNsaXBwaW5nUGxhbmVzID0gY2EubnVtUGxhbmVzLCBoLm51bUludGVyc2VjdGlvbiA9IGNhLm51bUludGVyc2VjdGlvbiwgbS5jbGlwcGluZ1BsYW5lcyA9IGNhLnVuaWZvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgaC5mb2cgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGgubGlnaHRzSGFzaCA9IGJhLmhhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5saWdodHMgJiYgKG0uYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBiYS5hbWJpZW50LCBtLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlID0gYmEuZGlyZWN0aW9uYWwsIG0uc3BvdExpZ2h0cy52YWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhLnNwb3QsIG0ucmVjdEFyZWFMaWdodHMudmFsdWUgPSBiYS5yZWN0QXJlYSwgbS5wb2ludExpZ2h0cy52YWx1ZSA9IGJhLnBvaW50LCBtLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBiYS5oZW1pLCBtLmRpcmVjdGlvbmFsU2hhZG93TWFwLnZhbHVlID0gYmEuZGlyZWN0aW9uYWxTaGFkb3dNYXAsIG0uZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBiYS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeCwgbS5zcG90U2hhZG93TWFwLnZhbHVlID0gYmEuc3BvdFNoYWRvd01hcCwgbS5zcG90U2hhZG93TWF0cml4LnZhbHVlID0gYmEuc3BvdFNoYWRvd01hdHJpeCwgbS5wb2ludFNoYWRvd01hcC52YWx1ZSA9IGJhLnBvaW50U2hhZG93TWFwLCBtLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gYmEucG9pbnRTaGFkb3dNYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSBoLnByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBtID0gJGEuc2VxV2l0aFZhbHVlKGsuc2VxLCBtKTtcclxuICAgICAgICAgICAgICAgICAgICBoLnVuaWZvcm1zTGlzdCA9IG1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGMubmVlZHNVcGRhdGUgPSAhMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwID0gITEsIHQgPSBuID0gITEsIGggPSBnLnByb2dyYW0sXHJcbiAgICAgICAgICAgICAgICBtID0gaC5nZXRVbmlmb3JtcygpLCBrID0gZy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xyXG4gICAgICAgICAgICBoLmlkICE9PSB3YSAmJiAoQi51c2VQcm9ncmFtKGgucHJvZ3JhbSksIHdhID0gaC5pZCwgdCA9IG4gPSBwID0gITApO1xyXG4gICAgICAgICAgICBjLmlkICE9PSBSICYmIChSID0gYy5pZCwgbiA9ICEwKTtcclxuICAgICAgICAgICAgaWYgKHAgfHwgYSAhPT0gVSkge1xyXG4gICAgICAgICAgICAgICAgbS5zZXQoQiwgYSwgXCJwcm9qZWN0aW9uTWF0cml4XCIpO1xyXG4gICAgICAgICAgICAgICAgbGEubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBtLnNldFZhbHVlKEIsIFwibG9nRGVwdGhCdWZGQ1wiLCAyIC8gKE1hdGgubG9nKGEuZmFyICsgMSkgLyBNYXRoLkxOMikpO1xyXG4gICAgICAgICAgICAgICAgYSAhPT0gVSAmJiAoVSA9IGEsIHQgPSBuID0gITApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMuaXNTaGFkZXJNYXRlcmlhbCB8fCBjLmlzTWVzaFBob25nTWF0ZXJpYWwgfHwgYy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IGMuZW52TWFwKSBwID0gbS5tYXAuY2FtZXJhUG9zaXRpb24sIHZvaWQgMCAhPT0gcCAmJiBwLnNldFZhbHVlKEIsIEdhLnNldEZyb21NYXRyaXhQb3NpdGlvbihhLm1hdHJpeFdvcmxkKSk7XHJcbiAgICAgICAgICAgICAgICAoYy5pc01lc2hQaG9uZ01hdGVyaWFsIHx8IGMuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IGMuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgYy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IGMuaXNTaGFkZXJNYXRlcmlhbCB8fCBjLnNraW5uaW5nKSAmJiBtLnNldFZhbHVlKEIsIFwidmlld01hdHJpeFwiLCBhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XHJcbiAgICAgICAgICAgICAgICBtLnNldChCLCBQLCBcInRvbmVNYXBwaW5nRXhwb3N1cmVcIik7XHJcbiAgICAgICAgICAgICAgICBtLnNldChCLCBQLCBcInRvbmVNYXBwaW5nV2hpdGVQb2ludFwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGMuc2tpbm5pbmcgJiYgKG0uc2V0T3B0aW9uYWwoQiwgZCwgXCJiaW5kTWF0cml4XCIpLCBtLnNldE9wdGlvbmFsKEIsIGQsIFwiYmluZE1hdHJpeEludmVyc2VcIiksIGEgPSBkLnNrZWxldG9uKSAmJiAobGEuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBhLnVzZVZlcnRleFRleHR1cmUgPyAobS5zZXQoQiwgYSwgXCJib25lVGV4dHVyZVwiKSwgbS5zZXQoQiwgYSwgXCJib25lVGV4dHVyZVdpZHRoXCIpLCBtLnNldChCLCBhLCBcImJvbmVUZXh0dXJlSGVpZ2h0XCIpKSA6IG0uc2V0T3B0aW9uYWwoQiwgYSwgXCJib25lTWF0cmljZXNcIikpO1xyXG4gICAgICAgICAgICBpZiAobikge1xyXG4gICAgICAgICAgICAgICAgYy5saWdodHMgJiYgKGEgPSB0LCBrLmFtYmllbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gYSwgay5kaXJlY3Rpb25hbExpZ2h0cy5uZWVkc1VwZGF0ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgYSwgay5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IGEsIGsuc3BvdExpZ2h0cy5uZWVkc1VwZGF0ZSA9IGEsIGsucmVjdEFyZWFMaWdodHMubmVlZHNVcGRhdGUgPSBhLCBrLmhlbWlzcGhlcmVMaWdodHMubmVlZHNVcGRhdGUgPSBhKTtcclxuICAgICAgICAgICAgICAgIGIgJiYgYy5mb2cgJiYgKGsuZm9nQ29sb3IudmFsdWUgPSBiLmNvbG9yLCBiLmlzRm9nID8gKGsuZm9nTmVhci52YWx1ZSA9IGIubmVhciwgay5mb2dGYXIudmFsdWUgPSBiLmZhcikgOiBiLmlzRm9nRXhwMiAmJiAoay5mb2dEZW5zaXR5LnZhbHVlID0gYi5kZW5zaXR5KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5pc01lc2hCYXNpY01hdGVyaWFsIHx8IGMuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IGMuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBjLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgYy5pc01lc2hOb3JtYWxNYXRlcmlhbCB8fCBjLmlzTWVzaERlcHRoTWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBrLm9wYWNpdHkudmFsdWUgPSBjLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgay5kaWZmdXNlLnZhbHVlID0gYy5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICBjLmVtaXNzaXZlICYmIGsuZW1pc3NpdmUudmFsdWUuY29weShjLmVtaXNzaXZlKS5tdWx0aXBseVNjYWxhcihjLmVtaXNzaXZlSW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBrLm1hcC52YWx1ZSA9IGMubWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIGsuc3BlY3VsYXJNYXAudmFsdWUgPSBjLnNwZWN1bGFyTWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIGsuYWxwaGFNYXAudmFsdWUgPSBjLmFscGhhTWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIGMubGlnaHRNYXAgJiYgKGsubGlnaHRNYXAudmFsdWUgPSBjLmxpZ2h0TWFwLCBrLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gYy5saWdodE1hcEludGVuc2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5hb01hcCAmJiAoay5hb01hcC52YWx1ZSA9IGMuYW9NYXAsIGsuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBjLmFvTWFwSW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbDtcclxuICAgICAgICAgICAgICAgICAgICBjLm1hcCA/IGwgPSBjLm1hcCA6IGMuc3BlY3VsYXJNYXAgPyBsID0gYy5zcGVjdWxhck1hcCA6IGMuZGlzcGxhY2VtZW50TWFwID8gbCA9IGMuZGlzcGxhY2VtZW50TWFwIDogYy5ub3JtYWxNYXAgPyBsID0gYy5ub3JtYWxNYXAgOiBjLmJ1bXBNYXAgPyBsID0gYy5idW1wTWFwIDogYy5yb3VnaG5lc3NNYXAgPyBsID0gYy5yb3VnaG5lc3NNYXAgOiBjLm1ldGFsbmVzc01hcCA/IGwgPSBjLm1ldGFsbmVzc01hcCA6IGMuYWxwaGFNYXAgPyBsID0gYy5hbHBoYU1hcCA6IGMuZW1pc3NpdmVNYXAgJiYgKGwgPSBjLmVtaXNzaXZlTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgbCAmJiAobC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICYmIChsID0gbC50ZXh0dXJlKSwgYiA9IGwub2Zmc2V0LCBsID0gbC5yZXBlYXQsIGsub2Zmc2V0UmVwZWF0LnZhbHVlLnNldChiLngsIGIueSwgbC54LCBsLnkpKTtcclxuICAgICAgICAgICAgICAgICAgICBrLmVudk1hcC52YWx1ZSA9IGMuZW52TWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIGsuZmxpcEVudk1hcC52YWx1ZSA9IGMuZW52TWFwICYmIGMuZW52TWFwLmlzQ3ViZVRleHR1cmUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgay5yZWZsZWN0aXZpdHkudmFsdWUgPSBjLnJlZmxlY3Rpdml0eTtcclxuICAgICAgICAgICAgICAgICAgICBrLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IGMucmVmcmFjdGlvblJhdGlvXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjLmlzTGluZUJhc2ljTWF0ZXJpYWwgPyAoay5kaWZmdXNlLnZhbHVlID0gYy5jb2xvciwgay5vcGFjaXR5LnZhbHVlID0gYy5vcGFjaXR5KSA6IGMuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgPyAoay5kaWZmdXNlLnZhbHVlID0gYy5jb2xvciwgay5vcGFjaXR5LnZhbHVlID0gYy5vcGFjaXR5LCBrLmRhc2hTaXplLnZhbHVlID0gYy5kYXNoU2l6ZSwgay50b3RhbFNpemUudmFsdWUgPSBjLmRhc2hTaXplICsgYy5nYXBTaXplLCBrLnNjYWxlLnZhbHVlID0gYy5zY2FsZSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGMuaXNQb2ludHNNYXRlcmlhbCA/IChrLmRpZmZ1c2UudmFsdWUgPSBjLmNvbG9yLCBrLm9wYWNpdHkudmFsdWUgPSBjLm9wYWNpdHksIGsuc2l6ZS52YWx1ZSA9IGMuc2l6ZSAqIFJhLCBrLnNjYWxlLnZhbHVlID0gLjUgKiBDYywgay5tYXAudmFsdWUgPSBjLm1hcCwgbnVsbCAhPT0gYy5tYXAgJiYgKGwgPSBjLm1hcC5vZmZzZXQsIGMgPSBjLm1hcC5yZXBlYXQsIGsub2Zmc2V0UmVwZWF0LnZhbHVlLnNldChsLngsIGwueSwgYy54LCBjLnkpKSkgOiBjLmlzTWVzaExhbWJlcnRNYXRlcmlhbCA/IGMuZW1pc3NpdmVNYXAgJiYgKGsuZW1pc3NpdmVNYXAudmFsdWUgPSBjLmVtaXNzaXZlTWFwKSA6IGMuaXNNZXNoVG9vbk1hdGVyaWFsID8gKHIoaywgYyksIGMuZ3JhZGllbnRNYXAgJiYgKGsuZ3JhZGllbnRNYXAudmFsdWUgPSBjLmdyYWRpZW50TWFwKSkgOiBjLmlzTWVzaFBob25nTWF0ZXJpYWwgPyByKGssIGMpIDogYy5pc01lc2hQaHlzaWNhbE1hdGVyaWFsID8gKGsuY2xlYXJDb2F0LnZhbHVlID0gYy5jbGVhckNvYXQsIGsuY2xlYXJDb2F0Um91Z2huZXNzLnZhbHVlID0gYy5jbGVhckNvYXRSb3VnaG5lc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEEoaywgYykpIDogYy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gQShrLCBjKSA6IGMuaXNNZXNoRGVwdGhNYXRlcmlhbCA/IGMuZGlzcGxhY2VtZW50TWFwICYmIChrLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IGMuZGlzcGxhY2VtZW50TWFwLCBrLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gYy5kaXNwbGFjZW1lbnRTY2FsZSwgay5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gYy5kaXNwbGFjZW1lbnRCaWFzKSA6IGMuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgJiYgKGMuYnVtcE1hcCAmJiAoay5idW1wTWFwLnZhbHVlID0gYy5idW1wTWFwLCBrLmJ1bXBTY2FsZS52YWx1ZSA9IGMuYnVtcFNjYWxlKSwgYy5ub3JtYWxNYXAgJiYgKGsubm9ybWFsTWFwLnZhbHVlID0gYy5ub3JtYWxNYXAsIGsubm9ybWFsU2NhbGUudmFsdWUuY29weShjLm5vcm1hbFNjYWxlKSksIGMuZGlzcGxhY2VtZW50TWFwICYmIChrLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IGMuZGlzcGxhY2VtZW50TWFwLCBrLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gYy5kaXNwbGFjZW1lbnRTY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IGMuZGlzcGxhY2VtZW50QmlhcykpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBrLmx0Y01hdCAmJiAoay5sdGNNYXQudmFsdWUgPSBUSFJFRS5Vbmlmb3Jtc0xpYi5MVENfTUFUX1RFWFRVUkUpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBrLmx0Y01hZyAmJiAoay5sdGNNYWcudmFsdWUgPSBUSFJFRS5Vbmlmb3Jtc0xpYi5MVENfTUFHX1RFWFRVUkUpO1xyXG4gICAgICAgICAgICAgICAgJGEudXBsb2FkKEIsIGcudW5pZm9ybXNMaXN0LCBrLCBQKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG0uc2V0KEIsIGQsIFwibW9kZWxWaWV3TWF0cml4XCIpO1xyXG4gICAgICAgICAgICBtLnNldChCLCBkLCBcIm5vcm1hbE1hdHJpeFwiKTtcclxuICAgICAgICAgICAgbS5zZXRWYWx1ZShCLCBcIm1vZGVsTWF0cml4XCIsIGQubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gaFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcihhLCBiKSB7XHJcbiAgICAgICAgICAgIGEuc3BlY3VsYXIudmFsdWUgPSBiLnNwZWN1bGFyO1xyXG4gICAgICAgICAgICBhLnNoaW5pbmVzcy52YWx1ZSA9IE1hdGgubWF4KGIuc2hpbmluZXNzLCAxRS00KTtcclxuICAgICAgICAgICAgYi5lbWlzc2l2ZU1hcCAmJiAoYS5lbWlzc2l2ZU1hcC52YWx1ZSA9IGIuZW1pc3NpdmVNYXApO1xyXG4gICAgICAgICAgICBiLmJ1bXBNYXAgJiYgKGEuYnVtcE1hcC52YWx1ZSA9IGIuYnVtcE1hcCxcclxuICAgICAgICAgICAgICAgIGEuYnVtcFNjYWxlLnZhbHVlID0gYi5idW1wU2NhbGUpO1xyXG4gICAgICAgICAgICBiLm5vcm1hbE1hcCAmJiAoYS5ub3JtYWxNYXAudmFsdWUgPSBiLm5vcm1hbE1hcCwgYS5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KGIubm9ybWFsU2NhbGUpKTtcclxuICAgICAgICAgICAgYi5kaXNwbGFjZW1lbnRNYXAgJiYgKGEuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gYi5kaXNwbGFjZW1lbnRNYXAsIGEuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBiLmRpc3BsYWNlbWVudFNjYWxlLCBhLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBiLmRpc3BsYWNlbWVudEJpYXMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBBKGEsIGIpIHtcclxuICAgICAgICAgICAgYS5yb3VnaG5lc3MudmFsdWUgPSBiLnJvdWdobmVzcztcclxuICAgICAgICAgICAgYS5tZXRhbG5lc3MudmFsdWUgPSBiLm1ldGFsbmVzcztcclxuICAgICAgICAgICAgYi5yb3VnaG5lc3NNYXAgJiYgKGEucm91Z2huZXNzTWFwLnZhbHVlID0gYi5yb3VnaG5lc3NNYXApO1xyXG4gICAgICAgICAgICBiLm1ldGFsbmVzc01hcCAmJiAoYS5tZXRhbG5lc3NNYXAudmFsdWUgPSBiLm1ldGFsbmVzc01hcCk7XHJcbiAgICAgICAgICAgIGIuZW1pc3NpdmVNYXAgJiYgKGEuZW1pc3NpdmVNYXAudmFsdWUgPSBiLmVtaXNzaXZlTWFwKTtcclxuICAgICAgICAgICAgYi5idW1wTWFwICYmIChhLmJ1bXBNYXAudmFsdWUgPSBiLmJ1bXBNYXAsIGEuYnVtcFNjYWxlLnZhbHVlID0gYi5idW1wU2NhbGUpO1xyXG4gICAgICAgICAgICBiLm5vcm1hbE1hcCAmJiAoYS5ub3JtYWxNYXAudmFsdWUgPSBiLm5vcm1hbE1hcCwgYS5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KGIubm9ybWFsU2NhbGUpKTtcclxuICAgICAgICAgICAgYi5kaXNwbGFjZW1lbnRNYXAgJiYgKGEuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gYi5kaXNwbGFjZW1lbnRNYXAsIGEuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBiLmRpc3BsYWNlbWVudFNjYWxlLCBhLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBiLmRpc3BsYWNlbWVudEJpYXMpO1xyXG4gICAgICAgICAgICBiLmVudk1hcCAmJiAoYS5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPSBiLmVudk1hcEludGVuc2l0eSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHcoYSkge1xyXG4gICAgICAgICAgICB2YXIgYjtcclxuICAgICAgICAgICAgaWYgKDFFMyA9PT0gYSlyZXR1cm4gQi5SRVBFQVQ7XHJcbiAgICAgICAgICAgIGlmICgxMDAxID09PSBhKXJldHVybiBCLkNMQU1QX1RPX0VER0U7XHJcbiAgICAgICAgICAgIGlmICgxMDAyID09PSBhKXJldHVybiBCLk1JUlJPUkVEX1JFUEVBVDtcclxuICAgICAgICAgICAgaWYgKDEwMDMgPT09IGEpcmV0dXJuIEIuTkVBUkVTVDtcclxuICAgICAgICAgICAgaWYgKDEwMDQgPT09IGEpcmV0dXJuIEIuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcclxuICAgICAgICAgICAgaWYgKDEwMDUgPT09IGEpcmV0dXJuIEIuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xyXG4gICAgICAgICAgICBpZiAoMTAwNiA9PT0gYSlyZXR1cm4gQi5MSU5FQVI7XHJcbiAgICAgICAgICAgIGlmICgxMDA3ID09PSBhKXJldHVybiBCLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcclxuICAgICAgICAgICAgaWYgKDEwMDggPT09IGEpcmV0dXJuIEIuTElORUFSX01JUE1BUF9MSU5FQVI7XHJcbiAgICAgICAgICAgIGlmICgxMDA5ID09PSBhKXJldHVybiBCLlVOU0lHTkVEX0JZVEU7XHJcbiAgICAgICAgICAgIGlmICgxMDE3ID09PSBhKXJldHVybiBCLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XHJcbiAgICAgICAgICAgIGlmICgxMDE4ID09PSBhKXJldHVybiBCLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XHJcbiAgICAgICAgICAgIGlmICgxMDE5ID09PSBhKXJldHVybiBCLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xyXG4gICAgICAgICAgICBpZiAoMTAxMCA9PT0gYSlyZXR1cm4gQi5CWVRFO1xyXG4gICAgICAgICAgICBpZiAoMTAxMSA9PT0gYSlyZXR1cm4gQi5TSE9SVDtcclxuICAgICAgICAgICAgaWYgKDEwMTIgPT09IGEpcmV0dXJuIEIuVU5TSUdORURfU0hPUlQ7XHJcbiAgICAgICAgICAgIGlmICgxMDEzID09PSBhKXJldHVybiBCLklOVDtcclxuICAgICAgICAgICAgaWYgKDEwMTQgPT09IGEpcmV0dXJuIEIuVU5TSUdORURfSU5UO1xyXG4gICAgICAgICAgICBpZiAoMTAxNSA9PT0gYSlyZXR1cm4gQi5GTE9BVDtcclxuICAgICAgICAgICAgaWYgKDEwMTYgPT09IGEgJiYgKGIgPSBqYS5nZXQoXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLCBudWxsICE9PSBiKSlyZXR1cm4gYi5IQUxGX0ZMT0FUX09FUztcclxuICAgICAgICAgICAgaWYgKDEwMjEgPT09IGEpcmV0dXJuIEIuQUxQSEE7XHJcbiAgICAgICAgICAgIGlmICgxMDIyID09PSBhKXJldHVybiBCLlJHQjtcclxuICAgICAgICAgICAgaWYgKDEwMjMgPT09IGEpcmV0dXJuIEIuUkdCQTtcclxuICAgICAgICAgICAgaWYgKDEwMjQgPT09IGEpcmV0dXJuIEIuTFVNSU5BTkNFO1xyXG4gICAgICAgICAgICBpZiAoMTAyNSA9PT0gYSlyZXR1cm4gQi5MVU1JTkFOQ0VfQUxQSEE7XHJcbiAgICAgICAgICAgIGlmICgxMDI2ID09PSBhKXJldHVybiBCLkRFUFRIX0NPTVBPTkVOVDtcclxuICAgICAgICAgICAgaWYgKDEwMjcgPT09IGEpcmV0dXJuIEIuREVQVEhfU1RFTkNJTDtcclxuICAgICAgICAgICAgaWYgKDEwMCA9PT0gYSlyZXR1cm4gQi5GVU5DX0FERDtcclxuICAgICAgICAgICAgaWYgKDEwMSA9PT0gYSlyZXR1cm4gQi5GVU5DX1NVQlRSQUNUO1xyXG4gICAgICAgICAgICBpZiAoMTAyID09PSBhKXJldHVybiBCLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcclxuICAgICAgICAgICAgaWYgKDIwMCA9PT0gYSlyZXR1cm4gQi5aRVJPO1xyXG4gICAgICAgICAgICBpZiAoMjAxID09PSBhKXJldHVybiBCLk9ORTtcclxuICAgICAgICAgICAgaWYgKDIwMiA9PT0gYSlyZXR1cm4gQi5TUkNfQ09MT1I7XHJcbiAgICAgICAgICAgIGlmICgyMDMgPT09IGEpcmV0dXJuIEIuT05FX01JTlVTX1NSQ19DT0xPUjtcclxuICAgICAgICAgICAgaWYgKDIwNCA9PT0gYSlyZXR1cm4gQi5TUkNfQUxQSEE7XHJcbiAgICAgICAgICAgIGlmICgyMDUgPT09IGEpcmV0dXJuIEIuT05FX01JTlVTX1NSQ19BTFBIQTtcclxuICAgICAgICAgICAgaWYgKDIwNiA9PT0gYSlyZXR1cm4gQi5EU1RfQUxQSEE7XHJcbiAgICAgICAgICAgIGlmICgyMDcgPT09IGEpcmV0dXJuIEIuT05FX01JTlVTX0RTVF9BTFBIQTtcclxuICAgICAgICAgICAgaWYgKDIwOCA9PT0gYSlyZXR1cm4gQi5EU1RfQ09MT1I7XHJcbiAgICAgICAgICAgIGlmICgyMDkgPT09IGEpcmV0dXJuIEIuT05FX01JTlVTX0RTVF9DT0xPUjtcclxuICAgICAgICAgICAgaWYgKDIxMCA9PT0gYSlyZXR1cm4gQi5TUkNfQUxQSEFfU0FUVVJBVEU7XHJcbiAgICAgICAgICAgIGlmICgyMDAxID09PSBhIHx8IDIwMDIgPT09IGEgfHwgMjAwMyA9PT0gYSB8fCAyMDA0ID09PSBhKWlmIChiID0gamEuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIiksIG51bGwgIT09IGIpIHtcclxuICAgICAgICAgICAgICAgIGlmICgyMDAxID09PSBhKXJldHVybiBiLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoMjAwMiA9PT0gYSlyZXR1cm4gYi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcclxuICAgICAgICAgICAgICAgIGlmICgyMDAzID09PSBhKXJldHVybiBiLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xyXG4gICAgICAgICAgICAgICAgaWYgKDIwMDQgPT09IGEpcmV0dXJuIGIuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoMjEwMCA9PT0gYSB8fCAyMTAxID09PSBhIHx8IDIxMDIgPT09IGEgfHwgMjEwMyA9PT0gYSlpZiAoYiA9IGphLmdldChcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSwgbnVsbCAhPT0gYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKDIxMDAgPT09IGEpcmV0dXJuIGIuQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcclxuICAgICAgICAgICAgICAgIGlmICgyMTAxID09PSBhKXJldHVybiBiLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XHJcbiAgICAgICAgICAgICAgICBpZiAoMjEwMiA9PT0gYSlyZXR1cm4gYi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcclxuICAgICAgICAgICAgICAgIGlmICgyMTAzID09PSBhKXJldHVybiBiLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKDIxNTEgPT09IGEgJiYgKGIgPSBqYS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSwgbnVsbCAhPT0gYikpcmV0dXJuIGIuQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTDtcclxuICAgICAgICAgICAgaWYgKDEwMyA9PT0gYSB8fCAxMDQgPT09IGEpaWYgKGIgPSBqYS5nZXQoXCJFWFRfYmxlbmRfbWlubWF4XCIpLFxyXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKDEwMyA9PT0gYSlyZXR1cm4gYi5NSU5fRVhUO1xyXG4gICAgICAgICAgICAgICAgaWYgKDEwNCA9PT0gYSlyZXR1cm4gYi5NQVhfRVhUXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDEwMjAgPT09IGEgJiYgKGIgPSBqYS5nZXQoXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIpLCBudWxsICE9PSBiKSA/IGIuVU5TSUdORURfSU5UXzI0XzhfV0VCR0wgOiAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUmVuZGVyZXJcIiwgXCI4NFwiKTtcclxuICAgICAgICBhID0gYSB8fCB7fTtcclxuICAgICAgICB2YXIgeSA9IHZvaWQgMCAhPT0gYS5jYW52YXMgPyBhLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJjYW52YXNcIiksXHJcbiAgICAgICAgICAgIEsgPSB2b2lkIDAgIT09IGEuY29udGV4dCA/IGEuY29udGV4dCA6IG51bGwsIHYgPSB2b2lkIDAgIT09IGEuYWxwaGEgPyBhLmFscGhhIDogITEsXHJcbiAgICAgICAgICAgIEUgPSB2b2lkIDAgIT09IGEuZGVwdGggPyBhLmRlcHRoIDogITAsIEwgPSB2b2lkIDAgIT09IGEuc3RlbmNpbCA/IGEuc3RlbmNpbCA6ICEwLFxyXG4gICAgICAgICAgICBDID0gdm9pZCAwICE9PSBhLmFudGlhbGlhcyA/IGEuYW50aWFsaWFzIDogITEsIEYgPSB2b2lkIDAgIT09IGEucHJlbXVsdGlwbGllZEFscGhhID9cclxuICAgICAgICAgICAgICAgIGEucHJlbXVsdGlwbGllZEFscGhhIDogITAsIHggPSB2b2lkIDAgIT09IGEucHJlc2VydmVEcmF3aW5nQnVmZmVyID8gYS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiAhMSwgSCA9IFtdLFxyXG4gICAgICAgICAgICBhYSA9IFtdLCBEID0gLTEsIHogPSBbXSwgVCA9IC0xLCBRID0gbmV3IEZsb2F0MzJBcnJheSg4KSwgTSA9IFtdLCBPID0gW107XHJcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0geTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc29ydE9iamVjdHMgPSB0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0aGlzLmF1dG9DbGVhckRlcHRoID0gdGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRoaXMuYXV0b0NsZWFyID0gITA7XHJcbiAgICAgICAgdGhpcy5jbGlwcGluZ1BsYW5lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQgPSAhMTtcclxuICAgICAgICB0aGlzLmdhbW1hRmFjdG9yID0gMjtcclxuICAgICAgICB0aGlzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gdGhpcy5nYW1tYU91dHB1dCA9IHRoaXMuZ2FtbWFJbnB1dCA9ICExO1xyXG4gICAgICAgIHRoaXMudG9uZU1hcHBpbmdXaGl0ZVBvaW50ID0gdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlID0gdGhpcy50b25lTWFwcGluZyA9IDE7XHJcbiAgICAgICAgdGhpcy5tYXhNb3JwaFRhcmdldHMgPVxyXG4gICAgICAgICAgICA4O1xyXG4gICAgICAgIHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcclxuICAgICAgICB2YXIgUCA9IHRoaXMsIHdhID0gbnVsbCwgVyA9IG51bGwsIE4gPSBudWxsLCBSID0gLTEsIFYgPSBcIlwiLCBVID0gbnVsbCwgWCA9IG5ldyBmYSwgU2EgPSBudWxsLCBaID0gbmV3IGZhLFxyXG4gICAgICAgICAgICBlYSA9IDAsIEVhID0gbmV3IEooMCksIGdiID0gMCwgbWQgPSB5LndpZHRoLCBDYyA9IHkuaGVpZ2h0LCBSYSA9IDEsIGdhID0gbmV3IGZhKDAsIDAsIG1kLCBDYyksIGthID0gITEsXHJcbiAgICAgICAgICAgIGlhID0gbmV3IGZhKDAsIDAsIG1kLCBDYyksIG1hID0gbmV3IHRjLCBjYSA9IG5ldyBVZiwgb2EgPSAhMSwgcmEgPSAhMSwgbmEgPSBuZXcgTmEsIHVhID0gbmV3IFMsIEdhID0gbmV3IHEsXHJcbiAgICAgICAgICAgIEJhID0gbmV3IFMsIHhhID0gbmV3IFMsIGJhID0ge1xyXG4gICAgICAgICAgICAgICAgaGFzaDogXCJcIixcclxuICAgICAgICAgICAgICAgIGFtYmllbnQ6IFswLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbmFsOiBbXSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbmFsU2hhZG93TWFwOiBbXSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcclxuICAgICAgICAgICAgICAgIHNwb3Q6IFtdLFxyXG4gICAgICAgICAgICAgICAgc3BvdFNoYWRvd01hcDogW10sXHJcbiAgICAgICAgICAgICAgICBzcG90U2hhZG93TWF0cml4OiBbXSxcclxuICAgICAgICAgICAgICAgIHJlY3RBcmVhOiBbXSxcclxuICAgICAgICAgICAgICAgIHBvaW50OiBbXSxcclxuICAgICAgICAgICAgICAgIHBvaW50U2hhZG93TWFwOiBbXSxcclxuICAgICAgICAgICAgICAgIHBvaW50U2hhZG93TWF0cml4OiBbXSxcclxuICAgICAgICAgICAgICAgIGhlbWk6IFtdLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93czogW11cclxuICAgICAgICAgICAgfSwgcGEgPSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsczogMCxcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzOiAwLCBmYWNlczogMCwgcG9pbnRzOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5pbmZvID0ge3JlbmRlcjogcGEsIG1lbW9yeToge2dlb21ldHJpZXM6IDAsIHRleHR1cmVzOiAwfSwgcHJvZ3JhbXM6IG51bGx9O1xyXG4gICAgICAgIHZhciBCO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHYgPSB7YWxwaGE6IHYsIGRlcHRoOiBFLCBzdGVuY2lsOiBMLCBhbnRpYWxpYXM6IEMsIHByZW11bHRpcGxpZWRBbHBoYTogRiwgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB4fTtcclxuICAgICAgICAgICAgQiA9IEsgfHwgeS5nZXRDb250ZXh0KFwid2ViZ2xcIiwgdikgfHwgeS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHYpO1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gQikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHkuZ2V0Q29udGV4dChcIndlYmdsXCIpKXRocm93XCJFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLlwiO1xyXG4gICAgICAgICAgICAgICAgdGhyb3dcIkVycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdm9pZCAwID09PSBCLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCAmJiAoQi5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlTWluOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlTWF4OiAxLCBwcmVjaXNpb246IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHkuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgZCwgITEpXHJcbiAgICAgICAgfSBjYXRjaCAoVmYpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFwiICsgVmYpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBqYSA9IG5ldyBUZihCKTtcclxuICAgICAgICBqYS5nZXQoXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIpO1xyXG4gICAgICAgIGphLmdldChcIk9FU190ZXh0dXJlX2Zsb2F0XCIpO1xyXG4gICAgICAgIGphLmdldChcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKTtcclxuICAgICAgICBqYS5nZXQoXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO1xyXG4gICAgICAgIGphLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpO1xyXG4gICAgICAgIGphLmdldChcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKTtcclxuICAgICAgICBqYS5nZXQoXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xyXG4gICAgICAgIGphLmdldChcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIikgJiYgKEkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2KTtcclxuICAgICAgICB2YXIgbGEgPSBuZXcgU2YoQiwgamEsIGEpLCBZID0gbmV3IFJmKEIsIGphLCB3KSwgaGEgPSBuZXcgUWYsIHRhID0gbmV3IFBmKEIsIGphLCBZLCBoYSwgbGEsXHJcbiAgICAgICAgICAgIHcsIHRoaXMuaW5mbyksIHFhID0gbmV3IE9mKEIsIGhhLCB0aGlzLmluZm8pLCB5YSA9IG5ldyBNZih0aGlzLCBsYSksIHphID0gbmV3IEVmO1xyXG4gICAgICAgIHRoaXMuaW5mby5wcm9ncmFtcyA9IHlhLnByb2dyYW1zO1xyXG4gICAgICAgIHZhciBMYSA9IG5ldyBEZihCLCBqYSwgcGEpLCBPYSA9IG5ldyBDZihCLCBqYSwgcGEpLCBJYSwgQ2EsIHNhLCB2YTtcclxuICAgICAgICBiKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gQjtcclxuICAgICAgICB0aGlzLmNhcGFiaWxpdGllcyA9IGxhO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGphO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IGhhO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBZO1xyXG4gICAgICAgIHZhciBNYSA9IG5ldyBLZSh0aGlzLCBiYSwgcWEsIGxhKTtcclxuICAgICAgICB0aGlzLnNoYWRvd01hcCA9IE1hO1xyXG4gICAgICAgIHZhciBQYSA9IG5ldyB6Zih0aGlzLCBNKSwgUWEgPSBuZXcgeWYodGhpcywgTyk7XHJcbiAgICAgICAgdGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEIuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5mb3JjZUNvbnRleHRMb3NzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBqYS5nZXQoXCJXRUJHTF9sb3NlX2NvbnRleHRcIikubG9zZUNvbnRleHQoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGEuZ2V0TWF4QW5pc290cm9weSgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhLnByZWNpc2lvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYSAmJiAoUmEgPSBhLCB0aGlzLnNldFNpemUoaWEueiwgaWEudywgITEpKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge3dpZHRoOiBtZCwgaGVpZ2h0OiBDY31cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIG1kID0gYTtcclxuICAgICAgICAgICAgQ2MgPSBiO1xyXG4gICAgICAgICAgICB5LndpZHRoID0gYSAqIFJhO1xyXG4gICAgICAgICAgICB5LmhlaWdodCA9IGIgKiBSYTtcclxuICAgICAgICAgICAgITEgIT09IGMgJiYgKHkuc3R5bGUud2lkdGggPSBhICsgXCJweFwiLCB5LnN0eWxlLmhlaWdodCA9IGIgKyBcInB4XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIGEsIGIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgWS52aWV3cG9ydChpYS5zZXQoYSwgYiwgYywgZCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldFNjaXNzb3IgPVxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgWS5zY2lzc29yKGdhLnNldChhLCBiLCBjLCBkKSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgWS5zZXRTY2lzc29yVGVzdChrYSA9IGEpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFYVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgRWEuc2V0KGEpO1xyXG4gICAgICAgICAgICBnYiA9IHZvaWQgMCAhPT0gYiA/IGIgOiAxO1xyXG4gICAgICAgICAgICBZLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoRWEuciwgRWEuZywgRWEuYiwgZ2IsIEYpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnYlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZ2IgPSBhO1xyXG4gICAgICAgICAgICBZLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoRWEuciwgRWEuZywgRWEuYiwgZ2IsIEYpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBhIHx8IGEpIGQgfD0gQi5DT0xPUl9CVUZGRVJfQklUO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBiIHx8IGIpIGQgfD0gQi5ERVBUSF9CVUZGRVJfQklUO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBjIHx8XHJcbiAgICAgICAgICAgICAgICBjKSBkIHw9IEIuU1RFTkNJTF9CVUZGRVJfQklUO1xyXG4gICAgICAgICAgICBCLmNsZWFyKGQpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoITAsICExLCAhMSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcighMSwgITAsICExKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoITEsICExLCAhMClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldChhKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcihiLCBjLCBkKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZXNldEdMU3RhdGUgPSBjO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgeiA9IFtdO1xyXG4gICAgICAgICAgICBUID0gLTE7XHJcbiAgICAgICAgICAgIGFhID0gW107XHJcbiAgICAgICAgICAgIEQgPSAtMTtcclxuICAgICAgICAgICAgeS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCBkLCAhMSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgWS5pbml0QXR0cmlidXRlcygpO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGhhLmdldChhKTtcclxuICAgICAgICAgICAgYS5oYXNQb3NpdGlvbnMgJiYgIWQucG9zaXRpb24gJiYgKGQucG9zaXRpb24gPSBCLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgICAgICAgYS5oYXNOb3JtYWxzICYmICFkLm5vcm1hbCAmJiAoZC5ub3JtYWwgPSBCLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgICAgICAgYS5oYXNVdnMgJiYgIWQudXYgJiYgKGQudXYgPSBCLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgICAgICAgYS5oYXNDb2xvcnMgJiYgIWQuY29sb3IgJiYgKGQuY29sb3IgPSBCLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgICAgICAgYiA9IGIuZ2V0QXR0cmlidXRlcygpO1xyXG4gICAgICAgICAgICBhLmhhc1Bvc2l0aW9ucyAmJiAoQi5iaW5kQnVmZmVyKEIuQVJSQVlfQlVGRkVSLCBkLnBvc2l0aW9uKSwgQi5idWZmZXJEYXRhKEIuQVJSQVlfQlVGRkVSLCBhLnBvc2l0aW9uQXJyYXksIEIuRFlOQU1JQ19EUkFXKSwgWS5lbmFibGVBdHRyaWJ1dGUoYi5wb3NpdGlvbiksIEIudmVydGV4QXR0cmliUG9pbnRlcihiLnBvc2l0aW9uLCAzLCBCLkZMT0FULCAhMSwgMCwgMCkpO1xyXG4gICAgICAgICAgICBpZiAoYS5oYXNOb3JtYWxzKSB7XHJcbiAgICAgICAgICAgICAgICBCLmJpbmRCdWZmZXIoQi5BUlJBWV9CVUZGRVIsIGQubm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIGlmICghYy5pc01lc2hQaG9uZ01hdGVyaWFsICYmICFjLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgJiYgIWMuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgJiYgMSA9PT1cclxuICAgICAgICAgICAgICAgICAgICBjLnNoYWRpbmcpZm9yICh2YXIgZSA9IDAsIGYgPSAzICogYS5jb3VudDsgZSA8IGY7IGUgKz0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gYS5ub3JtYWxBcnJheSwgaCA9IChnW2UgKyAwXSArIGdbZSArIDNdICsgZ1tlICsgNl0pIC8gMyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IChnW2UgKyAxXSArIGdbZSArIDRdICsgZ1tlICsgN10pIC8gMywgayA9IChnW2UgKyAyXSArIGdbZSArIDVdICsgZ1tlICsgOF0pIC8gMztcclxuICAgICAgICAgICAgICAgICAgICBnW2UgKyAwXSA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZ1tlICsgMV0gPSBtO1xyXG4gICAgICAgICAgICAgICAgICAgIGdbZSArIDJdID0gaztcclxuICAgICAgICAgICAgICAgICAgICBnW2UgKyAzXSA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZ1tlICsgNF0gPSBtO1xyXG4gICAgICAgICAgICAgICAgICAgIGdbZSArIDVdID0gaztcclxuICAgICAgICAgICAgICAgICAgICBnW2UgKyA2XSA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZ1tlICsgN10gPSBtO1xyXG4gICAgICAgICAgICAgICAgICAgIGdbZSArIDhdID0ga1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgQi5idWZmZXJEYXRhKEIuQVJSQVlfQlVGRkVSLCBhLm5vcm1hbEFycmF5LCBCLkRZTkFNSUNfRFJBVyk7XHJcbiAgICAgICAgICAgICAgICBZLmVuYWJsZUF0dHJpYnV0ZShiLm5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBCLnZlcnRleEF0dHJpYlBvaW50ZXIoYi5ub3JtYWwsIDMsIEIuRkxPQVQsICExLCAwLCAwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGEuaGFzVXZzICYmIGMubWFwICYmIChCLmJpbmRCdWZmZXIoQi5BUlJBWV9CVUZGRVIsIGQudXYpLCBCLmJ1ZmZlckRhdGEoQi5BUlJBWV9CVUZGRVIsIGEudXZBcnJheSwgQi5EWU5BTUlDX0RSQVcpLCBZLmVuYWJsZUF0dHJpYnV0ZShiLnV2KSwgQi52ZXJ0ZXhBdHRyaWJQb2ludGVyKGIudXYsXHJcbiAgICAgICAgICAgICAgICAyLCBCLkZMT0FULCAhMSwgMCwgMCkpO1xyXG4gICAgICAgICAgICBhLmhhc0NvbG9ycyAmJiAwICE9PSBjLnZlcnRleENvbG9ycyAmJiAoQi5iaW5kQnVmZmVyKEIuQVJSQVlfQlVGRkVSLCBkLmNvbG9yKSwgQi5idWZmZXJEYXRhKEIuQVJSQVlfQlVGRkVSLCBhLmNvbG9yQXJyYXksIEIuRFlOQU1JQ19EUkFXKSwgWS5lbmFibGVBdHRyaWJ1dGUoYi5jb2xvciksIEIudmVydGV4QXR0cmliUG9pbnRlcihiLmNvbG9yLCAzLCBCLkZMT0FULCAhMSwgMCwgMCkpO1xyXG4gICAgICAgICAgICBZLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgICAgIEIuZHJhd0FycmF5cyhCLlRSSUFOR0xFUywgMCwgYS5jb3VudCk7XHJcbiAgICAgICAgICAgIGEuY291bnQgPSAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgICAgIGwoZCk7XHJcbiAgICAgICAgICAgIHZhciBoID0gRyhhLCBiLCBkLCBlKSwgbSA9ICExO1xyXG4gICAgICAgICAgICBhID0gYy5pZCArIFwiX1wiICsgaC5pZCArIFwiX1wiICsgZC53aXJlZnJhbWU7XHJcbiAgICAgICAgICAgIGEgIT09IFYgJiYgKFYgPSBhLCBtID0gITApO1xyXG4gICAgICAgICAgICBiID0gZS5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gW107XHJcbiAgICAgICAgICAgICAgICBhID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBiLmxlbmd0aDsgYSA8IG47IGErKyltID1cclxuICAgICAgICAgICAgICAgICAgICBiW2FdLCBrLnB1c2goW20sIGFdKTtcclxuICAgICAgICAgICAgICAgIGsuc29ydChnKTtcclxuICAgICAgICAgICAgICAgIDggPCBrLmxlbmd0aCAmJiAoay5sZW5ndGggPSA4KTtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gYy5tb3JwaEF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICBhID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobiA9IGsubGVuZ3RoOyBhIDwgbjsgYSsrKW0gPSBrW2FdLCBRW2FdID0gbVswXSwgMCAhPT0gbVswXSA/IChiID0gbVsxXSwgITAgPT09IGQubW9ycGhUYXJnZXRzICYmIHQucG9zaXRpb24gJiYgYy5hZGRBdHRyaWJ1dGUoXCJtb3JwaFRhcmdldFwiICsgYSwgdC5wb3NpdGlvbltiXSksICEwID09PSBkLm1vcnBoTm9ybWFscyAmJiB0Lm5vcm1hbCAmJiBjLmFkZEF0dHJpYnV0ZShcIm1vcnBoTm9ybWFsXCIgKyBhLCB0Lm5vcm1hbFtiXSkpIDogKCEwID09PSBkLm1vcnBoVGFyZ2V0cyAmJiBjLnJlbW92ZUF0dHJpYnV0ZShcIm1vcnBoVGFyZ2V0XCIgKyBhKSwgITAgPT09IGQubW9ycGhOb3JtYWxzICYmIGMucmVtb3ZlQXR0cmlidXRlKFwibW9ycGhOb3JtYWxcIiArIGEpKTtcclxuICAgICAgICAgICAgICAgIGEgPSBrLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoYiA9IFEubGVuZ3RoOyBhIDwgYjsgYSsrKVFbYV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgaC5nZXRVbmlmb3JtcygpLnNldFZhbHVlKEIsIFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIsIFEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICEwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IGMuaW5kZXg7XHJcbiAgICAgICAgICAgIG4gPSBjLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAhMCA9PT0gZC53aXJlZnJhbWUgJiYgKGIgPSBxYS5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoYyksIGsgPSAyKTtcclxuICAgICAgICAgICAgbnVsbCAhPT0gYiA/IChhID0gT2EsIGEuc2V0SW5kZXgoYikpIDogYSA9IExhO1xyXG4gICAgICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgYTp7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB2b2lkIDAsIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgJiYgYy5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICYmIChwID0gamEuZ2V0KFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKSwgbnVsbCA9PT0gcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGFcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBtICYmIChtID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgWS5pbml0QXR0cmlidXRlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYy5hdHRyaWJ1dGVzLCBoID0gaC5nZXRBdHRyaWJ1dGVzKCksIHIgPSBkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHE7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChxIGluIGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBoW3FdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA8PSB5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRbcV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSB2Lm5vcm1hbGl6ZWQsIEEgPSB2Lml0ZW1TaXplLCBLID0gcWEuZ2V0QXR0cmlidXRlUHJvcGVydGllcyh2KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQyA9IEsuX193ZWJnbEJ1ZmZlciwgTCA9IEsudHlwZSwgSyA9IEsuYnl0ZXNQZXJFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2LmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEYgPSB2LmRhdGEsIEUgPSBGLnN0cmlkZSwgdiA9IHYub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGICYmIEYuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA/IChZLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoeSwgRi5tZXNoUGVyQXR0cmlidXRlLCBwKSwgdm9pZCAwID09PSBjLm1heEluc3RhbmNlZENvdW50ICYmIChjLm1heEluc3RhbmNlZENvdW50ID0gRi5tZXNoUGVyQXR0cmlidXRlICogRi5jb3VudCkpIDogWS5lbmFibGVBdHRyaWJ1dGUoeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIuYmluZEJ1ZmZlcihCLkFSUkFZX0JVRkZFUiwgQyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIudmVydGV4QXR0cmliUG9pbnRlcih5LCBBLCBMLCB3LCBFICogSywgKG0gKiBFICsgdikgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugdi5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA/IChZLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoeSwgdi5tZXNoUGVyQXR0cmlidXRlLCBwKSwgdm9pZCAwID09PSBjLm1heEluc3RhbmNlZENvdW50ICYmIChjLm1heEluc3RhbmNlZENvdW50ID0gdi5tZXNoUGVyQXR0cmlidXRlICogdi5jb3VudCkpIDogWS5lbmFibGVBdHRyaWJ1dGUoeSksIEIuYmluZEJ1ZmZlcihCLkFSUkFZX0JVRkZFUiwgQyksIEIudmVydGV4QXR0cmliUG9pbnRlcih5LCBBLCBMLCB3LCAwLCBtICogQSAqIEspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gciAmJiAodyA9IHJbcV0sIHZvaWQgMCAhPT0gdykpc3dpdGNoICh3Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQi52ZXJ0ZXhBdHRyaWIyZnYoeSwgdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQi52ZXJ0ZXhBdHRyaWIzZnYoeSwgdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQi52ZXJ0ZXhBdHRyaWI0ZnYoeSwgdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIudmVydGV4QXR0cmliMWZ2KHksIHcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgWS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBudWxsICE9PSBiICYmIEIuYmluZEJ1ZmZlcihCLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxyXG4gICAgICAgICAgICAgICAgICAgIHFhLmdldEF0dHJpYnV0ZUJ1ZmZlcihiKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gMDtcclxuICAgICAgICAgICAgbnVsbCAhPT0gYiA/IHAgPSBiLmNvdW50IDogdm9pZCAwICE9PSBuICYmIChwID0gbi5jb3VudCk7XHJcbiAgICAgICAgICAgIGIgPSBjLmRyYXdSYW5nZS5zdGFydCAqIGs7XHJcbiAgICAgICAgICAgIG4gPSBudWxsICE9PSBmID8gZi5zdGFydCAqIGsgOiAwO1xyXG4gICAgICAgICAgICBxID0gTWF0aC5tYXgoYiwgbik7XHJcbiAgICAgICAgICAgIGYgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwLCBiICsgYy5kcmF3UmFuZ2UuY291bnQgKiBrLCBuICsgKG51bGwgIT09IGYgPyBmLmNvdW50ICogayA6IEluZmluaXR5KSkgLSAxIC0gcSArIDEpO1xyXG4gICAgICAgICAgICBpZiAoMCAhPT0gZikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaXNNZXNoKWlmICghMCA9PT0gZC53aXJlZnJhbWUpIFkuc2V0TGluZVdpZHRoKGQud2lyZWZyYW1lTGluZXdpZHRoICogKG51bGwgPT09IFcgPyBSYSA6IDEpKSwgYS5zZXRNb2RlKEIuTElORVMpOyBlbHNlIHN3aXRjaCAoZS5kcmF3TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5zZXRNb2RlKEIuVFJJQU5HTEVTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnNldE1vZGUoQi5UUklBTkdMRV9TVFJJUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5zZXRNb2RlKEIuVFJJQU5HTEVfRkFOKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGUuaXNMaW5lID8gKGQgPSBkLmxpbmV3aWR0aCwgdm9pZCAwID09PVxyXG4gICAgICAgICAgICAgICAgZCAmJiAoZCA9IDEpLCBZLnNldExpbmVXaWR0aChkICogKG51bGwgPT09IFcgPyBSYSA6IDEpKSwgZS5pc0xpbmVTZWdtZW50cyA/IGEuc2V0TW9kZShCLkxJTkVTKSA6IGEuc2V0TW9kZShCLkxJTkVfU1RSSVApKSA6IGUuaXNQb2ludHMgJiYgYS5zZXRNb2RlKEIuUE9JTlRTKTtcclxuICAgICAgICAgICAgICAgIGMgJiYgYy5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID8gMCA8IGMubWF4SW5zdGFuY2VkQ291bnQgJiYgYS5yZW5kZXJJbnN0YW5jZXMoYywgcSwgZikgOiBhLnJlbmRlcihxLCBmKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGIgJiYgITAgIT09IGIuaXNDYW1lcmEpIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuXCIpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFYgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgUiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgVSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAhMCA9PT0gYS5hdXRvVXBkYXRlICYmIGEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuICAgICAgICAgICAgICAgIG51bGwgPT09IGIucGFyZW50ICYmIGIudXBkYXRlTWF0cml4V29ybGQoKTtcclxuICAgICAgICAgICAgICAgIGIubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoYi5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICB1YS5tdWx0aXBseU1hdHJpY2VzKGIucHJvamVjdGlvbk1hdHJpeCwgYi5tYXRyaXhXb3JsZEludmVyc2UpO1xyXG4gICAgICAgICAgICAgICAgbWEuc2V0RnJvbU1hdHJpeCh1YSk7XHJcbiAgICAgICAgICAgICAgICBILmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBUID0gRCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgTS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgTy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgcmEgPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgb2EgPSBjYS5pbml0KHRoaXMuY2xpcHBpbmdQbGFuZXMsIHJhLCBiKTtcclxuICAgICAgICAgICAgICAgIHAoYSwgYik7XHJcbiAgICAgICAgICAgICAgICBhYS5sZW5ndGggPSBEICsgMTtcclxuICAgICAgICAgICAgICAgIHoubGVuZ3RoID0gVCArIDE7XHJcbiAgICAgICAgICAgICAgICAhMCA9PT0gUC5zb3J0T2JqZWN0cyAmJiAoYWEuc29ydChoKSwgei5zb3J0KG0pKTtcclxuICAgICAgICAgICAgICAgIG9hICYmIGNhLmJlZ2luU2hhZG93cygpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IEgsIGYgPSAwLCBnID0gMCwgayA9IGUubGVuZ3RoOyBnIDwgazsgZysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlW2ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuY2FzdFNoYWRvdyAmJiAoYmEuc2hhZG93c1tmKytdID0gdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJhLnNoYWRvd3MubGVuZ3RoID0gZjtcclxuICAgICAgICAgICAgICAgIE1hLnJlbmRlcihhLCBiKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSBILCBsID0gdCA9IDAsIHUgPSAwLCByLCBHLCBxLCB5LCB2ID0gYi5tYXRyaXhXb3JsZEludmVyc2UsIHcgPSAwLCBBID0gMCwgSyA9IDAsIEMgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgTCA9IDAsIGYgPSAwLCBnID0gZS5sZW5ndGg7IGYgPCBnOyBmKyspaWYgKGsgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlW2ZdLCByID0gay5jb2xvciwgRyA9IGsuaW50ZW5zaXR5LCBxID0gay5kaXN0YW5jZSwgeSA9IGsuc2hhZG93ICYmIGsuc2hhZG93Lm1hcCA/IGsuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbCwgay5pc0FtYmllbnRMaWdodCkgdCArPSByLnIgKiBHLCBsICs9IHIuZyAqIEcsIHUgKz0gci5iICogRzsgZWxzZSBpZiAoay5pc0RpcmVjdGlvbmFsTGlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRSA9IHphLmdldChrKTtcclxuICAgICAgICAgICAgICAgICAgICBFLmNvbG9yLmNvcHkoay5jb2xvcikubXVsdGlwbHlTY2FsYXIoay5pbnRlbnNpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIEUuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihrLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgICAgICBHYS5zZXRGcm9tTWF0cml4UG9zaXRpb24oay50YXJnZXQubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIEUuZGlyZWN0aW9uLnN1YihHYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgRS5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChFLnNoYWRvdyA9IGsuY2FzdFNoYWRvdykgRS5zaGFkb3dCaWFzID0gay5zaGFkb3cuYmlhcywgRS5zaGFkb3dSYWRpdXMgPSBrLnNoYWRvdy5yYWRpdXMsIEUuc2hhZG93TWFwU2l6ZSA9IGsuc2hhZG93Lm1hcFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgYmEuZGlyZWN0aW9uYWxTaGFkb3dNYXBbd10gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGJhLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4W3ddID0gay5zaGFkb3cubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJhLmRpcmVjdGlvbmFsW3crK10gPSBFXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsuaXNTcG90TGlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBFID0gemEuZ2V0KGspO1xyXG4gICAgICAgICAgICAgICAgICAgIEUucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGsubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIEUucG9zaXRpb24uYXBwbHlNYXRyaXg0KHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIEUuY29sb3IuY29weShyKS5tdWx0aXBseVNjYWxhcihHKTtcclxuICAgICAgICAgICAgICAgICAgICBFLmRpc3RhbmNlID0gcTtcclxuICAgICAgICAgICAgICAgICAgICBFLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oay5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgR2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGsudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgICAgICBFLmRpcmVjdGlvbi5zdWIoR2EpO1xyXG4gICAgICAgICAgICAgICAgICAgIEUuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2KTtcclxuICAgICAgICAgICAgICAgICAgICBFLmNvbmVDb3MgPSBNYXRoLmNvcyhrLmFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICBFLnBlbnVtYnJhQ29zID0gTWF0aC5jb3Moay5hbmdsZSAqICgxIC0gay5wZW51bWJyYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIEUuZGVjYXkgPSAwID09PSBrLmRpc3RhbmNlID8gMCA6IGsuZGVjYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEUuc2hhZG93ID0gay5jYXN0U2hhZG93KSBFLnNoYWRvd0JpYXMgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrLnNoYWRvdy5iaWFzLCBFLnNoYWRvd1JhZGl1cyA9IGsuc2hhZG93LnJhZGl1cywgRS5zaGFkb3dNYXBTaXplID0gay5zaGFkb3cubWFwU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBiYS5zcG90U2hhZG93TWFwW0tdID0geTtcclxuICAgICAgICAgICAgICAgICAgICBiYS5zcG90U2hhZG93TWF0cml4W0tdID0gay5zaGFkb3cubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJhLnNwb3RbSysrXSA9IEVcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoay5pc1JlY3RBcmVhTGlnaHQpIEUgPSB6YS5nZXQoayksIEUuY29sb3IuY29weShyKS5tdWx0aXBseVNjYWxhcihHIC8gKGsud2lkdGggKiBrLmhlaWdodCkpLCBFLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihrLm1hdHJpeFdvcmxkKSwgRS5wb3NpdGlvbi5hcHBseU1hdHJpeDQodiksIHhhLmlkZW50aXR5KCksIEJhLmNvcHkoay5tYXRyaXhXb3JsZCksIEJhLnByZW11bHRpcGx5KHYpLCB4YS5leHRyYWN0Um90YXRpb24oQmEpLCBFLmhhbGZXaWR0aC5zZXQoLjUgKiBrLndpZHRoLCAwLCAwKSwgRS5oYWxmSGVpZ2h0LnNldCgwLCAuNSAqIGsuaGVpZ2h0LCAwKSwgRS5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KHhhKSwgRS5oYWxmSGVpZ2h0LmFwcGx5TWF0cml4NCh4YSksXHJcbiAgICAgICAgICAgICAgICAgICAgYmEucmVjdEFyZWFbQysrXSA9IEU7IGVsc2UgaWYgKGsuaXNQb2ludExpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRSA9IHphLmdldChrKTtcclxuICAgICAgICAgICAgICAgICAgICBFLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihrLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgICAgICBFLnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2KTtcclxuICAgICAgICAgICAgICAgICAgICBFLmNvbG9yLmNvcHkoay5jb2xvcikubXVsdGlwbHlTY2FsYXIoay5pbnRlbnNpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIEUuZGlzdGFuY2UgPSBrLmRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIEUuZGVjYXkgPSAwID09PSBrLmRpc3RhbmNlID8gMCA6IGsuZGVjYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEUuc2hhZG93ID0gay5jYXN0U2hhZG93KSBFLnNoYWRvd0JpYXMgPSBrLnNoYWRvdy5iaWFzLCBFLnNoYWRvd1JhZGl1cyA9IGsuc2hhZG93LnJhZGl1cywgRS5zaGFkb3dNYXBTaXplID0gay5zaGFkb3cubWFwU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBiYS5wb2ludFNoYWRvd01hcFtBXSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBiYS5wb2ludFNoYWRvd01hdHJpeFtBXSAmJiAoYmEucG9pbnRTaGFkb3dNYXRyaXhbQV0gPSBuZXcgUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgR2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGsubWF0cml4V29ybGQpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhLnBvaW50U2hhZG93TWF0cml4W0FdLmlkZW50aXR5KCkuc2V0UG9zaXRpb24oR2EpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhLnBvaW50W0ErK10gPSBFXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Ugay5pc0hlbWlzcGhlcmVMaWdodCAmJiAoRSA9IHphLmdldChrKSwgRS5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGsubWF0cml4V29ybGQpLCBFLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odiksIEUuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpLCBFLnNreUNvbG9yLmNvcHkoay5jb2xvcikubXVsdGlwbHlTY2FsYXIoRyksIEUuZ3JvdW5kQ29sb3IuY29weShrLmdyb3VuZENvbG9yKS5tdWx0aXBseVNjYWxhcihHKSwgYmEuaGVtaVtMKytdID0gRSk7XHJcbiAgICAgICAgICAgICAgICBiYS5hbWJpZW50WzBdID0gdDtcclxuICAgICAgICAgICAgICAgIGJhLmFtYmllbnRbMV0gPSBsO1xyXG4gICAgICAgICAgICAgICAgYmEuYW1iaWVudFsyXSA9IHU7XHJcbiAgICAgICAgICAgICAgICBiYS5kaXJlY3Rpb25hbC5sZW5ndGggPSB3O1xyXG4gICAgICAgICAgICAgICAgYmEuc3BvdC5sZW5ndGggPSBLO1xyXG4gICAgICAgICAgICAgICAgYmEucmVjdEFyZWEubGVuZ3RoID0gQztcclxuICAgICAgICAgICAgICAgIGJhLnBvaW50Lmxlbmd0aCA9IEE7XHJcbiAgICAgICAgICAgICAgICBiYS5oZW1pLmxlbmd0aCA9IEw7XHJcbiAgICAgICAgICAgICAgICBiYS5oYXNoID0gdyArIFwiLFwiICsgQSArIFwiLFwiICsgSyArIFwiLFwiICsgQyArIFwiLFwiICsgTCArIFwiLFwiICsgYmEuc2hhZG93cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBvYSAmJiBjYS5lbmRTaGFkb3dzKCk7XHJcbiAgICAgICAgICAgICAgICBwYS5jYWxscyA9XHJcbiAgICAgICAgICAgICAgICAgICAgMDtcclxuICAgICAgICAgICAgICAgIHBhLnZlcnRpY2VzID0gMDtcclxuICAgICAgICAgICAgICAgIHBhLmZhY2VzID0gMDtcclxuICAgICAgICAgICAgICAgIHBhLnBvaW50cyA9IDA7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGMgJiYgKGMgPSBudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KGMpO1xyXG4gICAgICAgICAgICAgICAgZSA9IGEuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgICAgIG51bGwgPT09IGUgPyBZLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoRWEuciwgRWEuZywgRWEuYiwgZ2IsIEYpIDogZSAmJiBlLmlzQ29sb3IgJiYgKFkuYnVmZmVycy5jb2xvci5zZXRDbGVhcihlLnIsIGUuZywgZS5iLCAxLCBGKSwgZCA9ICEwKTtcclxuICAgICAgICAgICAgICAgICh0aGlzLmF1dG9DbGVhciB8fCBkKSAmJiB0aGlzLmNsZWFyKHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCk7XHJcbiAgICAgICAgICAgICAgICBlICYmIGUuaXNDdWJlVGV4dHVyZSA/ICh2b2lkIDAgPT09IHNhICYmIChzYSA9IG5ldyBGYSwgdmEgPSBuZXcgQWEobmV3IGtiKDUsIDUsIDUpLCBuZXcgSGEoe1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBiYi5jdWJlLnVuaWZvcm1zLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogYmIuY3ViZS52ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGJiLmN1YmUuZnJhZ21lbnRTaGFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZTogMSxcclxuICAgICAgICAgICAgICAgICAgICBkZXB0aFRlc3Q6ICExLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoV3JpdGU6ICExLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvZzogITFcclxuICAgICAgICAgICAgICAgIH0pKSksIHNhLnByb2plY3Rpb25NYXRyaXguY29weShiLnByb2plY3Rpb25NYXRyaXgpLCBzYS5tYXRyaXhXb3JsZC5leHRyYWN0Um90YXRpb24oYi5tYXRyaXhXb3JsZCksIHNhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKHNhLm1hdHJpeFdvcmxkKSwgdmEubWF0ZXJpYWwudW5pZm9ybXMudEN1YmUudmFsdWUgPSBlLCB2YS5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhzYS5tYXRyaXhXb3JsZEludmVyc2UsIHZhLm1hdHJpeFdvcmxkKSwgcWEudXBkYXRlKHZhKSwgUC5yZW5kZXJCdWZmZXJEaXJlY3Qoc2EsIG51bGwsIHZhLmdlb21ldHJ5LCB2YS5tYXRlcmlhbCwgdmEsIG51bGwpKSA6IGUgJiYgZS5pc1RleHR1cmUgJiYgKHZvaWQgMCA9PT0gSWEgJiYgKElhID0gbmV3IEpiKC0xLCAxLCAxLCAtMSwgMCwgMSksIENhID0gbmV3IEFhKG5ldyBsYigyLCAyKSwgbmV3IEthKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhUZXN0OiAhMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhXcml0ZTogITEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvZzogITFcclxuICAgICAgICAgICAgICAgICAgICB9KSkpLCBDYS5tYXRlcmlhbC5tYXAgPSBlLCBxYS51cGRhdGUoQ2EpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQLnJlbmRlckJ1ZmZlckRpcmVjdChJYSwgbnVsbCwgQ2EuZ2VvbWV0cnksIENhLm1hdGVyaWFsLCBDYSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgYS5vdmVycmlkZU1hdGVyaWFsID8gKGQgPSBhLm92ZXJyaWRlTWF0ZXJpYWwsIG4oYWEsIGEsIGIsIGQpLCBuKHosIGEsIGIsIGQpKSA6IChZLnNldEJsZW5kaW5nKDApLCBuKGFhLCBhLCBiKSwgbih6LCBhLCBiKSk7XHJcbiAgICAgICAgICAgICAgICBQYS5yZW5kZXIoYSwgYik7XHJcbiAgICAgICAgICAgICAgICBRYS5yZW5kZXIoYSwgYiwgWik7XHJcbiAgICAgICAgICAgICAgICBjICYmIHRhLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChjKTtcclxuICAgICAgICAgICAgICAgIFkuc2V0RGVwdGhUZXN0KCEwKTtcclxuICAgICAgICAgICAgICAgIFkuc2V0RGVwdGhXcml0ZSghMCk7XHJcbiAgICAgICAgICAgICAgICBZLnNldENvbG9yV3JpdGUoITApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBZLnNldEN1bGxGYWNlKGEpO1xyXG4gICAgICAgICAgICBZLnNldEZsaXBTaWRlZCgwID09PSBiKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hbGxvY1RleHR1cmVVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGVhO1xyXG4gICAgICAgICAgICBhID49IGxhLm1heFRleHR1cmVzICYmIGNvbnNvbGUud2FybihcIldlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgXCIgKyBhICsgXCIgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5IFwiICtcclxuICAgICAgICAgICAgICAgIGxhLm1heFRleHR1cmVzKTtcclxuICAgICAgICAgICAgZWEgKz0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZTJEID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9ICExO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIGIgJiYgYi5pc1dlYkdMUmVuZGVyVGFyZ2V0ICYmIChhIHx8IChjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnNldFRleHR1cmUyRDogZG9uJ3QgdXNlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiksIGEgPSAhMCksIGIgPSBiLnRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgdGEuc2V0VGV4dHVyZTJEKGIsIGMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCk7XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9ICExO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIGEgfHwgKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlIGlzIGRlcHJlY2F0ZWQsIHVzZSBzZXRUZXh0dXJlMkQgaW5zdGVhZC5cIiksIGEgPSAhMCk7XHJcbiAgICAgICAgICAgICAgICB0YS5zZXRUZXh0dXJlMkQoYiwgYylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKTtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmVDdWJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9XHJcbiAgICAgICAgICAgICAgICAhMTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICBiICYmIGIuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgJiYgKGEgfHwgKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZUN1YmU6IGRvbid0IHVzZSBjdWJlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiksIGEgPSAhMCksIGIgPSBiLnRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgYiAmJiBiLmlzQ3ViZVRleHR1cmUgfHwgQXJyYXkuaXNBcnJheShiLmltYWdlKSAmJiA2ID09PSBiLmltYWdlLmxlbmd0aCA/IHRhLnNldFRleHR1cmVDdWJlKGIsIGMpIDogdGEuc2V0VGV4dHVyZUN1YmVEeW5hbWljKGIsIGMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCk7XHJcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gV1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAoVyA9IGEpICYmIHZvaWQgMCA9PT0gaGEuZ2V0KGEpLl9fd2ViZ2xGcmFtZWJ1ZmZlciAmJiB0YS5zZXR1cFJlbmRlclRhcmdldChhKTtcclxuICAgICAgICAgICAgdmFyIGIgPSBhICYmIGEuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUsXHJcbiAgICAgICAgICAgICAgICBjO1xyXG4gICAgICAgICAgICBhID8gKGMgPSBoYS5nZXQoYSksIGMgPSBiID8gYy5fX3dlYmdsRnJhbWVidWZmZXJbYS5hY3RpdmVDdWJlRmFjZV0gOiBjLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgWC5jb3B5KGEuc2Npc3NvciksIFNhID0gYS5zY2lzc29yVGVzdCwgWi5jb3B5KGEudmlld3BvcnQpKSA6IChjID0gbnVsbCwgWC5jb3B5KGdhKS5tdWx0aXBseVNjYWxhcihSYSksIFNhID0ga2EsIFouY29weShpYSkubXVsdGlwbHlTY2FsYXIoUmEpKTtcclxuICAgICAgICAgICAgTiAhPT0gYyAmJiAoQi5iaW5kRnJhbWVidWZmZXIoQi5GUkFNRUJVRkZFUiwgYyksIE4gPSBjKTtcclxuICAgICAgICAgICAgWS5zY2lzc29yKFgpO1xyXG4gICAgICAgICAgICBZLnNldFNjaXNzb3JUZXN0KFNhKTtcclxuICAgICAgICAgICAgWS52aWV3cG9ydChaKTtcclxuICAgICAgICAgICAgYiAmJiAoYiA9IGhhLmdldChhLnRleHR1cmUpLCBCLmZyYW1lYnVmZmVyVGV4dHVyZTJEKEIuRlJBTUVCVUZGRVIsIEIuQ09MT1JfQVRUQUNITUVOVDAsIEIuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgYS5hY3RpdmVDdWJlRmFjZSwgYi5fX3dlYmdsVGV4dHVyZSwgYS5hY3RpdmVNaXBNYXBMZXZlbCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPVxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCExID09PSAoYSAmJiBhLmlzV2ViR0xSZW5kZXJUYXJnZXQpKSBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LlwiKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBoYS5nZXQoYSkuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgIT09IE4gJiYgKEIuYmluZEZyYW1lYnVmZmVyKEIuRlJBTUVCVUZGRVIsIGcpLCBoID0gITApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBhLnRleHR1cmUsIG0gPSBrLmZvcm1hdCwgbiA9IGsudHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMjMgIT09IG0gJiYgdyhtKSAhPT0gQi5nZXRQYXJhbWV0ZXIoQi5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCkgPyBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuXCIpIDogMTAwOSA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gfHwgdyhuKSA9PT0gQi5nZXRQYXJhbWV0ZXIoQi5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUpIHx8IDEwMTUgPT09IG4gJiYgKGphLmdldChcIk9FU190ZXh0dXJlX2Zsb2F0XCIpIHx8IGphLmdldChcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSkgfHwgMTAxNiA9PT0gbiAmJiBqYS5nZXQoXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikgPyBCLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoQi5GUkFNRUJVRkZFUikgPT09IEIuRlJBTUVCVUZGRVJfQ09NUExFVEUgPyAwIDw9IGIgJiYgYiA8PSBhLndpZHRoIC0gZCAmJiAwIDw9IGMgJiYgYyA8PSBhLmhlaWdodCAtIGUgJiYgQi5yZWFkUGl4ZWxzKGIsIGMsIGQsIGUsIHcobSksIHcobiksIGYpIDogY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS5cIikgOiBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQi5iaW5kRnJhbWVidWZmZXIoQi5GUkFNRUJVRkZFUiwgTilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEtiKGEsIGIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgSihhKTtcclxuICAgICAgICB0aGlzLmRlbnNpdHkgPSB2b2lkIDAgIT09IGIgPyBiIDogMi41RS00XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTGIoYSwgYiwgYykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBKKGEpO1xyXG4gICAgICAgIHRoaXMubmVhciA9IHZvaWQgMCAhPT0gYiA/IGIgOiAxO1xyXG4gICAgICAgIHRoaXMuZmFyID0gdm9pZCAwICE9PSBjID8gYyA6IDFFM1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1iKCkge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlNjZW5lXCI7XHJcbiAgICAgICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5mb2cgPSB0aGlzLmJhY2tncm91bmQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0b1VwZGF0ZSA9ICEwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWmQoYSwgYiwgYywgZCwgZSkge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmxlbnNGbGFyZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IHE7XHJcbiAgICAgICAgdGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHZvaWQgMDtcclxuICAgICAgICB2b2lkIDAgIT09IGEgJiYgdGhpcy5hZGQoYSwgYiwgYywgZCwgZSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuYihhKSB7XHJcbiAgICAgICAgWC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiU3ByaXRlTWF0ZXJpYWxcIjtcclxuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IEooMTY3NzcyMTUpO1xyXG4gICAgICAgIHRoaXMubWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLmxpZ2h0cyA9IHRoaXMuZm9nID0gITE7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZXMoYSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBEYyhhKSB7XHJcbiAgICAgICAgeC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiU3ByaXRlXCI7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHZvaWQgMCAhPT0gYSA/IGEgOiBuZXcgbmJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBFYygpIHtcclxuICAgICAgICB4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJMT0RcIjtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7bGV2ZWxzOiB7ZW51bWVyYWJsZTogITAsIHZhbHVlOiBbXX19KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9kKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB2b2lkIDAgIT09IGMgPyBjIDogITA7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBTO1xyXG4gICAgICAgIGEgPSBhIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuYm9uZXMgPSBhLnNsaWNlKDApO1xyXG4gICAgICAgIHRoaXMudXNlVmVydGV4VGV4dHVyZSA/IChhID0gTWF0aC5zcXJ0KDQgKiB0aGlzLmJvbmVzLmxlbmd0aCksIGEgPSBOLm5leHRQb3dlck9mVHdvKE1hdGguY2VpbChhKSksXHJcbiAgICAgICAgICAgIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgPSB0aGlzLmJvbmVUZXh0dXJlV2lkdGggPSBhID0gTWF0aC5tYXgoYSwgNCksIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJvbmVUZXh0dXJlV2lkdGggKiB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ICogNCksIHRoaXMuYm9uZVRleHR1cmUgPSBuZXcgZWIodGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgMTAyMywgMTAxNSkpIDogdGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KDE2ICogdGhpcy5ib25lcy5sZW5ndGgpO1xyXG4gICAgICAgIGlmICh2b2lkIDAgPT09IGIpIHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTsgZWxzZSBpZiAodGhpcy5ib25lcy5sZW5ndGggPT09IGIubGVuZ3RoKSB0aGlzLmJvbmVJbnZlcnNlcyA9IGIuc2xpY2UoMCk7IGVsc2UgZm9yIChjb25zb2xlLndhcm4oXCJUSFJFRS5Ta2VsZXRvbiBib25JbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLlwiKSwgdGhpcy5ib25lSW52ZXJzZXMgPSBbXSwgYiA9XHJcbiAgICAgICAgICAgIDAsIGEgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGE7IGIrKyl0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKG5ldyBTKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBkKCkge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIkJvbmVcIlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHFkKGEsIGIsIGMpIHtcclxuICAgICAgICBBYS5jYWxsKHRoaXMsIGEsIGIpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiU2tpbm5lZE1lc2hcIjtcclxuICAgICAgICB0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xyXG4gICAgICAgIHRoaXMuYmluZE1hdHJpeCA9IG5ldyBTO1xyXG4gICAgICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgUztcclxuICAgICAgICBhID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvbWV0cnkgJiYgdm9pZCAwICE9PSB0aGlzLmdlb21ldHJ5LmJvbmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGQsIGUgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICBmID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGUgPCBmOyArK2UpZCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbZV0sIGIgPSBuZXcgcGQsIGEucHVzaChiKSwgYi5uYW1lID0gZC5uYW1lLCBiLnBvc2l0aW9uLmZyb21BcnJheShkLnBvcyksIGIucXVhdGVybmlvbi5mcm9tQXJyYXkoZC5yb3RxKSwgdm9pZCAwICE9PSBkLnNjbCAmJiBiLnNjYWxlLmZyb21BcnJheShkLnNjbCk7XHJcbiAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGYgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgZSA8IGY7ICsrZSlkID0gdGhpcy5nZW9tZXRyeS5ib25lc1tlXSwgLTEgIT09IGQucGFyZW50ICYmIG51bGwgIT09IGQucGFyZW50ICYmIHZvaWQgMCAhPT0gYVtkLnBhcmVudF0gPyBhW2QucGFyZW50XS5hZGQoYVtlXSkgOiB0aGlzLmFkZChhW2VdKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCghMCk7XHJcbiAgICAgICAgdGhpcy5iaW5kKG5ldyBvZChhLCB2b2lkIDAsIGMpLCB0aGlzLm1hdHJpeFdvcmxkKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlhKGEpIHtcclxuICAgICAgICBYLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJMaW5lQmFzaWNNYXRlcmlhbFwiO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgSigxNjc3NzIxNSk7XHJcbiAgICAgICAgdGhpcy5saW5ld2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMubGluZWpvaW4gPSB0aGlzLmxpbmVjYXAgPSBcInJvdW5kXCI7XHJcbiAgICAgICAgdGhpcy5saWdodHMgPSAhMTtcclxuICAgICAgICB0aGlzLnNldFZhbHVlcyhhKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFVhKGEsIGIsIGMpIHtcclxuICAgICAgICBpZiAoMSA9PT0gYylyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuTGluZTogcGFyYW1ldGVyIFRIUkVFLkxpbmVQaWVjZXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gQ3JlYXRlZCBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC5cIiksXHJcbiAgICAgICAgICAgIG5ldyBnYShhLCBiKTtcclxuICAgICAgICB4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJMaW5lXCI7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IHZvaWQgMCAhPT0gYSA/IGEgOiBuZXcgSTtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsID0gdm9pZCAwICE9PSBiID8gYiA6IG5ldyBpYSh7Y29sb3I6IDE2Nzc3MjE1ICogTWF0aC5yYW5kb20oKX0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2EoYSwgYikge1xyXG4gICAgICAgIFVhLmNhbGwodGhpcywgYSwgYik7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJMaW5lU2VnbWVudHNcIlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE9hKGEpIHtcclxuICAgICAgICBYLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJQb2ludHNNYXRlcmlhbFwiO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgSigxNjc3NzIxNSk7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5zaXplQXR0ZW51YXRpb24gPSAhMDtcclxuICAgICAgICB0aGlzLmxpZ2h0cyA9ICExO1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWVzKGEpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTWIoYSwgYikge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlBvaW50c1wiO1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSB2b2lkIDAgIT09IGEgPyBhIDogbmV3IEk7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHZvaWQgMCAhPT0gYiA/IGIgOiBuZXcgT2Eoe2NvbG9yOiAxNjc3NzIxNSAqIE1hdGgucmFuZG9tKCl9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEZjKCkge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIkdyb3VwXCJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBtKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaygpIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGspO1xyXG4gICAgICAgICAgICBhLnJlYWR5U3RhdGUgPj0gYS5IQVZFX0NVUlJFTlRfREFUQSAmJiAodC5uZWVkc1VwZGF0ZSA9ICEwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWEuY2FsbCh0aGlzLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBtKTtcclxuICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9ICExO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcztcclxuICAgICAgICBrKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBOYihhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBtLCBrLCB0LCBwKSB7XHJcbiAgICAgICAgZWEuY2FsbCh0aGlzLCBudWxsLCBmLCBnLCBoLCBtLCBrLCBkLCBlLCB0LCBwKTtcclxuICAgICAgICB0aGlzLmltYWdlID0ge3dpZHRoOiBiLCBoZWlnaHQ6IGN9O1xyXG4gICAgICAgIHRoaXMubWlwbWFwcyA9IGE7XHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0aGlzLmZsaXBZID0gITFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBtKSB7XHJcbiAgICAgICAgZWEuY2FsbCh0aGlzLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBtKTtcclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gITBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHYyhhLCBiLCBjLCBkLCBlLCBmLCBnLFxyXG4gICAgICAgICAgICAgICAgaCwgbSwgaykge1xyXG4gICAgICAgIGsgPSB2b2lkIDAgIT09IGsgPyBrIDogMTAyNjtcclxuICAgICAgICBpZiAoMTAyNiAhPT0gayAmJiAxMDI3ICE9PSBrKXRocm93IEVycm9yKFwiRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXRcIik7XHJcbiAgICAgICAgdm9pZCAwID09PSBjICYmIDEwMjYgPT09IGsgJiYgKGMgPSAxMDEyKTtcclxuICAgICAgICB2b2lkIDAgPT09IGMgJiYgMTAyNyA9PT0gayAmJiAoYyA9IDEwMjApO1xyXG4gICAgICAgIGVhLmNhbGwodGhpcywgbnVsbCwgZCwgZSwgZiwgZywgaCwgaywgYywgbSk7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IHt3aWR0aDogYSwgaGVpZ2h0OiBifTtcclxuICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHZvaWQgMCAhPT0gZyA/IGcgOiAxMDAzO1xyXG4gICAgICAgIHRoaXMubWluRmlsdGVyID0gdm9pZCAwICE9PSBoID8gaCA6IDEwMDM7XHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0aGlzLmZsaXBZID0gITFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBPYihhKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhIC0gYlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiV2lyZWZyYW1lR2VvbWV0cnlcIjtcclxuICAgICAgICB2YXIgYyA9IFtdLCBkLCBlLCBmLCBnLCBoID0gWzAsIDBdLCBtID0ge30sIGssIHQgPSBbXCJhXCIsIFwiYlwiLFxyXG4gICAgICAgICAgICBcImNcIl07XHJcbiAgICAgICAgaWYgKGEgJiYgYS5pc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgIHZhciBwID0gYS5mYWNlcztcclxuICAgICAgICAgICAgZCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoZiA9IHAubGVuZ3RoOyBkIDwgZjsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHBbZF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGUgPSAwOyAzID4gZTsgZSsrKWhbMF0gPSBuW3RbZV1dLCBoWzFdID0gblt0WyhlICsgMSkgJSAzXV0sIGguc29ydChiKSwgayA9IGgudG9TdHJpbmcoKSwgdm9pZCAwID09PSBtW2tdICYmIChtW2tdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4MTogaFswXSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDI6IGhbMV1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChrIGluIG0pZCA9IG1ba10sIHQgPSBhLnZlcnRpY2VzW2QuaW5kZXgxXSwgYy5wdXNoKHQueCwgdC55LCB0LnopLCB0ID0gYS52ZXJ0aWNlc1tkLmluZGV4Ml0sIGMucHVzaCh0LngsIHQueSwgdC56KVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYSAmJiBhLmlzQnVmZmVyR2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgdmFyIGwsIHQgPSBuZXcgcTtcclxuICAgICAgICAgICAgaWYgKG51bGwgIT09IGEuaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBhLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBuID0gYS5pbmRleDtcclxuICAgICAgICAgICAgICAgIGwgPSBhLmdyb3VwcztcclxuICAgICAgICAgICAgICAgIDAgPT09IGwubGVuZ3RoICYmIGEuYWRkR3JvdXAoMCwgbi5jb3VudCk7XHJcbiAgICAgICAgICAgICAgICBhID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoZyA9IGwubGVuZ3RoOyBhIDwgZzsgKythKWZvciAoZCA9IGxbYV0sIGUgPSBkLnN0YXJ0LCBmID0gZC5jb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBlLCBmID0gZSArIGY7IGQgPCBmOyBkICs9IDMpZm9yIChlID0gMDsgMyA+IGU7IGUrKyloWzBdID0gbi5nZXRYKGQgKyBlKSwgaFsxXSA9IG4uZ2V0WChkICsgKGUgKyAxKSAlIDMpLCBoLnNvcnQoYiksIGsgPSBoLnRvU3RyaW5nKCksIHZvaWQgMCA9PT0gbVtrXSAmJiAobVtrXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDE6IGhbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgyOiBoWzFdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGZvciAoayBpbiBtKWQgPSBtW2tdLCB0LmZyb21CdWZmZXJBdHRyaWJ1dGUocCwgZC5pbmRleDEpLCBjLnB1c2godC54LCB0LnksIHQueiksIHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwLCBkLmluZGV4MiksIGMucHVzaCh0LngsIHQueSwgdC56KVxyXG4gICAgICAgICAgICB9IGVsc2UgZm9yIChwID0gYS5hdHRyaWJ1dGVzLnBvc2l0aW9uLCBkID0gMCwgZiA9IHAuY291bnQgLyAzOyBkIDwgZjsgZCsrKWZvciAoZSA9IDA7IDMgPiBlOyBlKyspbSA9IDMgKiBkICsgZSwgdC5mcm9tQnVmZmVyQXR0cmlidXRlKHAsIG0pLCBjLnB1c2godC54LCB0LnksIHQueiksIG0gPSAzICogZCArIChlICsgMSkgJSAzLCB0LmZyb21CdWZmZXJBdHRyaWJ1dGUocCwgbSksIGMucHVzaCh0LngsIHQueSwgdC56KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KGMsIDMpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEhjKGEsIGIsIGMpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJQYXJhbWV0cmljR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7ZnVuYzogYSwgc2xpY2VzOiBiLCBzdGFja3M6IGN9O1xyXG4gICAgICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBQYihhLCBiLCBjKSk7XHJcbiAgICAgICAgdGhpcy5tZXJnZVZlcnRpY2VzKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBQYihhLCBiLCBjKSB7XHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge2Z1bmM6IGEsIHNsaWNlczogYiwgc3RhY2tzOiBjfTtcclxuICAgICAgICB2YXIgZCA9IFtdLCBlID0gW10sIGYgPSBbXSwgZywgaCwgbSA9IGIgKyAxO1xyXG4gICAgICAgIGZvciAoZyA9IDA7IGcgPD0gYzsgZysrKSB7XHJcbiAgICAgICAgICAgIHZhciBrID0gZyAvIGM7XHJcbiAgICAgICAgICAgIGZvciAoaCA9IDA7IGggPD0gYjsgaCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGggLyBiLCBwID0gYSh0LCBrKTtcclxuICAgICAgICAgICAgICAgIGUucHVzaChwLngsIHAueSwgcC56KTtcclxuICAgICAgICAgICAgICAgIGYucHVzaCh0LCBrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoZyA9IDA7IGcgPCBjOyBnKyspZm9yIChoID0gMDsgaCA8IGI7IGgrKylhID0gZyAqIG0gKyBoICsgMSwgayA9IChnICsgMSkgKiBtICsgaCArIDEsIHQgPSAoZyArIDEpICogbSArIGgsIGQucHVzaChnICogbSArIGgsIGEsIHQpLCBkLnB1c2goYSwgayxcclxuICAgICAgICAgICAgdCk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleChkKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KGUsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInV2XCIsIG5ldyB6KGYsIDIpKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJYyhhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgVC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiUG9seWhlZHJvbkdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3ZlcnRpY2VzOiBhLCBpbmRpY2VzOiBiLCByYWRpdXM6IGMsIGRldGFpbDogZH07XHJcbiAgICAgICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkobmV3IEJhKGEsIGIsIGMsIGQpKTtcclxuICAgICAgICB0aGlzLm1lcmdlVmVydGljZXMoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEJhKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICBmdW5jdGlvbiBlKGEpIHtcclxuICAgICAgICAgICAgaC5wdXNoKGEueCwgYS55LCBhLnopXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmKGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSAzICogYjtcclxuICAgICAgICAgICAgYy54ID0gYVtkICsgMF07XHJcbiAgICAgICAgICAgIGMueSA9IGFbZCArIDFdO1xyXG4gICAgICAgICAgICBjLnogPSBhW2QgKyAyXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZyhhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIDAgPiBkICYmIDEgPT09IGEueCAmJiAobVtiXSA9IGEueCAtIDEpO1xyXG4gICAgICAgICAgICAwID09PSBjLnggJiYgMCA9PT0gYy56ICYmIChtW2JdID0gZCAvIDIgLyBNYXRoLlBJICtcclxuICAgICAgICAgICAgICAgIC41KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3ZlcnRpY2VzOiBhLCBpbmRpY2VzOiBiLCByYWRpdXM6IGMsIGRldGFpbDogZH07XHJcbiAgICAgICAgYyA9IGMgfHwgMTtcclxuICAgICAgICB2YXIgaCA9IFtdLCBtID0gW107XHJcbiAgICAgICAgKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSBuZXcgcSwgZCA9IG5ldyBxLCBnID0gbmV3IHEsIGggPSAwOyBoIDwgYi5sZW5ndGg7IGggKz0gMykge1xyXG4gICAgICAgICAgICAgICAgZihiW2ggKyAwXSwgYyk7XHJcbiAgICAgICAgICAgICAgICBmKGJbaCArIDFdLCBkKTtcclxuICAgICAgICAgICAgICAgIGYoYltoICsgMl0sIGcpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBjLCBsID0gZCwgQSA9IGcsIHcgPSBNYXRoLnBvdygyLCBhKSwgeSA9IFtdLCBLLCB2O1xyXG4gICAgICAgICAgICAgICAgZm9yIChLID0gMDsgSyA8PSB3OyBLKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB5W0tdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIEUgPSBtLmNsb25lKCkubGVycChBLCBLIC8gdyksIEwgPSBsLmNsb25lKCkubGVycChBLCBLIC8gdyksIEMgPSB3IC0gSztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDw9IEM7IHYrKyl5W0tdW3ZdID0gMCA9PT0gdiAmJiBLID09PSB3ID8gRSA6IEUuY2xvbmUoKS5sZXJwKEwsIHYgLyBDKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChLID0gMDsgSyA8IHc7IEsrKylmb3IgKHYgPSAwOyB2IDwgMiAqICh3IC0gSykgLSAxOyB2KyspbSA9IE1hdGguZmxvb3IodiAvIDIpLCAwID09PSB2ICUgMiA/IChlKHlbS11bbSArIDFdKSxcclxuICAgICAgICAgICAgICAgICAgICBlKHlbSyArIDFdW21dKSwgZSh5W0tdW21dKSkgOiAoZSh5W0tdW20gKyAxXSksIGUoeVtLICsgMV1bbSArIDFdKSwgZSh5W0sgKyAxXVttXSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KShkIHx8IDApO1xyXG4gICAgICAgIChmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gbmV3IHEsXHJcbiAgICAgICAgICAgICAgICAgICAgIGMgPSAwOyBjIDwgaC5sZW5ndGg7IGMgKz0gMyliLnggPSBoW2MgKyAwXSwgYi55ID0gaFtjICsgMV0sIGIueiA9IGhbYyArIDJdLCBiLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGEpLCBoW2MgKyAwXSA9IGIueCwgaFtjICsgMV0gPSBiLnksIGhbYyArIDJdID0gYi56XHJcbiAgICAgICAgfSkoYyk7XHJcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IG5ldyBxLFxyXG4gICAgICAgICAgICAgICAgICAgICBiID0gMDsgYiA8IGgubGVuZ3RoOyBiICs9IDMpYS54ID0gaFtiICsgMF0sIGEueSA9IGhbYiArIDFdLCBhLnogPSBoW2IgKyAyXSwgbS5wdXNoKE1hdGguYXRhbjIoYS56LCAtYS54KSAvIDIgLyBNYXRoLlBJICsgLjUsIDEgLSAoTWF0aC5hdGFuMigtYS55LCBNYXRoLnNxcnQoYS54ICogYS54ICsgYS56ICogYS56KSkgLyBNYXRoLlBJICsgLjUpKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IG5ldyBxLCBiID0gbmV3IHEsIGMgPSBuZXcgcSwgZCA9IG5ldyBxLCBlID0gbmV3IEQsIGYgPSBuZXcgRCwgbCA9IG5ldyBELCBBID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgdyA9IDA7IEEgPCBoLmxlbmd0aDsgQSArPSA5LCB3ICs9XHJcbiAgICAgICAgICAgICAgICA2KSB7XHJcbiAgICAgICAgICAgICAgICBhLnNldChoW0EgKyAwXSwgaFtBICsgMV0sIGhbQSArIDJdKTtcclxuICAgICAgICAgICAgICAgIGIuc2V0KGhbQSArIDNdLCBoW0EgKyA0XSwgaFtBICsgNV0pO1xyXG4gICAgICAgICAgICAgICAgYy5zZXQoaFtBICsgNl0sIGhbQSArIDddLCBoW0EgKyA4XSk7XHJcbiAgICAgICAgICAgICAgICBlLnNldChtW3cgKyAwXSwgbVt3ICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgZi5zZXQobVt3ICsgMl0sIG1bdyArIDNdKTtcclxuICAgICAgICAgICAgICAgIGwuc2V0KG1bdyArIDRdLCBtW3cgKyA1XSk7XHJcbiAgICAgICAgICAgICAgICBkLmNvcHkoYSkuYWRkKGIpLmFkZChjKS5kaXZpZGVTY2FsYXIoMyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IE1hdGguYXRhbjIoZC56LCAtZC54KTtcclxuICAgICAgICAgICAgICAgIGcoZSwgdyArIDAsIGEsIHkpO1xyXG4gICAgICAgICAgICAgICAgZyhmLCB3ICsgMiwgYiwgeSk7XHJcbiAgICAgICAgICAgICAgICBnKGwsIHcgKyA0LCBjLCB5KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCBtLmxlbmd0aDsgYSArPSA2KWIgPSBtW2EgKyAwXSwgYyA9IG1bYSArIDJdLCBkID0gbVthICsgNF0sIGUgPSBNYXRoLm1pbihiLCBjLCBkKSwgLjkgPCBNYXRoLm1heChiLCBjLCBkKSAmJiAuMSA+IGUgJiYgKC4yID4gYiAmJiAobVthICsgMF0gKz0gMSksIC4yID4gYyAmJiAobVthICsgMl0gKz0gMSksIC4yID4gZCAmJiAobVthICsgNF0gKz0gMSkpXHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KGgsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgeihoLnNsaWNlKCksIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInV2XCIsXHJcbiAgICAgICAgICAgIG5ldyB6KG0sIDIpKTtcclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEpjKGEsIGIpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJUZXRyYWhlZHJvbkdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3JhZGl1czogYSwgZGV0YWlsOiBifTtcclxuICAgICAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeShuZXcgUWIoYSwgYikpO1xyXG4gICAgICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUWIoYSwgYikge1xyXG4gICAgICAgIEJhLmNhbGwodGhpcywgWzEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTFdLCBbMiwgMSwgMCwgMCwgMywgMiwgMSwgMywgMCwgMiwgMywgMV0sIGEsIGIpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtyYWRpdXM6IGEsIGRldGFpbDogYn1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBLYyhhLCBiKSB7XHJcbiAgICAgICAgVC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiT2N0YWhlZHJvbkdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3JhZGl1czogYSwgZGV0YWlsOiBifTtcclxuICAgICAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeShuZXcgb2IoYSwgYikpO1xyXG4gICAgICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb2IoYSwgYikge1xyXG4gICAgICAgIEJhLmNhbGwodGhpcywgWzEsIDAsIDAsIC0xLCAwLCAwLCAwLCAxLCAwLCAwLCAtMSwgMCwgMCwgMCwgMSwgMCwgMCwgLTFdLCBbMCwgMiwgNCwgMCwgNCwgMywgMCwgMywgNSwgMCwgNSwgMiwgMSwgMiwgNSwgMSwgNSwgMywgMSwgMywgNCwgMSwgNCwgMl0sIGEsIGIpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3JhZGl1czogYSwgZGV0YWlsOiBifVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIExjKGEsIGIpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJJY29zYWhlZHJvbkdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3JhZGl1czogYSwgZGV0YWlsOiBifTtcclxuICAgICAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeShuZXcgUmIoYSwgYikpO1xyXG4gICAgICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUmIoYSwgYikge1xyXG4gICAgICAgIHZhciBjID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcclxuICAgICAgICBCYS5jYWxsKHRoaXMsIFstMSwgYywgMCwgMSwgYywgMCwgLTEsIC1jLCAwLCAxLCAtYywgMCwgMCwgLTEsIGMsIDAsIDEsIGMsIDAsIC0xLCAtYywgMCwgMSwgLWMsIGMsIDAsIC0xLCBjLCAwLCAxLCAtYywgMCwgLTEsIC1jLCAwLCAxXSwgWzAsIDExLFxyXG4gICAgICAgICAgICA1LCAwLCA1LCAxLCAwLCAxLCA3LCAwLCA3LCAxMCwgMCwgMTAsIDExLCAxLCA1LCA5LCA1LCAxMSwgNCwgMTEsIDEwLCAyLCAxMCwgNywgNiwgNywgMSwgOCwgMywgOSwgNCwgMywgNCwgMiwgMywgMiwgNiwgMywgNiwgOCwgMywgOCwgOSwgNCwgOSwgNSwgMiwgNCwgMTEsIDYsIDIsIDEwLCA4LCA2LCA3LCA5LCA4LCAxXSwgYSwgYik7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3JhZGl1czogYSwgZGV0YWlsOiBifVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE1jKGEsIGIpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJEb2RlY2FoZWRyb25HZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtyYWRpdXM6IGEsIGRldGFpbDogYn07XHJcbiAgICAgICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkobmV3IFNiKGEsIGIpKTtcclxuICAgICAgICB0aGlzLm1lcmdlVmVydGljZXMoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFNiKGEsIGIpIHtcclxuICAgICAgICB2YXIgYyA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDIsIGQgPSAxIC8gYztcclxuICAgICAgICBCYS5jYWxsKHRoaXMsIFstMSwgLTEsIC0xLCAtMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIDEsIC0xLCAxLCAxLCAxLCAwLCAtZCwgLWMsIDAsIC1kLCBjLCAwLFxyXG4gICAgICAgICAgICBkLCAtYywgMCwgZCwgYywgLWQsIC1jLCAwLCAtZCwgYywgMCwgZCwgLWMsIDAsIGQsIGMsIDAsIC1jLCAwLCAtZCwgYywgMCwgLWQsIC1jLCAwLCBkLCBjLCAwLCBkXSwgWzMsIDExLCA3LCAzLCA3LCAxNSwgMywgMTUsIDEzLCA3LCAxOSwgMTcsIDcsIDE3LCA2LCA3LCA2LCAxNSwgMTcsIDQsIDgsIDE3LCA4LCAxMCwgMTcsIDEwLCA2LCA4LCAwLCAxNiwgOCwgMTYsIDIsIDgsIDIsIDEwLCAwLCAxMiwgMSwgMCwgMSwgMTgsIDAsIDE4LCAxNiwgNiwgMTAsIDIsIDYsIDIsIDEzLCA2LCAxMywgMTUsIDIsIDE2LCAxOCwgMiwgMTgsIDMsIDIsIDMsIDEzLCAxOCwgMSwgOSwgMTgsIDksIDExLCAxOCwgMTEsIDMsIDQsIDE0LCAxMiwgNCwgMTIsIDAsIDQsIDAsIDgsIDExLCA5LCA1LCAxMSwgNSwgMTksIDExLCAxOSwgNywgMTksIDUsIDE0LCAxOSwgMTQsIDQsIDE5LCA0LCAxNywgMSwgMTIsIDE0LCAxLCAxNCwgNSwgMSwgNSwgOV0sIGEsIGIpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7cmFkaXVzOiBhLCBkZXRhaWw6IGJ9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTmMoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgIFQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlR1YmVHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgcGF0aDogYSxcclxuICAgICAgICAgICAgdHVidWxhclNlZ21lbnRzOiBiLCByYWRpdXM6IGMsIHJhZGlhbFNlZ21lbnRzOiBkLCBjbG9zZWQ6IGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZvaWQgMCAhPT0gZiAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5UdWJlR2VvbWV0cnk6IHRhcGVyIGhhcyBiZWVuIHJlbW92ZWQuXCIpO1xyXG4gICAgICAgIGEgPSBuZXcgVGIoYSwgYiwgYywgZCwgZSk7XHJcbiAgICAgICAgdGhpcy50YW5nZW50cyA9IGEudGFuZ2VudHM7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxzID0gYS5ub3JtYWxzO1xyXG4gICAgICAgIHRoaXMuYmlub3JtYWxzID0gYS5iaW5vcm1hbHM7XHJcbiAgICAgICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoYSk7XHJcbiAgICAgICAgdGhpcy5tZXJnZVZlcnRpY2VzKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBUYihhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZihlKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gYS5nZXRQb2ludEF0KGUgLyBiKSwgayA9IGcubm9ybWFsc1tlXTtcclxuICAgICAgICAgICAgZSA9IGcuYmlub3JtYWxzW2VdO1xyXG4gICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDw9IGQ7IHArKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBwIC8gZCAqIE1hdGguUEkgKiAyLCByID0gTWF0aC5zaW4odCksIHQgPSAtTWF0aC5jb3ModCk7XHJcbiAgICAgICAgICAgICAgICBtLnggPSB0ICogay54ICsgciAqIGUueDtcclxuICAgICAgICAgICAgICAgIG0ueSA9IHQgKiBrLnkgKyByICogZS55O1xyXG4gICAgICAgICAgICAgICAgbS56ID0gdCAqIGsueiArIHIgKiBlLno7XHJcbiAgICAgICAgICAgICAgICBtLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgbC5wdXNoKG0ueCxcclxuICAgICAgICAgICAgICAgICAgICBtLnksIG0ueik7XHJcbiAgICAgICAgICAgICAgICBoLnggPSBmLnggKyBjICogbS54O1xyXG4gICAgICAgICAgICAgICAgaC55ID0gZi55ICsgYyAqIG0ueTtcclxuICAgICAgICAgICAgICAgIGgueiA9IGYueiArIGMgKiBtLno7XHJcbiAgICAgICAgICAgICAgICBuLnB1c2goaC54LCBoLnksIGgueilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiVHViZUJ1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3BhdGg6IGEsIHR1YnVsYXJTZWdtZW50czogYiwgcmFkaXVzOiBjLCByYWRpYWxTZWdtZW50czogZCwgY2xvc2VkOiBlfTtcclxuICAgICAgICBiID0gYiB8fCA2NDtcclxuICAgICAgICBjID0gYyB8fCAxO1xyXG4gICAgICAgIGQgPSBkIHx8IDg7XHJcbiAgICAgICAgZSA9IGUgfHwgITE7XHJcbiAgICAgICAgdmFyIGcgPSBhLmNvbXB1dGVGcmVuZXRGcmFtZXMoYiwgZSk7XHJcbiAgICAgICAgdGhpcy50YW5nZW50cyA9IGcudGFuZ2VudHM7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxzID0gZy5ub3JtYWxzO1xyXG4gICAgICAgIHRoaXMuYmlub3JtYWxzID0gZy5iaW5vcm1hbHM7XHJcbiAgICAgICAgdmFyIGggPSBuZXcgcSwgbSA9IG5ldyBxLCBrID0gbmV3IEQsIHQsIHAsIG4gPSBbXSwgbCA9IFtdLCBHID0gW10sIHIgPSBbXTtcclxuICAgICAgICBmb3IgKHQgPSAwOyB0IDwgYjsgdCsrKWYodCk7XHJcbiAgICAgICAgZighMSA9PT0gZSA/IGIgOiAwKTtcclxuICAgICAgICBmb3IgKHQgPSAwOyB0IDw9IGI7IHQrKylmb3IgKHAgPSAwOyBwIDw9IGQ7IHArKylrLnggPSB0IC8gYiwgay55ID0gcCAvIGQsIEcucHVzaChrLngsIGsueSk7XHJcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yIChwID1cclxuICAgICAgICAgICAgICAgICAgICAgMTsgcCA8PSBiOyBwKyspZm9yICh0ID0gMTsgdCA8PSBkOyB0KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gKGQgKyAxKSAqIHAgKyAodCAtIDEpLCBjID0gKGQgKyAxKSAqIHAgKyB0LCBlID0gKGQgKyAxKSAqIChwIC0gMSkgKyB0O1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKChkICsgMSkgKiAocCAtIDEpICsgKHQgLSAxKSwgYSwgZSk7XHJcbiAgICAgICAgICAgICAgICByLnB1c2goYSwgYywgZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleChyKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KG4sIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgeihsLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgeihHLCAyKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBPYyhhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XHJcbiAgICAgICAgVC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiVG9ydXNLbm90R2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7cmFkaXVzOiBhLCB0dWJlOiBiLCB0dWJ1bGFyU2VnbWVudHM6IGMsIHJhZGlhbFNlZ21lbnRzOiBkLCBwOiBlLCBxOiBmfTtcclxuICAgICAgICB2b2lkIDAgIT09IGcgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk6IGhlaWdodFNjYWxlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuc2NhbGUoIHgsIHksIHogKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeShuZXcgVWIoYSwgYiwgYywgZCwgZSwgZikpO1xyXG4gICAgICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVWIoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGcoYSwgYiwgYywgZCwgZSkge1xyXG4gICAgICAgICAgICB2YXIgZiA9IE1hdGguc2luKGEpO1xyXG4gICAgICAgICAgICBiID0gYyAvIGIgKiBhO1xyXG4gICAgICAgICAgICBjID0gTWF0aC5jb3MoYik7XHJcbiAgICAgICAgICAgIGUueCA9IGQgKiAoMiArIGMpICogLjUgKiBNYXRoLmNvcyhhKTtcclxuICAgICAgICAgICAgZS55ID0gZCAqICgyICsgYykgKiBmICogLjU7XHJcbiAgICAgICAgICAgIGUueiA9IGQgKiBNYXRoLnNpbihiKSAqIC41XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBJLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJUb3J1c0tub3RCdWZmZXJHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtyYWRpdXM6IGEsIHR1YmU6IGIsIHR1YnVsYXJTZWdtZW50czogYywgcmFkaWFsU2VnbWVudHM6IGQsIHA6IGUsIHE6IGZ9O1xyXG4gICAgICAgIGEgPSBhIHx8IDEwMDtcclxuICAgICAgICBiID0gYiB8fCA0MDtcclxuICAgICAgICBjID0gTWF0aC5mbG9vcihjKSB8fCA2NDtcclxuICAgICAgICBkID0gTWF0aC5mbG9vcihkKSB8fCA4O1xyXG4gICAgICAgIGUgPSBlIHx8IDI7XHJcbiAgICAgICAgZiA9IGYgfHwgMztcclxuICAgICAgICB2YXIgaCA9IFtdLCBtID0gW10sIGsgPSBbXSwgdCA9IFtdLCBwLCBuLCBsID0gbmV3IHEsIEcgPSBuZXcgcTtcclxuICAgICAgICBuZXcgRDtcclxuICAgICAgICB2YXIgciA9IG5ldyBxLCBBID0gbmV3IHEsIHcgPSBuZXcgcSwgeSA9IG5ldyBxLCBLID1cclxuICAgICAgICAgICAgbmV3IHE7XHJcbiAgICAgICAgZm9yIChwID0gMDsgcCA8PSBjOyArK3ApZm9yIChuID0gcCAvIGMgKiBlICogTWF0aC5QSSAqIDIsIGcobiwgZSwgZiwgYSwgciksIGcobiArIC4wMSwgZSwgZiwgYSwgQSksIHkuc3ViVmVjdG9ycyhBLCByKSwgSy5hZGRWZWN0b3JzKEEsIHIpLCB3LmNyb3NzVmVjdG9ycyh5LCBLKSwgSy5jcm9zc1ZlY3RvcnModywgeSksIHcubm9ybWFsaXplKCksIEsubm9ybWFsaXplKCksIG4gPSAwOyBuIDw9IGQ7ICsrbikge1xyXG4gICAgICAgICAgICB2YXIgdiA9IG4gLyBkICogTWF0aC5QSSAqIDIsIEUgPSAtYiAqIE1hdGguY29zKHYpLCB2ID0gYiAqIE1hdGguc2luKHYpO1xyXG4gICAgICAgICAgICBsLnggPSByLnggKyAoRSAqIEsueCArIHYgKiB3LngpO1xyXG4gICAgICAgICAgICBsLnkgPSByLnkgKyAoRSAqIEsueSArIHYgKiB3LnkpO1xyXG4gICAgICAgICAgICBsLnogPSByLnogKyAoRSAqIEsueiArIHYgKiB3LnopO1xyXG4gICAgICAgICAgICBtLnB1c2gobC54LCBsLnksIGwueik7XHJcbiAgICAgICAgICAgIEcuc3ViVmVjdG9ycyhsLCByKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgay5wdXNoKEcueCwgRy55LCBHLnopO1xyXG4gICAgICAgICAgICB0LnB1c2gocCAvIGMpO1xyXG4gICAgICAgICAgICB0LnB1c2gobiAvIGQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobiA9IDE7IG4gPD0gYzsgbisrKWZvciAocCA9IDE7IHAgPD0gZDsgcCsrKWEgPSAoZCArIDEpICogbiArIChwIC0gMSksIGIgPSAoZCArIDEpICogbiArIHAsIGUgPSAoZCArIDEpICogKG4gLSAxKSArIHAsIGgucHVzaCgoZCArIDEpICogKG4gLSAxKSArXHJcbiAgICAgICAgICAgIChwIC0gMSksIGEsIGUpLCBoLnB1c2goYSwgYiwgZSk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleChoKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KG0sIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgeihrLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgeih0LCAyKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBQYyhhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgVC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiVG9ydXNHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtyYWRpdXM6IGEsIHR1YmU6IGIsIHJhZGlhbFNlZ21lbnRzOiBjLCB0dWJ1bGFyU2VnbWVudHM6IGQsIGFyYzogZX07XHJcbiAgICAgICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkobmV3IFZiKGEsIGIsIGMsIGQsIGUpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFZiKGEsIGIsIGMsIGQsIGUpIHtcclxuICAgICAgICBJLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJUb3J1c0J1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3JhZGl1czogYSwgdHViZTogYiwgcmFkaWFsU2VnbWVudHM6IGMsIHR1YnVsYXJTZWdtZW50czogZCwgYXJjOiBlfTtcclxuICAgICAgICBhID0gYSB8fCAxMDA7XHJcbiAgICAgICAgYiA9IGIgfHwgNDA7XHJcbiAgICAgICAgYyA9IE1hdGguZmxvb3IoYykgfHxcclxuICAgICAgICAgICAgODtcclxuICAgICAgICBkID0gTWF0aC5mbG9vcihkKSB8fCA2O1xyXG4gICAgICAgIGUgPSBlIHx8IDIgKiBNYXRoLlBJO1xyXG4gICAgICAgIHZhciBmID0gW10sIGcgPSBbXSwgaCA9IFtdLCBtID0gW10sIGsgPSBuZXcgcSwgdCA9IG5ldyBxLCBwID0gbmV3IHEsIG4sIGw7XHJcbiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBjOyBuKyspZm9yIChsID0gMDsgbCA8PSBkOyBsKyspIHtcclxuICAgICAgICAgICAgdmFyIEcgPSBsIC8gZCAqIGUsIHIgPSBuIC8gYyAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICB0LnggPSAoYSArIGIgKiBNYXRoLmNvcyhyKSkgKiBNYXRoLmNvcyhHKTtcclxuICAgICAgICAgICAgdC55ID0gKGEgKyBiICogTWF0aC5jb3MocikpICogTWF0aC5zaW4oRyk7XHJcbiAgICAgICAgICAgIHQueiA9IGIgKiBNYXRoLnNpbihyKTtcclxuICAgICAgICAgICAgZy5wdXNoKHQueCwgdC55LCB0LnopO1xyXG4gICAgICAgICAgICBrLnggPSBhICogTWF0aC5jb3MoRyk7XHJcbiAgICAgICAgICAgIGsueSA9IGEgKiBNYXRoLnNpbihHKTtcclxuICAgICAgICAgICAgcC5zdWJWZWN0b3JzKHQsIGspLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBoLnB1c2gocC54LCBwLnksIHAueik7XHJcbiAgICAgICAgICAgIG0ucHVzaChsIC8gZCk7XHJcbiAgICAgICAgICAgIG0ucHVzaChuIC8gYylcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChuID0gMTsgbiA8PSBjOyBuKyspZm9yIChsID0gMTsgbCA8PSBkOyBsKyspYSA9IChkICsgMSkgKiAobiAtIDEpICsgbCAtIDEsIGIgPSAoZCArIDEpICogKG4gLSAxKSArIGwsIGUgPSAoZCArIDEpICogbiArIGwsIGYucHVzaCgoZCArIDEpICogbiArIGwgLSAxLCBhLCBlKSwgZi5wdXNoKGEsIGIsIGUpO1xyXG4gICAgICAgIHRoaXMuc2V0SW5kZXgoZik7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgeihnLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbmV3IHooaCwgMykpO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwidXZcIiwgbmV3IHoobSwgMikpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTGEoYSwgYikge1xyXG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhICYmIChULmNhbGwodGhpcyksIHRoaXMudHlwZSA9IFwiRXh0cnVkZUdlb21ldHJ5XCIsIGEgPSBBcnJheS5pc0FycmF5KGEpID8gYSA6IFthXSwgdGhpcy5hZGRTaGFwZUxpc3QoYSwgYiksIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCkpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUWMoYSwgYikge1xyXG4gICAgICAgIGIgPSBiIHx8IHt9O1xyXG4gICAgICAgIHZhciBjID0gYi5mb250O1xyXG4gICAgICAgIGlmICghMSA9PT0gKGMgJiYgYy5pc0ZvbnQpKXJldHVybiBjb25zb2xlLmVycm9yKFwiVEhSRUUuVGV4dEdlb21ldHJ5OiBmb250IHBhcmFtZXRlciBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRm9udC5cIiksIG5ldyBUO1xyXG4gICAgICAgIGMgPSBjLmdlbmVyYXRlU2hhcGVzKGEsIGIuc2l6ZSwgYi5jdXJ2ZVNlZ21lbnRzKTtcclxuICAgICAgICBiLmFtb3VudCA9IHZvaWQgMCAhPT0gYi5oZWlnaHQgP1xyXG4gICAgICAgICAgICBiLmhlaWdodCA6IDUwO1xyXG4gICAgICAgIHZvaWQgMCA9PT0gYi5iZXZlbFRoaWNrbmVzcyAmJiAoYi5iZXZlbFRoaWNrbmVzcyA9IDEwKTtcclxuICAgICAgICB2b2lkIDAgPT09IGIuYmV2ZWxTaXplICYmIChiLmJldmVsU2l6ZSA9IDgpO1xyXG4gICAgICAgIHZvaWQgMCA9PT0gYi5iZXZlbEVuYWJsZWQgJiYgKGIuYmV2ZWxFbmFibGVkID0gITEpO1xyXG4gICAgICAgIExhLmNhbGwodGhpcywgYywgYik7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJUZXh0R2VvbWV0cnlcIlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFJjKGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJTcGhlcmVHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgcmFkaXVzOiBhLFxyXG4gICAgICAgICAgICB3aWR0aFNlZ21lbnRzOiBiLFxyXG4gICAgICAgICAgICBoZWlnaHRTZWdtZW50czogYyxcclxuICAgICAgICAgICAgcGhpU3RhcnQ6IGQsXHJcbiAgICAgICAgICAgIHBoaUxlbmd0aDogZSxcclxuICAgICAgICAgICAgdGhldGFTdGFydDogZixcclxuICAgICAgICAgICAgdGhldGFMZW5ndGg6IGdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBwYihhLCBiLCBjLCBkLCBlLCBmLCBnKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYihhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiU3BoZXJlQnVmZmVyR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgICAgIHJhZGl1czogYSxcclxuICAgICAgICAgICAgd2lkdGhTZWdtZW50czogYiwgaGVpZ2h0U2VnbWVudHM6IGMsIHBoaVN0YXJ0OiBkLCBwaGlMZW5ndGg6IGUsIHRoZXRhU3RhcnQ6IGYsIHRoZXRhTGVuZ3RoOiBnXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhID0gYSB8fCA1MDtcclxuICAgICAgICBiID0gTWF0aC5tYXgoMywgTWF0aC5mbG9vcihiKSB8fCA4KTtcclxuICAgICAgICBjID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcihjKSB8fCA2KTtcclxuICAgICAgICBkID0gdm9pZCAwICE9PSBkID8gZCA6IDA7XHJcbiAgICAgICAgZSA9IHZvaWQgMCAhPT0gZSA/IGUgOiAyICogTWF0aC5QSTtcclxuICAgICAgICBmID0gdm9pZCAwICE9PSBmID8gZiA6IDA7XHJcbiAgICAgICAgZyA9IHZvaWQgMCAhPT0gZyA/IGcgOiBNYXRoLlBJO1xyXG4gICAgICAgIHZhciBoID0gZiArIGcsIG0sIGssIHQgPSAwLCBwID0gW10sIG4gPSBuZXcgcSwgbCA9IG5ldyBxLCBHID0gW10sIHIgPSBbXSwgQSA9IFtdLCB3ID0gW107XHJcbiAgICAgICAgZm9yIChrID0gMDsgayA8PSBjOyBrKyspIHtcclxuICAgICAgICAgICAgdmFyIHkgPSBbXSwgSyA9IGsgLyBjO1xyXG4gICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDw9IGI7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBtIC8gYjtcclxuICAgICAgICAgICAgICAgIG4ueCA9IC1hICogTWF0aC5jb3MoZCArIHYgKiBlKSAqIE1hdGguc2luKGYgKyBLICogZyk7XHJcbiAgICAgICAgICAgICAgICBuLnkgPSBhICogTWF0aC5jb3MoZiArIEsgKiBnKTtcclxuICAgICAgICAgICAgICAgIG4ueiA9IGEgKiBNYXRoLnNpbihkICsgdiAqIGUpICogTWF0aC5zaW4oZiArIEsgKiBnKTtcclxuICAgICAgICAgICAgICAgIHIucHVzaChuLngsIG4ueSwgbi56KTtcclxuICAgICAgICAgICAgICAgIGwuc2V0KG4ueCwgbi55LCBuLnopLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgQS5wdXNoKGwueCwgbC55LCBsLnopO1xyXG4gICAgICAgICAgICAgICAgdy5wdXNoKHYsIDEgLSBLKTtcclxuICAgICAgICAgICAgICAgIHkucHVzaCh0KyspXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcC5wdXNoKHkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBjOyBrKyspZm9yIChtID0gMDsgbSA8IGI7IG0rKylhID0gcFtrXVttICsgMV0sIGQgPSBwW2tdW21dLCBlID0gcFtrICsgMV1bbV0sIGcgPSBwW2sgKyAxXVttICsgMV0sICgwICE9PSBrIHx8IDAgPCBmKSAmJiBHLnB1c2goYSwgZCwgZyksIChrICE9PSBjIC0gMSB8fCBoIDwgTWF0aC5QSSkgJiYgRy5wdXNoKGQsIGUsIGcpO1xyXG4gICAgICAgIHRoaXMuc2V0SW5kZXgoRyk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgeihyLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbmV3IHooQSwgMykpO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwidXZcIiwgbmV3IHoodywgMikpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gU2MoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgIFQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlJpbmdHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgaW5uZXJSYWRpdXM6IGEsXHJcbiAgICAgICAgICAgIG91dGVyUmFkaXVzOiBiLFxyXG4gICAgICAgICAgICB0aGV0YVNlZ21lbnRzOiBjLFxyXG4gICAgICAgICAgICBwaGlTZWdtZW50czogZCxcclxuICAgICAgICAgICAgdGhldGFTdGFydDogZSxcclxuICAgICAgICAgICAgdGhldGFMZW5ndGg6IGZcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBXYihhLFxyXG4gICAgICAgICAgICBiLCBjLCBkLCBlLCBmKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBXYihhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiUmluZ0J1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgICAgICBpbm5lclJhZGl1czogYSxcclxuICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IGIsXHJcbiAgICAgICAgICAgIHRoZXRhU2VnbWVudHM6IGMsXHJcbiAgICAgICAgICAgIHBoaVNlZ21lbnRzOiBkLFxyXG4gICAgICAgICAgICB0aGV0YVN0YXJ0OiBlLFxyXG4gICAgICAgICAgICB0aGV0YUxlbmd0aDogZlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYSA9IGEgfHwgMjA7XHJcbiAgICAgICAgYiA9IGIgfHwgNTA7XHJcbiAgICAgICAgZSA9IHZvaWQgMCAhPT0gZSA/IGUgOiAwO1xyXG4gICAgICAgIGYgPSB2b2lkIDAgIT09IGYgPyBmIDogMiAqIE1hdGguUEk7XHJcbiAgICAgICAgYyA9IHZvaWQgMCAhPT0gYyA/IE1hdGgubWF4KDMsIGMpIDogODtcclxuICAgICAgICBkID0gdm9pZCAwICE9PSBkID8gTWF0aC5tYXgoMSwgZCkgOiAxO1xyXG4gICAgICAgIHZhciBnID0gW10sIGggPSBbXSwgbSA9IFtdLCBrID0gW10sIHQgPSBhLCBwID0gKGIgLSBhKSAvIGQsIG4gPSBuZXcgcSwgbCA9IG5ldyBELCBHLCByO1xyXG4gICAgICAgIGZvciAoRyA9IDA7IEcgPD0gZDsgRysrKSB7XHJcbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPD0gYzsgcisrKWEgPSBlICsgciAvIGMgKiBmLCBuLnggPSB0ICogTWF0aC5jb3MoYSksIG4ueSA9IHQgKiBNYXRoLnNpbihhKSwgaC5wdXNoKG4ueCwgbi55LCBuLnopLCBtLnB1c2goMCwgMCwgMSksIGwueCA9IChuLnggLyBiICsgMSkgLyAyLCBsLnkgPSAobi55IC8gYiArIDEpIC9cclxuICAgICAgICAgICAgICAgIDIsIGsucHVzaChsLngsIGwueSk7XHJcbiAgICAgICAgICAgIHQgKz0gcFxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKEcgPSAwOyBHIDwgZDsgRysrKWZvciAoYiA9IEcgKiAoYyArIDEpLCByID0gMDsgciA8IGM7IHIrKylhID0gciArIGIsIGUgPSBhICsgYyArIDEsIGYgPSBhICsgYyArIDIsIHQgPSBhICsgMSwgZy5wdXNoKGEsIGUsIHQpLCBnLnB1c2goZSwgZiwgdCk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleChnKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KGgsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgeihtLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgeihrLCAyKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBUYyhhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgVC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiTGF0aGVHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtwb2ludHM6IGEsIHNlZ21lbnRzOiBiLCBwaGlTdGFydDogYywgcGhpTGVuZ3RoOiBkfTtcclxuICAgICAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeShuZXcgWGIoYSwgYiwgYywgZCkpO1xyXG4gICAgICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWGIoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIEkuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIkxhdGhlQnVmZmVyR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7cG9pbnRzOiBhLCBzZWdtZW50czogYiwgcGhpU3RhcnQ6IGMsIHBoaUxlbmd0aDogZH07XHJcbiAgICAgICAgYiA9IE1hdGguZmxvb3IoYikgfHwgMTI7XHJcbiAgICAgICAgYyA9IGMgfHwgMDtcclxuICAgICAgICBkID0gZCB8fCAyICogTWF0aC5QSTtcclxuICAgICAgICBkID0gTi5jbGFtcChkLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgdmFyIGUgPSBbXSwgZiA9IFtdLCBnID0gW10sIGggPSAxIC8gYiwgbSA9IG5ldyBxLCBrID0gbmV3IEQsIHQsIHA7XHJcbiAgICAgICAgZm9yICh0ID0gMDsgdCA8PSBiOyB0KyspIHtcclxuICAgICAgICAgICAgcCA9IGMgKyB0ICogaCAqIGQ7XHJcbiAgICAgICAgICAgIHZhciBuID0gTWF0aC5zaW4ocCksIGwgPSBNYXRoLmNvcyhwKTtcclxuICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8PSBhLmxlbmd0aCAtIDE7IHArKyltLnggPSBhW3BdLnggKiBuLCBtLnkgPSBhW3BdLnksIG0ueiA9IGFbcF0ueCAqIGwsIGYucHVzaChtLngsIG0ueSwgbS56KSwgay54ID0gdCAvIGIsIGsueSA9IHAgLyAoYS5sZW5ndGggLSAxKSwgZy5wdXNoKGsueCwgay55KVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHQgPSAwOyB0IDwgYjsgdCsrKWZvciAocCA9IDA7IHAgPCBhLmxlbmd0aCAtIDE7IHArKyljID0gcCArIHQgKiBhLmxlbmd0aCwgaCA9IGMgKyBhLmxlbmd0aCwgbSA9IGMgKyBhLmxlbmd0aCArIDEsIGsgPSBjICsgMSwgZS5wdXNoKGMsIGgsIGspLCBlLnB1c2goaCwgbSwgayk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleChlKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsXHJcbiAgICAgICAgICAgIG5ldyB6KGYsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInV2XCIsIG5ldyB6KGcsIDIpKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcbiAgICAgICAgaWYgKGQgPT09IDIgKiBNYXRoLlBJKWZvciAoZCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXksIGUgPSBuZXcgcSwgZiA9IG5ldyBxLCBnID0gbmV3IHEsIGMgPSBiICogYS5sZW5ndGggKiAzLCBwID0gdCA9IDA7IHQgPCBhLmxlbmd0aDsgdCsrLCBwICs9IDMpZS54ID0gZFtwICsgMF0sIGUueSA9IGRbcCArIDFdLCBlLnogPSBkW3AgKyAyXSwgZi54ID0gZFtjICsgcCArIDBdLCBmLnkgPSBkW2MgKyBwICsgMV0sIGYueiA9IGRbYyArIHAgKyAyXSwgZy5hZGRWZWN0b3JzKGUsIGYpLm5vcm1hbGl6ZSgpLCBkW3AgKyAwXSA9IGRbYyArIHAgKyAwXSA9IGcueCwgZFtwICsgMV0gPSBkW2MgKyBwICsgMV0gPSBnLnksIGRbcCArIDJdID0gZFtjICsgcCArIDJdID0gZy56XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWWIoYSwgYikge1xyXG4gICAgICAgIFQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlNoYXBlR2VvbWV0cnlcIjtcclxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgYiAmJiAoY29uc29sZS53YXJuKFwiVEhSRUUuU2hhcGVHZW9tZXRyeTogT3B0aW9ucyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cIiksXHJcbiAgICAgICAgICAgIGIgPSBiLmN1cnZlU2VnbWVudHMpO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtzaGFwZXM6IGEsIGN1cnZlU2VnbWVudHM6IGJ9O1xyXG4gICAgICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBaYihhLCBiKSk7XHJcbiAgICAgICAgdGhpcy5tZXJnZVZlcnRpY2VzKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBaYihhLCBiKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYyhhKSB7XHJcbiAgICAgICAgICAgIHZhciBjLCBoLCBrID0gZS5sZW5ndGggLyAzO1xyXG4gICAgICAgICAgICBhID0gYS5leHRyYWN0UG9pbnRzKGIpO1xyXG4gICAgICAgICAgICB2YXIgbCA9IGEuc2hhcGUsIHIgPSBhLmhvbGVzO1xyXG4gICAgICAgICAgICBpZiAoITEgPT09IElhLmlzQ2xvY2tXaXNlKGwpKWZvciAobCA9IGwucmV2ZXJzZSgpLCBhID0gMCwgYyA9IHIubGVuZ3RoOyBhIDwgYzsgYSsrKWggPSByW2FdLCAhMCA9PT0gSWEuaXNDbG9ja1dpc2UoaCkgJiYgKHJbYV0gPSBoLnJldmVyc2UoKSk7XHJcbiAgICAgICAgICAgIHZhciBxID0gSWEudHJpYW5ndWxhdGVTaGFwZShsLCByKTtcclxuICAgICAgICAgICAgYSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoYyA9IHIubGVuZ3RoOyBhIDwgYzsgYSsrKWggPSByW2FdLCBsID0gbC5jb25jYXQoaCk7XHJcbiAgICAgICAgICAgIGEgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSBsLmxlbmd0aDsgYSA8IGM7IGErKyloID0gbFthXSwgZS5wdXNoKGgueCwgaC55LCAwKSwgZi5wdXNoKDAsIDAsIDEpLCBnLnB1c2goaC54LCBoLnkpO1xyXG4gICAgICAgICAgICBhID0gMDtcclxuICAgICAgICAgICAgZm9yIChjID1cclxuICAgICAgICAgICAgICAgICAgICAgcS5sZW5ndGg7IGEgPCBjOyBhKyspbCA9IHFbYV0sIGQucHVzaChsWzBdICsgaywgbFsxXSArIGssIGxbMl0gKyBrKSwgbSArPSAzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBJLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJTaGFwZUJ1ZmZlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3NoYXBlczogYSwgY3VydmVTZWdtZW50czogYn07XHJcbiAgICAgICAgYiA9IGIgfHwgMTI7XHJcbiAgICAgICAgdmFyIGQgPSBbXSwgZSA9IFtdLCBmID0gW10sIGcgPSBbXSwgaCA9IDAsIG0gPSAwO1xyXG4gICAgICAgIGlmICghMSA9PT0gQXJyYXkuaXNBcnJheShhKSkgYyhhKTsgZWxzZSBmb3IgKHZhciBrID0gMDsgayA8IGEubGVuZ3RoOyBrKyspYyhhW2tdKSwgdGhpcy5hZGRHcm91cChoLCBtLCBrKSwgaCArPSBtLCBtID0gMDtcclxuICAgICAgICB0aGlzLnNldEluZGV4KGQpO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IHooZSwgMykpO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwibm9ybWFsXCIsIG5ldyB6KGYsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInV2XCIsIG5ldyB6KGcsIDIpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uICRiKGEsIGIpIHtcclxuICAgICAgICBmdW5jdGlvbiBjKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgLSBiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBJLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJFZGdlc0dlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge3RocmVzaG9sZEFuZ2xlOiBifTtcclxuICAgICAgICB2YXIgZCA9IFtdLCBlID0gTWF0aC5jb3MoTi5ERUcyUkFEICogKHZvaWQgMCAhPT0gYiA/IGIgOiAxKSksIGYgPSBbMCwgMF0sIGcgPSB7fSwgaCwgbSA9IFtcImFcIiwgXCJiXCIsIFwiY1wiXSwgaztcclxuICAgICAgICBhLmlzQnVmZmVyR2VvbWV0cnkgPyAoayA9IG5ldyBULCBrLmZyb21CdWZmZXJHZW9tZXRyeShhKSkgOiBrID0gYS5jbG9uZSgpO1xyXG4gICAgICAgIGsubWVyZ2VWZXJ0aWNlcygpO1xyXG4gICAgICAgIGsuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcbiAgICAgICAgdmFyIHQgPSBrLnZlcnRpY2VzO1xyXG4gICAgICAgIGsgPSBrLmZhY2VzO1xyXG4gICAgICAgIGZvciAodmFyIHAgPSAwLCBuID0gay5sZW5ndGg7IHAgPCBuOyBwKyspZm9yICh2YXIgbCA9IGtbcF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gMDsgMyA+IHE7IHErKylmWzBdID0gbFttW3FdXSwgZlsxXSA9IGxbbVsocSArIDEpICUgM11dLCBmLnNvcnQoYyksIGggPSBmLnRvU3RyaW5nKCksIHZvaWQgMCA9PT0gZ1toXSA/IGdbaF0gPSB7XHJcbiAgICAgICAgICAgIGluZGV4MTogZlswXSxcclxuICAgICAgICAgICAgaW5kZXgyOiBmWzFdLFxyXG4gICAgICAgICAgICBmYWNlMTogcCxcclxuICAgICAgICAgICAgZmFjZTI6IHZvaWQgMFxyXG4gICAgICAgIH0gOiBnW2hdLmZhY2UyID0gcDtcclxuICAgICAgICBmb3IgKGggaW4gZylpZiAoZiA9IGdbaF0sIHZvaWQgMCA9PT0gZi5mYWNlMiB8fCBrW2YuZmFjZTFdLm5vcm1hbC5kb3Qoa1tmLmZhY2UyXS5ub3JtYWwpIDw9XHJcbiAgICAgICAgICAgIGUpIG0gPSB0W2YuaW5kZXgxXSwgZC5wdXNoKG0ueCwgbS55LCBtLnopLCBtID0gdFtmLmluZGV4Ml0sIGQucHVzaChtLngsIG0ueSwgbS56KTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KGQsIDMpKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHFiKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcclxuICAgICAgICBULmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJDeWxpbmRlckdlb21ldHJ5XCI7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgICAgICByYWRpdXNUb3A6IGEsXHJcbiAgICAgICAgICAgIHJhZGl1c0JvdHRvbTogYixcclxuICAgICAgICAgICAgaGVpZ2h0OiBjLFxyXG4gICAgICAgICAgICByYWRpYWxTZWdtZW50czogZCxcclxuICAgICAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGUsXHJcbiAgICAgICAgICAgIG9wZW5FbmRlZDogZixcclxuICAgICAgICAgICAgdGhldGFTdGFydDogZyxcclxuICAgICAgICAgICAgdGhldGFMZW5ndGg6IGhcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBWYShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSk7XHJcbiAgICAgICAgdGhpcy5tZXJnZVZlcnRpY2VzKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBWYShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gbShjKSB7XHJcbiAgICAgICAgICAgIHZhciBlLCBmLCBtLCByID0gbmV3IEQsIEMgPSBuZXcgcSwgRiA9IDAsIHggPSAhMCA9PT0gYyA/IGEgOiBiLCBIID0gITAgPT09IGMgPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGYgPSBHO1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAxOyBlIDw9IGQ7IGUrKylwLnB1c2goMCxcclxuICAgICAgICAgICAgICAgIEEgKiBILCAwKSwgbi5wdXNoKDAsIEgsIDApLCBsLnB1c2goLjUsIC41KSwgRysrO1xyXG4gICAgICAgICAgICBtID0gRztcclxuICAgICAgICAgICAgZm9yIChlID0gMDsgZSA8PSBkOyBlKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhYSA9IGUgLyBkICogaCArIGcsIHogPSBNYXRoLmNvcyhhYSksIGFhID0gTWF0aC5zaW4oYWEpO1xyXG4gICAgICAgICAgICAgICAgQy54ID0geCAqIGFhO1xyXG4gICAgICAgICAgICAgICAgQy55ID0gQSAqIEg7XHJcbiAgICAgICAgICAgICAgICBDLnogPSB4ICogejtcclxuICAgICAgICAgICAgICAgIHAucHVzaChDLngsIEMueSwgQy56KTtcclxuICAgICAgICAgICAgICAgIG4ucHVzaCgwLCBILCAwKTtcclxuICAgICAgICAgICAgICAgIHIueCA9IC41ICogeiArIC41O1xyXG4gICAgICAgICAgICAgICAgci55ID0gLjUgKiBhYSAqIEggKyAuNTtcclxuICAgICAgICAgICAgICAgIGwucHVzaChyLngsIHIueSk7XHJcbiAgICAgICAgICAgICAgICBHKytcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBlIDwgZDsgZSsrKXIgPSBmICsgZSwgQyA9IG0gKyBlLCAhMCA9PT0gYyA/IHQucHVzaChDLCBDICsgMSwgcikgOiB0LnB1c2goQyArIDEsIEMsIHIpLCBGICs9IDM7XHJcbiAgICAgICAgICAgIGsuYWRkR3JvdXAodywgRiwgITAgPT09IGMgPyAxIDogMik7XHJcbiAgICAgICAgICAgIHcgKz0gRlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgcmFkaXVzVG9wOiBhLFxyXG4gICAgICAgICAgICByYWRpdXNCb3R0b206IGIsXHJcbiAgICAgICAgICAgIGhlaWdodDogYyxcclxuICAgICAgICAgICAgcmFkaWFsU2VnbWVudHM6IGQsXHJcbiAgICAgICAgICAgIGhlaWdodFNlZ21lbnRzOiBlLFxyXG4gICAgICAgICAgICBvcGVuRW5kZWQ6IGYsXHJcbiAgICAgICAgICAgIHRoZXRhU3RhcnQ6IGcsXHJcbiAgICAgICAgICAgIHRoZXRhTGVuZ3RoOiBoXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgayA9IHRoaXM7XHJcbiAgICAgICAgYSA9IHZvaWQgMCAhPT0gYSA/IGEgOiAyMDtcclxuICAgICAgICBiID0gdm9pZCAwICE9PSBiID8gYiA6IDIwO1xyXG4gICAgICAgIGMgPSB2b2lkIDAgIT09IGMgPyBjIDogMTAwO1xyXG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQpIHx8IDg7XHJcbiAgICAgICAgZSA9IE1hdGguZmxvb3IoZSkgfHwgMTtcclxuICAgICAgICBmID0gdm9pZCAwICE9PSBmID8gZiA6ICExO1xyXG4gICAgICAgIGcgPSB2b2lkIDAgIT09IGcgPyBnIDogMDtcclxuICAgICAgICBoID0gdm9pZCAwICE9PSBoID8gaCA6IDIgKiBNYXRoLlBJO1xyXG4gICAgICAgIHZhciB0ID0gW10sIHAgPSBbXSwgbiA9IFtdLCBsID0gW10sIEcgPSAwLCByID0gW10sIEEgPSBjIC8gMiwgdyA9IDA7XHJcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGYsIG0sIHYgPSBuZXcgcSwgRSA9IG5ldyBxLCBMID0gMCwgQyA9IChiIC0gYSkgLyBjO1xyXG4gICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDw9IGU7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIEYgPSBbXSwgeCA9IG0gLyBlLCBIID0geCAqIChiIC0gYSkgKyBhO1xyXG4gICAgICAgICAgICAgICAgZm9yIChmID0gMDsgZiA8PSBkOyBmKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRCA9IGYgLyBkLCB6ID0gRCAqIGggKyBnLCBKID0gTWF0aC5zaW4oeiksIHogPSBNYXRoLmNvcyh6KTtcclxuICAgICAgICAgICAgICAgICAgICBFLnggPSBIICogSjtcclxuICAgICAgICAgICAgICAgICAgICBFLnkgPSAteCAqIGMgKyBBO1xyXG4gICAgICAgICAgICAgICAgICAgIEUueiA9IEggKiB6O1xyXG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChFLngsIEUueSwgRS56KTtcclxuICAgICAgICAgICAgICAgICAgICB2LnNldChKLCBDLCB6KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnB1c2godi54LCB2LnksIHYueik7XHJcbiAgICAgICAgICAgICAgICAgICAgbC5wdXNoKEQsIDEgLSB4KTtcclxuICAgICAgICAgICAgICAgICAgICBGLnB1c2goRysrKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgci5wdXNoKEYpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChmID0gMDsgZiA8IGQ7IGYrKylmb3IgKG0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7IG0gPCBlOyBtKyspdiA9IHJbbSArIDFdW2ZdLCBFID0gclttICsgMV1bZiArIDFdLCBDID0gclttXVtmICsgMV0sIHQucHVzaChyW21dW2ZdLCB2LCBDKSwgdC5wdXNoKHYsIEUsIEMpLCBMICs9IDY7XHJcbiAgICAgICAgICAgIGsuYWRkR3JvdXAodywgTCwgMCk7XHJcbiAgICAgICAgICAgIHcgKz0gTFxyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgITEgPT09IGYgJiYgKDAgPCBhICYmIG0oITApLCAwIDwgYiAmJiBtKCExKSk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0KTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KHAsIDMpKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgeihuLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgeihsLCAyKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBVYyhhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XHJcbiAgICAgICAgcWIuY2FsbCh0aGlzLCAwLCBhLCBiLCBjLCBkLCBlLCBmLCBnKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIkNvbmVHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgcmFkaXVzOiBhLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGIsXHJcbiAgICAgICAgICAgIHJhZGlhbFNlZ21lbnRzOiBjLFxyXG4gICAgICAgICAgICBoZWlnaHRTZWdtZW50czogZCxcclxuICAgICAgICAgICAgb3BlbkVuZGVkOiBlLFxyXG4gICAgICAgICAgICB0aGV0YVN0YXJ0OiBmLFxyXG4gICAgICAgICAgICB0aGV0YUxlbmd0aDogZ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBWYyhhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XHJcbiAgICAgICAgVmEuY2FsbCh0aGlzLFxyXG4gICAgICAgICAgICAwLCBhLCBiLCBjLCBkLCBlLCBmLCBnKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIkNvbmVCdWZmZXJHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgcmFkaXVzOiBhLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGIsXHJcbiAgICAgICAgICAgIHJhZGlhbFNlZ21lbnRzOiBjLFxyXG4gICAgICAgICAgICBoZWlnaHRTZWdtZW50czogZCxcclxuICAgICAgICAgICAgb3BlbkVuZGVkOiBlLFxyXG4gICAgICAgICAgICB0aGV0YVN0YXJ0OiBmLFxyXG4gICAgICAgICAgICB0aGV0YUxlbmd0aDogZ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBXYyhhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgVC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQ2lyY2xlR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7cmFkaXVzOiBhLCBzZWdtZW50czogYiwgdGhldGFTdGFydDogYywgdGhldGFMZW5ndGg6IGR9O1xyXG4gICAgICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBhYyhhLCBiLCBjLCBkKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhYyhhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgSS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQ2lyY2xlQnVmZmVyR2VvbWV0cnlcIjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7cmFkaXVzOiBhLCBzZWdtZW50czogYiwgdGhldGFTdGFydDogYywgdGhldGFMZW5ndGg6IGR9O1xyXG4gICAgICAgIGEgPSBhIHx8IDUwO1xyXG4gICAgICAgIGIgPSB2b2lkIDAgIT09IGIgPyBNYXRoLm1heCgzLCBiKSA6IDg7XHJcbiAgICAgICAgYyA9IHZvaWQgMCAhPT1cclxuICAgICAgICBjID8gYyA6IDA7XHJcbiAgICAgICAgZCA9IHZvaWQgMCAhPT0gZCA/IGQgOiAyICogTWF0aC5QSTtcclxuICAgICAgICB2YXIgZSA9IFtdLCBmID0gW10sIGcgPSBbXSwgaCA9IFtdLCBtLCBrLCB0ID0gbmV3IHEsIHAgPSBuZXcgRDtcclxuICAgICAgICBmLnB1c2goMCwgMCwgMCk7XHJcbiAgICAgICAgZy5wdXNoKDAsIDAsIDEpO1xyXG4gICAgICAgIGgucHVzaCguNSwgLjUpO1xyXG4gICAgICAgIGsgPSAwO1xyXG4gICAgICAgIGZvciAobSA9IDM7IGsgPD0gYjsgaysrLCBtICs9IDMpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBjICsgayAvIGIgKiBkO1xyXG4gICAgICAgICAgICB0LnggPSBhICogTWF0aC5jb3Mobik7XHJcbiAgICAgICAgICAgIHQueSA9IGEgKiBNYXRoLnNpbihuKTtcclxuICAgICAgICAgICAgZi5wdXNoKHQueCwgdC55LCB0LnopO1xyXG4gICAgICAgICAgICBnLnB1c2goMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHAueCA9IChmW21dIC8gYSArIDEpIC8gMjtcclxuICAgICAgICAgICAgcC55ID0gKGZbbSArIDFdIC8gYSArIDEpIC8gMjtcclxuICAgICAgICAgICAgaC5wdXNoKHAueCwgcC55KVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKG0gPSAxOyBtIDw9IGI7IG0rKyllLnB1c2gobSwgbSArIDEsIDApO1xyXG4gICAgICAgIHRoaXMuc2V0SW5kZXgoZSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgeihmLCAzKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbmV3IHooZywgMykpO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwidXZcIiwgbmV3IHooaCwgMikpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYmMoKSB7XHJcbiAgICAgICAgSGEuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zOiBKYS5tZXJnZShbVi5saWdodHMsXHJcbiAgICAgICAgICAgICAgICB7b3BhY2l0eToge3ZhbHVlOiAxfX1dKSwgdmVydGV4U2hhZGVyOiBaLnNoYWRvd192ZXJ0LCBmcmFnbWVudFNoYWRlcjogWi5zaGFkb3dfZnJhZ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSB0aGlzLmxpZ2h0cyA9ICEwO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgb3BhY2l0eToge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWVcclxuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBhXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNjKGEpIHtcclxuICAgICAgICBIYS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiUmF3U2hhZGVyTWF0ZXJpYWxcIlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFhjKGEpIHtcclxuICAgICAgICB0aGlzLnV1aWQgPSBOLmdlbmVyYXRlVVVJRCgpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiTXVsdGlNYXRlcmlhbFwiO1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWxzID0gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbXTtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSAhMFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFFhKGEpIHtcclxuICAgICAgICBYLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kZWZpbmVzID0ge1NUQU5EQVJEOiBcIlwifTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIk1lc2hTdGFuZGFyZE1hdGVyaWFsXCI7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBKKDE2Nzc3MjE1KTtcclxuICAgICAgICB0aGlzLm1ldGFsbmVzcyA9IHRoaXMucm91Z2huZXNzID0gLjU7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcCA9IHRoaXMubWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmFvTWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmVtaXNzaXZlID0gbmV3IEooMCk7XHJcbiAgICAgICAgdGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5idW1wTWFwID0gdGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5idW1wU2NhbGUgPSAxO1xyXG4gICAgICAgIHRoaXMubm9ybWFsTWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLm5vcm1hbFNjYWxlID0gbmV3IEQoMSwgMSk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xyXG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcbiAgICAgICAgdGhpcy5lbnZNYXAgPSB0aGlzLmFscGhhTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbnZNYXBJbnRlbnNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID1cclxuICAgICAgICAgICAgLjk4O1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lID0gITE7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBcInJvdW5kXCI7XHJcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoVGFyZ2V0cyA9IHRoaXMuc2tpbm5pbmcgPSAhMTtcclxuICAgICAgICB0aGlzLnNldFZhbHVlcyhhKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJiKGEpIHtcclxuICAgICAgICBRYS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGVmaW5lcyA9IHtQSFlTSUNBTDogXCJcIn07XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJNZXNoUGh5c2ljYWxNYXRlcmlhbFwiO1xyXG4gICAgICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gLjU7XHJcbiAgICAgICAgdGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSB0aGlzLmNsZWFyQ29hdCA9IDA7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZXMoYSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBDYShhKSB7XHJcbiAgICAgICAgWC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiTWVzaFBob25nTWF0ZXJpYWxcIjtcclxuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IEooMTY3NzcyMTUpO1xyXG4gICAgICAgIHRoaXMuc3BlY3VsYXIgPSBuZXcgSigxMTE4NDgxKTtcclxuICAgICAgICB0aGlzLnNoaW5pbmVzcyA9IDMwO1xyXG4gICAgICAgIHRoaXMubGlnaHRNYXAgPSB0aGlzLm1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5hb01hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hb01hcEludGVuc2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBKKDApO1xyXG4gICAgICAgIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuYnVtcE1hcCA9IHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYnVtcFNjYWxlID0gMTtcclxuICAgICAgICB0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBEKDEsIDEpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG4gICAgICAgIHRoaXMuZW52TWFwID0gdGhpcy5hbHBoYU1hcCA9IHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29tYmluZSA9IDA7XHJcbiAgICAgICAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gLjk4O1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lID0gITE7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBcInJvdW5kXCI7XHJcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHMgPVxyXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHRoaXMuc2tpbm5pbmcgPSAhMTtcclxuICAgICAgICB0aGlzLnNldFZhbHVlcyhhKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNiKGEpIHtcclxuICAgICAgICBDYS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGVmaW5lcyA9IHtUT09OOiBcIlwifTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIk1lc2hUb29uTWF0ZXJpYWxcIjtcclxuICAgICAgICB0aGlzLmdyYWRpZW50TWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNldFZhbHVlcyhhKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRiKGEpIHtcclxuICAgICAgICBYLmNhbGwodGhpcywgYSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJNZXNoTm9ybWFsTWF0ZXJpYWxcIjtcclxuICAgICAgICB0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYnVtcFNjYWxlID0gMTtcclxuICAgICAgICB0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBEKDEsIDEpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lID0gITE7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaFRhcmdldHMgPSB0aGlzLnNraW5uaW5nID0gdGhpcy5saWdodHMgPSB0aGlzLmZvZyA9XHJcbiAgICAgICAgICAgICExO1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWVzKGEpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdWIoYSkge1xyXG4gICAgICAgIFguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIk1lc2hMYW1iZXJ0TWF0ZXJpYWxcIjtcclxuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IEooMTY3NzcyMTUpO1xyXG4gICAgICAgIHRoaXMubGlnaHRNYXAgPSB0aGlzLm1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5hb01hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hb01hcEludGVuc2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBKKDApO1xyXG4gICAgICAgIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuZW52TWFwID0gdGhpcy5hbHBoYU1hcCA9IHRoaXMuc3BlY3VsYXJNYXAgPSB0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbWJpbmUgPSAwO1xyXG4gICAgICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcclxuICAgICAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IC45ODtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZSA9ICExO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gXCJyb3VuZFwiO1xyXG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaFRhcmdldHMgPVxyXG4gICAgICAgICAgICB0aGlzLnNraW5uaW5nID0gITE7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZXMoYSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2YihhKSB7XHJcbiAgICAgICAgWC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiTGluZURhc2hlZE1hdGVyaWFsXCI7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBKKDE2Nzc3MjE1KTtcclxuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5saW5ld2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuZGFzaFNpemUgPSAzO1xyXG4gICAgICAgIHRoaXMuZ2FwU2l6ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5saWdodHMgPSAhMTtcclxuICAgICAgICB0aGlzLnNldFZhbHVlcyhhKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uICRkKGEsIGIsIGMpIHtcclxuICAgICAgICB2YXIgZCA9IHRoaXMsIGUgPSAhMSwgZiA9IDAsIGcgPSAwO1xyXG4gICAgICAgIHRoaXMub25TdGFydCA9IHZvaWQgMDtcclxuICAgICAgICB0aGlzLm9uTG9hZCA9IGE7XHJcbiAgICAgICAgdGhpcy5vblByb2dyZXNzID0gYjtcclxuICAgICAgICB0aGlzLm9uRXJyb3IgPSBjO1xyXG4gICAgICAgIHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZysrO1xyXG4gICAgICAgICAgICBpZiAoITEgPT09IGUgJiYgdm9pZCAwICE9PSBkLm9uU3RhcnQpIGQub25TdGFydChhLCBmLCBnKTtcclxuICAgICAgICAgICAgZSA9ICEwXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmKys7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGQub25Qcm9ncmVzcykgZC5vblByb2dyZXNzKGEsIGYsIGcpO1xyXG4gICAgICAgICAgICBpZiAoZiA9PT0gZyAmJiAoZSA9ICExLCB2b2lkIDAgIT09XHJcbiAgICAgICAgICAgICAgICBkLm9uTG9hZCkpIGQub25Mb2FkKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaXRlbUVycm9yID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZC5vbkVycm9yKSBkLm9uRXJyb3IoYSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2EoYSkge1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHZvaWQgMCAhPT0gYSA/IGEgOiB0YVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFJlKGEpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSB2b2lkIDAgIT09IGEgPyBhIDogdGE7XHJcbiAgICAgICAgdGhpcy5fcGFyc2VyID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFlKGEpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSB2b2lkIDAgIT09IGEgPyBhIDogdGE7XHJcbiAgICAgICAgdGhpcy5fcGFyc2VyID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFljKGEpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSB2b2lkIDAgIT09IGEgPyBhIDogdGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiZShhKSB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gdm9pZCAwICE9PSBhID8gYSA6IHRhXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGQoYSkge1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHZvaWQgMCAhPT0gYSA/IGEgOiB0YVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hKGEsIGIpIHtcclxuICAgICAgICB4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJMaWdodFwiO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgSihhKTtcclxuICAgICAgICB0aGlzLmludGVuc2l0eSA9IHZvaWQgMCAhPT0gYiA/IGIgOiAxO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9XHJcbiAgICAgICAgICAgIHZvaWQgMFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVkKGEsIGIsIGMpIHtcclxuICAgICAgICBtYS5jYWxsKHRoaXMsIGEsIGMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiSGVtaXNwaGVyZUxpZ2h0XCI7XHJcbiAgICAgICAgdGhpcy5jYXN0U2hhZG93ID0gdm9pZCAwO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weSh4LkRlZmF1bHRVcCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgICAgICB0aGlzLmdyb3VuZENvbG9yID0gbmV3IEooYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3YihhKSB7XHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBhO1xyXG4gICAgICAgIHRoaXMuYmlhcyA9IDA7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAxO1xyXG4gICAgICAgIHRoaXMubWFwU2l6ZSA9IG5ldyBEKDUxMiwgNTEyKTtcclxuICAgICAgICB0aGlzLm1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgU1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHZkKCkge1xyXG4gICAgICAgIHdiLmNhbGwodGhpcywgbmV3IEZhKDUwLCAxLCAuNSwgNTAwKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3ZChhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgbWEuY2FsbCh0aGlzLCBhLCBiKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlNwb3RMaWdodFwiO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weSh4LkRlZmF1bHRVcCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IG5ldyB4O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvd2VyXCIsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVuc2l0eSAqIE1hdGguUElcclxuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZW5zaXR5ID0gYSAvIE1hdGguUElcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdm9pZCAwICE9PSBjID8gYyA6IDA7XHJcbiAgICAgICAgdGhpcy5hbmdsZSA9IHZvaWQgMCAhPT0gZCA/IGQgOiBNYXRoLlBJIC8gMztcclxuICAgICAgICB0aGlzLnBlbnVtYnJhID0gdm9pZCAwICE9PSBlID8gZSA6IDA7XHJcbiAgICAgICAgdGhpcy5kZWNheSA9IHZvaWQgMCAhPT0gZiA/IGYgOiAxO1xyXG4gICAgICAgIHRoaXMuc2hhZG93ID0gbmV3IHZkXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geGQoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIG1hLmNhbGwodGhpcywgYSwgYik7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJQb2ludExpZ2h0XCI7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicG93ZXJcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA0ICogdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZW5zaXR5ID0gYSAvICg0ICogTWF0aC5QSSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSB2b2lkIDAgIT09IGMgPyBjIDogMDtcclxuICAgICAgICB0aGlzLmRlY2F5ID0gdm9pZCAwICE9PSBkID8gZCA6IDE7XHJcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBuZXcgd2IobmV3IEZhKDkwLFxyXG4gICAgICAgICAgICAxLCAuNSwgNTAwKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB5ZCgpIHtcclxuICAgICAgICB3Yi5jYWxsKHRoaXMsIG5ldyBKYigtNSwgNSwgNSwgLTUsIC41LCA1MDApKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHpkKGEsIGIpIHtcclxuICAgICAgICBtYS5jYWxsKHRoaXMsIGEsIGIpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiRGlyZWN0aW9uYWxMaWdodFwiO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weSh4LkRlZmF1bHRVcCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IG5ldyB4O1xyXG4gICAgICAgIHRoaXMuc2hhZG93ID0gbmV3IHlkXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQWQoYSwgYikge1xyXG4gICAgICAgIG1hLmNhbGwodGhpcywgYSwgYik7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJBbWJpZW50TGlnaHRcIjtcclxuICAgICAgICB0aGlzLmNhc3RTaGFkb3cgPSB2b2lkIDBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB4YShhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBhO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLnJlc3VsdEJ1ZmZlciA9IHZvaWQgMCAhPT0gZCA/IGQgOiBuZXcgYi5jb25zdHJ1Y3RvcihjKTtcclxuICAgICAgICB0aGlzLnNhbXBsZVZhbHVlcyA9IGI7XHJcbiAgICAgICAgdGhpcy52YWx1ZVNpemUgPSBjXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQmQoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHhhLmNhbGwodGhpcywgYSwgYiwgYywgZCk7XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0TmV4dCA9XHJcbiAgICAgICAgICAgIHRoaXMuX3dlaWdodE5leHQgPSB0aGlzLl9vZmZzZXRQcmV2ID0gdGhpcy5fd2VpZ2h0UHJldiA9IC0wXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWmMoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHhhLmNhbGwodGhpcywgYSwgYiwgYywgZClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBDZChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgeGEuY2FsbCh0aGlzLCBhLCBiLCBjLCBkKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHhiKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICBpZiAodm9pZCAwID09PSBhKXRocm93IEVycm9yKFwidHJhY2sgbmFtZSBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYiB8fCAwID09PSBiLmxlbmd0aCl0aHJvdyBFcnJvcihcIm5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCBcIiArIGEpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGE7XHJcbiAgICAgICAgdGhpcy50aW1lcyA9IG5hLmNvbnZlcnRBcnJheShiLCB0aGlzLlRpbWVCdWZmZXJUeXBlKTtcclxuICAgICAgICB0aGlzLnZhbHVlcyA9IG5hLmNvbnZlcnRBcnJheShjLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSk7XHJcbiAgICAgICAgdGhpcy5zZXRJbnRlcnBvbGF0aW9uKGQgfHwgdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbik7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMub3B0aW1pemUoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRjKGEsIGIsXHJcbiAgICAgICAgICAgICAgICBjLCBkKSB7XHJcbiAgICAgICAgeGIuY2FsbCh0aGlzLCBhLCBiLCBjLCBkKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIERkKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICB4YS5jYWxsKHRoaXMsIGEsIGIsIGMsIGQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gJGMoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHhiLmNhbGwodGhpcywgYSwgYiwgYywgZClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlYyhhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgeGIuY2FsbCh0aGlzLCBhLCBiLCBjLCBkKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEVkKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICB4Yi5jYWxsKHRoaXMsIGEsIGIsIGMsIGQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRmQoYSwgYiwgYykge1xyXG4gICAgICAgIHhiLmNhbGwodGhpcywgYSwgYiwgYylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHZChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgeGIuY2FsbCh0aGlzLCBhLCBiLCBjLCBkKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHliKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICB4Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcWEoYSwgYiwgYykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGE7XHJcbiAgICAgICAgdGhpcy50cmFja3MgPSBjO1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSB2b2lkIDAgIT09IGIgPyBiIDogLTE7XHJcbiAgICAgICAgdGhpcy51dWlkID0gTi5nZW5lcmF0ZVVVSUQoKTtcclxuICAgICAgICAwID4gdGhpcy5kdXJhdGlvbiAmJiB0aGlzLnJlc2V0RHVyYXRpb24oKTtcclxuICAgICAgICB0aGlzLm9wdGltaXplKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBIZChhKSB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID1cclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhID8gYSA6IHRhO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNlKGEpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSB2b2lkIDAgIT09IGEgPyBhIDogdGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB6YigpIHtcclxuICAgICAgICB0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlKGEpIHtcclxuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGEgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLkpTT05Mb2FkZXI6IHNob3dTdGF0dXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBjb25zdHJ1Y3Rvci5cIiksIGEgPSB2b2lkIDApO1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHZvaWQgMCAhPT0gYSA/IGEgOiB0YTtcclxuICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9ICExXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gU2UoYSkge1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHZvaWQgMCAhPT0gYSA/IGEgOiB0YTtcclxuICAgICAgICB0aGlzLnRleHR1cmVQYXRoID0gXCJcIlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFRlKGEsIGIsIGMsIGQsIGUpIHtcclxuICAgICAgICBiID0gLjUgKiAoZCAtIGIpO1xyXG4gICAgICAgIGUgPSAuNSAqIChlIC0gYyk7XHJcbiAgICAgICAgdmFyIGYgPSBhICogYTtcclxuICAgICAgICByZXR1cm4gKDIgKlxyXG4gICAgICAgICAgICBjIC0gMiAqIGQgKyBiICsgZSkgKiBhICogZiArICgtMyAqIGMgKyAzICogZCAtIDIgKiBiIC0gZSkgKiBmICsgYiAqIGEgKyBjXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQWIoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHZhciBlID0gMSAtIGE7XHJcbiAgICAgICAgcmV0dXJuIGUgKiBlICogYiArIDIgKiAoMSAtIGEpICogYSAqIGMgKyBhICogYSAqIGRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBCYihhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgdmFyIGYgPSAxIC0gYSwgZyA9IDEgLSBhO1xyXG4gICAgICAgIHJldHVybiBmICogZiAqIGYgKiBiICsgMyAqIGcgKiBnICogYSAqIGMgKyAzICogKDEgLSBhKSAqIGEgKiBhICogZCArIGEgKiBhICogYSAqIGVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1YSgpIHtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBUYShhLCBiKSB7XHJcbiAgICAgICAgdGhpcy52MSA9IGE7XHJcbiAgICAgICAgdGhpcy52MiA9IGJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZCgpIHtcclxuICAgICAgICB0aGlzLmN1cnZlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYXV0b0Nsb3NlID0gITFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBXYShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XHJcbiAgICAgICAgdGhpcy5hWCA9IGE7XHJcbiAgICAgICAgdGhpcy5hWSA9IGI7XHJcbiAgICAgICAgdGhpcy54UmFkaXVzID0gYztcclxuICAgICAgICB0aGlzLnlSYWRpdXMgPSBkO1xyXG4gICAgICAgIHRoaXMuYVN0YXJ0QW5nbGUgPSBlO1xyXG4gICAgICAgIHRoaXMuYUVuZEFuZ2xlID0gZjtcclxuICAgICAgICB0aGlzLmFDbG9ja3dpc2UgPSBnO1xyXG4gICAgICAgIHRoaXMuYVJvdGF0aW9uID0gaCB8fCAwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQ2IoYSkge1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gdm9pZCAwID09PSBhID8gW10gOiBhXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmMoYSwgYiwgYyxcclxuICAgICAgICAgICAgICAgIGQpIHtcclxuICAgICAgICB0aGlzLnYwID0gYTtcclxuICAgICAgICB0aGlzLnYxID0gYjtcclxuICAgICAgICB0aGlzLnYyID0gYztcclxuICAgICAgICB0aGlzLnYzID0gZFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdjKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLnYwID0gYTtcclxuICAgICAgICB0aGlzLnYxID0gYjtcclxuICAgICAgICB0aGlzLnYyID0gY1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJkKGEpIHtcclxuICAgICAgICBhZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ID0gbmV3IEQ7XHJcbiAgICAgICAgYSAmJiB0aGlzLmZyb21Qb2ludHMoYSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBEYigpIHtcclxuICAgICAgICBiZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaG9sZXMgPSBbXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVlKCkge1xyXG4gICAgICAgIHRoaXMuc3ViUGF0aHMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZlKGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBhXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVWUoYSkge1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHZvaWQgMCAhPT0gYSA/IGEgOiB0YVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdlKGEpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSB2b2lkIDAgIT09IGEgPyBhIDogdGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoZShhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgbWEuY2FsbCh0aGlzLCBhLCBiKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlJlY3RBcmVhTGlnaHRcIjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnNldCgwLCAxLCAwKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPVxyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGMgPyBjIDogMTA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB2b2lkIDAgIT09IGQgPyBkIDogMTBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBWZSgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlN0ZXJlb0NhbWVyYVwiO1xyXG4gICAgICAgIHRoaXMuYXNwZWN0ID0gMTtcclxuICAgICAgICB0aGlzLmV5ZVNlcCA9IC4wNjQ7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFMID0gbmV3IEZhO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhTC5sYXllcnMuZW5hYmxlKDEpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gITE7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFSID0gbmV3IEZhO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKDIpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhUi5tYXRyaXhBdXRvVXBkYXRlID0gITFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJZChhLCBiLCBjKSB7XHJcbiAgICAgICAgeC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQ3ViZUNhbWVyYVwiO1xyXG4gICAgICAgIHZhciBkID0gbmV3IEZhKDkwLCAxLCBhLCBiKTtcclxuICAgICAgICBkLnVwLnNldCgwLCAtMSwgMCk7XHJcbiAgICAgICAgZC5sb29rQXQobmV3IHEoMSwgMCwgMCkpO1xyXG4gICAgICAgIHRoaXMuYWRkKGQpO1xyXG4gICAgICAgIHZhciBlID0gbmV3IEZhKDkwLCAxLCBhLCBiKTtcclxuICAgICAgICBlLnVwLnNldCgwLCAtMSwgMCk7XHJcbiAgICAgICAgZS5sb29rQXQobmV3IHEoLTEsIDAsIDApKTtcclxuICAgICAgICB0aGlzLmFkZChlKTtcclxuICAgICAgICB2YXIgZiA9IG5ldyBGYSg5MCxcclxuICAgICAgICAgICAgMSwgYSwgYik7XHJcbiAgICAgICAgZi51cC5zZXQoMCwgMCwgMSk7XHJcbiAgICAgICAgZi5sb29rQXQobmV3IHEoMCwgMSwgMCkpO1xyXG4gICAgICAgIHRoaXMuYWRkKGYpO1xyXG4gICAgICAgIHZhciBnID0gbmV3IEZhKDkwLCAxLCBhLCBiKTtcclxuICAgICAgICBnLnVwLnNldCgwLCAwLCAtMSk7XHJcbiAgICAgICAgZy5sb29rQXQobmV3IHEoMCwgLTEsIDApKTtcclxuICAgICAgICB0aGlzLmFkZChnKTtcclxuICAgICAgICB2YXIgaCA9IG5ldyBGYSg5MCwgMSwgYSwgYik7XHJcbiAgICAgICAgaC51cC5zZXQoMCwgLTEsIDApO1xyXG4gICAgICAgIGgubG9va0F0KG5ldyBxKDAsIDAsIDEpKTtcclxuICAgICAgICB0aGlzLmFkZChoKTtcclxuICAgICAgICB2YXIgbSA9IG5ldyBGYSg5MCwgMSwgYSwgYik7XHJcbiAgICAgICAgbS51cC5zZXQoMCwgLTEsIDApO1xyXG4gICAgICAgIG0ubG9va0F0KG5ldyBxKDAsIDAsIC0xKSk7XHJcbiAgICAgICAgdGhpcy5hZGQobSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgR2IoYywgYywge2Zvcm1hdDogMTAyMiwgbWFnRmlsdGVyOiAxMDA2LCBtaW5GaWx0ZXI6IDEwMDZ9KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBudWxsID09PSB0aGlzLnBhcmVudCAmJiB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5yZW5kZXJUYXJnZXQsIG4gPSBjLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xyXG4gICAgICAgICAgICBjLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID1cclxuICAgICAgICAgICAgICAgICExO1xyXG4gICAgICAgICAgICBjLmFjdGl2ZUN1YmVGYWNlID0gMDtcclxuICAgICAgICAgICAgYS5yZW5kZXIoYiwgZCwgYyk7XHJcbiAgICAgICAgICAgIGMuYWN0aXZlQ3ViZUZhY2UgPSAxO1xyXG4gICAgICAgICAgICBhLnJlbmRlcihiLCBlLCBjKTtcclxuICAgICAgICAgICAgYy5hY3RpdmVDdWJlRmFjZSA9IDI7XHJcbiAgICAgICAgICAgIGEucmVuZGVyKGIsIGYsIGMpO1xyXG4gICAgICAgICAgICBjLmFjdGl2ZUN1YmVGYWNlID0gMztcclxuICAgICAgICAgICAgYS5yZW5kZXIoYiwgZywgYyk7XHJcbiAgICAgICAgICAgIGMuYWN0aXZlQ3ViZUZhY2UgPSA0O1xyXG4gICAgICAgICAgICBhLnJlbmRlcihiLCBoLCBjKTtcclxuICAgICAgICAgICAgYy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG47XHJcbiAgICAgICAgICAgIGMuYWN0aXZlQ3ViZUZhY2UgPSA1O1xyXG4gICAgICAgICAgICBhLnJlbmRlcihiLCBtLCBjKTtcclxuICAgICAgICAgICAgYS5zZXRSZW5kZXJUYXJnZXQobnVsbClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaWUoKSB7XHJcbiAgICAgICAgeC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQXVkaW9MaXN0ZW5lclwiO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGplLmdldENvbnRleHQoKTtcclxuICAgICAgICB0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGMoYSkge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIkF1ZGlvXCI7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID1cclxuICAgICAgICAgICAgYS5jb250ZXh0O1xyXG4gICAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5nYWluLmNvbm5lY3QoYS5nZXRJbnB1dCgpKTtcclxuICAgICAgICB0aGlzLmF1dG9wbGF5ID0gITE7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubG9vcCA9ICExO1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSAhMTtcclxuICAgICAgICB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9ICEwO1xyXG4gICAgICAgIHRoaXMuc291cmNlVHlwZSA9IFwiZW1wdHlcIjtcclxuICAgICAgICB0aGlzLmZpbHRlcnMgPSBbXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGtlKGEpIHtcclxuICAgICAgICBoYy5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xyXG4gICAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5nYWluKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxlKGEsIGIpIHtcclxuICAgICAgICB0aGlzLmFuYWx5c2VyID0gYS5jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XHJcbiAgICAgICAgdGhpcy5hbmFseXNlci5mZnRTaXplID0gdm9pZCAwICE9PSBiID8gYiA6IDIwNDg7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XHJcbiAgICAgICAgYS5nZXRPdXRwdXQoKS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSmQoYSwgYiwgYykge1xyXG4gICAgICAgIHRoaXMuYmluZGluZyA9IGE7XHJcbiAgICAgICAgdGhpcy52YWx1ZVNpemUgPSBjO1xyXG4gICAgICAgIGEgPSBGbG9hdDY0QXJyYXk7XHJcbiAgICAgICAgc3dpdGNoIChiKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJxdWF0ZXJuaW9uXCI6XHJcbiAgICAgICAgICAgICAgICBiID0gdGhpcy5fc2xlcnA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxyXG4gICAgICAgICAgICAgICAgYSA9IEFycmF5O1xyXG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuX3NlbGVjdDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuX2xlcnBcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgYSg0ICogYyk7XHJcbiAgICAgICAgdGhpcy5fbWl4QnVmZmVyUmVnaW9uID0gYjtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZUNvdW50ID0gdGhpcy51c2VDb3VudCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrYShhLCBiLCBjKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gYjtcclxuICAgICAgICB0aGlzLnBhcnNlZFBhdGggPSBjIHx8IGthLnBhcnNlVHJhY2tOYW1lKGIpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IGthLmZpbmROb2RlKGEsIHRoaXMucGFyc2VkUGF0aC5ub2RlTmFtZSkgfHwgYTtcclxuICAgICAgICB0aGlzLnJvb3ROb2RlID0gYVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lKGEpIHtcclxuICAgICAgICB0aGlzLnV1aWQgPSBOLmdlbmVyYXRlVVVJRCgpO1xyXG4gICAgICAgIHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDtcclxuICAgICAgICB2YXIgYiA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2luZGljZXNCeVVVSUQgPSBiO1xyXG4gICAgICAgIGZvciAodmFyIGMgPSAwLCBkID0gYXJndW1lbnRzLmxlbmd0aDsgYyAhPT0gZDsgKytjKWJbYXJndW1lbnRzW2NdLnV1aWRdID0gYztcclxuICAgICAgICB0aGlzLl9wYXRocyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BhcnNlZFBhdGhzID0gW107XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGggPSB7fTtcclxuICAgICAgICB2YXIgZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcclxuICAgICAgICAgICAgb2JqZWN0czoge1xyXG4gICAgICAgICAgICAgICAgZ2V0IHRvdGFsKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLl9vYmplY3RzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgfSwgZ2V0IGluVXNlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsIC0gZS5uQ2FjaGVkT2JqZWN0c19cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZ2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuX2JpbmRpbmdzLmxlbmd0aFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5lKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLl9taXhlciA9IGE7XHJcbiAgICAgICAgdGhpcy5fY2xpcCA9IGI7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxSb290ID0gYyB8fCBudWxsO1xyXG4gICAgICAgIGEgPSBiLnRyYWNrcztcclxuICAgICAgICBiID0gYS5sZW5ndGg7XHJcbiAgICAgICAgYyA9IEFycmF5KGIpO1xyXG4gICAgICAgIGZvciAodmFyIGQgPSB7ZW5kaW5nU3RhcnQ6IDI0MDAsIGVuZGluZ0VuZDogMjQwMH0sIGUgPSAwOyBlICE9PSBiOyArK2UpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBhW2VdLmNyZWF0ZUludGVycG9sYW50KG51bGwpO1xyXG4gICAgICAgICAgICBjW2VdID0gZjtcclxuICAgICAgICAgICAgZi5zZXR0aW5ncyA9IGRcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncyA9IGQ7XHJcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhbnRzID0gYztcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzID0gQXJyYXkoYik7XHJcbiAgICAgICAgdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IHRoaXMuX2J5Q2xpcENhY2hlSW5kZXggPSB0aGlzLl9jYWNoZUluZGV4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxvb3AgPSAyMjAxO1xyXG4gICAgICAgIHRoaXMuX2xvb3BDb3VudCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50aW1lID0gMDtcclxuICAgICAgICB0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLndlaWdodCA9IHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlID0gMTtcclxuICAgICAgICB0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSAhMTtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPVxyXG4gICAgICAgICAgICAhMDtcclxuICAgICAgICB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkID0gITE7XHJcbiAgICAgICAgdGhpcy56ZXJvU2xvcGVBdEVuZCA9IHRoaXMuemVyb1Nsb3BlQXRTdGFydCA9ICEwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2QoYSkge1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBhO1xyXG4gICAgICAgIHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XHJcbiAgICAgICAgdGhpcy50aW1lID0gdGhpcy5fYWNjdUluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBLZChhLCBiKSB7XHJcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGEgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLlVuaWZvcm06IFR5cGUgcGFyYW1ldGVyIGlzIG5vIGxvbmdlciBuZWVkZWQuXCIpLCBhID0gYik7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBFYigpIHtcclxuICAgICAgICBJLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeVwiO1xyXG4gICAgICAgIHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB2b2lkIDBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvZShhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdGhpcy51dWlkID0gTi5nZW5lcmF0ZVVVSUQoKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBhO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSBiO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gYztcclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSAhMCA9PT1cclxuICAgICAgICAgICAgZFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGljKGEsIGIpIHtcclxuICAgICAgICB0aGlzLnV1aWQgPSBOLmdlbmVyYXRlVVVJRCgpO1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhO1xyXG4gICAgICAgIHRoaXMuc3RyaWRlID0gYjtcclxuICAgICAgICB0aGlzLmNvdW50ID0gdm9pZCAwICE9PSBhID8gYS5sZW5ndGggLyBiIDogMDtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSAhMTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlID0ge29mZnNldDogMCwgY291bnQ6IC0xfTtcclxuICAgICAgICB0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gamMoYSwgYiwgYykge1xyXG4gICAgICAgIGljLmNhbGwodGhpcywgYSwgYik7XHJcbiAgICAgICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gYyB8fCAxXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga2MoYSwgYiwgYykge1xyXG4gICAgICAgIFUuY2FsbCh0aGlzLCBhLCBiKTtcclxuICAgICAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBjIHx8IDFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwZShhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdGhpcy5yYXkgPSBuZXcgY2IoYSwgYik7XHJcbiAgICAgICAgdGhpcy5uZWFyID0gYyB8fCAwO1xyXG4gICAgICAgIHRoaXMuZmFyID0gZCB8fCBJbmZpbml0eTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHtNZXNoOiB7fSwgTGluZToge30sIExPRDoge30sIFBvaW50czoge3RocmVzaG9sZDogMX0sIFNwcml0ZToge319O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMucGFyYW1zLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQb2ludENsb3VkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlJheWNhc3RlcjogcGFyYW1zLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBwYXJhbXMuUG9pbnRzLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuUG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFdlKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2VcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBxZShhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgaWYgKCExICE9PSBhLnZpc2libGUgJiYgKGEucmF5Y2FzdChiLCBjKSwgITAgPT09IGQpKSB7XHJcbiAgICAgICAgICAgIGEgPSBhLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGEubGVuZ3RoOyBkIDwgZTsgZCsrKXFlKGFbZF0sIGIsIGMsICEwKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZShhKSB7XHJcbiAgICAgICAgdGhpcy5hdXRvU3RhcnQgPSB2b2lkIDAgIT09IGEgPyBhIDogITA7XHJcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSAhMVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHZvaWQgMCAhPT0gYSA/IGEgOiAxO1xyXG4gICAgICAgIHRoaXMucGhpID0gdm9pZCAwICE9PSBiID8gYiA6IDA7XHJcbiAgICAgICAgdGhpcy50aGV0YSA9IHZvaWQgMCAhPT1cclxuICAgICAgICBjID8gYyA6IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZShhLCBiLCBjKSB7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB2b2lkIDAgIT09IGEgPyBhIDogMTtcclxuICAgICAgICB0aGlzLnRoZXRhID0gdm9pZCAwICE9PSBiID8gYiA6IDA7XHJcbiAgICAgICAgdGhpcy55ID0gdm9pZCAwICE9PSBjID8gYyA6IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvYShhLCBiKSB7XHJcbiAgICAgICAgQWEuY2FsbCh0aGlzLCBhLCBiKTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVBbmltYXRpb24oXCJfX2RlZmF1bHRcIiwgMCwgYyAtIDEsIGMgLyAxKTtcclxuICAgICAgICB0aGlzLnNldEFuaW1hdGlvbldlaWdodChcIl9fZGVmYXVsdFwiLCAxKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRkKGEpIHtcclxuICAgICAgICB4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IGE7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlZChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBhO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHZvaWQgMCAhPT0gYiA/IGIgOiAxO1xyXG4gICAgICAgIGEgPSB2b2lkIDAgIT09IGMgPyBjIDogMTY3MTE2ODA7XHJcbiAgICAgICAgZCA9IHZvaWQgMCAhPT0gZCA/IGQgOiAxO1xyXG4gICAgICAgIGIgPSAwO1xyXG4gICAgICAgIChjID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkpICYmIGMuaXNHZW9tZXRyeSA/IGIgPSAzICogYy5mYWNlcy5sZW5ndGggOiBjICYmIGMuaXNCdWZmZXJHZW9tZXRyeSAmJiAoYiA9IGMuYXR0cmlidXRlcy5ub3JtYWwuY291bnQpO1xyXG4gICAgICAgIGMgPSBuZXcgSTtcclxuICAgICAgICBiID0gbmV3IHooNiAqIGIsIDMpO1xyXG4gICAgICAgIGMuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIiwgYik7XHJcbiAgICAgICAgZ2EuY2FsbCh0aGlzLCBjLCBuZXcgaWEoe2NvbG9yOiBhLCBsaW5ld2lkdGg6IGR9KSk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gITE7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxjKGEpIHtcclxuICAgICAgICB4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5saWdodCA9IGE7XHJcbiAgICAgICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gYS5tYXRyaXhXb3JsZDtcclxuICAgICAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSAhMTtcclxuICAgICAgICBhID0gbmV3IEk7XHJcbiAgICAgICAgZm9yICh2YXIgYiA9IFswLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxLCAwLCAxLCAwLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMSwgMCwgMCwgMCwgMCwgLTEsIDFdLFxyXG4gICAgICAgICAgICAgICAgIGMgPSAwLCBkID0gMTsgMzIgPiBjOyBjKyssIGQrKykge1xyXG4gICAgICAgICAgICB2YXIgZSA9IGMgLyAzMiAqIE1hdGguUEkgKiAyLCBmID0gZCAvIDMyICpcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICBiLnB1c2goTWF0aC5jb3MoZSksIE1hdGguc2luKGUpLCAxLCBNYXRoLmNvcyhmKSwgTWF0aC5zaW4oZiksIDEpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGEuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IHooYiwgMykpO1xyXG4gICAgICAgIGIgPSBuZXcgaWEoe2ZvZzogITF9KTtcclxuICAgICAgICB0aGlzLmNvbmUgPSBuZXcgZ2EoYSwgYik7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5jb25lKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWMoYSkge1xyXG4gICAgICAgIHRoaXMuYm9uZXMgPSB0aGlzLmdldEJvbmVMaXN0KGEpO1xyXG4gICAgICAgIGZvciAodmFyIGIgPSBuZXcgSSwgYyA9IFtdLCBkID0gW10sIGUgPSBuZXcgSigwLCAwLCAxKSwgZiA9IG5ldyBKKDAsIDEsIDApLCBnID0gMDsgZyA8IHRoaXMuYm9uZXMubGVuZ3RoOyBnKyspIHtcclxuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmJvbmVzW2ddO1xyXG4gICAgICAgICAgICBoLnBhcmVudCAmJiBoLnBhcmVudC5pc0JvbmUgJiYgKGMucHVzaCgwLCAwLCAwKSwgYy5wdXNoKDAsIDAsIDApLCBkLnB1c2goZS5yLCBlLmcsIGUuYiksIGQucHVzaChmLnIsIGYuZywgZi5iKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgYi5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgeihjLCAzKSk7XHJcbiAgICAgICAgYi5hZGRBdHRyaWJ1dGUoXCJjb2xvclwiLCBuZXcgeihkLCAzKSk7XHJcbiAgICAgICAgYyA9IG5ldyBpYSh7dmVydGV4Q29sb3JzOiAyLCBkZXB0aFRlc3Q6ICExLCBkZXB0aFdyaXRlOiAhMSwgdHJhbnNwYXJlbnQ6ICEwfSk7XHJcbiAgICAgICAgZ2EuY2FsbCh0aGlzLCBiLCBjKTtcclxuICAgICAgICB0aGlzLnJvb3QgPSBhO1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gYS5tYXRyaXhXb3JsZDtcclxuICAgICAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSAhMTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmMoYSwgYikge1xyXG4gICAgICAgIHRoaXMubGlnaHQgPSBhO1xyXG4gICAgICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuICAgICAgICB2YXIgYyA9IG5ldyBwYihiLCA0LCAyKSwgZCA9IG5ldyBLYSh7d2lyZWZyYW1lOiAhMCwgZm9nOiAhMX0pO1xyXG4gICAgICAgIGQuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7XHJcbiAgICAgICAgQWEuY2FsbCh0aGlzLCBjLCBkKTtcclxuICAgICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gITFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvYyhhKSB7XHJcbiAgICAgICAgeC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubGlnaHQgPSBhO1xyXG4gICAgICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuICAgICAgICB2YXIgYiA9XHJcbiAgICAgICAgICAgIG5ldyBLYSh7Y29sb3I6IGEuY29sb3IsIGZvZzogITF9KTtcclxuICAgICAgICBhID0gbmV3IEthKHtjb2xvcjogYS5jb2xvciwgZm9nOiAhMSwgd2lyZWZyYW1lOiAhMH0pO1xyXG4gICAgICAgIHZhciBjID0gbmV3IEk7XHJcbiAgICAgICAgYy5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgVShuZXcgRmxvYXQzMkFycmF5KDE4KSwgMykpO1xyXG4gICAgICAgIHRoaXMuYWRkKG5ldyBBYShjLCBiKSk7XHJcbiAgICAgICAgdGhpcy5hZGQobmV3IEFhKGMsIGEpKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGMoYSwgYikge1xyXG4gICAgICAgIHguY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmxpZ2h0ID0gYTtcclxuICAgICAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBhLm1hdHJpeFdvcmxkO1xyXG4gICAgICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9ICExO1xyXG4gICAgICAgIHZhciBjID0gbmV3IG9iKGIpO1xyXG4gICAgICAgIGMucm90YXRlWSguNSAqIE1hdGguUEkpO1xyXG4gICAgICAgIHZhciBkID0gbmV3IEthKHt2ZXJ0ZXhDb2xvcnM6IDIsIHdpcmVmcmFtZTogITB9KSwgZSA9IGMuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiksXHJcbiAgICAgICAgICAgIGUgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiBlLmNvdW50KTtcclxuICAgICAgICBjLmFkZEF0dHJpYnV0ZShcImNvbG9yXCIsIG5ldyBVKGUsXHJcbiAgICAgICAgICAgIDMpKTtcclxuICAgICAgICB0aGlzLmFkZChuZXcgQWEoYywgZCkpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmZChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgYSA9IGEgfHwgMTA7XHJcbiAgICAgICAgYiA9IGIgfHwgMTA7XHJcbiAgICAgICAgYyA9IG5ldyBKKHZvaWQgMCAhPT0gYyA/IGMgOiA0NDczOTI0KTtcclxuICAgICAgICBkID0gbmV3IEoodm9pZCAwICE9PSBkID8gZCA6IDg5NDc4NDgpO1xyXG4gICAgICAgIHZhciBlID0gYiAvIDIsIGYgPSBhIC8gYiwgZyA9IGEgLyAyO1xyXG4gICAgICAgIGEgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBoID0gW10sIG0gPSAwLCBrID0gMCwgdCA9IC1nOyBtIDw9IGI7IG0rKywgdCArPSBmKSB7XHJcbiAgICAgICAgICAgIGEucHVzaCgtZywgMCwgdCwgZywgMCwgdCk7XHJcbiAgICAgICAgICAgIGEucHVzaCh0LCAwLCAtZywgdCwgMCwgZyk7XHJcbiAgICAgICAgICAgIHZhciBsID0gbSA9PT0gZSA/IGMgOiBkO1xyXG4gICAgICAgICAgICBsLnRvQXJyYXkoaCwgayk7XHJcbiAgICAgICAgICAgIGsgKz0gMztcclxuICAgICAgICAgICAgbC50b0FycmF5KGgsIGspO1xyXG4gICAgICAgICAgICBrICs9IDM7XHJcbiAgICAgICAgICAgIGwudG9BcnJheShoLCBrKTtcclxuICAgICAgICAgICAgayArPSAzO1xyXG4gICAgICAgICAgICBsLnRvQXJyYXkoaCwgayk7XHJcbiAgICAgICAgICAgIGsgKz0gM1xyXG4gICAgICAgIH1cclxuICAgICAgICBiID0gbmV3IEk7XHJcbiAgICAgICAgYi5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgeihhLCAzKSk7XHJcbiAgICAgICAgYi5hZGRBdHRyaWJ1dGUoXCJjb2xvclwiLCBuZXcgeihoLCAzKSk7XHJcbiAgICAgICAgYyA9IG5ldyBpYSh7dmVydGV4Q29sb3JzOiAyfSk7XHJcbiAgICAgICAgZ2EuY2FsbCh0aGlzLCBiLCBjKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIExkKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICBhID0gYSB8fCAxMDtcclxuICAgICAgICBiID0gYiB8fCAxNjtcclxuICAgICAgICBjID0gYyB8fCA4O1xyXG4gICAgICAgIGQgPSBkIHx8IDY0O1xyXG4gICAgICAgIGUgPSBuZXcgSih2b2lkIDAgIT09IGUgPyBlIDogNDQ3MzkyNCk7XHJcbiAgICAgICAgZiA9IG5ldyBKKHZvaWQgMCAhPT0gZiA/IGYgOiA4OTQ3ODQ4KTtcclxuICAgICAgICB2YXIgZyA9IFtdLCBoID0gW10sIG0sIGssIHQsIGwsIG47XHJcbiAgICAgICAgZm9yICh0ID0gMDsgdCA8PSBiOyB0KyspayA9IHQgLyBiICogMiAqIE1hdGguUEksIG0gPSBNYXRoLnNpbihrKSAqIGEsIGsgPSBNYXRoLmNvcyhrKSAqIGEsIGcucHVzaCgwLCAwLCAwKSwgZy5wdXNoKG0sIDAsIGspLCBuID0gdCAmIDEgPyBlIDogZiwgaC5wdXNoKG4uciwgbi5nLCBuLmIpLCBoLnB1c2gobi5yLCBuLmcsIG4uYik7XHJcbiAgICAgICAgZm9yICh0ID0gMDsgdCA8PSBjOyB0KyspZm9yIChuID0gdCAmIDEgPyBlIDogZiwgbCA9IGEgLSBhIC8gYyAqIHQsIGIgPSAwOyBiIDwgZDsgYisrKWsgPSBiIC8gZCAqIDIgKiBNYXRoLlBJLCBtID0gTWF0aC5zaW4oaykgKiBsLCBrID0gTWF0aC5jb3MoaykgKiBsLCBnLnB1c2gobSwgMCwgayksIGgucHVzaChuLnIsIG4uZywgbi5iKSwgayA9IChiICsgMSkgLyBkICogMiAqIE1hdGguUEksIG0gPSBNYXRoLnNpbihrKSAqIGwsIGsgPSBNYXRoLmNvcyhrKSAqIGwsIGcucHVzaChtLCAwLCBrKSwgaC5wdXNoKG4uciwgbi5nLCBuLmIpO1xyXG4gICAgICAgIGEgPSBuZXcgSTtcclxuICAgICAgICBhLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsXHJcbiAgICAgICAgICAgIG5ldyB6KGcsIDMpKTtcclxuICAgICAgICBhLmFkZEF0dHJpYnV0ZShcImNvbG9yXCIsIG5ldyB6KGgsIDMpKTtcclxuICAgICAgICBnID0gbmV3IGlhKHt2ZXJ0ZXhDb2xvcnM6IDJ9KTtcclxuICAgICAgICBnYS5jYWxsKHRoaXMsIGEsIGcpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2QoYSwgYiwgYywgZCkge1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gYTtcclxuICAgICAgICB0aGlzLnNpemUgPSB2b2lkIDAgIT09IGIgPyBiIDogMTtcclxuICAgICAgICBhID0gdm9pZCAwICE9PSBjID8gYyA6IDE2Nzc2OTYwO1xyXG4gICAgICAgIGQgPSB2b2lkIDAgIT09IGQgPyBkIDogMTtcclxuICAgICAgICBiID0gMDtcclxuICAgICAgICAoYyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5KSAmJiBjLmlzR2VvbWV0cnkgPyBiID0gYy5mYWNlcy5sZW5ndGggOiBjb25zb2xlLndhcm4oXCJUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLlwiKTtcclxuICAgICAgICBjID0gbmV3IEk7XHJcbiAgICAgICAgYiA9IG5ldyB6KDYgKiBiLCAzKTtcclxuICAgICAgICBjLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIGIpO1xyXG4gICAgICAgIGdhLmNhbGwodGhpcywgYywgbmV3IGlhKHtjb2xvcjogYSwgbGluZXdpZHRoOiBkfSkpO1xyXG4gICAgICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9ICExO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBxYyhhLCBiKSB7XHJcbiAgICAgICAgeC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubGlnaHQgPSBhO1xyXG4gICAgICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeCA9IGEubWF0cml4V29ybGQ7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gITE7XHJcbiAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMSk7XHJcbiAgICAgICAgdmFyIGMgPSBuZXcgSTtcclxuICAgICAgICBjLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KFstYiwgYiwgMCwgYiwgYiwgMCwgYiwgLWIsIDAsIC1iLCAtYiwgMCwgLWIsIGIsIDBdLCAzKSk7XHJcbiAgICAgICAgdmFyIGQgPSBuZXcgaWEoe2ZvZzogITF9KTtcclxuICAgICAgICB0aGlzLmFkZChuZXcgVWEoYywgZCkpO1xyXG4gICAgICAgIGMgPSBuZXcgSTtcclxuICAgICAgICBjLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KFswLCAwLCAwLCAwLCAwLCAxXSwgMykpO1xyXG4gICAgICAgIHRoaXMuYWRkKG5ldyBVYShjLCBkKSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhkKGEpIHtcclxuICAgICAgICBmdW5jdGlvbiBiKGEsIGIsIGQpIHtcclxuICAgICAgICAgICAgYyhhLCBkKTtcclxuICAgICAgICAgICAgYyhiLCBkKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYyhhLCBiKSB7XHJcbiAgICAgICAgICAgIGYucHVzaCgwLCAwLCAwKTtcclxuICAgICAgICAgICAgZy5wdXNoKGIuciwgYi5nLCBiLmIpO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGhbYV0gJiYgKGhbYV0gPSBbXSk7XHJcbiAgICAgICAgICAgIGhbYV0ucHVzaChmLmxlbmd0aCAvXHJcbiAgICAgICAgICAgICAgICAzIC0gMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkID0gbmV3IEksIGUgPSBuZXcgaWEoe2NvbG9yOiAxNjc3NzIxNSwgdmVydGV4Q29sb3JzOiAxfSksIGYgPSBbXSwgZyA9IFtdLCBoID0ge30sIG0gPSBuZXcgSigxNjc1NTIwMCksXHJcbiAgICAgICAgICAgIGsgPSBuZXcgSigxNjcxMTY4MCksIGwgPSBuZXcgSig0Mzc3NSksIHAgPSBuZXcgSigxNjc3NzIxNSksIG4gPSBuZXcgSigzMzU1NDQzKTtcclxuICAgICAgICBiKFwibjFcIiwgXCJuMlwiLCBtKTtcclxuICAgICAgICBiKFwibjJcIiwgXCJuNFwiLCBtKTtcclxuICAgICAgICBiKFwibjRcIiwgXCJuM1wiLCBtKTtcclxuICAgICAgICBiKFwibjNcIiwgXCJuMVwiLCBtKTtcclxuICAgICAgICBiKFwiZjFcIiwgXCJmMlwiLCBtKTtcclxuICAgICAgICBiKFwiZjJcIiwgXCJmNFwiLCBtKTtcclxuICAgICAgICBiKFwiZjRcIiwgXCJmM1wiLCBtKTtcclxuICAgICAgICBiKFwiZjNcIiwgXCJmMVwiLCBtKTtcclxuICAgICAgICBiKFwibjFcIiwgXCJmMVwiLCBtKTtcclxuICAgICAgICBiKFwibjJcIiwgXCJmMlwiLCBtKTtcclxuICAgICAgICBiKFwibjNcIiwgXCJmM1wiLCBtKTtcclxuICAgICAgICBiKFwibjRcIiwgXCJmNFwiLCBtKTtcclxuICAgICAgICBiKFwicFwiLCBcIm4xXCIsIGspO1xyXG4gICAgICAgIGIoXCJwXCIsIFwibjJcIiwgayk7XHJcbiAgICAgICAgYihcInBcIiwgXCJuM1wiLCBrKTtcclxuICAgICAgICBiKFwicFwiLCBcIm40XCIsIGspO1xyXG4gICAgICAgIGIoXCJ1MVwiLCBcInUyXCIsIGwpO1xyXG4gICAgICAgIGIoXCJ1MlwiLCBcInUzXCIsIGwpO1xyXG4gICAgICAgIGIoXCJ1M1wiLCBcInUxXCIsIGwpO1xyXG4gICAgICAgIGIoXCJjXCIsIFwidFwiLCBwKTtcclxuICAgICAgICBiKFwicFwiLCBcImNcIiwgbik7XHJcbiAgICAgICAgYihcImNuMVwiLCBcImNuMlwiLCBuKTtcclxuICAgICAgICBiKFwiY24zXCIsIFwiY240XCIsIG4pO1xyXG4gICAgICAgIGIoXCJjZjFcIiwgXCJjZjJcIiwgbik7XHJcbiAgICAgICAgYihcImNmM1wiLCBcImNmNFwiLCBuKTtcclxuICAgICAgICBkLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KGYsIDMpKTtcclxuICAgICAgICBkLmFkZEF0dHJpYnV0ZShcImNvbG9yXCIsIG5ldyB6KGcsIDMpKTtcclxuICAgICAgICBnYS5jYWxsKHRoaXMsIGQsIGUpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gYTtcclxuICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ICYmIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeCA9IGEubWF0cml4V29ybGQ7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gITE7XHJcbiAgICAgICAgdGhpcy5wb2ludE1hcCA9IGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJjKGEsIGIpIHtcclxuICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAxNjc3Njk2MCk7XHJcbiAgICAgICAgdmFyIGMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDddKSxcclxuICAgICAgICAgICAgZCA9IG5ldyBGbG9hdDMyQXJyYXkoMjQpLCBlID0gbmV3IEk7XHJcbiAgICAgICAgZS5zZXRJbmRleChuZXcgVShjLCAxKSk7XHJcbiAgICAgICAgZS5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgVShkLCAzKSk7XHJcbiAgICAgICAgZ2EuY2FsbCh0aGlzLFxyXG4gICAgICAgICAgICBlLCBuZXcgaWEoe2NvbG9yOiBifSkpO1xyXG4gICAgICAgIHZvaWQgMCAhPT0gYSAmJiB0aGlzLnVwZGF0ZShhKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEZiKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICB4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdm9pZCAwID09PSBkICYmIChkID0gMTY3NzY5NjApO1xyXG4gICAgICAgIHZvaWQgMCA9PT0gYyAmJiAoYyA9IDEpO1xyXG4gICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IC4yICogYyk7XHJcbiAgICAgICAgdm9pZCAwID09PSBmICYmIChmID0gLjIgKiBlKTtcclxuICAgICAgICB2b2lkIDAgPT09IE1kICYmIChNZCA9IG5ldyBJLCBNZC5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgeihbMCwgMCwgMCwgMCwgMSwgMF0sIDMpKSwgdWUgPSBuZXcgVmEoMCwgLjUsIDEsIDUsIDEpLCB1ZS50cmFuc2xhdGUoMCwgLS41LCAwKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KGIpO1xyXG4gICAgICAgIHRoaXMubGluZSA9IG5ldyBVYShNZCwgbmV3IGlhKHtjb2xvcjogZH0pKTtcclxuICAgICAgICB0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9ICExO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMubGluZSk7XHJcbiAgICAgICAgdGhpcy5jb25lID0gbmV3IEFhKHVlLCBuZXcgS2Eoe2NvbG9yOiBkfSkpO1xyXG4gICAgICAgIHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gITE7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5jb25lKTtcclxuICAgICAgICB0aGlzLnNldERpcmVjdGlvbihhKTtcclxuICAgICAgICB0aGlzLnNldExlbmd0aChjLCBlLCBmKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE5kKGEpIHtcclxuICAgICAgICBhID0gYSB8fCAxO1xyXG4gICAgICAgIHZhciBiID0gWzAsIDAsIDAsIGEsIDAsIDAsIDAsIDAsIDAsIDAsIGEsIDAsIDAsIDAsIDAsIDAsIDAsIGFdO1xyXG4gICAgICAgIGEgPSBuZXcgSTtcclxuICAgICAgICBhLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyB6KGIsIDMpKTtcclxuICAgICAgICBhLmFkZEF0dHJpYnV0ZShcImNvbG9yXCIsIG5ldyB6KFsxLCAwLCAwLCAxLCAuNiwgMCwgMCwgMSwgMCwgLjYsIDEsIDAsIDAsIDAsIDEsIDAsIC42LCAxXSwgMykpO1xyXG4gICAgICAgIGIgPSBuZXcgaWEoe3ZlcnRleENvbG9yczogMn0pO1xyXG4gICAgICAgIGdhLmNhbGwodGhpcywgYSwgYilcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2ZSgpIHtcclxuICAgICAgICB2YXIgYSA9IDAsIGIgPSAwLCBjID0gMCwgZCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW5pdENhdG11bGxSb206IGZ1bmN0aW9uIChlLCBmLCBnLCBoLCBtKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbSAqIChnIC0gZSk7XHJcbiAgICAgICAgICAgICAgICBoID0gbSAqIChoIC0gZik7XHJcbiAgICAgICAgICAgICAgICBhID0gZjtcclxuICAgICAgICAgICAgICAgIGIgPSBlO1xyXG4gICAgICAgICAgICAgICAgYyA9IC0zICogZiArIDMgKiBnIC0gMiAqIGUgLSBoO1xyXG4gICAgICAgICAgICAgICAgZCA9IDIgKiBmIC0gMiAqIGcgKyBlICsgaFxyXG4gICAgICAgICAgICB9LCBpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uIChlLCBmLCBnLCBoLCBtLCBrLCBsKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gKChmIC0gZSkgLyBtIC0gKGcgLSBlKSAvIChtICsgaykgKyAoZyAtIGYpIC8gaykgKiBrO1xyXG4gICAgICAgICAgICAgICAgaCA9ICgoZyAtIGYpIC8gayAtIChoIC0gZikgLyAoayArIGwpICsgKGggLSBnKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgbCkgKiBrO1xyXG4gICAgICAgICAgICAgICAgYSA9IGY7XHJcbiAgICAgICAgICAgICAgICBiID0gZTtcclxuICAgICAgICAgICAgICAgIGMgPSAtMyAqIGYgKyAzICogZyAtIDIgKiBlIC0gaDtcclxuICAgICAgICAgICAgICAgIGQgPSAyICogZiAtIDIgKiBnICsgZSArIGhcclxuICAgICAgICAgICAgfSwgY2FsYzogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gZSAqIGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSArIGIgKiBlICsgYyAqIGYgKyBkICogZiAqIGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2YShhKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBhIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuY2xvc2VkID0gITFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpZChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdGhpcy52MCA9IGE7XHJcbiAgICAgICAgdGhpcy52MSA9IGI7XHJcbiAgICAgICAgdGhpcy52MiA9IGM7XHJcbiAgICAgICAgdGhpcy52MyA9IGRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBqZChhLCBiLCBjKSB7XHJcbiAgICAgICAgdGhpcy52MCA9IGE7XHJcbiAgICAgICAgdGhpcy52MSA9IGI7XHJcbiAgICAgICAgdGhpcy52MiA9IGNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZChhLCBiKSB7XHJcbiAgICAgICAgdGhpcy52MSA9IGE7XHJcbiAgICAgICAgdGhpcy52MiA9IGJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBPZChhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgV2EuY2FsbCh0aGlzLCBhLCBiLCBjLCBjLCBkLCBlLCBmKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFhlKGEpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgdmEuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImNhdG11bGxyb21cIjtcclxuICAgICAgICB0aGlzLmNsb3NlZCA9XHJcbiAgICAgICAgICAgICEwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWWUoYSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlNwbGluZUN1cnZlMyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLlwiKTtcclxuICAgICAgICB2YS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiY2F0bXVsbHJvbVwiXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2UoYSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlNwbGluZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLlwiKTtcclxuICAgICAgICB2YS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiY2F0bXVsbHJvbVwiXHJcbiAgICB9XHJcblxyXG4gICAgdm9pZCAwID09PSBOdW1iZXIuRVBTSUxPTiAmJiAoTnVtYmVyLkVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpKTtcclxuICAgIHZvaWQgMCA9PT0gTWF0aC5zaWduICYmIChNYXRoLnNpZ24gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHJldHVybiAwID4gYSA/IC0xIDogMCA8IGEgPyAxIDogK2FcclxuICAgIH0pO1xyXG4gICAgdm9pZCAwID09PSBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCBcIm5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uXFxzKihbXlxcKFxcc10qKS8pWzFdXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2b2lkIDAgPT09IE9iamVjdC5hc3NpZ24gJiYgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBhIHx8IG51bGwgPT09IGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IE9iamVjdChhKSwgYyA9IDE7IGMgPCBhcmd1bWVudHMubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzW2NdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZCAmJiBudWxsICE9PSBkKWZvciAodmFyIGUgaW4gZClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCwgZSkgJiYgKGJbZV0gPSBkW2VdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgfVxyXG4gICAgfSgpO1xyXG4gICAgcGEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gdGhpcy5fbGlzdGVuZXJzICYmICh0aGlzLl9saXN0ZW5lcnMgPSB7fSk7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGNbYV0gJiYgKGNbYV0gPSBbXSk7XHJcbiAgICAgICAgICAgIC0xID09PSBjW2FdLmluZGV4T2YoYikgJiYgY1thXS5wdXNoKGIpXHJcbiAgICAgICAgfSwgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdGhpcy5fbGlzdGVuZXJzKXJldHVybiAhMTtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGNbYV0gJiYgLTEgIT09IGNbYV0uaW5kZXhPZihiKVxyXG4gICAgICAgIH0sIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9saXN0ZW5lcnNbYV07XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBjLmluZGV4T2YoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgLTEgIT09IGQgJiYgYy5zcGxpY2UoZCwgMSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9saXN0ZW5lcnNbYS50eXBlXTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhLnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBbXSwgZCwgZSA9IGIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZCA9IDA7IGQgPCBlOyBkKyspY1tkXSA9IGJbZF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChkID0gMDsgZCA8IGU7IGQrKyljW2RdLmNhbGwodGhpcywgYSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgTiA9IHtcclxuICAgICAgICBERUcyUkFEOiBNYXRoLlBJIC8gMTgwLCBSQUQyREVHOiAxODAgLyBNYXRoLlBJLCBnZW5lcmF0ZVVVSUQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPVxyXG4gICAgICAgICAgICAgICAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLnNwbGl0KFwiXCIpLCBiID0gQXJyYXkoMzYpLCBjID0gMCwgZDtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyAzNiA+IGU7IGUrKyk4ID09PSBlIHx8IDEzID09PSBlIHx8IDE4ID09PSBlIHx8IDIzID09PSBlID8gYltlXSA9IFwiLVwiIDogMTQgPT09IGUgPyBiW2VdID0gXCI0XCIgOiAoMiA+PSBjICYmIChjID0gMzM1NTQ0MzIgKyAxNjc3NzIxNiAqIE1hdGgucmFuZG9tKCkgfCAwKSwgZCA9IGMgJiAxNSwgYyA+Pj0gNCwgYltlXSA9IGFbMTkgPT09IGUgPyBkICYgMyB8IDggOiBkXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5qb2luKFwiXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGNsYW1wOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYiwgTWF0aC5taW4oYywgYSkpXHJcbiAgICAgICAgfSwgZXVjbGlkZWFuTW9kdWxvOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gKGEgJSBiICsgYikgJSBiXHJcbiAgICAgICAgfSwgbWFwTGluZWFyOiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZCArIChhIC0gYikgKiAoZSAtIGQpIC8gKGMgLSBiKVxyXG4gICAgICAgIH0sIGxlcnA6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoMSAtIGMpICogYSArIGMgKiBiXHJcbiAgICAgICAgfSwgc21vb3Roc3RlcDogZnVuY3Rpb24gKGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIsIGMpIHtcclxuICAgICAgICAgICAgaWYgKGEgPD0gYilyZXR1cm4gMDtcclxuICAgICAgICAgICAgaWYgKGEgPj0gYylyZXR1cm4gMTtcclxuICAgICAgICAgICAgYSA9IChhIC0gYikgLyAoYyAtIGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYSAqIGEgKiAoMyAtIDIgKiBhKVxyXG4gICAgICAgIH0sIHNtb290aGVyc3RlcDogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgaWYgKGEgPD0gYilyZXR1cm4gMDtcclxuICAgICAgICAgICAgaWYgKGEgPj0gYylyZXR1cm4gMTtcclxuICAgICAgICAgICAgYSA9IChhIC0gYikgLyAoYyAtIGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYSAqIGEgKiBhICogKGEgKiAoNiAqIGEgLSAxNSkgKyAxMClcclxuICAgICAgICB9LCByYW5kSW50OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChiIC0gYSArIDEpKVxyXG4gICAgICAgIH0sIHJhbmRGbG9hdDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgKyBNYXRoLnJhbmRvbSgpICogKGIgLSBhKVxyXG4gICAgICAgIH0sIHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgKiAoLjUgLSBNYXRoLnJhbmRvbSgpKVxyXG4gICAgICAgIH0sIGRlZ1RvUmFkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYSAqIE4uREVHMlJBRFxyXG4gICAgICAgIH0sIHJhZFRvRGVnOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYSAqIE4uUkFEMkRFR1xyXG4gICAgICAgIH0sIGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAgPT09IChhICYgYSAtIDEpICYmIDAgIT09IGFcclxuICAgICAgICB9LCBuZWFyZXN0UG93ZXJPZlR3bzogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsXHJcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKE1hdGgubG9nKGEpIC8gTWF0aC5MTjIpKVxyXG4gICAgICAgIH0sIG5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhLS07XHJcbiAgICAgICAgICAgIGEgfD0gYSA+PiAxO1xyXG4gICAgICAgICAgICBhIHw9IGEgPj4gMjtcclxuICAgICAgICAgICAgYSB8PSBhID4+IDQ7XHJcbiAgICAgICAgICAgIGEgfD0gYSA+PiA4O1xyXG4gICAgICAgICAgICBhIHw9IGEgPj4gMTY7XHJcbiAgICAgICAgICAgIGErKztcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IEQsIGlzVmVjdG9yMjogITAsIGdldCB3aWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueFxyXG4gICAgICAgIH0sIHNldCB3aWR0aChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGFcclxuICAgICAgICB9LCBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55XHJcbiAgICAgICAgfSwgc2V0IGhlaWdodChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGFcclxuICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0U2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnggPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0WTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy55ID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnkpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gYS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhLnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBiKXJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLCB0aGlzLmFkZFZlY3RvcnMoYSwgYik7XHJcbiAgICAgICAgICAgIHRoaXMueCArPSBhLng7XHJcbiAgICAgICAgICAgIHRoaXMueSArPSBhLnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkU2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gYTtcclxuICAgICAgICAgICAgdGhpcy55ICs9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkVmVjdG9yczogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gYS54ICogYjtcclxuICAgICAgICAgICAgdGhpcy55ICs9IGEueSAqIGI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc3ViOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBiKXJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLCB0aGlzLnN1YlZlY3RvcnMoYSwgYik7XHJcbiAgICAgICAgICAgIHRoaXMueCAtPSBhLng7XHJcbiAgICAgICAgICAgIHRoaXMueSAtPSBhLnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc3ViU2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnggLT0gYTtcclxuICAgICAgICAgICAgdGhpcy55IC09IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc3ViVmVjdG9yczogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy54ID1cclxuICAgICAgICAgICAgICAgIGEueCAtIGIueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG11bHRpcGx5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnggKj0gYS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgKj0gYS55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpc0Zpbml0ZShhKSA/ICh0aGlzLnggKj0gYSwgdGhpcy55ICo9IGEpIDogdGhpcy55ID0gdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBkaXZpZGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAvPSBhLng7XHJcbiAgICAgICAgICAgIHRoaXMueSAvPSBhLnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gYSlcclxuICAgICAgICB9LCBtaW46IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgYS54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5taW4odGhpcy55LCBhLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG1heDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBhLngpO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIGEueSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xhbXA6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgubWF4KGEueCxcclxuICAgICAgICAgICAgICAgIE1hdGgubWluKGIueCwgdGhpcy54KSk7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IE1hdGgubWF4KGEueSwgTWF0aC5taW4oYi55LCB0aGlzLnkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYjtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgRCwgYiA9IG5ldyBEKTtcclxuICAgICAgICAgICAgICAgIGEuc2V0KGMsIGMpO1xyXG4gICAgICAgICAgICAgICAgYi5zZXQoZCwgZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFtcChhLCBiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBjbGFtcExlbmd0aDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihNYXRoLm1heChhLCBNYXRoLm1pbihiLCBjKSkgLyBjKVxyXG4gICAgICAgIH0sIGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IDAgPiB0aGlzLnggPyBNYXRoLmNlaWwodGhpcy54KSA6IE1hdGguZmxvb3IodGhpcy54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gMCA+IHRoaXMueSA/IE1hdGguY2VpbCh0aGlzLnkpIDogTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGRvdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIGEueCArIHRoaXMueSAqIGEueVxyXG4gICAgICAgIH0sIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnlcclxuICAgICAgICB9LCBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpXHJcbiAgICAgICAgfSwgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KVxyXG4gICAgICAgIH0sIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFuZ2xlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XHJcbiAgICAgICAgICAgIDAgPiBhICYmIChhICs9IDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoYSkpXHJcbiAgICAgICAgfSwgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy54IC0gYS54O1xyXG4gICAgICAgICAgICBhID0gdGhpcy55IC0gYS55O1xyXG4gICAgICAgICAgICByZXR1cm4gYiAqIGIgKyBhICogYVxyXG4gICAgICAgIH0sIGRpc3RhbmNlVG9NYW5oYXR0YW46IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSBhLngpICsgTWF0aC5hYnModGhpcy55IC0gYS55KVxyXG4gICAgICAgIH0sIHNldExlbmd0aDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoYSAvIHRoaXMubGVuZ3RoKCkpXHJcbiAgICAgICAgfSwgbGVycDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy54ICs9IChhLnggLSB0aGlzLngpICogYjtcclxuICAgICAgICAgICAgdGhpcy55ICs9IChhLnkgLSB0aGlzLnkpICogYjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBsZXJwVmVjdG9yczogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyhiLFxyXG4gICAgICAgICAgICAgICAgYSkubXVsdGlwbHlTY2FsYXIoYykuYWRkKGEpXHJcbiAgICAgICAgfSwgZXF1YWxzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS54ID09PSB0aGlzLnggJiYgYS55ID09PSB0aGlzLnlcclxuICAgICAgICB9LCBmcm9tQXJyYXk6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhW2JdO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhW2IgKyAxXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0b0FycmF5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBbXSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xyXG4gICAgICAgICAgICBhW2JdID0gdGhpcy54O1xyXG4gICAgICAgICAgICBhW2IgKyAxXSA9IHRoaXMueTtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCBmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGMgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMjogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLlwiKTtcclxuICAgICAgICAgICAgdGhpcy54ID0gYS5nZXRYKGIpO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhLmdldFkoYik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcm90YXRlQXJvdW5kOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IE1hdGguY29zKGIpLCBkID0gTWF0aC5zaW4oYiksIGUgPSB0aGlzLnggLVxyXG4gICAgICAgICAgICAgICAgYS54LCBmID0gdGhpcy55IC0gYS55O1xyXG4gICAgICAgICAgICB0aGlzLnggPSBlICogYyAtIGYgKiBkICsgYS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBlICogZCArIGYgKiBjICsgYS55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgWmUgPSAwO1xyXG4gICAgZWEuREVGQVVMVF9JTUFHRSA9IHZvaWQgMDtcclxuICAgIGVhLkRFRkFVTFRfTUFQUElORyA9IDMwMDtcclxuICAgIGVhLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZWEsIGlzVGV4dHVyZTogITAsIHNldCBuZWVkc1VwZGF0ZShhKSB7XHJcbiAgICAgICAgICAgICEwID09PSBhICYmIHRoaXMudmVyc2lvbisrXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBhLmltYWdlO1xyXG4gICAgICAgICAgICB0aGlzLm1pcG1hcHMgPSBhLm1pcG1hcHMuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwcGluZyA9IGEubWFwcGluZztcclxuICAgICAgICAgICAgdGhpcy53cmFwUyA9IGEud3JhcFM7XHJcbiAgICAgICAgICAgIHRoaXMud3JhcFQgPSBhLndyYXBUO1xyXG4gICAgICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IGEubWFnRmlsdGVyO1xyXG4gICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IGEubWluRmlsdGVyO1xyXG4gICAgICAgICAgICB0aGlzLmFuaXNvdHJvcHkgPSBhLmFuaXNvdHJvcHk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gYS5mb3JtYXQ7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IGEudHlwZTtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQuY29weShhLm9mZnNldCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0LmNvcHkoYS5yZXBlYXQpO1xyXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGEuZ2VuZXJhdGVNaXBtYXBzO1xyXG4gICAgICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBhLnByZW11bHRpcGx5QWxwaGE7XHJcbiAgICAgICAgICAgIHRoaXMuZmxpcFkgPSBhLmZsaXBZO1xyXG4gICAgICAgICAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IGEudW5wYWNrQWxpZ25tZW50O1xyXG4gICAgICAgICAgICB0aGlzLmVuY29kaW5nID0gYS5lbmNvZGluZztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0b0pTT046IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGEudGV4dHVyZXNbdGhpcy51dWlkXSlyZXR1cm4gYS50ZXh0dXJlc1t0aGlzLnV1aWRdO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7dmVyc2lvbjogNC40LCB0eXBlOiBcIlRleHR1cmVcIiwgZ2VuZXJhdG9yOiBcIlRleHR1cmUudG9KU09OXCJ9LFxyXG4gICAgICAgICAgICAgICAgdXVpZDogdGhpcy51dWlkLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgbWFwcGluZzogdGhpcy5tYXBwaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVwZWF0OiBbdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueV0sXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IFt0aGlzLm9mZnNldC54LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0LnldLFxyXG4gICAgICAgICAgICAgICAgd3JhcDogW3RoaXMud3JhcFMsIHRoaXMud3JhcFRdLFxyXG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcclxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICBhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHksXHJcbiAgICAgICAgICAgICAgICBmbGlwWTogdGhpcy5mbGlwWVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSB0aGlzLmltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGMudXVpZCAmJiAoYy51dWlkID0gTi5nZW5lcmF0ZVVVSUQoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBhLmltYWdlc1tjLnV1aWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBhLmltYWdlcywgZSA9IGMudXVpZCwgZiA9IGMudXVpZCwgZztcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGMudG9EYXRhVVJMID8gZyA9IGMgOiAoZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJjYW52YXNcIiksIGcud2lkdGggPSBjLndpZHRoLCBnLmhlaWdodCA9IGMuaGVpZ2h0LCBnLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UoYywgMCwgMCwgYy53aWR0aCwgYy5oZWlnaHQpKTtcclxuICAgICAgICAgICAgICAgICAgICBnID0gMjA0OCA8IGcud2lkdGggfHwgMjA0OCA8IGcuaGVpZ2h0ID8gZy50b0RhdGFVUkwoXCJpbWFnZS9qcGVnXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC42KSA6IGcudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRbZV0gPSB7dXVpZDogZiwgdXJsOiBnfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYi5pbWFnZSA9IGMudXVpZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhLnRleHR1cmVzW3RoaXMudXVpZF0gPSBiXHJcbiAgICAgICAgfSwgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6IFwiZGlzcG9zZVwifSlcclxuICAgICAgICB9LCB0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKDMwMCA9PT0gdGhpcy5tYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBhLm11bHRpcGx5KHRoaXMucmVwZWF0KTtcclxuICAgICAgICAgICAgICAgIGEuYWRkKHRoaXMub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICgwID4gYS54IHx8IDEgPCBhLngpc3dpdGNoICh0aGlzLndyYXBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxRTM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEueCAtPSBNYXRoLmZsb29yKGEueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS54ID0gMCA+IGEueCA/IDAgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEueCA9IDEgPT09IE1hdGguYWJzKE1hdGguZmxvb3IoYS54KSAlIDIpID8gTWF0aC5jZWlsKGEueCkgLSBhLnggOiBhLnggLSBNYXRoLmZsb29yKGEueClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgwID4gYS55IHx8IDEgPCBhLnkpc3dpdGNoICh0aGlzLndyYXBUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxRTM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEueSAtPSBNYXRoLmZsb29yKGEueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS55ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPiBhLnkgPyAwIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnkgPSAxID09PSBNYXRoLmFicyhNYXRoLmZsb29yKGEueSkgJSAyKSA/IE1hdGguY2VpbChhLnkpIC0gYS55IDogYS55IC0gTWF0aC5mbG9vcihhLnkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsaXBZICYmIChhLnkgPSAxIC0gYS55KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oZWEucHJvdG90eXBlLCBwYS5wcm90b3R5cGUpO1xyXG4gICAgZmEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmYSwgaXNWZWN0b3I0OiAhMCwgc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBiO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBjO1xyXG4gICAgICAgICAgICB0aGlzLncgPSBkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy53ID0gdGhpcy56ID0gdGhpcy55ID0gdGhpcy54ID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRYOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0WjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy56ID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRXOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLncgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGEpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLncgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIgKyBhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldENvbXBvbmVudDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLno7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53KVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGEueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gYS55O1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhLno7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IHZvaWQgMCAhPT0gYS53ID9cclxuICAgICAgICAgICAgICAgIGEudyA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBiKXJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLCB0aGlzLmFkZFZlY3RvcnMoYSwgYik7XHJcbiAgICAgICAgICAgIHRoaXMueCArPSBhLng7XHJcbiAgICAgICAgICAgIHRoaXMueSArPSBhLnk7XHJcbiAgICAgICAgICAgIHRoaXMueiArPSBhLno7XHJcbiAgICAgICAgICAgIHRoaXMudyArPSBhLnc7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkU2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gYTtcclxuICAgICAgICAgICAgdGhpcy55ICs9IGE7XHJcbiAgICAgICAgICAgIHRoaXMueiArPSBhO1xyXG4gICAgICAgICAgICB0aGlzLncgKz0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBhZGRWZWN0b3JzOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhLnggKyBiLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGEueSArIGIueTtcclxuICAgICAgICAgICAgdGhpcy56ID0gYS56ICsgYi56O1xyXG4gICAgICAgICAgICB0aGlzLncgPSBhLncgKyBiLnc7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gYS54ICogYjtcclxuICAgICAgICAgICAgdGhpcy55ICs9IGEueSAqIGI7XHJcbiAgICAgICAgICAgIHRoaXMueiArPSBhLnogKiBiO1xyXG4gICAgICAgICAgICB0aGlzLncgKz0gYS53ICogYjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzdWI6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGIpcmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjQ6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksIHRoaXMuc3ViVmVjdG9ycyhhLCBiKTtcclxuICAgICAgICAgICAgdGhpcy54IC09IGEueDtcclxuICAgICAgICAgICAgdGhpcy55IC09IGEueTtcclxuICAgICAgICAgICAgdGhpcy56IC09IGEuejtcclxuICAgICAgICAgICAgdGhpcy53IC09IGEudztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzdWJTY2FsYXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAtPSBhO1xyXG4gICAgICAgICAgICB0aGlzLnkgLT0gYTtcclxuICAgICAgICAgICAgdGhpcy56IC09IGE7XHJcbiAgICAgICAgICAgIHRoaXMudyAtPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHN1YlZlY3RvcnM6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhLnogLSBiLno7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IGEudyAtIGIudztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaXNGaW5pdGUoYSkgPyAodGhpcy54ICo9IGEsIHRoaXMueSAqPSBhLCB0aGlzLnogKj0gYSwgdGhpcy53ICo9IGEpIDogdGhpcy53ID0gdGhpcy56ID1cclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMueCwgYyA9IHRoaXMueSwgZCA9IHRoaXMueiwgZSA9IHRoaXMudztcclxuICAgICAgICAgICAgYSA9IGEuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGFbMF0gKiBiICsgYVs0XSAqIGMgKyBhWzhdICogZCArIGFbMTJdICogZTtcclxuICAgICAgICAgICAgdGhpcy55ID0gYVsxXSAqIGIgKyBhWzVdICogYyArIGFbOV0gKiBkICsgYVsxM10gKiBlO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhWzJdICogYiArIGFbNl0gKiBjICsgYVsxMF0gKiBkICsgYVsxNF0gKiBlO1xyXG4gICAgICAgICAgICB0aGlzLncgPSBhWzNdICogYiArIGFbN10gKiBjICsgYVsxMV0gKiBkICsgYVsxNV0gKiBlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIGEpXHJcbiAgICAgICAgfSwgc2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoYS53KTtcclxuICAgICAgICAgICAgdmFyIGIgPSBNYXRoLnNxcnQoMSAtIGEudyAqIGEudyk7XHJcbiAgICAgICAgICAgIDFFLTQgPiBiID8gKHRoaXMueCA9IDEsIHRoaXMueiA9IHRoaXMueSA9IDApIDogKHRoaXMueCA9IGEueCAvIGIsIHRoaXMueSA9IGEueSAvIGIsIHRoaXMueiA9IGEueiAvIGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiwgYywgZDtcclxuICAgICAgICAgICAgYSA9IGEuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHZhciBlID0gYVswXTtcclxuICAgICAgICAgICAgZCA9IGFbNF07XHJcbiAgICAgICAgICAgIHZhciBmID0gYVs4XSwgZyA9IGFbMV0sIGggPSBhWzVdLCBtID0gYVs5XTtcclxuICAgICAgICAgICAgYyA9IGFbMl07XHJcbiAgICAgICAgICAgIGIgPSBhWzZdO1xyXG4gICAgICAgICAgICB2YXIgayA9IGFbMTBdO1xyXG4gICAgICAgICAgICBpZiAoLjAxID4gTWF0aC5hYnMoZCAtIGcpICYmIC4wMSA+IE1hdGguYWJzKGYgLSBjKSAmJiAuMDEgPiBNYXRoLmFicyhtIC0gYikpIHtcclxuICAgICAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKGQgKyBnKSAmJiAuMSA+IE1hdGguYWJzKGYgKyBjKSAmJiAuMSA+IE1hdGguYWJzKG0gKyBiKSAmJiAuMSA+IE1hdGguYWJzKGUgKyBoICsgayAtIDMpKXJldHVybiB0aGlzLnNldCgxLCAwLCAwLCAwKSwgdGhpcztcclxuICAgICAgICAgICAgICAgIGEgPSBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgZSA9IChlICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgaCA9IChoICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgayA9IChrICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgZCA9IChkICsgZykgLyA0O1xyXG4gICAgICAgICAgICAgICAgZiA9IChmICsgYykgLyA0O1xyXG4gICAgICAgICAgICAgICAgbSA9IChtICsgYikgLyA0O1xyXG4gICAgICAgICAgICAgICAgZSA+IGggJiYgZSA+IGsgPyAuMDEgPiBlID8gKGIgPSAwLCBkID0gYyA9IC43MDcxMDY3ODEpIDogKGIgPSBNYXRoLnNxcnQoZSksIGMgPSBkIC8gYiwgZCA9IGYgLyBiKSA6IGggPiBrID8gLjAxID4gaCA/IChiID0gLjcwNzEwNjc4MSwgYyA9IDAsIGQgPSAuNzA3MTA2NzgxKSA6IChjID0gTWF0aC5zcXJ0KGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBkIC8gYywgZCA9IG0gLyBjKSA6IC4wMSA+IGsgPyAoYyA9IGIgPSAuNzA3MTA2NzgxLCBkID0gMCkgOiAoZCA9IE1hdGguc3FydChrKSwgYiA9IGYgLyBkLCBjID0gbSAvIGQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoYiwgYywgZCwgYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGEgPSBNYXRoLnNxcnQoKGIgLSBtKSAqIChiIC0gbSkgKyAoZiAtIGMpICogKGYgLSBjKSArIChnIC0gZCkgKiAoZyAtIGQpKTtcclxuICAgICAgICAgICAgLjAwMSA+IE1hdGguYWJzKGEpICYmIChhID0gMSk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IChiIC0gbSkgLyBhO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSAoZiAtIGMpIC8gYTtcclxuICAgICAgICAgICAgdGhpcy56ID0gKGcgLSBkKSAvIGE7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IE1hdGguYWNvcygoZSArIGggKyBrIC0gMSkgLyAyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtaW46IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgYS54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5taW4odGhpcy55LCBhLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIGEueik7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IE1hdGgubWluKHRoaXMudywgYS53KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtYXg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgYS54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBhLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIGEueik7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IE1hdGgubWF4KHRoaXMudywgYS53KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjbGFtcDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgoYS54LCBNYXRoLm1pbihiLngsIHRoaXMueCkpO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLm1heChhLnksIE1hdGgubWluKGIueSwgdGhpcy55KSk7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IE1hdGgubWF4KGEueiwgTWF0aC5taW4oYi56LCB0aGlzLnopKTtcclxuICAgICAgICAgICAgdGhpcy53ID0gTWF0aC5tYXgoYS53LCBNYXRoLm1pbihiLncsIHRoaXMudykpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBiO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMsIGQpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBmYSwgYiA9IG5ldyBmYSk7XHJcbiAgICAgICAgICAgICAgICBhLnNldChjLCBjLCBjLCBjKTtcclxuICAgICAgICAgICAgICAgIGIuc2V0KGQsIGQsIGQsIGQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoYSwgYilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IE1hdGguZmxvb3IodGhpcy56KTtcclxuICAgICAgICAgICAgdGhpcy53ID0gTWF0aC5mbG9vcih0aGlzLncpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBNYXRoLmNlaWwodGhpcy56KTtcclxuICAgICAgICAgICAgdGhpcy53ID0gTWF0aC5jZWlsKHRoaXMudyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IE1hdGgucm91bmQodGhpcy56KTtcclxuICAgICAgICAgICAgdGhpcy53ID0gTWF0aC5yb3VuZCh0aGlzLncpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IDAgPiB0aGlzLnggPyBNYXRoLmNlaWwodGhpcy54KSA6IE1hdGguZmxvb3IodGhpcy54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gMCA+IHRoaXMueSA/IE1hdGguY2VpbCh0aGlzLnkpIDogTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSAwID4gdGhpcy56ID8gTWF0aC5jZWlsKHRoaXMueikgOiBNYXRoLmZsb29yKHRoaXMueik7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IDAgPiB0aGlzLncgPyBNYXRoLmNlaWwodGhpcy53KSA6IE1hdGguZmxvb3IodGhpcy53KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gLXRoaXMueTtcclxuICAgICAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcclxuICAgICAgICAgICAgdGhpcy53ID0gLXRoaXMudztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBkb3Q6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiBhLnggKyB0aGlzLnkgKiBhLnkgKyB0aGlzLnogKiBhLnogKyB0aGlzLncgKiBhLndcclxuICAgICAgICB9LCBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53XHJcbiAgICAgICAgfSwgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KVxyXG4gICAgICAgIH0sIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopICsgTWF0aC5hYnModGhpcy53KVxyXG4gICAgICAgIH0sIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldExlbmd0aDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoYSAvIHRoaXMubGVuZ3RoKCkpXHJcbiAgICAgICAgfSwgbGVycDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy54ICs9IChhLnggLSB0aGlzLngpICogYjtcclxuICAgICAgICAgICAgdGhpcy55ICs9IChhLnkgLSB0aGlzLnkpICogYjtcclxuICAgICAgICAgICAgdGhpcy56ICs9IChhLnogLSB0aGlzLnopICogYjtcclxuICAgICAgICAgICAgdGhpcy53ICs9IChhLncgLSB0aGlzLncpICogYjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBsZXJwVmVjdG9yczogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyhiLCBhKS5tdWx0aXBseVNjYWxhcihjKS5hZGQoYSlcclxuICAgICAgICB9LCBlcXVhbHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnggPT09IHRoaXMueCAmJiBhLnkgPT09IHRoaXMueSAmJiBhLnogPT09IHRoaXMueiAmJiBhLncgPT09IHRoaXMud1xyXG4gICAgICAgIH0sIGZyb21BcnJheTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMCk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGFbYl07XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGFbYiArIDFdO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhW2IgKyAyXTtcclxuICAgICAgICAgICAgdGhpcy53ID0gYVtiICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgdG9BcnJheTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID1cclxuICAgICAgICAgICAgICAgIFtdKTtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMCk7XHJcbiAgICAgICAgICAgIGFbYl0gPSB0aGlzLng7XHJcbiAgICAgICAgICAgIGFbYiArIDFdID0gdGhpcy55O1xyXG4gICAgICAgICAgICBhW2IgKyAyXSA9IHRoaXMuejtcclxuICAgICAgICAgICAgYVtiICsgM10gPSB0aGlzLnc7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSwgZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBjICYmIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjQ6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS5cIik7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGEuZ2V0WChiKTtcclxuICAgICAgICAgICAgdGhpcy55ID0gYS5nZXRZKGIpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhLmdldFooYik7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IGEuZ2V0VyhiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgWWEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBZYSwgaXNXZWJHTFJlbmRlclRhcmdldDogITAsIHNldFNpemU6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBhIHx8IHRoaXMuaGVpZ2h0ICE9PSBiKSB0aGlzLndpZHRoID0gYSwgdGhpcy5oZWlnaHQgPSBiLCB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5zZXQoMCwgMCwgYSwgYik7XHJcbiAgICAgICAgICAgIHRoaXMuc2Npc3Nvci5zZXQoMCwgMCwgYSxcclxuICAgICAgICAgICAgICAgIGIpXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBhLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmNvcHkoYS52aWV3cG9ydCk7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IGEudGV4dHVyZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmRlcHRoQnVmZmVyID0gYS5kZXB0aEJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gYS5zdGVuY2lsQnVmZmVyO1xyXG4gICAgICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IGEuZGVwdGhUZXh0dXJlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiBcImRpc3Bvc2VcIn0pXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oWWEucHJvdG90eXBlLCBwYS5wcm90b3R5cGUpO1xyXG4gICAgR2IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShZYS5wcm90b3R5cGUpO1xyXG4gICAgR2IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2I7XHJcbiAgICBHYi5wcm90b3R5cGUuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPSAhMDtcclxuICAgIGNhLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogY2EsIGdldCB4KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feFxyXG4gICAgICAgIH0sIHNldCB4KGEpIHtcclxuICAgICAgICAgICAgdGhpcy5feCA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpXHJcbiAgICAgICAgfSwgZ2V0IHkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95XHJcbiAgICAgICAgfSwgc2V0IHkoYSkge1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYTtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKClcclxuICAgICAgICB9LCBnZXQgeigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pcclxuICAgICAgICB9LCBzZXQgeihhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBhO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKVxyXG4gICAgICAgIH0sIGdldCB3KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd1xyXG4gICAgICAgIH0sIHNldCB3KGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpXHJcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gYTtcclxuICAgICAgICAgICAgdGhpcy5feSA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gZDtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5feCA9XHJcbiAgICAgICAgICAgICAgICBhLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBhLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBhLno7XHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSBhLnc7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21FdWxlcjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKCExID09PSAoYSAmJiBhLmlzRXVsZXIpKXRocm93IEVycm9yKFwiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuXCIpO1xyXG4gICAgICAgICAgICB2YXIgYyA9IE1hdGguY29zKGEuX3ggLyAyKSwgZCA9IE1hdGguY29zKGEuX3kgLyAyKSwgZSA9IE1hdGguY29zKGEuX3ogLyAyKSwgZiA9IE1hdGguc2luKGEuX3ggLyAyKSxcclxuICAgICAgICAgICAgICAgIGcgPSBNYXRoLnNpbihhLl95IC8gMiksIGggPSBNYXRoLnNpbihhLl96IC8gMiksIG0gPSBhLm9yZGVyO1xyXG4gICAgICAgICAgICBcIlhZWlwiID09PSBtID8gKHRoaXMuX3ggPSBmICogZCAqIGUgKyBjICogZyAqIGgsIHRoaXMuX3kgPSBjICogZyAqIGUgLSBmICogZCAqIGgsIHRoaXMuX3ogPSBjICogZCAqIGggKyBmICogZyAqIGUsIHRoaXMuX3cgPSBjICogZCAqIGUgLSBmICogZyAqIGgpIDogXCJZWFpcIiA9PT0gbSA/ICh0aGlzLl94ID0gZiAqIGQgKiBlICsgYyAqIGcgKiBoLCB0aGlzLl95ID0gYyAqIGcgKlxyXG4gICAgICAgICAgICAgICAgZSAtIGYgKiBkICogaCwgdGhpcy5feiA9IGMgKiBkICogaCAtIGYgKiBnICogZSwgdGhpcy5fdyA9IGMgKiBkICogZSArIGYgKiBnICogaCkgOiBcIlpYWVwiID09PSBtID8gKHRoaXMuX3ggPSBmICogZCAqIGUgLSBjICogZyAqIGgsIHRoaXMuX3kgPSBjICogZyAqIGUgKyBmICogZCAqIGgsIHRoaXMuX3ogPSBjICogZCAqIGggKyBmICogZyAqIGUsIHRoaXMuX3cgPSBjICogZCAqIGUgLSBmICogZyAqIGgpIDogXCJaWVhcIiA9PT0gbSA/ICh0aGlzLl94ID0gZiAqIGQgKiBlIC0gYyAqIGcgKiBoLCB0aGlzLl95ID0gYyAqIGcgKiBlICsgZiAqIGQgKiBoLCB0aGlzLl96ID0gYyAqIGQgKiBoIC0gZiAqIGcgKiBlLCB0aGlzLl93ID0gYyAqIGQgKiBlICsgZiAqIGcgKiBoKSA6IFwiWVpYXCIgPT09IG0gPyAodGhpcy5feCA9IGYgKiBkICogZSArIGMgKiBnICogaCwgdGhpcy5feSA9IGMgKiBnICogZSArIGYgKiBkICogaCwgdGhpcy5feiA9IGMgKiBkICogaCAtIGYgKiBnICogZSwgdGhpcy5fdyA9IGMgKiBkICogZSAtIGYgKiBnICogaCkgOiBcIlhaWVwiID09PSBtICYmICh0aGlzLl94ID0gZiAqIGQgKiBlIC0gYyAqIGcgKiBoLCB0aGlzLl95ID0gYyAqIGcgKiBlIC0gZiAqIGQgKiBoLCB0aGlzLl96ID0gYyAqIGQgKiBoICsgZiAqIGcgKiBlLCB0aGlzLl93ID0gYyAqIGQgKiBlICsgZiAqIGcgKiBoKTtcclxuICAgICAgICAgICAgaWYgKCExICE9PSBiKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9XHJcbiAgICAgICAgICAgICAgICBiIC8gMiwgZCA9IE1hdGguc2luKGMpO1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gYS54ICogZDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IGEueSAqIGQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBhLnogKiBkO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gTWF0aC5jb3MoYyk7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBhLmVsZW1lbnRzLCBjID0gYlswXTtcclxuICAgICAgICAgICAgYSA9IGJbNF07XHJcbiAgICAgICAgICAgIHZhciBkID0gYls4XSwgZSA9IGJbMV0sIGYgPSBiWzVdLCBnID0gYls5XSwgaCA9IGJbMl0sIG0gPSBiWzZdLCBiID0gYlsxMF0sIGsgPSBjICsgZiArIGI7XHJcbiAgICAgICAgICAgIDAgPCBrID8gKGMgPSAuNSAvIE1hdGguc3FydChrICsgMSksIHRoaXMuX3cgPSAuMjUgLyBjLCB0aGlzLl94ID0gKG0gLSBnKSAqIGMsIHRoaXMuX3kgPSAoZCAtIGgpICogYywgdGhpcy5feiA9IChlIC0gYSkgKiBjKSA6IGMgPiBmICYmIGMgPiBiID8gKGMgPSAyICogTWF0aC5zcXJ0KDEgKyBjIC0gZiAtIGIpLCB0aGlzLl93ID0gKG0gLSBnKSAvIGMsIHRoaXMuX3ggPSAuMjUgKiBjLCB0aGlzLl95ID0gKGEgKyBlKSAvIGMsIHRoaXMuX3ogPSAoZCArIGgpIC8gYykgOiBmID4gYiA/IChjID0gMiAqIE1hdGguc3FydCgxICsgZiAtIGMgLSBiKSwgdGhpcy5fdyA9IChkIC0gaCkgLyBjLCB0aGlzLl94ID0gKGEgKyBlKSAvIGMsIHRoaXMuX3kgPSAuMjUgKiBjLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IChnICsgbSkgLyBjKSA6IChjID0gMiAqIE1hdGguc3FydCgxICsgYiAtIGMgLSBmKSwgdGhpcy5fdyA9IChlIC0gYSkgLyBjLCB0aGlzLl94ID0gKGQgKyBoKSAvIGMsIHRoaXMuX3kgPSAoZyArIG0pIC8gYywgdGhpcy5feiA9IC4yNSAqIGMpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGI7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgZCkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHEpO1xyXG4gICAgICAgICAgICAgICAgYiA9IGMuZG90KGQpICsgMTtcclxuICAgICAgICAgICAgICAgIDFFLTYgPiBiID8gKGIgPSAwLCBNYXRoLmFicyhjLngpID4gTWF0aC5hYnMoYy56KSA/IGEuc2V0KC1jLnksIGMueCwgMCkgOiBhLnNldCgwLCAtYy56LCBjLnkpKSA6IGEuY3Jvc3NWZWN0b3JzKGMsIGQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGEueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBhLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gYS56O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdyA9IGI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpXHJcbiAgICAgICAgfSwgY29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggKj0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgKj1cclxuICAgICAgICAgICAgICAgIC0xO1xyXG4gICAgICAgICAgICB0aGlzLl96ICo9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBkb3Q6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94ICogYS5feCArIHRoaXMuX3kgKiBhLl95ICsgdGhpcy5feiAqIGEuX3ogKyB0aGlzLl93ICogYS5fd1xyXG4gICAgICAgIH0sIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fd1xyXG4gICAgICAgIH0sIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93KVxyXG4gICAgICAgIH0sIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMubGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIDAgPT09IGEgPyAodGhpcy5feiA9IHRoaXMuX3kgPSB0aGlzLl94ID0gMCwgdGhpcy5fdyA9IDEpIDogKGEgPSAxIC8gYSwgdGhpcy5feCAqPSBhLCB0aGlzLl95ICo9IGEsIHRoaXMuX3ogKj0gYSwgdGhpcy5fdyAqPSBhKTtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbXVsdGlwbHk6IGZ1bmN0aW9uIChhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBiID8gKGNvbnNvbGUud2FybihcIlRIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSwgdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKGEsIGIpKSA6IHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLCBhKVxyXG4gICAgICAgIH0sIHByZW11bHRpcGx5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKGEsIHRoaXMpXHJcbiAgICAgICAgfSwgbXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBhLl94LCBkID0gYS5feSwgZSA9IGEuX3osIGYgPSBhLl93LCBnID0gYi5feCwgaCA9IGIuX3ksIG0gPSBiLl96LCBrID0gYi5fdztcclxuICAgICAgICAgICAgdGhpcy5feCA9IGMgKiBrICsgZiAqIGcgKyBkICogbSAtIGUgKiBoO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gZCAqIGsgKyBmICogaCArIGUgKiBnIC0gYyAqIG07XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBlICogayArIGYgKiBtICsgYyAqIGggLSBkICogZztcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGYgKiBrIC0gYyAqIGcgLSBkICogaCAtIGUgKiBtO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzbGVycDogZnVuY3Rpb24gKGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKSB7XHJcbiAgICAgICAgICAgIGlmICgwID09PSBiKXJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoMSA9PT0gYilyZXR1cm4gdGhpcy5jb3B5KGEpO1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX3gsIGQgPSB0aGlzLl95LCBlID0gdGhpcy5feiwgZiA9IHRoaXMuX3csIGcgPSBmICogYS5fdyArIGMgKiBhLl94ICsgZCAqIGEuX3kgKyBlICogYS5fejtcclxuICAgICAgICAgICAgMCA+IGcgPyAodGhpcy5fdyA9IC1hLl93LCB0aGlzLl94ID0gLWEuX3gsIHRoaXMuX3kgPSAtYS5feSwgdGhpcy5feiA9IC1hLl96LCBnID0gLWcpIDogdGhpcy5jb3B5KGEpO1xyXG4gICAgICAgICAgICBpZiAoMSA8PSBnKXJldHVybiB0aGlzLl93ID0gZiwgdGhpcy5feCA9IGMsIHRoaXMuX3kgPSBkLCB0aGlzLl96ID0gZSwgdGhpcztcclxuICAgICAgICAgICAgdmFyIGggPSBNYXRoLnNxcnQoMSAtIGcgKiBnKTtcclxuICAgICAgICAgICAgaWYgKC4wMDEgPiBNYXRoLmFicyhoKSlyZXR1cm4gdGhpcy5fdyA9IC41ICogKGYgKyB0aGlzLl93KSwgdGhpcy5feCA9IC41ICogKGMgKyB0aGlzLl94KSwgdGhpcy5feSA9IC41ICogKGQgKyB0aGlzLl95KSwgdGhpcy5feiA9IC41ICogKGUgKyB0aGlzLl96KSwgdGhpcztcclxuICAgICAgICAgICAgdmFyIG0gPSBNYXRoLmF0YW4yKGgsIGcpLCBnID0gTWF0aC5zaW4oKDEgLSBiKSAqIG0pIC8gaCwgaCA9IE1hdGguc2luKGIgKiBtKSAvIGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSBmICogZyArIHRoaXMuX3cgKiBoO1xyXG4gICAgICAgICAgICB0aGlzLl94ID1cclxuICAgICAgICAgICAgICAgIGMgKiBnICsgdGhpcy5feCAqIGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBkICogZyArIHRoaXMuX3kgKiBoO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gZSAqIGcgKyB0aGlzLl96ICogaDtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZXF1YWxzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5feCA9PT0gdGhpcy5feCAmJiBhLl95ID09PSB0aGlzLl95ICYmIGEuX3ogPT09IHRoaXMuX3ogJiYgYS5fdyA9PT0gdGhpcy5fd1xyXG4gICAgICAgIH0sIGZyb21BcnJheTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSBhW2JdO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYVtiICsgMV07XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBhW2IgKyAyXTtcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGFbYiArIDNdO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0b0FycmF5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBbXSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xyXG4gICAgICAgICAgICBhW2JdID0gdGhpcy5feDtcclxuICAgICAgICAgICAgYVtiICsgMV0gPSB0aGlzLl95O1xyXG4gICAgICAgICAgICBhW2IgKyAyXSA9IHRoaXMuX3o7XHJcbiAgICAgICAgICAgIGFbYiArIDNdID0gdGhpcy5fdztcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCBvbkNoYW5nZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihjYSwge1xyXG4gICAgICAgIHNsZXJwOiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYy5jb3B5KGEpLnNsZXJwKGIsIGQpXHJcbiAgICAgICAgfSwgc2xlcnBGbGF0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZiwgZykge1xyXG4gICAgICAgICAgICB2YXIgaCA9IGNbZCArIDBdLCBtID0gY1tkICsgMV0sIGsgPSBjW2QgKyAyXTtcclxuICAgICAgICAgICAgYyA9IGNbZCArIDNdO1xyXG4gICAgICAgICAgICBkID0gZVtmICsgMF07XHJcbiAgICAgICAgICAgIHZhciBsID0gZVtmICsgMV0sIHAgPSBlW2YgKyAyXTtcclxuICAgICAgICAgICAgZSA9IGVbZiArIDNdO1xyXG4gICAgICAgICAgICBpZiAoYyAhPT0gZSB8fCBoICE9PSBkIHx8IG0gIT09IGwgfHwgayAhPT0gcCkge1xyXG4gICAgICAgICAgICAgICAgZiA9IDEgLSBnO1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBoICogZCArIG0gKiBsICsgayAqIHAgKyBjICogZSwgdSA9IDAgPD0gbiA/IDEgOiAtMSwgcSA9IDEgLSBuICogbjtcclxuICAgICAgICAgICAgICAgIHEgPiBOdW1iZXIuRVBTSUxPTiAmJiAocSA9IE1hdGguc3FydChxKSwgbiA9IE1hdGguYXRhbjIocSwgbiAqIHUpLCBmID0gTWF0aC5zaW4oZiAqIG4pIC8gcSwgZyA9IE1hdGguc2luKGcgKiBuKSAvIHEpO1xyXG4gICAgICAgICAgICAgICAgdSAqPSBnO1xyXG4gICAgICAgICAgICAgICAgaCA9IGggKiBmICsgZCAqIHU7XHJcbiAgICAgICAgICAgICAgICBtID0gbSAqIGYgKyBsICogdTtcclxuICAgICAgICAgICAgICAgIGsgPSBrICogZiArIHAgKiB1O1xyXG4gICAgICAgICAgICAgICAgYyA9IGMgKiBmICsgZSAqIHU7XHJcbiAgICAgICAgICAgICAgICBmID09PSAxIC0gZyAmJiAoZyA9IDEgLyBNYXRoLnNxcnQoaCAqIGggKyBtICogbSArIGsgKiBrICsgYyAqIGMpLCBoICo9IGcsIG0gKj0gZywgayAqPSBnLCBjICo9IGcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYVtiXSA9IGg7XHJcbiAgICAgICAgICAgIGFbYiArXHJcbiAgICAgICAgICAgIDFdID0gbTtcclxuICAgICAgICAgICAgYVtiICsgMl0gPSBrO1xyXG4gICAgICAgICAgICBhW2IgKyAzXSA9IGNcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBxLCBpc1ZlY3RvcjM6ICEwLCBzZXQ6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IGM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0U2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnogPSB0aGlzLnkgPSB0aGlzLnggPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0WTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy55ID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRaOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldENvbXBvbmVudDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIiArIGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGEpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuejtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMueilcclxuICAgICAgICB9LCBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGEueTtcclxuICAgICAgICAgICAgdGhpcy56ID0gYS56O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGFkZDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYilyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSwgdGhpcy5hZGRWZWN0b3JzKGEsIGIpO1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gYS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgKz0gYS55O1xyXG4gICAgICAgICAgICB0aGlzLnogKz0gYS56O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGFkZFNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ICs9IGE7XHJcbiAgICAgICAgICAgIHRoaXMueSArPSBhO1xyXG4gICAgICAgICAgICB0aGlzLnogKz0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFZlY3RvcnM6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGEueCArIGIueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gYS55ICsgYi55O1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhLnogKyBiLno7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gYS54ICogYjtcclxuICAgICAgICAgICAgdGhpcy55ICs9IGEueSAqIGI7XHJcbiAgICAgICAgICAgIHRoaXMueiArPSBhLnogKiBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHN1YjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYilyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSwgdGhpcy5zdWJWZWN0b3JzKGEsIGIpO1xyXG4gICAgICAgICAgICB0aGlzLnggLT0gYS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgLT0gYS55O1xyXG4gICAgICAgICAgICB0aGlzLnogLT0gYS56O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHN1YlNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy54IC09IGE7XHJcbiAgICAgICAgICAgIHRoaXMueSAtPSBhO1xyXG4gICAgICAgICAgICB0aGlzLnogLT0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzdWJWZWN0b3JzOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhLnggLSBiLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcclxuICAgICAgICAgICAgdGhpcy56ID1cclxuICAgICAgICAgICAgICAgIGEueiAtIGIuejtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtdWx0aXBseTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYilyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksIHRoaXMubXVsdGlwbHlWZWN0b3JzKGEsIGIpO1xyXG4gICAgICAgICAgICB0aGlzLnggKj0gYS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgKj0gYS55O1xyXG4gICAgICAgICAgICB0aGlzLnogKj0gYS56O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpc0Zpbml0ZShhKSA/ICh0aGlzLnggKj0gYSwgdGhpcy55ICo9IGEsIHRoaXMueiAqPSBhKSA6IHRoaXMueiA9IHRoaXMueSA9IHRoaXMueCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhLnggKiBiLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGEueSAqIGIueTtcclxuICAgICAgICAgICAgdGhpcy56ID0gYS56ICogYi56O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgITEgPT09IChiICYmXHJcbiAgICAgICAgICAgICAgICBiLmlzRXVsZXIpICYmIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuXCIpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IGNhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihhLnNldEZyb21FdWxlcihiKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgYXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYiwgYykge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IGNhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihhLnNldEZyb21BeGlzQW5nbGUoYiwgYykpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLngsIGMgPSB0aGlzLnksIGQgPSB0aGlzLno7XHJcbiAgICAgICAgICAgIGEgPSBhLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhWzBdICogYiArIGFbM10gKiBjICsgYVs2XSAqIGQ7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGFbMV0gKiBiICsgYVs0XSAqIGMgKyBhWzddICogZDtcclxuICAgICAgICAgICAgdGhpcy56ID0gYVsyXSAqIGIgKyBhWzVdICogYyArIGFbOF0gKiBkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy54LCBjID0gdGhpcy55LCBkID0gdGhpcy56O1xyXG4gICAgICAgICAgICBhID0gYS5lbGVtZW50cztcclxuICAgICAgICAgICAgdGhpcy54ID0gYVswXSAqIGIgKyBhWzRdICogYyArIGFbOF0gKiBkICsgYVsxMl07XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGFbMV0gKiBiICsgYVs1XSAqIGMgKyBhWzldICogZCArIGFbMTNdO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhWzJdICogYiArIGFbNl0gKiBjICsgYVsxMF0gKiBkICsgYVsxNF07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcihhWzNdICogYiArIGFbN10gKiBjICsgYVsxMV0gKiBkICsgYVsxNV0pXHJcbiAgICAgICAgfSwgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMueCwgYyA9IHRoaXMueSwgZCA9IHRoaXMueiwgZSA9IGEueCwgZiA9IGEueSwgZyA9IGEuejtcclxuICAgICAgICAgICAgYSA9IGEudztcclxuICAgICAgICAgICAgdmFyIGggPSBhICogYiArIGYgKiBkIC0gZyAqIGMsIG0gPSBhICogYyArIGcgKiBiIC0gZSAqIGQsIGsgPSBhICogZCArIGUgKiBjIC0gZiAqIGIsXHJcbiAgICAgICAgICAgICAgICBiID0gLWUgKiBiIC0gZiAqIGMgLSBnICogZDtcclxuICAgICAgICAgICAgdGhpcy54ID0gaCAqIGEgKyBiICogLWUgKyBtICogLWcgLSBrICogLWY7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IG0gKiBhICsgYiAqIC1mICsgayAqIC1lIC0gaCAqIC1nO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBrICogYSArIGIgKiAtZyArIGggKiAtZiAtIG0gKiAtZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBTKTtcclxuICAgICAgICAgICAgICAgIGEubXVsdGlwbHlNYXRyaWNlcyhiLnByb2plY3Rpb25NYXRyaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgYS5nZXRJbnZlcnNlKGIubWF0cml4V29ybGQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCB1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IFMpO1xyXG4gICAgICAgICAgICAgICAgYS5tdWx0aXBseU1hdHJpY2VzKGIubWF0cml4V29ybGQsIGEuZ2V0SW52ZXJzZShiLnByb2plY3Rpb25NYXRyaXgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCB0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy54LCBjID0gdGhpcy55LCBkID0gdGhpcy56O1xyXG4gICAgICAgICAgICBhID0gYS5lbGVtZW50cztcclxuICAgICAgICAgICAgdGhpcy54ID0gYVswXSAqIGIgKyBhWzRdICogYyArIGFbOF0gKiBkO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhWzFdICogYiArIGFbNV0gKiBjICsgYVs5XSAqIGQ7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IGFbMl0gKiBiICsgYVs2XSAqIGMgKyBhWzEwXSAqIGQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpXHJcbiAgICAgICAgfSwgZGl2aWRlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnggLz0gYS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgLz0gYS55O1xyXG4gICAgICAgICAgICB0aGlzLnogLz0gYS56O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvXHJcbiAgICAgICAgICAgICAgICBhKVxyXG4gICAgICAgIH0sIG1pbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCBhLngpO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIGEueSk7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IE1hdGgubWluKHRoaXMueiwgYS56KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtYXg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgYS54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBhLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIGEueik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xhbXA6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgubWF4KGEueCwgTWF0aC5taW4oYi54LCB0aGlzLngpKTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgoYS55LCBNYXRoLm1pbihiLnksIHRoaXMueSkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBNYXRoLm1heChhLnosIE1hdGgubWluKGIueiwgdGhpcy56KSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGI7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgZCkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHEsIGIgPSBuZXcgcSk7XHJcbiAgICAgICAgICAgICAgICBhLnNldChjLCBjLCBjKTtcclxuICAgICAgICAgICAgICAgIGIuc2V0KGQsIGQsIGQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoYSxcclxuICAgICAgICAgICAgICAgICAgICBiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBjbGFtcExlbmd0aDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihNYXRoLm1heChhLCBNYXRoLm1pbihiLCBjKSkgLyBjKVxyXG4gICAgICAgIH0sIGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBNYXRoLmZsb29yKHRoaXMueik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2VpbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IE1hdGguY2VpbCh0aGlzLnopO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gMCA+IHRoaXMueCA/IE1hdGguY2VpbCh0aGlzLngpIDogTWF0aC5mbG9vcih0aGlzLngpO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSAwID4gdGhpcy55ID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSk7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IDAgPiB0aGlzLnogPyBNYXRoLmNlaWwodGhpcy56KSA6IE1hdGguZmxvb3IodGhpcy56KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gLXRoaXMueTtcclxuICAgICAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBkb3Q6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiBhLnggKyB0aGlzLnkgKiBhLnkgKyB0aGlzLnogKiBhLnpcclxuICAgICAgICB9LCBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56XHJcbiAgICAgICAgfSwgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56KVxyXG4gICAgICAgIH0sIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopXHJcbiAgICAgICAgfSwgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0TGVuZ3RoOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihhIC8gdGhpcy5sZW5ndGgoKSlcclxuICAgICAgICB9LCBsZXJwOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gKGEueCAtIHRoaXMueCkgKiBiO1xyXG4gICAgICAgICAgICB0aGlzLnkgKz0gKGEueSAtIHRoaXMueSkgKiBiO1xyXG4gICAgICAgICAgICB0aGlzLnogKz0gKGEueiAtIHRoaXMueikgKiBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKGIsIGEpLm11bHRpcGx5U2NhbGFyKGMpLmFkZChhKVxyXG4gICAgICAgIH0sIGNyb3NzOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBiKXJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSwgdGhpcy5jcm9zc1ZlY3RvcnMoYSwgYik7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy54LCBkID0gdGhpcy55LCBlID0gdGhpcy56O1xyXG4gICAgICAgICAgICB0aGlzLnggPSBkICogYS56IC0gZSAqIGEueTtcclxuICAgICAgICAgICAgdGhpcy55ID0gZSAqIGEueCAtIGMgKiBhLno7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IGMgKiBhLnkgLVxyXG4gICAgICAgICAgICAgICAgZCAqIGEueDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYS54LCBkID0gYS55LCBlID0gYS56LCBmID0gYi54LCBnID0gYi55LCBoID0gYi56O1xyXG4gICAgICAgICAgICB0aGlzLnggPSBkICogaCAtIGUgKiBnO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBlICogZiAtIGMgKiBoO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBjICogZyAtIGQgKiBmO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBhLmRvdCh0aGlzKSAvIGEubGVuZ3RoU3EoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29weShhKS5tdWx0aXBseVNjYWxhcihiKVxyXG4gICAgICAgIH0sIHByb2plY3RPblBsYW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBxKTtcclxuICAgICAgICAgICAgICAgIGEuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IoYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIoYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgcmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgcSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIoYS5jb3B5KGIpLm11bHRpcGx5U2NhbGFyKDIgKiB0aGlzLmRvdChiKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGFuZ2xlVG86IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3QoYSkgLyBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpICogYS5sZW5ndGhTcSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhOLmNsYW1wKGEsIC0xLCAxKSlcclxuICAgICAgICB9LCBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoYSkpXHJcbiAgICAgICAgfSwgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy54IC0gYS54LCBjID0gdGhpcy55IC0gYS55O1xyXG4gICAgICAgICAgICBhID0gdGhpcy56IC0gYS56O1xyXG4gICAgICAgICAgICByZXR1cm4gYiAqIGIgKyBjICogYyArIGEgKiBhXHJcbiAgICAgICAgfSwgZGlzdGFuY2VUb01hbmhhdHRhbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIGEueCkgKyBNYXRoLmFicyh0aGlzLnkgLSBhLnkpICsgTWF0aC5hYnModGhpcy56IC0gYS56KVxyXG4gICAgICAgIH0sIHNldEZyb21TcGhlcmljYWw6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gTWF0aC5zaW4oYS5waGkpICogYS5yYWRpdXM7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGIgKiBNYXRoLnNpbihhLnRoZXRhKTtcclxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5jb3MoYS5waGkpICogYS5yYWRpdXM7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IGIgKiBNYXRoLmNvcyhhLnRoZXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEZyb21DeWxpbmRyaWNhbDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gYS5yYWRpdXMgKiBNYXRoLnNpbihhLnRoZXRhKTtcclxuICAgICAgICAgICAgdGhpcy55ID0gYS55O1xyXG4gICAgICAgICAgICB0aGlzLnogPSBhLnJhZGl1cyAqIE1hdGguY29zKGEudGhldGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihhLCAzKVxyXG4gICAgICAgIH0sIHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oYSwgMCkubGVuZ3RoKCksIGMgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oYSwgMSkubGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oYSwgMikubGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGM7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiBhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IzOiBzZXRGcm9tTWF0cml4Q29sdW1uIG5vdyBleHBlY3RzICggbWF0cml4LCBpbmRleCApLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gYTtcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgYiA9IGNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkoYS5lbGVtZW50cywgNCAqIGIpXHJcbiAgICAgICAgfSwgZXF1YWxzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS54ID09PSB0aGlzLnggJiYgYS55ID09PSB0aGlzLnkgJiYgYS56ID09PSB0aGlzLnpcclxuICAgICAgICB9LCBmcm9tQXJyYXk6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhW2JdO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhW2IgKyAxXTtcclxuICAgICAgICAgICAgdGhpcy56ID0gYVtiICsgMl07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgdG9BcnJheTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gW10pO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAwKTtcclxuICAgICAgICAgICAgYVtiXSA9IHRoaXMueDtcclxuICAgICAgICAgICAgYVtiICsgMV0gPSB0aGlzLnk7XHJcbiAgICAgICAgICAgIGFbYiArIDJdID0gdGhpcy56O1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH0sIGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYyAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IzOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhLmdldFgoYik7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGEuZ2V0WShiKTtcclxuICAgICAgICAgICAgdGhpcy56ID0gYS5nZXRaKGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogUywgaXNNYXRyaXg0OiAhMCwgc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgbSwgaywgbCwgcCwgbiwgdSwgcSwgcikge1xyXG4gICAgICAgICAgICB2YXIgQSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIEFbMF0gPSBhO1xyXG4gICAgICAgICAgICBBWzRdID0gYjtcclxuICAgICAgICAgICAgQVs4XSA9IGM7XHJcbiAgICAgICAgICAgIEFbMTJdID0gZDtcclxuICAgICAgICAgICAgQVsxXSA9IGU7XHJcbiAgICAgICAgICAgIEFbNV0gPSBmO1xyXG4gICAgICAgICAgICBBWzldID0gZztcclxuICAgICAgICAgICAgQVsxM10gPSBoO1xyXG4gICAgICAgICAgICBBWzJdID0gbTtcclxuICAgICAgICAgICAgQVs2XSA9IGs7XHJcbiAgICAgICAgICAgIEFbMTBdID0gbDtcclxuICAgICAgICAgICAgQVsxNF0gPSBwO1xyXG4gICAgICAgICAgICBBWzNdID0gbjtcclxuICAgICAgICAgICAgQVs3XSA9IHU7XHJcbiAgICAgICAgICAgIEFbMTFdID0gcTtcclxuICAgICAgICAgICAgQVsxNV0gPSByO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobmV3IFMpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KGEuZWxlbWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBhID0gYS5lbGVtZW50cztcclxuICAgICAgICAgICAgYlsxMl0gPSBhWzEyXTtcclxuICAgICAgICAgICAgYlsxM10gPSBhWzEzXTtcclxuICAgICAgICAgICAgYlsxNF0gPSBhWzE0XTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBleHRyYWN0QmFzaXM6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGEuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAwKTtcclxuICAgICAgICAgICAgYi5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDEpO1xyXG4gICAgICAgICAgICBjLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZUJhc2lzOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB0aGlzLnNldChhLngsIGIueCwgYy54LCAwLCBhLnksIGIueSwgYy55LCAwLCBhLnosIGIueiwgYy56LCAwLCAwLCAwLCAwLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmVsZW1lbnRzLCBkID0gYi5lbGVtZW50cywgZSA9IDEgLyBhLnNldEZyb21NYXRyaXhDb2x1bW4oYiwgMCkubGVuZ3RoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IDEgLyBhLnNldEZyb21NYXRyaXhDb2x1bW4oYiwgMSkubGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBiID0gMSAvIGEuc2V0RnJvbU1hdHJpeENvbHVtbihiLCAyKS5sZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGNbMF0gPSBkWzBdICogZTtcclxuICAgICAgICAgICAgICAgIGNbMV0gPSBkWzFdICogZTtcclxuICAgICAgICAgICAgICAgIGNbMl0gPSBkWzJdICogZTtcclxuICAgICAgICAgICAgICAgIGNbNF0gPSBkWzRdICogZjtcclxuICAgICAgICAgICAgICAgIGNbNV0gPSBkWzVdICogZjtcclxuICAgICAgICAgICAgICAgIGNbNl0gPSBkWzZdICogZjtcclxuICAgICAgICAgICAgICAgIGNbOF0gPSBkWzhdICogYjtcclxuICAgICAgICAgICAgICAgIGNbOV0gPSBkWzldICogYjtcclxuICAgICAgICAgICAgICAgIGNbMTBdID0gZFsxMF0gKiBiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgbWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAhMSA9PT0gKGEgJiYgYS5pc0V1bGVyKSAmJiBjb25zb2xlLmVycm9yKFwiVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLlwiKTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnRzLCBjID0gYS54LCBkID0gYS55LCBlID0gYS56LCBmID0gTWF0aC5jb3MoYyksIGMgPSBNYXRoLnNpbihjKSwgZyA9IE1hdGguY29zKGQpLFxyXG4gICAgICAgICAgICAgICAgZCA9IE1hdGguc2luKGQpLCBoID0gTWF0aC5jb3MoZSksIGUgPSBNYXRoLnNpbihlKTtcclxuICAgICAgICAgICAgaWYgKFwiWFlaXCIgPT09IGEub3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIGEgPSBmICogaDtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gZiAqIGUsIGsgPSBjICogaCwgbCA9IGMgKiBlO1xyXG4gICAgICAgICAgICAgICAgYlswXSA9IGcgKiBoO1xyXG4gICAgICAgICAgICAgICAgYls0XSA9IC1nICogZTtcclxuICAgICAgICAgICAgICAgIGJbOF0gPSBkO1xyXG4gICAgICAgICAgICAgICAgYlsxXSA9IG0gK1xyXG4gICAgICAgICAgICAgICAgICAgIGsgKiBkO1xyXG4gICAgICAgICAgICAgICAgYls1XSA9IGEgLSBsICogZDtcclxuICAgICAgICAgICAgICAgIGJbOV0gPSAtYyAqIGc7XHJcbiAgICAgICAgICAgICAgICBiWzJdID0gbCAtIGEgKiBkO1xyXG4gICAgICAgICAgICAgICAgYls2XSA9IGsgKyBtICogZDtcclxuICAgICAgICAgICAgICAgIGJbMTBdID0gZiAqIGdcclxuICAgICAgICAgICAgfSBlbHNlXCJZWFpcIiA9PT0gYS5vcmRlciA/IChhID0gZyAqIGgsIG0gPSBnICogZSwgayA9IGQgKiBoLCBsID0gZCAqIGUsIGJbMF0gPSBhICsgbCAqIGMsIGJbNF0gPSBrICogYyAtIG0sIGJbOF0gPSBmICogZCwgYlsxXSA9IGYgKiBlLCBiWzVdID0gZiAqIGgsIGJbOV0gPSAtYywgYlsyXSA9IG0gKiBjIC0gaywgYls2XSA9IGwgKyBhICogYywgYlsxMF0gPSBmICogZykgOiBcIlpYWVwiID09PSBhLm9yZGVyID8gKGEgPSBnICogaCwgbSA9IGcgKiBlLCBrID0gZCAqIGgsIGwgPSBkICogZSwgYlswXSA9IGEgLSBsICogYywgYls0XSA9IC1mICogZSwgYls4XSA9IGsgKyBtICogYywgYlsxXSA9IG0gKyBrICogYywgYls1XSA9IGYgKiBoLCBiWzldID0gbCAtIGEgKiBjLCBiWzJdID0gLWYgKiBkLCBiWzZdID0gYywgYlsxMF0gPSBmICogZykgOiBcIlpZWFwiID09PSBhLm9yZGVyID8gKGEgPSBmICogaCwgbSA9IGYgKiBlLCBrID0gYyAqIGgsIGwgPSBjICogZSwgYlswXSA9IGcgKiBoLCBiWzRdID0gayAqIGQgLSBtLCBiWzhdID0gYSAqIGQgKyBsLCBiWzFdID0gZyAqIGUsIGJbNV0gPSBsICogZCArIGEsIGJbOV0gPSBtICogZCAtIGssIGJbMl0gPSAtZCwgYls2XSA9IGMgKiBnLCBiWzEwXSA9IGYgKiBnKSA6IFwiWVpYXCIgPT09IGEub3JkZXIgPyAoYSA9IGYgKiBnLCBtID0gZiAqIGQsIGsgPSBjICogZywgbCA9IGMgKiBkLCBiWzBdID1cclxuICAgICAgICAgICAgICAgIGcgKiBoLCBiWzRdID0gbCAtIGEgKiBlLCBiWzhdID0gayAqIGUgKyBtLCBiWzFdID0gZSwgYls1XSA9IGYgKiBoLCBiWzldID0gLWMgKiBoLCBiWzJdID0gLWQgKiBoLCBiWzZdID0gbSAqIGUgKyBrLCBiWzEwXSA9IGEgLSBsICogZSkgOiBcIlhaWVwiID09PSBhLm9yZGVyICYmIChhID0gZiAqIGcsIG0gPSBmICogZCwgayA9IGMgKiBnLCBsID0gYyAqIGQsIGJbMF0gPSBnICogaCwgYls0XSA9IC1lLCBiWzhdID0gZCAqIGgsIGJbMV0gPSBhICogZSArIGwsIGJbNV0gPSBmICogaCwgYls5XSA9IG0gKiBlIC0gaywgYlsyXSA9IGsgKiBlIC0gbSwgYls2XSA9IGMgKiBoLCBiWzEwXSA9IGwgKiBlICsgYSk7XHJcbiAgICAgICAgICAgIGJbM10gPSAwO1xyXG4gICAgICAgICAgICBiWzddID0gMDtcclxuICAgICAgICAgICAgYlsxMV0gPSAwO1xyXG4gICAgICAgICAgICBiWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGJbMTNdID0gMDtcclxuICAgICAgICAgICAgYlsxNF0gPSAwO1xyXG4gICAgICAgICAgICBiWzE1XSA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50cywgYyA9IGEueCwgZCA9IGEueSwgZSA9IGEueiwgZiA9IGEudywgZyA9IGMgKyBjLCBoID0gZCArIGQsIG0gPSBlICsgZTtcclxuICAgICAgICAgICAgYSA9IGMgKiBnO1xyXG4gICAgICAgICAgICB2YXIgayA9IGMgKiBoLCBjID0gYyAqIG0sIGwgPSBkICogaCwgZCA9IGQgKiBtLCBlID0gZSAqIG0sIGcgPSBmICogZywgaCA9IGYgKiBoLCBmID0gZiAqIG07XHJcbiAgICAgICAgICAgIGJbMF0gPSAxIC0gKGwgKyBlKTtcclxuICAgICAgICAgICAgYls0XSA9IGsgLSBmO1xyXG4gICAgICAgICAgICBiWzhdID0gYyArIGg7XHJcbiAgICAgICAgICAgIGJbMV0gPSBrICsgZjtcclxuICAgICAgICAgICAgYls1XSA9IDEgLSAoYSArIGUpO1xyXG4gICAgICAgICAgICBiWzldID1cclxuICAgICAgICAgICAgICAgIGQgLSBnO1xyXG4gICAgICAgICAgICBiWzJdID0gYyAtIGg7XHJcbiAgICAgICAgICAgIGJbNl0gPSBkICsgZztcclxuICAgICAgICAgICAgYlsxMF0gPSAxIC0gKGEgKyBsKTtcclxuICAgICAgICAgICAgYlszXSA9IDA7XHJcbiAgICAgICAgICAgIGJbN10gPSAwO1xyXG4gICAgICAgICAgICBiWzExXSA9IDA7XHJcbiAgICAgICAgICAgIGJbMTJdID0gMDtcclxuICAgICAgICAgICAgYlsxM10gPSAwO1xyXG4gICAgICAgICAgICBiWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGJbMTVdID0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGIsIGM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCwgZSwgZikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHEsIGIgPSBuZXcgcSwgYyA9IG5ldyBxKTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgICAgIGMuc3ViVmVjdG9ycyhkLCBlKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIDAgPT09IGMubGVuZ3RoU3EoKSAmJiAoYy56ID0gMSk7XHJcbiAgICAgICAgICAgICAgICBhLmNyb3NzVmVjdG9ycyhmLCBjKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIDAgPT09IGEubGVuZ3RoU3EoKSAmJiAoYy56ICs9IDFFLTQsIGEuY3Jvc3NWZWN0b3JzKGYsIGMpLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICAgICAgICAgIGIuY3Jvc3NWZWN0b3JzKGMsIGEpO1xyXG4gICAgICAgICAgICAgICAgZ1swXSA9IGEueDtcclxuICAgICAgICAgICAgICAgIGdbNF0gPSBiLng7XHJcbiAgICAgICAgICAgICAgICBnWzhdID0gYy54O1xyXG4gICAgICAgICAgICAgICAgZ1sxXSA9IGEueTtcclxuICAgICAgICAgICAgICAgIGdbNV0gPSBiLnk7XHJcbiAgICAgICAgICAgICAgICBnWzldID0gYy55O1xyXG4gICAgICAgICAgICAgICAgZ1syXSA9IGEuejtcclxuICAgICAgICAgICAgICAgIGdbNl0gPSBiLno7XHJcbiAgICAgICAgICAgICAgICBnWzEwXSA9IGMuejtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIG11bHRpcGx5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PVxyXG4gICAgICAgICAgICBiID8gKGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLlwiKSwgdGhpcy5tdWx0aXBseU1hdHJpY2VzKGEsIGIpKSA6IHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLCBhKVxyXG4gICAgICAgIH0sIHByZW11bHRpcGx5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKGEsIHRoaXMpXHJcbiAgICAgICAgfSwgbXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBhLmVsZW1lbnRzLCBkID0gYi5lbGVtZW50cywgZSA9IHRoaXMuZWxlbWVudHMsIGYgPSBjWzBdLCBnID0gY1s0XSwgaCA9IGNbOF0sIG0gPSBjWzEyXSwgayA9IGNbMV0sXHJcbiAgICAgICAgICAgICAgICBsID0gY1s1XSwgcCA9IGNbOV0sIG4gPSBjWzEzXSwgdSA9IGNbMl0sIHEgPSBjWzZdLCByID0gY1sxMF0sIEEgPSBjWzE0XSwgdyA9IGNbM10sIHkgPSBjWzddLCBLID0gY1sxMV0sXHJcbiAgICAgICAgICAgICAgICBjID0gY1sxNV0sIHYgPSBkWzBdLCBFID0gZFs0XSwgTCA9IGRbOF0sIEMgPSBkWzEyXSwgRiA9IGRbMV0sIHggPSBkWzVdLCBIID0gZFs5XSwgRCA9IGRbMTNdLCB6ID0gZFsyXSxcclxuICAgICAgICAgICAgICAgIEogPSBkWzZdLFxyXG4gICAgICAgICAgICAgICAgSSA9IGRbMTBdLCBRID0gZFsxNF0sIE0gPSBkWzNdLCBPID0gZFs3XSwgUCA9IGRbMTFdLCBkID0gZFsxNV07XHJcbiAgICAgICAgICAgIGVbMF0gPSBmICogdiArIGcgKiBGICsgaCAqIHogKyBtICogTTtcclxuICAgICAgICAgICAgZVs0XSA9IGYgKiBFICsgZyAqIHggKyBoICogSiArIG0gKiBPO1xyXG4gICAgICAgICAgICBlWzhdID0gZiAqIEwgKyBnICogSCArIGggKiBJICsgbSAqIFA7XHJcbiAgICAgICAgICAgIGVbMTJdID0gZiAqIEMgKyBnICogRCArIGggKiBRICsgbSAqIGQ7XHJcbiAgICAgICAgICAgIGVbMV0gPSBrICogdiArIGwgKiBGICsgcCAqIHogKyBuICogTTtcclxuICAgICAgICAgICAgZVs1XSA9IGsgKiBFICsgbCAqIHggKyBwICogSiArIG4gKiBPO1xyXG4gICAgICAgICAgICBlWzldID0gayAqIEwgKyBsICogSCArIHAgKiBJICsgbiAqIFA7XHJcbiAgICAgICAgICAgIGVbMTNdID0gayAqIEMgKyBsICogRCArIHAgKiBRICsgbiAqIGQ7XHJcbiAgICAgICAgICAgIGVbMl0gPSB1ICogdiArIHEgKiBGICsgciAqIHogKyBBICogTTtcclxuICAgICAgICAgICAgZVs2XSA9IHUgKiBFICsgcSAqIHggKyByICogSiArIEEgKiBPO1xyXG4gICAgICAgICAgICBlWzEwXSA9IHUgKiBMICsgcSAqIEggKyByICogSSArIEEgKiBQO1xyXG4gICAgICAgICAgICBlWzE0XSA9IHUgKiBDICsgcSAqIEQgKyByICogUSArIEEgKiBkO1xyXG4gICAgICAgICAgICBlWzNdID0gdyAqIHYgKyB5ICogRiArIEsgKiB6ICsgYyAqIE07XHJcbiAgICAgICAgICAgIGVbN10gPSB3ICogRSArIHkgKiB4ICsgSyAqIEogKyBjICogTztcclxuICAgICAgICAgICAgZVsxMV0gPSB3ICogTCArIHkgKiBIICsgSyAqIEkgKyBjICogUDtcclxuICAgICAgICAgICAgZVsxNV0gPSB3ICogQyArIHkgKiBEICsgSyAqIFEgKyBjICogZDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtdWx0aXBseVRvQXJyYXk6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBseU1hdHJpY2VzKGEsIGIpO1xyXG4gICAgICAgICAgICBjWzBdID0gZFswXTtcclxuICAgICAgICAgICAgY1sxXSA9IGRbMV07XHJcbiAgICAgICAgICAgIGNbMl0gPVxyXG4gICAgICAgICAgICAgICAgZFsyXTtcclxuICAgICAgICAgICAgY1szXSA9IGRbM107XHJcbiAgICAgICAgICAgIGNbNF0gPSBkWzRdO1xyXG4gICAgICAgICAgICBjWzVdID0gZFs1XTtcclxuICAgICAgICAgICAgY1s2XSA9IGRbNl07XHJcbiAgICAgICAgICAgIGNbN10gPSBkWzddO1xyXG4gICAgICAgICAgICBjWzhdID0gZFs4XTtcclxuICAgICAgICAgICAgY1s5XSA9IGRbOV07XHJcbiAgICAgICAgICAgIGNbMTBdID0gZFsxMF07XHJcbiAgICAgICAgICAgIGNbMTFdID0gZFsxMV07XHJcbiAgICAgICAgICAgIGNbMTJdID0gZFsxMl07XHJcbiAgICAgICAgICAgIGNbMTNdID0gZFsxM107XHJcbiAgICAgICAgICAgIGNbMTRdID0gZFsxNF07XHJcbiAgICAgICAgICAgIGNbMTVdID0gZFsxNV07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgYlswXSAqPSBhO1xyXG4gICAgICAgICAgICBiWzRdICo9IGE7XHJcbiAgICAgICAgICAgIGJbOF0gKj0gYTtcclxuICAgICAgICAgICAgYlsxMl0gKj0gYTtcclxuICAgICAgICAgICAgYlsxXSAqPSBhO1xyXG4gICAgICAgICAgICBiWzVdICo9IGE7XHJcbiAgICAgICAgICAgIGJbOV0gKj0gYTtcclxuICAgICAgICAgICAgYlsxM10gKj0gYTtcclxuICAgICAgICAgICAgYlsyXSAqPSBhO1xyXG4gICAgICAgICAgICBiWzZdICo9IGE7XHJcbiAgICAgICAgICAgIGJbMTBdICo9IGE7XHJcbiAgICAgICAgICAgIGJbMTRdICo9IGE7XHJcbiAgICAgICAgICAgIGJbM10gKj0gYTtcclxuICAgICAgICAgICAgYls3XSAqPSBhO1xyXG4gICAgICAgICAgICBiWzExXSAqPSBhO1xyXG4gICAgICAgICAgICBiWzE1XSAqPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHEpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGQgPSBiLmNvdW50OyBjIDwgZDsgYysrKWEueCA9IGIuZ2V0WChjKSwgYS55ID0gYi5nZXRZKGMpLCBhLnogPSBiLmdldFooYyksXHJcbiAgICAgICAgICAgICAgICAgICAgYS5hcHBseU1hdHJpeDQodGhpcyksIGIuc2V0WFlaKGMsIGEueCwgYS55LCBhLnopO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnRzLCBiID0gYVswXSwgYyA9IGFbNF0sIGQgPSBhWzhdLCBlID0gYVsxMl0sIGYgPSBhWzFdLCBnID0gYVs1XSwgaCA9IGFbOV0sIG0gPSBhWzEzXSxcclxuICAgICAgICAgICAgICAgIGsgPSBhWzJdLCBsID0gYVs2XSwgcCA9IGFbMTBdLCBuID0gYVsxNF07XHJcbiAgICAgICAgICAgIHJldHVybiBhWzNdICogKCtlICogaCAqIGwgLSBkICogbSAqIGwgLSBlICogZyAqIHAgKyBjICogbSAqIHAgKyBkICogZyAqIG4gLSBjICogaCAqIG4pICsgYVs3XSAqICgrYiAqIGggKiBuIC0gYiAqIG0gKiBwICsgZSAqIGYgKiBwIC0gZCAqIGYgKiBuICsgZCAqIG0gKiBrIC0gZSAqIGggKiBrKSArIGFbMTFdICogKCtiICogbSAqIGwgLSBiICogZyAqIG4gLSBlICogZiAqIGwgKyBjICogZiAqIG4gKyBlICogZyAqIGsgLSBjICogbSAqIGspICsgYVsxNV0gKiAoLWQgKiBnICogayAtIGIgKiBoICogbCArIGIgKiBnICogcCArIGQgKiBmICogbCAtIGMgKiBmICogcCArIGMgKiBoICogaylcclxuICAgICAgICB9LCB0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnRzLCBiO1xyXG4gICAgICAgICAgICBiID0gYVsxXTtcclxuICAgICAgICAgICAgYVsxXSA9IGFbNF07XHJcbiAgICAgICAgICAgIGFbNF0gPSBiO1xyXG4gICAgICAgICAgICBiID0gYVsyXTtcclxuICAgICAgICAgICAgYVsyXSA9IGFbOF07XHJcbiAgICAgICAgICAgIGFbOF0gPSBiO1xyXG4gICAgICAgICAgICBiID0gYVs2XTtcclxuICAgICAgICAgICAgYVs2XSA9IGFbOV07XHJcbiAgICAgICAgICAgIGFbOV0gPSBiO1xyXG4gICAgICAgICAgICBiID0gYVszXTtcclxuICAgICAgICAgICAgYVszXSA9XHJcbiAgICAgICAgICAgICAgICBhWzEyXTtcclxuICAgICAgICAgICAgYVsxMl0gPSBiO1xyXG4gICAgICAgICAgICBiID0gYVs3XTtcclxuICAgICAgICAgICAgYVs3XSA9IGFbMTNdO1xyXG4gICAgICAgICAgICBhWzEzXSA9IGI7XHJcbiAgICAgICAgICAgIGIgPSBhWzExXTtcclxuICAgICAgICAgICAgYVsxMV0gPSBhWzE0XTtcclxuICAgICAgICAgICAgYVsxNF0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGJbMTJdID0gYS54O1xyXG4gICAgICAgICAgICBiWzEzXSA9IGEueTtcclxuICAgICAgICAgICAgYlsxNF0gPSBhLno7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZ2V0SW52ZXJzZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmVsZW1lbnRzLCBkID0gYS5lbGVtZW50cywgZSA9IGRbMF0sIGYgPSBkWzFdLCBnID0gZFsyXSwgaCA9IGRbM10sIG0gPSBkWzRdLCBrID0gZFs1XSwgbCA9IGRbNl0sXHJcbiAgICAgICAgICAgICAgICBwID0gZFs3XSwgbiA9IGRbOF0sIHUgPSBkWzldLCBxID0gZFsxMF0sIHIgPSBkWzExXSwgQSA9IGRbMTJdLCB3ID0gZFsxM10sIHkgPSBkWzE0XSwgZCA9IGRbMTVdLFxyXG4gICAgICAgICAgICAgICAgSyA9IHUgKiB5ICogcCAtIHcgKiBxICogcCArIHcgKiBsICogciAtIGsgKiB5ICogciAtIHUgKiBsICogZCArIGsgKiBxICogZCxcclxuICAgICAgICAgICAgICAgIHYgPSBBICogcSAqIHAgLSBuICogeSAqIHAgLSBBICogbCAqIHIgKyBtICogeSAqIHIgKyBuICogbCAqIGQgLSBtICogcSAqIGQsXHJcbiAgICAgICAgICAgICAgICBFID0gbiAqIHcgKiBwIC0gQSAqIHUgKiBwICsgQSAqIGsgKiByIC0gbSAqIHcgKiByIC0gbiAqIGsgKiBkICsgbSAqIHUgKiBkLFxyXG4gICAgICAgICAgICAgICAgTCA9IEEgKiB1ICogbCAtIG4gKiB3ICogbCAtIEEgKiBrICogcSArIG0gKiB3ICogcSArIG4gKiBrICogeSAtIG0gKiB1ICogeSwgQyA9IGUgKiBLICtcclxuICAgICAgICAgICAgICAgICAgICBmICogdiArIGcgKiBFICsgaCAqIEw7XHJcbiAgICAgICAgICAgIGlmICgwID09PSBDKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoITAgPT09IGIpdGhyb3cgRXJyb3IoXCJUSFJFRS5NYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEMgPSAxIC8gQztcclxuICAgICAgICAgICAgY1swXSA9IEsgKiBDO1xyXG4gICAgICAgICAgICBjWzFdID0gKHcgKiBxICogaCAtIHUgKiB5ICogaCAtIHcgKiBnICogciArIGYgKiB5ICogciArIHUgKiBnICogZCAtIGYgKiBxICogZCkgKiBDO1xyXG4gICAgICAgICAgICBjWzJdID0gKGsgKiB5ICogaCAtIHcgKiBsICogaCArIHcgKiBnICogcCAtIGYgKiB5ICogcCAtIGsgKiBnICogZCArIGYgKiBsICogZCkgKiBDO1xyXG4gICAgICAgICAgICBjWzNdID0gKHUgKiBsICogaCAtIGsgKiBxICogaCAtIHUgKiBnICogcCArIGYgKiBxICogcCArIGsgKiBnICogciAtIGYgKiBsICogcikgKiBDO1xyXG4gICAgICAgICAgICBjWzRdID0gdiAqIEM7XHJcbiAgICAgICAgICAgIGNbNV0gPSAobiAqIHkgKiBoIC0gQSAqIHEgKiBoICsgQSAqIGcgKiByIC0gZSAqIHkgKiByIC0gbiAqIGcgKiBkICsgZSAqIHEgKiBkKSAqIEM7XHJcbiAgICAgICAgICAgIGNbNl0gPSAoQSAqIGwgKiBoIC0gbSAqIHkgKiBoIC0gQSAqIGcgKiBwICsgZSAqIHkgKiBwICsgbSAqIGcgKiBkIC0gZSAqIGwgKiBkKSAqIEM7XHJcbiAgICAgICAgICAgIGNbN10gPSAobSAqIHEgKiBoIC0gbiAqIGwgKiBoICsgbiAqIGcgKiBwIC0gZSAqIHEgKiBwIC0gbSAqIGcgKlxyXG4gICAgICAgICAgICAgICAgciArIGUgKiBsICogcikgKiBDO1xyXG4gICAgICAgICAgICBjWzhdID0gRSAqIEM7XHJcbiAgICAgICAgICAgIGNbOV0gPSAoQSAqIHUgKiBoIC0gbiAqIHcgKiBoIC0gQSAqIGYgKiByICsgZSAqIHcgKiByICsgbiAqIGYgKiBkIC0gZSAqIHUgKiBkKSAqIEM7XHJcbiAgICAgICAgICAgIGNbMTBdID0gKG0gKiB3ICogaCAtIEEgKiBrICogaCArIEEgKiBmICogcCAtIGUgKiB3ICogcCAtIG0gKiBmICogZCArIGUgKiBrICogZCkgKiBDO1xyXG4gICAgICAgICAgICBjWzExXSA9IChuICogayAqIGggLSBtICogdSAqIGggLSBuICogZiAqIHAgKyBlICogdSAqIHAgKyBtICogZiAqIHIgLSBlICogayAqIHIpICogQztcclxuICAgICAgICAgICAgY1sxMl0gPSBMICogQztcclxuICAgICAgICAgICAgY1sxM10gPSAobiAqIHcgKiBnIC0gQSAqIHUgKiBnICsgQSAqIGYgKiBxIC0gZSAqIHcgKiBxIC0gbiAqIGYgKiB5ICsgZSAqIHUgKiB5KSAqIEM7XHJcbiAgICAgICAgICAgIGNbMTRdID0gKEEgKiBrICogZyAtIG0gKiB3ICogZyAtIEEgKiBmICogbCArIGUgKiB3ICogbCArIG0gKiBmICogeSAtIGUgKiBrICogeSkgKiBDO1xyXG4gICAgICAgICAgICBjWzE1XSA9IChtICogdSAqIGcgLSBuICogayAqIGcgKyBuICogZiAqIGwgLSBlICogdSAqIGwgLSBtICogZiAqIHEgKyBlICogayAqIHEpICogQztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzY2FsZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnRzLCBjID0gYS54LCBkID0gYS55O1xyXG4gICAgICAgICAgICBhID0gYS56O1xyXG4gICAgICAgICAgICBiWzBdICo9IGM7XHJcbiAgICAgICAgICAgIGJbNF0gKj0gZDtcclxuICAgICAgICAgICAgYls4XSAqPSBhO1xyXG4gICAgICAgICAgICBiWzFdICo9IGM7XHJcbiAgICAgICAgICAgIGJbNV0gKj0gZDtcclxuICAgICAgICAgICAgYls5XSAqPSBhO1xyXG4gICAgICAgICAgICBiWzJdICo9IGM7XHJcbiAgICAgICAgICAgIGJbNl0gKj0gZDtcclxuICAgICAgICAgICAgYlsxMF0gKj0gYTtcclxuICAgICAgICAgICAgYlszXSAqPSBjO1xyXG4gICAgICAgICAgICBiWzddICo9IGQ7XHJcbiAgICAgICAgICAgIGJbMTFdICo9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZ2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heChhWzBdICogYVswXSArIGFbMV0gKiBhWzFdICsgYVsyXSAqIGFbMl0sIGFbNF0gKiBhWzRdICsgYVs1XSAqIGFbNV0gKyBhWzZdICogYVs2XSwgYVs4XSAqIGFbOF0gKyBhWzldICogYVs5XSArIGFbMTBdICogYVsxMF0pKVxyXG4gICAgICAgIH0sIG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoMSwgMCwgMCwgYSwgMCwgMSwgMCwgYiwgMCwgMCwgMSwgYywgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBNYXRoLmNvcyhhKTtcclxuICAgICAgICAgICAgYSA9IE1hdGguc2luKGEpO1xyXG4gICAgICAgICAgICB0aGlzLnNldCgxLCAwLCAwLCAwLCAwLCBiLCAtYSwgMCwgMCwgYSwgYiwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBNYXRoLmNvcyhhKTtcclxuICAgICAgICAgICAgYSA9IE1hdGguc2luKGEpO1xyXG4gICAgICAgICAgICB0aGlzLnNldChiLCAwLCBhLCAwLCAwLCAxLCAwLCAwLCAtYSwgMCwgYiwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBNYXRoLmNvcyhhKTtcclxuICAgICAgICAgICAgYSA9IE1hdGguc2luKGEpO1xyXG4gICAgICAgICAgICB0aGlzLnNldChiLCAtYSwgMCwgMCwgYSwgYiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhiKSwgZCA9IE1hdGguc2luKGIpLCBlID0gMSAtIGMsIGYgPSBhLngsIGcgPSBhLnksIGggPSBhLnosIG0gPSBlICogZiwgayA9IGUgKiBnO1xyXG4gICAgICAgICAgICB0aGlzLnNldChtICogZiArIGMsIG0gKiBnIC0gZCAqIGgsIG0gKiBoICsgZCAqIGcsIDAsIG0gKiBnICsgZCAqIGgsIGsgKiBnICsgYywgayAqIGggLSBkICogZiwgMCwgbSAqIGggLSBkICogZywgayAqIGggKyBkICogZiwgZSAqIGggKiBoICsgYywgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZVNjYWxlOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB0aGlzLnNldChhLCAwLCAwLCAwLCAwLCBiLCAwLCAwLCAwLCAwLCBjLCAwLCAwLCAwLCAwLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtYWtlU2hlYXI6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KDEsIGIsIGMsIDAsIGEsIDEsIGMsIDAsIGEsIGIsIDEsIDAsIDAsIDAsIDAsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvbXBvc2U6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oYik7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUoYyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oYSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBiO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBxLCBiID0gbmV3IFMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLmVsZW1lbnRzLCBnID0gYS5zZXQoZlswXSwgZlsxXSwgZlsyXSkubGVuZ3RoKCksIGggPSBhLnNldChmWzRdLCBmWzVdLCBmWzZdKS5sZW5ndGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBtID0gYS5zZXQoZls4XSwgZls5XSwgZlsxMF0pLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgMCA+IHRoaXMuZGV0ZXJtaW5hbnQoKSAmJiAoZyA9IC1nKTtcclxuICAgICAgICAgICAgICAgIGMueCA9IGZbMTJdO1xyXG4gICAgICAgICAgICAgICAgYy55ID0gZlsxM107XHJcbiAgICAgICAgICAgICAgICBjLnogPSBmWzE0XTtcclxuICAgICAgICAgICAgICAgIGIuZWxlbWVudHMuc2V0KHRoaXMuZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgYyA9IDEgLyBnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSAxIC8gaCwgayA9IDEgLyBtO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1swXSAqPSBjO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1sxXSAqPSBjO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1syXSAqPSBjO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1s0XSAqPSBmO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1s1XSAqPSBmO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1s2XSAqPSBmO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1s4XSAqPSBrO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1s5XSAqPSBrO1xyXG4gICAgICAgICAgICAgICAgYi5lbGVtZW50c1sxMF0gKj0gaztcclxuICAgICAgICAgICAgICAgIGQuc2V0RnJvbVJvdGF0aW9uTWF0cml4KGIpO1xyXG4gICAgICAgICAgICAgICAgZS54ID0gZztcclxuICAgICAgICAgICAgICAgIGUueSA9IGg7XHJcbiAgICAgICAgICAgICAgICBlLnogPSBtO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgbWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGYgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLm1ha2VQZXJzcGVjdGl2ZSgpIGhhcyBiZWVuIHJlZGVmaW5lZCBhbmQgaGFzIGEgbmV3IHNpZ25hdHVyZS4gUGxlYXNlIGNoZWNrIHRoZSBkb2NzLlwiKTtcclxuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBnWzBdID0gMiAqIGUgLyAoYiAtIGEpO1xyXG4gICAgICAgICAgICBnWzRdID0gMDtcclxuICAgICAgICAgICAgZ1s4XSA9IChiICsgYSkgLyAoYiAtIGEpO1xyXG4gICAgICAgICAgICBnWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGdbMV0gPSAwO1xyXG4gICAgICAgICAgICBnWzVdID0gMiAqIGUgLyAoYyAtIGQpO1xyXG4gICAgICAgICAgICBnWzldID0gKGMgKyBkKSAvIChjIC0gZCk7XHJcbiAgICAgICAgICAgIGdbMTNdID0gMDtcclxuICAgICAgICAgICAgZ1syXSA9IDA7XHJcbiAgICAgICAgICAgIGdbNl0gPSAwO1xyXG4gICAgICAgICAgICBnWzEwXSA9IC0oZiArIGUpIC8gKGYgLSBlKTtcclxuICAgICAgICAgICAgZ1sxNF0gPSAtMiAqIGYgKiBlIC8gKGYgLSBlKTtcclxuICAgICAgICAgICAgZ1szXSA9IDA7XHJcbiAgICAgICAgICAgIGdbN10gPSAwO1xyXG4gICAgICAgICAgICBnWzExXSA9IC0xO1xyXG4gICAgICAgICAgICBnWzE1XSA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmVsZW1lbnRzLCBoID0gMSAvIChiIC0gYSksIG0gPSAxIC8gKGMgLSBkKSwgayA9IDEgLyAoZiAtIGUpO1xyXG4gICAgICAgICAgICBnWzBdID1cclxuICAgICAgICAgICAgICAgIDIgKiBoO1xyXG4gICAgICAgICAgICBnWzRdID0gMDtcclxuICAgICAgICAgICAgZ1s4XSA9IDA7XHJcbiAgICAgICAgICAgIGdbMTJdID0gLSgoYiArIGEpICogaCk7XHJcbiAgICAgICAgICAgIGdbMV0gPSAwO1xyXG4gICAgICAgICAgICBnWzVdID0gMiAqIG07XHJcbiAgICAgICAgICAgIGdbOV0gPSAwO1xyXG4gICAgICAgICAgICBnWzEzXSA9IC0oKGMgKyBkKSAqIG0pO1xyXG4gICAgICAgICAgICBnWzJdID0gMDtcclxuICAgICAgICAgICAgZ1s2XSA9IDA7XHJcbiAgICAgICAgICAgIGdbMTBdID0gLTIgKiBrO1xyXG4gICAgICAgICAgICBnWzE0XSA9IC0oKGYgKyBlKSAqIGspO1xyXG4gICAgICAgICAgICBnWzNdID0gMDtcclxuICAgICAgICAgICAgZ1s3XSA9IDA7XHJcbiAgICAgICAgICAgIGdbMTFdID0gMDtcclxuICAgICAgICAgICAgZ1sxNV0gPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGVxdWFsczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBhID0gYS5lbGVtZW50cztcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IDE2ID4gYzsgYysrKWlmIChiW2NdICE9PSBhW2NdKXJldHVybiAhMTtcclxuICAgICAgICAgICAgcmV0dXJuICEwXHJcbiAgICAgICAgfSwgZnJvbUFycmF5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAwKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IDE2ID4gYzsgYysrKXRoaXMuZWxlbWVudHNbY10gPSBhW2MgKyBiXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0b0FycmF5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBbXSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGFbYl0gPSBjWzBdO1xyXG4gICAgICAgICAgICBhW2IgKyAxXSA9IGNbMV07XHJcbiAgICAgICAgICAgIGFbYiArIDJdID0gY1syXTtcclxuICAgICAgICAgICAgYVtiICsgM10gPSBjWzNdO1xyXG4gICAgICAgICAgICBhW2IgKyA0XSA9IGNbNF07XHJcbiAgICAgICAgICAgIGFbYiArIDVdID0gY1s1XTtcclxuICAgICAgICAgICAgYVtiICsgNl0gPSBjWzZdO1xyXG4gICAgICAgICAgICBhW2IgKyA3XSA9IGNbN107XHJcbiAgICAgICAgICAgIGFbYiArIDhdID0gY1s4XTtcclxuICAgICAgICAgICAgYVtiICsgOV0gPSBjWzldO1xyXG4gICAgICAgICAgICBhW2IgKyAxMF0gPSBjWzEwXTtcclxuICAgICAgICAgICAgYVtiICsgMTFdID0gY1sxMV07XHJcbiAgICAgICAgICAgIGFbYiArIDEyXSA9IGNbMTJdO1xyXG4gICAgICAgICAgICBhW2IgKyAxM10gPSBjWzEzXTtcclxuICAgICAgICAgICAgYVtiICsgMTRdID0gY1sxNF07XHJcbiAgICAgICAgICAgIGFbYiArIDE1XSA9IGNbMTVdO1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBaYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGVhLnByb3RvdHlwZSk7XHJcbiAgICBaYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBaYTtcclxuICAgIFphLnByb3RvdHlwZS5pc0N1YmVUZXh0dXJlID0gITA7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWmEucHJvdG90eXBlLCBcImltYWdlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlXHJcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlID0gYVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIEVlID0gbmV3IGVhLCBGZSA9IG5ldyBaYSwgQmUgPSBbXSwgRGUgPSBbXTtcclxuICAgIEplLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYyA9IHRoaXMuc2VxLCBkID0gMCwgZSA9IGMubGVuZ3RoOyBkICE9PSBlOyArK2QpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBjW2RdO1xyXG4gICAgICAgICAgICBmLnNldFZhbHVlKGEsXHJcbiAgICAgICAgICAgICAgICBiW2YuaWRdKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgUmQgPSAvKFtcXHdcXGRfXSspKFxcXSk/KFxcW3xcXC4pPy9nO1xyXG4gICAgJGEucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICBiID0gdGhpcy5tYXBbYl07XHJcbiAgICAgICAgdm9pZCAwICE9PSBiICYmIGIuc2V0VmFsdWUoYSwgYywgdGhpcy5yZW5kZXJlcilcclxuICAgIH07XHJcbiAgICAkYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICB2YXIgZCA9IHRoaXMubWFwW2NdO1xyXG4gICAgICAgIHZvaWQgMCAhPT0gZCAmJiBkLnNldFZhbHVlKGEsIGJbY10sIHRoaXMucmVuZGVyZXIpXHJcbiAgICB9O1xyXG4gICAgJGEucHJvdG90eXBlLnNldE9wdGlvbmFsID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICBiID0gYltjXTtcclxuICAgICAgICB2b2lkIDAgIT09IGIgJiYgdGhpcy5zZXRWYWx1ZShhLCBjLCBiKVxyXG4gICAgfTtcclxuICAgICRhLnVwbG9hZCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIGYgPSBiLmxlbmd0aDsgZSAhPT0gZjsgKytlKSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gYltlXSwgaCA9IGNbZy5pZF07XHJcbiAgICAgICAgICAgICExICE9PSBoLm5lZWRzVXBkYXRlICYmIGcuc2V0VmFsdWUoYSwgaC52YWx1ZSwgZClcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgJGEuc2VxV2l0aFZhbHVlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBmb3IgKHZhciBjID0gW10sIGQgPSAwLCBlID0gYS5sZW5ndGg7IGQgIT09XHJcbiAgICAgICAgZTsgKytkKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gYVtkXTtcclxuICAgICAgICAgICAgZi5pZCBpbiBiICYmIGMucHVzaChmKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY1xyXG4gICAgfTtcclxuICAgIHZhciBKYSA9IHtcclxuICAgICAgICBtZXJnZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IHt9LCBjID0gMDsgYyA8IGEubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5jbG9uZShhW2NdKSwgZTtcclxuICAgICAgICAgICAgICAgIGZvciAoZSBpbiBkKWJbZV0gPSBkW2VdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB7fSwgYztcclxuICAgICAgICAgICAgZm9yIChjIGluIGEpIHtcclxuICAgICAgICAgICAgICAgIGJbY10gPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgaW4gYVtjXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gYVtjXVtkXTtcclxuICAgICAgICAgICAgICAgICAgICBlICYmIChlLmlzQ29sb3IgfHwgZS5pc01hdHJpeDMgfHwgZS5pc01hdHJpeDQgfHwgZS5pc1ZlY3RvcjIgfHwgZS5pc1ZlY3RvcjMgfHwgZS5pc1ZlY3RvcjQgfHwgZS5pc1RleHR1cmUpID8gYltjXVtkXSA9IGUuY2xvbmUoKSA6IEFycmF5LmlzQXJyYXkoZSkgPyBiW2NdW2RdID0gZS5zbGljZSgpIDogYltjXVtkXSA9IGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYlxyXG4gICAgICAgIH1cclxuICAgIH0sIFogPSB7XHJcbiAgICAgICAgYWxwaGFtYXBfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgYWxwaGFtYXBfcGFyc19mcmFnbWVudDogXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgYWxwaGF0ZXN0X2ZyYWdtZW50OiBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBhb21hcF9mcmFnbWVudDogXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFx0ZmxvYXQgYW1iaWVudE9jY2x1c2lvbiA9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKVxcblxcdFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICo9IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggZG90TlYsIGFtYmllbnRPY2NsdXNpb24sIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgYW9tYXBfcGFyc19mcmFnbWVudDogXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG4jZW5kaWZcIixcclxuICAgICAgICBiZWdpbl92ZXJ0ZXg6IFwiXFxudmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XFxuXCIsXHJcbiAgICAgICAgYmVnaW5ub3JtYWxfdmVydGV4OiBcIlxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuXCIsXHJcbiAgICAgICAgYnNkZnM6IFwiZmxvYXQgcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggY29uc3QgaW4gZmxvYXQgbGlnaHREaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxuXFx0XFx0aWYoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuI2lmIGRlZmluZWQgKCBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTIClcXG5cXHRcXHRcXHRmbG9hdCBkaXN0YW5jZUZhbGxvZmYgPSAxLjAgLyBtYXgoIHBvdyggbGlnaHREaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApLCAwLjAxICk7XFxuXFx0XFx0XFx0ZmxvYXQgbWF4RGlzdGFuY2VDdXRvZmZGYWN0b3IgPSBwb3cyKCBzYXR1cmF0ZSggMS4wIC0gcG93NCggbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICkgKSApO1xcblxcdFxcdFxcdHJldHVybiBkaXN0YW5jZUZhbGxvZmYgKiBtYXhEaXN0YW5jZUN1dG9mZkZhY3RvcjtcXG4jZWxzZVxcblxcdFxcdFxcdHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG4jZW5kaWZcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDEuMDtcXG59XFxudmVjMyBCUkRGX0RpZmZ1c2VfTGFtYmVydCggY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IgKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxufVxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IGRvdExIICkge1xcblxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC01LjU1NDczICogZG90TEggLSA2Ljk4MzE2ICkgKiBkb3RMSCApO1xcblxcdHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIGZyZXNuZWwgKyBzcGVjdWxhckNvbG9yO1xcbn1cXG5mbG9hdCBHX0dHWF9TbWl0aCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZ2wgPSBkb3ROTCArIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcblxcdGZsb2F0IGd2ID0gZG90TlYgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXG5cXHRyZXR1cm4gMS4wIC8gKCBnbCAqIGd2ICk7XFxufVxcbmZsb2F0IEdfR0dYX1NtaXRoQ29ycmVsYXRlZCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xcblxcdGZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXG5cXHRyZXR1cm4gMC41IC8gbWF4KCBndiArIGdsLCBFUFNJTE9OICk7XFxufVxcbmZsb2F0IERfR0dYKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGRlbm9tID0gcG93MiggZG90TkggKSAqICggYTIgLSAxLjAgKSArIDEuMDtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gcG93MiggZGVub20gKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKyBnZW9tZXRyeS52aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24sIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cXHRmbG9hdCBHID0gR19HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXG59XFxudmVjMiBsdGNUZXh0dXJlQ29vcmRzKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgID0gNjQuMDtcXG5cXHRjb25zdCBmbG9hdCBMVVRfU0NBTEUgPSAoTFVUX1NJWkUgLSAxLjApL0xVVF9TSVpFO1xcblxcdGNvbnN0IGZsb2F0IExVVF9CSUFTICA9IDAuNS9MVVRfU0laRTtcXG5cXHR2ZWMzIE4gPSBnZW9tZXRyeS5ub3JtYWw7XFxuXFx0dmVjMyBWID0gZ2VvbWV0cnkudmlld0RpcjtcXG5cXHR2ZWMzIFAgPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRmbG9hdCB0aGV0YSA9IGFjb3MoIGRvdCggTiwgViApICk7XFxuXFx0dmVjMiB1diA9IHZlYzIoXFxuXFx0XFx0c3FydCggc2F0dXJhdGUoIHJvdWdobmVzcyApICksXFxuXFx0XFx0c2F0dXJhdGUoIHRoZXRhIC8gKCAwLjUgKiBQSSApICkgKTtcXG5cXHR1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7XFxuXFx0cmV0dXJuIHV2O1xcbn1cXG52b2lkIGNsaXBRdWFkVG9Ib3Jpem9uKCBpbm91dCB2ZWMzIExbNV0sIG91dCBpbnQgbiApIHtcXG5cXHRpbnQgY29uZmlnID0gMDtcXG5cXHRpZiAoIExbMF0ueiA+IDAuMCApIGNvbmZpZyArPSAxO1xcblxcdGlmICggTFsxXS56ID4gMC4wICkgY29uZmlnICs9IDI7XFxuXFx0aWYgKCBMWzJdLnogPiAwLjAgKSBjb25maWcgKz0gNDtcXG5cXHRpZiAoIExbM10ueiA+IDAuMCApIGNvbmZpZyArPSA4O1xcblxcdG4gPSAwO1xcblxcdGlmICggY29uZmlnID09IDAgKSB7XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDEgKSB7XFxuXFx0XFx0biA9IDM7XFxuXFx0XFx0TFsxXSA9IC1MWzFdLnogKiBMWzBdICsgTFswXS56ICogTFsxXTtcXG5cXHRcXHRMWzJdID0gLUxbM10ueiAqIExbMF0gKyBMWzBdLnogKiBMWzNdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSAyICkge1xcblxcdFxcdG4gPSAzO1xcblxcdFxcdExbMF0gPSAtTFswXS56ICogTFsxXSArIExbMV0ueiAqIExbMF07XFxuXFx0XFx0TFsyXSA9IC1MWzJdLnogKiBMWzFdICsgTFsxXS56ICogTFsyXTtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gMyApIHtcXG5cXHRcXHRuID0gNDtcXG5cXHRcXHRMWzJdID0gLUxbMl0ueiAqIExbMV0gKyBMWzFdLnogKiBMWzJdO1xcblxcdFxcdExbM10gPSAtTFszXS56ICogTFswXSArIExbMF0ueiAqIExbM107XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDQgKSB7XFxuXFx0XFx0biA9IDM7XFxuXFx0XFx0TFswXSA9IC1MWzNdLnogKiBMWzJdICsgTFsyXS56ICogTFszXTtcXG5cXHRcXHRMWzFdID0gLUxbMV0ueiAqIExbMl0gKyBMWzJdLnogKiBMWzFdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSA1ICkge1xcblxcdFxcdG4gPSAwO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSA2ICkge1xcblxcdFxcdG4gPSA0O1xcblxcdFxcdExbMF0gPSAtTFswXS56ICogTFsxXSArIExbMV0ueiAqIExbMF07XFxuXFx0XFx0TFszXSA9IC1MWzNdLnogKiBMWzJdICsgTFsyXS56ICogTFszXTtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gNyApIHtcXG5cXHRcXHRuID0gNTtcXG5cXHRcXHRMWzRdID0gLUxbM10ueiAqIExbMF0gKyBMWzBdLnogKiBMWzNdO1xcblxcdFxcdExbM10gPSAtTFszXS56ICogTFsyXSArIExbMl0ueiAqIExbM107XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDggKSB7XFxuXFx0XFx0biA9IDM7XFxuXFx0XFx0TFswXSA9IC1MWzBdLnogKiBMWzNdICsgTFszXS56ICogTFswXTtcXG5cXHRcXHRMWzFdID0gLUxbMl0ueiAqIExbM10gKyBMWzNdLnogKiBMWzJdO1xcblxcdFxcdExbMl0gPSAgTFszXTtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gOSApIHtcXG5cXHRcXHRuID0gNDtcXG5cXHRcXHRMWzFdID0gLUxbMV0ueiAqIExbMF0gKyBMWzBdLnogKiBMWzFdO1xcblxcdFxcdExbMl0gPSAtTFsyXS56ICogTFszXSArIExbM10ueiAqIExbMl07XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDEwICkge1xcblxcdFxcdG4gPSAwO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSAxMSApIHtcXG5cXHRcXHRuID0gNTtcXG5cXHRcXHRMWzRdID0gTFszXTtcXG5cXHRcXHRMWzNdID0gLUxbMl0ueiAqIExbM10gKyBMWzNdLnogKiBMWzJdO1xcblxcdFxcdExbMl0gPSAtTFsyXS56ICogTFsxXSArIExbMV0ueiAqIExbMl07XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDEyICkge1xcblxcdFxcdG4gPSA0O1xcblxcdFxcdExbMV0gPSAtTFsxXS56ICogTFsyXSArIExbMl0ueiAqIExbMV07XFxuXFx0XFx0TFswXSA9IC1MWzBdLnogKiBMWzNdICsgTFszXS56ICogTFswXTtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gMTMgKSB7XFxuXFx0XFx0biA9IDU7XFxuXFx0XFx0TFs0XSA9IExbM107XFxuXFx0XFx0TFszXSA9IExbMl07XFxuXFx0XFx0TFsyXSA9IC1MWzFdLnogKiBMWzJdICsgTFsyXS56ICogTFsxXTtcXG5cXHRcXHRMWzFdID0gLUxbMV0ueiAqIExbMF0gKyBMWzBdLnogKiBMWzFdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSAxNCApIHtcXG5cXHRcXHRuID0gNTtcXG5cXHRcXHRMWzRdID0gLUxbMF0ueiAqIExbM10gKyBMWzNdLnogKiBMWzBdO1xcblxcdFxcdExbMF0gPSAtTFswXS56ICogTFsxXSArIExbMV0ueiAqIExbMF07XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDE1ICkge1xcblxcdFxcdG4gPSA0O1xcblxcdH1cXG5cXHRpZiAoIG4gPT0gMyApXFxuXFx0XFx0TFszXSA9IExbMF07XFxuXFx0aWYgKCBuID09IDQgKVxcblxcdFxcdExbNF0gPSBMWzBdO1xcbn1cXG5mbG9hdCBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3RFZGdlKCB2ZWMzIHYxLCB2ZWMzIHYyICkge1xcblxcdGZsb2F0IGNvc1RoZXRhID0gZG90KCB2MSwgdjIgKTtcXG5cXHRmbG9hdCB0aGV0YSA9IGFjb3MoIGNvc1RoZXRhICk7XFxuXFx0ZmxvYXQgcmVzID0gY3Jvc3MoIHYxLCB2MiApLnogKiAoICggdGhldGEgPiAwLjAwMSApID8gdGhldGEgLyBzaW4oIHRoZXRhICkgOiAxLjAgKTtcXG5cXHRyZXR1cm4gcmVzO1xcbn1cXG52b2lkIGluaXRSZWN0UG9pbnRzKCBjb25zdCBpbiB2ZWMzIHBvcywgY29uc3QgaW4gdmVjMyBoYWxmV2lkdGgsIGNvbnN0IGluIHZlYzMgaGFsZkhlaWdodCwgb3V0IHZlYzMgcmVjdFBvaW50c1s0XSApIHtcXG5cXHRyZWN0UG9pbnRzWzBdID0gcG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXG5cXHRyZWN0UG9pbnRzWzFdID0gcG9zICsgaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXG5cXHRyZWN0UG9pbnRzWzJdID0gcG9zICsgaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXG5cXHRyZWN0UG9pbnRzWzNdID0gcG9zIC0gaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXG59XFxudmVjMyBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3QoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIG1hdDMgYnJkZk1hdCwgY29uc3QgaW4gdmVjMyByZWN0UG9pbnRzWzRdICkge1xcblxcdHZlYzMgTiA9IGdlb21ldHJ5Lm5vcm1hbDtcXG5cXHR2ZWMzIFYgPSBnZW9tZXRyeS52aWV3RGlyO1xcblxcdHZlYzMgUCA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdHZlYzMgVDEsIFQyO1xcblxcdFQxID0gbm9ybWFsaXplKFYgLSBOICogZG90KCBWLCBOICkpO1xcblxcdFQyID0gLSBjcm9zcyggTiwgVDEgKTtcXG5cXHRtYXQzIGJyZGZXcnRTdXJmYWNlID0gYnJkZk1hdCAqIHRyYW5zcG9zZSggbWF0MyggVDEsIFQyLCBOICkgKTtcXG5cXHR2ZWMzIGNsaXBwZWRSZWN0WzVdO1xcblxcdGNsaXBwZWRSZWN0WzBdID0gYnJkZldydFN1cmZhY2UgKiAoIHJlY3RQb2ludHNbMF0gLSBQICk7XFxuXFx0Y2xpcHBlZFJlY3RbMV0gPSBicmRmV3J0U3VyZmFjZSAqICggcmVjdFBvaW50c1sxXSAtIFAgKTtcXG5cXHRjbGlwcGVkUmVjdFsyXSA9IGJyZGZXcnRTdXJmYWNlICogKCByZWN0UG9pbnRzWzJdIC0gUCApO1xcblxcdGNsaXBwZWRSZWN0WzNdID0gYnJkZldydFN1cmZhY2UgKiAoIHJlY3RQb2ludHNbM10gLSBQICk7XFxuXFx0aW50IG47XFxuXFx0Y2xpcFF1YWRUb0hvcml6b24oY2xpcHBlZFJlY3QsIG4pO1xcblxcdGlmICggbiA9PSAwIClcXG5cXHRcXHRyZXR1cm4gdmVjMyggMCwgMCwgMCApO1xcblxcdGNsaXBwZWRSZWN0WzBdID0gbm9ybWFsaXplKCBjbGlwcGVkUmVjdFswXSApO1xcblxcdGNsaXBwZWRSZWN0WzFdID0gbm9ybWFsaXplKCBjbGlwcGVkUmVjdFsxXSApO1xcblxcdGNsaXBwZWRSZWN0WzJdID0gbm9ybWFsaXplKCBjbGlwcGVkUmVjdFsyXSApO1xcblxcdGNsaXBwZWRSZWN0WzNdID0gbm9ybWFsaXplKCBjbGlwcGVkUmVjdFszXSApO1xcblxcdGNsaXBwZWRSZWN0WzRdID0gbm9ybWFsaXplKCBjbGlwcGVkUmVjdFs0XSApO1xcblxcdGZsb2F0IHN1bSA9IDAuMDtcXG5cXHRzdW0gKz0gaW50ZWdyYXRlTHRjQnJkZk92ZXJSZWN0RWRnZSggY2xpcHBlZFJlY3RbMF0sIGNsaXBwZWRSZWN0WzFdICk7XFxuXFx0c3VtICs9IGludGVncmF0ZUx0Y0JyZGZPdmVyUmVjdEVkZ2UoIGNsaXBwZWRSZWN0WzFdLCBjbGlwcGVkUmVjdFsyXSApO1xcblxcdHN1bSArPSBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3RFZGdlKCBjbGlwcGVkUmVjdFsyXSwgY2xpcHBlZFJlY3RbM10gKTtcXG5cXHRpZiAobiA+PSA0KVxcblxcdFxcdHN1bSArPSBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3RFZGdlKCBjbGlwcGVkUmVjdFszXSwgY2xpcHBlZFJlY3RbNF0gKTtcXG5cXHRpZiAobiA9PSA1KVxcblxcdFxcdHN1bSArPSBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3RFZGdlKCBjbGlwcGVkUmVjdFs0XSwgY2xpcHBlZFJlY3RbMF0gKTtcXG5cXHRzdW0gPSBtYXgoIDAuMCwgc3VtICk7XFxuXFx0dmVjMyBMb19pID0gdmVjMyggc3VtLCBzdW0sIHN1bSApO1xcblxcdHJldHVybiBMb19pO1xcbn1cXG52ZWMzIFJlY3RfQXJlYV9MaWdodF9TcGVjdWxhcl9SZWZsZWN0YW5jZShcXG5cXHRcXHRjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LFxcblxcdFxcdGNvbnN0IGluIHZlYzMgbGlnaHRQb3MsIGNvbnN0IGluIHZlYzMgbGlnaHRIYWxmV2lkdGgsIGNvbnN0IGluIHZlYzMgbGlnaHRIYWxmSGVpZ2h0LFxcblxcdFxcdGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyxcXG5cXHRcXHRjb25zdCBpbiBzYW1wbGVyMkQgbHRjTWF0LCBjb25zdCBpbiBzYW1wbGVyMkQgbHRjTWFnICkge1xcblxcdHZlYzMgcmVjdFBvaW50c1s0XTtcXG5cXHRpbml0UmVjdFBvaW50cyggbGlnaHRQb3MsIGxpZ2h0SGFsZldpZHRoLCBsaWdodEhhbGZIZWlnaHQsIHJlY3RQb2ludHMgKTtcXG5cXHR2ZWMyIHV2ID0gbHRjVGV4dHVyZUNvb3JkcyggZ2VvbWV0cnksIHJvdWdobmVzcyApO1xcblxcdHZlYzQgYnJkZkx0Y0FwcHJveFBhcmFtcywgdDtcXG5cXHRicmRmTHRjQXBwcm94UGFyYW1zID0gdGV4dHVyZTJEKCBsdGNNYXQsIHV2ICk7XFxuXFx0dCA9IHRleHR1cmUyRCggbHRjTWF0LCB1diApO1xcblxcdGZsb2F0IGJyZGZMdGNTY2FsYXIgPSB0ZXh0dXJlMkQoIGx0Y01hZywgdXYgKS5hO1xcblxcdG1hdDMgYnJkZkx0Y0FwcHJveE1hdCA9IG1hdDMoXFxuXFx0XFx0dmVjMyggICAxLCAgIDAsIHQueSApLFxcblxcdFxcdHZlYzMoICAgMCwgdC56LCAgIDAgKSxcXG5cXHRcXHR2ZWMzKCB0LncsICAgMCwgdC54IClcXG5cXHQpO1xcblxcdHZlYzMgc3BlY3VsYXJSZWZsZWN0YW5jZSA9IGludGVncmF0ZUx0Y0JyZGZPdmVyUmVjdCggZ2VvbWV0cnksIGJyZGZMdGNBcHByb3hNYXQsIHJlY3RQb2ludHMgKTtcXG5cXHRzcGVjdWxhclJlZmxlY3RhbmNlICo9IGJyZGZMdGNTY2FsYXI7XFxuXFx0cmV0dXJuIHNwZWN1bGFyUmVmbGVjdGFuY2U7XFxufVxcbnZlYzMgUmVjdF9BcmVhX0xpZ2h0X0RpZmZ1c2VfUmVmbGVjdGFuY2UoXFxuXFx0XFx0Y29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSxcXG5cXHRcXHRjb25zdCBpbiB2ZWMzIGxpZ2h0UG9zLCBjb25zdCBpbiB2ZWMzIGxpZ2h0SGFsZldpZHRoLCBjb25zdCBpbiB2ZWMzIGxpZ2h0SGFsZkhlaWdodCApIHtcXG5cXHR2ZWMzIHJlY3RQb2ludHNbNF07XFxuXFx0aW5pdFJlY3RQb2ludHMoIGxpZ2h0UG9zLCBsaWdodEhhbGZXaWR0aCwgbGlnaHRIYWxmSGVpZ2h0LCByZWN0UG9pbnRzICk7XFxuXFx0bWF0MyBkaWZmdXNlQnJkZk1hdCA9IG1hdDMoMSk7XFxuXFx0dmVjMyBkaWZmdXNlUmVmbGVjdGFuY2UgPSBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3QoIGdlb21ldHJ5LCBkaWZmdXNlQnJkZk1hdCwgcmVjdFBvaW50cyApO1xcblxcdHJldHVybiBkaWZmdXNlUmVmbGVjdGFuY2U7XFxufVxcbnZlYzMgQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRjb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTtcXG5cXHRjb25zdCB2ZWM0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcXG5cXHR2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcblxcdGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55O1xcblxcdHZlYzIgQUIgPSB2ZWMyKCAtMS4wNCwgMS4wNCApICogYTAwNCArIHIuenc7XFxuXFx0cmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBBQi54ICsgQUIueTtcXG59XFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHtcXG5cXHRyZXR1cm4gMC4yNTtcXG59XFxuZmxvYXQgRF9CbGlublBob25nKCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKTtcXG5cXHRmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxuXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufVxcbmZsb2F0IEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggY29uc3QgaW4gZmxvYXQgZ2d4Um91Z2huZXNzICkge1xcblxcdHJldHVybiAoIDIuMCAvIHBvdzIoIGdneFJvdWdobmVzcyArIDAuMDAwMSApIC0gMi4wICk7XFxufVxcbmZsb2F0IEJsaW5uRXhwb25lbnRUb0dHWFJvdWdobmVzcyggY29uc3QgaW4gZmxvYXQgYmxpbm5FeHBvbmVudCApIHtcXG5cXHRyZXR1cm4gc3FydCggMi4wIC8gKCBibGlubkV4cG9uZW50ICsgMi4wICkgKTtcXG59XFxuXCIsXHJcbiAgICAgICAgYnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFx0dmVjMiBkSGR4eV9md2QoKSB7XFxuXFx0XFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblxcdFxcdHZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcXG5cXHRcXHRmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxuXFx0XFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXFx0XFx0ZmxvYXQgZEJ5ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeSApLnggLSBIbGw7XFxuXFx0XFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxuXFx0fVxcblxcdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFx0XFx0dmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcXG5cXHRcXHR2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1xcblxcdFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblxcdFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXHRcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OiBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgKysgaSApIHtcXG5cXHRcXHR2ZWM0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRpZiAoIGRvdCggdlZpZXdQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDtcXG5cXHR9XFxuXFx0XFx0XFxuXFx0I2lmIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyA8IE5VTV9DTElQUElOR19QTEFORVNcXG5cXHRcXHRib29sIGNsaXBwZWQgPSB0cnVlO1xcblxcdFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgKysgaSApIHtcXG5cXHRcXHRcXHR2ZWM0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRcXHRjbGlwcGVkID0gKCBkb3QoIHZWaWV3UG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApICYmIGNsaXBwZWQ7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggY2xpcHBlZCApIGRpc2NhcmQ7XFxuXFx0XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ6IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0I2lmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg6IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwICYmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBjbGlwcGluZ19wbGFuZXNfdmVydGV4OiBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMCAmJiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgY29sb3JfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcbiNlbmRpZlwiLFxyXG4gICAgICAgIGNvbG9yX3BhcnNfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgY29sb3JfcGFyc192ZXJ0ZXg6IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXCIsXHJcbiAgICAgICAgY29sb3JfdmVydGV4OiBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcbiNlbmRpZlwiLFxyXG4gICAgICAgIGNvbW1vbjogXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE4XFxuI2RlZmluZSBQSV9IQUxGIDEuNTcwNzk2MzI2Nzk0OVxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSSAwLjMxODMwOTg4NjE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0XFxuI2RlZmluZSBMT0cyIDEuNDQyNjk1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG4jZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2RlZmluZSB3aGl0ZUNvbXBsaW1lbnQoYSkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxuZmxvYXQgcG93MyggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeCp4OyB9XFxuZmxvYXQgcG93NCggY29uc3QgaW4gZmxvYXQgeCApIHsgZmxvYXQgeDIgPSB4Kng7IHJldHVybiB4Mip4MjsgfVxcbmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgY29sb3IgKSB7IHJldHVybiBkb3QoIGNvbG9yLCB2ZWMzKCAwLjMzMzMgKSApOyB9XFxuaGlnaHAgZmxvYXQgcmFuZCggY29uc3QgaW4gdmVjMiB1diApIHtcXG5cXHRjb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7XFxuXFx0aGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7XFxuXFx0cmV0dXJuIGZyYWN0KHNpbihzbikgKiBjKTtcXG59XFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0Ym9vbCB2aXNpYmxlO1xcbn07XFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxufTtcXG5zdHJ1Y3QgR2VvbWV0cmljQ29udGV4dCB7XFxuXFx0dmVjMyBwb3NpdGlvbjtcXG5cXHR2ZWMzIG5vcm1hbDtcXG5cXHR2ZWMzIHZpZXdEaXI7XFxufTtcXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xcbn1cXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG59XFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXHRmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxuXFx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcbn1cXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFx0cmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXG59XFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFx0cmV0dXJuIGxpbmVEaXJlY3Rpb24gKiAoIGRvdCggcGxhbmVOb3JtYWwsIHBvaW50T25QbGFuZSAtIHBvaW50T25MaW5lICkgLyBkb3QoIHBsYW5lTm9ybWFsLCBsaW5lRGlyZWN0aW9uICkgKSArIHBvaW50T25MaW5lO1xcbn1cXG5tYXQzIHRyYW5zcG9zZSggY29uc3QgaW4gbWF0MyB2ICkge1xcblxcdG1hdDMgdG1wO1xcblxcdHRtcFswXSA9IHZlYzModlswXS54LCB2WzFdLngsIHZbMl0ueCk7XFxuXFx0dG1wWzFdID0gdmVjMyh2WzBdLnksIHZbMV0ueSwgdlsyXS55KTtcXG5cXHR0bXBbMl0gPSB2ZWMzKHZbMF0ueiwgdlsxXS56LCB2WzJdLnopO1xcblxcdHJldHVybiB0bXA7XFxufVxcblwiLFxyXG4gICAgICAgIGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDogXCIjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVlxcbiNkZWZpbmUgY3ViZVVWX3RleHR1cmVTaXplICgxMDI0LjApXFxuaW50IGdldEZhY2VGcm9tRGlyZWN0aW9uKHZlYzMgZGlyZWN0aW9uKSB7XFxuXFx0dmVjMyBhYnNEaXJlY3Rpb24gPSBhYnMoZGlyZWN0aW9uKTtcXG5cXHRpbnQgZmFjZSA9IC0xO1xcblxcdGlmKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkge1xcblxcdFxcdGlmKGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueCA+IDAuMCA/IDAgOiAzO1xcblxcdFxcdGVsc2VcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxIDogNDtcXG5cXHR9XFxuXFx0ZWxzZSB7XFxuXFx0XFx0aWYoYWJzRGlyZWN0aW9uLnogPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi56ID4gMC4wID8gMiA6IDU7XFxuXFx0XFx0ZWxzZVxcblxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEgOiA0O1xcblxcdH1cXG5cXHRyZXR1cm4gZmFjZTtcXG59XFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczEgIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDEuMClcXG4jZGVmaW5lIGN1YmVVVl9yYW5nZUNsYW1wIChleHAyKCg2LjAgLSAxLjApICogMi4wKSlcXG52ZWMyIE1pcExldmVsSW5mbyggdmVjMyB2ZWMsIGZsb2F0IHJvdWdobmVzc0xldmVsLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgc2NhbGUgPSBleHAyKGN1YmVVVl9tYXhMb2RzMSAtIHJvdWdobmVzc0xldmVsKTtcXG5cXHRmbG9hdCBkeFJvdWdobmVzcyA9IGRGZHgocm91Z2huZXNzKTtcXG5cXHRmbG9hdCBkeVJvdWdobmVzcyA9IGRGZHkocm91Z2huZXNzKTtcXG5cXHR2ZWMzIGR4ID0gZEZkeCggdmVjICogc2NhbGUgKiBkeFJvdWdobmVzcyApO1xcblxcdHZlYzMgZHkgPSBkRmR5KCB2ZWMgKiBzY2FsZSAqIGR5Um91Z2huZXNzICk7XFxuXFx0ZmxvYXQgZCA9IG1heCggZG90KCBkeCwgZHggKSwgZG90KCBkeSwgZHkgKSApO1xcblxcdGQgPSBjbGFtcChkLCAxLjAsIGN1YmVVVl9yYW5nZUNsYW1wKTtcXG5cXHRmbG9hdCBtaXBMZXZlbCA9IDAuNSAqIGxvZzIoZCk7XFxuXFx0cmV0dXJuIHZlYzIoZmxvb3IobWlwTGV2ZWwpLCBmcmFjdChtaXBMZXZlbCkpO1xcbn1cXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMiAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAyLjApXFxuI2RlZmluZSBjdWJlVVZfcmNwVGV4dHVyZVNpemUgKDEuMCAvIGN1YmVVVl90ZXh0dXJlU2l6ZSlcXG52ZWMyIGdldEN1YmVVVih2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgcm91Z2huZXNzTGV2ZWwsIGZsb2F0IG1pcExldmVsKSB7XFxuXFx0bWlwTGV2ZWwgPSByb3VnaG5lc3NMZXZlbCA+IGN1YmVVVl9tYXhMb2RzMiAtIDMuMCA/IDAuMCA6IG1pcExldmVsO1xcblxcdGZsb2F0IGEgPSAxNi4wICogY3ViZVVWX3JjcFRleHR1cmVTaXplO1xcblxcdHZlYzIgZXhwMl9wYWNrZWQgPSBleHAyKCB2ZWMyKCByb3VnaG5lc3NMZXZlbCwgbWlwTGV2ZWwgKSApO1xcblxcdHZlYzIgcmNwX2V4cDJfcGFja2VkID0gdmVjMiggMS4wICkgLyBleHAyX3BhY2tlZDtcXG5cXHRmbG9hdCBwb3dTY2FsZSA9IGV4cDJfcGFja2VkLnggKiBleHAyX3BhY2tlZC55O1xcblxcdGZsb2F0IHNjYWxlID0gcmNwX2V4cDJfcGFja2VkLnggKiByY3BfZXhwMl9wYWNrZWQueSAqIDAuMjU7XFxuXFx0ZmxvYXQgbWlwT2Zmc2V0ID0gMC43NSooMS4wIC0gcmNwX2V4cDJfcGFja2VkLnkpICogcmNwX2V4cDJfcGFja2VkLng7XFxuXFx0Ym9vbCBiUmVzID0gbWlwTGV2ZWwgPT0gMC4wO1xcblxcdHNjYWxlID0gIGJSZXMgJiYgKHNjYWxlIDwgYSkgPyBhIDogc2NhbGU7XFxuXFx0dmVjMyByO1xcblxcdHZlYzIgb2Zmc2V0O1xcblxcdGludCBmYWNlID0gZ2V0RmFjZUZyb21EaXJlY3Rpb24oZGlyZWN0aW9uKTtcXG5cXHRmbG9hdCByY3BQb3dTY2FsZSA9IDEuMCAvIHBvd1NjYWxlO1xcblxcdGlmKCBmYWNlID09IDApIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueCwgLWRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSk7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigwLjArbWlwT2Zmc2V0LDAuNzUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAxKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueik7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNzUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAyKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSk7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigyLjAqc2NhbGUrbWlwT2Zmc2V0LCAwLjc1ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyBhIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2UgaWYoIGZhY2UgPT0gMykge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkpO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoMC4wK21pcE9mZnNldCwwLjUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IDAuMCA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIGlmKCBmYWNlID09IDQpIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngsIC1kaXJlY3Rpb24ueik7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2Uge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi56LCAtZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDIuMCpzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdHIgPSBub3JtYWxpemUocik7XFxuXFx0ZmxvYXQgdGV4ZWxPZmZzZXQgPSAwLjUgKiBjdWJlVVZfcmNwVGV4dHVyZVNpemU7XFxuXFx0dmVjMiBzID0gKCByLnl6IC8gYWJzKCByLnggKSArIHZlYzIoIDEuMCApICkgKiAwLjU7XFxuXFx0dmVjMiBiYXNlID0gb2Zmc2V0ICsgdmVjMiggdGV4ZWxPZmZzZXQgKTtcXG5cXHRyZXR1cm4gYmFzZSArIHMgKiAoIHNjYWxlIC0gMi4wICogdGV4ZWxPZmZzZXQgKTtcXG59XFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczMgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMy4wKVxcbnZlYzQgdGV4dHVyZUN1YmVVVih2ZWMzIHJlZmxlY3RlZERpcmVjdGlvbiwgZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IHJvdWdobmVzc1ZhbCA9IHJvdWdobmVzcyogY3ViZVVWX21heExvZHMzO1xcblxcdGZsb2F0IHIxID0gZmxvb3Iocm91Z2huZXNzVmFsKTtcXG5cXHRmbG9hdCByMiA9IHIxICsgMS4wO1xcblxcdGZsb2F0IHQgPSBmcmFjdChyb3VnaG5lc3NWYWwpO1xcblxcdHZlYzIgbWlwSW5mbyA9IE1pcExldmVsSW5mbyhyZWZsZWN0ZWREaXJlY3Rpb24sIHIxLCByb3VnaG5lc3MpO1xcblxcdGZsb2F0IHMgPSBtaXBJbmZvLnk7XFxuXFx0ZmxvYXQgbGV2ZWwwID0gbWlwSW5mby54O1xcblxcdGZsb2F0IGxldmVsMSA9IGxldmVsMCArIDEuMDtcXG5cXHRsZXZlbDEgPSBsZXZlbDEgPiA1LjAgPyA1LjAgOiBsZXZlbDE7XFxuXFx0bGV2ZWwwICs9IG1pbiggZmxvb3IoIHMgKyAwLjUgKSwgNS4wICk7XFxuXFx0dmVjMiB1dl8xMCA9IGdldEN1YmVVVihyZWZsZWN0ZWREaXJlY3Rpb24sIHIxLCBsZXZlbDApO1xcblxcdHZlYzQgY29sb3IxMCA9IGVudk1hcFRleGVsVG9MaW5lYXIodGV4dHVyZTJEKGVudk1hcCwgdXZfMTApKTtcXG5cXHR2ZWMyIHV2XzIwID0gZ2V0Q3ViZVVWKHJlZmxlY3RlZERpcmVjdGlvbiwgcjIsIGxldmVsMCk7XFxuXFx0dmVjNCBjb2xvcjIwID0gZW52TWFwVGV4ZWxUb0xpbmVhcih0ZXh0dXJlMkQoZW52TWFwLCB1dl8yMCkpO1xcblxcdHZlYzQgcmVzdWx0ID0gbWl4KGNvbG9yMTAsIGNvbG9yMjAsIHQpO1xcblxcdHJldHVybiB2ZWM0KHJlc3VsdC5yZ2IsIDEuMCk7XFxufVxcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIGRlZmF1bHRub3JtYWxfdmVydGV4OiBcIiNpZmRlZiBGTElQX1NJREVEXFxuXFx0b2JqZWN0Tm9ybWFsID0gLW9iamVjdE5vcm1hbDtcXG4jZW5kaWZcXG52ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcblwiLFxyXG4gICAgICAgIGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleDogXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgZW1pc3NpdmVtYXBfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdiApO1xcblxcdGVtaXNzaXZlQ29sb3IucmdiID0gZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyKCBlbWlzc2l2ZUNvbG9yICkucmdiO1xcblxcdHRvdGFsRW1pc3NpdmVSYWRpYW5jZSAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBlbmNvZGluZ3NfZnJhZ21lbnQ6IFwiICBnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcXG5cIixcclxuICAgICAgICBlbmNvZGluZ3NfcGFyc19mcmFnbWVudDogXCJcXG52ZWM0IExpbmVhclRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2YWx1ZTtcXG59XFxudmVjNCBHYW1tYVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBnYW1tYUZhY3RvciApIHtcXG5cXHRyZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1xcbn1cXG52ZWM0IExpbmVhclRvR2FtbWEoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcblxcdHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnh5eiwgdmVjMyggMS4wIC8gZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS53ICk7XFxufVxcbnZlYzQgc1JHQlRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIHZhbHVlLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHZhbHVlLncgKTtcXG59XFxudmVjNCBMaW5lYXJUb3NSR0IoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IsIHZlYzMoIDAuNDE2NjYgKSApICogMS4wNTUgLSB2ZWMzKCAwLjA1NSApLCB2YWx1ZS5yZ2IgKiAxMi45MiwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjAwMzEzMDggKSApICkgKSwgdmFsdWUudyApO1xcbn1cXG52ZWM0IFJHQkVUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogZXhwMiggdmFsdWUuYSAqIDI1NS4wIC0gMTI4LjAgKSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JFKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdGZsb2F0IG1heENvbXBvbmVudCA9IG1heCggbWF4KCB2YWx1ZS5yLCB2YWx1ZS5nICksIHZhbHVlLmIgKTtcXG5cXHRmbG9hdCBmRXhwID0gY2xhbXAoIGNlaWwoIGxvZzIoIG1heENvbXBvbmVudCApICksIC0xMjguMCwgMTI3LjAgKTtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gZXhwMiggZkV4cCApLCAoIGZFeHAgKyAxMjguMCApIC8gMjU1LjAgKTtcXG59XFxudmVjNCBSR0JNVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS54eXogKiB2YWx1ZS53ICogbWF4UmFuZ2UsIDEuMCApO1xcbn1cXG52ZWM0IExpbmVhclRvUkdCTSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0ZmxvYXQgbWF4UkdCID0gbWF4KCB2YWx1ZS54LCBtYXgoIHZhbHVlLmcsIHZhbHVlLmIgKSApO1xcblxcdGZsb2F0IE0gICAgICA9IGNsYW1wKCBtYXhSR0IgLyBtYXhSYW5nZSwgMC4wLCAxLjAgKTtcXG5cXHRNICAgICAgICAgICAgPSBjZWlsKCBNICogMjU1LjAgKSAvIDI1NS4wO1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyAoIE0gKiBtYXhSYW5nZSApLCBNICk7XFxufVxcbnZlYzQgUkdCRFRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogKCAoIG1heFJhbmdlIC8gMjU1LjAgKSAvIHZhbHVlLmEgKSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JEKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLngsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxuXFx0ZmxvYXQgRCAgICAgID0gbWF4KCBtYXhSYW5nZSAvIG1heFJHQiwgMS4wICk7XFxuXFx0RCAgICAgICAgICAgID0gbWluKCBmbG9vciggRCApIC8gMjU1LjAsIDEuMCApO1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoIEQgKiAoIDI1NS4wIC8gbWF4UmFuZ2UgKSApLCBEICk7XFxufVxcbmNvbnN0IG1hdDMgY0xvZ0x1dk0gPSBtYXQzKCAwLjIyMDksIDAuMzM5MCwgMC40MTg0LCAwLjExMzgsIDAuNjc4MCwgMC43MzE5LCAwLjAxMDIsIDAuMTEzMCwgMC4yOTY5ICk7XFxudmVjNCBMaW5lYXJUb0xvZ0x1diggaW4gdmVjNCB2YWx1ZSApICB7XFxuXFx0dmVjMyBYcF9ZX1hZWnAgPSB2YWx1ZS5yZ2IgKiBjTG9nTHV2TTtcXG5cXHRYcF9ZX1hZWnAgPSBtYXgoWHBfWV9YWVpwLCB2ZWMzKDFlLTYsIDFlLTYsIDFlLTYpKTtcXG5cXHR2ZWM0IHZSZXN1bHQ7XFxuXFx0dlJlc3VsdC54eSA9IFhwX1lfWFlacC54eSAvIFhwX1lfWFlacC56O1xcblxcdGZsb2F0IExlID0gMi4wICogbG9nMihYcF9ZX1hZWnAueSkgKyAxMjcuMDtcXG5cXHR2UmVzdWx0LncgPSBmcmFjdChMZSk7XFxuXFx0dlJlc3VsdC56ID0gKExlIC0gKGZsb29yKHZSZXN1bHQudyoyNTUuMCkpLzI1NS4wKS8yNTUuMDtcXG5cXHRyZXR1cm4gdlJlc3VsdDtcXG59XFxuY29uc3QgbWF0MyBjTG9nTHV2SW52ZXJzZU0gPSBtYXQzKCA2LjAwMTQsIC0yLjcwMDgsIC0xLjc5OTYsIC0xLjMzMjAsIDMuMTAyOSwgLTUuNzcyMSwgMC4zMDA4LCAtMS4wODgyLCA1LjYyNjggKTtcXG52ZWM0IExvZ0x1dlRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdGZsb2F0IExlID0gdmFsdWUueiAqIDI1NS4wICsgdmFsdWUudztcXG5cXHR2ZWMzIFhwX1lfWFlacDtcXG5cXHRYcF9ZX1hZWnAueSA9IGV4cDIoKExlIC0gMTI3LjApIC8gMi4wKTtcXG5cXHRYcF9ZX1hZWnAueiA9IFhwX1lfWFlacC55IC8gdmFsdWUueTtcXG5cXHRYcF9ZX1hZWnAueCA9IHZhbHVlLnggKiBYcF9ZX1hZWnAuejtcXG5cXHR2ZWMzIHZSR0IgPSBYcF9ZX1hZWnAucmdiICogY0xvZ0x1dkludmVyc2VNO1xcblxcdHJldHVybiB2ZWM0KCBtYXgodlJHQiwgMC4wKSwgMS4wICk7XFxufVxcblwiLFxyXG4gICAgICAgIGVudm1hcF9mcmFnbWVudDogXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG5cXHRcXHR2ZWMyIHNhbXBsZVVWO1xcblxcdFxcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblxcdFxcdHNhbXBsZVVWLnggPSBhdGFuKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy56LCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWaWV3ID0gZmxpcE5vcm1hbCAqIG5vcm1hbGl6ZSggKCB2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkgKS54eXogKyB2ZWMzKCAwLjAsIDAuMCwgMS4wICkgKTtcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41ICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0I2VuZGlmXFxuXFx0ZW52Q29sb3IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZDb2xvciApO1xcblxcdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXFx0XFx0b3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIGVudm1hcF9wYXJzX2ZyYWdtZW50OiBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhZU0lDQUwgKVxcblxcdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcblxcdHVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zaXR5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAoIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgKVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBQSFlTSUNBTCApXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgZW52bWFwX3BhcnNfdmVydGV4OiBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgZW52bWFwX3ZlcnRleDogXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgZm9nX3ZlcnRleDogXCJcXG4jaWZkZWYgVVNFX0ZPR1xcbmZvZ0RlcHRoID0gLW12UG9zaXRpb24uejtcXG4jZW5kaWZcIixcclxuICAgICAgICBmb2dfcGFyc192ZXJ0ZXg6IFwiI2lmZGVmIFVTRV9GT0dcXG4gIHZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgZm9nX2ZyYWdtZW50OiBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gd2hpdGVDb21wbGltZW50KCBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZm9nRGVwdGggKiBmb2dEZXB0aCAqIExPRzIgKSApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBmb2dEZXB0aCApO1xcblxcdCNlbmRpZlxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBmb2dfcGFyc19mcmFnbWVudDogXCIjaWZkZWYgVVNFX0ZPR1xcblxcdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cXHR2YXJ5aW5nIGZsb2F0IGZvZ0RlcHRoO1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OiBcIiNpZmRlZiBUT09OXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnRNYXA7XFxuXFx0dmVjMyBnZXRHcmFkaWVudElycmFkaWFuY2UoIHZlYzMgbm9ybWFsLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uICkge1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7XFxuXFx0XFx0dmVjMiBjb29yZCA9IHZlYzIoIGRvdE5MICogMC41ICsgMC41LCAwLjAgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX0dSQURJRU5UTUFQXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRCggZ3JhZGllbnRNYXAsIGNvb3JkICkucmdiO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuICggY29vcmQueCA8IDAuNyApID8gdmVjMyggMC43ICkgOiB2ZWMzKCAxLjAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgbGlnaHRtYXBfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBQSSAqIHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcbiNlbmRpZlwiLFxyXG4gICAgICAgIGxpZ2h0c19sYW1iZXJ0X3ZlcnRleDogXCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHR2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG5mbG9hdCBkb3ROTDtcXG52ZWMzIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgYmFja0dlb21ldHJ5ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIGxpZ2h0c19wYXJzOiBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG52ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG59XFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdGludCBzaGFkb3c7XFxuXFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdH07XFxuXFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgKSB7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0LmNvbG9yO1xcblxcdFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbmFsTGlnaHQuZGlyZWN0aW9uO1xcblxcdFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSB0cnVlO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgUG9pbnRMaWdodCB7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdGZsb2F0IGRpc3RhbmNlO1xcblxcdFxcdGZsb2F0IGRlY2F5O1xcblxcdFxcdGludCBzaGFkb3c7XFxuXFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdH07XFxuXFx0dW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gUG9pbnRMaWdodCBwb2ludExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gcG9pbnRMaWdodC5jb2xvcjtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlLCBwb2ludExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9ICggZGlyZWN0TGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0XFx0ZmxvYXQgY29uZUNvcztcXG5cXHRcXHRmbG9hdCBwZW51bWJyYUNvcztcXG5cXHRcXHRpbnQgc2hhZG93O1xcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBhbmdsZUNvcyA9IGRvdCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0aWYgKCBhbmdsZUNvcyA+IHNwb3RMaWdodC5jb25lQ29zICkge1xcblxcdFxcdFxcdGZsb2F0IHNwb3RFZmZlY3QgPSBzbW9vdGhzdGVwKCBzcG90TGlnaHQuY29uZUNvcywgc3BvdExpZ2h0LnBlbnVtYnJhQ29zLCBhbmdsZUNvcyApO1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gc3BvdExpZ2h0LmNvbG9yO1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IHNwb3RFZmZlY3QgKiBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBsaWdodERpc3RhbmNlLCBzcG90TGlnaHQuZGlzdGFuY2UsIHNwb3RMaWdodC5kZWNheSApO1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSB0cnVlO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gZmFsc2U7XFxuXFx0XFx0fVxcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFJlY3RBcmVhTGlnaHQge1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aDtcXG5cXHRcXHR2ZWMzIGhhbGZIZWlnaHQ7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNNYXQ7XFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjTWFnO1xcblxcdHVuaWZvcm0gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0c1sgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgXTtcXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblxcdHN0cnVjdCBIZW1pc3BoZXJlTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgc2t5Q29sb3I7XFxuXFx0XFx0dmVjMyBncm91bmRDb2xvcjtcXG5cXHR9O1xcblxcdHVuaWZvcm0gSGVtaXNwaGVyZUxpZ2h0IGhlbWlzcGhlcmVMaWdodHNbIE5VTV9IRU1JX0xJR0hUUyBdO1xcblxcdHZlYzMgZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gSGVtaXNwaGVyZUxpZ2h0IGhlbWlMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSApIHtcXG5cXHRcXHRmbG9hdCBkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3ROTCArIDAuNTtcXG5cXHRcXHR2ZWMzIGlycmFkaWFuY2UgPSBtaXgoIGhlbWlMaWdodC5ncm91bmRDb2xvciwgaGVtaUxpZ2h0LnNreUNvbG9yLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcdFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmV0dXJuIGlycmFkaWFuY2U7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKVxcblxcdHZlYzMgZ2V0TGlnaHRQcm9iZUluZGlyZWN0SXJyYWRpYW5jZSggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBnZW9tZXRyeS5ub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdFxcdHZlYzMgcXVlcnlWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogd29ybGROb3JtYWwueCwgd29ybGROb3JtYWwueXogKTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlTG9kRVhUKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdFxcdHZlYzMgcXVlcnlWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogd29ybGROb3JtYWwueCwgd29ybGROb3JtYWwueXogKTtcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggcXVlcnlWZWMsIDEuMCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHZlYzQoIDAuMCApO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdHJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0U3BlY3VsYXJNSVBMZXZlbCggY29uc3QgaW4gZmxvYXQgYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcblxcdFxcdGZsb2F0IG1heE1JUExldmVsU2NhbGFyID0gZmxvYXQoIG1heE1JUExldmVsICk7XFxuXFx0XFx0ZmxvYXQgZGVzaXJlZE1JUExldmVsID0gbWF4TUlQTGV2ZWxTY2FsYXIgLSAwLjc5MjQ4IC0gMC41ICogbG9nMiggcG93MiggYmxpbm5TaGluaW5lc3NFeHBvbmVudCApICsgMS4wICk7XFxuXFx0XFx0cmV0dXJuIGNsYW1wKCBkZXNpcmVkTUlQTGV2ZWwsIDAuMCwgbWF4TUlQTGV2ZWxTY2FsYXIgKTtcXG5cXHR9XFxuXFx0dmVjMyBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gZmxvYXQgYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRmbG9hdCBzcGVjdWxhck1JUExldmVsID0gZ2V0U3BlY3VsYXJNSVBMZXZlbCggYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgbWF4TUlQTGV2ZWwgKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdFxcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApO1xcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVJlZmxlY3RWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICk7XFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYocXVlcnlSZWZsZWN0VmVjLCBCbGlubkV4cG9uZW50VG9HR1hSb3VnaG5lc3MoYmxpbm5TaGluaW5lc3NFeHBvbmVudCkpO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcblxcdFxcdFxcdHZlYzIgc2FtcGxlVVY7XFxuXFx0XFx0XFx0c2FtcGxlVVYueSA9IHNhdHVyYXRlKCByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cXHRcXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggcmVmbGVjdFZlYy56LCByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJETG9kRVhUKCBlbnZNYXAsIHNhbXBsZVVWLCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWLCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWaWV3ID0gbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSApLnh5eiArIHZlYzMoIDAuMCwwLjAsMS4wICkgKTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0fVxcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIGxpZ2h0c19waG9uZ19mcmFnbWVudDogXCJCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5tYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gc3BlY3VsYXI7XFxubWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7XFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XFxuXCIsXHJcbiAgICAgICAgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwge1xcblxcdHZlYzNcXHRkaWZmdXNlQ29sb3I7XFxuXFx0dmVjM1xcdHNwZWN1bGFyQ29sb3I7XFxuXFx0ZmxvYXRcXHRzcGVjdWxhclNoaW5pbmVzcztcXG5cXHRmbG9hdFxcdHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxuXFx0dm9pZCBSRV9EaXJlY3RfUmVjdEFyZWFfQmxpbm5QaG9uZyggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdFxcdHZlYzMgbWF0RGlmZkNvbG9yID0gbWF0ZXJpYWwuZGlmZnVzZUNvbG9yO1xcblxcdFxcdHZlYzMgbWF0U3BlY0NvbG9yID0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvcjtcXG5cXHRcXHR2ZWMzIGxpZ2h0Q29sb3IgICA9IHJlY3RBcmVhTGlnaHQuY29sb3I7XFxuXFx0XFx0ZmxvYXQgcm91Z2huZXNzID0gQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApO1xcblxcdFxcdHZlYzMgc3BlYyA9IFJlY3RfQXJlYV9MaWdodF9TcGVjdWxhcl9SZWZsZWN0YW5jZShcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeSxcXG5cXHRcXHRcXHRcXHRyZWN0QXJlYUxpZ2h0LnBvc2l0aW9uLCByZWN0QXJlYUxpZ2h0LmhhbGZXaWR0aCwgcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0LFxcblxcdFxcdFxcdFxcdHJvdWdobmVzcyxcXG5cXHRcXHRcXHRcXHRsdGNNYXQsIGx0Y01hZyApO1xcblxcdFxcdHZlYzMgZGlmZiA9IFJlY3RfQXJlYV9MaWdodF9EaWZmdXNlX1JlZmxlY3RhbmNlKFxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LFxcblxcdFxcdFxcdFxcdHJlY3RBcmVhTGlnaHQucG9zaXRpb24sIHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoLCByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogbWF0U3BlY0NvbG9yICogc3BlYyAvIFBJMjtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICArPSBsaWdodENvbG9yICogbWF0RGlmZkNvbG9yICogZGlmZiAvIFBJMjtcXG5cXHR9XFxuI2VuZGlmXFxudm9pZCBSRV9EaXJlY3RfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHQjaWZkZWYgVE9PTlxcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEdyYWRpZW50SXJyYWRpYW5jZSggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0XFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHQjZW5kaWZcXG5cXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcXG4jZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYVxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYV9CbGlublBob25nXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZ1xcbiNkZWZpbmUgTWF0ZXJpYWxfTGlnaHRQcm9iZUxPRCggbWF0ZXJpYWwgKVxcdCgwKVxcblwiLFxyXG4gICAgICAgIGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudDogXCJQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIHJvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wICk7XFxuI2lmZGVmIFNUQU5EQVJEXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG4jZWxzZVxcblxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKiBwb3cyKCByZWZsZWN0aXZpdHkgKSApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHRtYXRlcmlhbC5jbGVhckNvYXQgPSBzYXR1cmF0ZSggY2xlYXJDb2F0ICk7XFx0bWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0gY2xhbXAoIGNsZWFyQ29hdFJvdWdobmVzcywgMC4wNCwgMS4wICk7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcblxcdHZlYzNcXHRkaWZmdXNlQ29sb3I7XFxuXFx0ZmxvYXRcXHRzcGVjdWxhclJvdWdobmVzcztcXG5cXHR2ZWMzXFx0c3BlY3VsYXJDb2xvcjtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0O1xcblxcdFxcdGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXG5cXHQjZW5kaWZcXG59O1xcbiNkZWZpbmUgTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjE2XFxuI2RlZmluZSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UIDAuMDRcXG5mbG9hdCBjbGVhckNvYXRESFJBcHByb3goIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkwgKSB7XFxuXFx0cmV0dXJuIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKyAoIDEuMCAtIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSAqICggcG93KCAxLjAgLSBkb3ROTCwgNS4wICkgKiBwb3coIDEuMCAtIHJvdWdobmVzcywgMi4wICkgKTtcXG59XFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHZvaWQgUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsKCBjb25zdCBpbiBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdFxcdHZlYzMgbWF0RGlmZkNvbG9yID0gbWF0ZXJpYWwuZGlmZnVzZUNvbG9yO1xcblxcdFxcdHZlYzMgbWF0U3BlY0NvbG9yID0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvcjtcXG5cXHRcXHR2ZWMzIGxpZ2h0Q29sb3IgICA9IHJlY3RBcmVhTGlnaHQuY29sb3I7XFxuXFx0XFx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyBzcGVjID0gUmVjdF9BcmVhX0xpZ2h0X1NwZWN1bGFyX1JlZmxlY3RhbmNlKFxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LFxcblxcdFxcdFxcdFxcdHJlY3RBcmVhTGlnaHQucG9zaXRpb24sIHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoLCByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQsXFxuXFx0XFx0XFx0XFx0cm91Z2huZXNzLFxcblxcdFxcdFxcdFxcdGx0Y01hdCwgbHRjTWFnICk7XFxuXFx0XFx0dmVjMyBkaWZmID0gUmVjdF9BcmVhX0xpZ2h0X0RpZmZ1c2VfUmVmbGVjdGFuY2UoXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnksXFxuXFx0XFx0XFx0XFx0cmVjdEFyZWFMaWdodC5wb3NpdGlvbiwgcmVjdEFyZWFMaWdodC5oYWxmV2lkdGgsIHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodCApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGxpZ2h0Q29sb3IgKiBtYXRTcGVjQ29sb3IgKiBzcGVjO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgICs9IGxpZ2h0Q29sb3IgKiBtYXREaWZmQ29sb3IgKiBkaWZmO1xcblxcdH1cXG4jZW5kaWZcXG52b2lkIFJFX0RpcmVjdF9QaHlzaWNhbCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdCNlbmRpZlxcblxcdCNpZm5kZWYgU1RBTkRBUkRcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSBtYXRlcmlhbC5jbGVhckNvYXQgKiBjbGVhckNvYXRESFJBcHByb3goIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcywgZG90TkwgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IDAuMDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogaXJyYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfR0dYKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIG1hdGVyaWFsLmNsZWFyQ29hdCAqIEJSREZfU3BlY3VsYXJfR0dYKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdCNpZm5kZWYgU1RBTkRBUkRcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3ROVjtcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSBtYXRlcmlhbC5jbGVhckNvYXQgKiBjbGVhckNvYXRESFJBcHByb3goIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcywgZG90TkwgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IDAuMDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiByYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSBjbGVhckNvYXRSYWRpYW5jZSAqIG1hdGVyaWFsLmNsZWFyQ29hdCAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYVxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyXFx0XFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxcbiNkZWZpbmUgTWF0ZXJpYWxfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSAgIEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKVxcbiNkZWZpbmUgTWF0ZXJpYWxfQ2xlYXJDb2F0X0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICkgICBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApXFxuZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7XFxufVxcblwiLFxyXG4gICAgICAgIGxpZ2h0c190ZW1wbGF0ZTogXCJcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbDtcXG5nZW9tZXRyeS52aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG4jaWYgKCBOVU1fUE9JTlRfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIHBvaW50TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggcG9pbnRMaWdodC5zaGFkb3csIGRpcmVjdExpZ2h0LnZpc2libGUgKSApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBzcG90TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodElycmFkaWFuY2UoIGRpcmVjdGlvbmFsTGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3csIGRpcmVjdExpZ2h0LnZpc2libGUgKSApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdF9SZWN0QXJlYSApXFxuXFx0UmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9SRUNUX0FSRUFfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHJlY3RBcmVhTGlnaHQgPSByZWN0QXJlYUxpZ2h0c1sgaSBdO1xcblxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYSggcmVjdEFyZWFMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRcXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXHRcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRcXHRsaWdodE1hcElycmFkaWFuY2UgKj0gUEk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0aXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7XFxuXFx0I2VuZGlmXFxuXFx0I2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApXFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdFxcdGlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblxcdFxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0aXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBnZW9tZXRyeSwgOCApO1xcblxcdCNlbmRpZlxcblxcdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0dmVjMyByYWRpYW5jZSA9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeSwgTWF0ZXJpYWxfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSwgOCApO1xcblxcdCNpZm5kZWYgU1RBTkRBUkRcXG5cXHRcXHR2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LCBNYXRlcmlhbF9DbGVhckNvYXRfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSwgOCApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBjbGVhckNvYXRSYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcblxcdCNlbmRpZlxcblxcdFJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBjbGVhckNvYXRSYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIGxvZ2RlcHRoYnVmX2ZyYWdtZW50OiBcIiNpZiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRikgJiYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUZfRVhUKVxcblxcdGdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIodkZyYWdEZXB0aCkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1xcbiNlbmRpZlwiLFxyXG4gICAgICAgIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcbiNlbmRpZlwiLFxyXG4gICAgICAgIGxvZ2RlcHRoYnVmX3ZlcnRleDogXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0Z2xfUG9zaXRpb24ueiA9IGxvZzIobWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkpICogbG9nRGVwdGhCdWZGQztcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcdFxcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcdCNlbHNlXFxuXFx0XFx0Z2xfUG9zaXRpb24ueiA9IChnbF9Qb3NpdGlvbi56IC0gMS4wKSAqIGdsX1Bvc2l0aW9uLnc7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgbWFwX2ZyYWdtZW50OiBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcdHRleGVsQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhlbENvbG9yICk7XFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgbWFwX3BhcnNfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgbWFwX3BhcnRpY2xlX2ZyYWdtZW50OiBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dmVjNCBtYXBUZXhlbCA9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuXFx0ZGlmZnVzZUNvbG9yICo9IG1hcFRleGVsVG9MaW5lYXIoIG1hcFRleGVsICk7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2VXYgKTtcXG5cXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MucjtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcXG4jZW5kaWZcIixcclxuICAgICAgICBtb3JwaG5vcm1hbF92ZXJ0ZXg6IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OiBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXG5cXHQjZWxzZVxcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsXHJcbiAgICAgICAgbW9ycGh0YXJnZXRfdmVydGV4OiBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDEgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDIgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDYgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgbm9ybWFsX2ZsaXA6IFwiI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuI2Vsc2VcXG5cXHRmbG9hdCBmbGlwTm9ybWFsID0gMS4wO1xcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIG5vcm1hbF9mcmFnbWVudDogXCIjaWZkZWYgRkxBVF9TSEFERURcXG5cXHR2ZWMzIGZkeCA9IHZlYzMoIGRGZHgoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeCggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG4jZWxzZVxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICkgKiBmbGlwTm9ybWFsO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxuXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBub3JtYWxtYXBfcGFyc19mcmFnbWVudDogXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXG5cXHRcXHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cXHRcXHR2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTtcXG5cXHRcXHR2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcblxcdFxcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFx0XFx0dmVjMyBTID0gbm9ybWFsaXplKCBxMCAqIHN0MS50IC0gcTEgKiBzdDAudCApO1xcblxcdFxcdHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxuXFx0XFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXHRcXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdFxcdG1hcE4ueHkgPSBub3JtYWxTY2FsZSAqIG1hcE4ueHk7XFxuXFx0XFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcblxcdH1cXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBwYWNraW5nOiBcInZlYzMgcGFja05vcm1hbFRvUkdCKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCBub3JtYWwgKSAqIDAuNSArIDAuNTtcXG59XFxudmVjMyB1bnBhY2tSR0JUb05vcm1hbCggY29uc3QgaW4gdmVjMyByZ2IgKSB7XFxuXFx0cmV0dXJuIDEuMCAtIDIuMCAqIHJnYi54eXo7XFxufVxcbmNvbnN0IGZsb2F0IFBhY2tVcHNjYWxlID0gMjU2LiAvIDI1NS47Y29uc3QgZmxvYXQgVW5wYWNrRG93bnNjYWxlID0gMjU1LiAvIDI1Ni47XFxuY29uc3QgdmVjMyBQYWNrRmFjdG9ycyA9IHZlYzMoIDI1Ni4gKiAyNTYuICogMjU2LiwgMjU2LiAqIDI1Ni4sICAyNTYuICk7XFxuY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzID0gVW5wYWNrRG93bnNjYWxlIC8gdmVjNCggUGFja0ZhY3RvcnMsIDEuICk7XFxuY29uc3QgZmxvYXQgU2hpZnRSaWdodDggPSAxLiAvIDI1Ni47XFxudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggZnJhY3QoIHYgKiBQYWNrRmFjdG9ycyApLCB2ICk7XFxuXFx0ci55encgLT0gci54eXogKiBTaGlmdFJpZ2h0ODtcXHRyZXR1cm4gciAqIFBhY2tVcHNjYWxlO1xcbn1cXG5mbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkge1xcblxcdHJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnMgKTtcXG59XFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxufVxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gbGluZWFyQ2xpcFogKiAoIG5lYXIgLSBmYXIgKSAtIG5lYXI7XFxufVxcbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCggZmFyIC0gbmVhciApICogdmlld1ogKTtcXG59XFxuZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGludkNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGludkNsaXBaIC0gZmFyICk7XFxufVxcblwiLFxyXG4gICAgICAgIHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6IFwiI2lmZGVmIFBSRU1VTFRJUExJRURfQUxQSEFcXG5cXHRnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIHByb2plY3RfdmVydGV4OiBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1xcbiNlbHNlXFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcbiNlbmRpZlxcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXCIsXHJcbiAgICAgICAgcm91Z2huZXNzbWFwX2ZyYWdtZW50OiBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLnI7XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCIsXHJcbiAgICAgICAgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHBvaW50U2hhZG93TWFwWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuXFx0ZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cXHRcXHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgdGV4dHVyZTJEU2hhZG93TGVycCggc2FtcGxlcjJEIGRlcHRocywgdmVjMiBzaXplLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcblxcdFxcdGNvbnN0IHZlYzIgb2Zmc2V0ID0gdmVjMiggMC4wLCAxLjAgKTtcXG5cXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2l6ZTtcXG5cXHRcXHR2ZWMyIGNlbnRyb2lkVVYgPSBmbG9vciggdXYgKiBzaXplICsgMC41ICkgLyBzaXplO1xcblxcdFxcdGZsb2F0IGxiID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnh4LCBjb21wYXJlICk7XFxuXFx0XFx0ZmxvYXQgbHQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHksIGNvbXBhcmUgKTtcXG5cXHRcXHRmbG9hdCByYiA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC55eCwgY29tcGFyZSApO1xcblxcdFxcdGZsb2F0IHJ0ID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnl5LCBjb21wYXJlICk7XFxuXFx0XFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2l6ZSArIDAuNSApO1xcblxcdFxcdGZsb2F0IGEgPSBtaXgoIGxiLCBsdCwgZi55ICk7XFxuXFx0XFx0ZmxvYXQgYiA9IG1peCggcmIsIHJ0LCBmLnkgKTtcXG5cXHRcXHRmbG9hdCBjID0gbWl4KCBhLCBiLCBmLnggKTtcXG5cXHRcXHRyZXR1cm4gYztcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCApIHtcXG5cXHRcXHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcXG5cXHRcXHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7XFxuXFx0XFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXHRcXHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFx0XFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXG5cXHRcXHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDEuMDtcXG5cXHR9XFxuXFx0dmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkge1xcblxcdFxcdHZlYzMgYWJzViA9IGFicyggdiApO1xcblxcdFxcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xcblxcdFxcdGFic1YgKj0gc2NhbGVUb0N1YmU7XFxuXFx0XFx0diAqPSBzY2FsZVRvQ3ViZSAqICggMS4wIC0gMi4wICogdGV4ZWxTaXplWSApO1xcblxcdFxcdHZlYzIgcGxhbmFyID0gdi54eTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZO1xcblxcdFxcdGZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDtcXG5cXHRcXHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0aWYgKCB2LnogPiAwLjAgKVxcblxcdFxcdFxcdFxcdHBsYW5hci54ID0gNC4wIC0gdi54O1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApO1xcblxcdFxcdFxcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XFxuXFx0XFx0XFx0cGxhbmFyLnkgPSB2LnogKiBzaWduWSAtIDIuMDtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApO1xcblxcdH1cXG5cXHRmbG9hdCBnZXRQb2ludFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7XFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTtcXG5cXHRcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejtcXG5cXHRcXHR2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcdFxcdGZsb2F0IGRwID0gKCBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApIC0gc2hhZG93QmlhcyApIC8gMTAwMC4wO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFx0XFx0XFx0dmVjMiBvZmZzZXQgPSB2ZWMyKCAtIDEsIDEgKSAqIHNoYWRvd1JhZGl1cyAqIHRleGVsU2l6ZS55O1xcblxcdFxcdFxcdHJldHVybiAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh4LCB0ZXhlbFNpemUueSApLCBkcCApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgc2hhZG93bWFwX3BhcnNfdmVydGV4OiBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIHNoYWRvd21hcF92ZXJ0ZXg6IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50OiBcImZsb2F0IGdldFNoYWRvd01hc2soKSB7XFxuXFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcblxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSBib29sKCBzcG90TGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IGJvb2woIHBvaW50TGlnaHQuc2hhZG93ICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNlbmRpZlxcblxcdCNlbmRpZlxcblxcdHJldHVybiBzaGFkb3c7XFxufVxcblwiLFxyXG4gICAgICAgIHNraW5iYXNlX3ZlcnRleDogXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXFx0bWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxuXFx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXFx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuI2VuZGlmXCIsXHJcbiAgICAgICAgc2tpbm5pbmdfcGFyc192ZXJ0ZXg6IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG5cXHRcXHR1bmlmb3JtIGludCBib25lVGV4dHVyZUhlaWdodDtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXFx0XFx0XFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblxcdFxcdFxcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXHRcXHRcXHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXHRcXHRcXHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXHRcXHRcXHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIG1hdDQgYm9uZU1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gYm9uZU1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgc2tpbm5pbmdfdmVydGV4OiBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcblxcdHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIHNraW5ub3JtYWxfdmVydGV4OiBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblxcdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXG4jZW5kaWZcXG5cIixcclxuICAgICAgICBzcGVjdWxhcm1hcF9mcmFnbWVudDogXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcbiNlbHNlXFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIixcclxuICAgICAgICBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OiBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG4jZW5kaWZcIixcclxuICAgICAgICB0b25lbWFwcGluZ19mcmFnbWVudDogXCIjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IFwiI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nV2hpdGVQb2ludDtcXG52ZWMzIExpbmVhclRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdHJldHVybiB0b25lTWFwcGluZ0V4cG9zdXJlICogY29sb3I7XFxufVxcbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgLyAoIHZlYzMoIDEuMCApICsgY29sb3IgKSApO1xcbn1cXG4jZGVmaW5lIFVuY2hhcnRlZDJIZWxwZXIoIHggKSBtYXgoICggKCB4ICogKCAwLjE1ICogeCArIDAuMTAgKiAwLjUwICkgKyAwLjIwICogMC4wMiApIC8gKCB4ICogKCAwLjE1ICogeCArIDAuNTAgKSArIDAuMjAgKiAwLjMwICkgKSAtIDAuMDIgLyAwLjMwLCB2ZWMzKCAwLjAgKSApXFxudmVjMyBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIFVuY2hhcnRlZDJIZWxwZXIoIGNvbG9yICkgLyBVbmNoYXJ0ZWQySGVscGVyKCB2ZWMzKCB0b25lTWFwcGluZ1doaXRlUG9pbnQgKSApICk7XFxufVxcbnZlYzMgT3B0aW1pemVkQ2luZW9uVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRjb2xvciA9IG1heCggdmVjMyggMC4wICksIGNvbG9yIC0gMC4wMDQgKTtcXG5cXHRyZXR1cm4gcG93KCAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDAuNSApICkgLyAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDEuNyApICsgMC4wNiApLCB2ZWMzKCAyLjIgKSApO1xcbn1cXG5cIixcclxuICAgICAgICB1dl9wYXJzX2ZyYWdtZW50OiBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuI2VuZGlmXCIsXHJcbiAgICAgICAgdXZfcGFyc192ZXJ0ZXg6IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcbiNlbmRpZlxcblwiLFxyXG4gICAgICAgIHV2X3ZlcnRleDogXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXG5cXHR2VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcXG4jZW5kaWZcIixcclxuICAgICAgICB1djJfcGFyc19mcmFnbWVudDogXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG4jZW5kaWZcIixcclxuICAgICAgICB1djJfcGFyc192ZXJ0ZXg6IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcbiNlbmRpZlwiLFxyXG4gICAgICAgIHV2Ml92ZXJ0ZXg6IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0dlV2MiA9IHV2MjtcXG4jZW5kaWZcIixcclxuICAgICAgICB3b3JsZHBvc192ZXJ0ZXg6IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIFBIWVNJQ0FMICkgfHwgZGVmaW5lZCggTEFNQkVSVCApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQIClcXG5cXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0XFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCIsXHJcbiAgICAgICAgY3ViZV9mcmFnOiBcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XFxuXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXG59XFxuXCIsXHJcbiAgICAgICAgY3ViZV92ZXJ0OiBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxufVxcblwiLFxyXG4gICAgICAgIGRlcHRoX2ZyYWc6IFwiI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBnbF9GcmFnQ29vcmQueiApLCBvcGFjaXR5ICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBnbF9GcmFnQ29vcmQueiApO1xcblxcdCNlbmRpZlxcbn1cXG5cIixcclxuICAgICAgICBkZXB0aF92ZXJ0OiBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4Plxcbn1cXG5cIixcclxuICAgICAgICBkaXN0YW5jZVJHQkFfZnJhZzogXCJ1bmlmb3JtIHZlYzMgbGlnaHRQb3M7XFxudmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbiAoKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGxlbmd0aCggdldvcmxkUG9zaXRpb24ueHl6IC0gbGlnaHRQb3MueHl6ICkgLyAxMDAwLjAgKTtcXG59XFxuXCIsXHJcbiAgICAgICAgZGlzdGFuY2VSR0JBX3ZlcnQ6IFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcXG59XFxuXCIsXHJcbiAgICAgICAgZXF1aXJlY3RfZnJhZzogXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XFxuXFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIHRGbGlwICogZGlyZWN0aW9uLnkgKiAtMC41ICsgMC41ICk7XFxuXFx0c2FtcGxlVVYueCA9IGF0YW4oIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XFxufVxcblwiLFxyXG4gICAgICAgIGVxdWlyZWN0X3ZlcnQ6IFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG59XFxuXCIsXHJcbiAgICAgICAgbGluZWRhc2hlZF9mcmFnOiBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XFxuXFx0XFx0ZGlzY2FyZDtcXG5cXHR9XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiLFxyXG4gICAgICAgIGxpbmVkYXNoZWRfdmVydDogXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVxcblwiLFxyXG4gICAgICAgIG1lc2hiYXNpY19mcmFnOiBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB2ZWMzKCAxLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcblxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCIsXHJcbiAgICAgICAgbWVzaGJhc2ljX3ZlcnQ6IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XFxuXCIsXHJcbiAgICAgICAgbWVzaGxhbWJlcnRfZnJhZzogXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxuXFx0I2luY2x1ZGUgPGxpZ2h0bWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBCUkRGX0RpZmZ1c2VfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApO1xcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gKCBnbF9Gcm9udEZhY2luZyApID8gdkxpZ2h0RnJvbnQgOiB2TGlnaHRCYWNrO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZMaWdodEZyb250O1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKSAqIGdldFNoYWRvd01hc2soKTtcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiLFxyXG4gICAgICAgIG1lc2hsYW1iZXJ0X3ZlcnQ6IFwiI2RlZmluZSBMQU1CRVJUXFxudmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XFxuXCIsXHJcbiAgICAgICAgbWVzaHBob25nX2ZyYWc6IFwiI2RlZmluZSBQSE9OR1xcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIHZlYzMgc3BlY3VsYXI7XFxudW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mbGlwPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c190ZW1wbGF0ZT5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCIsXHJcbiAgICAgICAgbWVzaHBob25nX3ZlcnQ6IFwiI2RlZmluZSBQSE9OR1xcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVxcblwiLFxyXG4gICAgICAgIG1lc2hwaHlzaWNhbF9mcmFnOiBcIiNkZWZpbmUgUEhZU0lDQUxcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7XFxudW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZm5kZWYgU1RBTkRBUkRcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyQ29hdDtcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXG4jZW5kaWZcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdGVtcGxhdGU+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cXG5cIixcclxuICAgICAgICBtZXNocGh5c2ljYWxfdmVydDogXCIjZGVmaW5lIFBIWVNJQ0FMXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVxcblwiLFxyXG4gICAgICAgIG5vcm1hbF9mcmFnOiBcIiNkZWZpbmUgTk9STUFMXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mbGlwPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCBub3JtYWwgKSwgb3BhY2l0eSApO1xcbn1cXG5cIixcclxuICAgICAgICBub3JtYWxfdmVydDogXCIjZGVmaW5lIE5PUk1BTFxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuI2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcXG59XFxuXCIsXHJcbiAgICAgICAgcG9pbnRzX2ZyYWc6IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCIsXHJcbiAgICAgICAgcG9pbnRzX3ZlcnQ6IFwidW5pZm9ybSBmbG9hdCBzaXplO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXFxuXFx0XFx0Z2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1xcblxcdCNlbHNlXFxuXFx0XFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVxcblwiLFxyXG4gICAgICAgIHNoYWRvd19mcmFnOiBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7XFxufVxcblwiLFxyXG4gICAgICAgIHNoYWRvd192ZXJ0OiBcIiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxufVxcblwiXHJcbiAgICB9O1xyXG4gICAgSi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IEosXHJcbiAgICAgICAgaXNDb2xvcjogITAsIHI6IDEsIGc6IDEsIGI6IDEsIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSAmJiBhLmlzQ29sb3IgPyB0aGlzLmNvcHkoYSkgOiBcIm51bWJlclwiID09PSB0eXBlb2YgYSA/IHRoaXMuc2V0SGV4KGEpIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGEgJiYgdGhpcy5zZXRTdHlsZShhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRTY2FsYXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYiA9IHRoaXMuZyA9IHRoaXMuciA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0SGV4OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gTWF0aC5mbG9vcihhKTtcclxuICAgICAgICAgICAgdGhpcy5yID0gKGEgPj4gMTYgJiAyNTUpIC8gMjU1O1xyXG4gICAgICAgICAgICB0aGlzLmcgPSAoYSA+PiA4ICYgMjU1KSAvIDI1NTtcclxuICAgICAgICAgICAgdGhpcy5iID0gKGEgJiAyNTUpIC8gMjU1O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFJHQjogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gYTtcclxuICAgICAgICAgICAgdGhpcy5nID0gYjtcclxuICAgICAgICAgICAgdGhpcy5iID0gYztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRIU0w6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gYShhLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAwID4gZCAmJiAoZCArPSAxKTtcclxuICAgICAgICAgICAgICAgIDEgPCBkICYmIC0tZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkIDwgMSAvIDYgPyBhICsgNiAqIChjIC0gYSkgKiBkIDogLjUgPiBkID8gYyA6IGQgPCAyIC8gMyA/IGEgKyA2ICogKGMgLSBhKSAqICgyIC8gMyAtIGQpIDogYVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgYiA9IE4uZXVjbGlkZWFuTW9kdWxvKGIsIDEpO1xyXG4gICAgICAgICAgICAgICAgYyA9IE4uY2xhbXAoYywgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICBkID0gTi5jbGFtcChkLCAwLCAxKTtcclxuICAgICAgICAgICAgICAgIDAgPT09IGMgPyB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBkIDogKGMgPSAuNSA+PSBkID8gZCAqICgxICsgYykgOiBkICsgYyAtIGQgKiBjLCBkID0gMiAqIGQgLSBjLCB0aGlzLnIgPSBhKGQsIGMsIGIgKyAxIC8gMyksIHRoaXMuZyA9IGEoZCwgYywgYiksIHRoaXMuYiA9IGEoZCwgYywgYiAtIDEgLyAzKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBzZXRTdHlsZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gYihiKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIgJiYgMSA+IHBhcnNlRmxvYXQoYikgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiBcIiArIGEgKyBcIiB3aWxsIGJlIGlnbm9yZWQuXCIpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICBpZiAoYyA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyhhKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBjWzJdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJnYlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZ2JhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID0gL14oXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyhkKSlyZXR1cm4gdGhpcy5yID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY1sxXSwgMTApKSAvIDI1NSwgdGhpcy5nID0gTWF0aC5taW4oMjU1LCBwYXJzZUludChjWzJdLCAxMCkpIC8gMjU1LCB0aGlzLmIgPSBNYXRoLm1pbigyNTUsIHBhcnNlSW50KGNbM10sIDEwKSkgLyAyNTUsIGIoY1s1XSksIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyhkKSlyZXR1cm4gdGhpcy5yID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjWzFdLCAxMCkpIC8gMTAwLCB0aGlzLmcgPSBNYXRoLm1pbigxMDAsIHBhcnNlSW50KGNbMl0sIDEwKSkgLyAxMDAsIHRoaXMuYiA9IE1hdGgubWluKDEwMCwgcGFyc2VJbnQoY1szXSwgMTApKSAvIDEwMCwgYihjWzVdKSwgdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhzbFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoc2xhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyhkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBwYXJzZUZsb2F0KGNbMV0pIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzNjAsIGUgPSBwYXJzZUludChjWzJdLCAxMCkgLyAxMDAsIGYgPSBwYXJzZUludChjWzNdLCAxMCkgLyAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKGNbNV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0SFNMKGQsIGUsIGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID0gL15cXCMoW0EtRmEtZjAtOV0rKSQvLmV4ZWMoYSkpIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjWzFdO1xyXG4gICAgICAgICAgICAgICAgZCA9IGMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKDMgPT09IGQpcmV0dXJuIHRoaXMuciA9IHBhcnNlSW50KGMuY2hhckF0KDApICsgYy5jaGFyQXQoMCksIDE2KSAvIDI1NSwgdGhpcy5nID0gcGFyc2VJbnQoYy5jaGFyQXQoMSkgKyBjLmNoYXJBdCgxKSwgMTYpIC8gMjU1LCB0aGlzLmIgPSBwYXJzZUludChjLmNoYXJBdCgyKSArIGMuY2hhckF0KDIpLCAxNikgLyAyNTUsIHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoNiA9PT0gZClyZXR1cm4gdGhpcy5yID0gcGFyc2VJbnQoYy5jaGFyQXQoMCkgKyBjLmNoYXJBdCgxKSwgMTYpIC8gMjU1LCB0aGlzLmcgPSBwYXJzZUludChjLmNoYXJBdCgyKSArIGMuY2hhckF0KDMpLCAxNikgLyAyNTUsIHRoaXMuYiA9IHBhcnNlSW50KGMuY2hhckF0KDQpICsgYy5jaGFyQXQoNSksIDE2KSAvIDI1NSwgdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGEgJiYgMCA8IGEubGVuZ3RoICYmIChjID0gV2ZbYV0sIHZvaWQgMCAhPT1cclxuICAgICAgICAgICAgYyA/IHRoaXMuc2V0SGV4KGMpIDogY29uc29sZS53YXJuKFwiVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgXCIgKyBhKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gYS5yO1xyXG4gICAgICAgICAgICB0aGlzLmcgPSBhLmc7XHJcbiAgICAgICAgICAgIHRoaXMuYiA9IGEuYjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMik7XHJcbiAgICAgICAgICAgIHRoaXMuciA9IE1hdGgucG93KGEuciwgYik7XHJcbiAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgucG93KGEuZywgYik7XHJcbiAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgucG93KGEuYiwgYik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDIpO1xyXG4gICAgICAgICAgICB2YXIgYyA9IDAgPCBiID8gMSAvIGIgOiAxO1xyXG4gICAgICAgICAgICB0aGlzLnIgPSBNYXRoLnBvdyhhLnIsIGMpO1xyXG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLnBvdyhhLmcsIGMpO1xyXG4gICAgICAgICAgICB0aGlzLmIgPSBNYXRoLnBvdyhhLmIsIGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID1cclxuICAgICAgICAgICAgICAgIHRoaXMuciwgYiA9IHRoaXMuZywgYyA9IHRoaXMuYjtcclxuICAgICAgICAgICAgdGhpcy5yID0gYSAqIGE7XHJcbiAgICAgICAgICAgIHRoaXMuZyA9IGIgKiBiO1xyXG4gICAgICAgICAgICB0aGlzLmIgPSBjICogYztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnIgPSBNYXRoLnNxcnQodGhpcy5yKTtcclxuICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5zcXJ0KHRoaXMuZyk7XHJcbiAgICAgICAgICAgIHRoaXMuYiA9IE1hdGguc3FydCh0aGlzLmIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldEhleDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMjU1ICogdGhpcy5yIDw8IDE2IF4gMjU1ICogdGhpcy5nIDw8IDggXiAyNTUgKiB0aGlzLmIgPDwgMFxyXG4gICAgICAgIH0sIGdldEhleFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFwiMDAwMDAwXCIgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpXHJcbiAgICAgICAgfSwgZ2V0SFNMOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYSB8fCB7aDogMCwgczogMCwgbDogMH07XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5yLCBjID0gdGhpcy5nLCBkID0gdGhpcy5iLCBlID0gTWF0aC5tYXgoYiwgYywgZCksIGYgPSBNYXRoLm1pbihiLCBjLCBkKSwgZywgaCA9IChmICsgZSkgLyAyO1xyXG4gICAgICAgICAgICBpZiAoZiA9PT0gZSkgZiA9IGcgPSAwOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gZSAtIGYsIGYgPSAuNSA+PSBoID8gbSAvIChlICsgZikgOlxyXG4gICAgICAgICAgICAgICAgICAgIG0gLyAoMiAtIGUgLSBmKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IChjIC0gZCkgLyBtICsgKGMgPCBkID8gNiA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSAoZCAtIGIpIC8gbSArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IChiIC0gYykgLyBtICsgNFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZyAvPSA2XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYS5oID0gZztcclxuICAgICAgICAgICAgYS5zID0gZjtcclxuICAgICAgICAgICAgYS5sID0gaDtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCBnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJyZ2IoXCIgKyAoMjU1ICogdGhpcy5yIHwgMCkgKyBcIixcIiArICgyNTUgKiB0aGlzLmcgfCAwKSArIFwiLFwiICsgKDI1NSAqIHRoaXMuYiB8IDApICsgXCIpXCJcclxuICAgICAgICB9LCBvZmZzZXRIU0w6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5nZXRIU0woKTtcclxuICAgICAgICAgICAgZC5oICs9IGE7XHJcbiAgICAgICAgICAgIGQucyArPSBiO1xyXG4gICAgICAgICAgICBkLmwgKz0gYztcclxuICAgICAgICAgICAgdGhpcy5zZXRIU0woZC5oLCBkLnMsIGQubCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgYWRkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnIgKz0gYS5yO1xyXG4gICAgICAgICAgICB0aGlzLmcgKz0gYS5nO1xyXG4gICAgICAgICAgICB0aGlzLmIgKz0gYS5iO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGFkZENvbG9yczogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gYS5yICsgYi5yO1xyXG4gICAgICAgICAgICB0aGlzLmcgPSBhLmcgKyBiLmc7XHJcbiAgICAgICAgICAgIHRoaXMuYiA9IGEuYiArIGIuYjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBhZGRTY2FsYXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuciArPVxyXG4gICAgICAgICAgICAgICAgYTtcclxuICAgICAgICAgICAgdGhpcy5nICs9IGE7XHJcbiAgICAgICAgICAgIHRoaXMuYiArPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHN1YjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5tYXgoMCwgdGhpcy5yIC0gYS5yKTtcclxuICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5tYXgoMCwgdGhpcy5nIC0gYS5nKTtcclxuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5tYXgoMCwgdGhpcy5iIC0gYS5iKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtdWx0aXBseTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yICo9IGEucjtcclxuICAgICAgICAgICAgdGhpcy5nICo9IGEuZztcclxuICAgICAgICAgICAgdGhpcy5iICo9IGEuYjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yICo9IGE7XHJcbiAgICAgICAgICAgIHRoaXMuZyAqPSBhO1xyXG4gICAgICAgICAgICB0aGlzLmIgKj0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBsZXJwOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnIgKz0gKGEuciAtIHRoaXMucikgKiBiO1xyXG4gICAgICAgICAgICB0aGlzLmcgKz0gKGEuZyAtIHRoaXMuZykgKiBiO1xyXG4gICAgICAgICAgICB0aGlzLmIgKz0gKGEuYiAtIHRoaXMuYikgKiBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGVxdWFsczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuciA9PT0gdGhpcy5yICYmIGEuZyA9PT0gdGhpcy5nICYmIGEuYiA9PT0gdGhpcy5iXHJcbiAgICAgICAgfSwgZnJvbUFycmF5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPVxyXG4gICAgICAgICAgICAgICAgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuciA9IGFbYl07XHJcbiAgICAgICAgICAgIHRoaXMuZyA9IGFbYiArIDFdO1xyXG4gICAgICAgICAgICB0aGlzLmIgPSBhW2IgKyAyXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0b0FycmF5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBbXSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xyXG4gICAgICAgICAgICBhW2JdID0gdGhpcy5yO1xyXG4gICAgICAgICAgICBhW2IgKyAxXSA9IHRoaXMuZztcclxuICAgICAgICAgICAgYVtiICsgMl0gPSB0aGlzLmI7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSwgdG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhleCgpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBXZiA9IHtcclxuICAgICAgICBhbGljZWJsdWU6IDE1NzkyMzgzLFxyXG4gICAgICAgIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXHJcbiAgICAgICAgYXF1YTogNjU1MzUsXHJcbiAgICAgICAgYXF1YW1hcmluZTogODM4ODU2NCxcclxuICAgICAgICBhenVyZTogMTU3OTQxNzUsXHJcbiAgICAgICAgYmVpZ2U6IDE2MTE5MjYwLFxyXG4gICAgICAgIGJpc3F1ZTogMTY3NzAyNDQsXHJcbiAgICAgICAgYmxhY2s6IDAsXHJcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6IDE2NzcyMDQ1LFxyXG4gICAgICAgIGJsdWU6IDI1NSxcclxuICAgICAgICBibHVldmlvbGV0OiA5MDU1MjAyLFxyXG4gICAgICAgIGJyb3duOiAxMDgyNDIzNCxcclxuICAgICAgICBidXJseXdvb2Q6IDE0NTk2MjMxLFxyXG4gICAgICAgIGNhZGV0Ymx1ZTogNjI2NjUyOCxcclxuICAgICAgICBjaGFydHJldXNlOiA4Mzg4MzUyLFxyXG4gICAgICAgIGNob2NvbGF0ZTogMTM3ODk0NzAsXHJcbiAgICAgICAgY29yYWw6IDE2NzQ0MjcyLFxyXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiA2NTkxOTgxLFxyXG4gICAgICAgIGNvcm5zaWxrOiAxNjc3NTM4OCxcclxuICAgICAgICBjcmltc29uOiAxNDQyMzEwMCxcclxuICAgICAgICBjeWFuOiA2NTUzNSxcclxuICAgICAgICBkYXJrYmx1ZTogMTM5LFxyXG4gICAgICAgIGRhcmtjeWFuOiAzNTcyMyxcclxuICAgICAgICBkYXJrZ29sZGVucm9kOiAxMjA5MjkzOSxcclxuICAgICAgICBkYXJrZ3JheTogMTExMTkwMTcsXHJcbiAgICAgICAgZGFya2dyZWVuOiAyNTYwMCxcclxuICAgICAgICBkYXJrZ3JleTogMTExMTkwMTcsXHJcbiAgICAgICAgZGFya2toYWtpOiAxMjQzMzI1OSxcclxuICAgICAgICBkYXJrbWFnZW50YTogOTEwOTY0MyxcclxuICAgICAgICBkYXJrb2xpdmVncmVlbjogNTU5Nzk5OSxcclxuICAgICAgICBkYXJrb3JhbmdlOiAxNjc0NzUyMCxcclxuICAgICAgICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcclxuICAgICAgICBkYXJrcmVkOiA5MTA5NTA0LFxyXG4gICAgICAgIGRhcmtzYWxtb246IDE1MzA4NDEwLFxyXG4gICAgICAgIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcclxuICAgICAgICBkYXJrc2xhdGVibHVlOiA0NzM0MzQ3LFxyXG4gICAgICAgIGRhcmtzbGF0ZWdyYXk6IDMxMDA0OTUsXHJcbiAgICAgICAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcclxuICAgICAgICBkYXJrdHVycXVvaXNlOiA1Mjk0NSxcclxuICAgICAgICBkYXJrdmlvbGV0OiA5Njk5NTM5LFxyXG4gICAgICAgIGRlZXBwaW5rOiAxNjcxNjk0NyxcclxuICAgICAgICBkZWVwc2t5Ymx1ZTogNDkxNTEsXHJcbiAgICAgICAgZGltZ3JheTogNjkwODI2NSxcclxuICAgICAgICBkaW1ncmV5OiA2OTA4MjY1LFxyXG4gICAgICAgIGRvZGdlcmJsdWU6IDIwMDMxOTksXHJcbiAgICAgICAgZmlyZWJyaWNrOiAxMTY3NDE0NixcclxuICAgICAgICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXHJcbiAgICAgICAgZm9yZXN0Z3JlZW46IDIyNjM4NDIsXHJcbiAgICAgICAgZnVjaHNpYTogMTY3MTE5MzUsXHJcbiAgICAgICAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcclxuICAgICAgICBnaG9zdHdoaXRlOiAxNjMxNjY3MSxcclxuICAgICAgICBnb2xkOiAxNjc2NjcyMCxcclxuICAgICAgICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxyXG4gICAgICAgIGdyYXk6IDg0MjE1MDQsXHJcbiAgICAgICAgZ3JlZW46IDMyNzY4LFxyXG4gICAgICAgIGdyZWVueWVsbG93OiAxMTQwMzA1NSxcclxuICAgICAgICBncmV5OiA4NDIxNTA0LFxyXG4gICAgICAgIGhvbmV5ZGV3OiAxNTc5NDE2MCxcclxuICAgICAgICBob3RwaW5rOiAxNjczODc0MCxcclxuICAgICAgICBpbmRpYW5yZWQ6IDEzNDU4NTI0LFxyXG4gICAgICAgIGluZGlnbzogNDkxNTMzMCxcclxuICAgICAgICBpdm9yeTogMTY3NzcyMDAsXHJcbiAgICAgICAga2hha2k6IDE1Nzg3NjYwLFxyXG4gICAgICAgIGxhdmVuZGVyOiAxNTEzMjQxMCxcclxuICAgICAgICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcclxuICAgICAgICBsYXduZ3JlZW46IDgxOTA5NzYsXHJcbiAgICAgICAgbGVtb25jaGlmZm9uOiAxNjc3NTg4NSxcclxuICAgICAgICBsaWdodGJsdWU6IDExMzkzMjU0LFxyXG4gICAgICAgIGxpZ2h0Y29yYWw6IDE1NzYxNTM2LFxyXG4gICAgICAgIGxpZ2h0Y3lhbjogMTQ3NDU1OTksXHJcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxyXG4gICAgICAgIGxpZ2h0Z3JheTogMTM4ODIzMjMsXHJcbiAgICAgICAgbGlnaHRncmVlbjogOTQ5ODI1NixcclxuICAgICAgICBsaWdodGdyZXk6IDEzODgyMzIzLFxyXG4gICAgICAgIGxpZ2h0cGluazogMTY3NTg0NjUsXHJcbiAgICAgICAgbGlnaHRzYWxtb246IDE2NzUyNzYyLFxyXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXHJcbiAgICAgICAgbGlnaHRza3libHVlOiA4OTAwMzQ2LFxyXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiA3ODMzNzUzLFxyXG4gICAgICAgIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxyXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiAxMTU4NDczNCxcclxuICAgICAgICBsaWdodHllbGxvdzogMTY3NzcxODQsXHJcbiAgICAgICAgbGltZTogNjUyODAsXHJcbiAgICAgICAgbGltZWdyZWVuOiAzMzI5MzMwLFxyXG4gICAgICAgIGxpbmVuOiAxNjQ0NTY3MCxcclxuICAgICAgICBtYWdlbnRhOiAxNjcxMTkzNSxcclxuICAgICAgICBtYXJvb246IDgzODg2MDgsXHJcbiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogNjczNzMyMixcclxuICAgICAgICBtZWRpdW1ibHVlOiAyMDUsXHJcbiAgICAgICAgbWVkaXVtb3JjaGlkOiAxMjIxMTY2NyxcclxuICAgICAgICBtZWRpdW1wdXJwbGU6IDk2NjI2ODMsXHJcbiAgICAgICAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXHJcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiA4MDg3NzkwLFxyXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiA2NDE1NCxcclxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXHJcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAxMzA0NzE3MyxcclxuICAgICAgICBtaWRuaWdodGJsdWU6IDE2NDQ5MTIsXHJcbiAgICAgICAgbWludGNyZWFtOiAxNjEyMTg1MCxcclxuICAgICAgICBtaXN0eXJvc2U6IDE2NzcwMjczLFxyXG4gICAgICAgIG1vY2Nhc2luOiAxNjc3MDIyOSxcclxuICAgICAgICBuYXZham93aGl0ZTogMTY3Njg2ODUsXHJcbiAgICAgICAgbmF2eTogMTI4LFxyXG4gICAgICAgIG9sZGxhY2U6IDE2NjQzNTU4LFxyXG4gICAgICAgIG9saXZlOiA4NDIxMzc2LFxyXG4gICAgICAgIG9saXZlZHJhYjogNzA0ODczOSxcclxuICAgICAgICBvcmFuZ2U6IDE2NzUzOTIwLFxyXG4gICAgICAgIG9yYW5nZXJlZDogMTY3MjkzNDQsXHJcbiAgICAgICAgb3JjaGlkOiAxNDMxNTczNCxcclxuICAgICAgICBwYWxlZ29sZGVucm9kOiAxNTY1NzEzMCxcclxuICAgICAgICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxyXG4gICAgICAgIHBhbGV0dXJxdW9pc2U6IDExNTI5OTY2LFxyXG4gICAgICAgIHBhbGV2aW9sZXRyZWQ6IDE0MzgxMjAzLFxyXG4gICAgICAgIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxyXG4gICAgICAgIHBlYWNocHVmZjogMTY3Njc2NzMsXHJcbiAgICAgICAgcGVydTogMTM0Njg5OTEsXHJcbiAgICAgICAgcGluazogMTY3NjEwMzUsXHJcbiAgICAgICAgcGx1bTogMTQ1MjQ2MzcsXHJcbiAgICAgICAgcG93ZGVyYmx1ZTogMTE1OTE5MTAsXHJcbiAgICAgICAgcHVycGxlOiA4Mzg4NzM2LFxyXG4gICAgICAgIHJlZDogMTY3MTE2ODAsXHJcbiAgICAgICAgcm9zeWJyb3duOiAxMjM1NzUxOSxcclxuICAgICAgICByb3lhbGJsdWU6IDQyODY5NDUsXHJcbiAgICAgICAgc2FkZGxlYnJvd246IDkxMjcxODcsXHJcbiAgICAgICAgc2FsbW9uOiAxNjQxNjg4MixcclxuICAgICAgICBzYW5keWJyb3duOiAxNjAzMjg2NCxcclxuICAgICAgICBzZWFncmVlbjogMzA1MDMyNyxcclxuICAgICAgICBzZWFzaGVsbDogMTY3NzQ2MzgsXHJcbiAgICAgICAgc2llbm5hOiAxMDUwNjc5NyxcclxuICAgICAgICBzaWx2ZXI6IDEyNjMyMjU2LFxyXG4gICAgICAgIHNreWJsdWU6IDg5MDAzMzEsXHJcbiAgICAgICAgc2xhdGVibHVlOiA2OTcwMDYxLFxyXG4gICAgICAgIHNsYXRlZ3JheTogNzM3Mjk0NCxcclxuICAgICAgICBzbGF0ZWdyZXk6IDczNzI5NDQsXHJcbiAgICAgICAgc25vdzogMTY3NzU5MzAsXHJcbiAgICAgICAgc3ByaW5nZ3JlZW46IDY1NDA3LFxyXG4gICAgICAgIHN0ZWVsYmx1ZTogNDYyMDk4MCxcclxuICAgICAgICB0YW46IDEzODA4NzgwLFxyXG4gICAgICAgIHRlYWw6IDMyODk2LFxyXG4gICAgICAgIHRoaXN0bGU6IDE0MjA0ODg4LFxyXG4gICAgICAgIHRvbWF0bzogMTY3MzcwOTUsXHJcbiAgICAgICAgdHVycXVvaXNlOiA0MjUxODU2LFxyXG4gICAgICAgIHZpb2xldDogMTU2MzEwODYsXHJcbiAgICAgICAgd2hlYXQ6IDE2MTEzMzMxLFxyXG4gICAgICAgIHdoaXRlOiAxNjc3NzIxNSxcclxuICAgICAgICB3aGl0ZXNtb2tlOiAxNjExOTI4NSxcclxuICAgICAgICB5ZWxsb3c6IDE2Nzc2OTYwLFxyXG4gICAgICAgIHllbGxvd2dyZWVuOiAxMDE0NTA3NFxyXG4gICAgfTtcclxuICAgIGViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZWEucHJvdG90eXBlKTtcclxuICAgIGViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGViO1xyXG4gICAgZWIucHJvdG90eXBlLmlzRGF0YVRleHR1cmUgPSAhMDtcclxuICAgIHZhciBWID0ge1xyXG4gICAgICAgIGNvbW1vbjoge1xyXG4gICAgICAgICAgICBkaWZmdXNlOiB7dmFsdWU6IG5ldyBKKDE1NjU4NzM0KX0sXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMX0sXHJcbiAgICAgICAgICAgIG1hcDoge3ZhbHVlOiBudWxsfSxcclxuICAgICAgICAgICAgb2Zmc2V0UmVwZWF0OiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IGZhKDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCwgMSwgMSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3BlY3VsYXJNYXA6IHt2YWx1ZTogbnVsbH0sXHJcbiAgICAgICAgICAgIGFscGhhTWFwOiB7dmFsdWU6IG51bGx9LFxyXG4gICAgICAgICAgICBlbnZNYXA6IHt2YWx1ZTogbnVsbH0sXHJcbiAgICAgICAgICAgIGZsaXBFbnZNYXA6IHt2YWx1ZTogLTF9LFxyXG4gICAgICAgICAgICByZWZsZWN0aXZpdHk6IHt2YWx1ZTogMX0sXHJcbiAgICAgICAgICAgIHJlZnJhY3Rpb25SYXRpbzoge3ZhbHVlOiAuOTh9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhb21hcDoge2FvTWFwOiB7dmFsdWU6IG51bGx9LCBhb01hcEludGVuc2l0eToge3ZhbHVlOiAxfX0sXHJcbiAgICAgICAgbGlnaHRtYXA6IHtsaWdodE1hcDoge3ZhbHVlOiBudWxsfSwgbGlnaHRNYXBJbnRlbnNpdHk6IHt2YWx1ZTogMX19LFxyXG4gICAgICAgIGVtaXNzaXZlbWFwOiB7ZW1pc3NpdmVNYXA6IHt2YWx1ZTogbnVsbH19LFxyXG4gICAgICAgIGJ1bXBtYXA6IHtidW1wTWFwOiB7dmFsdWU6IG51bGx9LCBidW1wU2NhbGU6IHt2YWx1ZTogMX19LFxyXG4gICAgICAgIG5vcm1hbG1hcDoge25vcm1hbE1hcDoge3ZhbHVlOiBudWxsfSwgbm9ybWFsU2NhbGU6IHt2YWx1ZTogbmV3IEQoMSwgMSl9fSxcclxuICAgICAgICBkaXNwbGFjZW1lbnRtYXA6IHtkaXNwbGFjZW1lbnRNYXA6IHt2YWx1ZTogbnVsbH0sIGRpc3BsYWNlbWVudFNjYWxlOiB7dmFsdWU6IDF9LCBkaXNwbGFjZW1lbnRCaWFzOiB7dmFsdWU6IDB9fSxcclxuICAgICAgICByb3VnaG5lc3NtYXA6IHtyb3VnaG5lc3NNYXA6IHt2YWx1ZTogbnVsbH19LFxyXG4gICAgICAgIG1ldGFsbmVzc21hcDoge21ldGFsbmVzc01hcDoge3ZhbHVlOiBudWxsfX0sXHJcbiAgICAgICAgZ3JhZGllbnRtYXA6IHtncmFkaWVudE1hcDoge3ZhbHVlOiBudWxsfX0sXHJcbiAgICAgICAgZm9nOiB7XHJcbiAgICAgICAgICAgIGZvZ0RlbnNpdHk6IHt2YWx1ZTogMi41RS00fSxcclxuICAgICAgICAgICAgZm9nTmVhcjoge3ZhbHVlOiAxfSxcclxuICAgICAgICAgICAgZm9nRmFyOiB7dmFsdWU6IDJFM30sXHJcbiAgICAgICAgICAgIGZvZ0NvbG9yOiB7dmFsdWU6IG5ldyBKKDE2Nzc3MjE1KX1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpZ2h0czoge1xyXG4gICAgICAgICAgICBhbWJpZW50TGlnaHRDb2xvcjoge3ZhbHVlOiBbXX0sXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsTGlnaHRzOiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogW10sXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7ZGlyZWN0aW9uOiB7fSwgY29sb3I6IHt9LCBzaGFkb3c6IHt9LCBzaGFkb3dCaWFzOiB7fSwgc2hhZG93UmFkaXVzOiB7fSwgc2hhZG93TWFwU2l6ZToge319XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsU2hhZG93TWFwOiB7dmFsdWU6IFtdfSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IHt2YWx1ZTogW119LFxyXG4gICAgICAgICAgICBzcG90TGlnaHRzOiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmVDb3M6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBlbnVtYnJhQ29zOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBkZWNheToge30sXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93OiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dCaWFzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dSYWRpdXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd01hcFNpemU6IHt9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNwb3RTaGFkb3dNYXA6IHt2YWx1ZTogW119LFxyXG4gICAgICAgICAgICBzcG90U2hhZG93TWF0cml4OiB7dmFsdWU6IFtdfSxcclxuICAgICAgICAgICAgcG9pbnRMaWdodHM6IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2F5OiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZToge30sXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93OiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dCaWFzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dSYWRpdXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd01hcFNpemU6IHt9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBvaW50U2hhZG93TWFwOiB7dmFsdWU6IFtdfSxcclxuICAgICAgICAgICAgcG9pbnRTaGFkb3dNYXRyaXg6IHt2YWx1ZTogW119LFxyXG4gICAgICAgICAgICBoZW1pc3BoZXJlTGlnaHRzOiB7dmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7ZGlyZWN0aW9uOiB7fSwgc2t5Q29sb3I6IHt9LCBncm91bmRDb2xvcjoge319fSxcclxuICAgICAgICAgICAgcmVjdEFyZWFMaWdodHM6IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB7fSwgcG9zaXRpb246IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB7fSwgaGVpZ2h0OiB7fVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb2ludHM6IHtcclxuICAgICAgICAgICAgZGlmZnVzZToge3ZhbHVlOiBuZXcgSigxNTY1ODczNCl9LFxyXG4gICAgICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDF9LFxyXG4gICAgICAgICAgICBzaXplOiB7dmFsdWU6IDF9LFxyXG4gICAgICAgICAgICBzY2FsZToge3ZhbHVlOiAxfSxcclxuICAgICAgICAgICAgbWFwOiB7dmFsdWU6IG51bGx9LFxyXG4gICAgICAgICAgICBvZmZzZXRSZXBlYXQ6IHt2YWx1ZTogbmV3IGZhKDAsIDAsIDEsIDEpfVxyXG4gICAgICAgIH1cclxuICAgIH0sIGJiID0ge1xyXG4gICAgICAgIGJhc2ljOiB7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zOiBKYS5tZXJnZShbVi5jb21tb24sIFYuYW9tYXAsIFYubGlnaHRtYXAsIFYuZm9nXSksXHJcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcjogWi5tZXNoYmFzaWNfdmVydCxcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFoubWVzaGJhc2ljX2ZyYWdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhbWJlcnQ6IHtcclxuICAgICAgICAgICAgdW5pZm9ybXM6IEphLm1lcmdlKFtWLmNvbW1vbiwgVi5hb21hcCwgVi5saWdodG1hcCwgVi5lbWlzc2l2ZW1hcCwgVi5mb2csIFYubGlnaHRzLCB7ZW1pc3NpdmU6IHt2YWx1ZTogbmV3IEooMCl9fV0pLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFoubWVzaGxhbWJlcnRfdmVydCxcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFoubWVzaGxhbWJlcnRfZnJhZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGhvbmc6IHtcclxuICAgICAgICAgICAgdW5pZm9ybXM6IEphLm1lcmdlKFtWLmNvbW1vbixcclxuICAgICAgICAgICAgICAgIFYuYW9tYXAsIFYubGlnaHRtYXAsIFYuZW1pc3NpdmVtYXAsIFYuYnVtcG1hcCwgVi5ub3JtYWxtYXAsIFYuZGlzcGxhY2VtZW50bWFwLCBWLmdyYWRpZW50bWFwLCBWLmZvZywgVi5saWdodHMsIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWlzc2l2ZToge3ZhbHVlOiBuZXcgSigwKX0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3BlY3VsYXI6IHt2YWx1ZTogbmV3IEooMTExODQ4MSl9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNoaW5pbmVzczoge3ZhbHVlOiAzMH1cclxuICAgICAgICAgICAgICAgIH1dKSwgdmVydGV4U2hhZGVyOiBaLm1lc2hwaG9uZ192ZXJ0LCBmcmFnbWVudFNoYWRlcjogWi5tZXNocGhvbmdfZnJhZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhbmRhcmQ6IHtcclxuICAgICAgICAgICAgdW5pZm9ybXM6IEphLm1lcmdlKFtWLmNvbW1vbiwgVi5hb21hcCwgVi5saWdodG1hcCwgVi5lbWlzc2l2ZW1hcCwgVi5idW1wbWFwLCBWLm5vcm1hbG1hcCwgVi5kaXNwbGFjZW1lbnRtYXAsIFYucm91Z2huZXNzbWFwLCBWLm1ldGFsbmVzc21hcCwgVi5mb2csIFYubGlnaHRzLCB7XHJcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZToge3ZhbHVlOiBuZXcgSigwKX0sXHJcbiAgICAgICAgICAgICAgICByb3VnaG5lc3M6IHt2YWx1ZTogLjV9LFxyXG4gICAgICAgICAgICAgICAgbWV0YWxuZXNzOiB7dmFsdWU6IDB9LFxyXG4gICAgICAgICAgICAgICAgZW52TWFwSW50ZW5zaXR5OiB7dmFsdWU6IDF9XHJcbiAgICAgICAgICAgIH1dKSxcclxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBaLm1lc2hwaHlzaWNhbF92ZXJ0LCBmcmFnbWVudFNoYWRlcjogWi5tZXNocGh5c2ljYWxfZnJhZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcG9pbnRzOiB7dW5pZm9ybXM6IEphLm1lcmdlKFtWLnBvaW50cywgVi5mb2ddKSwgdmVydGV4U2hhZGVyOiBaLnBvaW50c192ZXJ0LCBmcmFnbWVudFNoYWRlcjogWi5wb2ludHNfZnJhZ30sXHJcbiAgICAgICAgZGFzaGVkOiB7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zOiBKYS5tZXJnZShbVi5jb21tb24sIFYuZm9nLCB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZToge3ZhbHVlOiAxfSxcclxuICAgICAgICAgICAgICAgIGRhc2hTaXplOiB7dmFsdWU6IDF9LFxyXG4gICAgICAgICAgICAgICAgdG90YWxTaXplOiB7dmFsdWU6IDJ9XHJcbiAgICAgICAgICAgIH1dKSwgdmVydGV4U2hhZGVyOiBaLmxpbmVkYXNoZWRfdmVydCwgZnJhZ21lbnRTaGFkZXI6IFoubGluZWRhc2hlZF9mcmFnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXB0aDoge1xyXG4gICAgICAgICAgICB1bmlmb3JtczogSmEubWVyZ2UoW1YuY29tbW9uLCBWLmRpc3BsYWNlbWVudG1hcF0pLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFouZGVwdGhfdmVydCxcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFouZGVwdGhfZnJhZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9ybWFsOiB7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zOiBKYS5tZXJnZShbVi5jb21tb24sIFYuYnVtcG1hcCwgVi5ub3JtYWxtYXAsXHJcbiAgICAgICAgICAgICAgICBWLmRpc3BsYWNlbWVudG1hcCwge29wYWNpdHk6IHt2YWx1ZTogMX19XSksIHZlcnRleFNoYWRlcjogWi5ub3JtYWxfdmVydCwgZnJhZ21lbnRTaGFkZXI6IFoubm9ybWFsX2ZyYWdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGN1YmU6IHtcclxuICAgICAgICAgICAgdW5pZm9ybXM6IHt0Q3ViZToge3ZhbHVlOiBudWxsfSwgdEZsaXA6IHt2YWx1ZTogLTF9LCBvcGFjaXR5OiB7dmFsdWU6IDF9fSxcclxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBaLmN1YmVfdmVydCxcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFouY3ViZV9mcmFnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcXVpcmVjdDoge1xyXG4gICAgICAgICAgICB1bmlmb3Jtczoge3RFcXVpcmVjdDoge3ZhbHVlOiBudWxsfSwgdEZsaXA6IHt2YWx1ZTogLTF9fSxcclxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBaLmVxdWlyZWN0X3ZlcnQsXHJcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBaLmVxdWlyZWN0X2ZyYWdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3RhbmNlUkdCQToge1xyXG4gICAgICAgICAgICB1bmlmb3Jtczoge2xpZ2h0UG9zOiB7dmFsdWU6IG5ldyBxfX0sXHJcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcjogWi5kaXN0YW5jZVJHQkFfdmVydCxcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFouZGlzdGFuY2VSR0JBX2ZyYWdcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgYmIucGh5c2ljYWwgPSB7XHJcbiAgICAgICAgdW5pZm9ybXM6IEphLm1lcmdlKFtiYi5zdGFuZGFyZC51bmlmb3JtcyxcclxuICAgICAgICAgICAge2NsZWFyQ29hdDoge3ZhbHVlOiAwfSwgY2xlYXJDb2F0Um91Z2huZXNzOiB7dmFsdWU6IDB9fV0pLFxyXG4gICAgICAgIHZlcnRleFNoYWRlcjogWi5tZXNocGh5c2ljYWxfdmVydCxcclxuICAgICAgICBmcmFnbWVudFNoYWRlcjogWi5tZXNocGh5c2ljYWxfZnJhZ1xyXG4gICAgfTtcclxuICAgIHNjLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcjogc2MsIHNldDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4uY29weShhKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguY29weShiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMCwgYyA9IGEubGVuZ3RoOyBiIDwgYzsgYisrKXRoaXMuZXhwYW5kQnlQb2ludChhW2JdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBEO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gYS5jb3B5KGMpLm11bHRpcGx5U2NhbGFyKC41KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluLmNvcHkoYikuc3ViKGQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXguY29weShiKS5hZGQoZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbi5jb3B5KGEubWluKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguY29weShhLm1heCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4LnggPCB0aGlzLm1pbi54IHx8IHRoaXMubWF4LnkgPCB0aGlzLm1pbi55XHJcbiAgICAgICAgfSwgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYSB8fCBuZXcgRDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gYS5zZXQoMCwgMCkgOiBhLmFkZFZlY3RvcnModGhpcy5taW4sIHRoaXMubWF4KS5tdWx0aXBseVNjYWxhciguNSlcclxuICAgICAgICB9LCBnZXRTaXplOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYSB8fCBuZXcgRDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gYS5zZXQoMCwgMCkgOiBhLnN1YlZlY3RvcnModGhpcy5tYXgsIHRoaXMubWluKVxyXG4gICAgICAgIH0sIGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluLm1pbihhKTtcclxuICAgICAgICAgICAgdGhpcy5tYXgubWF4KGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbi5zdWIoYSk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4LmFkZChhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4uYWRkU2NhbGFyKC1hKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguYWRkU2NhbGFyKGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnggPCB0aGlzLm1pbi54IHx8IGEueCA+IHRoaXMubWF4LnggfHwgYS55IDwgdGhpcy5taW4ueSB8fCBhLnkgPiB0aGlzLm1heC55ID8gITEgOiAhMFxyXG4gICAgICAgIH0sIGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW4ueCA8PSBhLm1pbi54ICYmIGEubWF4LnggPD0gdGhpcy5tYXgueCAmJiB0aGlzLm1pbi55IDw9IGEubWluLnkgJiYgYS5tYXgueSA8PSB0aGlzLm1heC55XHJcbiAgICAgICAgfSwgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gKGIgfHwgbmV3IEQpLnNldCgoYS54IC0gdGhpcy5taW4ueCkgLyAodGhpcy5tYXgueCAtIHRoaXMubWluLngpLCAoYS55IC0gdGhpcy5taW4ueSkgLyAodGhpcy5tYXgueSAtXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbi55KSlcclxuICAgICAgICB9LCBpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5tYXgueCA8IHRoaXMubWluLnggfHwgYS5taW4ueCA+IHRoaXMubWF4LnggfHwgYS5tYXgueSA8IHRoaXMubWluLnkgfHwgYS5taW4ueSA+IHRoaXMubWF4LnkgPyAhMSA6ICEwXHJcbiAgICAgICAgfSwgY2xhbXBQb2ludDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChiIHx8IG5ldyBEKS5jb3B5KGEpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heClcclxuICAgICAgICB9LCBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgRDtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jb3B5KGIpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heCkuc3ViKGIpLmxlbmd0aCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGludGVyc2VjdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4ubWF4KGEubWluKTtcclxuICAgICAgICAgICAgdGhpcy5tYXgubWluKGEubWF4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB1bmlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4ubWluKGEubWluKTtcclxuICAgICAgICAgICAgdGhpcy5tYXgubWF4KGEubWF4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0cmFuc2xhdGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluLmFkZChhKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguYWRkKGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGVxdWFsczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEubWluLmVxdWFscyh0aGlzLm1pbikgJiYgYS5tYXguZXF1YWxzKHRoaXMubWF4KVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgQWYgPSAwO1xyXG4gICAgWC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IFgsIGlzTWF0ZXJpYWw6ICEwLCBnZXQgbmVlZHNVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZVxyXG4gICAgICAgIH0sIHNldCBuZWVkc1VwZGF0ZShhKSB7XHJcbiAgICAgICAgICAgICEwID09PSBhICYmIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gYVxyXG4gICAgICAgIH0sIHNldFZhbHVlczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSlmb3IgKHZhciBiIGluIGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gYVtiXTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGMpIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdGVyaWFsOiAnXCIgKyBiICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBkID8gY29uc29sZS53YXJuKFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgKyBcIjogJ1wiICsgYiArIFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgJiYgZC5pc0NvbG9yID8gZC5zZXQoYykgOiBkICYmIGQuaXNWZWN0b3IzICYmIGMgJiYgYy5pc1ZlY3RvcjMgPyBkLmNvcHkoYykgOiB0aGlzW2JdID0gXCJvdmVyZHJhd1wiID09PSBiID8gTnVtYmVyKGMpIDogY1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdG9KU09OOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBiKGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gW10sIGM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGMgaW4gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gYVtjXTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZC5tZXRhZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBiLnB1c2goZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjID0gdm9pZCAwID09PSBhO1xyXG4gICAgICAgICAgICBjICYmIChhID0ge3RleHR1cmVzOiB7fSwgaW1hZ2VzOiB7fX0pO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHttZXRhZGF0YToge3ZlcnNpb246IDQuNCwgdHlwZTogXCJNYXRlcmlhbFwiLCBnZW5lcmF0b3I6IFwiTWF0ZXJpYWwudG9KU09OXCJ9fTtcclxuICAgICAgICAgICAgZC51dWlkID0gdGhpcy51dWlkO1xyXG4gICAgICAgICAgICBkLnR5cGUgPSB0aGlzLnR5cGU7XHJcbiAgICAgICAgICAgIFwiXCIgIT09IHRoaXMubmFtZSAmJiAoZC5uYW1lID0gdGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciAmJiB0aGlzLmNvbG9yLmlzQ29sb3IgJiYgKGQuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLnJvdWdobmVzcyAmJiAoZC5yb3VnaG5lc3MgPSB0aGlzLnJvdWdobmVzcyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy5tZXRhbG5lc3MgJiYgKGQubWV0YWxuZXNzID0gdGhpcy5tZXRhbG5lc3MpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXNzaXZlICYmIHRoaXMuZW1pc3NpdmUuaXNDb2xvciAmJiAoZC5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvciAmJiAoZC5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMuc2hpbmluZXNzICYmIChkLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLmNsZWFyQ29hdCAmJiAoZC5jbGVhckNvYXQgPSB0aGlzLmNsZWFyQ29hdCk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgJiYgKGQuY2xlYXJDb2F0Um91Z2huZXNzID0gdGhpcy5jbGVhckNvYXRSb3VnaG5lc3MpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcCAmJiB0aGlzLm1hcC5pc1RleHR1cmUgJiYgKGQubWFwID0gdGhpcy5tYXAudG9KU09OKGEpLnV1aWQpO1xyXG4gICAgICAgICAgICB0aGlzLmFscGhhTWFwICYmIHRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlICYmIChkLmFscGhhTWFwID1cclxuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGFNYXAudG9KU09OKGEpLnV1aWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0TWFwICYmIHRoaXMubGlnaHRNYXAuaXNUZXh0dXJlICYmIChkLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oYSkudXVpZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVtcE1hcCAmJiB0aGlzLmJ1bXBNYXAuaXNUZXh0dXJlICYmIChkLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKGEpLnV1aWQsIGQuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGUpO1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUgJiYgKGQubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKGEpLnV1aWQsIGQubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlLnRvQXJyYXkoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwICYmIHRoaXMuZGlzcGxhY2VtZW50TWFwLmlzVGV4dHVyZSAmJiAoZC5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oYSkudXVpZCwgZC5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGUsIGQuZGlzcGxhY2VtZW50QmlhcyA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUgJiYgKGQucm91Z2huZXNzTWFwID0gdGhpcy5yb3VnaG5lc3NNYXAudG9KU09OKGEpLnV1aWQpO1xyXG4gICAgICAgICAgICB0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUgJiYgKGQubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKGEpLnV1aWQpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXNzaXZlTWFwICYmIHRoaXMuZW1pc3NpdmVNYXAuaXNUZXh0dXJlICYmIChkLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oYSkudXVpZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlY3VsYXJNYXAgJiYgdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUgJiYgKGQuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTihhKS51dWlkKTtcclxuICAgICAgICAgICAgdGhpcy5lbnZNYXAgJiYgdGhpcy5lbnZNYXAuaXNUZXh0dXJlICYmIChkLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTihhKS51dWlkLCBkLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5KTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudE1hcCAmJiB0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSAmJiAoZC5ncmFkaWVudE1hcCA9IHRoaXMuZ3JhZGllbnRNYXAudG9KU09OKGEpLnV1aWQpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMuc2l6ZSAmJiAoZC5zaXplID0gdGhpcy5zaXplKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLnNpemVBdHRlbnVhdGlvbiAmJiAoZC5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbik7XHJcbiAgICAgICAgICAgIDEgIT09IHRoaXMuYmxlbmRpbmcgJiYgKGQuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nKTtcclxuICAgICAgICAgICAgMiAhPT0gdGhpcy5zaGFkaW5nICYmIChkLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmcpO1xyXG4gICAgICAgICAgICAwICE9PSB0aGlzLnNpZGUgJiYgKGQuc2lkZSA9IHRoaXMuc2lkZSk7XHJcbiAgICAgICAgICAgIDAgIT09IHRoaXMudmVydGV4Q29sb3JzICYmIChkLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzKTtcclxuICAgICAgICAgICAgMSA+IHRoaXMub3BhY2l0eSAmJiAoZC5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5KTtcclxuICAgICAgICAgICAgITAgPT09IHRoaXMudHJhbnNwYXJlbnQgJiYgKGQudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50KTtcclxuICAgICAgICAgICAgZC5kZXB0aEZ1bmMgPSB0aGlzLmRlcHRoRnVuYztcclxuICAgICAgICAgICAgZC5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcclxuICAgICAgICAgICAgZC5kZXB0aFdyaXRlID0gdGhpcy5kZXB0aFdyaXRlO1xyXG4gICAgICAgICAgICAwIDwgdGhpcy5hbHBoYVRlc3QgJiYgKGQuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3QpO1xyXG4gICAgICAgICAgICAhMCA9PT0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgJiYgKGQucHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEpO1xyXG4gICAgICAgICAgICAhMCA9PT0gdGhpcy53aXJlZnJhbWUgJiYgKGQud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWUpO1xyXG4gICAgICAgICAgICAxIDwgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggJiYgKGQud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGgpO1xyXG4gICAgICAgICAgICBcInJvdW5kXCIgIT09IHRoaXMud2lyZWZyYW1lTGluZWNhcCAmJiAoZC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwKTtcclxuICAgICAgICAgICAgXCJyb3VuZFwiICE9PSB0aGlzLndpcmVmcmFtZUxpbmVqb2luICYmIChkLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbik7XHJcbiAgICAgICAgICAgIGQuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xyXG4gICAgICAgICAgICBkLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgICAgICBjICYmIChjID0gYihhLnRleHR1cmVzKSwgYSA9IGIoYS5pbWFnZXMpLCAwIDwgYy5sZW5ndGggJiYgKGQudGV4dHVyZXMgPSBjKSwgMCA8IGEubGVuZ3RoICYmIChkLmltYWdlcyA9IGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRcclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5uYW1lID0gYS5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmZvZyA9IGEuZm9nO1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0cyA9IGEubGlnaHRzO1xyXG4gICAgICAgICAgICB0aGlzLmJsZW5kaW5nID0gYS5ibGVuZGluZztcclxuICAgICAgICAgICAgdGhpcy5zaWRlID0gYS5zaWRlO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRpbmcgPSBhLnNoYWRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGV4Q29sb3JzID0gYS52ZXJ0ZXhDb2xvcnM7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGEub3BhY2l0eTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGEudHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRTcmMgPSBhLmJsZW5kU3JjO1xyXG4gICAgICAgICAgICB0aGlzLmJsZW5kRHN0ID0gYS5ibGVuZERzdDtcclxuICAgICAgICAgICAgdGhpcy5ibGVuZEVxdWF0aW9uID0gYS5ibGVuZEVxdWF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmJsZW5kU3JjQWxwaGEgPSBhLmJsZW5kU3JjQWxwaGE7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmREc3RBbHBoYSA9XHJcbiAgICAgICAgICAgICAgICBhLmJsZW5kRHN0QWxwaGE7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gYS5ibGVuZEVxdWF0aW9uQWxwaGE7XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhGdW5jID0gYS5kZXB0aEZ1bmM7XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUZXN0ID0gYS5kZXB0aFRlc3Q7XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhXcml0ZSA9IGEuZGVwdGhXcml0ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvcldyaXRlID0gYS5jb2xvcldyaXRlO1xyXG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvbiA9IGEucHJlY2lzaW9uO1xyXG4gICAgICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBhLnBvbHlnb25PZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IGEucG9seWdvbk9mZnNldEZhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBhLnBvbHlnb25PZmZzZXRVbml0cztcclxuICAgICAgICAgICAgdGhpcy5hbHBoYVRlc3QgPSBhLmFscGhhVGVzdDtcclxuICAgICAgICAgICAgdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBhLnByZW11bHRpcGxpZWRBbHBoYTtcclxuICAgICAgICAgICAgdGhpcy5vdmVyZHJhdyA9IGEub3ZlcmRyYXc7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGEudmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5jbGlwU2hhZG93cyA9IGEuY2xpcFNoYWRvd3M7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IGEuY2xpcEludGVyc2VjdGlvbjtcclxuICAgICAgICAgICAgYSA9IGEuY2xpcHBpbmdQbGFuZXM7XHJcbiAgICAgICAgICAgIHZhciBiID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKG51bGwgIT09IGEpZm9yICh2YXIgYyA9IGEubGVuZ3RoLCBiID0gQXJyYXkoYyksIGQgPSAwOyBkICE9PSBjOyArK2QpYltkXSA9IGFbZF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGlwcGluZ1BsYW5lcyA9IGI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogXCJ1cGRhdGVcIn0pXHJcbiAgICAgICAgfSwgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6IFwiZGlzcG9zZVwifSlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihYLnByb3RvdHlwZSwgcGEucHJvdG90eXBlKTtcclxuICAgIEhhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoWC5wcm90b3R5cGUpO1xyXG4gICAgSGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGE7XHJcbiAgICBIYS5wcm90b3R5cGUuaXNTaGFkZXJNYXRlcmlhbCA9ICEwO1xyXG4gICAgSGEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIFgucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gYS5mcmFnbWVudFNoYWRlcjtcclxuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9XHJcbiAgICAgICAgICAgIGEudmVydGV4U2hhZGVyO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBKYS5jbG9uZShhLnVuaWZvcm1zKTtcclxuICAgICAgICB0aGlzLmRlZmluZXMgPSBhLmRlZmluZXM7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWUgPSBhLndpcmVmcmFtZTtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGEud2lyZWZyYW1lTGluZXdpZHRoO1xyXG4gICAgICAgIHRoaXMubGlnaHRzID0gYS5saWdodHM7XHJcbiAgICAgICAgdGhpcy5jbGlwcGluZyA9IGEuY2xpcHBpbmc7XHJcbiAgICAgICAgdGhpcy5za2lubmluZyA9IGEuc2tpbm5pbmc7XHJcbiAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMgPSBhLm1vcnBoVGFyZ2V0cztcclxuICAgICAgICB0aGlzLm1vcnBoTm9ybWFscyA9IGEubW9ycGhOb3JtYWxzO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGEuZXh0ZW5zaW9ucztcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIEhhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGEgPSBYLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICBhLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcclxuICAgICAgICBhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xyXG4gICAgICAgIGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xyXG4gICAgICAgIHJldHVybiBhXHJcbiAgICB9O1xyXG4gICAgYWIucHJvdG90eXBlID1cclxuICAgICAgICBPYmplY3QuY3JlYXRlKFgucHJvdG90eXBlKTtcclxuICAgIGFiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGFiO1xyXG4gICAgYWIucHJvdG90eXBlLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSAhMDtcclxuICAgIGFiLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBYLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgYSk7XHJcbiAgICAgICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBhLmRlcHRoUGFja2luZztcclxuICAgICAgICB0aGlzLnNraW5uaW5nID0gYS5za2lubmluZztcclxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGEubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgIHRoaXMubWFwID0gYS5tYXA7XHJcbiAgICAgICAgdGhpcy5hbHBoYU1hcCA9IGEuYWxwaGFNYXA7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBhLmRpc3BsYWNlbWVudE1hcDtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gYS5kaXNwbGFjZW1lbnRTY2FsZTtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBhLmRpc3BsYWNlbWVudEJpYXM7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWUgPSBhLndpcmVmcmFtZTtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGEud2lyZWZyYW1lTGluZXdpZHRoO1xyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9O1xyXG4gICAgUGEucHJvdG90eXBlID1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBQYSwgaXNCb3gzOiAhMCwgc2V0OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLm1pbi5jb3B5KGEpO1xyXG4gICAgICAgICAgICB0aGlzLm1heC5jb3B5KGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21BcnJheTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IEluZmluaXR5LCBjID0gSW5maW5pdHksIGQgPSBJbmZpbml0eSwgZSA9IC1JbmZpbml0eSwgZiA9IC1JbmZpbml0eSwgZyA9IC1JbmZpbml0eSwgaCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIG0gPSBhLmxlbmd0aDsgaCA8IG07IGggKz0gMykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGsgPSBhW2hdLCBsID0gYVtoICsgMV0sIHAgPSBhW2ggKyAyXTtcclxuICAgICAgICAgICAgICAgIGsgPCBiICYmIChiID0gayk7XHJcbiAgICAgICAgICAgICAgICBsIDwgYyAmJiAoYyA9IGwpO1xyXG4gICAgICAgICAgICAgICAgcCA8IGQgJiYgKGQgPSBwKTtcclxuICAgICAgICAgICAgICAgIGsgPiBlICYmIChlID0gayk7XHJcbiAgICAgICAgICAgICAgICBsID4gZiAmJiAoZiA9IGwpO1xyXG4gICAgICAgICAgICAgICAgcCA+IGcgJiYgKGcgPSBwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWluLnNldChiLCBjLCBkKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguc2V0KGUsIGYsIGcpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSBJbmZpbml0eSwgYyA9IEluZmluaXR5LCBkID0gSW5maW5pdHksIGUgPSAtSW5maW5pdHksIGYgPSAtSW5maW5pdHksIGcgPSAtSW5maW5pdHksIGggPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICBtID0gYS5jb3VudDsgaCA8IG07IGgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGsgPVxyXG4gICAgICAgICAgICAgICAgICAgIGEuZ2V0WChoKSwgbCA9IGEuZ2V0WShoKSwgcCA9IGEuZ2V0WihoKTtcclxuICAgICAgICAgICAgICAgIGsgPCBiICYmIChiID0gayk7XHJcbiAgICAgICAgICAgICAgICBsIDwgYyAmJiAoYyA9IGwpO1xyXG4gICAgICAgICAgICAgICAgcCA8IGQgJiYgKGQgPSBwKTtcclxuICAgICAgICAgICAgICAgIGsgPiBlICYmIChlID0gayk7XHJcbiAgICAgICAgICAgICAgICBsID4gZiAmJiAoZiA9IGwpO1xyXG4gICAgICAgICAgICAgICAgcCA+IGcgJiYgKGcgPSBwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWluLnNldChiLCBjLCBkKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguc2V0KGUsIGYsIGcpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwLCBjID0gYS5sZW5ndGg7IGIgPCBjOyBiKyspdGhpcy5leHBhbmRCeVBvaW50KGFbYl0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYiwgYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBhLmNvcHkoYykubXVsdGlwbHlTY2FsYXIoLjUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW4uY29weShiKS5zdWIoZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heC5jb3B5KGIpLmFkZChkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZEJ5T2JqZWN0KGEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAobmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcylcclxuICAgICAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4uY29weShhLm1pbik7XHJcbiAgICAgICAgICAgIHRoaXMubWF4LmNvcHkoYS5tYXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4LnggPCB0aGlzLm1pbi54IHx8IHRoaXMubWF4LnkgPCB0aGlzLm1pbi55IHx8IHRoaXMubWF4LnogPCB0aGlzLm1pbi56XHJcbiAgICAgICAgfSwgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYSB8fCBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gYS5zZXQoMCwgMCwgMCkgOiBhLmFkZFZlY3RvcnModGhpcy5taW4sIHRoaXMubWF4KS5tdWx0aXBseVNjYWxhciguNSlcclxuICAgICAgICB9LCBnZXRTaXplOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYSB8fCBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID9cclxuICAgICAgICAgICAgICAgIGEuc2V0KDAsIDAsIDApIDogYS5zdWJWZWN0b3JzKHRoaXMubWF4LCB0aGlzLm1pbilcclxuICAgICAgICB9LCBleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbi5taW4oYSk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4Lm1heChhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4uc3ViKGEpO1xyXG4gICAgICAgICAgICB0aGlzLm1heC5hZGQoYSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluLmFkZFNjYWxhcigtYSk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4LmFkZFNjYWxhcihhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBleHBhbmRCeU9iamVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGIudXBkYXRlTWF0cml4V29ybGQoITApO1xyXG4gICAgICAgICAgICAgICAgYi50cmF2ZXJzZShmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlLCBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBiLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUpaWYgKGUuaXNHZW9tZXRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGUudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGYgPSBnLmxlbmd0aDsgZSA8IGY7IGUrKylhLmNvcHkoZ1tlXSksIGEuYXBwbHlNYXRyaXg0KGIubWF0cml4V29ybGQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5leHBhbmRCeVBvaW50KGEpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmlzQnVmZmVyR2VvbWV0cnkgJiYgKGcgPSBlLmF0dHJpYnV0ZXMucG9zaXRpb24sIHZvaWQgMCAhPT0gZykpZm9yIChlID0gMCwgZiA9IGcuY291bnQ7IGUgPCBmOyBlKyspYS5mcm9tQnVmZmVyQXR0cmlidXRlKGcsIGUpLmFwcGx5TWF0cml4NChiLm1hdHJpeFdvcmxkKSwgYy5leHBhbmRCeVBvaW50KGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnggPCB0aGlzLm1pbi54IHx8IGEueCA+IHRoaXMubWF4LnggfHwgYS55IDwgdGhpcy5taW4ueSB8fCBhLnkgPiB0aGlzLm1heC55IHx8IGEueiA8IHRoaXMubWluLnogfHwgYS56ID4gdGhpcy5tYXgueiA/ICExIDogITBcclxuICAgICAgICB9LCBjb250YWluc0JveDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluLnggPD0gYS5taW4ueCAmJiBhLm1heC54IDw9IHRoaXMubWF4LnggJiYgdGhpcy5taW4ueSA8PSBhLm1pbi55ICYmIGEubWF4LnkgPD0gdGhpcy5tYXgueSAmJiB0aGlzLm1pbi56IDw9IGEubWluLnogJiYgYS5tYXgueiA8PSB0aGlzLm1heC56XHJcbiAgICAgICAgfSwgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYiB8fCBuZXcgcSkuc2V0KChhLnggLSB0aGlzLm1pbi54KSAvICh0aGlzLm1heC54IC0gdGhpcy5taW4ueCksIChhLnkgLSB0aGlzLm1pbi55KSAvICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSksIChhLnogLSB0aGlzLm1pbi56KSAvICh0aGlzLm1heC56IC0gdGhpcy5taW4ueikpXHJcbiAgICAgICAgfSwgaW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEubWF4LnggPCB0aGlzLm1pbi54IHx8IGEubWluLnggPiB0aGlzLm1heC54IHx8IGEubWF4LnkgPCB0aGlzLm1pbi55IHx8IGEubWluLnkgPiB0aGlzLm1heC55IHx8IGEubWF4LnogPCB0aGlzLm1pbi56IHx8IGEubWluLnogPiB0aGlzLm1heC56ID8gITEgOiAhMFxyXG4gICAgICAgIH0sIGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFtcFBvaW50KGIuY2VudGVyLCBhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmRpc3RhbmNlVG9TcXVhcmVkKGIuY2VudGVyKSA8PSBiLnJhZGl1cyAqIGIucmFkaXVzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIsXHJcbiAgICAgICAgICAgICAgICBjO1xyXG4gICAgICAgICAgICAwIDwgYS5ub3JtYWwueCA/IChiID0gYS5ub3JtYWwueCAqIHRoaXMubWluLngsIGMgPSBhLm5vcm1hbC54ICogdGhpcy5tYXgueCkgOiAoYiA9IGEubm9ybWFsLnggKiB0aGlzLm1heC54LCBjID0gYS5ub3JtYWwueCAqIHRoaXMubWluLngpO1xyXG4gICAgICAgICAgICAwIDwgYS5ub3JtYWwueSA/IChiICs9IGEubm9ybWFsLnkgKiB0aGlzLm1pbi55LCBjICs9IGEubm9ybWFsLnkgKiB0aGlzLm1heC55KSA6IChiICs9IGEubm9ybWFsLnkgKiB0aGlzLm1heC55LCBjICs9IGEubm9ybWFsLnkgKiB0aGlzLm1pbi55KTtcclxuICAgICAgICAgICAgMCA8IGEubm9ybWFsLnogPyAoYiArPSBhLm5vcm1hbC56ICogdGhpcy5taW4ueiwgYyArPSBhLm5vcm1hbC56ICogdGhpcy5tYXgueikgOiAoYiArPSBhLm5vcm1hbC56ICogdGhpcy5tYXgueiwgYyArPSBhLm5vcm1hbC56ICogdGhpcy5taW4ueik7XHJcbiAgICAgICAgICAgIHJldHVybiBiIDw9IGEuY29uc3RhbnQgJiYgYyA+PSBhLmNvbnN0YW50XHJcbiAgICAgICAgfSwgY2xhbXBQb2ludDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChiIHx8IG5ldyBxKS5jb3B5KGEpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heClcclxuICAgICAgICB9LCBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jb3B5KGIpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heCkuc3ViKGIpLmxlbmd0aCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIgfHwgbmV3IE5hO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDZW50ZXIoYi5jZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgYi5yYWRpdXMgPSAuNSAqIHRoaXMuZ2V0U2l6ZShhKS5sZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGludGVyc2VjdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4ubWF4KGEubWluKTtcclxuICAgICAgICAgICAgdGhpcy5tYXgubWluKGEubWF4KTtcclxuICAgICAgICAgICAgdGhpcy5pc0VtcHR5KCkgJiYgdGhpcy5tYWtlRW1wdHkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB1bmlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4ubWluKGEubWluKTtcclxuICAgICAgICAgICAgdGhpcy5tYXgubWF4KGEubWF4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBbbmV3IHEsIG5ldyBxLCBuZXcgcSwgbmV3IHEsIG5ldyBxLCBuZXcgcSwgbmV3IHEsIG5ldyBxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICBhWzBdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICBhWzFdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICBhWzJdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICBhWzNdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICBhWzRdLnNldCh0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICBhWzVdLnNldCh0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICBhWzZdLnNldCh0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICBhWzddLnNldCh0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoYik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21Qb2ludHMoYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLFxyXG4gICAgICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbi5hZGQoYSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heC5hZGQoYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9LCBlcXVhbHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLm1pbi5lcXVhbHModGhpcy5taW4pICYmIGEubWF4LmVxdWFscyh0aGlzLm1heClcclxuICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIE5hLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogTmEsIHNldDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXIuY29weShhKTtcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYiwgYykge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IFBhKTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5jZW50ZXI7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGMgPyBkLmNvcHkoYykgOiBhLnNldEZyb21Qb2ludHMoYikuZ2V0Q2VudGVyKGQpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDAsIGYgPSAwLCBnID0gYi5sZW5ndGg7IGYgPCBnOyBmKyspZSA9IE1hdGgubWF4KGUsIGQuZGlzdGFuY2VUb1NxdWFyZWQoYltmXSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5jb3B5KGEuY2VudGVyKTtcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBhLnJhZGl1cztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBlbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMCA+PSB0aGlzLnJhZGl1c1xyXG4gICAgICAgIH0sIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKSA8PSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzXHJcbiAgICAgICAgfSwgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5kaXN0YW5jZVRvKHRoaXMuY2VudGVyKSAtIHRoaXMucmFkaXVzXHJcbiAgICAgICAgfSwgaW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnJhZGl1cyArIGEucmFkaXVzO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpIDw9IGIgKiBiXHJcbiAgICAgICAgfSwgaW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuaW50ZXJzZWN0c1NwaGVyZSh0aGlzKVxyXG4gICAgICAgIH0sIGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuY2VudGVyLmRvdChhLm5vcm1hbCkgLVxyXG4gICAgICAgICAgICAgICAgICAgIGEuY29uc3RhbnQpIDw9IHRoaXMucmFkaXVzXHJcbiAgICAgICAgfSwgY2xhbXBQb2ludDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChhKSwgZCA9IGIgfHwgbmV3IHE7XHJcbiAgICAgICAgICAgIGQuY29weShhKTtcclxuICAgICAgICAgICAgYyA+IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgJiYgKGQuc3ViKHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKSwgZC5tdWx0aXBseVNjYWxhcih0aGlzLnJhZGl1cykuYWRkKHRoaXMuY2VudGVyKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkXHJcbiAgICAgICAgfSwgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEgPSBhIHx8IG5ldyBQYTtcclxuICAgICAgICAgICAgYS5zZXQodGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyKTtcclxuICAgICAgICAgICAgYS5leHBhbmRCeVNjYWxhcih0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSwgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoYSk7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaXVzICo9IGEuZ2V0TWF4U2NhbGVPbkF4aXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0cmFuc2xhdGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyLmFkZChhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBlcXVhbHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpICYmXHJcbiAgICAgICAgICAgICAgICBhLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXNcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgeWEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB5YSwgaXNNYXRyaXgzOiAhMCwgc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgbSkge1xyXG4gICAgICAgICAgICB2YXIgayA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGtbMF0gPSBhO1xyXG4gICAgICAgICAgICBrWzFdID0gZDtcclxuICAgICAgICAgICAga1syXSA9IGc7XHJcbiAgICAgICAgICAgIGtbM10gPSBiO1xyXG4gICAgICAgICAgICBrWzRdID0gZTtcclxuICAgICAgICAgICAga1s1XSA9IGg7XHJcbiAgICAgICAgICAgIGtbNl0gPSBjO1xyXG4gICAgICAgICAgICBrWzddID0gZjtcclxuICAgICAgICAgICAga1s4XSA9IG07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgaWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3RvcikuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSA9IGEuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KGFbMF0sIGFbM10sIGFbNl0sIGFbMV0sIGFbNF0sIGFbN10sIGFbMl0sIGFbNV0sIGFbOF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21NYXRyaXg0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYS5lbGVtZW50cztcclxuICAgICAgICAgICAgdGhpcy5zZXQoYVswXSwgYVs0XSwgYVs4XSwgYVsxXSwgYVs1XSwgYVs5XSxcclxuICAgICAgICAgICAgICAgIGFbMl0sIGFbNl0sIGFbMTBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBhcHBseVRvQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBxKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGIuY291bnQ7IGMgPCBkOyBjKyspYS54ID0gYi5nZXRYKGMpLCBhLnkgPSBiLmdldFkoYyksIGEueiA9IGIuZ2V0WihjKSwgYS5hcHBseU1hdHJpeDModGhpcyksIGIuc2V0WFlaKGMsIGEueCwgYS55LCBhLnopO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgYlswXSAqPSBhO1xyXG4gICAgICAgICAgICBiWzNdICo9IGE7XHJcbiAgICAgICAgICAgIGJbNl0gKj0gYTtcclxuICAgICAgICAgICAgYlsxXSAqPSBhO1xyXG4gICAgICAgICAgICBiWzRdICo9IGE7XHJcbiAgICAgICAgICAgIGJbN10gKj0gYTtcclxuICAgICAgICAgICAgYlsyXSAqPSBhO1xyXG4gICAgICAgICAgICBiWzVdICo9IGE7XHJcbiAgICAgICAgICAgIGJbOF0gKj0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZWxlbWVudHMsIGIgPSBhWzBdLCBjID0gYVsxXSwgZCA9IGFbMl0sIGUgPSBhWzNdLCBmID0gYVs0XSwgZyA9IGFbNV0sIGggPSBhWzZdLCBtID0gYVs3XSxcclxuICAgICAgICAgICAgICAgIGEgPSBhWzhdO1xyXG4gICAgICAgICAgICByZXR1cm4gYiAqIGYgKiBhIC0gYiAqIGcgKiBtIC0gYyAqIGUgKlxyXG4gICAgICAgICAgICAgICAgYSArIGMgKiBnICogaCArIGQgKiBlICogbSAtIGQgKiBmICogaFxyXG4gICAgICAgIH0sIGdldEludmVyc2U6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGEgJiYgYS5pc01hdHJpeDQgJiYgY29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDMuZ2V0SW52ZXJzZSBubyBsb25nZXIgdGFrZXMgYSBNYXRyaXg0IGFyZ3VtZW50LlwiKTtcclxuICAgICAgICAgICAgdmFyIGMgPSBhLmVsZW1lbnRzLCBkID0gdGhpcy5lbGVtZW50cywgZSA9IGNbMF0sIGYgPSBjWzFdLCBnID0gY1syXSwgaCA9IGNbM10sIG0gPSBjWzRdLCBrID0gY1s1XSwgbCA9IGNbNl0sXHJcbiAgICAgICAgICAgICAgICBwID0gY1s3XSwgYyA9IGNbOF0sIG4gPSBjICogbSAtIGsgKiBwLCB1ID0gayAqIGwgLSBjICogaCwgcSA9IHAgKiBoIC0gbSAqIGwsIHIgPSBlICogbiArIGYgKiB1ICsgZyAqIHE7XHJcbiAgICAgICAgICAgIGlmICgwID09PSByKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoITAgPT09IGIpdGhyb3cgRXJyb3IoXCJUSFJFRS5NYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHIgPSAxIC8gcjtcclxuICAgICAgICAgICAgZFswXSA9IG4gKiByO1xyXG4gICAgICAgICAgICBkWzFdID0gKGcgKiBwIC0gYyAqIGYpICogcjtcclxuICAgICAgICAgICAgZFsyXSA9IChrICogZiAtIGcgKiBtKSAqIHI7XHJcbiAgICAgICAgICAgIGRbM10gPSB1ICogcjtcclxuICAgICAgICAgICAgZFs0XSA9IChjICogZSAtIGcgKiBsKSAqIHI7XHJcbiAgICAgICAgICAgIGRbNV0gPSAoZyAqIGggLSBrICogZSkgKiByO1xyXG4gICAgICAgICAgICBkWzZdID0gcSAqIHI7XHJcbiAgICAgICAgICAgIGRbN10gPSAoZiAqIGwgLSBwICogZSkgKiByO1xyXG4gICAgICAgICAgICBkWzhdID0gKG0gKiBlIC0gZiAqIGgpICogcjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGIgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBhID0gYlsxXTtcclxuICAgICAgICAgICAgYlsxXSA9IGJbM107XHJcbiAgICAgICAgICAgIGJbM10gPSBhO1xyXG4gICAgICAgICAgICBhID0gYlsyXTtcclxuICAgICAgICAgICAgYlsyXSA9IGJbNl07XHJcbiAgICAgICAgICAgIGJbNl0gPSBhO1xyXG4gICAgICAgICAgICBhID0gYls1XTtcclxuICAgICAgICAgICAgYls1XSA9IGJbN107XHJcbiAgICAgICAgICAgIGJbN10gPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldE5vcm1hbE1hdHJpeDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQoYSkuZ2V0SW52ZXJzZSh0aGlzKS50cmFuc3Bvc2UoKVxyXG4gICAgICAgIH0sIHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBhWzBdID0gYlswXTtcclxuICAgICAgICAgICAgYVsxXSA9IGJbM107XHJcbiAgICAgICAgICAgIGFbMl0gPSBiWzZdO1xyXG4gICAgICAgICAgICBhWzNdID0gYlsxXTtcclxuICAgICAgICAgICAgYVs0XSA9IGJbNF07XHJcbiAgICAgICAgICAgIGFbNV0gPSBiWzddO1xyXG4gICAgICAgICAgICBhWzZdID0gYlsyXTtcclxuICAgICAgICAgICAgYVs3XSA9IGJbNV07XHJcbiAgICAgICAgICAgIGFbOF0gPSBiWzhdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAwKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IDkgPiBjOyBjKyspdGhpcy5lbGVtZW50c1tjXSA9IGFbYyArIGJdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHRvQXJyYXk6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IFtdKTtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMCk7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgYVtiXSA9IGNbMF07XHJcbiAgICAgICAgICAgIGFbYiArIDFdID0gY1sxXTtcclxuICAgICAgICAgICAgYVtiICsgMl0gPSBjWzJdO1xyXG4gICAgICAgICAgICBhW2IgKyAzXSA9IGNbM107XHJcbiAgICAgICAgICAgIGFbYiArIDRdID0gY1s0XTtcclxuICAgICAgICAgICAgYVtiICsgNV0gPSBjWzVdO1xyXG4gICAgICAgICAgICBhW2IgKyA2XSA9IGNbNl07XHJcbiAgICAgICAgICAgIGFbYiArIDddID0gY1s3XTtcclxuICAgICAgICAgICAgYVtiICsgOF0gPSBjWzhdO1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBsYS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGxhLCBzZXQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9ybWFsLmNvcHkoYSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnQgPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldENvbXBvbmVudHM6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9ybWFsLnNldChhLCBiLCBjKTtcclxuICAgICAgICAgICAgdGhpcy5jb25zdGFudCA9IGQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uIChhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYikge1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbC5jb3B5KGEpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50ID0gLWIuZG90KHRoaXMubm9ybWFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRGcm9tQ29wbGFuYXJQb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgICAgIGQgPSBhLnN1YlZlY3RvcnMoZSwgZCkuY3Jvc3MoYi5zdWJWZWN0b3JzKGMsIGQpKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoZCwgYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWwuY29weShhLm5vcm1hbCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnQgPSBhLmNvbnN0YW50O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IDEgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoYSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnQgKj0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50ICo9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbC5kb3QoYSkgKyB0aGlzLmNvbnN0YW50XHJcbiAgICAgICAgfSwgZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGEuY2VudGVyKSAtIGEucmFkaXVzXHJcbiAgICAgICAgfSwgcHJvamVjdFBvaW50OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcnRob1BvaW50KGEsIGIpLnN1YihhKS5uZWdhdGUoKVxyXG4gICAgICAgIH0sIG9ydGhvUG9pbnQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoYSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYiB8fCBuZXcgcSkuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoYylcclxuICAgICAgICB9LCBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYiwgYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBjIHx8IG5ldyBxLCBlID0gYi5kZWx0YShhKSwgZiA9IHRoaXMubm9ybWFsLmRvdChlKTtcclxuICAgICAgICAgICAgICAgIGlmICgwID09PSBmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IHRoaXMuZGlzdGFuY2VUb1BvaW50KGIuc3RhcnQpKXJldHVybiBkLmNvcHkoYi5zdGFydClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gZiA9IC0oYi5zdGFydC5kb3QodGhpcy5ub3JtYWwpICsgdGhpcy5jb25zdGFudCkgLyBmLCAwID4gZiB8fCAxIDwgZiA/IHZvaWQgMCA6IGQuY29weShlKS5tdWx0aXBseVNjYWxhcihmKS5hZGQoYi5zdGFydClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgaW50ZXJzZWN0c0xpbmU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoYS5zdGFydCk7XHJcbiAgICAgICAgICAgIGEgPSB0aGlzLmRpc3RhbmNlVG9Qb2ludChhLmVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiAwID4gYiAmJiAwIDwgYSB8fCAwID4gYSAmJiAwIDwgYlxyXG4gICAgICAgIH0sIGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmludGVyc2VjdHNQbGFuZSh0aGlzKVxyXG4gICAgICAgIH0sIGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmludGVyc2VjdHNQbGFuZSh0aGlzKVxyXG4gICAgICAgIH0sIGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSB8fCBuZXcgcSkuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoLXRoaXMuY29uc3RhbnQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyB5YTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuY29wbGFuYXJQb2ludChhKS5hcHBseU1hdHJpeDQoYyksIGYgPSBkIHx8IGIuZ2V0Tm9ybWFsTWF0cml4KGMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMoZikubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0YW50ID0gLWUuZG90KGYpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgdHJhbnNsYXRlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50IC09IGEuZG90KHRoaXMubm9ybWFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBlcXVhbHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpICYmIGEuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGMucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0Yywgc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMucGxhbmVzO1xyXG4gICAgICAgICAgICBnWzBdLmNvcHkoYSk7XHJcbiAgICAgICAgICAgIGdbMV0uY29weShiKTtcclxuICAgICAgICAgICAgZ1syXS5jb3B5KGMpO1xyXG4gICAgICAgICAgICBnWzNdLmNvcHkoZCk7XHJcbiAgICAgICAgICAgIGdbNF0uY29weShlKTtcclxuICAgICAgICAgICAgZ1s1XS5jb3B5KGYpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcylcclxuICAgICAgICB9LCBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5wbGFuZXMsIGMgPSAwOyA2ID4gYzsgYysrKWJbY10uY29weShhLnBsYW5lc1tjXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnBsYW5lcywgYyA9IGEuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGEgPSBjWzBdO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGNbMV0sIGUgPSBjWzJdLCBmID0gY1szXSwgZyA9IGNbNF0sIGggPSBjWzVdLCBtID0gY1s2XSwgayA9IGNbN10sIGwgPSBjWzhdLCBwID0gY1s5XSwgbiA9IGNbMTBdLFxyXG4gICAgICAgICAgICAgICAgdSA9IGNbMTFdLCBxID0gY1sxMl0sIHIgPSBjWzEzXSwgQSA9IGNbMTRdLCBjID0gY1sxNV07XHJcbiAgICAgICAgICAgIGJbMF0uc2V0Q29tcG9uZW50cyhmIC0gYSwgayAtIGcsIHUgLSBsLCBjIC0gcSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGJbMV0uc2V0Q29tcG9uZW50cyhmICsgYSwgayArIGcsIHUgKyBsLCBjICsgcSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGJbMl0uc2V0Q29tcG9uZW50cyhmICsgZCwgayArIGgsIHUgKyBwLCBjICsgcikubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGJbM10uc2V0Q29tcG9uZW50cyhmIC1cclxuICAgICAgICAgICAgICAgIGQsIGsgLSBoLCB1IC0gcCwgYyAtIHIpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBiWzRdLnNldENvbXBvbmVudHMoZiAtIGUsIGsgLSBtLCB1IC0gbiwgYyAtIEEpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBiWzVdLnNldENvbXBvbmVudHMoZiArIGUsIGsgKyBtLCB1ICsgbiwgYyArIEEpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGludGVyc2VjdHNPYmplY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgTmE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBiLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gYy5ib3VuZGluZ1NwaGVyZSAmJiBjLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG4gICAgICAgICAgICAgICAgYS5jb3B5KGMuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChiLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgaW50ZXJzZWN0c1Nwcml0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBOYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICBhLmNlbnRlci5zZXQoMCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBhLnJhZGl1cyA9IC43MDcxMDY3ODExODY1NDc2O1xyXG4gICAgICAgICAgICAgICAgYS5hcHBseU1hdHJpeDQoYi5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKGEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksXHJcbiAgICAgICAgaW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnBsYW5lcywgYyA9IGEuY2VudGVyO1xyXG4gICAgICAgICAgICBhID0gLWEucmFkaXVzO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgNiA+IGQ7IGQrKylpZiAoYltkXS5kaXN0YW5jZVRvUG9pbnQoYykgPCBhKXJldHVybiAhMTtcclxuICAgICAgICAgICAgcmV0dXJuICEwXHJcbiAgICAgICAgfSwgaW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxLCBiID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IHRoaXMucGxhbmVzLCBlID0gMDsgNiA+IGU7IGUrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gZFtlXTtcclxuICAgICAgICAgICAgICAgICAgICBhLnggPSAwIDwgZi5ub3JtYWwueCA/IGMubWluLnggOiBjLm1heC54O1xyXG4gICAgICAgICAgICAgICAgICAgIGIueCA9IDAgPCBmLm5vcm1hbC54ID8gYy5tYXgueCA6IGMubWluLng7XHJcbiAgICAgICAgICAgICAgICAgICAgYS55ID0gMCA8IGYubm9ybWFsLnkgPyBjLm1pbi55IDogYy5tYXgueTtcclxuICAgICAgICAgICAgICAgICAgICBiLnkgPSAwIDwgZi5ub3JtYWwueSA/IGMubWF4LnkgOiBjLm1pbi55O1xyXG4gICAgICAgICAgICAgICAgICAgIGEueiA9IDAgPCBmLm5vcm1hbC56ID8gYy5taW4ueiA6IGMubWF4Lno7XHJcbiAgICAgICAgICAgICAgICAgICAgYi56ID0gMCA8IGYubm9ybWFsLnogPyBjLm1heC56IDogYy5taW4uejtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGYuZGlzdGFuY2VUb1BvaW50KGEpLCBmID0gZi5kaXN0YW5jZVRvUG9pbnQoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnICYmIDAgPiBmKXJldHVybiAhMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLnBsYW5lcywgYyA9IDA7IDYgPiBjOyBjKyspaWYgKDAgPiBiW2NdLmRpc3RhbmNlVG9Qb2ludChhKSlyZXR1cm4gITE7XHJcbiAgICAgICAgICAgIHJldHVybiAhMFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjYi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGNiLCBzZXQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmNvcHkoYSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLmNvcHkoYik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmNvcHkoYS5vcmlnaW4pO1xyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KGEuZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBhdDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChiIHx8IG5ldyBxKS5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihhKS5hZGQodGhpcy5vcmlnaW4pXHJcbiAgICAgICAgfSwgbG9va0F0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KGEpLnN1Yih0aGlzLm9yaWdpbikubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcmVjYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4uY29weSh0aGlzLmF0KGIsIGEpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYiB8fCBuZXcgcTtcclxuICAgICAgICAgICAgYy5zdWJWZWN0b3JzKGEsIHRoaXMub3JpZ2luKTtcclxuICAgICAgICAgICAgdmFyIGQgPSBjLmRvdCh0aGlzLmRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiAwID4gZCA/IGMuY29weSh0aGlzLm9yaWdpbikgOiBjLmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGQpLmFkZCh0aGlzLm9yaWdpbilcclxuICAgICAgICB9LCBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG9Qb2ludChhKSlcclxuICAgICAgICB9LCBkaXN0YW5jZVNxVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gYS5zdWJWZWN0b3JzKGIsIHRoaXMub3JpZ2luKS5kb3QodGhpcy5kaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKDAgPiBjKXJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZChiKTtcclxuICAgICAgICAgICAgICAgIGEuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoYykuYWRkKHRoaXMub3JpZ2luKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmRpc3RhbmNlVG9TcXVhcmVkKGIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxLCBjID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCwgZSwgZiwgZykge1xyXG4gICAgICAgICAgICAgICAgYS5jb3B5KGQpLmFkZChlKS5tdWx0aXBseVNjYWxhciguNSk7XHJcbiAgICAgICAgICAgICAgICBiLmNvcHkoZSkuc3ViKGQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgYy5jb3B5KHRoaXMub3JpZ2luKS5zdWIoYSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IC41ICogZC5kaXN0YW5jZVRvKGUpLCBtID0gLXRoaXMuZGlyZWN0aW9uLmRvdChiKSwgayA9IGMuZG90KHRoaXMuZGlyZWN0aW9uKSwgbCA9IC1jLmRvdChiKSxcclxuICAgICAgICAgICAgICAgICAgICBwID0gYy5sZW5ndGhTcSgpLCBuID0gTWF0aC5hYnMoMSAtIG0gKiBtKSwgdTtcclxuICAgICAgICAgICAgICAgIDAgPCBuID8gKGQgPSBtICogbCAtIGssIGUgPSBtICogayAtIGwsIHUgPSBoICogbiwgMCA8PSBkID8gZSA+PSAtdSA/IGUgPD0gdSA/IChoID0gMSAvIG4sIGQgKj0gaCwgZSAqPSBoLCBtID0gZCAqIChkICsgbSAqIGUgKyAyICogaykgKyBlICogKG0gKiBkICsgZSArIDIgKiBsKSArIHApIDogKGUgPSBoLCBkID0gTWF0aC5tYXgoMCwgLShtICpcclxuICAgICAgICAgICAgICAgIGUgKyBrKSksIG0gPSAtZCAqIGQgKyBlICogKGUgKyAyICogbCkgKyBwKSA6IChlID0gLWgsIGQgPSBNYXRoLm1heCgwLCAtKG0gKiBlICsgaykpLCBtID0gLWQgKiBkICsgZSAqIChlICsgMiAqIGwpICsgcCkgOiBlIDw9IC11ID8gKGQgPSBNYXRoLm1heCgwLCAtKC1tICogaCArIGspKSwgZSA9IDAgPCBkID8gLWggOiBNYXRoLm1pbihNYXRoLm1heCgtaCwgLWwpLCBoKSwgbSA9IC1kICogZCArIGUgKiAoZSArIDIgKiBsKSArIHApIDogZSA8PSB1ID8gKGQgPSAwLCBlID0gTWF0aC5taW4oTWF0aC5tYXgoLWgsIC1sKSwgaCksIG0gPSBlICogKGUgKyAyICogbCkgKyBwKSA6IChkID0gTWF0aC5tYXgoMCwgLShtICogaCArIGspKSwgZSA9IDAgPCBkID8gaCA6IE1hdGgubWluKE1hdGgubWF4KC1oLCAtbCksIGgpLCBtID0gLWQgKiBkICsgZSAqIChlICsgMiAqIGwpICsgcCkpIDogKGUgPSAwIDwgbSA/IC1oIDogaCwgZCA9IE1hdGgubWF4KDAsIC0obSAqIGUgKyBrKSksIG0gPSAtZCAqIGQgKyBlICogKGUgKyAyICogbCkgKyBwKTtcclxuICAgICAgICAgICAgICAgIGYgJiYgZi5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihkKS5hZGQodGhpcy5vcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgZyAmJiBnLmNvcHkoYikubXVsdGlwbHlTY2FsYXIoZSkuYWRkKGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgaW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYiwgYykge1xyXG4gICAgICAgICAgICAgICAgYS5zdWJWZWN0b3JzKGIuY2VudGVyLCB0aGlzLm9yaWdpbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGEuZG90KHRoaXMuZGlyZWN0aW9uKSwgZSA9IGEuZG90KGEpIC0gZCAqIGQsIGYgPSBiLnJhZGl1cyAqIGIucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgPiBmKXJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgZiA9IE1hdGguc3FydChmIC0gZSk7XHJcbiAgICAgICAgICAgICAgICBlID0gZCAtIGY7XHJcbiAgICAgICAgICAgICAgICBkICs9IGY7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCA+IGUgJiYgMCA+IGQgPyBudWxsIDogMCA+IGUgPyB0aGlzLmF0KGQsIGMpIDogdGhpcy5hdChlLCBjKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoYS5jZW50ZXIpIDw9IGEucmFkaXVzXHJcbiAgICAgICAgfSwgZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGEubm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGlmICgwID09PSBiKXJldHVybiAwID09PSBhLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbikgPyAwIDogbnVsbDtcclxuICAgICAgICAgICAgYSA9IC0odGhpcy5vcmlnaW4uZG90KGEubm9ybWFsKSArIGEuY29uc3RhbnQpIC8gYjtcclxuICAgICAgICAgICAgcmV0dXJuIDAgPD0gYSA/IGEgOiBudWxsXHJcbiAgICAgICAgfSwgaW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uIChhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gYyA/IG51bGwgOiB0aGlzLmF0KGMsIGIpXHJcbiAgICAgICAgfSwgaW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGEuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKTtcclxuICAgICAgICAgICAgcmV0dXJuIDAgPT09IGIgfHwgMCA+IGEubm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbikgKiBiID8gITAgOiAhMVxyXG4gICAgICAgIH0sIGludGVyc2VjdEJveDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMsIGQsIGUsIGYsIGc7XHJcbiAgICAgICAgICAgIGQgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueDtcclxuICAgICAgICAgICAgZiA9IDEgLyB0aGlzLmRpcmVjdGlvbi55O1xyXG4gICAgICAgICAgICBnID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XHJcbiAgICAgICAgICAgIHZhciBoID0gdGhpcy5vcmlnaW47XHJcbiAgICAgICAgICAgIDAgPD0gZCA/IChjID0gKGEubWluLnggLSBoLngpICogZCwgZCAqPSBhLm1heC54IC0gaC54KSA6IChjID0gKGEubWF4LnggLSBoLngpICogZCwgZCAqPSBhLm1pbi54IC0gaC54KTtcclxuICAgICAgICAgICAgMCA8PSBmID8gKGUgPSAoYS5taW4ueSAtIGgueSkgKiBmLCBmICo9IGEubWF4LnkgLSBoLnkpIDogKGUgPSAoYS5tYXgueSAtIGgueSkgKiBmLCBmICo9IGEubWluLnkgLSBoLnkpO1xyXG4gICAgICAgICAgICBpZiAoYyA+IGYgfHwgZSA+IGQpcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGlmIChlID4gYyB8fCBjICE9PSBjKSBjID0gZTtcclxuICAgICAgICAgICAgaWYgKGYgPCBkIHx8IGQgIT09IGQpIGQgPSBmO1xyXG4gICAgICAgICAgICAwIDw9IGcgPyAoZSA9IChhLm1pbi56IC0gaC56KSAqIGcsIGcgKj0gYS5tYXgueiAtIGgueikgOiAoZSA9IChhLm1heC56IC0gaC56KSAqIGcsIGcgKj0gYS5taW4ueiAtIGgueik7XHJcbiAgICAgICAgICAgIGlmIChjID4gZyB8fCBlID4gZClyZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGUgPiBjIHx8IGMgIT09IGMpIGMgPSBlO1xyXG4gICAgICAgICAgICBpZiAoZyA8IGQgfHwgZCAhPT0gZCkgZCA9IGc7XHJcbiAgICAgICAgICAgIHJldHVybiAwID4gZCA/IG51bGwgOiB0aGlzLmF0KDAgPD0gYyA/IGMgOiBkLCBiKVxyXG4gICAgICAgIH0sIGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gdGhpcy5pbnRlcnNlY3RCb3goYiwgYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgaW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxLCBjID0gbmV3IHEsIGQgPSBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlLCBmLCBnLCBoLCBtKSB7XHJcbiAgICAgICAgICAgICAgICBiLnN1YlZlY3RvcnMoZiwgZSk7XHJcbiAgICAgICAgICAgICAgICBjLnN1YlZlY3RvcnMoZywgZSk7XHJcbiAgICAgICAgICAgICAgICBkLmNyb3NzVmVjdG9ycyhiLCBjKTtcclxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLmRpcmVjdGlvbi5kb3QoZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA8IGYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaClyZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBoID0gMVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgwID4gZikgaCA9XHJcbiAgICAgICAgICAgICAgICAgICAgLTEsIGYgPSAtZjsgZWxzZSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIGEuc3ViVmVjdG9ycyh0aGlzLm9yaWdpbiwgZSk7XHJcbiAgICAgICAgICAgICAgICBlID0gaCAqIHRoaXMuZGlyZWN0aW9uLmRvdChjLmNyb3NzVmVjdG9ycyhhLCBjKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA+IGUpcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBnID0gaCAqIHRoaXMuZGlyZWN0aW9uLmRvdChiLmNyb3NzKGEpKTtcclxuICAgICAgICAgICAgICAgIGlmICgwID4gZyB8fCBlICsgZyA+IGYpcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBlID0gLWggKiBhLmRvdChkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwID4gZSA/IG51bGwgOiB0aGlzLmF0KGUgLyBmLCBtKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLmFkZCh0aGlzLm9yaWdpbikuYXBwbHlNYXRyaXg0KGEpO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoYSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnN1Yih0aGlzLm9yaWdpbik7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGVxdWFsczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEub3JpZ2luLmVxdWFscyh0aGlzLm9yaWdpbikgJiYgYS5kaXJlY3Rpb24uZXF1YWxzKHRoaXMuZGlyZWN0aW9uKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBkYi5Sb3RhdGlvbk9yZGVycyA9XHJcbiAgICAgICAgXCJYWVogWVpYIFpYWSBYWlkgWVhaIFpZWFwiLnNwbGl0KFwiIFwiKTtcclxuICAgIGRiLkRlZmF1bHRPcmRlciA9IFwiWFlaXCI7XHJcbiAgICBkYi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGRiLCBpc0V1bGVyOiAhMCwgZ2V0IHgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94XHJcbiAgICAgICAgfSwgc2V0IHgoYSkge1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gYTtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKClcclxuICAgICAgICB9LCBnZXQgeSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3lcclxuICAgICAgICB9LCBzZXQgeShhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBhO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKVxyXG4gICAgICAgIH0sIGdldCB6KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5felxyXG4gICAgICAgIH0sIHNldCB6KGEpIHtcclxuICAgICAgICAgICAgdGhpcy5feiA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpXHJcbiAgICAgICAgfSwgZ2V0IG9yZGVyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXJcclxuICAgICAgICB9LCBzZXQgb3JkZXIoYSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vcmRlciA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpXHJcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gYTtcclxuICAgICAgICAgICAgdGhpcy5feSA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBjO1xyXG4gICAgICAgICAgICB0aGlzLl9vcmRlciA9IGQgfHwgdGhpcy5fb3JkZXI7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSBhLl94O1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYS5feTtcclxuICAgICAgICAgICAgdGhpcy5feiA9IGEuX3o7XHJcbiAgICAgICAgICAgIHRoaXMuX29yZGVyID0gYS5fb3JkZXI7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBOLmNsYW1wLCBlID0gYS5lbGVtZW50cztcclxuICAgICAgICAgICAgYSA9IGVbMF07XHJcbiAgICAgICAgICAgIHZhciBmID0gZVs0XSwgZyA9IGVbOF0sIGggPSBlWzFdLCBtID0gZVs1XSwgayA9IGVbOV0sIGwgPSBlWzJdLCBwID0gZVs2XSwgZSA9IGVbMTBdO1xyXG4gICAgICAgICAgICBiID0gYiB8fCB0aGlzLl9vcmRlcjtcclxuICAgICAgICAgICAgXCJYWVpcIiA9PT0gYiA/ICh0aGlzLl95ID0gTWF0aC5hc2luKGQoZywgLTEsIDEpKSwgLjk5OTk5ID4gTWF0aC5hYnMoZykgPyAodGhpcy5feCA9IE1hdGguYXRhbjIoLWssIGUpLCB0aGlzLl96ID0gTWF0aC5hdGFuMigtZiwgYSkpIDogKHRoaXMuX3ggPSBNYXRoLmF0YW4yKHAsIG0pLCB0aGlzLl96ID0gMCkpIDogXCJZWFpcIiA9PT1cclxuICAgICAgICAgICAgYiA/ICh0aGlzLl94ID0gTWF0aC5hc2luKC1kKGssIC0xLCAxKSksIC45OTk5OSA+IE1hdGguYWJzKGspID8gKHRoaXMuX3kgPSBNYXRoLmF0YW4yKGcsIGUpLCB0aGlzLl96ID0gTWF0aC5hdGFuMihoLCBtKSkgOiAodGhpcy5feSA9IE1hdGguYXRhbjIoLWwsIGEpLCB0aGlzLl96ID0gMCkpIDogXCJaWFlcIiA9PT0gYiA/ICh0aGlzLl94ID0gTWF0aC5hc2luKGQocCwgLTEsIDEpKSwgLjk5OTk5ID4gTWF0aC5hYnMocCkgPyAodGhpcy5feSA9IE1hdGguYXRhbjIoLWwsIGUpLCB0aGlzLl96ID0gTWF0aC5hdGFuMigtZiwgbSkpIDogKHRoaXMuX3kgPSAwLCB0aGlzLl96ID0gTWF0aC5hdGFuMihoLCBhKSkpIDogXCJaWVhcIiA9PT0gYiA/ICh0aGlzLl95ID0gTWF0aC5hc2luKC1kKGwsIC0xLCAxKSksIC45OTk5OSA+IE1hdGguYWJzKGwpID8gKHRoaXMuX3ggPSBNYXRoLmF0YW4yKHAsIGUpLCB0aGlzLl96ID0gTWF0aC5hdGFuMihoLCBhKSkgOiAodGhpcy5feCA9IDAsIHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1mLCBtKSkpIDogXCJZWlhcIiA9PT0gYiA/ICh0aGlzLl96ID0gTWF0aC5hc2luKGQoaCwgLTEsIDEpKSwgLjk5OTk5ID4gTWF0aC5hYnMoaCkgPyAodGhpcy5feCA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmF0YW4yKC1rLCBtKSwgdGhpcy5feSA9IE1hdGguYXRhbjIoLWwsIGEpKSA6ICh0aGlzLl94ID0gMCwgdGhpcy5feSA9IE1hdGguYXRhbjIoZywgZSkpKSA6IFwiWFpZXCIgPT09IGIgPyAodGhpcy5feiA9IE1hdGguYXNpbigtZChmLCAtMSwgMSkpLCAuOTk5OTkgPiBNYXRoLmFicyhmKSA/ICh0aGlzLl94ID0gTWF0aC5hdGFuMihwLCBtKSwgdGhpcy5feSA9IE1hdGguYXRhbjIoZywgYSkpIDogKHRoaXMuX3ggPSBNYXRoLmF0YW4yKC1rLCBlKSwgdGhpcy5feSA9IDApKSA6IGNvbnNvbGUud2FybihcIlRIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6IFwiICsgYik7XHJcbiAgICAgICAgICAgIHRoaXMuX29yZGVyID0gYjtcclxuICAgICAgICAgICAgaWYgKCExICE9PSBjKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgUyk7XHJcbiAgICAgICAgICAgICAgICBhLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KGEsXHJcbiAgICAgICAgICAgICAgICAgICAgYywgZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgc2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChhLngsIGEueSwgYS56LCBiIHx8IHRoaXMuX29yZGVyKVxyXG4gICAgICAgIH0sIHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgY2E7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgYS5zZXRGcm9tRXVsZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbihhLCBiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBlcXVhbHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLl94ID09PSB0aGlzLl94ICYmIGEuX3kgPT09IHRoaXMuX3kgJiYgYS5feiA9PT0gdGhpcy5feiAmJiBhLl9vcmRlciA9PT0gdGhpcy5fb3JkZXJcclxuICAgICAgICB9LCBmcm9tQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSBhWzBdO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYVsxXTtcclxuICAgICAgICAgICAgdGhpcy5feiA9IGFbMl07XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYVszXSAmJiAodGhpcy5fb3JkZXIgPSBhWzNdKTtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgdG9BcnJheTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gW10pO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAwKTtcclxuICAgICAgICAgICAgYVtiXSA9IHRoaXMuX3g7XHJcbiAgICAgICAgICAgIGFbYiArIDFdID1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3k7XHJcbiAgICAgICAgICAgIGFbYiArIDJdID0gdGhpcy5fejtcclxuICAgICAgICAgICAgYVtiICsgM10gPSB0aGlzLl9vcmRlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCB0b1ZlY3RvcjM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhID8gYS5zZXQodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feikgOiBuZXcgcSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96KVxyXG4gICAgICAgIH0sIG9uQ2hhbmdlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbmQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBuZCwgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hc2sgPSAxIDw8IGFcclxuICAgICAgICB9LCBlbmFibGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFzayB8PSAxIDw8IGFcclxuICAgICAgICB9LCB0b2dnbGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFzayBePSAxIDw8IGFcclxuICAgICAgICB9LCBkaXNhYmxlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hc2sgJj0gfigxIDw8IGEpXHJcbiAgICAgICAgfSwgdGVzdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAgIT09ICh0aGlzLm1hc2sgJiBhLm1hc2spXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBCZiA9IDA7XHJcbiAgICB4LkRlZmF1bHRVcCA9IG5ldyBxKDAsIDEsIDApO1xyXG4gICAgeC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSA9XHJcbiAgICAgICAgITA7XHJcbiAgICB4LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogeCwgaXNPYmplY3QzRDogITAsIGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGEsIHRoaXMubWF0cml4KTtcclxuICAgICAgICAgICAgdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSlcclxuICAgICAgICB9LCBzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKGEsIGIpXHJcbiAgICAgICAgfSwgc2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoYSwgITApXHJcbiAgICAgICAgfSwgc2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGEpXHJcbiAgICAgICAgfSwgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoYSlcclxuICAgICAgICB9LCByb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgY2E7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjKSB7XHJcbiAgICAgICAgICAgICAgICBhLnNldEZyb21BeGlzQW5nbGUoYiwgYyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCByb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHEoMSwgMCwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGEsIGIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSgwLCAxLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoYSwgYilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgcm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxKDAsIDAsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhhLCBiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCB0cmFuc2xhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICBhLmNvcHkoYikuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZChhLm11bHRpcGx5U2NhbGFyKGMpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksXHJcbiAgICAgICAgdHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxKDEsIDAsIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhhLCBiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCB0cmFuc2xhdGVZOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHEoMCwgMSwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGEsIGIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSgwLCAwLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoYSwgYilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgbG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZClcclxuICAgICAgICB9LCB3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgUztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5hcHBseU1hdHJpeDQoYS5nZXRJbnZlcnNlKHRoaXMubWF0cml4V29ybGQpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgUztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICBhLmxvb2tBdChiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24sIHRoaXMudXApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBhZGQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBhcmd1bWVudHMubGVuZ3RoOyBiKyspdGhpcy5hZGQoYXJndW1lbnRzW2JdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGEgPT09IHRoaXMpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiwgYSksIHRoaXM7XHJcbiAgICAgICAgICAgIGEgJiYgYS5pc09iamVjdDNEID8gKG51bGwgIT09IGEucGFyZW50ICYmIGEucGFyZW50LnJlbW92ZShhKSwgYS5wYXJlbnQgPSB0aGlzLCBhLmRpc3BhdGNoRXZlbnQoe3R5cGU6IFwiYWRkZWRcIn0pLCB0aGlzLmNoaWxkcmVuLnB1c2goYSkpIDogY29uc29sZS5lcnJvcihcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgYSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpZiAoMSA8XHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoKWZvciAodmFyIGIgPSAwOyBiIDwgYXJndW1lbnRzLmxlbmd0aDsgYisrKXRoaXMucmVtb3ZlKGFyZ3VtZW50c1tiXSk7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoYSk7XHJcbiAgICAgICAgICAgIC0xICE9PSBiICYmIChhLnBhcmVudCA9IG51bGwsIGEuZGlzcGF0Y2hFdmVudCh7dHlwZTogXCJyZW1vdmVkXCJ9KSwgdGhpcy5jaGlsZHJlbi5zcGxpY2UoYiwgMSkpXHJcbiAgICAgICAgfSwgZ2V0T2JqZWN0QnlJZDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eShcImlkXCIsIGEpXHJcbiAgICAgICAgfSwgZ2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KFwibmFtZVwiLCBhKVxyXG4gICAgICAgIH0sIGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzW2FdID09PSBiKXJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgZCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBjIDwgZDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuY2hpbGRyZW5bY10uZ2V0T2JqZWN0QnlQcm9wZXJ0eShhLCBiKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUpcmV0dXJuIGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0V29ybGRQb3NpdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSA9IGEgfHwgbmV3IHE7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoITApO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZClcclxuICAgICAgICB9LCBnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjIHx8IG5ldyBjYTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoITApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoYSwgYywgYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IGNhO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiIHx8IG5ldyBkYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuc2V0RnJvbVF1YXRlcm5pb24oYSwgdGhpcy5yb3RhdGlvbi5vcmRlciwgITEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBjYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gYyB8fCBuZXcgcTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoITApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoYSwgYiwgYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBjYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICBiID0gYiB8fCBuZXcgcTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuc2V0KDAsIDAsIDEpLmFwcGx5UXVhdGVybmlvbihhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCByYXljYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfSwgdHJhdmVyc2U6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEodGhpcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmNoaWxkcmVuLCBjID0gMCwgZCA9IGIubGVuZ3RoOyBjIDwgZDsgYysrKWJbY10udHJhdmVyc2UoYSlcclxuICAgICAgICB9LCB0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmICghMSAhPT0gdGhpcy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBhKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMuY2hpbGRyZW4sIGMgPSAwLCBkID0gYi5sZW5ndGg7IGMgPCBkOyBjKyspYltjXS50cmF2ZXJzZVZpc2libGUoYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICBudWxsICE9PSBiICYmIChhKGIpLCBiLnRyYXZlcnNlQW5jZXN0b3JzKGEpKVxyXG4gICAgICAgIH0sIHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9ICEwXHJcbiAgICAgICAgfSwgdXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICEwID09PSB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgJiYgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgICAgICAgICAgaWYgKCEwID09PSB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgITAgPT09IGEpIG51bGwgPT09IHRoaXMucGFyZW50ID8gdGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KSA6IHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXgpLCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSAhMSwgYSA9ICEwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5jaGlsZHJlbiwgYyA9IDAsIGQgPSBiLmxlbmd0aDsgYyA8IGQ7IGMrKyliW2NdLnVwZGF0ZU1hdHJpeFdvcmxkKGEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBbXSwgYztcclxuICAgICAgICAgICAgICAgIGZvciAoYyBpbiBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBhW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkLm1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGIucHVzaChkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGMgPSB2b2lkIDAgPT09IGEgfHwgXCJcIiA9PT0gYSwgZCA9IHt9O1xyXG4gICAgICAgICAgICBjICYmIChhID0ge2dlb21ldHJpZXM6IHt9LCBtYXRlcmlhbHM6IHt9LCB0ZXh0dXJlczoge30sIGltYWdlczoge319LCBkLm1ldGFkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJPYmplY3RcIixcclxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogXCJPYmplY3QzRC50b0pTT05cIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGUgPSB7fTtcclxuICAgICAgICAgICAgZS51dWlkID0gdGhpcy51dWlkO1xyXG4gICAgICAgICAgICBlLnR5cGUgPSB0aGlzLnR5cGU7XHJcbiAgICAgICAgICAgIFwiXCIgIT09IHRoaXMubmFtZSAmJiAoZS5uYW1lID0gdGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgXCJ7fVwiICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJEYXRhKSAmJiAoZS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGEpO1xyXG4gICAgICAgICAgICAhMCA9PT0gdGhpcy5jYXN0U2hhZG93ICYmIChlLmNhc3RTaGFkb3cgPSAhMCk7XHJcbiAgICAgICAgICAgICEwID09PSB0aGlzLnJlY2VpdmVTaGFkb3cgJiYgKGUucmVjZWl2ZVNoYWRvdyA9ICEwKTtcclxuICAgICAgICAgICAgITEgPT09IHRoaXMudmlzaWJsZSAmJlxyXG4gICAgICAgICAgICAoZS52aXNpYmxlID0gITEpO1xyXG4gICAgICAgICAgICBlLm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLmdlb21ldHJ5ICYmICh2b2lkIDAgPT09IGEuZ2VvbWV0cmllc1t0aGlzLmdlb21ldHJ5LnV1aWRdICYmIChhLmdlb21ldHJpZXNbdGhpcy5nZW9tZXRyeS51dWlkXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKGEpKSwgZS5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZCk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy5tYXRlcmlhbCAmJiAodm9pZCAwID09PSBhLm1hdGVyaWFsc1t0aGlzLm1hdGVyaWFsLnV1aWRdICYmIChhLm1hdGVyaWFsc1t0aGlzLm1hdGVyaWFsLnV1aWRdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oYSkpLCBlLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkKTtcclxuICAgICAgICAgICAgaWYgKDAgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZS5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgZisrKWUuY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ZdLnRvSlNPTihhKS5vYmplY3QpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID1cclxuICAgICAgICAgICAgICAgICAgICBiKGEuZ2VvbWV0cmllcyksIGYgPSBiKGEubWF0ZXJpYWxzKSwgZyA9IGIoYS50ZXh0dXJlcyk7XHJcbiAgICAgICAgICAgICAgICBhID0gYihhLmltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAwIDwgYy5sZW5ndGggJiYgKGQuZ2VvbWV0cmllcyA9IGMpO1xyXG4gICAgICAgICAgICAgICAgMCA8IGYubGVuZ3RoICYmIChkLm1hdGVyaWFscyA9IGYpO1xyXG4gICAgICAgICAgICAgICAgMCA8IGcubGVuZ3RoICYmIChkLnRleHR1cmVzID0gZyk7XHJcbiAgICAgICAgICAgICAgICAwIDwgYS5sZW5ndGggJiYgKGQuaW1hZ2VzID0gYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkLm9iamVjdCA9IGU7XHJcbiAgICAgICAgICAgIHJldHVybiBkXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcywgYSlcclxuICAgICAgICB9LCBjb3B5OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAhMCk7XHJcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGEubmFtZTtcclxuICAgICAgICAgICAgdGhpcy51cC5jb3B5KGEudXApO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkoYS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KGEucXVhdGVybmlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUuY29weShhLnNjYWxlKTtcclxuICAgICAgICAgICAgdGhpcy5tYXRyaXguY29weShhLm1hdHJpeCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weShhLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID1cclxuICAgICAgICAgICAgICAgIGEubWF0cml4QXV0b1VwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gYS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xyXG4gICAgICAgICAgICB0aGlzLmxheWVycy5tYXNrID0gYS5sYXllcnMubWFzaztcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gYS52aXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLmNhc3RTaGFkb3cgPSBhLmNhc3RTaGFkb3c7XHJcbiAgICAgICAgICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IGEucmVjZWl2ZVNoYWRvdztcclxuICAgICAgICAgICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gYS5mcnVzdHVtQ3VsbGVkO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck9yZGVyID0gYS5yZW5kZXJPcmRlcjtcclxuICAgICAgICAgICAgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYS51c2VyRGF0YSkpO1xyXG4gICAgICAgICAgICBpZiAoITAgPT09IGIpZm9yICh2YXIgYyA9IDA7IGMgPCBhLmNoaWxkcmVuLmxlbmd0aDsgYysrKXRoaXMuYWRkKGEuY2hpbGRyZW5bY10uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oeC5wcm90b3R5cGUsIHBhLnByb3RvdHlwZSk7XHJcbiAgICBoYi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGhiLCBzZXQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuY29weShhKTtcclxuICAgICAgICAgICAgdGhpcy5lbmQuY29weShiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydC5jb3B5KGEuc3RhcnQpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZC5jb3B5KGEuZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBnZXRDZW50ZXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSB8fCBuZXcgcSkuYWRkVmVjdG9ycyh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkubXVsdGlwbHlTY2FsYXIoLjUpXHJcbiAgICAgICAgfSwgZGVsdGE6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSB8fCBuZXcgcSkuc3ViVmVjdG9ycyh0aGlzLmVuZCwgdGhpcy5zdGFydClcclxuICAgICAgICB9LCBkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuZW5kKVxyXG4gICAgICAgIH0sIGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8odGhpcy5lbmQpXHJcbiAgICAgICAgfSwgYXQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYiB8fCBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGEoYykubXVsdGlwbHlTY2FsYXIoYSkuYWRkKHRoaXMuc3RhcnQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHEsIGIgPSBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICBhLnN1YlZlY3RvcnMoYywgdGhpcy5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICBiLnN1YlZlY3RvcnModGhpcy5lbmQsIHRoaXMuc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBiLmRvdChiKSwgZSA9IGIuZG90KGEpIC8gZTtcclxuICAgICAgICAgICAgICAgIGQgJiYgKGUgPSBOLmNsYW1wKGUsIDAsIDEpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGEgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoYSwgYik7XHJcbiAgICAgICAgICAgIGMgPSBjIHx8IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWx0YShjKS5tdWx0aXBseVNjYWxhcihhKS5hZGQodGhpcy5zdGFydClcclxuICAgICAgICB9LCBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KGEpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZC5hcHBseU1hdHJpeDQoYSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZXF1YWxzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydC5lcXVhbHModGhpcy5zdGFydCkgJiYgYS5lbmQuZXF1YWxzKHRoaXMuZW5kKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB6YS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGEgPSBuZXcgcTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgZSA9IGUgfHwgbmV3IHE7XHJcbiAgICAgICAgICAgIGUuc3ViVmVjdG9ycyhkLCBjKTtcclxuICAgICAgICAgICAgYS5zdWJWZWN0b3JzKGIsIGMpO1xyXG4gICAgICAgICAgICBlLmNyb3NzKGEpO1xyXG4gICAgICAgICAgICBiID0gZS5sZW5ndGhTcSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gMCA8IGIgPyBlLm11bHRpcGx5U2NhbGFyKDEgLyBNYXRoLnNxcnQoYikpIDogZS5zZXQoMCwgMCwgMClcclxuICAgICAgICB9XHJcbiAgICB9KCk7XHJcbiAgICB6YS5iYXJ5Y29vcmRGcm9tUG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxLCBjID0gbmV3IHE7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBlLCBmLCBnLCBoKSB7XHJcbiAgICAgICAgICAgIGEuc3ViVmVjdG9ycyhnLCBlKTtcclxuICAgICAgICAgICAgYi5zdWJWZWN0b3JzKGYsIGUpO1xyXG4gICAgICAgICAgICBjLnN1YlZlY3RvcnMoZCwgZSk7XHJcbiAgICAgICAgICAgIGQgPSBhLmRvdChhKTtcclxuICAgICAgICAgICAgZSA9IGEuZG90KGIpO1xyXG4gICAgICAgICAgICBmID0gYS5kb3QoYyk7XHJcbiAgICAgICAgICAgIHZhciBtID0gYi5kb3QoYik7XHJcbiAgICAgICAgICAgIGcgPSBiLmRvdChjKTtcclxuICAgICAgICAgICAgdmFyIGsgPSBkICogbSAtIGUgKiBlO1xyXG4gICAgICAgICAgICBoID0gaCB8fCBuZXcgcTtcclxuICAgICAgICAgICAgaWYgKDAgPT09IGspcmV0dXJuIGguc2V0KC0yLCAtMSwgLTEpO1xyXG4gICAgICAgICAgICBrID0gMSAvIGs7XHJcbiAgICAgICAgICAgIG0gPSAobSAqIGYgLSBlICogZykgKiBrO1xyXG4gICAgICAgICAgICBkID0gKGQgKiBnIC0gZSAqIGYpICogaztcclxuICAgICAgICAgICAgcmV0dXJuIGguc2V0KDEgLSBtIC1cclxuICAgICAgICAgICAgICAgIGQsIGQsIG0pXHJcbiAgICAgICAgfVxyXG4gICAgfSgpO1xyXG4gICAgemEuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYSA9IG5ldyBxO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYiwgYywgZCwgZSkge1xyXG4gICAgICAgICAgICBiID0gemEuYmFyeWNvb3JkRnJvbVBvaW50KGIsIGMsIGQsIGUsIGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gMCA8PSBiLnggJiYgMCA8PSBiLnkgJiYgMSA+PSBiLnggKyBiLnlcclxuICAgICAgICB9XHJcbiAgICB9KCk7XHJcbiAgICB6YS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IHphLCBzZXQ6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYS5jb3B5KGEpO1xyXG4gICAgICAgICAgICB0aGlzLmIuY29weShiKTtcclxuICAgICAgICAgICAgdGhpcy5jLmNvcHkoYyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYS5jb3B5KGFbYl0pO1xyXG4gICAgICAgICAgICB0aGlzLmIuY29weShhW2NdKTtcclxuICAgICAgICAgICAgdGhpcy5jLmNvcHkoYVtkXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYS5jb3B5KGEuYSk7XHJcbiAgICAgICAgICAgIHRoaXMuYi5jb3B5KGEuYik7XHJcbiAgICAgICAgICAgIHRoaXMuYy5jb3B5KGEuYyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcmVhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHEsIGIgPSBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGEuc3ViVmVjdG9ycyh0aGlzLmMsIHRoaXMuYik7XHJcbiAgICAgICAgICAgICAgICBiLnN1YlZlY3RvcnModGhpcy5hLCB0aGlzLmIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC41ICogYS5jcm9zcyhiKS5sZW5ndGgoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBtaWRwb2ludDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhIHx8IG5ldyBxKS5hZGRWZWN0b3JzKHRoaXMuYSwgdGhpcy5iKS5hZGQodGhpcy5jKS5tdWx0aXBseVNjYWxhcigxIC8gMylcclxuICAgICAgICB9LCBub3JtYWw6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB6YS5ub3JtYWwodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgYSlcclxuICAgICAgICB9LCBwbGFuZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhIHx8IG5ldyBsYSkuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMpXHJcbiAgICAgICAgfSwgYmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gemEuYmFyeWNvb3JkRnJvbVBvaW50KGEsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIGIpXHJcbiAgICAgICAgfSwgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHphLmNvbnRhaW5zUG9pbnQoYSxcclxuICAgICAgICAgICAgICAgIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMpXHJcbiAgICAgICAgfSwgY2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYiwgYywgZDtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlLCBmKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgbGEsIGIgPSBbbmV3IGhiLCBuZXcgaGIsIG5ldyBoYl0sIGMgPSBuZXcgcSwgZCA9IG5ldyBxKTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gZiB8fCBuZXcgcSwgaCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgYS5zZXRGcm9tQ29wbGFuYXJQb2ludHModGhpcy5hLCB0aGlzLmIsIHRoaXMuYyk7XHJcbiAgICAgICAgICAgICAgICBhLnByb2plY3RQb2ludChlLCBjKTtcclxuICAgICAgICAgICAgICAgIGlmICghMCA9PT0gdGhpcy5jb250YWluc1BvaW50KGMpKSBnLmNvcHkoYyk7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJbMF0uc2V0KHRoaXMuYSwgdGhpcy5iKTtcclxuICAgICAgICAgICAgICAgICAgICBiWzFdLnNldCh0aGlzLmIsIHRoaXMuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYlsyXS5zZXQodGhpcy5jLCB0aGlzLmEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgYi5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiW21dLmNsb3Nlc3RQb2ludFRvUG9pbnQoYywgITAsIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGMuZGlzdGFuY2VUb1NxdWFyZWQoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPCBoICYmIChoID0gaywgZy5jb3B5KGQpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGVxdWFsczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuYS5lcXVhbHModGhpcy5hKSAmJlxyXG4gICAgICAgICAgICAgICAgYS5iLmVxdWFscyh0aGlzLmIpICYmIGEuYy5lcXVhbHModGhpcy5jKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBoYS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGhhLCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5hID0gYS5hO1xyXG4gICAgICAgICAgICB0aGlzLmIgPSBhLmI7XHJcbiAgICAgICAgICAgIHRoaXMuYyA9IGEuYztcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWwuY29weShhLm5vcm1hbCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IuY29weShhLmNvbG9yKTtcclxuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbEluZGV4ID0gYS5tYXRlcmlhbEluZGV4O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMCwgYyA9IGEudmVydGV4Tm9ybWFscy5sZW5ndGg7IGIgPCBjOyBiKyspdGhpcy52ZXJ0ZXhOb3JtYWxzW2JdID0gYS52ZXJ0ZXhOb3JtYWxzW2JdLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSBhLnZlcnRleENvbG9ycy5sZW5ndGg7IGIgPCBjOyBiKyspdGhpcy52ZXJ0ZXhDb2xvcnNbYl0gPSBhLnZlcnRleENvbG9yc1tiXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFgucHJvdG90eXBlKTtcclxuICAgIEthLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9XHJcbiAgICAgICAgS2E7XHJcbiAgICBLYS5wcm90b3R5cGUuaXNNZXNoQmFzaWNNYXRlcmlhbCA9ICEwO1xyXG4gICAgS2EucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIFgucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoYS5jb2xvcik7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBhLm1hcDtcclxuICAgICAgICB0aGlzLmxpZ2h0TWFwID0gYS5saWdodE1hcDtcclxuICAgICAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gYS5saWdodE1hcEludGVuc2l0eTtcclxuICAgICAgICB0aGlzLmFvTWFwID0gYS5hb01hcDtcclxuICAgICAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gYS5hb01hcEludGVuc2l0eTtcclxuICAgICAgICB0aGlzLnNwZWN1bGFyTWFwID0gYS5zcGVjdWxhck1hcDtcclxuICAgICAgICB0aGlzLmFscGhhTWFwID0gYS5hbHBoYU1hcDtcclxuICAgICAgICB0aGlzLmVudk1hcCA9IGEuZW52TWFwO1xyXG4gICAgICAgIHRoaXMuY29tYmluZSA9IGEuY29tYmluZTtcclxuICAgICAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IGEucmVmbGVjdGl2aXR5O1xyXG4gICAgICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gYS5yZWZyYWN0aW9uUmF0aW87XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWUgPSBhLndpcmVmcmFtZTtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGEud2lyZWZyYW1lTGluZXdpZHRoO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IGEud2lyZWZyYW1lTGluZWNhcDtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gYS53aXJlZnJhbWVMaW5lam9pbjtcclxuICAgICAgICB0aGlzLnNraW5uaW5nID0gYS5za2lubmluZztcclxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGEubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9O1xyXG4gICAgVS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IFUsIGlzQnVmZmVyQXR0cmlidXRlOiAhMCwgc2V0IG5lZWRzVXBkYXRlKGEpIHtcclxuICAgICAgICAgICAgITAgPT09IGEgJiYgdGhpcy52ZXJzaW9uKytcclxuICAgICAgICB9LCBzZXRBcnJheTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gdm9pZCAwICE9PSBhID8gYS5sZW5ndGggLyB0aGlzLml0ZW1TaXplIDogMDtcclxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IGFcclxuICAgICAgICB9LCBzZXREeW5hbWljOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWMgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXkgPVxyXG4gICAgICAgICAgICAgICAgbmV3IGEuYXJyYXkuY29uc3RydWN0b3IoYS5hcnJheSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbVNpemUgPSBhLml0ZW1TaXplO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gYS5jb3VudDtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkID0gYS5ub3JtYWxpemVkO1xyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWMgPSBhLmR5bmFtaWM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY29weUF0OiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBhICo9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgICAgIGMgKj0gYi5pdGVtU2l6ZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDAsIGUgPSB0aGlzLml0ZW1TaXplOyBkIDwgZTsgZCsrKXRoaXMuYXJyYXlbYSArIGRdID0gYi5hcnJheVtjICsgZF07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY29weUFycmF5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5LnNldChhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjb3B5Q29sb3JzQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmFycmF5LCBjID0gMCwgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZCA8IGU7IGQrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBhW2RdO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBmICYmIChjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGQpLCBmID0gbmV3IEopO1xyXG4gICAgICAgICAgICAgICAgYltjKytdID0gZi5yO1xyXG4gICAgICAgICAgICAgICAgYltjKytdID0gZi5nO1xyXG4gICAgICAgICAgICAgICAgYltjKytdID0gZi5iXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjb3B5SW5kaWNlc0FycmF5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5hcnJheSwgYyA9IDAsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGQgPCBlOyBkKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gYVtkXTtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYuYTtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYuYjtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYuY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmFycmF5LCBjID0gMCwgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZCA8IGU7IGQrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBhW2RdO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBmICYmIChjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZFwiLCBkKSwgZiA9IG5ldyBEKTtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYueDtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYueVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmFycmF5LCBjID0gMCwgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZCA8IGU7IGQrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPVxyXG4gICAgICAgICAgICAgICAgICAgIGFbZF07XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGYgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkXCIsIGQpLCBmID0gbmV3IHEpO1xyXG4gICAgICAgICAgICAgICAgYltjKytdID0gZi54O1xyXG4gICAgICAgICAgICAgICAgYltjKytdID0gZi55O1xyXG4gICAgICAgICAgICAgICAgYltjKytdID0gZi56XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMuYXJyYXksIGMgPSAwLCBkID0gMCwgZSA9IGEubGVuZ3RoOyBkIDwgZTsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGFbZF07XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGYgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkXCIsIGQpLCBmID0gbmV3IGZhKTtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYueDtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYueTtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYuejtcclxuICAgICAgICAgICAgICAgIGJbYysrXSA9IGYud1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAwKTtcclxuICAgICAgICAgICAgdGhpcy5hcnJheS5zZXQoYSwgYik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZ2V0WDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbYSAqXHJcbiAgICAgICAgICAgIHRoaXMuaXRlbVNpemVdXHJcbiAgICAgICAgfSwgc2V0WDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5hcnJheVthICogdGhpcy5pdGVtU2l6ZV0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldFk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5W2EgKiB0aGlzLml0ZW1TaXplICsgMV1cclxuICAgICAgICB9LCBzZXRZOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5W2EgKiB0aGlzLml0ZW1TaXplICsgMV0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldFo6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5W2EgKiB0aGlzLml0ZW1TaXplICsgMl1cclxuICAgICAgICB9LCBzZXRaOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5W2EgKiB0aGlzLml0ZW1TaXplICsgMl0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldFc6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5W2EgKiB0aGlzLml0ZW1TaXplICsgM11cclxuICAgICAgICB9LCBzZXRXOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5W2EgKiB0aGlzLml0ZW1TaXplICsgM10gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFhZOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBhICo9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXlbYSArIDBdID0gYjtcclxuICAgICAgICAgICAgdGhpcy5hcnJheVthICtcclxuICAgICAgICAgICAgMV0gPSBjO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFhZWjogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgYSAqPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5W2EgKyAwXSA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXlbYSArIDFdID0gYztcclxuICAgICAgICAgICAgdGhpcy5hcnJheVthICsgMl0gPSBkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFhZWlc6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIGEgKj0gdGhpcy5pdGVtU2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5hcnJheVthICsgMF0gPSBiO1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5W2EgKyAxXSA9IGM7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXlbYSArIDJdID0gZDtcclxuICAgICAgICAgICAgdGhpcy5hcnJheVthICsgM10gPSBlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG9uVXBsb2FkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSkpLmNvcHkodGhpcylcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdWMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVLnByb3RvdHlwZSk7XHJcbiAgICB1Yy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB1YztcclxuICAgIHZjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVS5wcm90b3R5cGUpO1xyXG4gICAgdmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdmM7XHJcbiAgICB3Yy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFUucHJvdG90eXBlKTtcclxuICAgIHdjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHdjO1xyXG4gICAgeGMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVLnByb3RvdHlwZSk7XHJcbiAgICB4Yy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB4YztcclxuICAgIGliLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVS5wcm90b3R5cGUpO1xyXG4gICAgaWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaWI7XHJcbiAgICB5Yy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFUucHJvdG90eXBlKTtcclxuICAgIHljLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHljO1xyXG4gICAgamIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVLnByb3RvdHlwZSk7XHJcbiAgICBqYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBqYjtcclxuICAgIHoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVLnByb3RvdHlwZSk7XHJcbiAgICB6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHo7XHJcbiAgICB6Yy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFUucHJvdG90eXBlKTtcclxuICAgIHpjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHpjO1xyXG4gICAgT2JqZWN0LmFzc2lnbihNZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiwgYyA9IFtdLCBkID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBhID0gYS5mYWNlcztcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBhLmxlbmd0aDsgZSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGFbZV07XHJcbiAgICAgICAgICAgICAgICBmLm1hdGVyaWFsSW5kZXggIT09IGQgJiYgKGQgPSBmLm1hdGVyaWFsSW5kZXgsIHZvaWQgMCAhPT0gYiAmJiAoYi5jb3VudCA9IDMgKiBlIC0gYi5zdGFydCwgYy5wdXNoKGIpKSwgYiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogMyAqIGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleDogZFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGIgJiYgKGIuY291bnQgPSAzICogZSAtIGIuc3RhcnQsIGMucHVzaChiKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gY1xyXG4gICAgICAgIH0sIGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBhLmZhY2VzLCBjID0gYS52ZXJ0aWNlcywgZCA9IGEuZmFjZVZlcnRleFV2cywgZSA9IGRbMF0gJiYgMCA8IGRbMF0ubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgZiA9IGRbMV0gJiYgMCA8IGRbMV0ubGVuZ3RoLCBnID0gYS5tb3JwaFRhcmdldHMsIGggPSBnLmxlbmd0aCwgbTtcclxuICAgICAgICAgICAgaWYgKDAgPCBoKSB7XHJcbiAgICAgICAgICAgICAgICBtID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGg7IGsrKyltW2tdID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgbVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsID0gYS5tb3JwaE5vcm1hbHMsIHAgPSBsLmxlbmd0aCwgbjtcclxuICAgICAgICAgICAgaWYgKDAgPCBwKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcDsgaysrKW5ba10gPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gYS5za2luSW5kaWNlcywgcSA9IGEuc2tpbldlaWdodHMsIHIgPSB1Lmxlbmd0aCA9PT0gYy5sZW5ndGgsIEEgPSBxLmxlbmd0aCA9PT0gYy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgIGsgPSAwOyBrIDwgYi5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBiW2tdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKGNbdy5hXSwgY1t3LmJdLCBjW3cuY10pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB3LnZlcnRleE5vcm1hbHM7XHJcbiAgICAgICAgICAgICAgICAzID09PSB5Lmxlbmd0aCA/IHRoaXMubm9ybWFscy5wdXNoKHlbMF0sIHlbMV0sIHlbMl0pIDogKHkgPSB3Lm5vcm1hbCwgdGhpcy5ub3JtYWxzLnB1c2goeSwgeSwgeSkpO1xyXG4gICAgICAgICAgICAgICAgeSA9IHcudmVydGV4Q29sb3JzO1xyXG4gICAgICAgICAgICAgICAgMyA9PT0geS5sZW5ndGggPyB0aGlzLmNvbG9ycy5wdXNoKHlbMF0sIHlbMV0sIHlbMl0pIDogKHkgPSB3LmNvbG9yLCB0aGlzLmNvbG9ycy5wdXNoKHksIHksIHkpKTtcclxuICAgICAgICAgICAgICAgICEwID09PSBlICYmICh5ID0gZFswXVtrXSwgdm9pZCAwICE9PSB5ID8gdGhpcy51dnMucHVzaCh5WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHlbMV0sIHlbMl0pIDogKGNvbnNvbGUud2FybihcIlRIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgXCIsIGspLCB0aGlzLnV2cy5wdXNoKG5ldyBELCBuZXcgRCwgbmV3IEQpKSk7XHJcbiAgICAgICAgICAgICAgICAhMCA9PT0gZiAmJiAoeSA9IGRbMV1ba10sIHZvaWQgMCAhPT0geSA/IHRoaXMudXZzMi5wdXNoKHlbMF0sIHlbMV0sIHlbMl0pIDogKGNvbnNvbGUud2FybihcIlRIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyIFwiLCBrKSwgdGhpcy51dnMyLnB1c2gobmV3IEQsIG5ldyBELCBuZXcgRCkpKTtcclxuICAgICAgICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBoOyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgSyA9IGdbeV0udmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgbVt5XS5wdXNoKEtbdy5hXSwgS1t3LmJdLCBLW3cuY10pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgcDsgeSsrKUsgPSBsW3ldLnZlcnRleE5vcm1hbHNba10sIG5beV0ucHVzaChLLmEsIEsuYiwgSy5jKTtcclxuICAgICAgICAgICAgICAgIHIgJiYgdGhpcy5za2luSW5kaWNlcy5wdXNoKHVbdy5hXSwgdVt3LmJdLCB1W3cuY10pO1xyXG4gICAgICAgICAgICAgICAgQSAmJiB0aGlzLnNraW5XZWlnaHRzLnB1c2gocVt3LmFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHFbdy5iXSwgcVt3LmNdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUdyb3VwcyhhKTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBhLnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGEubm9ybWFsc05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGEuY29sb3JzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy51dnNOZWVkVXBkYXRlID0gYS51dnNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBhLmdyb3Vwc05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgVmQgPSAwO1xyXG4gICAgVC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IFQsIGlzR2VvbWV0cnk6ICEwLCBhcHBseU1hdHJpeDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IChuZXcgeWEpLmdldE5vcm1hbE1hdHJpeChhKSwgYyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgYyA8IGQ7IGMrKyl0aGlzLnZlcnRpY2VzW2NdLmFwcGx5TWF0cml4NChhKTtcclxuICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoZCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBjIDwgZDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5mYWNlc1tjXTtcclxuICAgICAgICAgICAgICAgIGEubm9ybWFsLmFwcGx5TWF0cml4MyhiKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gYS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgZSA8IGY7IGUrKylhLnZlcnRleE5vcm1hbHNbZV0uYXBwbHlNYXRyaXgzKGIpLm5vcm1hbGl6ZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbnVsbCAhPT0gdGhpcy5ib3VuZGluZ0JveCAmJiB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgICAgICBudWxsICE9PSB0aGlzLmJvdW5kaW5nU3BoZXJlICYmIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9ICEwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IFMpO1xyXG4gICAgICAgICAgICAgICAgYS5tYWtlUm90YXRpb25YKGIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeChhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IFMpO1xyXG4gICAgICAgICAgICAgICAgYS5tYWtlUm90YXRpb25ZKGIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeChhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksXHJcbiAgICAgICAgcm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgUyk7XHJcbiAgICAgICAgICAgICAgICBhLm1ha2VSb3RhdGlvblooYik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBTKTtcclxuICAgICAgICAgICAgICAgIGEubWFrZVRyYW5zbGF0aW9uKGIsIGMsIGQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeChhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIHNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBTKTtcclxuICAgICAgICAgICAgICAgIGEubWFrZVNjYWxlKGIsIGMsIGQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeChhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgeCk7XHJcbiAgICAgICAgICAgICAgICBhLmxvb2tBdChiKTtcclxuICAgICAgICAgICAgICAgIGEudXBkYXRlTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KGEubWF0cml4KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLFxyXG4gICAgICAgIGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gYihhLCBiLCBkLCBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IHZvaWQgMCAhPT0gZyA/IFtsW2FdLmNsb25lKCksIGxbYl0uY2xvbmUoKSwgbFtkXS5jbG9uZSgpXSA6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHUgPSB2b2lkIDAgIT09IGggPyBbYy5jb2xvcnNbYV0uY2xvbmUoKSwgYy5jb2xvcnNbYl0uY2xvbmUoKSwgYy5jb2xvcnNbZF0uY2xvbmUoKV0gOiBbXTtcclxuICAgICAgICAgICAgICAgIGUgPSBuZXcgaGEoYSwgYiwgZCwgZiwgdSwgZSk7XHJcbiAgICAgICAgICAgICAgICBjLmZhY2VzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IG0gJiYgYy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3BbYV0uY2xvbmUoKSwgcFtiXS5jbG9uZSgpLCBwW2RdLmNsb25lKCldKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gayAmJiBjLmZhY2VWZXJ0ZXhVdnNbMV0ucHVzaChbblthXS5jbG9uZSgpLCBuW2JdLmNsb25lKCksIG5bZF0uY2xvbmUoKV0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcywgZCA9IG51bGwgIT09IGEuaW5kZXggPyBhLmluZGV4LmFycmF5IDogdm9pZCAwLCBlID0gYS5hdHRyaWJ1dGVzLCBmID0gZS5wb3NpdGlvbi5hcnJheSxcclxuICAgICAgICAgICAgICAgIGcgPSB2b2lkIDAgIT09IGUubm9ybWFsID8gZS5ub3JtYWwuYXJyYXkgOlxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCwgaCA9IHZvaWQgMCAhPT0gZS5jb2xvciA/IGUuY29sb3IuYXJyYXkgOiB2b2lkIDAsIG0gPSB2b2lkIDAgIT09IGUudXYgPyBlLnV2LmFycmF5IDogdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgayA9IHZvaWQgMCAhPT0gZS51djIgPyBlLnV2Mi5hcnJheSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBrICYmICh0aGlzLmZhY2VWZXJ0ZXhVdnNbMV0gPSBbXSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSBbXSwgcCA9IFtdLCBuID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgIHUgPSBlID0gMDsgZSA8IGYubGVuZ3RoOyBlICs9IDMsIHUgKz0gMiljLnZlcnRpY2VzLnB1c2gobmV3IHEoZltlXSwgZltlICsgMV0sIGZbZSArIDJdKSksIHZvaWQgMCAhPT0gZyAmJiBsLnB1c2gobmV3IHEoZ1tlXSwgZ1tlICsgMV0sIGdbZSArIDJdKSksIHZvaWQgMCAhPT0gaCAmJiBjLmNvbG9ycy5wdXNoKG5ldyBKKGhbZV0sIGhbZSArIDFdLCBoW2UgKyAyXSkpLCB2b2lkIDAgIT09IG0gJiYgcC5wdXNoKG5ldyBEKG1bdV0sIG1bdSArIDFdKSksIHZvaWQgMCAhPT0gayAmJiBuLnB1c2gobmV3IEQoa1t1XSwga1t1ICsgMV0pKTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZClpZiAoZiA9IGEuZ3JvdXBzLCAwIDwgZi5sZW5ndGgpZm9yIChlID0gMDsgZSA8IGYubGVuZ3RoOyBlKyspZm9yICh2YXIgRyA9IGZbZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBHLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBID0gRy5jb3VudCwgdSA9IHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByICsgQTsgdSA8IHI7IHUgKz0gMyliKGRbdV0sIGRbdSArIDFdLCBkW3UgKyAyXSwgRy5tYXRlcmlhbEluZGV4KTsgZWxzZSBmb3IgKGUgPSAwOyBlIDwgZC5sZW5ndGg7IGUgKz0gMyliKGRbZV0sIGRbZSArIDFdLCBkW2UgKyAyXSk7IGVsc2UgZm9yIChlID0gMDsgZSA8IGYubGVuZ3RoIC8gMzsgZSArPSAzKWIoZSwgZSArIDEsIGUgKyAyKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICAgICAgbnVsbCAhPT0gYS5ib3VuZGluZ0JveCAmJiAodGhpcy5ib3VuZGluZ0JveCA9IGEuYm91bmRpbmdCb3guY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIG51bGwgIT09IGEuYm91bmRpbmdTcGhlcmUgJiYgKHRoaXMuYm91bmRpbmdTcGhlcmUgPSBhLmJvdW5kaW5nU3BoZXJlLmNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGEueCwgYS55LCBhLnopO1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH0sIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyLCBiID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMsIGIgPSAwID09PSBiID8gMSA6IDEgLyBiLCBjID0gbmV3IFM7XHJcbiAgICAgICAgICAgIGMuc2V0KGIsIDAsIDAsIC1iICogYS54LCAwLCBiLCAwLCAtYiAqIGEueSwgMCwgMCwgYiwgLWIgKiBhLnosIDAsIDAsIDAsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gbmV3IHEsIGIgPSBuZXcgcSwgYyA9IDAsIGQgPSB0aGlzLmZhY2VzLmxlbmd0aDsgYyA8IGQ7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmZhY2VzW2NdLCBmID0gdGhpcy52ZXJ0aWNlc1tlLmFdLCBnID0gdGhpcy52ZXJ0aWNlc1tlLmJdO1xyXG4gICAgICAgICAgICAgICAgYS5zdWJWZWN0b3JzKHRoaXMudmVydGljZXNbZS5jXSwgZyk7XHJcbiAgICAgICAgICAgICAgICBiLnN1YlZlY3RvcnMoZiwgZyk7XHJcbiAgICAgICAgICAgICAgICBhLmNyb3NzKGIpO1xyXG4gICAgICAgICAgICAgICAgYS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIGUubm9ybWFsLmNvcHkoYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMCk7XHJcbiAgICAgICAgICAgIHZhciBiLCBjLCBkO1xyXG4gICAgICAgICAgICBkID0gQXJyYXkodGhpcy52ZXJ0aWNlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBiID0gMDtcclxuICAgICAgICAgICAgZm9yIChjID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGIgPCBjOyBiKyspZFtiXSA9IG5ldyBxO1xyXG4gICAgICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUsIGYsIGcsIGggPSBuZXcgcSwgbSA9IG5ldyBxO1xyXG4gICAgICAgICAgICAgICAgYSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGIgPSB0aGlzLmZhY2VzLmxlbmd0aDsgYSA8IGI7IGErKyljID0gdGhpcy5mYWNlc1thXSwgZSA9IHRoaXMudmVydGljZXNbYy5hXSwgZiA9IHRoaXMudmVydGljZXNbYy5iXSwgZyA9IHRoaXMudmVydGljZXNbYy5jXSwgaC5zdWJWZWN0b3JzKGcsIGYpLCBtLnN1YlZlY3RvcnMoZSwgZiksIGguY3Jvc3MobSksIGRbYy5hXS5hZGQoaCksIGRbYy5iXS5hZGQoaCksIGRbYy5jXS5hZGQoaClcclxuICAgICAgICAgICAgfSBlbHNlIGZvciAodGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKSwgYSA9IDAsIGIgPSB0aGlzLmZhY2VzLmxlbmd0aDsgYSA8IGI7IGErKyljID0gdGhpcy5mYWNlc1thXSwgZFtjLmFdLmFkZChjLm5vcm1hbCksIGRbYy5iXS5hZGQoYy5ub3JtYWwpLCBkW2MuY10uYWRkKGMubm9ybWFsKTtcclxuICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoYyA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBiIDwgYzsgYisrKWRbYl0ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGEgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGIgPSB0aGlzLmZhY2VzLmxlbmd0aDsgYSA8XHJcbiAgICAgICAgICAgIGI7IGErKyljID0gdGhpcy5mYWNlc1thXSwgZSA9IGMudmVydGV4Tm9ybWFscywgMyA9PT0gZS5sZW5ndGggPyAoZVswXS5jb3B5KGRbYy5hXSksIGVbMV0uY29weShkW2MuYl0pLCBlWzJdLmNvcHkoZFtjLmNdKSkgOiAoZVswXSA9IGRbYy5hXS5jbG9uZSgpLCBlWzFdID0gZFtjLmJdLmNsb25lKCksIGVbMl0gPSBkW2MuY10uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIDAgPCB0aGlzLmZhY2VzLmxlbmd0aCAmJiAodGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9ICEwKVxyXG4gICAgICAgIH0sIGNvbXB1dGVGbGF0VmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYiwgYztcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICAgICAgYSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoYiA9IHRoaXMuZmFjZXMubGVuZ3RoOyBhIDwgYjsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5mYWNlc1thXTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gYy52ZXJ0ZXhOb3JtYWxzO1xyXG4gICAgICAgICAgICAgICAgMyA9PT0gZC5sZW5ndGggPyAoZFswXS5jb3B5KGMubm9ybWFsKSwgZFsxXS5jb3B5KGMubm9ybWFsKSwgZFsyXS5jb3B5KGMubm9ybWFsKSkgOiAoZFswXSA9IGMubm9ybWFsLmNsb25lKCksIGRbMV0gPSBjLm5vcm1hbC5jbG9uZSgpLCBkWzJdID0gYy5ub3JtYWwuY2xvbmUoKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAwIDxcclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5sZW5ndGggJiYgKHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSAhMClcclxuICAgICAgICB9LCBjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBiLCBjLCBkLCBlO1xyXG4gICAgICAgICAgICBjID0gMDtcclxuICAgICAgICAgICAgZm9yIChkID0gdGhpcy5mYWNlcy5sZW5ndGg7IGMgPCBkOyBjKyspZm9yIChlID0gdGhpcy5mYWNlc1tjXSwgZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA/IGUuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weShlLm5vcm1hbCkgOiBlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZS5ub3JtYWwuY2xvbmUoKSwgZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyB8fCAoZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdKSwgYSA9IDAsIGIgPSBlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBhIDwgYjsgYSsrKWUuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbYV0gPyBlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzW2FdLmNvcHkoZS52ZXJ0ZXhOb3JtYWxzW2FdKSA6IGUuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbYV0gPSBlLnZlcnRleE5vcm1hbHNbYV0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgVDtcclxuICAgICAgICAgICAgZi5mYWNlcyA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VzO1xyXG4gICAgICAgICAgICBhID0gMDtcclxuICAgICAgICAgICAgZm9yIChiID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBhIDwgYjsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW9ycGhOb3JtYWxzW2FdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbYV0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1thXS5mYWNlTm9ybWFscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzW2FdLnZlcnRleE5vcm1hbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5tb3JwaE5vcm1hbHNbYV0uZmFjZU5vcm1hbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSB0aGlzLm1vcnBoTm9ybWFsc1thXS52ZXJ0ZXhOb3JtYWxzLCBoLCBtO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBjIDwgZDsgYysrKWggPSBuZXcgcSwgbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYTogbmV3IHEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IG5ldyBxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjOiBuZXcgcVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGUucHVzaChoKSwgZy5wdXNoKG0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnID0gdGhpcy5tb3JwaE5vcm1hbHNbYV07XHJcbiAgICAgICAgICAgICAgICBmLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbYV0udmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICBmLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG4gICAgICAgICAgICAgICAgZi5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG4gICAgICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSB0aGlzLmZhY2VzLmxlbmd0aDsgYyA8IGQ7IGMrKyllID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2VzW2NdLCBoID0gZy5mYWNlTm9ybWFsc1tjXSwgbSA9IGcudmVydGV4Tm9ybWFsc1tjXSwgaC5jb3B5KGUubm9ybWFsKSwgbS5hLmNvcHkoZS52ZXJ0ZXhOb3JtYWxzWzBdKSwgbS5iLmNvcHkoZS52ZXJ0ZXhOb3JtYWxzWzFdKSwgbS5jLmNvcHkoZS52ZXJ0ZXhOb3JtYWxzWzJdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGQgPSB0aGlzLmZhY2VzLmxlbmd0aDsgYyA8IGQ7IGMrKyllID0gdGhpcy5mYWNlc1tjXSwgZS5ub3JtYWwgPSBlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLCBlLnZlcnRleE5vcm1hbHMgPSBlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzXHJcbiAgICAgICAgfSwgY29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDAsIGIgPSB0aGlzLnZlcnRpY2VzLCBjID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgZCA9IGIubGVuZ3RoOyBjIDwgZDsgYysrKTAgPCBjICYmIChhICs9IGJbY10uZGlzdGFuY2VUbyhiW2MgLSAxXSkpLCB0aGlzLmxpbmVEaXN0YW5jZXNbY10gPSBhXHJcbiAgICAgICAgfSwgY29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG51bGwgPT09IHRoaXMuYm91bmRpbmdCb3ggJiYgKHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgUGEpO1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcylcclxuICAgICAgICB9LCBjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbnVsbCA9PT0gdGhpcy5ib3VuZGluZ1NwaGVyZSAmJiAodGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBOYSk7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzKVxyXG4gICAgICAgIH0sIG1lcmdlOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBpZiAoITEgPT09IChhICYmIGEuaXNHZW9tZXRyeSkpIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuXCIsIGEpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkLCBlID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsIGYgPSB0aGlzLnZlcnRpY2VzLCBnID0gYS52ZXJ0aWNlcywgaCA9IHRoaXMuZmFjZXMsIG0gPSBhLmZhY2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIGsgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0sIGwgPSBhLmZhY2VWZXJ0ZXhVdnNbMF0sIHAgPSB0aGlzLmNvbG9ycywgbiA9IGEuY29sb3JzO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBjICYmIChjID0gMCk7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09XHJcbiAgICAgICAgICAgICAgICBiICYmIChkID0gKG5ldyB5YSkuZ2V0Tm9ybWFsTWF0cml4KGIpKTtcclxuICAgICAgICAgICAgICAgIGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdSA9IGcubGVuZ3RoOyBhIDwgdTsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBnW2FdLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiICYmIHEuYXBwbHlNYXRyaXg0KGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGYucHVzaChxKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHUgPSBuLmxlbmd0aDsgYSA8IHU7IGErKylwLnB1c2goblthXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh1ID0gbS5sZW5ndGg7IGEgPCB1OyBhKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IG1bYV0sIHIgPSBnLnZlcnRleE5vcm1hbHMsIG4gPSBnLnZlcnRleENvbG9ycywgcCA9IG5ldyBoYShnLmEgKyBlLCBnLmIgKyBlLCBnLmMgKyBlKTtcclxuICAgICAgICAgICAgICAgICAgICBwLm5vcm1hbC5jb3B5KGcubm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGQgJiYgcC5ub3JtYWwuYXBwbHlNYXRyaXgzKGQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZiA9IHIubGVuZ3RoOyBiIDwgZjsgYisrKXEgPSByW2JdLmNsb25lKCksIHZvaWQgMCAhPT0gZCAmJiBxLmFwcGx5TWF0cml4MyhkKS5ub3JtYWxpemUoKSwgcC52ZXJ0ZXhOb3JtYWxzLnB1c2gocSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5jb2xvci5jb3B5KGcuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZiA9IG4ubGVuZ3RoOyBiIDwgZjsgYisrKXEgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuW2JdLCBwLnZlcnRleENvbG9ycy5wdXNoKHEuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5tYXRlcmlhbEluZGV4ID0gZy5tYXRlcmlhbEluZGV4ICsgYztcclxuICAgICAgICAgICAgICAgICAgICBoLnB1c2gocClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh1ID0gbC5sZW5ndGg7IGEgPCB1OyBhKyspaWYgKGMgPSBsW2FdLCBkID0gW10sIHZvaWQgMCAhPT0gYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZiA9IGMubGVuZ3RoOyBiIDwgZjsgYisrKWQucHVzaChjW2JdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsucHVzaChkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgbWVyZ2VNZXNoOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAhMSA9PT0gKGEgJiYgYS5pc01lc2gpID8gY29uc29sZS5lcnJvcihcIlRIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLlwiLCBhKSA6IChhLm1hdHJpeEF1dG9VcGRhdGUgJiYgYS51cGRhdGVNYXRyaXgoKSwgdGhpcy5tZXJnZShhLmdlb21ldHJ5LCBhLm1hdHJpeCkpXHJcbiAgICAgICAgfSwgbWVyZ2VWZXJ0aWNlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHt9LCBiID0gW10sIGMgPSBbXSwgZCwgZSA9IE1hdGgucG93KDEwLCA0KSwgZiwgZztcclxuICAgICAgICAgICAgZiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoZyA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBmIDwgZzsgZisrKWQgPSB0aGlzLnZlcnRpY2VzW2ZdLFxyXG4gICAgICAgICAgICAgICAgZCA9IE1hdGgucm91bmQoZC54ICogZSkgKyBcIl9cIiArIE1hdGgucm91bmQoZC55ICogZSkgKyBcIl9cIiArIE1hdGgucm91bmQoZC56ICogZSksIHZvaWQgMCA9PT0gYVtkXSA/IChhW2RdID0gZiwgYi5wdXNoKHRoaXMudmVydGljZXNbZl0pLCBjW2ZdID0gYi5sZW5ndGggLSAxKSA6IGNbZl0gPSBjW2FbZF1dO1xyXG4gICAgICAgICAgICBhID0gW107XHJcbiAgICAgICAgICAgIGYgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGcgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGc7IGYrKylmb3IgKGUgPSB0aGlzLmZhY2VzW2ZdLCBlLmEgPSBjW2UuYV0sIGUuYiA9IGNbZS5iXSwgZS5jID0gY1tlLmNdLCBlID0gW2UuYSwgZS5iLCBlLmNdLCBkID0gMDsgMyA+IGQ7IGQrKylpZiAoZVtkXSA9PT0gZVsoZCArIDEpICUgM10pIHtcclxuICAgICAgICAgICAgICAgIGEucHVzaChmKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChmID0gYS5sZW5ndGggLSAxOyAwIDw9IGY7IGYtLSlmb3IgKGUgPSBhW2ZdLCB0aGlzLmZhY2VzLnNwbGljZShlLCAxKSwgYyA9IDAsIGcgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBjIDwgZzsgYysrKXRoaXMuZmFjZVZlcnRleFV2c1tjXS5zcGxpY2UoZSwgMSk7XHJcbiAgICAgICAgICAgIGYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIGIubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gYjtcclxuICAgICAgICAgICAgcmV0dXJuIGZcclxuICAgICAgICB9LCBzb3J0RmFjZXNCeU1hdGVyaWFsSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VzLCBiID0gYS5sZW5ndGgsIGMgPSAwOyBjIDwgYjsgYysrKWFbY10uX2lkID0gYztcclxuICAgICAgICAgICAgYS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5tYXRlcmlhbEluZGV4IC0gYi5tYXRlcmlhbEluZGV4XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZmFjZVZlcnRleFV2c1swXSwgZSA9IHRoaXMuZmFjZVZlcnRleFV2c1sxXSwgZiwgZztcclxuICAgICAgICAgICAgZCAmJiBkLmxlbmd0aCA9PT0gYiAmJiAoZiA9IFtdKTtcclxuICAgICAgICAgICAgZSAmJiBlLmxlbmd0aCA9PT0gYiAmJiAoZyA9IFtdKTtcclxuICAgICAgICAgICAgZm9yIChjID0gMDsgYyA8IGI7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBhW2NdLl9pZDtcclxuICAgICAgICAgICAgICAgIGYgJiYgZi5wdXNoKGRbaF0pO1xyXG4gICAgICAgICAgICAgICAgZyAmJiBnLnB1c2goZVtoXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmICYmICh0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0gPSBmKTtcclxuICAgICAgICAgICAgZyAmJiAodGhpcy5mYWNlVmVydGV4VXZzWzFdID0gZylcclxuICAgICAgICB9LCB0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gYShhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYyA/IGEgfCAxIDw8IGIgOiBhICYgfigxIDw8IGIpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBhLngudG9TdHJpbmcoKSArIGEueS50b1N0cmluZygpICsgYS56LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBrW2JdKXJldHVybiBrW2JdO1xyXG4gICAgICAgICAgICAgICAga1tiXSA9IG0ubGVuZ3RoIC9cclxuICAgICAgICAgICAgICAgICAgICAzO1xyXG4gICAgICAgICAgICAgICAgbS5wdXNoKGEueCwgYS55LCBhLnopO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtbYl1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYyhhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGEuci50b1N0cmluZygpICsgYS5nLnRvU3RyaW5nKCkgKyBhLmIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHBbYl0pcmV0dXJuIHBbYl07XHJcbiAgICAgICAgICAgICAgICBwW2JdID0gbC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsLnB1c2goYS5nZXRIZXgoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcFtiXVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBkKGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYS54LnRvU3RyaW5nKCkgKyBhLnkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHVbYl0pcmV0dXJuIHVbYl07XHJcbiAgICAgICAgICAgICAgICB1W2JdID0gbi5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgbi5wdXNoKGEueCwgYS55KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1W2JdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBlID0ge21ldGFkYXRhOiB7dmVyc2lvbjogNC40LCB0eXBlOiBcIkdlb21ldHJ5XCIsIGdlbmVyYXRvcjogXCJHZW9tZXRyeS50b0pTT05cIn19O1xyXG4gICAgICAgICAgICBlLnV1aWQgPSB0aGlzLnV1aWQ7XHJcbiAgICAgICAgICAgIGUudHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICAgICAgXCJcIiAhPT0gdGhpcy5uYW1lICYmIChlLm5hbWUgPSB0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSB0aGlzLnBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5wYXJhbWV0ZXJzLCBnO1xyXG4gICAgICAgICAgICAgICAgZm9yIChnIGluIGYpdm9pZCAwICE9PVxyXG4gICAgICAgICAgICAgICAgZltnXSAmJiAoZVtnXSA9IGZbZ10pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmID0gW107XHJcbiAgICAgICAgICAgIGZvciAoZyA9IDA7IGcgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgZysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMudmVydGljZXNbZ107XHJcbiAgICAgICAgICAgICAgICBmLnB1c2goaC54LCBoLnksIGgueilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaCA9IFtdLCBtID0gW10sIGsgPSB7fSwgbCA9IFtdLCBwID0ge30sIG4gPSBbXSwgdSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGcgPSAwOyBnIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGcrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmZhY2VzW2ddLCByID0gdm9pZCAwICE9PSB0aGlzLmZhY2VWZXJ0ZXhVdnNbMF1bZ10sIEEgPSAwIDwgcS5ub3JtYWwubGVuZ3RoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IDAgPCBxLnZlcnRleE5vcm1hbHMubGVuZ3RoLCB5ID0gMSAhPT0gcS5jb2xvci5yIHx8IDEgIT09IHEuY29sb3IuZyB8fCAxICE9PSBxLmNvbG9yLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgSyA9IDAgPCBxLnZlcnRleENvbG9ycy5sZW5ndGgsIHYgPSAwLCB2ID0gYSh2LCAwLCAwKSwgdiA9IGEodiwgMSwgITApLCB2ID0gYSh2LCAyLCAhMSksXHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGEodiwgMywgciksIHYgPSBhKHYsIDQsIEEpLCB2ID0gYSh2LCA1LCB3KSwgdiA9IGEodiwgNiwgeSksIHYgPSBhKHYsIDcsIEspO1xyXG4gICAgICAgICAgICAgICAgaC5wdXNoKHYpO1xyXG4gICAgICAgICAgICAgICAgaC5wdXNoKHEuYSwgcS5iLCBxLmMpO1xyXG4gICAgICAgICAgICAgICAgaC5wdXNoKHEubWF0ZXJpYWxJbmRleCk7XHJcbiAgICAgICAgICAgICAgICByICYmIChyID0gdGhpcy5mYWNlVmVydGV4VXZzWzBdW2ddLCBoLnB1c2goZChyWzBdKSwgZChyWzFdKSwgZChyWzJdKSkpO1xyXG4gICAgICAgICAgICAgICAgQSAmJiBoLnB1c2goYihxLm5vcm1hbCkpO1xyXG4gICAgICAgICAgICAgICAgdyAmJiAoQSA9IHEudmVydGV4Tm9ybWFscywgaC5wdXNoKGIoQVswXSksIGIoQVsxXSksIGIoQVsyXSkpKTtcclxuICAgICAgICAgICAgICAgIHkgJiYgaC5wdXNoKGMocS5jb2xvcikpO1xyXG4gICAgICAgICAgICAgICAgSyAmJiAocSA9IHEudmVydGV4Q29sb3JzLCBoLnB1c2goYyhxWzBdKSwgYyhxWzFdKSwgYyhxWzJdKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZS5kYXRhID0ge307XHJcbiAgICAgICAgICAgIGUuZGF0YS52ZXJ0aWNlcyA9IGY7XHJcbiAgICAgICAgICAgIGUuZGF0YS5ub3JtYWxzID0gbTtcclxuICAgICAgICAgICAgMCA8IGwubGVuZ3RoICYmIChlLmRhdGEuY29sb3JzID0gbCk7XHJcbiAgICAgICAgICAgIDAgPCBuLmxlbmd0aCAmJiAoZS5kYXRhLnV2cyA9IFtuXSk7XHJcbiAgICAgICAgICAgIGUuZGF0YS5mYWNlcyA9IGg7XHJcbiAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgVCkuY29weSh0aGlzKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiLCBjLCBkLCBlLCBmLCBnO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMgPVxyXG4gICAgICAgICAgICAgICAgW107XHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBhLm5hbWU7XHJcbiAgICAgICAgICAgIGQgPSBhLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICBiID0gMDtcclxuICAgICAgICAgICAgZm9yIChjID0gZC5sZW5ndGg7IGIgPCBjOyBiKyspdGhpcy52ZXJ0aWNlcy5wdXNoKGRbYl0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGQgPSBhLmNvbG9ycztcclxuICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoYyA9IGQubGVuZ3RoOyBiIDwgYzsgYisrKXRoaXMuY29sb3JzLnB1c2goZFtiXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgZCA9IGEuZmFjZXM7XHJcbiAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSBkLmxlbmd0aDsgYiA8IGM7IGIrKyl0aGlzLmZhY2VzLnB1c2goZFtiXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoYyA9IGEuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGIgPCBjOyBiKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBoID0gYS5mYWNlVmVydGV4VXZzW2JdO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSB0aGlzLmZhY2VWZXJ0ZXhVdnNbYl0gJiYgKHRoaXMuZmFjZVZlcnRleFV2c1tiXSA9IFtdKTtcclxuICAgICAgICAgICAgICAgIGQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChlID0gaC5sZW5ndGg7IGQgPFxyXG4gICAgICAgICAgICAgICAgZTsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBoW2RdLCBrID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChnID0gbS5sZW5ndGg7IGYgPCBnOyBmKyspay5wdXNoKG1bZl0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzW2JdLnB1c2goaylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmID0gYS5tb3JwaFRhcmdldHM7XHJcbiAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSBmLmxlbmd0aDsgYiA8IGM7IGIrKykge1xyXG4gICAgICAgICAgICAgICAgZyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZy5uYW1lID0gZltiXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZltiXS52ZXJ0aWNlcylmb3IgKGcudmVydGljZXMgPSBbXSwgZCA9IDAsIGUgPSBmW2JdLnZlcnRpY2VzLmxlbmd0aDsgZCA8IGU7IGQrKylnLnZlcnRpY2VzLnB1c2goZltiXS52ZXJ0aWNlc1tkXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZbYl0ubm9ybWFscylmb3IgKGcubm9ybWFscyA9IFtdLCBkID0gMCwgZSA9IGZbYl0ubm9ybWFscy5sZW5ndGg7IGQgPCBlOyBkKyspZy5ub3JtYWxzLnB1c2goZltiXS5ub3JtYWxzW2RdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMucHVzaChnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGYgPSBhLm1vcnBoTm9ybWFscztcclxuICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoYyA9IGYubGVuZ3RoOyBiIDwgYzsgYisrKSB7XHJcbiAgICAgICAgICAgICAgICBnID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBmW2JdLnZlcnRleE5vcm1hbHMpZm9yIChnLnZlcnRleE5vcm1hbHMgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdLCBkID0gMCwgZSA9IGZbYl0udmVydGV4Tm9ybWFscy5sZW5ndGg7IGQgPCBlOyBkKyspaCA9IGZbYl0udmVydGV4Tm9ybWFsc1tkXSwgbSA9IHt9LCBtLmEgPSBoLmEuY2xvbmUoKSwgbS5iID0gaC5iLmNsb25lKCksIG0uYyA9IGguYy5jbG9uZSgpLCBnLnZlcnRleE5vcm1hbHMucHVzaChtKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZbYl0uZmFjZU5vcm1hbHMpZm9yIChnLmZhY2VOb3JtYWxzID0gW10sIGQgPSAwLCBlID0gZltiXS5mYWNlTm9ybWFscy5sZW5ndGg7IGQgPCBlOyBkKyspZy5mYWNlTm9ybWFscy5wdXNoKGZbYl0uZmFjZU5vcm1hbHNbZF0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFscy5wdXNoKGcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZCA9IGEuc2tpbldlaWdodHM7XHJcbiAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSBkLmxlbmd0aDsgYiA8IGM7IGIrKyl0aGlzLnNraW5XZWlnaHRzLnB1c2goZFtiXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgZCA9IGEuc2tpbkluZGljZXM7XHJcbiAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSBkLmxlbmd0aDsgYiA8IGM7IGIrKyl0aGlzLnNraW5JbmRpY2VzLnB1c2goZFtiXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgZCA9IGEubGluZURpc3RhbmNlcztcclxuICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoYyA9IGQubGVuZ3RoOyBiIDxcclxuICAgICAgICAgICAgYzsgYisrKXRoaXMubGluZURpc3RhbmNlcy5wdXNoKGRbYl0pO1xyXG4gICAgICAgICAgICBiID0gYS5ib3VuZGluZ0JveDtcclxuICAgICAgICAgICAgbnVsbCAhPT0gYiAmJiAodGhpcy5ib3VuZGluZ0JveCA9IGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGIgPSBhLmJvdW5kaW5nU3BoZXJlO1xyXG4gICAgICAgICAgICBudWxsICE9PSBiICYmICh0aGlzLmJvdW5kaW5nU3BoZXJlID0gYi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBhLmVsZW1lbnRzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBhLnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy51dnNOZWVkVXBkYXRlID0gYS51dnNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gYS5ub3JtYWxzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gYS5jb2xvcnNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gYS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5ncm91cHNOZWVkVXBkYXRlID0gYS5ncm91cHNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiBcImRpc3Bvc2VcIn0pXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oVC5wcm90b3R5cGUsIHBhLnByb3RvdHlwZSk7XHJcbiAgICBJLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogSSwgaXNCdWZmZXJHZW9tZXRyeTogITAsIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4XHJcbiAgICAgICAgfSwgc2V0SW5kZXg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoYSkgPyB0aGlzLmluZGV4ID0gbmV3ICg2NTUzNSA8IFVkKGEpID8gamIgOiBpYikoYSwgMSkgOiB0aGlzLmluZGV4ID0gYVxyXG4gICAgICAgIH0sIGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgaWYgKCExID09PSAoYiAmJiBiLmlzQnVmZmVyQXR0cmlidXRlKSAmJiAhMSA9PT0gKGIgJiYgYi5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSkgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLlwiKSwgdGhpcy5hZGRBdHRyaWJ1dGUoYSwgbmV3IFUoYiwgYykpOyBlbHNlIGlmIChcImluZGV4XCIgPT09IGEpIGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuXCIpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbmRleChiKTsgZWxzZSByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2FdID0gYiwgdGhpc1xyXG4gICAgICAgIH0sIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thXVxyXG4gICAgICAgIH0sIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBhZGRHcm91cDogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cHMucHVzaCh7c3RhcnQ6IGEsIGNvdW50OiBiLCBtYXRlcmlhbEluZGV4OiB2b2lkIDAgIT09IGMgPyBjIDogMH0pXHJcbiAgICAgICAgfSwgY2xlYXJHcm91cHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cHMgPSBbXVxyXG4gICAgICAgIH0sIHNldERyYXdSYW5nZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBhO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGJcclxuICAgICAgICB9LCBhcHBseU1hdHJpeDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYiAmJiAoYS5hcHBseVRvQnVmZmVyQXR0cmlidXRlKGIpLCBiLm5lZWRzVXBkYXRlID0gITApO1xyXG4gICAgICAgICAgICBiID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBiICYmICgobmV3IHlhKS5nZXROb3JtYWxNYXRyaXgoYSkuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZShiKSwgYi5uZWVkc1VwZGF0ZSA9ICEwKTtcclxuICAgICAgICAgICAgbnVsbCAhPT0gdGhpcy5ib3VuZGluZ0JveCAmJiB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgICAgICBudWxsICE9PSB0aGlzLmJvdW5kaW5nU3BoZXJlICYmIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgUyk7XHJcbiAgICAgICAgICAgICAgICBhLm1ha2VSb3RhdGlvblgoYik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgcm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgUyk7XHJcbiAgICAgICAgICAgICAgICBhLm1ha2VSb3RhdGlvblkoYik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgcm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09XHJcbiAgICAgICAgICAgICAgICBhICYmIChhID0gbmV3IFMpO1xyXG4gICAgICAgICAgICAgICAgYS5tYWtlUm90YXRpb25aKGIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeChhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgUyk7XHJcbiAgICAgICAgICAgICAgICBhLm1ha2VUcmFuc2xhdGlvbihiLCBjLCBkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBzY2FsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBuZXcgUyk7XHJcbiAgICAgICAgICAgICAgICBhLm1ha2VTY2FsZShiLCBjLCBkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHgpO1xyXG4gICAgICAgICAgICAgICAgYS5sb29rQXQoYik7XHJcbiAgICAgICAgICAgICAgICBhLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeChhLm1hdHJpeClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgY2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoKS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoYS54LCBhLnksIGEueik7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSwgc2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBhLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICBpZiAoYS5pc1BvaW50cyB8fCBhLmlzTGluZSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IG5ldyB6KDMgKiBiLnZlcnRpY2VzLmxlbmd0aCwgMyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyB6KDMgKiBiLmNvbG9ycy5sZW5ndGgsIDMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBhLmNvcHlWZWN0b3Izc0FycmF5KGIudmVydGljZXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwiY29sb3JcIiwgYy5jb3B5Q29sb3JzQXJyYXkoYi5jb2xvcnMpKTtcclxuICAgICAgICAgICAgICAgIGIubGluZURpc3RhbmNlcyAmJiBiLmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBiLnZlcnRpY2VzLmxlbmd0aCAmJiAoYSA9IG5ldyB6KGIubGluZURpc3RhbmNlcy5sZW5ndGgsIDEpLCB0aGlzLmFkZEF0dHJpYnV0ZShcImxpbmVEaXN0YW5jZVwiLCBhLmNvcHlBcnJheShiLmxpbmVEaXN0YW5jZXMpKSk7XHJcbiAgICAgICAgICAgICAgICBudWxsICE9PSBiLmJvdW5kaW5nU3BoZXJlICYmICh0aGlzLmJvdW5kaW5nU3BoZXJlID0gYi5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIG51bGwgIT09IGIuYm91bmRpbmdCb3ggJiYgKHRoaXMuYm91bmRpbmdCb3ggPSBiLmJvdW5kaW5nQm94LmNsb25lKCkpXHJcbiAgICAgICAgICAgIH0gZWxzZSBhLmlzTWVzaCAmJiBiICYmIGIuaXNHZW9tZXRyeSAmJiB0aGlzLmZyb21HZW9tZXRyeShiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGEuZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgIGlmIChhLmlzTWVzaCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBiLl9fZGlyZWN0R2VvbWV0cnk7XHJcbiAgICAgICAgICAgICAgICAhMCA9PT0gYi5lbGVtZW50c05lZWRVcGRhdGUgJiYgKGMgPSB2b2lkIDAsIGIuZWxlbWVudHNOZWVkVXBkYXRlID0gITEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYylyZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoYik7XHJcbiAgICAgICAgICAgICAgICBjLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGIudmVydGljZXNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgYy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGIubm9ybWFsc05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBjLmNvbG9yc05lZWRVcGRhdGUgPSBiLmNvbG9yc05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBjLnV2c05lZWRVcGRhdGUgPSBiLnV2c05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBjLmdyb3Vwc05lZWRVcGRhdGUgPSBiLmdyb3Vwc05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBiLnZlcnRpY2VzTmVlZFVwZGF0ZSA9ICExO1xyXG4gICAgICAgICAgICAgICAgYi5ub3JtYWxzTmVlZFVwZGF0ZSA9ICExO1xyXG4gICAgICAgICAgICAgICAgYi5jb2xvcnNOZWVkVXBkYXRlID0gITE7XHJcbiAgICAgICAgICAgICAgICBiLnV2c05lZWRVcGRhdGUgPSAhMTtcclxuICAgICAgICAgICAgICAgIGIuZ3JvdXBzTmVlZFVwZGF0ZSA9ICExO1xyXG4gICAgICAgICAgICAgICAgYiA9IGNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAhMCA9PT0gYi52ZXJ0aWNlc05lZWRVcGRhdGUgJiYgKGMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sIHZvaWQgMCAhPT0gYyAmJiAoYy5jb3B5VmVjdG9yM3NBcnJheShiLnZlcnRpY2VzKSwgYy5uZWVkc1VwZGF0ZSA9ICEwKSwgYi52ZXJ0aWNlc05lZWRVcGRhdGUgPSAhMSk7XHJcbiAgICAgICAgICAgICEwID09PSBiLm5vcm1hbHNOZWVkVXBkYXRlICYmIChjID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbCwgdm9pZCAwICE9PSBjICYmIChjLmNvcHlWZWN0b3Izc0FycmF5KGIubm9ybWFscyksIGMubmVlZHNVcGRhdGUgPSAhMCksIGIubm9ybWFsc05lZWRVcGRhdGUgPSAhMSk7XHJcbiAgICAgICAgICAgICEwID09PSBiLmNvbG9yc05lZWRVcGRhdGUgJiYgKGMgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3IsIHZvaWQgMCAhPT0gYyAmJiAoYy5jb3B5Q29sb3JzQXJyYXkoYi5jb2xvcnMpLCBjLm5lZWRzVXBkYXRlID0gITApLFxyXG4gICAgICAgICAgICAgICAgYi5jb2xvcnNOZWVkVXBkYXRlID0gITEpO1xyXG4gICAgICAgICAgICBiLnV2c05lZWRVcGRhdGUgJiYgKGMgPSB0aGlzLmF0dHJpYnV0ZXMudXYsIHZvaWQgMCAhPT0gYyAmJiAoYy5jb3B5VmVjdG9yMnNBcnJheShiLnV2cyksIGMubmVlZHNVcGRhdGUgPSAhMCksIGIudXZzTmVlZFVwZGF0ZSA9ICExKTtcclxuICAgICAgICAgICAgYi5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSAmJiAoYyA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2UsIHZvaWQgMCAhPT0gYyAmJiAoYy5jb3B5QXJyYXkoYi5saW5lRGlzdGFuY2VzKSwgYy5uZWVkc1VwZGF0ZSA9ICEwKSwgYi5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9ICExKTtcclxuICAgICAgICAgICAgYi5ncm91cHNOZWVkVXBkYXRlICYmIChiLmNvbXB1dGVHcm91cHMoYS5nZW9tZXRyeSksIHRoaXMuZ3JvdXBzID0gYi5ncm91cHMsIGIuZ3JvdXBzTmVlZFVwZGF0ZSA9ICExKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEuX19kaXJlY3RHZW9tZXRyeSA9IChuZXcgTWUpLmZyb21HZW9tZXRyeShhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KGEuX19kaXJlY3RHZW9tZXRyeSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiBhLnZlcnRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIiwgKG5ldyBVKGIsIDMpKS5jb3B5VmVjdG9yM3NBcnJheShhLnZlcnRpY2VzKSk7XHJcbiAgICAgICAgICAgIDAgPCBhLm5vcm1hbHMubGVuZ3RoICYmIChiID0gbmV3IEZsb2F0MzJBcnJheSgzICogYS5ub3JtYWxzLmxlbmd0aCksIHRoaXMuYWRkQXR0cmlidXRlKFwibm9ybWFsXCIsIChuZXcgVShiLCAzKSkuY29weVZlY3RvcjNzQXJyYXkoYS5ub3JtYWxzKSkpO1xyXG4gICAgICAgICAgICAwIDwgYS5jb2xvcnMubGVuZ3RoICYmIChiID0gbmV3IEZsb2F0MzJBcnJheSgzICogYS5jb2xvcnMubGVuZ3RoKSwgdGhpcy5hZGRBdHRyaWJ1dGUoXCJjb2xvclwiLCAobmV3IFUoYiwgMykpLmNvcHlDb2xvcnNBcnJheShhLmNvbG9ycykpKTtcclxuICAgICAgICAgICAgMCA8IGEudXZzLmxlbmd0aCAmJiAoYiA9IG5ldyBGbG9hdDMyQXJyYXkoMiAqIGEudXZzLmxlbmd0aCksIHRoaXMuYWRkQXR0cmlidXRlKFwidXZcIiwgKG5ldyBVKGIsIDIpKS5jb3B5VmVjdG9yMnNBcnJheShhLnV2cykpKTtcclxuICAgICAgICAgICAgMCA8IGEudXZzMi5sZW5ndGggJiYgKGIgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBhLnV2czIubGVuZ3RoKSwgdGhpcy5hZGRBdHRyaWJ1dGUoXCJ1djJcIiwgKG5ldyBVKGIsIDIpKS5jb3B5VmVjdG9yMnNBcnJheShhLnV2czIpKSk7XHJcbiAgICAgICAgICAgIDAgPCBhLmluZGljZXMubGVuZ3RoICYmIChiID0gbmV3ICg2NTUzNSA8IFVkKGEuaW5kaWNlcykgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5KSgzICogYS5pbmRpY2VzLmxlbmd0aCksIHRoaXMuc2V0SW5kZXgoKG5ldyBVKGIsIDEpKS5jb3B5SW5kaWNlc0FycmF5KGEuaW5kaWNlcykpKTtcclxuICAgICAgICAgICAgdGhpcy5ncm91cHMgPSBhLmdyb3VwcztcclxuICAgICAgICAgICAgZm9yICh2YXIgYyBpbiBhLm1vcnBoVGFyZ2V0cykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IFtdLCBkID0gYS5tb3JwaFRhcmdldHNbY10sIGUgPSAwLCBmID0gZC5sZW5ndGg7IGUgPCBmOyBlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGRbZV0sIGggPSBuZXcgeigzICogZy5sZW5ndGgsIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIucHVzaChoLmNvcHlWZWN0b3Izc0FycmF5KGcpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXNbY10gPSBiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgMCA8IGEuc2tpbkluZGljZXMubGVuZ3RoICYmIChjID0gbmV3IHooNCAqXHJcbiAgICAgICAgICAgICAgICBhLnNraW5JbmRpY2VzLmxlbmd0aCwgNCksIHRoaXMuYWRkQXR0cmlidXRlKFwic2tpbkluZGV4XCIsIGMuY29weVZlY3RvcjRzQXJyYXkoYS5za2luSW5kaWNlcykpKTtcclxuICAgICAgICAgICAgMCA8IGEuc2tpbldlaWdodHMubGVuZ3RoICYmIChjID0gbmV3IHooNCAqIGEuc2tpbldlaWdodHMubGVuZ3RoLCA0KSwgdGhpcy5hZGRBdHRyaWJ1dGUoXCJza2luV2VpZ2h0XCIsIGMuY29weVZlY3RvcjRzQXJyYXkoYS5za2luV2VpZ2h0cykpKTtcclxuICAgICAgICAgICAgbnVsbCAhPT0gYS5ib3VuZGluZ1NwaGVyZSAmJiAodGhpcy5ib3VuZGluZ1NwaGVyZSA9IGEuYm91bmRpbmdTcGhlcmUuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIG51bGwgIT09IGEuYm91bmRpbmdCb3ggJiYgKHRoaXMuYm91bmRpbmdCb3ggPSBhLmJvdW5kaW5nQm94LmNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBudWxsID09PSB0aGlzLmJvdW5kaW5nQm94ICYmICh0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFBhKTtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYSA/IHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShhKSA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xyXG4gICAgICAgICAgICAoaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueCkgfHwgaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueSkgfHwgaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueikpICYmIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcylcclxuICAgICAgICB9LCBjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgUGEsIGIgPSBuZXcgcTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG51bGwgPT09IHRoaXMuYm91bmRpbmdTcGhlcmUgJiYgKHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgTmEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZ2V0Q2VudGVyKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gYy5jb3VudDsgZiA8IGc7IGYrKyliLnggPSBjLmdldFgoZiksIGIueSA9IGMuZ2V0WShmKSwgYi56ID0gYy5nZXRaKGYpLCBlID0gTWF0aC5tYXgoZSwgZC5kaXN0YW5jZVRvU3F1YXJlZChiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNOYU4odGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpICYmIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCksIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIH0sIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5pbmRleCwgYiA9IHRoaXMuYXR0cmlidXRlcywgYyA9IHRoaXMuZ3JvdXBzO1xyXG4gICAgICAgICAgICBpZiAoYi5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBiLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYi5ub3JtYWwpIHRoaXMuYWRkQXR0cmlidXRlKFwibm9ybWFsXCIsIG5ldyBVKG5ldyBGbG9hdDMyQXJyYXkoZC5sZW5ndGgpLCAzKSk7IGVsc2UgZm9yICh2YXIgZSA9IGIubm9ybWFsLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBlLmxlbmd0aDsgZiA8IGc7IGYrKyllW2ZdID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gYi5ub3JtYWwuYXJyYXksIGgsIG0sIGssIGwgPSBuZXcgcSwgcCA9IG5ldyBxLCBuID0gbmV3IHEsIHUgPSBuZXcgcSwgRyA9IG5ldyBxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gYS5hcnJheTtcclxuICAgICAgICAgICAgICAgICAgICAwID09PSBjLmxlbmd0aCAmJiB0aGlzLmFkZEdyb3VwKDAsIGEubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBID0gYy5sZW5ndGg7IHIgPCBBOyArK3IpZm9yIChmID0gY1tyXSwgZyA9IGYuc3RhcnQsIGggPSBmLmNvdW50LCBmID0gZywgZyArPSBoOyBmIDwgZzsgZiArPSAzKWggPSAzICogYVtmICsgMF0sIG0gPSAzICogYVtmICsgMV0sIGsgPSAzICogYVtmICsgMl0sIGwuZnJvbUFycmF5KGQsIGgpLCBwLmZyb21BcnJheShkLCBtKSwgbi5mcm9tQXJyYXkoZCwgayksIHUuc3ViVmVjdG9ycyhuLCBwKSwgRy5zdWJWZWN0b3JzKGwsIHApLCB1LmNyb3NzKEcpLCBlW2hdICs9IHUueCwgZVtoICsgMV0gKz0gdS55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlW2ggKyAyXSArPSB1LnosIGVbbV0gKz0gdS54LCBlW20gKyAxXSArPSB1LnksIGVbbSArIDJdICs9IHUueiwgZVtrXSArPSB1LngsIGVbayArIDFdICs9IHUueSwgZVtrICsgMl0gKz0gdS56XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgZm9yIChmID0gMCwgZyA9IGQubGVuZ3RoOyBmIDwgZzsgZiArPSA5KWwuZnJvbUFycmF5KGQsIGYpLCBwLmZyb21BcnJheShkLCBmICsgMyksIG4uZnJvbUFycmF5KGQsIGYgKyA2KSwgdS5zdWJWZWN0b3JzKG4sIHApLCBHLnN1YlZlY3RvcnMobCwgcCksIHUuY3Jvc3MoRyksIGVbZl0gPSB1LngsIGVbZiArIDFdID0gdS55LCBlW2YgKyAyXSA9IHUueiwgZVtmICsgM10gPSB1LngsIGVbZiArIDRdID0gdS55LCBlW2YgKyA1XSA9IHUueiwgZVtmICsgNl0gPSB1LngsIGVbZiArIDddID0gdS55LCBlW2YgKyA4XSA9IHUuejtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG4gICAgICAgICAgICAgICAgYi5ub3JtYWwubmVlZHNVcGRhdGUgPSAhMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgbWVyZ2U6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmICghMSA9PT0gKGEgJiYgYS5pc0J1ZmZlckdlb21ldHJ5KSkgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS5cIixcclxuICAgICAgICAgICAgICAgIGEpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmF0dHJpYnV0ZXMsIGQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGQgaW4gYylpZiAodm9pZCAwICE9PSBhLmF0dHJpYnV0ZXNbZF0pZm9yICh2YXIgZSA9IGNbZF0uYXJyYXksIGYgPSBhLmF0dHJpYnV0ZXNbZF0sIGcgPSBmLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBmLml0ZW1TaXplICogYjsgaCA8IGcubGVuZ3RoOyBoKyssIGYrKyllW2ZdID0gZ1toXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5LCBiLCBjLCBkLCBlID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgZiA9IGEubGVuZ3RoOyBlIDwgZjsgZSArPSAzKWIgPSBhW2VdLCBjID0gYVtlICsgMV0sIGQgPSBhW2UgKyAyXSwgYiA9IDEgLyBNYXRoLnNxcnQoYiAqIGIgKyBjICogYyArIGQgKiBkKSwgYVtlXSAqPSBiLCBhW2UgKyAxXSAqPSBiLCBhW2UgKyAyXSAqPSBiXHJcbiAgICAgICAgfSwgdG9Ob25JbmRleGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChudWxsID09PSB0aGlzLmluZGV4KXJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeS50b05vbkluZGV4ZWQoKTogR2VvbWV0cnkgaXMgYWxyZWFkeSBub24taW5kZXhlZC5cIiksXHJcbiAgICAgICAgICAgICAgICB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBJLCBiID0gdGhpcy5pbmRleC5hcnJheSwgYyA9IHRoaXMuYXR0cmlidXRlcywgZDtcclxuICAgICAgICAgICAgZm9yIChkIGluIGMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSBjW2RdLCBmID0gZS5hcnJheSwgZSA9IGUuaXRlbVNpemUsIGcgPSBuZXcgZi5jb25zdHJ1Y3RvcihiLmxlbmd0aCAqIGUpLCBoLCBtID0gMCwgayA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBsID0gYi5sZW5ndGg7IGsgPCBsOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBoID0gYltrXSAqIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBlOyBwKyspZ1ttKytdID0gZltoKytdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhLmFkZEF0dHJpYnV0ZShkLCBuZXcgVShnLCBlKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH0sIHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHttZXRhZGF0YToge3ZlcnNpb246IDQuNCwgdHlwZTogXCJCdWZmZXJHZW9tZXRyeVwiLCBnZW5lcmF0b3I6IFwiQnVmZmVyR2VvbWV0cnkudG9KU09OXCJ9fTtcclxuICAgICAgICAgICAgYS51dWlkID0gdGhpcy51dWlkO1xyXG4gICAgICAgICAgICBhLnR5cGUgPSB0aGlzLnR5cGU7XHJcbiAgICAgICAgICAgIFwiXCIgIT09IHRoaXMubmFtZSAmJiAoYS5uYW1lID0gdGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdGhpcy5wYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMucGFyYW1ldGVycywgYztcclxuICAgICAgICAgICAgICAgIGZvciAoYyBpbiBiKXZvaWQgMCAhPT0gYltjXSAmJlxyXG4gICAgICAgICAgICAgICAgKGFbY10gPSBiW2NdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYS5kYXRhID0ge2F0dHJpYnV0ZXM6IHt9fTtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICBudWxsICE9PSBkICYmIChiID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZC5hcnJheSksIGEuZGF0YS5pbmRleCA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IGQuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuICAgICAgICAgICAgICAgIGFycmF5OiBiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICBmb3IgKGMgaW4gZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBkW2NdLCBiID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5hcnJheSk7XHJcbiAgICAgICAgICAgICAgICBhLmRhdGEuYXR0cmlidXRlc1tjXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtU2l6ZTogZS5pdGVtU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXk6IGIsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZDogZS5ub3JtYWxpemVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYyA9IHRoaXMuZ3JvdXBzO1xyXG4gICAgICAgICAgICAwIDwgYy5sZW5ndGggJiYgKGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKSk7XHJcbiAgICAgICAgICAgIGMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG4gICAgICAgICAgICBudWxsICE9PSBjICYmIChhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXI6IGMuY2VudGVyLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogYy5yYWRpdXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgSSkuY29weSh0aGlzKVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiLCBjLCBkO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5uYW1lID0gYS5uYW1lO1xyXG4gICAgICAgICAgICBjID0gYS5pbmRleDtcclxuICAgICAgICAgICAgbnVsbCAhPT0gYyAmJiB0aGlzLnNldEluZGV4KGMuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGMgPSBhLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgIGZvciAoYiBpbiBjKXRoaXMuYWRkQXR0cmlidXRlKGIsIGNbYl0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIHZhciBlID0gYS5tb3JwaEF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgIGZvciAoYiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IFtdLCBnID0gZVtiXTtcclxuICAgICAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChkID0gZy5sZW5ndGg7IGMgPCBkOyBjKyspZi5wdXNoKGdbY10uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoQXR0cmlidXRlc1tiXSA9IGZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gYS5ncm91cHM7XHJcbiAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGQgPSBiLmxlbmd0aDsgYyA8IGQ7IGMrKyllID1cclxuICAgICAgICAgICAgICAgIGJbY10sIHRoaXMuYWRkR3JvdXAoZS5zdGFydCwgZS5jb3VudCwgZS5tYXRlcmlhbEluZGV4KTtcclxuICAgICAgICAgICAgYiA9IGEuYm91bmRpbmdCb3g7XHJcbiAgICAgICAgICAgIG51bGwgIT09IGIgJiYgKHRoaXMuYm91bmRpbmdCb3ggPSBiLmNsb25lKCkpO1xyXG4gICAgICAgICAgICBiID0gYS5ib3VuZGluZ1NwaGVyZTtcclxuICAgICAgICAgICAgbnVsbCAhPT0gYiAmJiAodGhpcy5ib3VuZGluZ1NwaGVyZSA9IGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gYS5kcmF3UmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gYS5kcmF3UmFuZ2UuY291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6IFwiZGlzcG9zZVwifSlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSS5NYXhJbmRleCA9IDY1NTM1O1xyXG4gICAgT2JqZWN0LmFzc2lnbihJLnByb3RvdHlwZSwgcGEucHJvdG90eXBlKTtcclxuICAgIEFhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogQWEsIGlzTWVzaDogITAsIHNldERyYXdNb2RlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdNb2RlID0gYVxyXG4gICAgICAgIH0sIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHgucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLFxyXG4gICAgICAgICAgICAgICAgYSk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGUgPSBhLmRyYXdNb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHVwZGF0ZU1vcnBoVGFyZ2V0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBhICYmIDAgPCBhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBhLmxlbmd0aDsgYiA8IGM7IGIrKyl0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApLCB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVthW2JdLm5hbWVdID0gYlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgcmF5Y2FzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBhKGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcclxuICAgICAgICAgICAgICAgIHphLmJhcnljb29yZEZyb21Qb2ludChhLCBiLCBjLCBkLCByKTtcclxuICAgICAgICAgICAgICAgIGUubXVsdGlwbHlTY2FsYXIoci54KTtcclxuICAgICAgICAgICAgICAgIGYubXVsdGlwbHlTY2FsYXIoci55KTtcclxuICAgICAgICAgICAgICAgIGcubXVsdGlwbHlTY2FsYXIoci56KTtcclxuICAgICAgICAgICAgICAgIGUuYWRkKGYpLmFkZChnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLmNsb25lKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYihhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9XHJcbiAgICAgICAgICAgICAgICAgICAgYS5tYXRlcmlhbDtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSAoMSA9PT0gaC5zaWRlID8gYy5pbnRlcnNlY3RUcmlhbmdsZShmLCBlLCBkLCAhMCwgZykgOiBjLmludGVyc2VjdFRyaWFuZ2xlKGQsIGUsIGYsIDIgIT09IGguc2lkZSwgZykpKXJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdy5jb3B5KGcpO1xyXG4gICAgICAgICAgICAgICAgdy5hcHBseU1hdHJpeDQoYS5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICBjID0gYi5yYXkub3JpZ2luLmRpc3RhbmNlVG8odyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYyA8IGIubmVhciB8fCBjID4gYi5mYXIgPyBudWxsIDoge2Rpc3RhbmNlOiBjLCBwb2ludDogdy5jbG9uZSgpLCBvYmplY3Q6IGF9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGMoYywgZCwgZSwgZiwgaywgbCwgcCwgdCkge1xyXG4gICAgICAgICAgICAgICAgZy5mcm9tQnVmZmVyQXR0cmlidXRlKGYsIGwpO1xyXG4gICAgICAgICAgICAgICAgaC5mcm9tQnVmZmVyQXR0cmlidXRlKGYsIHApO1xyXG4gICAgICAgICAgICAgICAgbS5mcm9tQnVmZmVyQXR0cmlidXRlKGYsIHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPSBiKGMsIGQsIGUsIGcsIGgsIG0sIEEpKSBrICYmIChuLmZyb21CdWZmZXJBdHRyaWJ1dGUoaywgbCksIHUuZnJvbUJ1ZmZlckF0dHJpYnV0ZShrLCBwKSwgRy5mcm9tQnVmZmVyQXR0cmlidXRlKGssIHQpLCBjLnV2ID0gYShBLCBnLCBoLCBtLCBuLCB1LCBHKSksIGMuZmFjZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IGhhKGwsIHAsIHQsIHphLm5vcm1hbChnLCBoLCBtKSksIGMuZmFjZUluZGV4ID0gbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkID0gbmV3IFMsIGUgPSBuZXcgY2IsIGYgPSBuZXcgTmEsIGcgPSBuZXcgcSwgaCA9IG5ldyBxLCBtID0gbmV3IHEsIGsgPSBuZXcgcSwgbCA9IG5ldyBxLCBwID0gbmV3IHEsXHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEQsIHUgPSBuZXcgRCwgRyA9IG5ldyBELCByID0gbmV3IHEsIEEgPSBuZXcgcSwgdyA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHEsIHIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZW9tZXRyeSwgdyA9IHRoaXMubWF0ZXJpYWwsIEwgPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdyAmJiAobnVsbCA9PT0gdi5ib3VuZGluZ1NwaGVyZSAmJiB2LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLCBmLmNvcHkodi5ib3VuZGluZ1NwaGVyZSksIGYuYXBwbHlNYXRyaXg0KEwpLCAhMSAhPT0gcS5yYXkuaW50ZXJzZWN0c1NwaGVyZShmKSAmJiAoZC5nZXRJbnZlcnNlKEwpLCBlLmNvcHkocS5yYXkpLmFwcGx5TWF0cml4NChkKSwgbnVsbCA9PT0gdi5ib3VuZGluZ0JveCB8fCAhMSAhPT0gZS5pbnRlcnNlY3RzQm94KHYuYm91bmRpbmdCb3gpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgQztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi5pc0J1ZmZlckdlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBGLCB4LCB3ID0gdi5pbmRleCwgSCA9IHYuYXR0cmlidXRlcy5wb3NpdGlvbiwgTCA9IHYuYXR0cmlidXRlcy51diwgRCwgejtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHcpZm9yIChEID0gMCwgeiA9IHcuY291bnQ7IEQgPCB6OyBEICs9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID0gdy5nZXRYKEQpLCBGID0gdy5nZXRYKEQgKyAxKSwgeCA9IHcuZ2V0WChEICsgMiksIEMgPSBjKHRoaXMsIHEsIGUsIEgsIEwsIHYsIEYsIHgpKSBDLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoRCAvIDMpLCByLnB1c2goQylcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGZvciAoRCA9IDAsIHogPSBILmNvdW50OyBEIDwgejsgRCArPSAzKWlmICh2ID0gRCwgRiA9IEQgKyAxLCB4ID0gRCArIDIsIEMgPSBjKHRoaXMsIHEsIGUsIEgsIEwsIHYsIEYsIHgpKSBDLmluZGV4ID0gdiwgci5wdXNoKEMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LmlzR2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEosIEksIEwgPSB3ICYmIHcuaXNNdWx0aU1hdGVyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEID0gITAgPT09IEwgPyB3Lm1hdGVyaWFscyA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHogPSB2LnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGID0gdi5mYWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHYuZmFjZVZlcnRleFV2c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgMCA8IHgubGVuZ3RoICYmIChIID0geCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIFEgPSAwLCBNID0gRi5sZW5ndGg7IFEgPCBNOyBRKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBPID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGW1FdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQyA9ICEwID09PSBMID8gRFtPLm1hdGVyaWFsSW5kZXhdIDogdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IEMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0geltPLmFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEogPSB6W08uYl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSSA9IHpbTy5jXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IEMubW9ycGhUYXJnZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEMgPSB2Lm1vcnBoVGFyZ2V0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFAgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5zZXQoMCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguc2V0KDAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNldCgwLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgVCA9IDAsIFcgPSBDLmxlbmd0aDsgVCA8IFc7IFQrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFMgPSBQW1RdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgIT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUiA9IENbVF0udmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5hZGRTY2FsZWRWZWN0b3Ioay5zdWJWZWN0b3JzKFJbTy5hXSwgeCksIFMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguYWRkU2NhbGVkVmVjdG9yKGwuc3ViVmVjdG9ycyhSW08uYl0sIEopLCBTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmFkZFNjYWxlZFZlY3RvcihwLnN1YlZlY3RvcnMoUltPLmNdLCBJKSwgUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnLmFkZCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5hZGQoSik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYWRkKEkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSiA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEkgPSBtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDID0gYih0aGlzLCBxLCBlLCB4LCBKLCBJLCBBKSkgSCAmJiAoUCA9IEhbUV0sIG4uY29weShQWzBdKSwgdS5jb3B5KFBbMV0pLCBHLmNvcHkoUFsyXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEMudXYgPSBhKEEsIHgsIEosIEksIG4sIHUsIEcpKSwgQy5mYWNlID0gTywgQy5mYWNlSW5kZXggPSBRLCByLnB1c2goQylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKSkuY29weSh0aGlzKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgSWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcbiAgICBJYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJYjtcclxuICAgIGtiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSS5wcm90b3R5cGUpO1xyXG4gICAga2IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga2I7XHJcbiAgICBBYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuICAgIEFjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFjO1xyXG4gICAgbGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJLnByb3RvdHlwZSk7XHJcbiAgICBsYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsYjtcclxuICAgIHJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoeC5wcm90b3R5cGUpO1xyXG4gICAgcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gcmE7XHJcbiAgICByYS5wcm90b3R5cGUuaXNDYW1lcmEgPVxyXG4gICAgICAgICEwO1xyXG4gICAgcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhID0gbmV3IGNhO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICBiID0gYiB8fCBuZXcgcTtcclxuICAgICAgICAgICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBiLnNldCgwLCAwLCAtMSkuYXBwbHlRdWF0ZXJuaW9uKGEpXHJcbiAgICAgICAgfVxyXG4gICAgfSgpO1xyXG4gICAgcmEucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYSA9IG5ldyBTO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICBhLmxvb2tBdCh0aGlzLnBvc2l0aW9uLCBiLCB0aGlzLnVwKTtcclxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChhKVxyXG4gICAgICAgIH1cclxuICAgIH0oKTtcclxuICAgIHJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICB9O1xyXG4gICAgcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHgucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KGEubWF0cml4V29ybGRJbnZlcnNlKTtcclxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXguY29weShhLnByb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9O1xyXG4gICAgRmEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHJhLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogRmEsIGlzUGVyc3BlY3RpdmVDYW1lcmE6ICEwLCBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByYS5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgICAgICB0aGlzLmZvdiA9IGEuZm92O1xyXG4gICAgICAgICAgICB0aGlzLnpvb20gPSBhLnpvb207XHJcbiAgICAgICAgICAgIHRoaXMubmVhciA9IGEubmVhcjtcclxuICAgICAgICAgICAgdGhpcy5mYXIgPSBhLmZhcjtcclxuICAgICAgICAgICAgdGhpcy5mb2N1cyA9IGEuZm9jdXM7XHJcbiAgICAgICAgICAgIHRoaXMuYXNwZWN0ID0gYS5hc3BlY3Q7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IG51bGwgPT09IGEudmlldyA/IG51bGwgOiBPYmplY3QuYXNzaWduKHt9LCBhLnZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbG1HYXVnZSA9IGEuZmlsbUdhdWdlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbG1PZmZzZXQgPSBhLmZpbG1PZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0Rm9jYWxMZW5ndGg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEgPSAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gYTtcclxuICAgICAgICAgICAgdGhpcy5mb3YgPSAyICogTi5SQUQyREVHICogTWF0aC5hdGFuKGEpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Rm9jYWxMZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLnRhbiguNSAqIE4uREVHMlJBRCAqIHRoaXMuZm92KTtcclxuICAgICAgICAgICAgcmV0dXJuIC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBhXHJcbiAgICAgICAgfSwgZ2V0RWZmZWN0aXZlRk9WOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyICogTi5SQUQyREVHICogTWF0aC5hdGFuKE1hdGgudGFuKC41ICogTi5ERUcyUkFEICogdGhpcy5mb3YpIC8gdGhpcy56b29tKVxyXG4gICAgICAgIH0sIGdldEZpbG1XaWR0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbih0aGlzLmFzcGVjdCwgMSlcclxuICAgICAgICB9LCBnZXRGaWxtSGVpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbG1HYXVnZSAvIE1hdGgubWF4KHRoaXMuYXNwZWN0LCAxKVxyXG4gICAgICAgIH0sIHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXNwZWN0ID0gYSAvIGI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHtmdWxsV2lkdGg6IGEsIGZ1bGxIZWlnaHQ6IGIsIG9mZnNldFg6IGMsIG9mZnNldFk6IGQsIHdpZHRoOiBlLCBoZWlnaHQ6IGZ9O1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxyXG4gICAgICAgIH0sIGNsZWFyVmlld09mZnNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPVxyXG4gICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KClcclxuICAgICAgICB9LCB1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5uZWFyLCBiID0gYSAqIE1hdGgudGFuKC41ICogTi5ERUcyUkFEICogdGhpcy5mb3YpIC8gdGhpcy56b29tLCBjID0gMiAqIGIsIGQgPSB0aGlzLmFzcGVjdCAqIGMsXHJcbiAgICAgICAgICAgICAgICBlID0gLS41ICogZCwgZiA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgaWYgKG51bGwgIT09IGYpdmFyIGcgPSBmLmZ1bGxXaWR0aCwgaCA9IGYuZnVsbEhlaWdodCwgZSA9IGUgKyBmLm9mZnNldFggKiBkIC8gZywgYiA9IGIgLSBmLm9mZnNldFkgKiBjIC8gaCxcclxuICAgICAgICAgICAgICAgIGQgPSBmLndpZHRoIC8gZyAqIGQsIGMgPSBmLmhlaWdodCAvIGggKiBjO1xyXG4gICAgICAgICAgICBmID0gdGhpcy5maWxtT2Zmc2V0O1xyXG4gICAgICAgICAgICAwICE9PSBmICYmIChlICs9IGEgKiBmIC8gdGhpcy5nZXRGaWxtV2lkdGgoKSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoZSwgZSArIGQsIGIsIGIgLSBjLCBhLCB0aGlzLmZhcilcclxuICAgICAgICB9LCB0b0pTT046IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEgPSB4LnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICAgICAgYS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XHJcbiAgICAgICAgICAgIGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XHJcbiAgICAgICAgICAgIGEub2JqZWN0Lm5lYXIgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5uZWFyO1xyXG4gICAgICAgICAgICBhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcclxuICAgICAgICAgICAgYS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xyXG4gICAgICAgICAgICBhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcclxuICAgICAgICAgICAgbnVsbCAhPT0gdGhpcy52aWV3ICYmIChhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52aWV3KSk7XHJcbiAgICAgICAgICAgIGEub2JqZWN0LmZpbG1HYXVnZSA9IHRoaXMuZmlsbUdhdWdlO1xyXG4gICAgICAgICAgICBhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgSmIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHJhLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogSmIsIGlzT3J0aG9ncmFwaGljQ2FtZXJhOiAhMCwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmEucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gYS5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gYS5yaWdodDtcclxuICAgICAgICAgICAgdGhpcy50b3AgPSBhLnRvcDtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBhLmJvdHRvbTtcclxuICAgICAgICAgICAgdGhpcy5uZWFyID0gYS5uZWFyO1xyXG4gICAgICAgICAgICB0aGlzLmZhciA9IGEuZmFyO1xyXG4gICAgICAgICAgICB0aGlzLnpvb20gPSBhLnpvb207XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9XHJcbiAgICAgICAgICAgICAgICBudWxsID09PSBhLnZpZXcgPyBudWxsIDogT2JqZWN0LmFzc2lnbih7fSwgYS52aWV3KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB7ZnVsbFdpZHRoOiBhLCBmdWxsSGVpZ2h0OiBiLCBvZmZzZXRYOiBjLCBvZmZzZXRZOiBkLCB3aWR0aDogZSwgaGVpZ2h0OiBmfTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KClcclxuICAgICAgICB9LCBjbGVhclZpZXdPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KClcclxuICAgICAgICB9LCB1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpIC8gKDIgKiB0aGlzLnpvb20pLCBiID0gKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pIC8gKDIgKiB0aGlzLnpvb20pLFxyXG4gICAgICAgICAgICAgICAgYyA9ICh0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0KSAvIDIsIGQgPSAodGhpcy50b3AgKyB0aGlzLmJvdHRvbSkgLyAyLCBlID0gYyAtIGEsIGMgPSBjICsgYSwgYSA9IGQgKyBiLFxyXG4gICAgICAgICAgICAgICAgYiA9IGQgLSBiO1xyXG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdGhpcy52aWV3KXZhciBjID0gdGhpcy56b29tIC9cclxuICAgICAgICAgICAgICAgICAgICAodGhpcy52aWV3LndpZHRoIC8gdGhpcy52aWV3LmZ1bGxXaWR0aCksIGIgPSB0aGlzLnpvb20gLyAodGhpcy52aWV3LmhlaWdodCAvIHRoaXMudmlldy5mdWxsSGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgIGYgPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyB0aGlzLnZpZXcud2lkdGgsIGQgPSAodGhpcy50b3AgLSB0aGlzLmJvdHRvbSkgLyB0aGlzLnZpZXcuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZSA9IGUgKyB0aGlzLnZpZXcub2Zmc2V0WCAvIGMgKiBmLCBjID0gZSArIHRoaXMudmlldy53aWR0aCAvIGMgKiBmLCBhID0gYSAtIHRoaXMudmlldy5vZmZzZXRZIC8gYiAqIGQsXHJcbiAgICAgICAgICAgICAgICBiID0gYSAtIHRoaXMudmlldy5oZWlnaHQgLyBiICogZDtcclxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoZSwgYywgYSwgYiwgdGhpcy5uZWFyLCB0aGlzLmZhcilcclxuICAgICAgICB9LCB0b0pTT046IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEgPSB4LnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICAgICAgYS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcclxuICAgICAgICAgICAgYS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgYS5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICBhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcclxuICAgICAgICAgICAgYS5vYmplY3QuYm90dG9tID1cclxuICAgICAgICAgICAgICAgIHRoaXMuYm90dG9tO1xyXG4gICAgICAgICAgICBhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG4gICAgICAgICAgICBhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcclxuICAgICAgICAgICAgbnVsbCAhPT0gdGhpcy52aWV3ICYmIChhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52aWV3KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgTGYgPSAwO1xyXG4gICAgS2IucHJvdG90eXBlLmlzRm9nRXhwMiA9ICEwO1xyXG4gICAgS2IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgS2IodGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5KVxyXG4gICAgfTtcclxuICAgIEtiLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHJldHVybiB7dHlwZTogXCJGb2dFeHAyXCIsIGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLCBkZW5zaXR5OiB0aGlzLmRlbnNpdHl9XHJcbiAgICB9O1xyXG4gICAgTGIucHJvdG90eXBlLmlzRm9nID0gITA7XHJcbiAgICBMYi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMYih0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLm5lYXIsIHRoaXMuZmFyKVxyXG4gICAgfTtcclxuICAgIExiLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiRm9nXCIsXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLCBuZWFyOiB0aGlzLm5lYXIsIGZhcjogdGhpcy5mYXJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSk7XHJcbiAgICBtYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtYjtcclxuICAgIG1iLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB4LnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgYSwgYik7XHJcbiAgICAgICAgbnVsbCAhPT0gYS5iYWNrZ3JvdW5kICYmICh0aGlzLmJhY2tncm91bmQgPSBhLmJhY2tncm91bmQuY2xvbmUoKSk7XHJcbiAgICAgICAgbnVsbCAhPT0gYS5mb2cgJiYgKHRoaXMuZm9nID0gYS5mb2cuY2xvbmUoKSk7XHJcbiAgICAgICAgbnVsbCAhPT0gYS5vdmVycmlkZU1hdGVyaWFsICYmICh0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBhLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5hdXRvVXBkYXRlID0gYS5hdXRvVXBkYXRlO1xyXG4gICAgICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGEubWF0cml4QXV0b1VwZGF0ZTtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIG1iLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBiID0geC5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcyxcclxuICAgICAgICAgICAgYSk7XHJcbiAgICAgICAgbnVsbCAhPT0gdGhpcy5iYWNrZ3JvdW5kICYmIChiLm9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTihhKSk7XHJcbiAgICAgICAgbnVsbCAhPT0gdGhpcy5mb2cgJiYgKGIub2JqZWN0LmZvZyA9IHRoaXMuZm9nLnRvSlNPTigpKTtcclxuICAgICAgICByZXR1cm4gYlxyXG4gICAgfTtcclxuICAgIFpkLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogWmQsIGlzTGVuc0ZsYXJlOiAhMCwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgeC5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoYS5wb3NpdGlvblNjcmVlbik7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBhLmN1c3RvbVVwZGF0ZUNhbGxiYWNrO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMCwgYyA9IGEubGVuc0ZsYXJlcy5sZW5ndGg7IGIgPCBjOyBiKyspdGhpcy5sZW5zRmxhcmVzLnB1c2goYS5sZW5zRmxhcmVzW2JdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBhZGQ6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IC0xKTtcclxuICAgICAgICAgICAgdm9pZCAwID09PVxyXG4gICAgICAgICAgICBjICYmIChjID0gMCk7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZiAmJiAoZiA9IDEpO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSBuZXcgSigxNjc3NzIxNSkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGQgJiYgKGQgPSAxKTtcclxuICAgICAgICAgICAgYyA9IE1hdGgubWluKGMsIE1hdGgubWF4KDAsIGMpKTtcclxuICAgICAgICAgICAgdGhpcy5sZW5zRmxhcmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogYSxcclxuICAgICAgICAgICAgICAgIHNpemU6IGIsXHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZTogYyxcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgejogMCxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiAxLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246IDAsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBmLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGUsXHJcbiAgICAgICAgICAgICAgICBibGVuZGluZzogZFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sIHVwZGF0ZUxlbnNGbGFyZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGIgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoLCBjLCBkID0gMiAqIC10aGlzLnBvc2l0aW9uU2NyZWVuLngsIGUgPSAyICogLXRoaXMucG9zaXRpb25TY3JlZW4ueTtcclxuICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IGI7IGErKyljID0gdGhpcy5sZW5zRmxhcmVzW2FdLCBjLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyBkICogYy5kaXN0YW5jZSwgYy55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgZSAqIGMuZGlzdGFuY2UsIGMud2FudGVkUm90YXRpb24gPSBjLnggKiBNYXRoLlBJICogLjI1LCBjLnJvdGF0aW9uICs9IC4yNSAqIChjLndhbnRlZFJvdGF0aW9uIC1cclxuICAgICAgICAgICAgICAgIGMucm90YXRpb24pXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBuYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFgucHJvdG90eXBlKTtcclxuICAgIG5iLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG5iO1xyXG4gICAgbmIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIFgucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoYS5jb2xvcik7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBhLm1hcDtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gYS5yb3RhdGlvbjtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIERjLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogRGMsIGlzU3ByaXRlOiAhMCwgcmF5Y2FzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIGEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBiLnJheS5kaXN0YW5jZVNxVG9Qb2ludChhKTtcclxuICAgICAgICAgICAgICAgIGQgPiB0aGlzLnNjYWxlLnggKiB0aGlzLnNjYWxlLnkgLyA0IHx8IGMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IE1hdGguc3FydChkKSwgcG9pbnQ6IHRoaXMucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZTogbnVsbCwgb2JqZWN0OiB0aGlzXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubWF0ZXJpYWwpKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBFYy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoeC5wcm90b3R5cGUpLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IEVjLCBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB4LnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgYSwgITEpO1xyXG4gICAgICAgICAgICBhID0gYS5sZXZlbHM7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwLCBjID0gYS5sZW5ndGg7IGIgPCBjOyBiKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gYVtiXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGV2ZWwoZC5vYmplY3QuY2xvbmUoKSwgZC5kaXN0YW5jZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGFkZExldmVsOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAwKTtcclxuICAgICAgICAgICAgYiA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gdGhpcy5sZXZlbHMsIGQgPSAwOyBkIDwgYy5sZW5ndGggJiYgIShiIDwgY1tkXS5kaXN0YW5jZSk7IGQrKyk7XHJcbiAgICAgICAgICAgIGMuc3BsaWNlKGQsIDAsIHtkaXN0YW5jZTogYiwgb2JqZWN0OiBhfSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKGEpXHJcbiAgICAgICAgfSwgZ2V0T2JqZWN0Rm9yRGlzdGFuY2U6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbHMsIGMgPSAxLCBkID0gYi5sZW5ndGg7IGMgPCBkICYmICEoYSA8IGJbY10uZGlzdGFuY2UpOyBjKyspO1xyXG4gICAgICAgICAgICByZXR1cm4gYltjIC0gMV0ub2JqZWN0XHJcbiAgICAgICAgfSwgcmF5Y2FzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIGEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBiLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhhKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoZCkucmF5Y2FzdChiLCBjKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5sZXZlbHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoMSA8IGQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5zZXRGcm9tTWF0cml4UG9zaXRpb24oYy5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGEuZGlzdGFuY2VUbyhiKTtcclxuICAgICAgICAgICAgICAgICAgICBkWzBdLm9iamVjdC52aXNpYmxlID0gITA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDEsIGYgPSBkLmxlbmd0aDsgZSA8IGY7IGUrKylpZiAoYyA+PSBkW2VdLmRpc3RhbmNlKSBkW2UgLVxyXG4gICAgICAgICAgICAgICAgICAgIDFdLm9iamVjdC52aXNpYmxlID0gITEsIGRbZV0ub2JqZWN0LnZpc2libGUgPSAhMDsgZWxzZSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZSA8IGY7IGUrKylkW2VdLm9iamVjdC52aXNpYmxlID0gITFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgdG9KU09OOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0geC5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcywgYSk7XHJcbiAgICAgICAgICAgIGEub2JqZWN0LmxldmVscyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5sZXZlbHMsIGMgPSAwLCBkID0gYi5sZW5ndGg7IGMgPCBkOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gYltjXTtcclxuICAgICAgICAgICAgICAgIGEub2JqZWN0LmxldmVscy5wdXNoKHtvYmplY3Q6IGUub2JqZWN0LnV1aWQsIGRpc3RhbmNlOiBlLmRpc3RhbmNlfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihvZC5wcm90b3R5cGUsIHtcclxuICAgICAgICBjYWxjdWxhdGVJbnZlcnNlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMCwgYiA9IHRoaXMuYm9uZXMubGVuZ3RoOyBhIDwgYjsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBTO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lc1thXSAmJiBjLmdldEludmVyc2UodGhpcy5ib25lc1thXS5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKGMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSwgYiA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGM7IGIrKykoYSA9IHRoaXMuYm9uZXNbYl0pICYmIGEubWF0cml4V29ybGQuZ2V0SW52ZXJzZSh0aGlzLmJvbmVJbnZlcnNlc1tiXSk7XHJcbiAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGM7IGIrKylpZiAoYSA9IHRoaXMuYm9uZXNbYl0pIGEucGFyZW50ICYmIGEucGFyZW50LmlzQm9uZSA/IChhLm1hdHJpeC5nZXRJbnZlcnNlKGEucGFyZW50Lm1hdHJpeFdvcmxkKSwgYS5tYXRyaXgubXVsdGlwbHkoYS5tYXRyaXhXb3JsZCkpIDogYS5tYXRyaXguY29weShhLm1hdHJpeFdvcmxkKSwgYS5tYXRyaXguZGVjb21wb3NlKGEucG9zaXRpb24sIGEucXVhdGVybmlvbiwgYS5zY2FsZSlcclxuICAgICAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgUztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYzsgYisrKWEubXVsdGlwbHlNYXRyaWNlcyh0aGlzLmJvbmVzW2JdID8gdGhpcy5ib25lc1tiXS5tYXRyaXhXb3JsZCA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGVudGl0eU1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbYl0pLCBhLnRvQXJyYXkodGhpcy5ib25lTWF0cmljZXMsIDE2ICogYik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVZlcnRleFRleHR1cmUgJiYgKHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSAhMClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBvZCh0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcywgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcGQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHgucHJvdG90eXBlKSwge2NvbnN0cnVjdG9yOiBwZCwgaXNCb25lOiAhMH0pO1xyXG4gICAgcWQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKEFhLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogcWQsIGlzU2tpbm5lZE1lc2g6ICEwLCBiaW5kOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnNrZWxldG9uID0gYTtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmICh0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCEwKSwgdGhpcy5za2VsZXRvbi5jYWxjdWxhdGVJbnZlcnNlcygpLFxyXG4gICAgICAgICAgICAgICAgYiA9IHRoaXMubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRNYXRyaXguY29weShiKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKGIpXHJcbiAgICAgICAgfSwgcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNrZWxldG9uLnBvc2UoKVxyXG4gICAgICAgIH0sIG5vcm1hbGl6ZVNraW5XZWlnaHRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuaXNHZW9tZXRyeSlmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1thXSwgYyA9IDEgLyBiLmxlbmd0aE1hbmhhdHRhbigpO1xyXG4gICAgICAgICAgICAgICAgSW5maW5pdHkgIT09IGMgPyBiLm11bHRpcGx5U2NhbGFyKGMpIDogYi5zZXQoMSwgMCwgMCwgMClcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSlmb3IgKHZhciBiID0gbmV3IGZhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gMDsgYSA8IGQuY291bnQ7IGErKyliLnggPSBkLmdldFgoYSksIGIueSA9IGQuZ2V0WShhKSxcclxuICAgICAgICAgICAgICAgIGIueiA9IGQuZ2V0WihhKSwgYi53ID0gZC5nZXRXKGEpLCBjID0gMSAvIGIubGVuZ3RoTWFuaGF0dGFuKCksIEluZmluaXR5ICE9PSBjID8gYi5tdWx0aXBseVNjYWxhcihjKSA6IGIuc2V0KDEsIDAsIDAsIDApLCBkLnNldFhZWlcoYSwgYi54LCBiLnksIGIueiwgYi53KVxyXG4gICAgICAgIH0sIHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBBYS5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCh0aGlzLCAhMCk7XHJcbiAgICAgICAgICAgIFwiYXR0YWNoZWRcIiA9PT0gdGhpcy5iaW5kTW9kZSA/IHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSh0aGlzLm1hdHJpeFdvcmxkKSA6IFwiZGV0YWNoZWRcIiA9PT0gdGhpcy5iaW5kTW9kZSA/IHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSh0aGlzLmJpbmRNYXRyaXgpIDogY29uc29sZS53YXJuKFwiVEhSRUUuU2tpbm5lZE1lc2ggdW5yZWNvZ25pemVkIGJpbmRNb2RlOiBcIiArIHRoaXMuYmluZE1vZGUpXHJcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlKSkuY29weSh0aGlzKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShYLnByb3RvdHlwZSk7XHJcbiAgICBpYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpYTtcclxuICAgIGlhLnByb3RvdHlwZS5pc0xpbmVCYXNpY01hdGVyaWFsID0gITA7XHJcbiAgICBpYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgWC5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMuY29sb3IuY29weShhLmNvbG9yKTtcclxuICAgICAgICB0aGlzLmxpbmV3aWR0aCA9IGEubGluZXdpZHRoO1xyXG4gICAgICAgIHRoaXMubGluZWNhcCA9IGEubGluZWNhcDtcclxuICAgICAgICB0aGlzLmxpbmVqb2luID0gYS5saW5lam9pbjtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIFVhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogVWEsIGlzTGluZTogITAsIHJheWNhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgUywgYiA9IG5ldyBjYiwgYyA9IG5ldyBOYTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGQubGluZVByZWNpc2lvbiwgZiA9IGYgKiBmLFxyXG4gICAgICAgICAgICAgICAgICAgIGcgPSB0aGlzLmdlb21ldHJ5LCBoID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuICAgICAgICAgICAgICAgIG51bGwgPT09IGcuYm91bmRpbmdTcGhlcmUgJiYgZy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuICAgICAgICAgICAgICAgIGMuY29weShnLmJvdW5kaW5nU3BoZXJlKTtcclxuICAgICAgICAgICAgICAgIGMuYXBwbHlNYXRyaXg0KGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCExICE9PSBkLnJheS5pbnRlcnNlY3RzU3BoZXJlKGMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5nZXRJbnZlcnNlKGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuY29weShkLnJheSkuYXBwbHlNYXRyaXg0KGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gbmV3IHEsIGsgPSBuZXcgcSwgaCA9IG5ldyBxLCBsID0gbmV3IHEsIHAgPSB0aGlzICYmIHRoaXMuaXNMaW5lU2VnbWVudHMgPyAyIDogMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZy5pc0J1ZmZlckdlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZy5pbmRleCwgdSA9IGcuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IG4pZm9yICh2YXIgbiA9IG4uYXJyYXksIGcgPSAwLCBHID0gbi5sZW5ndGggLSAxOyBnIDwgRzsgZyArPSBwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG5bZyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5mcm9tQXJyYXkodSwgMyAqIG5bZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5mcm9tQXJyYXkodSwgMyAqIHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IGIuZGlzdGFuY2VTcVRvU2VnbWVudChtLCBrLCBsLCBoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPiBmIHx8IChsLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gZC5yYXkub3JpZ2luLmRpc3RhbmNlVG8obCksIHIgPCBkLm5lYXIgfHwgciA+IGQuZmFyIHx8IGUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGguY2xvbmUoKS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGZvciAoZyA9IDAsIEcgPSB1Lmxlbmd0aCAvIDMgLSAxOyBnIDwgRzsgZyArPSBwKW0uZnJvbUFycmF5KHUsIDMgKiBnKSwgay5mcm9tQXJyYXkodSwgMyAqIGcgKyAzKSwgciA9IGIuZGlzdGFuY2VTcVRvU2VnbWVudChtLCBrLCBsLCBoKSwgciA+IGYgfHwgKGwuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpLCByID0gZC5yYXkub3JpZ2luLmRpc3RhbmNlVG8obCksIHIgPCBkLm5lYXIgfHwgciA+IGQuZmFyIHx8IGUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBoLmNsb25lKCkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZy5pc0dlb21ldHJ5KWZvciAobSA9IGcudmVydGljZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IG0ubGVuZ3RoLCBnID0gMDsgZyA8IGsgLSAxOyBnICs9IHApciA9IGIuZGlzdGFuY2VTcVRvU2VnbWVudChtW2ddLCBtW2cgKyAxXSwgbCwgaCksIHIgPiBmIHx8IChsLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSwgciA9IGQucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGwpLCByIDwgZC5uZWFyIHx8IHIgPiBkLmZhciB8fCBlLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGguY2xvbmUoKS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBnYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoVWEucHJvdG90eXBlKSwge2NvbnN0cnVjdG9yOiBnYSwgaXNMaW5lU2VnbWVudHM6ICEwfSk7XHJcbiAgICBPYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFgucHJvdG90eXBlKTtcclxuICAgIE9hLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9XHJcbiAgICAgICAgT2E7XHJcbiAgICBPYS5wcm90b3R5cGUuaXNQb2ludHNNYXRlcmlhbCA9ICEwO1xyXG4gICAgT2EucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIFgucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoYS5jb2xvcik7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBhLm1hcDtcclxuICAgICAgICB0aGlzLnNpemUgPSBhLnNpemU7XHJcbiAgICAgICAgdGhpcy5zaXplQXR0ZW51YXRpb24gPSBhLnNpemVBdHRlbnVhdGlvbjtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIE1iLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogTWIsIGlzUG9pbnRzOiAhMCwgcmF5Y2FzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBTLCBiID0gbmV3IGNiLCBjID0gbmV3IE5hO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGUpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoYSwgYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gYi5kaXN0YW5jZVNxVG9Qb2ludChhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZiA8IGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBiLmNsb3Nlc3RQb2ludFRvUG9pbnQoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGguYXBwbHlNYXRyaXg0KG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGQucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrIDwgZC5uZWFyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPiBkLmZhciB8fCBlLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoZiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogaC5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBnID0gdGhpcywgaCA9IHRoaXMuZ2VvbWV0cnksIG0gPSB0aGlzLm1hdHJpeFdvcmxkLCBrID0gZC5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcclxuICAgICAgICAgICAgICAgIG51bGwgPT09IGguYm91bmRpbmdTcGhlcmUgJiYgaC5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuICAgICAgICAgICAgICAgIGMuY29weShoLmJvdW5kaW5nU3BoZXJlKTtcclxuICAgICAgICAgICAgICAgIGMuYXBwbHlNYXRyaXg0KG0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCExICE9PSBkLnJheS5pbnRlcnNlY3RzU3BoZXJlKGMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5nZXRJbnZlcnNlKG0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuY29weShkLnJheSkuYXBwbHlNYXRyaXg0KGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gayAvICgodGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56KSAvIDMpLCBsID0gayAqIGssIGsgPSBuZXcgcTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaC5pc0J1ZmZlckdlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gaC5pbmRleCwgaCA9IGguYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHApZm9yICh2YXIgbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmFycmF5LCBwID0gMCwgdSA9IG4ubGVuZ3RoOyBwIDwgdTsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgRyA9IG5bcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLmZyb21BcnJheShoLCAzICogRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmKGssIEcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKHAgPSAwLCBuID0gaC5sZW5ndGggLyAzOyBwIDwgbjsgcCsrKWsuZnJvbUFycmF5KGgsIDMgKiBwKSwgZihrLCBwKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKGsgPSBoLnZlcnRpY2VzLCBwID0gMCwgbiA9IGsubGVuZ3RoOyBwIDwgbjsgcCsrKWYoa1twXSwgcClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKSkuY29weSh0aGlzKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgRmMucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHgucHJvdG90eXBlKSwge2NvbnN0cnVjdG9yOiBGY30pO1xyXG4gICAgcmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlYS5wcm90b3R5cGUpO1xyXG4gICAgcmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gcmQ7XHJcbiAgICBOYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGVhLnByb3RvdHlwZSk7XHJcbiAgICBOYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYjtcclxuICAgIE5iLnByb3RvdHlwZS5pc0NvbXByZXNzZWRUZXh0dXJlID1cclxuICAgICAgICAhMDtcclxuICAgIHNkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZWEucHJvdG90eXBlKTtcclxuICAgIHNkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHNkO1xyXG4gICAgR2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlYS5wcm90b3R5cGUpO1xyXG4gICAgR2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2M7XHJcbiAgICBHYy5wcm90b3R5cGUuaXNEZXB0aFRleHR1cmUgPSAhMDtcclxuICAgIE9iLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSS5wcm90b3R5cGUpO1xyXG4gICAgT2IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2I7XHJcbiAgICBIYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuICAgIEhjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhjO1xyXG4gICAgUGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJLnByb3RvdHlwZSk7XHJcbiAgICBQYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYjtcclxuICAgIEljLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG4gICAgSWMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWM7XHJcbiAgICBCYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEkucHJvdG90eXBlKTtcclxuICAgIEJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9XHJcbiAgICAgICAgQmE7XHJcbiAgICBKYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuICAgIEpjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpjO1xyXG4gICAgUWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYS5wcm90b3R5cGUpO1xyXG4gICAgUWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUWI7XHJcbiAgICBLYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuICAgIEtjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtjO1xyXG4gICAgb2IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYS5wcm90b3R5cGUpO1xyXG4gICAgb2IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2I7XHJcbiAgICBMYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuICAgIExjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExjO1xyXG4gICAgUmIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYS5wcm90b3R5cGUpO1xyXG4gICAgUmIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmI7XHJcbiAgICBNYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuICAgIE1jLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1jO1xyXG4gICAgU2IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYS5wcm90b3R5cGUpO1xyXG4gICAgU2IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2I7XHJcbiAgICBOYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuICAgIE5jLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5jO1xyXG4gICAgVGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJLnByb3RvdHlwZSk7XHJcbiAgICBUYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUYjtcclxuICAgIE9jLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG4gICAgT2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2M7XHJcbiAgICBVYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEkucHJvdG90eXBlKTtcclxuICAgIFViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFViO1xyXG4gICAgUGMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcbiAgICBQYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYztcclxuICAgIFZiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSS5wcm90b3R5cGUpO1xyXG4gICAgVmIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmI7XHJcbiAgICB2YXIgSWEgPSB7XHJcbiAgICAgICAgYXJlYTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IGEubGVuZ3RoLCBjID0gMCwgZCA9IGIgLSAxLCBlID0gMDsgZSA8IGI7IGQgPSBlKyspYyArPVxyXG4gICAgICAgICAgICAgICAgYVtkXS54ICogYVtlXS55IC0gYVtlXS54ICogYVtkXS55O1xyXG4gICAgICAgICAgICByZXR1cm4gLjUgKiBjXHJcbiAgICAgICAgfSwgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKDMgPiBjKXJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBbXSwgZSA9IFtdLCBmID0gW10sIGcsIGgsIG07XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA8IElhLmFyZWEoYSkpZm9yIChoID0gMDsgaCA8IGM7IGgrKyllW2hdID0gaDsgZWxzZSBmb3IgKGggPSAwOyBoIDwgYzsgaCsrKWVbaF0gPSBjIC0gMSAtIGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IDIgKiBjO1xyXG4gICAgICAgICAgICAgICAgZm9yIChoID0gYyAtIDE7IDIgPCBjOykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgwID49IGstLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5TaGFwZVV0aWxzOiBVbmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiEgaW4gdHJpYW5ndWxhdGUoKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA8PSBnICYmIChnID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IGcgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPD0gaCAmJiAoaCA9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBoICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBjIDw9IG0gJiYgKG0gPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbDtcclxuICAgICAgICAgICAgICAgICAgICBhOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAsIG4sIHEsIEcsIHIsIEEsIHcsIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBhW2VbZ11dLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBhW2VbZ11dLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBhW2VbaF1dLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEcgPSBhW2VbaF1dLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBhW2VbbV1dLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEEgPSBhW2VbbV1dLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID49IChxIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHApICogKEEgLSBuKSAtIChHIC0gbikgKiAociAtIHApKSBsID0gITE7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEssIHYsIEUsIHgsIEMsIEYsIEQsIEgsIHosIEo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLID0gciAtIHE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gQSAtIEc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFID0gcCAtIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gbiAtIEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDID0gcSAtIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGID0gRyAtIG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgYzsgbCsrKWlmICh3ID0gYVtlW2xdXS54LCB5ID0gYVtlW2xdXS55LCAhKHcgPT09IHAgJiYgeSA9PT0gbiB8fCB3ID09PSBxICYmIHkgPT09IEcgfHwgdyA9PT0gciAmJiB5ID09PSBBKSAmJiAoRCA9IHcgLSBwLCBIID0geSAtIG4sIHogPSB3IC0gcSwgSiA9IHkgLSBHLCB3IC09IHIsIHkgLT0gQSwgeiA9IEsgKiBKIC0gdiAqIHosIEQgPSBDICogSCAtIEYgKiBELCBIID0gRSAqIHkgLSB4ICogdywgeiA+PSAtTnVtYmVyLkVQU0lMT04gJiYgSCA+PSAtTnVtYmVyLkVQU0lMT04gJiYgRCA+PSAtTnVtYmVyLkVQU0lMT04pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSAhMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaChbYVtlW2ddXSwgYVtlW2hdXSwgYVtlW21dXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmLnB1c2goW2VbZ10sIGVbaF0sIGVbbV1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobSA9IGggKyAxOyBtIDwgYzsgZysrLCBtKyspZVtnXSA9IGVbbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IDIgKiBjXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgPyBmIDogZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpLCB0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjKGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID1cclxuICAgICAgICAgICAgICAgICAgICBhLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIDIgPCBiICYmIGFbYiAtIDFdLmVxdWFscyhhWzBdKSAmJiBhLnBvcCgpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGQoYSwgYiwgYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEueCAhPT0gYi54ID8gYS54IDwgYi54ID8gYS54IDw9IGMueCAmJiBjLnggPD0gYi54IDogYi54IDw9IGMueCAmJiBjLnggPD0gYS54IDogYS55IDwgYi55ID8gYS55IDw9IGMueSAmJiBjLnkgPD0gYi55IDogYi55IDw9IGMueSAmJiBjLnkgPD0gYS55XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoYSwgYiwgYywgZSwgZikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBiLnggLSBhLngsIGggPSBiLnkgLSBhLnksIGsgPSBlLnggLSBjLngsIG0gPSBlLnkgLSBjLnksIGwgPSBhLnggLSBjLngsIG4gPSBhLnkgLSBjLnksXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGggKiBrIC0gZyAqIG0sIHQgPSBoICogbCAtIGcgKiBuO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHApID4gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMCA8IHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPiB0IHx8IHQgPiBwKXJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IG0gKiBsIC0gayAqIG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID4gayB8fCBrID4gcClyZXR1cm4gW11cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA8IHQgfHwgdCA8IHApcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gbSAqIGwgLSBrICogbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPCBrIHx8IGsgPCBwKXJldHVybiBbXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gaylyZXR1cm4gIWYgfHwgMCAhPT0gdCAmJiB0ICE9PSBwID8gW2FdIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT09IHApcmV0dXJuICFmIHx8IDAgIT09IHQgJiYgdCAhPT0gcCA/IFtiXSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09PSB0KXJldHVybiBbY107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT09IHApcmV0dXJuIFtlXTtcclxuICAgICAgICAgICAgICAgICAgICBmID0gayAvIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7eDogYS54ICsgZiAqIGcsIHk6IGEueSArIGYgKiBofV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgwICE9PSB0IHx8IG0gKiBsICE9PSBrICogbilyZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICBoID0gMCA9PT0gZyAmJiAwID09PSBoO1xyXG4gICAgICAgICAgICAgICAgayA9IDAgPT09IGsgJiYgMCA9PT0gbTtcclxuICAgICAgICAgICAgICAgIGlmIChoICYmIGspcmV0dXJuIGEueCAhPT0gYy54IHx8IGEueSAhPT0gYy55ID8gW10gOiBbYV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaClyZXR1cm4gZChjLCBlLCBhKSA/IFthXSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGspcmV0dXJuIGQoYSwgYiwgYykgPyBbY10gOiBbXTtcclxuICAgICAgICAgICAgICAgIDAgIT09IGcgPyAoYS54IDwgYi54ID8gKGcgPSBhLCBrID0gYS54LCBoID0gYiwgYSA9IGIueCkgOiAoZyA9IGIsIGsgPSBiLngsIGggPSBhLCBhID0gYS54KSwgYy54IDwgZS54ID8gKGIgPSBjLCBwID0gYy54LCBtID0gZSwgYyA9IGUueCkgOiAoYiA9IGUsIHAgPSBlLngsIG0gPSBjLCBjID0gYy54KSkgOiAoYS55IDwgYi55ID8gKGcgPSBhLCBrID0gYS55LCBoID0gYiwgYSA9IGIueSkgOiAoZyA9IGIsIGsgPSBiLnksIGggPSBhLCBhID0gYS55KSwgYy55IDwgZS55ID8gKGIgPSBjLCBwID0gYy55LCBtID0gZSwgYyA9IGUueSkgOiAoYiA9IGUsIHAgPSBlLnksIG0gPSBjLCBjID0gYy55KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gayA8PSBwID8gYSA8IHAgPyBbXSA6IGEgPT09IHAgPyBmID8gW10gOiBbYl0gOiBhIDw9IGMgPyBbYiwgaF0gOiBbYiwgbV0gOlxyXG4gICAgICAgICAgICAgICAgICAgIGsgPiBjID8gW10gOiBrID09PSBjID8gZiA/IFtdIDogW2ddIDogYSA8PSBjID8gW2csIGhdIDogW2csIG1dXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGYoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBiLnggLSBhLngsIGYgPSBiLnkgLSBhLnk7XHJcbiAgICAgICAgICAgICAgICBiID0gYy54IC0gYS54O1xyXG4gICAgICAgICAgICAgICAgYyA9IGMueSAtIGEueTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gZC54IC0gYS54O1xyXG4gICAgICAgICAgICAgICAgZCA9IGQueSAtIGEueTtcclxuICAgICAgICAgICAgICAgIGEgPSBlICogYyAtIGYgKiBiO1xyXG4gICAgICAgICAgICAgICAgZSA9IGUgKiBkIC0gZiAqIGc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSkgPiBOdW1iZXIuRVBTSUxPTiA/IChiID0gZyAqIGMgLSBkICogYiwgMCA8IGEgPyAwIDw9IGUgJiYgMCA8PSBiIDogMCA8PSBlIHx8IDAgPD0gYikgOiAwIDwgZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjKGEpO1xyXG4gICAgICAgICAgICBiLmZvckVhY2goYyk7XHJcbiAgICAgICAgICAgIHZhciBnLCBoLCBtLCBrLCBsLCBwID0ge307XHJcbiAgICAgICAgICAgIG0gPSBhLmNvbmNhdCgpO1xyXG4gICAgICAgICAgICBnID0gMDtcclxuICAgICAgICAgICAgZm9yIChoID0gYi5sZW5ndGg7IGcgPCBoOyBnKyspQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobSwgYltnXSk7XHJcbiAgICAgICAgICAgIGcgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGggPSBtLmxlbmd0aDsgZyA8IGg7IGcrKylsID0gbVtnXS54ICsgXCI6XCIgKyBtW2ddLnksIHZvaWQgMCAhPT0gcFtsXSAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5TaGFwZVV0aWxzOiBEdXBsaWNhdGUgcG9pbnRcIiwgbCwgZyksIHBbbF0gPSBnO1xyXG4gICAgICAgICAgICBnID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gaC5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCBlID0gYSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgMCA+IGUgJiYgKGUgPSBkKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGEgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPiBkICYmIChnID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IGYoaFthXSwgaFtlXSwgaFtnXSwga1tiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkKXJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgICAgICBkID0gay5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBiIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAwID4gZSAmJiAoZSA9IGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBiICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBnID4gZCAmJiAoZyA9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZCA9IGYoa1tiXSwga1tlXSwga1tnXSwgaFthXSkpID8gITAgOiAhMVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjLCBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBoLmxlbmd0aDsgYysrKWlmIChmID0gYyArIDEsIGYgJT0gaC5sZW5ndGgsIGYgPSBlKGEsIGIsIGhbY10sIGhbZl0sICEwKSwgMCA8IGYubGVuZ3RoKXJldHVybiAhMDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITFcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnKGEsIGMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCwgZiwgaCwgaztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgbS5sZW5ndGg7IGQrKylmb3IgKGYgPSBiW21bZF1dLCBoID0gMDsgaCA8IGYubGVuZ3RoOyBoKyspaWYgKGsgPSBoICsgMSwgayAlPSBmLmxlbmd0aCwgayA9IGUoYSwgYywgZltoXSwgZltrXSwgITApLCAwIDwgay5sZW5ndGgpcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBoID0gYS5jb25jYXQoKSwgaywgbSA9IFtdLCBsLCBuLCBwLCB0LCBxLCB4ID0gW10sIEQsIHosIEosIEkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsID0gYi5sZW5ndGg7IEkgPFxyXG4gICAgICAgICAgICAgICAgbDsgSSsrKW0ucHVzaChJKTtcclxuICAgICAgICAgICAgICAgIEQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgUSA9IDIgKiBtLmxlbmd0aDsgMCA8IG0ubGVuZ3RoOykge1xyXG4gICAgICAgICAgICAgICAgICAgIFEtLTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IFEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbmZpbml0ZSBMb29wISBIb2xlcyBsZWZ0OlwiICsgbS5sZW5ndGggKyBcIiwgUHJvYmFibHkgSG9sZSBvdXRzaWRlIFNoYXBlIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChuID0gRDsgbiA8IGgubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGhbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChJID0gMDsgSSA8IG0ubGVuZ3RoOyBJKyspaWYgKHQgPSBtW0ldLCBxID0gcC54ICsgXCI6XCIgKyBwLnkgKyBcIjpcIiArIHQsIHZvaWQgMCA9PT0geFtxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IGJbdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHogPSAwOyB6IDwgay5sZW5ndGg7IHorKylpZiAodCA9IGtbel0sIGMobiwgeikgJiYgIWQocCwgdCkgJiYgIWcocCwgdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gejtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNwbGljZShJLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEID0gaC5zbGljZSgwLCBuICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGguc2xpY2Uobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiA9IGsuc2xpY2UobCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSiA9IGsuc2xpY2UoMCwgbCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBELmNvbmNhdCh6KS5jb25jYXQoSikuY29uY2F0KHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEQgPSBuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA8PSBsKWJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFtxXSA9ICEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gbClicmVha1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBoXHJcbiAgICAgICAgICAgIH0oYSwgYik7XHJcbiAgICAgICAgICAgIHZhciBuID1cclxuICAgICAgICAgICAgICAgIElhLnRyaWFuZ3VsYXRlKGcsICExKTtcclxuICAgICAgICAgICAgZyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaCA9IG4ubGVuZ3RoOyBnIDwgaDsgZysrKWZvciAoayA9IG5bZ10sIG0gPSAwOyAzID4gbTsgbSsrKWwgPSBrW21dLnggKyBcIjpcIiArIGtbbV0ueSwgbCA9IHBbbF0sIHZvaWQgMCAhPT0gbCAmJiAoa1ttXSA9IGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbi5jb25jYXQoKVxyXG4gICAgICAgIH0sIGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMCA+IElhLmFyZWEoYSlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcbiAgICBMYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYTtcclxuICAgIExhLnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGZvciAodmFyIGMgPSBhLmxlbmd0aCwgZCA9IDA7IGQgPCBjOyBkKyspdGhpcy5hZGRTaGFwZShhW2RdLCBiKVxyXG4gICAgfTtcclxuICAgIExhLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYyhhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGIgfHwgY29uc29sZS5lcnJvcihcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGMpLmFkZChhKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkLCBlLCBmO1xyXG4gICAgICAgICAgICBlID0gYS54IC0gYi54O1xyXG4gICAgICAgICAgICBmID0gYS55IC0gYi55O1xyXG4gICAgICAgICAgICBkID0gYy54IC0gYS54O1xyXG4gICAgICAgICAgICB2YXIgZyA9IGMueSAtIGEueSwgaCA9IGUgKiBlICsgZiAqIGY7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhlICogZyAtIGYgKiBkKSA+IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGguc3FydChoKSwgbSA9IE1hdGguc3FydChkICogZCArIGcgKiBnKSwgaCA9IGIueCAtIGYgLyBrO1xyXG4gICAgICAgICAgICAgICAgYiA9IGIueSArIGUgLyBrO1xyXG4gICAgICAgICAgICAgICAgZyA9ICgoYy54IC0gZyAvIG0gLSBoKSAqIGcgLSAoYy55ICsgZCAvIG0gLSBiKSAqIGQpIC8gKGUgKiBnIC0gZiAqIGQpO1xyXG4gICAgICAgICAgICAgICAgZCA9IGggKyBlICogZyAtIGEueDtcclxuICAgICAgICAgICAgICAgIGUgPSBiICsgZiAqIGcgLSBhLnk7XHJcbiAgICAgICAgICAgICAgICBmID0gZCAqIGQgKyBlICogZTtcclxuICAgICAgICAgICAgICAgIGlmICgyID49IGYpcmV0dXJuIG5ldyBEKGQsIGUpO1xyXG4gICAgICAgICAgICAgICAgZiA9IE1hdGguc3FydChmIC8gMilcclxuICAgICAgICAgICAgfSBlbHNlIGEgPSAhMSwgZSA+IE51bWJlci5FUFNJTE9OID8gZCA+IE51bWJlci5FUFNJTE9OICYmIChhID0gITApIDogZSA8IC1OdW1iZXIuRVBTSUxPTiA/IGQgPCAtTnVtYmVyLkVQU0lMT04gJiYgKGEgPSAhMCkgOiBNYXRoLnNpZ24oZikgPT09IE1hdGguc2lnbihnKSAmJiAoYSA9ICEwKSwgYSA/IChkID0gLWYsIGYgPSBNYXRoLnNxcnQoaCkpIDogKGQgPSBlLCBlID0gZiwgZiA9IE1hdGguc3FydChoIC8gMikpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEQoZCAvIGYsIGUgLyBmKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZShhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjLCBkO1xyXG4gICAgICAgICAgICBmb3IgKFIgPSBhLmxlbmd0aDsgMCA8PSAtLVI7KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gUjtcclxuICAgICAgICAgICAgICAgIGQgPSBSIC0gMTtcclxuICAgICAgICAgICAgICAgIDAgPiBkICYmIChkID0gYS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIHZhciBlLCBmID0gdSArIDIgKiBsO1xyXG4gICAgICAgICAgICAgICAgZm9yIChlID0gMDsgZSA8IGY7IGUrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gVSAqIGUsIGggPSBVICogKGUgKyAxKSwgayA9IGIgKyBjICsgZywgZyA9IGIgKyBkICsgZywgbSA9IGIgKyBkICsgaCwgaCA9IGIgKyBjICsgaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IGsgKyBILCBnID0gZyArIEgsIG0gPSBtICsgSCwgaCA9IGggKyBIO1xyXG4gICAgICAgICAgICAgICAgICAgIEouZmFjZXMucHVzaChuZXcgaGEoaywgZywgaCwgbnVsbCwgbnVsbCwgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIEouZmFjZXMucHVzaChuZXcgaGEoZywgbSwgaCwgbnVsbCwgbnVsbCwgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSB3LmdlbmVyYXRlU2lkZVdhbGxVVihKLCBrLCBnLCBtLCBoKTtcclxuICAgICAgICAgICAgICAgICAgICBKLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChba1swXSwga1sxXSwga1szXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIEouZmFjZVZlcnRleFV2c1swXS5wdXNoKFtrWzFdLCBrWzJdLCBrWzNdXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIEoudmVydGljZXMucHVzaChuZXcgcShhLCBiLCBjKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGcoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBhICs9IEg7XHJcbiAgICAgICAgICAgIGIgKz0gSDtcclxuICAgICAgICAgICAgYyArPSBIO1xyXG4gICAgICAgICAgICBKLmZhY2VzLnB1c2gobmV3IGhhKGEsIGIsIGMsIG51bGwsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAwKSk7XHJcbiAgICAgICAgICAgIGEgPSB3LmdlbmVyYXRlVG9wVVYoSiwgYSwgYiwgYyk7XHJcbiAgICAgICAgICAgIEouZmFjZVZlcnRleFV2c1swXS5wdXNoKGEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaCA9IHZvaWQgMCAhPT0gYi5hbW91bnQgPyBiLmFtb3VudCA6IDEwMCwgbSA9IHZvaWQgMCAhPT0gYi5iZXZlbFRoaWNrbmVzcyA/IGIuYmV2ZWxUaGlja25lc3MgOiA2LFxyXG4gICAgICAgICAgICBrID0gdm9pZCAwICE9PSBiLmJldmVsU2l6ZSA/IGIuYmV2ZWxTaXplIDogbSAtIDIsIGwgPSB2b2lkIDAgIT09IGIuYmV2ZWxTZWdtZW50cyA/IGIuYmV2ZWxTZWdtZW50cyA6IDMsXHJcbiAgICAgICAgICAgIHAgPSB2b2lkIDAgIT09IGIuYmV2ZWxFbmFibGVkID8gYi5iZXZlbEVuYWJsZWQgOiAhMCwgbiA9IHZvaWQgMCAhPT0gYi5jdXJ2ZVNlZ21lbnRzID8gYi5jdXJ2ZVNlZ21lbnRzIDogMTIsXHJcbiAgICAgICAgICAgIHUgPSB2b2lkIDAgIT09IGIuc3RlcHMgPyBiLnN0ZXBzIDogMSwgRyA9IGIuZXh0cnVkZVBhdGgsIHIsIEEgPSAhMSxcclxuICAgICAgICAgICAgdyA9IHZvaWQgMCAhPT0gYi5VVkdlbmVyYXRvciA/IGIuVVZHZW5lcmF0b3IgOiBMYS5Xb3JsZFVWR2VuZXJhdG9yLCB5LCB4LCB2LCBFO1xyXG4gICAgICAgIEcgJiYgKHIgPSBHLmdldFNwYWNlZFBvaW50cyh1KSwgQSA9ICEwLCBwID0gITEsIHkgPSB2b2lkIDAgIT09IGIuZnJhbWVzID8gYi5mcmFtZXMgOlxyXG4gICAgICAgICAgICBHLmNvbXB1dGVGcmVuZXRGcmFtZXModSwgITEpLCB4ID0gbmV3IHEsIHYgPSBuZXcgcSwgRSA9IG5ldyBxKTtcclxuICAgICAgICBwIHx8IChrID0gbSA9IGwgPSAwKTtcclxuICAgICAgICB2YXIgeiwgQywgRiwgSiA9IHRoaXMsIEggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCwgRyA9IGEuZXh0cmFjdFBvaW50cyhuKSwgbiA9IEcuc2hhcGUsIEkgPSBHLmhvbGVzO1xyXG4gICAgICAgIGlmIChHID0gIUlhLmlzQ2xvY2tXaXNlKG4pKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgQyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoRiA9IEkubGVuZ3RoOyBDIDwgRjsgQysrKXogPSBJW0NdLCBJYS5pc0Nsb2NrV2lzZSh6KSAmJiAoSVtDXSA9IHoucmV2ZXJzZSgpKTtcclxuICAgICAgICAgICAgRyA9ICExXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBUID0gSWEudHJpYW5ndWxhdGVTaGFwZShuLCBJKSwgUyA9IG47XHJcbiAgICAgICAgQyA9IDA7XHJcbiAgICAgICAgZm9yIChGID0gSS5sZW5ndGg7IEMgPCBGOyBDKyspeiA9IElbQ10sIG4gPSBuLmNvbmNhdCh6KTtcclxuICAgICAgICB2YXIgTiwgUSwgTSwgTywgUCwgVSA9IG4ubGVuZ3RoLCBXLCBWID0gVC5sZW5ndGgsIEcgPSBbXSwgUiA9IDA7XHJcbiAgICAgICAgTSA9IFMubGVuZ3RoO1xyXG4gICAgICAgIE4gPSBNIC0gMTtcclxuICAgICAgICBmb3IgKFEgPSBSICsgMTsgUiA8IE07IFIrKywgTisrLCBRKyspTiA9PT0gTSAmJiAoTiA9IDApLCBRID09PSBNICYmIChRID0gMCksIEdbUl0gPSBkKFNbUl0sIFNbTl0sIFNbUV0pO1xyXG4gICAgICAgIHZhciBYID0gW10sIFosIGNhID0gRy5jb25jYXQoKTtcclxuICAgICAgICBDID0gMDtcclxuICAgICAgICBmb3IgKEYgPSBJLmxlbmd0aDsgQyA8IEY7IEMrKykge1xyXG4gICAgICAgICAgICB6ID0gSVtDXTtcclxuICAgICAgICAgICAgWiA9IFtdO1xyXG4gICAgICAgICAgICBSID0gMDtcclxuICAgICAgICAgICAgTSA9IHoubGVuZ3RoO1xyXG4gICAgICAgICAgICBOID0gTSAtIDE7XHJcbiAgICAgICAgICAgIGZvciAoUSA9IFIgKyAxOyBSIDwgTTsgUisrLCBOKyssIFErKylOID09PSBNICYmIChOID0gMCksIFEgPT09IE0gJiYgKFEgPSAwKSwgWltSXSA9IGQoeltSXSwgeltOXSwgeltRXSk7XHJcbiAgICAgICAgICAgIFgucHVzaChaKTtcclxuICAgICAgICAgICAgY2EgPSBjYS5jb25jYXQoWilcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChOID0gMDsgTiA8IGw7IE4rKykge1xyXG4gICAgICAgICAgICBNID0gTiAvIGw7XHJcbiAgICAgICAgICAgIE8gPSBtICogTWF0aC5jb3MoTSAqIE1hdGguUEkgLyAyKTtcclxuICAgICAgICAgICAgUSA9IGsgKiBNYXRoLnNpbihNICogTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgICAgICBSID0gMDtcclxuICAgICAgICAgICAgZm9yIChNID0gUy5sZW5ndGg7IFIgPCBNOyBSKyspUCA9IGMoU1tSXSwgR1tSXSwgUSksIGYoUC54LCBQLnksIC1PKTtcclxuICAgICAgICAgICAgQyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoRiA9IEkubGVuZ3RoOyBDIDwgRjsgQysrKWZvciAoeiA9IElbQ10sIFogPSBYW0NdLCBSID0gMCwgTSA9IHoubGVuZ3RoOyBSIDwgTTsgUisrKVAgPSBjKHpbUl0sIFpbUl0sIFEpLCBmKFAueCwgUC55LCAtTylcclxuICAgICAgICB9XHJcbiAgICAgICAgUSA9IGs7XHJcbiAgICAgICAgZm9yIChSID0gMDsgUiA8IFU7IFIrKylQID0gcCA/IGMobltSXSwgY2FbUl0sIFEpIDogbltSXSwgQSA/ICh2LmNvcHkoeS5ub3JtYWxzWzBdKS5tdWx0aXBseVNjYWxhcihQLngpLCB4LmNvcHkoeS5iaW5vcm1hbHNbMF0pLm11bHRpcGx5U2NhbGFyKFAueSksXHJcbiAgICAgICAgICAgIEUuY29weShyWzBdKS5hZGQodikuYWRkKHgpLCBmKEUueCwgRS55LCBFLnopKSA6IGYoUC54LCBQLnksIDApO1xyXG4gICAgICAgIGZvciAoTSA9IDE7IE0gPD0gdTsgTSsrKWZvciAoUiA9IDA7IFIgPCBVOyBSKyspUCA9IHAgPyBjKG5bUl0sIGNhW1JdLCBRKSA6IG5bUl0sIEEgPyAodi5jb3B5KHkubm9ybWFsc1tNXSkubXVsdGlwbHlTY2FsYXIoUC54KSwgeC5jb3B5KHkuYmlub3JtYWxzW01dKS5tdWx0aXBseVNjYWxhcihQLnkpLCBFLmNvcHkocltNXSkuYWRkKHYpLmFkZCh4KSwgZihFLngsIEUueSwgRS56KSkgOiBmKFAueCwgUC55LCBoIC8gdSAqIE0pO1xyXG4gICAgICAgIGZvciAoTiA9IGwgLSAxOyAwIDw9IE47IE4tLSkge1xyXG4gICAgICAgICAgICBNID0gTiAvIGw7XHJcbiAgICAgICAgICAgIE8gPSBtICogTWF0aC5jb3MoTSAqIE1hdGguUEkgLyAyKTtcclxuICAgICAgICAgICAgUSA9IGsgKiBNYXRoLnNpbihNICogTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgICAgICBSID0gMDtcclxuICAgICAgICAgICAgZm9yIChNID0gUy5sZW5ndGg7IFIgPCBNOyBSKyspUCA9IGMoU1tSXSwgR1tSXSwgUSksIGYoUC54LCBQLnksIGggKyBPKTtcclxuICAgICAgICAgICAgQyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoRiA9IEkubGVuZ3RoOyBDIDwgRjsgQysrKWZvciAoeiA9IElbQ10sIFogPSBYW0NdLCBSID0gMCwgTSA9IHoubGVuZ3RoOyBSIDwgTTsgUisrKVAgPSBjKHpbUl0sIFpbUl0sIFEpLCBBID8gZihQLngsIFAueSArIHJbdSAtIDFdLnksXHJcbiAgICAgICAgICAgICAgICByW3UgLSAxXS54ICsgTykgOiBmKFAueCwgUC55LCBoICsgTylcclxuICAgICAgICB9XHJcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gMCAqIFU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKFIgPSAwOyBSIDwgVjsgUisrKVcgPSBUW1JdLCBnKFdbMl0gKyBhLCBXWzFdICsgYSwgV1swXSArIGEpO1xyXG4gICAgICAgICAgICAgICAgYSA9IFUgKiAodSArIDIgKiBsKTtcclxuICAgICAgICAgICAgICAgIGZvciAoUiA9IDA7IFIgPCBWOyBSKyspVyA9IFRbUl0sIGcoV1swXSArIGEsIFdbMV0gKyBhLCBXWzJdICsgYSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAoUiA9IDA7IFIgPCBWOyBSKyspVyA9IFRbUl0sIGcoV1syXSwgV1sxXSwgV1swXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKFIgPSAwOyBSIDwgVjsgUisrKVcgPSBUW1JdLCBnKFdbMF0gKyBVICogdSwgV1sxXSArIFUgKiB1LCBXWzJdICsgVSAqIHUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gMDtcclxuICAgICAgICAgICAgZShTLCBhKTtcclxuICAgICAgICAgICAgYSArPSBTLmxlbmd0aDtcclxuICAgICAgICAgICAgQyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoRiA9IEkubGVuZ3RoOyBDIDwgRjsgQysrKXogPSBJW0NdLCBlKHosIGEpLCBhICs9IHoubGVuZ3RoXHJcbiAgICAgICAgfSkoKVxyXG4gICAgfTtcclxuICAgIExhLldvcmxkVVZHZW5lcmF0b3IgPSB7XHJcbiAgICAgICAgZ2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgYSA9IGEudmVydGljZXM7XHJcbiAgICAgICAgICAgIGIgPSBhW2JdO1xyXG4gICAgICAgICAgICBjID0gYVtjXTtcclxuICAgICAgICAgICAgZCA9IGFbZF07XHJcbiAgICAgICAgICAgIHJldHVybiBbbmV3IEQoYi54LCBiLnkpLCBuZXcgRChjLngsIGMueSksIG5ldyBEKGQueCwgZC55KV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgYSA9IGEudmVydGljZXM7XHJcbiAgICAgICAgICAgIGIgPSBhW2JdO1xyXG4gICAgICAgICAgICBjID0gYVtjXTtcclxuICAgICAgICAgICAgZCA9IGFbZF07XHJcbiAgICAgICAgICAgIGUgPSBhW2VdO1xyXG4gICAgICAgICAgICByZXR1cm4gLjAxID4gTWF0aC5hYnMoYi55IC0gYy55KSA/IFtuZXcgRChiLngsIDEgLSBiLnopLCBuZXcgRChjLngsIDEgLSBjLnopLCBuZXcgRChkLngsIDEgLSBkLnopLCBuZXcgRChlLngsIDEgLSBlLnopXSA6IFtuZXcgRChiLnksIDEgLSBiLnopLCBuZXcgRChjLnksIDEgLSBjLnopLCBuZXcgRChkLnksIDEgLSBkLnopLCBuZXcgRChlLnksIDEgLSBlLnopXVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBRYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExhLnByb3RvdHlwZSk7XHJcbiAgICBRYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRYztcclxuICAgIFJjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG4gICAgUmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmM7XHJcbiAgICBwYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEkucHJvdG90eXBlKTtcclxuICAgIHBiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHBiO1xyXG4gICAgU2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcbiAgICBTYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPVxyXG4gICAgICAgIFNjO1xyXG4gICAgV2IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJLnByb3RvdHlwZSk7XHJcbiAgICBXYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXYjtcclxuICAgIFRjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG4gICAgVGMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGM7XHJcbiAgICBYYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEkucHJvdG90eXBlKTtcclxuICAgIFhiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhiO1xyXG4gICAgWWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcbiAgICBZYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBZYjtcclxuICAgIFpiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSS5wcm90b3R5cGUpO1xyXG4gICAgWmIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWmI7XHJcbiAgICAkYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEkucHJvdG90eXBlKTtcclxuICAgICRiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9ICRiO1xyXG4gICAgcWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcbiAgICBxYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBxYjtcclxuICAgIFZhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSS5wcm90b3R5cGUpO1xyXG4gICAgVmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmE7XHJcbiAgICBVYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHFiLnByb3RvdHlwZSk7XHJcbiAgICBVYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVYztcclxuICAgIFZjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVmEucHJvdG90eXBlKTtcclxuICAgIFZjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZjO1xyXG4gICAgV2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcbiAgICBXYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXYztcclxuICAgIGFjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSS5wcm90b3R5cGUpO1xyXG4gICAgYWMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYWM7XHJcbiAgICB2YXIgTWEgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBXaXJlZnJhbWVHZW9tZXRyeTogT2IsXHJcbiAgICAgICAgUGFyYW1ldHJpY0dlb21ldHJ5OiBIYyxcclxuICAgICAgICBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk6IFBiLFxyXG4gICAgICAgIFRldHJhaGVkcm9uR2VvbWV0cnk6IEpjLFxyXG4gICAgICAgIFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IFFiLFxyXG4gICAgICAgIE9jdGFoZWRyb25HZW9tZXRyeTogS2MsXHJcbiAgICAgICAgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBvYixcclxuICAgICAgICBJY29zYWhlZHJvbkdlb21ldHJ5OiBMYyxcclxuICAgICAgICBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBSYixcclxuICAgICAgICBEb2RlY2FoZWRyb25HZW9tZXRyeTogTWMsXHJcbiAgICAgICAgRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IFNiLFxyXG4gICAgICAgIFBvbHloZWRyb25HZW9tZXRyeTogSWMsXHJcbiAgICAgICAgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBCYSxcclxuICAgICAgICBUdWJlR2VvbWV0cnk6IE5jLFxyXG4gICAgICAgIFR1YmVCdWZmZXJHZW9tZXRyeTogVGIsXHJcbiAgICAgICAgVG9ydXNLbm90R2VvbWV0cnk6IE9jLFxyXG4gICAgICAgIFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5OiBVYixcclxuICAgICAgICBUb3J1c0dlb21ldHJ5OiBQYyxcclxuICAgICAgICBUb3J1c0J1ZmZlckdlb21ldHJ5OiBWYixcclxuICAgICAgICBUZXh0R2VvbWV0cnk6IFFjLFxyXG4gICAgICAgIFNwaGVyZUdlb21ldHJ5OiBSYyxcclxuICAgICAgICBTcGhlcmVCdWZmZXJHZW9tZXRyeTogcGIsXHJcbiAgICAgICAgUmluZ0dlb21ldHJ5OiBTYyxcclxuICAgICAgICBSaW5nQnVmZmVyR2VvbWV0cnk6IFdiLFxyXG4gICAgICAgIFBsYW5lR2VvbWV0cnk6IEFjLFxyXG4gICAgICAgIFBsYW5lQnVmZmVyR2VvbWV0cnk6IGxiLFxyXG4gICAgICAgIExhdGhlR2VvbWV0cnk6IFRjLFxyXG4gICAgICAgIExhdGhlQnVmZmVyR2VvbWV0cnk6IFhiLFxyXG4gICAgICAgIFNoYXBlR2VvbWV0cnk6IFliLFxyXG4gICAgICAgIFNoYXBlQnVmZmVyR2VvbWV0cnk6IFpiLFxyXG4gICAgICAgIEV4dHJ1ZGVHZW9tZXRyeTogTGEsXHJcbiAgICAgICAgRWRnZXNHZW9tZXRyeTogJGIsXHJcbiAgICAgICAgQ29uZUdlb21ldHJ5OiBVYyxcclxuICAgICAgICBDb25lQnVmZmVyR2VvbWV0cnk6IFZjLFxyXG4gICAgICAgIEN5bGluZGVyR2VvbWV0cnk6IHFiLFxyXG4gICAgICAgIEN5bGluZGVyQnVmZmVyR2VvbWV0cnk6IFZhLFxyXG4gICAgICAgIENpcmNsZUdlb21ldHJ5OiBXYyxcclxuICAgICAgICBDaXJjbGVCdWZmZXJHZW9tZXRyeTogYWMsXHJcbiAgICAgICAgQm94R2VvbWV0cnk6IEliLFxyXG4gICAgICAgIEJveEJ1ZmZlckdlb21ldHJ5OiBrYlxyXG4gICAgfSk7XHJcbiAgICBiYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhhLnByb3RvdHlwZSk7XHJcbiAgICBiYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBiYztcclxuICAgIGJjLnByb3RvdHlwZS5pc1NoYWRvd01hdGVyaWFsID0gITA7XHJcbiAgICBjYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhhLnByb3RvdHlwZSk7XHJcbiAgICBjYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjYztcclxuICAgIGNjLnByb3RvdHlwZS5pc1Jhd1NoYWRlck1hdGVyaWFsID0gITA7XHJcbiAgICBYYy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IFhjLCBpc011bHRpTWF0ZXJpYWw6ICEwLCB0b0pTT046IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB7XHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge3ZlcnNpb246IDQuMiwgdHlwZTogXCJtYXRlcmlhbFwiLCBnZW5lcmF0b3I6IFwiTWF0ZXJpYWxFeHBvcnRlclwifSxcclxuICAgICAgICAgICAgICAgIHV1aWQ6IHRoaXMudXVpZCwgdHlwZTogdGhpcy50eXBlLCBtYXRlcmlhbHM6IFtdXHJcbiAgICAgICAgICAgIH0sIGMgPSB0aGlzLm1hdGVyaWFscywgZCA9IDAsIGUgPSBjLmxlbmd0aDsgZCA8IGU7IGQrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBjW2RdLnRvSlNPTihhKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmLm1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgYi5tYXRlcmlhbHMucHVzaChmKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcclxuICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gbmV3IHRoaXMuY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgIGIgPSAwOyBiIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBiKyspYS5tYXRlcmlhbHMucHVzaCh0aGlzLm1hdGVyaWFsc1tiXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgYS52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBRYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFgucHJvdG90eXBlKTtcclxuICAgIFFhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFFhO1xyXG4gICAgUWEucHJvdG90eXBlLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSAhMDtcclxuICAgIFFhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBYLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgYSk7XHJcbiAgICAgICAgdGhpcy5kZWZpbmVzID0ge1NUQU5EQVJEOiBcIlwifTtcclxuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoYS5jb2xvcik7XHJcbiAgICAgICAgdGhpcy5yb3VnaG5lc3MgPSBhLnJvdWdobmVzcztcclxuICAgICAgICB0aGlzLm1ldGFsbmVzcyA9IGEubWV0YWxuZXNzO1xyXG4gICAgICAgIHRoaXMubWFwID0gYS5tYXA7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcCA9IGEubGlnaHRNYXA7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IGEubGlnaHRNYXBJbnRlbnNpdHk7XHJcbiAgICAgICAgdGhpcy5hb01hcCA9IGEuYW9NYXA7XHJcbiAgICAgICAgdGhpcy5hb01hcEludGVuc2l0eSA9IGEuYW9NYXBJbnRlbnNpdHk7XHJcbiAgICAgICAgdGhpcy5lbWlzc2l2ZS5jb3B5KGEuZW1pc3NpdmUpO1xyXG4gICAgICAgIHRoaXMuZW1pc3NpdmVNYXAgPSBhLmVtaXNzaXZlTWFwO1xyXG4gICAgICAgIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBhLmVtaXNzaXZlSW50ZW5zaXR5O1xyXG4gICAgICAgIHRoaXMuYnVtcE1hcCA9IGEuYnVtcE1hcDtcclxuICAgICAgICB0aGlzLmJ1bXBTY2FsZSA9IGEuYnVtcFNjYWxlO1xyXG4gICAgICAgIHRoaXMubm9ybWFsTWFwID0gYS5ub3JtYWxNYXA7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxTY2FsZS5jb3B5KGEubm9ybWFsU2NhbGUpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gYS5kaXNwbGFjZW1lbnRNYXA7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IGEuZGlzcGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gYS5kaXNwbGFjZW1lbnRCaWFzO1xyXG4gICAgICAgIHRoaXMucm91Z2huZXNzTWFwID0gYS5yb3VnaG5lc3NNYXA7XHJcbiAgICAgICAgdGhpcy5tZXRhbG5lc3NNYXAgPSBhLm1ldGFsbmVzc01hcDtcclxuICAgICAgICB0aGlzLmFscGhhTWFwID0gYS5hbHBoYU1hcDtcclxuICAgICAgICB0aGlzLmVudk1hcCA9IGEuZW52TWFwO1xyXG4gICAgICAgIHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gYS5lbnZNYXBJbnRlbnNpdHk7XHJcbiAgICAgICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBhLnJlZnJhY3Rpb25SYXRpbztcclxuICAgICAgICB0aGlzLndpcmVmcmFtZSA9IGEud2lyZWZyYW1lO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gYS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gYS53aXJlZnJhbWVMaW5lY2FwO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBhLndpcmVmcmFtZUxpbmVqb2luO1xyXG4gICAgICAgIHRoaXMuc2tpbm5pbmcgPSBhLnNraW5uaW5nO1xyXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRzID0gYS5tb3JwaFRhcmdldHM7XHJcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHMgPVxyXG4gICAgICAgICAgICBhLm1vcnBoTm9ybWFscztcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIHJiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUWEucHJvdG90eXBlKTtcclxuICAgIHJiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHJiO1xyXG4gICAgcmIucHJvdG90eXBlLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSAhMDtcclxuICAgIHJiLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBRYS5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMuZGVmaW5lcyA9IHtQSFlTSUNBTDogXCJcIn07XHJcbiAgICAgICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBhLnJlZmxlY3Rpdml0eTtcclxuICAgICAgICB0aGlzLmNsZWFyQ29hdCA9IGEuY2xlYXJDb2F0O1xyXG4gICAgICAgIHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzID0gYS5jbGVhckNvYXRSb3VnaG5lc3M7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH07XHJcbiAgICBDYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFgucHJvdG90eXBlKTtcclxuICAgIENhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhO1xyXG4gICAgQ2EucHJvdG90eXBlLmlzTWVzaFBob25nTWF0ZXJpYWwgPSAhMDtcclxuICAgIENhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBYLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcyxcclxuICAgICAgICAgICAgYSk7XHJcbiAgICAgICAgdGhpcy5jb2xvci5jb3B5KGEuY29sb3IpO1xyXG4gICAgICAgIHRoaXMuc3BlY3VsYXIuY29weShhLnNwZWN1bGFyKTtcclxuICAgICAgICB0aGlzLnNoaW5pbmVzcyA9IGEuc2hpbmluZXNzO1xyXG4gICAgICAgIHRoaXMubWFwID0gYS5tYXA7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcCA9IGEubGlnaHRNYXA7XHJcbiAgICAgICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IGEubGlnaHRNYXBJbnRlbnNpdHk7XHJcbiAgICAgICAgdGhpcy5hb01hcCA9IGEuYW9NYXA7XHJcbiAgICAgICAgdGhpcy5hb01hcEludGVuc2l0eSA9IGEuYW9NYXBJbnRlbnNpdHk7XHJcbiAgICAgICAgdGhpcy5lbWlzc2l2ZS5jb3B5KGEuZW1pc3NpdmUpO1xyXG4gICAgICAgIHRoaXMuZW1pc3NpdmVNYXAgPSBhLmVtaXNzaXZlTWFwO1xyXG4gICAgICAgIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBhLmVtaXNzaXZlSW50ZW5zaXR5O1xyXG4gICAgICAgIHRoaXMuYnVtcE1hcCA9IGEuYnVtcE1hcDtcclxuICAgICAgICB0aGlzLmJ1bXBTY2FsZSA9IGEuYnVtcFNjYWxlO1xyXG4gICAgICAgIHRoaXMubm9ybWFsTWFwID0gYS5ub3JtYWxNYXA7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxTY2FsZS5jb3B5KGEubm9ybWFsU2NhbGUpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gYS5kaXNwbGFjZW1lbnRNYXA7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9XHJcbiAgICAgICAgICAgIGEuZGlzcGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gYS5kaXNwbGFjZW1lbnRCaWFzO1xyXG4gICAgICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBhLnNwZWN1bGFyTWFwO1xyXG4gICAgICAgIHRoaXMuYWxwaGFNYXAgPSBhLmFscGhhTWFwO1xyXG4gICAgICAgIHRoaXMuZW52TWFwID0gYS5lbnZNYXA7XHJcbiAgICAgICAgdGhpcy5jb21iaW5lID0gYS5jb21iaW5lO1xyXG4gICAgICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gYS5yZWZsZWN0aXZpdHk7XHJcbiAgICAgICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBhLnJlZnJhY3Rpb25SYXRpbztcclxuICAgICAgICB0aGlzLndpcmVmcmFtZSA9IGEud2lyZWZyYW1lO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gYS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gYS53aXJlZnJhbWVMaW5lY2FwO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBhLndpcmVmcmFtZUxpbmVqb2luO1xyXG4gICAgICAgIHRoaXMuc2tpbm5pbmcgPSBhLnNraW5uaW5nO1xyXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRzID0gYS5tb3JwaFRhcmdldHM7XHJcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBhLm1vcnBoTm9ybWFscztcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIHNiLnByb3RvdHlwZSA9XHJcbiAgICAgICAgT2JqZWN0LmNyZWF0ZShDYS5wcm90b3R5cGUpO1xyXG4gICAgc2IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc2I7XHJcbiAgICBzYi5wcm90b3R5cGUuaXNNZXNoVG9vbk1hdGVyaWFsID0gITA7XHJcbiAgICBzYi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgQ2EucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICB0aGlzLmdyYWRpZW50TWFwID0gYS5ncmFkaWVudE1hcDtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIHRiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoWC5wcm90b3R5cGUpO1xyXG4gICAgdGIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdGI7XHJcbiAgICB0Yi5wcm90b3R5cGUuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgPSAhMDtcclxuICAgIHRiLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBYLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgYSk7XHJcbiAgICAgICAgdGhpcy5idW1wTWFwID0gYS5idW1wTWFwO1xyXG4gICAgICAgIHRoaXMuYnVtcFNjYWxlID0gYS5idW1wU2NhbGU7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxNYXAgPSBhLm5vcm1hbE1hcDtcclxuICAgICAgICB0aGlzLm5vcm1hbFNjYWxlLmNvcHkoYS5ub3JtYWxTY2FsZSk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBhLmRpc3BsYWNlbWVudE1hcDtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gYS5kaXNwbGFjZW1lbnRTY2FsZTtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBhLmRpc3BsYWNlbWVudEJpYXM7XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWUgPSBhLndpcmVmcmFtZTtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGEud2lyZWZyYW1lTGluZXdpZHRoO1xyXG4gICAgICAgIHRoaXMuc2tpbm5pbmcgPSBhLnNraW5uaW5nO1xyXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRzID0gYS5tb3JwaFRhcmdldHM7XHJcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBhLm1vcnBoTm9ybWFscztcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIHViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoWC5wcm90b3R5cGUpO1xyXG4gICAgdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdWI7XHJcbiAgICB1Yi5wcm90b3R5cGUuaXNNZXNoTGFtYmVydE1hdGVyaWFsID0gITA7XHJcbiAgICB1Yi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgWC5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMuY29sb3IuY29weShhLmNvbG9yKTtcclxuICAgICAgICB0aGlzLm1hcCA9IGEubWFwO1xyXG4gICAgICAgIHRoaXMubGlnaHRNYXAgPSBhLmxpZ2h0TWFwO1xyXG4gICAgICAgIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPVxyXG4gICAgICAgICAgICBhLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG4gICAgICAgIHRoaXMuYW9NYXAgPSBhLmFvTWFwO1xyXG4gICAgICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBhLmFvTWFwSW50ZW5zaXR5O1xyXG4gICAgICAgIHRoaXMuZW1pc3NpdmUuY29weShhLmVtaXNzaXZlKTtcclxuICAgICAgICB0aGlzLmVtaXNzaXZlTWFwID0gYS5lbWlzc2l2ZU1hcDtcclxuICAgICAgICB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gYS5lbWlzc2l2ZUludGVuc2l0eTtcclxuICAgICAgICB0aGlzLnNwZWN1bGFyTWFwID0gYS5zcGVjdWxhck1hcDtcclxuICAgICAgICB0aGlzLmFscGhhTWFwID0gYS5hbHBoYU1hcDtcclxuICAgICAgICB0aGlzLmVudk1hcCA9IGEuZW52TWFwO1xyXG4gICAgICAgIHRoaXMuY29tYmluZSA9IGEuY29tYmluZTtcclxuICAgICAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IGEucmVmbGVjdGl2aXR5O1xyXG4gICAgICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gYS5yZWZyYWN0aW9uUmF0aW87XHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWUgPSBhLndpcmVmcmFtZTtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGEud2lyZWZyYW1lTGluZXdpZHRoO1xyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IGEud2lyZWZyYW1lTGluZWNhcDtcclxuICAgICAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gYS53aXJlZnJhbWVMaW5lam9pbjtcclxuICAgICAgICB0aGlzLnNraW5uaW5nID0gYS5za2lubmluZztcclxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGEubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzID0gYS5tb3JwaE5vcm1hbHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH07XHJcbiAgICB2Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFgucHJvdG90eXBlKTtcclxuICAgIHZiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHZiO1xyXG4gICAgdmIucHJvdG90eXBlLmlzTGluZURhc2hlZE1hdGVyaWFsID0gITA7XHJcbiAgICB2Yi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgWC5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMuY29sb3IuY29weShhLmNvbG9yKTtcclxuICAgICAgICB0aGlzLmxpbmV3aWR0aCA9IGEubGluZXdpZHRoO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBhLnNjYWxlO1xyXG4gICAgICAgIHRoaXMuZGFzaFNpemUgPSBhLmRhc2hTaXplO1xyXG4gICAgICAgIHRoaXMuZ2FwU2l6ZSA9IGEuZ2FwU2l6ZTtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIHZhciBYZiA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIFNoYWRvd01hdGVyaWFsOiBiYyxcclxuICAgICAgICBTcHJpdGVNYXRlcmlhbDogbmIsXHJcbiAgICAgICAgUmF3U2hhZGVyTWF0ZXJpYWw6IGNjLFxyXG4gICAgICAgIFNoYWRlck1hdGVyaWFsOiBIYSxcclxuICAgICAgICBQb2ludHNNYXRlcmlhbDogT2EsXHJcbiAgICAgICAgTXVsdGlNYXRlcmlhbDogWGMsXHJcbiAgICAgICAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6IHJiLFxyXG4gICAgICAgIE1lc2hTdGFuZGFyZE1hdGVyaWFsOiBRYSxcclxuICAgICAgICBNZXNoUGhvbmdNYXRlcmlhbDogQ2EsXHJcbiAgICAgICAgTWVzaFRvb25NYXRlcmlhbDogc2IsXHJcbiAgICAgICAgTWVzaE5vcm1hbE1hdGVyaWFsOiB0YixcclxuICAgICAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiB1YixcclxuICAgICAgICBNZXNoRGVwdGhNYXRlcmlhbDogYWIsXHJcbiAgICAgICAgTWVzaEJhc2ljTWF0ZXJpYWw6IEthLFxyXG4gICAgICAgIExpbmVEYXNoZWRNYXRlcmlhbDogdmIsXHJcbiAgICAgICAgTGluZUJhc2ljTWF0ZXJpYWw6IGlhLFxyXG4gICAgICAgIE1hdGVyaWFsOiBYXHJcbiAgICB9KSwgbGQgPSB7XHJcbiAgICAgICAgZW5hYmxlZDogITEsIGZpbGVzOiB7fSwgYWRkOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAhMSAhPT0gdGhpcy5lbmFibGVkICYmICh0aGlzLmZpbGVzW2FdID0gYilcclxuICAgICAgICB9LCBnZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmICghMSAhPT0gdGhpcy5lbmFibGVkKXJldHVybiB0aGlzLmZpbGVzW2FdXHJcbiAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1thXVxyXG4gICAgICAgIH0sIGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZXMgPSB7fVxyXG4gICAgICAgIH1cclxuICAgIH0sIHRhID0gbmV3ICRkO1xyXG4gICAgT2JqZWN0LmFzc2lnbihzYS5wcm90b3R5cGUsIHtcclxuICAgICAgICBsb2FkOiBmdW5jdGlvbiAoYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBcIlwiKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLnBhdGggJiYgKGEgPSB0aGlzLnBhdGggKyBhKTtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLCBmID0gbGQuZ2V0KGEpO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBmKXJldHVybiBlLm1hbmFnZXIuaXRlbVN0YXJ0KGEpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGIgJiYgYihmKTtcclxuICAgICAgICAgICAgICAgIGUubWFuYWdlci5pdGVtRW5kKGEpXHJcbiAgICAgICAgICAgIH0sIDApLCBmO1xyXG4gICAgICAgICAgICB2YXIgZyA9IGEubWF0Y2goL15kYXRhOiguKj8pKDtiYXNlNjQpPywoLiopJC8pO1xyXG4gICAgICAgICAgICBpZiAoZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBnWzFdLCBtID0gISFnWzJdLCBnID0gZ1szXSwgZyA9IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQoZyk7XHJcbiAgICAgICAgICAgICAgICBtICYmIChnID0gd2luZG93LmF0b2IoZykpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaywgbCA9ICh0aGlzLnJlc3BvbnNlVHlwZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJsb2JcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBuZXcgQXJyYXlCdWZmZXIoZy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IG5ldyBVaW50OEFycmF5KGspLCBtID0gMDsgbSA8IGcubGVuZ3RoOyBtKyspcFttXSA9IGcuY2hhckNvZGVBdChtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmxvYlwiID09PSBsICYmIChrID0gbmV3IEJsb2IoW2tdLCB7dHlwZTogaH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZG9jdW1lbnRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSAobmV3IERPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKGcsIGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrID0gSlNPTi5wYXJzZShnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IGdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiICYmIGIoayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWFuYWdlci5pdGVtRW5kKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMClcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHEpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgJiYgZChxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5tYW5hZ2VyLml0ZW1FcnJvcihhKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcclxuICAgICAgICAgICAgICAgIG4ub3BlbihcIkdFVFwiLCBhLCAhMCk7XHJcbiAgICAgICAgICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBjLnRhcmdldC5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICBsZC5hZGQoYSwgZik7XHJcbiAgICAgICAgICAgICAgICAgICAgMjAwID09PSB0aGlzLnN0YXR1cyA/IChiICYmIGIoZiksIGUubWFuYWdlci5pdGVtRW5kKGEpKSA6IDAgPT09IHRoaXMuc3RhdHVzID8gKGNvbnNvbGUud2FybihcIlRIUkVFLkZpbGVMb2FkZXI6IEhUVFAgU3RhdHVzIDAgcmVjZWl2ZWQuXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGIgJiYgYihmKSwgZS5tYW5hZ2VyLml0ZW1FbmQoYSkpIDogKGQgJiYgZChjKSwgZS5tYW5hZ2VyLml0ZW1FcnJvcihhKSlcclxuICAgICAgICAgICAgICAgIH0sICExKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gYyAmJiBuLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMoYSlcclxuICAgICAgICAgICAgICAgIH0sICExKTtcclxuICAgICAgICAgICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZCAmJiBkKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUubWFuYWdlci5pdGVtRXJyb3IoYSlcclxuICAgICAgICAgICAgICAgIH0sICExKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy5yZXNwb25zZVR5cGUgJiYgKG4ucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLndpdGhDcmVkZW50aWFscyAmJiAobi53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscyk7XHJcbiAgICAgICAgICAgICAgICBuLm92ZXJyaWRlTWltZVR5cGUgJiYgbi5vdmVycmlkZU1pbWVUeXBlKHZvaWQgMCAhPT0gdGhpcy5taW1lVHlwZSA/IHRoaXMubWltZVR5cGUgOiBcInRleHQvcGxhaW5cIik7XHJcbiAgICAgICAgICAgICAgICBuLnNlbmQobnVsbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlLm1hbmFnZXIuaXRlbVN0YXJ0KGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gblxyXG4gICAgICAgIH0sIHNldFBhdGg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9XHJcbiAgICAgICAgICAgICAgICBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFJlc3BvbnNlVHlwZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldE1pbWVUeXBlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbWVUeXBlID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5hc3NpZ24oUmUucHJvdG90eXBlLCB7XHJcbiAgICAgICAgbG9hZDogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZShlKSB7XHJcbiAgICAgICAgICAgICAgICBtLmxvYWQoYVtlXSwgZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gZi5fcGFyc2VyKGEsICEwKTtcclxuICAgICAgICAgICAgICAgICAgICBnW2VdID0ge3dpZHRoOiBhLndpZHRoLCBoZWlnaHQ6IGEuaGVpZ2h0LCBmb3JtYXQ6IGEuZm9ybWF0LCBtaXBtYXBzOiBhLm1pcG1hcHN9O1xyXG4gICAgICAgICAgICAgICAgICAgIGsgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICA2ID09PSBrICYmICgxID09PSBhLm1pcG1hcENvdW50ICYmIChoLm1pbkZpbHRlciA9IDEwMDYpLCBoLmZvcm1hdCA9IGEuZm9ybWF0LCBoLm5lZWRzVXBkYXRlID0gITAsIGIgJiYgYihoKSlcclxuICAgICAgICAgICAgICAgIH0sIGMsIGQpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmID0gdGhpcywgZyA9IFtdLCBoID0gbmV3IE5iO1xyXG4gICAgICAgICAgICBoLmltYWdlID0gZztcclxuICAgICAgICAgICAgdmFyIG0gPSBuZXcgc2EodGhpcy5tYW5hZ2VyKTtcclxuICAgICAgICAgICAgbS5zZXRQYXRoKHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgIG0uc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKWZvciAodmFyIGsgPSAwLCBsID0gMCwgcCA9IGEubGVuZ3RoOyBsIDwgcDsgKytsKWUobCk7IGVsc2UgbS5sb2FkKGEsIGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gZi5fcGFyc2VyKGEsICEwKTtcclxuICAgICAgICAgICAgICAgIGlmIChhLmlzQ3ViZW1hcClmb3IgKHZhciBjID0gYS5taXBtYXBzLmxlbmd0aCAvIGEubWlwbWFwQ291bnQsIGQgPSAwOyBkIDwgYzsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ1tkXSA9IHttaXBtYXBzOiBbXX07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBhLm1pcG1hcENvdW50OyBlKyspZ1tkXS5taXBtYXBzLnB1c2goYS5taXBtYXBzW2QgKiBhLm1pcG1hcENvdW50ICsgZV0pLCBnW2RdLmZvcm1hdCA9IGEuZm9ybWF0LCBnW2RdLndpZHRoID0gYS53aWR0aCwgZ1tkXS5oZWlnaHQgPSBhLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGguaW1hZ2Uud2lkdGggPSBhLndpZHRoLCBoLmltYWdlLmhlaWdodCA9IGEuaGVpZ2h0LCBoLm1pcG1hcHMgPSBhLm1pcG1hcHM7XHJcbiAgICAgICAgICAgICAgICAxID09PSBhLm1pcG1hcENvdW50ICYmXHJcbiAgICAgICAgICAgICAgICAoaC5taW5GaWx0ZXIgPSAxMDA2KTtcclxuICAgICAgICAgICAgICAgIGguZm9ybWF0ID0gYS5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICBoLm5lZWRzVXBkYXRlID0gITA7XHJcbiAgICAgICAgICAgICAgICBiICYmIGIoaClcclxuICAgICAgICAgICAgfSwgYywgZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBoXHJcbiAgICAgICAgfSwgc2V0UGF0aDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5hc3NpZ24oYWUucHJvdG90eXBlLCB7XHJcbiAgICAgICAgbG9hZDogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLCBmID0gbmV3IGViLCBnID0gbmV3IHNhKHRoaXMubWFuYWdlcik7XHJcbiAgICAgICAgICAgIGcuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XHJcbiAgICAgICAgICAgIGcubG9hZChhLCBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPSBlLl9wYXJzZXIoYSkpIHZvaWQgMCAhPT0gYS5pbWFnZSA/IGYuaW1hZ2UgPSBhLmltYWdlIDogdm9pZCAwICE9PSBhLmRhdGEgJiYgKGYuaW1hZ2Uud2lkdGggPSBhLndpZHRoLCBmLmltYWdlLmhlaWdodCA9IGEuaGVpZ2h0LCBmLmltYWdlLmRhdGEgPSBhLmRhdGEpLCBmLndyYXBTID0gdm9pZCAwICE9PSBhLndyYXBTID8gYS53cmFwUyA6IDEwMDEsIGYud3JhcFQgPSB2b2lkIDAgIT09IGEud3JhcFQgPyBhLndyYXBUIDogMTAwMSwgZi5tYWdGaWx0ZXIgPSB2b2lkIDAgIT09XHJcbiAgICAgICAgICAgICAgICBhLm1hZ0ZpbHRlciA/IGEubWFnRmlsdGVyIDogMTAwNiwgZi5taW5GaWx0ZXIgPSB2b2lkIDAgIT09IGEubWluRmlsdGVyID8gYS5taW5GaWx0ZXIgOiAxMDA4LCBmLmFuaXNvdHJvcHkgPSB2b2lkIDAgIT09IGEuYW5pc290cm9weSA/IGEuYW5pc290cm9weSA6IDEsIHZvaWQgMCAhPT0gYS5mb3JtYXQgJiYgKGYuZm9ybWF0ID0gYS5mb3JtYXQpLCB2b2lkIDAgIT09IGEudHlwZSAmJiAoZi50eXBlID0gYS50eXBlKSwgdm9pZCAwICE9PSBhLm1pcG1hcHMgJiYgKGYubWlwbWFwcyA9IGEubWlwbWFwcyksIDEgPT09IGEubWlwbWFwQ291bnQgJiYgKGYubWluRmlsdGVyID0gMTAwNiksIGYubmVlZHNVcGRhdGUgPSAhMCwgYiAmJiBiKGYsIGEpXHJcbiAgICAgICAgICAgIH0sIGMsIGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZlxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihZYy5wcm90b3R5cGUsIHtcclxuICAgICAgICBsb2FkOiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBcIlwiKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLnBhdGggJiYgKGEgPSB0aGlzLnBhdGggKyBhKTtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLCBmID0gbGQuZ2V0KGEpO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBmKXJldHVybiBlLm1hbmFnZXIuaXRlbVN0YXJ0KGEpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGIgJiZcclxuICAgICAgICAgICAgICAgIGIoZik7XHJcbiAgICAgICAgICAgICAgICBlLm1hbmFnZXIuaXRlbUVuZChhKVxyXG4gICAgICAgICAgICB9LCAwKSwgZjtcclxuICAgICAgICAgICAgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJpbWdcIik7XHJcbiAgICAgICAgICAgIGMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGQuYWRkKGEsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYiAmJiBiKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgZS5tYW5hZ2VyLml0ZW1FbmQoYSlcclxuICAgICAgICAgICAgfSwgITEpO1xyXG4gICAgICAgICAgICBjLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgZCAmJiBkKGIpO1xyXG4gICAgICAgICAgICAgICAgZS5tYW5hZ2VyLml0ZW1FcnJvcihhKVxyXG4gICAgICAgICAgICB9LCAhMSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy5jcm9zc09yaWdpbiAmJiAoYy5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW4pO1xyXG4gICAgICAgICAgICBlLm1hbmFnZXIuaXRlbVN0YXJ0KGEpO1xyXG4gICAgICAgICAgICBjLnNyYyA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgfSwgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFBhdGg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKGJlLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoYykge1xyXG4gICAgICAgICAgICAgICAgZy5sb2FkKGFbY10sIGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZi5pbWFnZXNbY10gPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGgrKztcclxuICAgICAgICAgICAgICAgICAgICA2ID09PSBoICYmIChmLm5lZWRzVXBkYXRlID0gITAsIGIgJiYgYihmKSlcclxuICAgICAgICAgICAgICAgIH0sIHZvaWQgMCwgZClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgWmEsIGcgPSBuZXcgWWModGhpcy5tYW5hZ2VyKTtcclxuICAgICAgICAgICAgZy5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcclxuICAgICAgICAgICAgZy5zZXRQYXRoKHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgIHZhciBoID0gMDtcclxuICAgICAgICAgICAgZm9yIChjID0gMDsgYyA8IGEubGVuZ3RoOyArK2MpZShjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZcclxuICAgICAgICB9LCBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0UGF0aDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5hc3NpZ24odGQucHJvdG90eXBlLCB7XHJcbiAgICAgICAgbG9hZDogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgZWEsIGYgPSBuZXcgWWModGhpcy5tYW5hZ2VyKTtcclxuICAgICAgICAgICAgZi5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcclxuICAgICAgICAgICAgZi5zZXRQYXRoKHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgIGYubG9hZChhLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IDAgPCBhLnNlYXJjaCgvXFwuKGpwZ3xqcGVnKSQvKSB8fCAwID09PSBhLnNlYXJjaCgvXmRhdGFcXDppbWFnZVxcL2pwZWcvKTtcclxuICAgICAgICAgICAgICAgICAgICBlLmZvcm1hdCA9IGQgPyAxMDIyIDogMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBlLmltYWdlID0gYztcclxuICAgICAgICAgICAgICAgICAgICBlLm5lZWRzVXBkYXRlID0gITA7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiICYmIGIoZSlcclxuICAgICAgICAgICAgICAgIH0sIGMsIGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgIH0sIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRQYXRoOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbWEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHgucHJvdG90eXBlKSwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBtYSwgaXNMaWdodDogITAsIGNvcHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHgucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvci5jb3B5KGEuY29sb3IpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVuc2l0eSA9IGEuaW50ZW5zaXR5O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHRvSlNPTjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSA9IHgucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhKTtcclxuICAgICAgICAgICAgYS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG4gICAgICAgICAgICBhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLmdyb3VuZENvbG9yICYmIChhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMuZGlzdGFuY2UgJiYgKGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy5hbmdsZSAmJiAoYS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLmRlY2F5ICYmIChhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMucGVudW1icmEgJiYgKGEub2JqZWN0LnBlbnVtYnJhID0gdGhpcy5wZW51bWJyYSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy5zaGFkb3cgJiYgKGEub2JqZWN0LnNoYWRvdyA9IHRoaXMuc2hhZG93LnRvSlNPTigpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHVkLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShtYS5wcm90b3R5cGUpLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IHVkLFxyXG4gICAgICAgIGlzSGVtaXNwaGVyZUxpZ2h0OiAhMCwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgbWEucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICAgICAgdGhpcy5ncm91bmRDb2xvci5jb3B5KGEuZ3JvdW5kQ29sb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbih3Yi5wcm90b3R5cGUsIHtcclxuICAgICAgICBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYSA9IGEuY2FtZXJhLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmlhcyA9IGEuYmlhcztcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBhLnJhZGl1cztcclxuICAgICAgICAgICAgdGhpcy5tYXBTaXplLmNvcHkoYS5tYXBTaXplKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSwgdG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0ge307XHJcbiAgICAgICAgICAgIDAgIT09IHRoaXMuYmlhcyAmJiAoYS5iaWFzID0gdGhpcy5iaWFzKTtcclxuICAgICAgICAgICAgMSAhPT0gdGhpcy5yYWRpdXMgJiYgKGEucmFkaXVzID0gdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICBpZiAoNTEyICE9PSB0aGlzLm1hcFNpemUueCB8fCA1MTIgIT09IHRoaXMubWFwU2l6ZS55KSBhLm1hcFNpemUgPSB0aGlzLm1hcFNpemUudG9BcnJheSgpO1xyXG4gICAgICAgICAgICBhLmNhbWVyYSA9IHRoaXMuY2FtZXJhLnRvSlNPTighMSkub2JqZWN0O1xyXG4gICAgICAgICAgICBkZWxldGUgYS5jYW1lcmEubWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHdiLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogdmQsXHJcbiAgICAgICAgaXNTcG90TGlnaHRTaGFkb3c6ICEwLFxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSAyICogTi5SQUQyREVHICogYS5hbmdsZSwgYyA9IHRoaXMubWFwU2l6ZS53aWR0aCAvIHRoaXMubWFwU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGEgPSBhLmRpc3RhbmNlIHx8IDUwMDtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmNhbWVyYTtcclxuICAgICAgICAgICAgaWYgKGIgIT09IGQuZm92IHx8IGMgIT09IGQuYXNwZWN0IHx8IGEgIT09IGQuZmFyKSBkLmZvdiA9IGIsIGQuYXNwZWN0ID0gYywgZC5mYXIgPSBhLCBkLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgd2QucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG1hLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcjogd2QsIGlzU3BvdExpZ2h0OiAhMCwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgbWEucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLFxyXG4gICAgICAgICAgICAgICAgYSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBhLmRpc3RhbmNlO1xyXG4gICAgICAgICAgICB0aGlzLmFuZ2xlID0gYS5hbmdsZTtcclxuICAgICAgICAgICAgdGhpcy5wZW51bWJyYSA9IGEucGVudW1icmE7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjYXkgPSBhLmRlY2F5O1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IGEudGFyZ2V0LmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93ID0gYS5zaGFkb3cuY2xvbmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHhkLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShtYS5wcm90b3R5cGUpLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IHhkLCBpc1BvaW50TGlnaHQ6ICEwLCBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBtYS5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gYS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgdGhpcy5kZWNheSA9IGEuZGVjYXk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93ID0gYS5zaGFkb3cuY2xvbmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHlkLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh3Yi5wcm90b3R5cGUpLCB7Y29uc3RydWN0b3I6IHlkfSk7XHJcbiAgICB6ZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobWEucHJvdG90eXBlKSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB6ZCwgaXNEaXJlY3Rpb25hbExpZ2h0OiAhMCwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgbWEucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBhLnRhcmdldC5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdyA9IGEuc2hhZG93LmNsb25lKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgQWQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG1hLnByb3RvdHlwZSksIHtjb25zdHJ1Y3RvcjogQWQsIGlzQW1iaWVudExpZ2h0OiAhMH0pO1xyXG4gICAgdmFyIG5hID0ge1xyXG4gICAgICAgIGFycmF5U2xpY2U6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYS5pc1R5cGVkQXJyYXkoYSkgPyBuZXcgYS5jb25zdHJ1Y3RvcihhLnN1YmFycmF5KGIsIGMpKSA6IGEuc2xpY2UoYiwgYylcclxuICAgICAgICB9LCBjb252ZXJ0QXJyYXk6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhYSB8fCAhYyAmJiBhLmNvbnN0cnVjdG9yID09PSBiID8gYSA6IFwibnVtYmVyXCIgPT09IHR5cGVvZiBiLkJZVEVTX1BFUl9FTEVNRU5UID8gbmV3IGIoYSkgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNUeXBlZEFycmF5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmICEoYSBpbnN0YW5jZW9mIERhdGFWaWV3KVxyXG4gICAgICAgIH0sIGdldEtleWZyYW1lT3JkZXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSBhLmxlbmd0aCwgYyA9IEFycmF5KGIpLCBkID0gMDsgZCAhPT0gYjsgKytkKWNbZF0gPSBkO1xyXG4gICAgICAgICAgICBjLnNvcnQoZnVuY3Rpb24gKGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhW2JdIC0gYVtjXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNcclxuICAgICAgICB9LCBzb3J0ZWRBcnJheTogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IGEubGVuZ3RoLCBlID0gbmV3IGEuY29uc3RydWN0b3IoZCksIGYgPSAwLCBnID0gMDsgZyAhPT0gZDsgKytmKWZvciAodmFyIGggPSBjW2ZdICogYixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAwOyBtICE9PSBiOyArK20pZVtnKytdID0gYVtoICsgbV07XHJcbiAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgfSwgZmxhdHRlbkpTT046IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSAxLCBmID0gYVswXTsgdm9pZCAwICE9PSBmICYmIHZvaWQgMCA9PT0gZltkXTspZiA9IGFbZSsrXTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBmW2RdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZylpZiAoQXJyYXkuaXNBcnJheShnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIGcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmW2RdLCB2b2lkIDAgIT09IGcgJiYgKGIucHVzaChmLnRpbWUpLCBjLnB1c2guYXBwbHkoYywgZykpLCBmID0gYVtlKytdOyB3aGlsZSAodm9pZCAwICE9PSBmKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IGcudG9BcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIGcgPSBmW2RdLCB2b2lkIDAgIT09IGcgJiYgKGIucHVzaChmLnRpbWUpLCBnLnRvQXJyYXkoYywgYy5sZW5ndGgpKSwgZiA9IGFbZSsrXTsgd2hpbGUgKHZvaWQgMCAhPT0gZilcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG8gZyA9IGZbZF0sIHZvaWQgMCAhPT0gZyAmJiAoYi5wdXNoKGYudGltZSksIGMucHVzaChnKSksIGYgPSBhW2UrK107IHdoaWxlICh2b2lkIDAgIT09IGYpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgeGEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB4YSwgZXZhbHVhdGU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsIGMgPSB0aGlzLl9jYWNoZWRJbmRleCwgZCA9IGJbY10sIGUgPSBiW2MgLSAxXTtcclxuICAgICAgICAgICAgYTp7XHJcbiAgICAgICAgICAgICAgICBiOntcclxuICAgICAgICAgICAgICAgICAgICBjOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDppZiAoIShhIDwgZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSBjICsgMjsgOykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBlKWJyZWFrIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZEluZGV4ID0gYyA9IGIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZnRlckVuZF8oYyAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLCBhLCBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gZilicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gYlsrK2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDwgZClicmVhayBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBjXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPj0gZSlicmVhayBhOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBiWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA8IGYgJiYgKGMgPSAyLCBlID0gZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGYgPSBjIC0gMjsgOykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpcmV0dXJuIHRoaXMuX2NhY2hlZEluZGV4ID0gMCwgdGhpcy5iZWZvcmVTdGFydF8oMCwgYSwgZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGYpYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGJbLS1jIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPj0gZSlicmVhayBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGMgPCBkOyllID0gYyArIGQgPj4+IDEsIGEgPCBiW2VdID8gZCA9IGUgOiBjID0gZSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IGJbY107XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IGJbYyAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpcmV0dXJuIHRoaXMuX2NhY2hlZEluZGV4ID0gMCwgdGhpcy5iZWZvcmVTdGFydF8oMCwgYSwgZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZClyZXR1cm4gdGhpcy5fY2FjaGVkSW5kZXggPSBjID0gYi5sZW5ndGgsIHRoaXMuYWZ0ZXJFbmRfKGMgLSAxLCBlLCBhKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkSW5kZXggPSBjO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbENoYW5nZWRfKGMsIGUsIGQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKGMsXHJcbiAgICAgICAgICAgICAgICBlLCBhLCBkKVxyXG4gICAgICAgIH0sIHNldHRpbmdzOiBudWxsLCBEZWZhdWx0U2V0dGluZ3NfOiB7fSwgZ2V0U2V0dGluZ3NfOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzIHx8IHRoaXMuRGVmYXVsdFNldHRpbmdzX1xyXG4gICAgICAgIH0sIGNvcHlTYW1wbGVWYWx1ZV86IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5yZXN1bHRCdWZmZXIsIGMgPSB0aGlzLnNhbXBsZVZhbHVlcywgZCA9IHRoaXMudmFsdWVTaXplO1xyXG4gICAgICAgICAgICBhICo9IGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlICE9PSBkOyArK2UpYltlXSA9IGNbYSArIGVdO1xyXG4gICAgICAgICAgICByZXR1cm4gYlxyXG4gICAgICAgIH0sIGludGVycG9sYXRlXzogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJjYWxsIHRvIGFic3RyYWN0IG1ldGhvZFwiKTtcclxuICAgICAgICB9LCBpbnRlcnZhbENoYW5nZWRfOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHhhLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGJlZm9yZVN0YXJ0XzogeGEucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8sXHJcbiAgICAgICAgYWZ0ZXJFbmRfOiB4YS5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlX1xyXG4gICAgfSk7XHJcbiAgICBCZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoeGEucHJvdG90eXBlKSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBCZCxcclxuICAgICAgICAgICAgRGVmYXVsdFNldHRpbmdzXzoge2VuZGluZ1N0YXJ0OiAyNDAwLCBlbmRpbmdFbmQ6IDI0MDB9LFxyXG4gICAgICAgICAgICBpbnRlcnZhbENoYW5nZWRfOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucywgZSA9IGEgLSAyLCBmID0gYSArIDEsIGcgPSBkW2VdLCBoID0gZFtmXTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGcpc3dpdGNoICh0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ1N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IDIgKiBiIC0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZC5sZW5ndGggLSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gYiArIGRbZV0gLSBkW2UgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGEsIGcgPSBjXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBoKXN3aXRjaCAodGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI0MDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gMiAqIGMgLSBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI0MDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gYyArIGRbMV0gLSBkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gYSAtIDEsIGggPSBiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhID0gLjUgKiAoYyAtIGIpO1xyXG4gICAgICAgICAgICAgICAgZCA9IHRoaXMudmFsdWVTaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0UHJldiA9IGEgLyAoYiAtIGcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0TmV4dCA9XHJcbiAgICAgICAgICAgICAgICAgICAgYSAvIChoIC0gYyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXRQcmV2ID0gZSAqIGQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXROZXh0ID0gZiAqIGRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnJlc3VsdEJ1ZmZlciwgZiA9IHRoaXMuc2FtcGxlVmFsdWVzLCBnID0gdGhpcy52YWx1ZVNpemU7XHJcbiAgICAgICAgICAgICAgICBhICo9IGc7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IGEgLSBnLCBtID0gdGhpcy5fb2Zmc2V0UHJldiwgayA9IHRoaXMuX29mZnNldE5leHQsIGwgPSB0aGlzLl93ZWlnaHRQcmV2LCBwID0gdGhpcy5fd2VpZ2h0TmV4dCxcclxuICAgICAgICAgICAgICAgICAgICBuID0gKGMgLSBiKSAvIChkIC0gYik7XHJcbiAgICAgICAgICAgICAgICBjID0gbiAqIG47XHJcbiAgICAgICAgICAgICAgICBkID0gYyAqIG47XHJcbiAgICAgICAgICAgICAgICBiID0gLWwgKiBkICsgMiAqIGwgKiBjIC0gbCAqIG47XHJcbiAgICAgICAgICAgICAgICBsID0gKDEgKyBsKSAqIGQgKyAoLTEuNSAtIDIgKiBsKSAqIGMgKyAoLS41ICsgbCkgKiBuICsgMTtcclxuICAgICAgICAgICAgICAgIG4gPSAoLTEgLSBwKSAqIGQgKyAoMS41ICsgcCkgKiBjICsgLjUgKiBuO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAgKiBkIC0gcCAqIGM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGMgPSAwOyBjICE9PSBnOyArK2MpZVtjXSA9IGIgKiBmW20gKyBjXSArIGwgKiBmW2ggKyBjXSArIG4gKiBmW2EgKyBjXSArIHAgKiBmW2sgKyBjXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIFpjLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4YS5wcm90b3R5cGUpLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IFpjLCBpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uIChhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucmVzdWx0QnVmZmVyLCBmID0gdGhpcy5zYW1wbGVWYWx1ZXMsIGcgPSB0aGlzLnZhbHVlU2l6ZTtcclxuICAgICAgICAgICAgYSAqPSBnO1xyXG4gICAgICAgICAgICB2YXIgaCA9IGEgLSBnO1xyXG4gICAgICAgICAgICBiID0gKGMgLSBiKSAvIChkIC0gYik7XHJcbiAgICAgICAgICAgIGMgPSAxIC0gYjtcclxuICAgICAgICAgICAgZm9yIChkID0gMDsgZCAhPT0gZzsgKytkKWVbZF0gPSBmW2ggKyBkXSAqIGMgKyBmW2EgKyBkXSAqIGI7XHJcbiAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBDZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoeGEucHJvdG90eXBlKSwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDZCwgaW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKGEgLSAxKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIFhhO1xyXG4gICAgWGEgPSB7XHJcbiAgICAgICAgVGltZUJ1ZmZlclR5cGU6IEZsb2F0MzJBcnJheSxcclxuICAgICAgICBWYWx1ZUJ1ZmZlclR5cGU6IEZsb2F0MzJBcnJheSxcclxuICAgICAgICBEZWZhdWx0SW50ZXJwb2xhdGlvbjogMjMwMSxcclxuICAgICAgICBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDZCh0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBaYyh0aGlzLnRpbWVzLFxyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIGEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmQodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIGEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYjtcclxuICAgICAgICAgICAgc3dpdGNoIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIzMDA6XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIzMDE6XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMzAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGIpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBcInVuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yIFwiICsgdGhpcy5WYWx1ZVR5cGVOYW1lICsgXCIga2V5ZnJhbWUgdHJhY2sgbmFtZWQgXCIgKyB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSB0aGlzLmNyZWF0ZUludGVycG9sYW50KWlmIChhICE9PSB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uKSB0aGlzLnNldEludGVycG9sYXRpb24odGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IEVycm9yKGIpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGIpXHJcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNyZWF0ZUludGVycG9sYW50ID0gYlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjMwMDtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIzMDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyMzAyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhbHVlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGhcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNoaWZ0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpZiAoMCAhPT0gYSlmb3IgKHZhciBiID0gdGhpcy50aW1lcywgYyA9IDAsIGQgPSBiLmxlbmd0aDsgYyAhPT0gZDsgKytjKWJbY10gKz0gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpZiAoMSAhPT0gYSlmb3IgKHZhciBiID0gdGhpcy50aW1lcywgYyA9XHJcbiAgICAgICAgICAgICAgICAwLCBkID0gYi5sZW5ndGg7IGMgIT09IGQ7ICsrYyliW2NdICo9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmltOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gdGhpcy50aW1lcywgZCA9IGMubGVuZ3RoLCBlID0gMCwgZiA9IGQgLSAxOyBlICE9PSBkICYmIGNbZV0gPCBhOykrK2U7XHJcbiAgICAgICAgICAgIGZvciAoOyAtMSAhPT0gZiAmJiBjW2ZdID4gYjspLS1mO1xyXG4gICAgICAgICAgICArK2Y7XHJcbiAgICAgICAgICAgIGlmICgwICE9PSBlIHx8IGYgIT09IGQpIGUgPj0gZiAmJiAoZiA9IE1hdGgubWF4KGYsIDEpLCBlID0gZiAtIDEpLCBkID0gdGhpcy5nZXRWYWx1ZVNpemUoKSwgdGhpcy50aW1lcyA9IG5hLmFycmF5U2xpY2UoYywgZSwgZiksIHRoaXMudmFsdWVzID0gbmEuYXJyYXlTbGljZSh0aGlzLnZhbHVlcywgZSAqIGQsIGYgKiBkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gITAsIGIgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xyXG4gICAgICAgICAgICAwICE9PSBiIC0gTWF0aC5mbG9vcihiKSAmJiAoY29uc29sZS5lcnJvcihcImludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFja1wiLCB0aGlzKSwgYSA9ICExKTtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnRpbWVzLCBiID0gdGhpcy52YWx1ZXMsIGQgPSBjLmxlbmd0aDtcclxuICAgICAgICAgICAgMCA9PT0gZCAmJiAoY29uc29sZS5lcnJvcihcInRyYWNrIGlzIGVtcHR5XCIsXHJcbiAgICAgICAgICAgICAgICB0aGlzKSwgYSA9ICExKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IG51bGwsIGYgPSAwOyBmICE9PSBkOyBmKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gY1tmXTtcclxuICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgZyAmJiBpc05hTihnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ0aW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiLCB0aGlzLCBmLCBnKTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBlICYmIGUgPiBnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIm91dCBvZiBvcmRlciBrZXlzXCIsIHRoaXMsIGYsIGcsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZSA9IGdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBiICYmIG5hLmlzVHlwZWRBcnJheShiKSlmb3IgKGYgPSAwLCBjID0gYi5sZW5ndGg7IGYgIT09IGM7ICsrZilpZiAoZCA9IGJbZl0sIGlzTmFOKGQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwidmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGYsIGQpO1xyXG4gICAgICAgICAgICAgICAgYSA9ICExO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW1pemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IHRoaXMudGltZXMsIGIgPSB0aGlzLnZhbHVlcywgYyA9IHRoaXMuZ2V0VmFsdWVTaXplKCksIGQgPSAyMzAyID09PSB0aGlzLmdldEludGVycG9sYXRpb24oKSxcclxuICAgICAgICAgICAgICAgICAgICAgZSA9IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgIGYgPSBhLmxlbmd0aCAtIDEsIGcgPSAxOyBnIDwgZjsgKytnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9ICExLCBtID0gYVtnXTtcclxuICAgICAgICAgICAgICAgIGlmIChtICE9PSBhW2cgKyAxXSAmJiAoMSAhPT0gZyB8fCBtICE9PSBtWzBdKSlpZiAoZCkgaCA9ICEwOyBlbHNlIGZvciAodmFyIGsgPSBnICogYywgbCA9IGsgLSBjLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGsgKyBjLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IDA7IG0gIT09IGM7ICsrbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gYltrICsgbV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IGJbbCArIG1dIHx8IG4gIT09IGJbcCArIG1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAhMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnICE9PSBlKWZvciAoYVtlXSA9IGFbZ10sIGggPSBnICogYywgayA9IGUgKiBjLCBtID0gMDsgbSAhPT0gYzsgKyttKWJbayArIG1dID0gYltoICsgbV07XHJcbiAgICAgICAgICAgICAgICAgICAgKytlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKDAgPCBmKSB7XHJcbiAgICAgICAgICAgICAgICBhW2VdID0gYVtmXTtcclxuICAgICAgICAgICAgICAgIGggPSBmICogYztcclxuICAgICAgICAgICAgICAgIGsgPSBlICogYztcclxuICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gIT09IGM7ICsrbSliW2sgKyBtXSA9IGJbaCArIG1dO1xyXG4gICAgICAgICAgICAgICAgKytlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZSAhPT0gYS5sZW5ndGggJiYgKHRoaXMudGltZXMgPSBuYS5hcnJheVNsaWNlKGEsIDAsIGUpLCB0aGlzLnZhbHVlcyA9IG5hLmFycmF5U2xpY2UoYiwgMCwgZSAqIGMpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZGMucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKFhhKSwge2NvbnN0cnVjdG9yOiBkYywgVmFsdWVUeXBlTmFtZTogXCJ2ZWN0b3JcIn0pO1xyXG4gICAgRGQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHhhLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogRGQsIGludGVycG9sYXRlXzogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnJlc3VsdEJ1ZmZlciwgZiA9IHRoaXMuc2FtcGxlVmFsdWVzLCBnID0gdGhpcy52YWx1ZVNpemU7XHJcbiAgICAgICAgICAgIGEgKj0gZztcclxuICAgICAgICAgICAgYiA9IChjIC0gYikgLyAoZCAtIGIpO1xyXG4gICAgICAgICAgICBmb3IgKGMgPSBhICsgZzsgYSAhPT0gYzsgYSArPSA0KWNhLnNsZXJwRmxhdChlLCAwLCBmLCBhIC0gZywgZiwgYSwgYik7XHJcbiAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAkYy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoWGEpLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6ICRjLFxyXG4gICAgICAgIFZhbHVlVHlwZU5hbWU6IFwicXVhdGVybmlvblwiLFxyXG4gICAgICAgIERlZmF1bHRJbnRlcnBvbGF0aW9uOiAyMzAxLFxyXG4gICAgICAgIEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZCh0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdm9pZCAwXHJcbiAgICB9KTtcclxuICAgIGVjLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShYYSksIHtjb25zdHJ1Y3RvcjogZWMsIFZhbHVlVHlwZU5hbWU6IFwibnVtYmVyXCJ9KTtcclxuICAgIEVkLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShYYSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogRWQsXHJcbiAgICAgICAgVmFsdWVUeXBlTmFtZTogXCJzdHJpbmdcIixcclxuICAgICAgICBWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxyXG4gICAgICAgIERlZmF1bHRJbnRlcnBvbGF0aW9uOiAyMzAwLFxyXG4gICAgICAgIEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdm9pZCAwLFxyXG4gICAgICAgIEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdm9pZCAwXHJcbiAgICB9KTtcclxuICAgIEZkLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShYYSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogRmQsXHJcbiAgICAgICAgVmFsdWVUeXBlTmFtZTogXCJib29sXCIsXHJcbiAgICAgICAgVmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcclxuICAgICAgICBEZWZhdWx0SW50ZXJwb2xhdGlvbjogMjMwMCxcclxuICAgICAgICBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IHZvaWQgMCxcclxuICAgICAgICBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHZvaWQgMFxyXG4gICAgfSk7XHJcbiAgICBHZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoWGEpLCB7Y29uc3RydWN0b3I6IEdkLCBWYWx1ZVR5cGVOYW1lOiBcImNvbG9yXCJ9KTtcclxuICAgIHliLnByb3RvdHlwZSA9IFhhO1xyXG4gICAgWGEuY29uc3RydWN0b3IgPSB5YjtcclxuICAgIE9iamVjdC5hc3NpZ24oeWIsIHtcclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYS50eXBlKXRocm93IEVycm9yKFwidHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2VcIik7XHJcbiAgICAgICAgICAgIHZhciBiID0geWIuX2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoYS50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYS50aW1lcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBbXSwgZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbmEuZmxhdHRlbkpTT04oYS5rZXlzLCBjLCBkLCBcInZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgYS50aW1lcyA9IGM7XHJcbiAgICAgICAgICAgICAgICBhLnZhbHVlcyA9IGRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBiLnBhcnNlID8gYi5wYXJzZShhKSA6IG5ldyBiKGEubmFtZSwgYS50aW1lcywgYS52YWx1ZXMsIGEuaW50ZXJwb2xhdGlvbilcclxuICAgICAgICB9LCB0b0pTT046IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYS5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYi50b0pTT04pIGIgPVxyXG4gICAgICAgICAgICAgICAgYi50b0pTT04oYSk7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzOiBuYS5jb252ZXJ0QXJyYXkoYS50aW1lcywgQXJyYXkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogbmEuY29udmVydEFycmF5KGEudmFsdWVzLCBBcnJheSlcclxuICAgICAgICAgICAgICAgIH0sIGMgPSBhLmdldEludGVycG9sYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGMgIT09IGEuRGVmYXVsdEludGVycG9sYXRpb24gJiYgKGIuaW50ZXJwb2xhdGlvbiA9IGMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYi50eXBlID0gYS5WYWx1ZVR5cGVOYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gYlxyXG4gICAgICAgIH0sIF9nZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGEudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlYztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWN0b3JcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWN0b3IyXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVjdG9yM1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInZlY3RvcjRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGM7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29sb3JcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2Q7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicXVhdGVybmlvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkYztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGZDtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGVOYW1lOiBcIiArIGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcWEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBxYSwgcmVzZXREdXJhdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMCwgYiA9IDAsIGMgPSB0aGlzLnRyYWNrcy5sZW5ndGg7IGIgIT09IGM7ICsrYil2YXIgZCA9IHRoaXMudHJhY2tzW2JdLFxyXG4gICAgICAgICAgICAgICAgYSA9IE1hdGgubWF4KGEsIGQudGltZXNbZC50aW1lcy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBhXHJcbiAgICAgICAgfSwgdHJpbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgYSsrKXRoaXMudHJhY2tzW2FdLnRyaW0oMCwgdGhpcy5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgb3B0aW1pemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGErKyl0aGlzLnRyYWNrc1thXS5vcHRpbWl6ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHFhLCB7XHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSBbXSwgYyA9IGEudHJhY2tzLFxyXG4gICAgICAgICAgICAgICAgICAgICBkID0gMSAvIChhLmZwcyB8fCAxKSwgZSA9IDAsIGYgPSBjLmxlbmd0aDsgZSAhPT0gZjsgKytlKWIucHVzaCh5Yi5wYXJzZShjW2VdKS5zY2FsZShkKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcWEoYS5uYW1lLCBhLmR1cmF0aW9uLCBiKVxyXG4gICAgICAgIH0sIHRvSlNPTjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBbXSwgYyA9IGEudHJhY2tzO1xyXG4gICAgICAgICAgICBhID0ge25hbWU6IGEubmFtZSwgZHVyYXRpb246IGEuZHVyYXRpb24sIHRyYWNrczogYn07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwLCBlID0gYy5sZW5ndGg7IGQgIT09IGU7ICsrZCliLnB1c2goeWIudG9KU09OKGNbZF0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCBDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZTogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGIubGVuZ3RoLCBmID0gW10sIGcgPSAwOyBnIDwgZTsgZysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IFtdLCBtID0gW107XHJcbiAgICAgICAgICAgICAgICBoLnB1c2goKGcgKyBlIC0gMSkgJSBlLCBnLCAoZyArIDEpICUgZSk7XHJcbiAgICAgICAgICAgICAgICBtLnB1c2goMCwgMSwgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IG5hLmdldEtleWZyYW1lT3JkZXIoaCksIGggPSBuYS5zb3J0ZWRBcnJheShoLCAxLCBrKSwgbSA9IG5hLnNvcnRlZEFycmF5KG0sIDEsIGspO1xyXG4gICAgICAgICAgICAgICAgZCB8fCAwICE9PSBoWzBdIHx8IChoLnB1c2goZSksXHJcbiAgICAgICAgICAgICAgICAgICAgbS5wdXNoKG1bMF0pKTtcclxuICAgICAgICAgICAgICAgIGYucHVzaCgobmV3IGVjKFwiLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tcIiArIGJbZ10ubmFtZSArIFwiXVwiLCBoLCBtKSkuc2NhbGUoMSAvIGMpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcWEoYSwgLTEsIGYpXHJcbiAgICAgICAgfSwgZmluZEJ5TmFtZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBhO1xyXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGEpIHx8IChjID0gYS5nZW9tZXRyeSAmJiBhLmdlb21ldHJ5LmFuaW1hdGlvbnMgfHwgYS5hbmltYXRpb25zKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBjLmxlbmd0aDsgZCsrKWlmIChjW2RdLm5hbWUgPT09IGIpcmV0dXJuIGNbZF07XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfSwgQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXM6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSB7fSwgZSA9IC9eKFtcXHctXSo/KShbXFxkXSspJC8sIGYgPSAwLCBnID0gYS5sZW5ndGg7IGYgPCBnOyBmKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBoID0gYVtmXSwgbSA9IGgubmFtZS5tYXRjaChlKTtcclxuICAgICAgICAgICAgICAgIGlmIChtICYmIDEgPCBtLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gbVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAobSA9IGRba10pIHx8IChkW2tdID0gbSA9IFtdKTtcclxuICAgICAgICAgICAgICAgICAgICBtLnB1c2goaClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhID0gW107XHJcbiAgICAgICAgICAgIGZvciAoayBpbiBkKWEucHVzaChxYS5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZShrLFxyXG4gICAgICAgICAgICAgICAgZFtrXSwgYiwgYykpO1xyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH0sIHBhcnNlQW5pbWF0aW9uOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAoIWEpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCIgIG5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGFcIiksIG51bGw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgwICE9PSBjLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IFtdLCBnID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hLmZsYXR0ZW5KU09OKGMsIGYsIGcsIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAwICE9PSBmLmxlbmd0aCAmJiBlLnB1c2gobmV3IGEoYiwgZiwgZykpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZCA9IFtdLCBlID0gYS5uYW1lIHx8IFwiZGVmYXVsdFwiLCBmID0gYS5sZW5ndGggfHwgLTEsIGcgPSBhLmZwcyB8fCAzMCwgaCA9IGEuaGllcmFyY2h5IHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICBtID0gMDsgbSA8IGgubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gaFttXS5rZXlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgJiYgMCAhPT0gay5sZW5ndGgpaWYgKGtbMF0ubW9ycGhUYXJnZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSAwOyBsIDwgay5sZW5ndGg7IGwrKylpZiAoa1tsXS5tb3JwaFRhcmdldHMpZm9yICh2YXIgcCA9IDA7IHAgPCBrW2xdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IHArKylmW2tbbF0ubW9ycGhUYXJnZXRzW3BdXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4gZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBxID0gW10sIEcgPSBbXSwgcCA9IDA7IHAgIT09IGtbbF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgKytwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGtbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLnB1c2goci50aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcucHVzaChyLm1vcnBoVGFyZ2V0ID09PSBuID8gMSA6IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZC5wdXNoKG5ldyBlYyhcIi5tb3JwaFRhcmdldEluZmx1ZW5jZVtcIiArIG4gKyBcIl1cIiwgcSwgRykpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmxlbmd0aCAqIChnIHx8IDEpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgbCA9IFwiLmJvbmVzW1wiICsgYlttXS5uYW1lICsgXCJdXCIsIGMoZGMsIGwgKyBcIi5wb3NpdGlvblwiLCBrLCBcInBvc1wiLCBkKSwgYygkYywgbCArIFwiLnF1YXRlcm5pb25cIiwgaywgXCJyb3RcIiwgZCksIGMoZGMsIGwgKyBcIi5zY2FsZVwiLCBrLCBcInNjbFwiLCBkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwID09PSBkLmxlbmd0aCA/IG51bGwgOiBuZXcgcWEoZSwgZiwgZClcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5hc3NpZ24oSGQucHJvdG90eXBlLCB7XHJcbiAgICAgICAgbG9hZDogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAobmV3IHNhKGUubWFuYWdlcikpLmxvYWQoYSwgZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGIoZS5wYXJzZShKU09OLnBhcnNlKGEpKSlcclxuICAgICAgICAgICAgfSwgYywgZClcclxuICAgICAgICB9LCBzZXRUZXh0dXJlczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlcyA9XHJcbiAgICAgICAgICAgICAgICBhXHJcbiAgICAgICAgfSwgcGFyc2U6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGIoYSkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBjW2FdICYmIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZVwiLCBhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjW2FdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy50ZXh0dXJlcywgZCA9IG5ldyBYZlthLnR5cGVdO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEudXVpZCAmJiAoZC51dWlkID0gYS51dWlkKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLm5hbWUgJiYgKGQubmFtZSA9IGEubmFtZSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5jb2xvciAmJiBkLmNvbG9yLnNldEhleChhLmNvbG9yKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnJvdWdobmVzcyAmJiAoZC5yb3VnaG5lc3MgPSBhLnJvdWdobmVzcyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5tZXRhbG5lc3MgJiYgKGQubWV0YWxuZXNzID0gYS5tZXRhbG5lc3MpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuZW1pc3NpdmUgJiYgZC5lbWlzc2l2ZS5zZXRIZXgoYS5lbWlzc2l2ZSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5zcGVjdWxhciAmJiBkLnNwZWN1bGFyLnNldEhleChhLnNwZWN1bGFyKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnNoaW5pbmVzcyAmJiAoZC5zaGluaW5lc3MgPSBhLnNoaW5pbmVzcyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5jbGVhckNvYXQgJiYgKGQuY2xlYXJDb2F0ID0gYS5jbGVhckNvYXQpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuY2xlYXJDb2F0Um91Z2huZXNzICYmIChkLmNsZWFyQ29hdFJvdWdobmVzcyA9IGEuY2xlYXJDb2F0Um91Z2huZXNzKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnVuaWZvcm1zICYmIChkLnVuaWZvcm1zID0gYS51bmlmb3Jtcyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS52ZXJ0ZXhTaGFkZXIgJiYgKGQudmVydGV4U2hhZGVyID0gYS52ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuZnJhZ21lbnRTaGFkZXIgJiYgKGQuZnJhZ21lbnRTaGFkZXIgPSBhLmZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnZlcnRleENvbG9ycyAmJiAoZC52ZXJ0ZXhDb2xvcnMgPSBhLnZlcnRleENvbG9ycyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5mb2cgJiYgKGQuZm9nID0gYS5mb2cpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuc2hhZGluZyAmJiAoZC5zaGFkaW5nID0gYS5zaGFkaW5nKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmJsZW5kaW5nICYmIChkLmJsZW5kaW5nID0gYS5ibGVuZGluZyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5zaWRlICYmIChkLnNpZGUgPSBhLnNpZGUpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09XHJcbiAgICAgICAgICAgIGEub3BhY2l0eSAmJiAoZC5vcGFjaXR5ID0gYS5vcGFjaXR5KTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnRyYW5zcGFyZW50ICYmIChkLnRyYW5zcGFyZW50ID0gYS50cmFuc3BhcmVudCk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5hbHBoYVRlc3QgJiYgKGQuYWxwaGFUZXN0ID0gYS5hbHBoYVRlc3QpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuZGVwdGhUZXN0ICYmIChkLmRlcHRoVGVzdCA9IGEuZGVwdGhUZXN0KTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmRlcHRoV3JpdGUgJiYgKGQuZGVwdGhXcml0ZSA9IGEuZGVwdGhXcml0ZSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5jb2xvcldyaXRlICYmIChkLmNvbG9yV3JpdGUgPSBhLmNvbG9yV3JpdGUpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEud2lyZWZyYW1lICYmIChkLndpcmVmcmFtZSA9IGEud2lyZWZyYW1lKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLndpcmVmcmFtZUxpbmV3aWR0aCAmJiAoZC53aXJlZnJhbWVMaW5ld2lkdGggPSBhLndpcmVmcmFtZUxpbmV3aWR0aCk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS53aXJlZnJhbWVMaW5lY2FwICYmIChkLndpcmVmcmFtZUxpbmVjYXAgPSBhLndpcmVmcmFtZUxpbmVjYXApO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEud2lyZWZyYW1lTGluZWpvaW4gJiZcclxuICAgICAgICAgICAgKGQud2lyZWZyYW1lTGluZWpvaW4gPSBhLndpcmVmcmFtZUxpbmVqb2luKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnNraW5uaW5nICYmIChkLnNraW5uaW5nID0gYS5za2lubmluZyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5tb3JwaFRhcmdldHMgJiYgKGQubW9ycGhUYXJnZXRzID0gYS5tb3JwaFRhcmdldHMpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuc2l6ZSAmJiAoZC5zaXplID0gYS5zaXplKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnNpemVBdHRlbnVhdGlvbiAmJiAoZC5zaXplQXR0ZW51YXRpb24gPSBhLnNpemVBdHRlbnVhdGlvbik7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5tYXAgJiYgKGQubWFwID0gYihhLm1hcCkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuYWxwaGFNYXAgJiYgKGQuYWxwaGFNYXAgPSBiKGEuYWxwaGFNYXApLCBkLnRyYW5zcGFyZW50ID0gITApO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuYnVtcE1hcCAmJiAoZC5idW1wTWFwID0gYihhLmJ1bXBNYXApKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmJ1bXBTY2FsZSAmJiAoZC5idW1wU2NhbGUgPSBhLmJ1bXBTY2FsZSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5ub3JtYWxNYXAgJiYgKGQubm9ybWFsTWFwID0gYihhLm5vcm1hbE1hcCkpO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBhLm5vcm1hbFNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgYS5ub3JtYWxTY2FsZTtcclxuICAgICAgICAgICAgICAgICExID09PSBBcnJheS5pc0FycmF5KGUpICYmIChlID0gW2UsIGVdKTtcclxuICAgICAgICAgICAgICAgIGQubm9ybWFsU2NhbGUgPSAobmV3IEQpLmZyb21BcnJheShlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5kaXNwbGFjZW1lbnRNYXAgJiYgKGQuZGlzcGxhY2VtZW50TWFwID0gYihhLmRpc3BsYWNlbWVudE1hcCkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuZGlzcGxhY2VtZW50U2NhbGUgJiYgKGQuZGlzcGxhY2VtZW50U2NhbGUgPSBhLmRpc3BsYWNlbWVudFNjYWxlKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmRpc3BsYWNlbWVudEJpYXMgJiYgKGQuZGlzcGxhY2VtZW50QmlhcyA9IGEuZGlzcGxhY2VtZW50Qmlhcyk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5yb3VnaG5lc3NNYXAgJiYgKGQucm91Z2huZXNzTWFwID0gYihhLnJvdWdobmVzc01hcCkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEubWV0YWxuZXNzTWFwICYmIChkLm1ldGFsbmVzc01hcCA9IGIoYS5tZXRhbG5lc3NNYXApKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmVtaXNzaXZlTWFwICYmIChkLmVtaXNzaXZlTWFwID0gYihhLmVtaXNzaXZlTWFwKSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5lbWlzc2l2ZUludGVuc2l0eSAmJiAoZC5lbWlzc2l2ZUludGVuc2l0eSA9XHJcbiAgICAgICAgICAgICAgICBhLmVtaXNzaXZlSW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLnNwZWN1bGFyTWFwICYmIChkLnNwZWN1bGFyTWFwID0gYihhLnNwZWN1bGFyTWFwKSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5lbnZNYXAgJiYgKGQuZW52TWFwID0gYihhLmVudk1hcCkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEucmVmbGVjdGl2aXR5ICYmIChkLnJlZmxlY3Rpdml0eSA9IGEucmVmbGVjdGl2aXR5KTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmxpZ2h0TWFwICYmIChkLmxpZ2h0TWFwID0gYihhLmxpZ2h0TWFwKSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5saWdodE1hcEludGVuc2l0eSAmJiAoZC5saWdodE1hcEludGVuc2l0eSA9IGEubGlnaHRNYXBJbnRlbnNpdHkpO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEuYW9NYXAgJiYgKGQuYW9NYXAgPSBiKGEuYW9NYXApKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmFvTWFwSW50ZW5zaXR5ICYmIChkLmFvTWFwSW50ZW5zaXR5ID0gYS5hb01hcEludGVuc2l0eSk7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYS5ncmFkaWVudE1hcCAmJiAoZC5ncmFkaWVudE1hcCA9IGIoYS5ncmFkaWVudE1hcCkpO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBhLm1hdGVyaWFscylmb3IgKHZhciBlID0gMCwgZiA9IGEubWF0ZXJpYWxzLmxlbmd0aDsgZSA8XHJcbiAgICAgICAgICAgIGY7IGUrKylkLm1hdGVyaWFscy5wdXNoKHRoaXMucGFyc2UoYS5tYXRlcmlhbHNbZV0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5hc3NpZ24oY2UucHJvdG90eXBlLCB7XHJcbiAgICAgICAgbG9hZDogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAobmV3IHNhKGUubWFuYWdlcikpLmxvYWQoYSwgZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGIoZS5wYXJzZShKU09OLnBhcnNlKGEpKSlcclxuICAgICAgICAgICAgfSwgYywgZClcclxuICAgICAgICB9LCBwYXJzZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBuZXcgSSwgYyA9IGEuZGF0YS5pbmRleCwgZCA9IHtcclxuICAgICAgICAgICAgICAgIEludDhBcnJheTogSW50OEFycmF5LFxyXG4gICAgICAgICAgICAgICAgVWludDhBcnJheTogVWludDhBcnJheSxcclxuICAgICAgICAgICAgICAgIFVpbnQ4Q2xhbXBlZEFycmF5OiBVaW50OENsYW1wZWRBcnJheSxcclxuICAgICAgICAgICAgICAgIEludDE2QXJyYXk6IEludDE2QXJyYXksXHJcbiAgICAgICAgICAgICAgICBVaW50MTZBcnJheTogVWludDE2QXJyYXksXHJcbiAgICAgICAgICAgICAgICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxyXG4gICAgICAgICAgICAgICAgVWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxyXG4gICAgICAgICAgICAgICAgRmxvYXQzMkFycmF5OiBGbG9hdDMyQXJyYXksXHJcbiAgICAgICAgICAgICAgICBGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGMgJiYgKGMgPSBuZXcgZFtjLnR5cGVdKGMuYXJyYXkpLFxyXG4gICAgICAgICAgICAgICAgYi5zZXRJbmRleChuZXcgVShjLCAxKSkpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IGEuZGF0YS5hdHRyaWJ1dGVzLCBmO1xyXG4gICAgICAgICAgICBmb3IgKGYgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBlW2ZdLCBjID0gbmV3IGRbZy50eXBlXShnLmFycmF5KTtcclxuICAgICAgICAgICAgICAgIGIuYWRkQXR0cmlidXRlKGYsIG5ldyBVKGMsIGcuaXRlbVNpemUsIGcubm9ybWFsaXplZCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZCA9IGEuZGF0YS5ncm91cHMgfHwgYS5kYXRhLmRyYXdjYWxscyB8fCBhLmRhdGEub2Zmc2V0cztcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZClmb3IgKGYgPSAwLCBjID0gZC5sZW5ndGg7IGYgIT09IGM7ICsrZillID0gZFtmXSwgYi5hZGRHcm91cChlLnN0YXJ0LCBlLmNvdW50LCBlLm1hdGVyaWFsSW5kZXgpO1xyXG4gICAgICAgICAgICBhID0gYS5kYXRhLmJvdW5kaW5nU3BoZXJlO1xyXG4gICAgICAgICAgICB2b2lkIDAgIT09IGEgJiYgKGQgPSBuZXcgcSwgdm9pZCAwICE9PSBhLmNlbnRlciAmJiBkLmZyb21BcnJheShhLmNlbnRlciksIGIuYm91bmRpbmdTcGhlcmUgPSBuZXcgTmEoZCwgYS5yYWRpdXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHpiLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogemIsIGNyb3NzT3JpZ2luOiB2b2lkIDAsIGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID1cclxuICAgICAgICAgICAgICAgIGEuc3BsaXQoXCIvXCIpO1xyXG4gICAgICAgICAgICBpZiAoMSA9PT0gYS5sZW5ndGgpcmV0dXJuIFwiLi9cIjtcclxuICAgICAgICAgICAgYS5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGEuam9pbihcIi9cIikgKyBcIi9cIlxyXG4gICAgICAgIH0sIGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSBbXSwgZSA9IDA7IGUgPCBhLmxlbmd0aDsgKytlKWRbZV0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKGFbZV0sIGIsIGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZFxyXG4gICAgICAgIH0sIGNyZWF0ZU1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0ge1xyXG4gICAgICAgICAgICAgICAgTm9CbGVuZGluZzogMCxcclxuICAgICAgICAgICAgICAgIE5vcm1hbEJsZW5kaW5nOiAxLFxyXG4gICAgICAgICAgICAgICAgQWRkaXRpdmVCbGVuZGluZzogMixcclxuICAgICAgICAgICAgICAgIFN1YnRyYWN0aXZlQmxlbmRpbmc6IDMsXHJcbiAgICAgICAgICAgICAgICBNdWx0aXBseUJsZW5kaW5nOiA0LFxyXG4gICAgICAgICAgICAgICAgQ3VzdG9tQmxlbmRpbmc6IDVcclxuICAgICAgICAgICAgfSwgYiwgYywgZDtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlLCBmLCBnKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoKGEsIGIsIGQsIGUsIGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gZiArIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSB6Yi5IYW5kbGVycy5nZXQoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gayA/IGEgPSBrLmxvYWQoYSkgOiAoYy5zZXRDcm9zc09yaWdpbihnKSwgYSA9IGMubG9hZChhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiICYmIChhLnJlcGVhdC5mcm9tQXJyYXkoYiksIDEgIT09IGJbMF0gJiZcclxuICAgICAgICAgICAgICAgICAgICAoYS53cmFwUyA9IDFFMyksIDEgIT09IGJbMV0gJiYgKGEud3JhcFQgPSAxRTMpKTtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGQgJiYgYS5vZmZzZXQuZnJvbUFycmF5KGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gZSAmJiAoXCJyZXBlYXRcIiA9PT0gZVswXSAmJiAoYS53cmFwUyA9IDFFMyksIFwibWlycm9yXCIgPT09IGVbMF0gJiYgKGEud3JhcFMgPSAxMDAyKSwgXCJyZXBlYXRcIiA9PT0gZVsxXSAmJiAoYS53cmFwVCA9IDFFMyksIFwibWlycm9yXCIgPT09IGVbMV0gJiYgKGEud3JhcFQgPSAxMDAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBoICYmIChhLmFuaXNvdHJvcHkgPSBoKTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gTi5nZW5lcmF0ZVVVSUQoKTtcclxuICAgICAgICAgICAgICAgICAgICBtW2JdID0gYTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IG5ldyBKKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYyAmJiAoYyA9IG5ldyB0ZCk7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGQgJiYgKGQgPSBuZXcgSGQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB7fSwgayA9IHt1dWlkOiBOLmdlbmVyYXRlVVVJRCgpLCB0eXBlOiBcIk1lc2hMYW1iZXJ0TWF0ZXJpYWxcIn0sIGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGwgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gZVtsXTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkRiZ0NvbG9yXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEYmdJbmRleFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3B0aWNhbERlbnNpdHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlsbHVtaW5hdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEYmdOYW1lXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLm5hbWUgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJibGVuZGluZ1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5ibGVuZGluZyA9IGFbcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbG9yQW1iaWVudFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwQW1iaWVudFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOlwiLCBsLCBcImlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb2xvckRpZmZ1c2VcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsuY29sb3IgPSBiLmZyb21BcnJheShwKS5nZXRIZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29sb3JTcGVjdWxhclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5zcGVjdWxhciA9IGIuZnJvbUFycmF5KHApLmdldEhleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb2xvckVtaXNzaXZlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLmVtaXNzaXZlID0gYi5mcm9tQXJyYXkocCkuZ2V0SGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNwZWN1bGFyQ29lZlwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5zaGluaW5lc3MgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzaGFkaW5nXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhc2ljXCIgPT09IHAudG9Mb3dlckNhc2UoKSAmJiAoay50eXBlID0gXCJNZXNoQmFzaWNNYXRlcmlhbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGhvbmdcIiA9PT0gcC50b0xvd2VyQ2FzZSgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoay50eXBlID0gXCJNZXNoUGhvbmdNYXRlcmlhbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhbmRhcmRcIiA9PT0gcC50b0xvd2VyQ2FzZSgpICYmIChrLnR5cGUgPSBcIk1lc2hTdGFuZGFyZE1hdGVyaWFsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBEaWZmdXNlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLm1hcCA9IGgocCwgZS5tYXBEaWZmdXNlUmVwZWF0LCBlLm1hcERpZmZ1c2VPZmZzZXQsIGUubWFwRGlmZnVzZVdyYXAsIGUubWFwRGlmZnVzZUFuaXNvdHJvcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBEaWZmdXNlUmVwZWF0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBEaWZmdXNlT2Zmc2V0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBEaWZmdXNlV3JhcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwRGlmZnVzZUFuaXNvdHJvcHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwRW1pc3NpdmVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsuZW1pc3NpdmVNYXAgPSBoKHAsIGUubWFwRW1pc3NpdmVSZXBlYXQsIGUubWFwRW1pc3NpdmVPZmZzZXQsIGUubWFwRW1pc3NpdmVXcmFwLCBlLm1hcEVtaXNzaXZlQW5pc290cm9weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEVtaXNzaXZlUmVwZWF0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBFbWlzc2l2ZU9mZnNldFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwRW1pc3NpdmVXcmFwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBFbWlzc2l2ZUFuaXNvdHJvcHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwTGlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsubGlnaHRNYXAgPSBoKHAsIGUubWFwTGlnaHRSZXBlYXQsIGUubWFwTGlnaHRPZmZzZXQsIGUubWFwTGlnaHRXcmFwLCBlLm1hcExpZ2h0QW5pc290cm9weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcExpZ2h0UmVwZWF0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBMaWdodE9mZnNldFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwTGlnaHRXcmFwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBMaWdodEFuaXNvdHJvcHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwQU9cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsuYW9NYXAgPSBoKHAsIGUubWFwQU9SZXBlYXQsIGUubWFwQU9PZmZzZXQsIGUubWFwQU9XcmFwLCBlLm1hcEFPQW5pc290cm9weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEFPUmVwZWF0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBBT09mZnNldFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwQU9XcmFwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBBT0FuaXNvdHJvcHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwQnVtcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5idW1wTWFwID0gaChwLCBlLm1hcEJ1bXBSZXBlYXQsIGUubWFwQnVtcE9mZnNldCwgZS5tYXBCdW1wV3JhcCwgZS5tYXBCdW1wQW5pc290cm9weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEJ1bXBTY2FsZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5idW1wU2NhbGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEJ1bXBSZXBlYXRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEJ1bXBPZmZzZXRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEJ1bXBXcmFwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBCdW1wQW5pc290cm9weVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBOb3JtYWxcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsubm9ybWFsTWFwID0gaChwLCBlLm1hcE5vcm1hbFJlcGVhdCwgZS5tYXBOb3JtYWxPZmZzZXQsIGUubWFwTm9ybWFsV3JhcCwgZS5tYXBOb3JtYWxBbmlzb3Ryb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwTm9ybWFsRmFjdG9yXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLm5vcm1hbFNjYWxlID0gW3AsIHBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBOb3JtYWxSZXBlYXRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcE5vcm1hbE9mZnNldFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwTm9ybWFsV3JhcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwTm9ybWFsQW5pc290cm9weVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBTcGVjdWxhclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5zcGVjdWxhck1hcCA9IGgocCwgZS5tYXBTcGVjdWxhclJlcGVhdCwgZS5tYXBTcGVjdWxhck9mZnNldCwgZS5tYXBTcGVjdWxhcldyYXAsIGUubWFwU3BlY3VsYXJBbmlzb3Ryb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwU3BlY3VsYXJSZXBlYXRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFNwZWN1bGFyT2Zmc2V0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBTcGVjdWxhcldyYXBcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFNwZWN1bGFyQW5pc290cm9weVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBNZXRhbG5lc3NcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsubWV0YWxuZXNzTWFwID0gaChwLCBlLm1hcE1ldGFsbmVzc1JlcGVhdCwgZS5tYXBNZXRhbG5lc3NPZmZzZXQsIGUubWFwTWV0YWxuZXNzV3JhcCwgZS5tYXBNZXRhbG5lc3NBbmlzb3Ryb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwTWV0YWxuZXNzUmVwZWF0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBNZXRhbG5lc3NPZmZzZXRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcE1ldGFsbmVzc1dyYXBcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcE1ldGFsbmVzc0FuaXNvdHJvcHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwUm91Z2huZXNzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLnJvdWdobmVzc01hcCA9IGgocCwgZS5tYXBSb3VnaG5lc3NSZXBlYXQsIGUubWFwUm91Z2huZXNzT2Zmc2V0LCBlLm1hcFJvdWdobmVzc1dyYXAsIGUubWFwUm91Z2huZXNzQW5pc290cm9weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFJvdWdobmVzc1JlcGVhdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwUm91Z2huZXNzT2Zmc2V0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBSb3VnaG5lc3NXcmFwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBSb3VnaG5lc3NBbmlzb3Ryb3B5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEFscGhhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLmFscGhhTWFwID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKHAsIGUubWFwQWxwaGFSZXBlYXQsIGUubWFwQWxwaGFPZmZzZXQsIGUubWFwQWxwaGFXcmFwLCBlLm1hcEFscGhhQW5pc290cm9weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcEFscGhhUmVwZWF0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBBbHBoYU9mZnNldFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwQWxwaGFXcmFwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBBbHBoYUFuaXNvdHJvcHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmxpcFNpZGVkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLnNpZGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb3VibGVTaWRlZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5zaWRlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNwYXJlbmN5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLm9wYWNpdHkgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZXB0aFRlc3RcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRlcHRoV3JpdGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbG9yV3JpdGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wYWNpdHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlZmxlY3Rpdml0eVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNwYXJlbnRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZpc2libGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndpcmVmcmFtZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga1tsXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmVydGV4Q29sb3JzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMCA9PT0gcCAmJiAoay52ZXJ0ZXhDb2xvcnMgPSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmFjZVwiID09PSBwICYmIChrLnZlcnRleENvbG9ycyA9IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBVbnN1cHBvcnRlZFwiLCBsLCBwKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFwiTWVzaEJhc2ljTWF0ZXJpYWxcIiA9PT0gay50eXBlICYmIGRlbGV0ZSBrLmVtaXNzaXZlO1xyXG4gICAgICAgICAgICAgICAgXCJNZXNoUGhvbmdNYXRlcmlhbFwiICE9PSBrLnR5cGUgJiYgZGVsZXRlIGsuc3BlY3VsYXI7XHJcbiAgICAgICAgICAgICAgICAxID4gay5vcGFjaXR5ICYmIChrLnRyYW5zcGFyZW50ID0gITApO1xyXG4gICAgICAgICAgICAgICAgZC5zZXRUZXh0dXJlcyhtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnBhcnNlKGspXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KClcclxuICAgIH07XHJcbiAgICB6Yi5IYW5kbGVycyA9IHtcclxuICAgICAgICBoYW5kbGVyczogW10sIGFkZDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGEsIGIpXHJcbiAgICAgICAgfSwgZ2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5oYW5kbGVycywgYyA9IDAsIGQgPSBiLmxlbmd0aDsgYyA8IGQ7IGMgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBiW2MgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChiW2NdLnRlc3QoYSkpcmV0dXJuIGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKGRlLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLnRleHR1cmVQYXRoICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGlzLnRleHR1cmVQYXRoID8gdGhpcy50ZXh0dXJlUGF0aCA6IHpiLnByb3RvdHlwZS5leHRyYWN0VXJsQmFzZShhKSxcclxuICAgICAgICAgICAgICAgIGcgPSBuZXcgc2EodGhpcy5tYW5hZ2VyKTtcclxuICAgICAgICAgICAgZy5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xyXG4gICAgICAgICAgICBnLmxvYWQoYSwgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIGMgPSBKU09OLnBhcnNlKGMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBjLm1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZCAmJiAoZCA9IGQudHlwZSwgdm9pZCAwICE9PSBkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSBkLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkpTT05Mb2FkZXI6IFwiICsgYSArIFwiIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5PYmplY3RMb2FkZXIgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzY2VuZVwiID09PSBkLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkpTT05Mb2FkZXI6IFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgKyBcIiBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGMgPSBlLnBhcnNlKGMsIGYpO1xyXG4gICAgICAgICAgICAgICAgYihjLmdlb21ldHJ5LCBjLm1hdGVyaWFscylcclxuICAgICAgICAgICAgfSwgYywgZClcclxuICAgICAgICB9LCBzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlUGF0aCA9IGFcclxuICAgICAgICB9LCBwYXJzZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBuZXcgVCwgZCA9IHZvaWQgMCAhPT0gYS5zY2FsZSA/IDEgLyBhLnNjYWxlIDogMTtcclxuICAgICAgICAgICAgKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCwgZywgaCwgbSwgaywgbCwgcCwgbiwgdSwgRywgciwgQSwgdywgeSA9IGEuZmFjZXM7XHJcbiAgICAgICAgICAgICAgICBsID0gYS52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gYS5ub3JtYWxzLCB2ID0gYS5jb2xvcnMsIHogPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYS51dnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgYS51dnMubGVuZ3RoOyBkKyspYS51dnNbZF0ubGVuZ3RoICYmIHorKztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgejsgZCsrKWMuZmFjZVZlcnRleFV2c1tkXSA9IFtdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IGwubGVuZ3RoOyBtIDwgazspZCA9IG5ldyBxLCBkLnggPSBsW20rK10gKiBiLCBkLnkgPSBsW20rK10gKiBiLCBkLnogPSBsW20rK10gKiBiLCBjLnZlcnRpY2VzLnB1c2goZCk7XHJcbiAgICAgICAgICAgICAgICBtID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IHkubGVuZ3RoOyBtIDwgazspaWYgKGIgPSB5W20rK10sIHUgPSBiICYgMSwgaCA9IGIgJiAyLCBkID0gYiAmIDgsIHAgPSBiICYgMTYsIEcgPSBiICYgMzIsIGwgPSBiICYgNjQsIGIgJj0gMTI4LCB1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IG5ldyBoYTtcclxuICAgICAgICAgICAgICAgICAgICB1LmEgPSB5W21dO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuYiA9IHlbbSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuYyA9IHlbbSArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBuZXcgaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgci5hID0geVttICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgci5iID0geVttICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgci5jID0geVttICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgbSArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGggJiYgKGggPSB5W20rK10sIHUubWF0ZXJpYWxJbmRleCA9IGgsIHIubWF0ZXJpYWxJbmRleCA9IGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSBjLmZhY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZClmb3IgKGQgPSAwOyBkIDwgejsgZCsrKWZvciAoQSA9IGEudXZzW2RdLCBjLmZhY2VWZXJ0ZXhVdnNbZF1baF0gPSBbXSwgYy5mYWNlVmVydGV4VXZzW2RdW2ggKyAxXSA9IFtdLCBnID0gMDsgNCA+IGc7IGcrKyluID0geVttKytdLCB3ID0gQVsyICogbl0sIG4gPSBBWzIgKiBuICsgMV0sIHcgPSBuZXcgRCh3LCBuKSwgMiAhPT0gZyAmJiBjLmZhY2VWZXJ0ZXhVdnNbZF1baF0ucHVzaCh3KSwgMCAhPT0gZyAmJiBjLmZhY2VWZXJ0ZXhVdnNbZF1baCArIDFdLnB1c2godyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCAmJiAocCA9IDMgKiB5W20rK10sIHUubm9ybWFsLnNldCh4W3ArK10sIHhbcCsrXSwgeFtwXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubm9ybWFsLmNvcHkodS5ub3JtYWwpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoRylmb3IgKGQgPSAwOyA0ID4gZDsgZCsrKXAgPSAzICogeVttKytdLCBHID0gbmV3IHEoeFtwKytdLCB4W3ArK10sIHhbcF0pLCAyICE9PSBkICYmIHUudmVydGV4Tm9ybWFscy5wdXNoKEcpLCAwICE9PSBkICYmIHIudmVydGV4Tm9ybWFscy5wdXNoKEcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGwgJiYgKGwgPSB5W20rK10sIGwgPSB2W2xdLCB1LmNvbG9yLnNldEhleChsKSwgci5jb2xvci5zZXRIZXgobCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiKWZvciAoZCA9IDA7IDQgPiBkOyBkKyspbCA9IHlbbSsrXSwgbCA9IHZbbF0sIDIgIT09IGQgJiYgdS52ZXJ0ZXhDb2xvcnMucHVzaChuZXcgSihsKSksIDAgIT09IGQgJiYgci52ZXJ0ZXhDb2xvcnMucHVzaChuZXcgSihsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5mYWNlcy5wdXNoKHUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuZmFjZXMucHVzaChyKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gbmV3IGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuYSA9IHlbbSsrXTtcclxuICAgICAgICAgICAgICAgICAgICB1LmIgPSB5W20rK107XHJcbiAgICAgICAgICAgICAgICAgICAgdS5jID0geVttKytdO1xyXG4gICAgICAgICAgICAgICAgICAgIGggJiYgKGggPSB5W20rK10sIHUubWF0ZXJpYWxJbmRleCA9IGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSBjLmZhY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZClmb3IgKGQgPSAwOyBkIDwgejsgZCsrKWZvciAoQSA9IGEudXZzW2RdLCBjLmZhY2VWZXJ0ZXhVdnNbZF1baF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbXSwgZyA9IDA7IDMgPiBnOyBnKyspbiA9IHlbbSsrXSwgdyA9IEFbMiAqIG5dLCBuID0gQVsyICogbiArIDFdLCB3ID0gbmV3IEQodywgbiksIGMuZmFjZVZlcnRleFV2c1tkXVtoXS5wdXNoKHcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgJiYgKHAgPSAzICogeVttKytdLCB1Lm5vcm1hbC5zZXQoeFtwKytdLCB4W3ArK10sIHhbcF0pKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoRylmb3IgKGQgPSAwOyAzID4gZDsgZCsrKXAgPSAzICogeVttKytdLCBHID0gbmV3IHEoeFtwKytdLCB4W3ArK10sIHhbcF0pLCB1LnZlcnRleE5vcm1hbHMucHVzaChHKTtcclxuICAgICAgICAgICAgICAgICAgICBsICYmIChsID0geVttKytdLCB1LmNvbG9yLnNldEhleCh2W2xdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIpZm9yIChkID0gMDsgMyA+IGQ7IGQrKylsID0geVttKytdLCB1LnZlcnRleENvbG9ycy5wdXNoKG5ldyBKKHZbbF0pKTtcclxuICAgICAgICAgICAgICAgICAgICBjLmZhY2VzLnB1c2godSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoZCk7XHJcbiAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHZvaWQgMCAhPT0gYS5pbmZsdWVuY2VzUGVyVmVydGV4ID8gYS5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcclxuICAgICAgICAgICAgICAgIGlmIChhLnNraW5XZWlnaHRzKWZvciAodmFyIGQgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGEuc2tpbldlaWdodHMubGVuZ3RoOyBkIDwgZzsgZCArPSBiKWMuc2tpbldlaWdodHMucHVzaChuZXcgZmEoYS5za2luV2VpZ2h0c1tkXSxcclxuICAgICAgICAgICAgICAgICAgICAxIDwgYiA/IGEuc2tpbldlaWdodHNbZCArIDFdIDogMCwgMiA8IGIgPyBhLnNraW5XZWlnaHRzW2QgKyAyXSA6IDAsIDMgPCBiID8gYS5za2luV2VpZ2h0c1tkICsgM10gOiAwKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5za2luSW5kaWNlcylmb3IgKGQgPSAwLCBnID0gYS5za2luSW5kaWNlcy5sZW5ndGg7IGQgPCBnOyBkICs9IGIpYy5za2luSW5kaWNlcy5wdXNoKG5ldyBmYShhLnNraW5JbmRpY2VzW2RdLCAxIDwgYiA/IGEuc2tpbkluZGljZXNbZCArIDFdIDogMCwgMiA8IGIgPyBhLnNraW5JbmRpY2VzW2QgKyAyXSA6IDAsIDMgPCBiID8gYS5za2luSW5kaWNlc1tkICsgM10gOiAwKSk7XHJcbiAgICAgICAgICAgICAgICBjLmJvbmVzID0gYS5ib25lcztcclxuICAgICAgICAgICAgICAgIGMuYm9uZXMgJiYgMCA8IGMuYm9uZXMubGVuZ3RoICYmIChjLnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gYy5za2luSW5kaWNlcy5sZW5ndGggfHwgYy5za2luSW5kaWNlcy5sZW5ndGggIT09IGMudmVydGljZXMubGVuZ3RoKSAmJiBjb25zb2xlLndhcm4oXCJXaGVuIHNraW5uaW5nLCBudW1iZXIgb2YgdmVydGljZXMgKFwiICsgYy52ZXJ0aWNlcy5sZW5ndGggKyBcIiksIHNraW5JbmRpY2VzIChcIiArIGMuc2tpbkluZGljZXMubGVuZ3RoICsgXCIpLCBhbmQgc2tpbldlaWdodHMgKFwiICtcclxuICAgICAgICAgICAgICAgICAgICBjLnNraW5XZWlnaHRzLmxlbmd0aCArIFwiKSBzaG91bGQgbWF0Y2guXCIpXHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgIChmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYS5tb3JwaFRhcmdldHMpZm9yICh2YXIgZCA9IDAsIGcgPSBhLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGQgPCBnOyBkKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjLm1vcnBoVGFyZ2V0c1tkXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGMubW9ycGhUYXJnZXRzW2RdLm5hbWUgPSBhLm1vcnBoVGFyZ2V0c1tkXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGMubW9ycGhUYXJnZXRzW2RdLnZlcnRpY2VzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaCA9IGMubW9ycGhUYXJnZXRzW2RdLnZlcnRpY2VzLCBtID0gYS5tb3JwaFRhcmdldHNbZF0udmVydGljZXMsIGsgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBtLmxlbmd0aDsgayA8IGw7IGsgKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnggPSBtW2tdICogYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC55ID0gbVtrICsgMV0gKiBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnogPSBtW2sgKyAyXSAqIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgucHVzaChwKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGEubW9ycGhDb2xvcnMgJiYgMCA8IGEubW9ycGhDb2xvcnMubGVuZ3RoKWZvciAoY29uc29sZS53YXJuKCdUSFJFRS5KU09OTG9hZGVyOiBcIm1vcnBoQ29sb3JzXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNpbmcgdGhlbSBhcyBmYWNlIGNvbG9ycy4nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjLmZhY2VzLCBoID0gYS5tb3JwaENvbG9yc1swXS5jb2xvcnMsIGQgPSAwLCBnID0gYi5sZW5ndGg7IGQgPCBnOyBkKyspYltkXS5jb2xvci5mcm9tQXJyYXkoaCwgMyAqIGQpXHJcbiAgICAgICAgICAgIH0pKGQpO1xyXG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBbXSwgZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBhLmFuaW1hdGlvbiAmJiBkLnB1c2goYS5hbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBhLmFuaW1hdGlvbnMgJiYgKGEuYW5pbWF0aW9ucy5sZW5ndGggPyBkID0gZC5jb25jYXQoYS5hbmltYXRpb25zKSA6IGQucHVzaChhLmFuaW1hdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgZC5sZW5ndGg7IGcrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gcWEucGFyc2VBbmltYXRpb24oZFtnXSwgYy5ib25lcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaCAmJiBiLnB1c2goaClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGMubW9ycGhUYXJnZXRzICYmIChkID0gcWEuQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMoYy5tb3JwaFRhcmdldHMsIDEwKSwgYiA9IGIuY29uY2F0KGQpKTtcclxuICAgICAgICAgICAgICAgIDAgPCBiLmxlbmd0aCAmJiAoYy5hbmltYXRpb25zID0gYilcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgICAgYy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICAgICAgYy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYS5tYXRlcmlhbHMgfHwgMCA9PT0gYS5tYXRlcmlhbHMubGVuZ3RoKXJldHVybiB7Z2VvbWV0cnk6IGN9O1xyXG4gICAgICAgICAgICBkID0gemIucHJvdG90eXBlLmluaXRNYXRlcmlhbHMoYS5tYXRlcmlhbHMsIGIsIHRoaXMuY3Jvc3NPcmlnaW4pO1xyXG4gICAgICAgICAgICByZXR1cm4ge2dlb21ldHJ5OiBjLCBtYXRlcmlhbHM6IGR9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKFNlLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIFwiXCIgPT09IHRoaXMudGV4dHVyZVBhdGggJiYgKHRoaXMudGV4dHVyZVBhdGggPSBhLnN1YnN0cmluZygwLCBhLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpKTtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAobmV3IHNhKGUubWFuYWdlcikpLmxvYWQoYSwgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IEpTT04ucGFyc2UoYylcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGQgJiYgZChoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUU6T2JqZWN0TG9hZGVyOiBDYW4ndCBwYXJzZSBcIiArIGEgKyBcIi5cIiwgaC5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGMgPSBnLm1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBjIHx8IHZvaWQgMCA9PT1cclxuICAgICAgICAgICAgICAgIGMudHlwZSB8fCBcImdlb21ldHJ5XCIgPT09IGMudHlwZS50b0xvd2VyQ2FzZSgpID8gY29uc29sZS5lcnJvcihcIlRIUkVFLk9iamVjdExvYWRlcjogQ2FuJ3QgbG9hZCBcIiArIGEgKyBcIi4gVXNlIFRIUkVFLkpTT05Mb2FkZXIgaW5zdGVhZC5cIikgOiBlLnBhcnNlKGcsIGIpXHJcbiAgICAgICAgICAgIH0sIGMsIGQpXHJcbiAgICAgICAgfSwgc2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVBhdGggPSBhXHJcbiAgICAgICAgfSwgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBhXHJcbiAgICAgICAgfSwgcGFyc2U6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoYS5nZW9tZXRyaWVzKSwgZCA9IHRoaXMucGFyc2VJbWFnZXMoYS5pbWFnZXMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIgJiYgYihlKVxyXG4gICAgICAgICAgICAgICAgfSksIGQgPSB0aGlzLnBhcnNlVGV4dHVyZXMoYS50ZXh0dXJlcywgZCksIGQgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKGEubWF0ZXJpYWxzLCBkKSxcclxuICAgICAgICAgICAgICAgIGUgPSB0aGlzLnBhcnNlT2JqZWN0KGEub2JqZWN0LCBjLCBkKTtcclxuICAgICAgICAgICAgYS5hbmltYXRpb25zICYmIChlLmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucyhhLmFuaW1hdGlvbnMpKTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBhLmltYWdlcyAmJiAwICE9PSBhLmltYWdlcy5sZW5ndGggfHwgdm9pZCAwID09PSBiIHx8IGIoZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgfSwgcGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHt9O1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBhKWZvciAodmFyIGMgPSBuZXcgZGUsIGQgPSBuZXcgY2UsIGUgPSAwLCBmID0gYS5sZW5ndGg7IGUgPCBmOyBlKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBnLCBoID0gYVtlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlBsYW5lR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUGxhbmVCdWZmZXJHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gbmV3IE1hW2gudHlwZV0oaC53aWR0aCwgaC5oZWlnaHQsIGgud2lkdGhTZWdtZW50cywgaC5oZWlnaHRTZWdtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCb3hHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCb3hCdWZmZXJHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDdWJlR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBNYVtoLnR5cGVdKGgud2lkdGgsIGguaGVpZ2h0LCBoLmRlcHRoLCBoLndpZHRoU2VnbWVudHMsIGguaGVpZ2h0U2VnbWVudHMsIGguZGVwdGhTZWdtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDaXJjbGVHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDaXJjbGVCdWZmZXJHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBNYVtoLnR5cGVdKGgucmFkaXVzLCBoLnNlZ21lbnRzLCBoLnRoZXRhU3RhcnQsIGgudGhldGFMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQ3lsaW5kZXJHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDeWxpbmRlckJ1ZmZlckdlb21ldHJ5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgTWFbaC50eXBlXShoLnJhZGl1c1RvcCwgaC5yYWRpdXNCb3R0b20sIGguaGVpZ2h0LCBoLnJhZGlhbFNlZ21lbnRzLCBoLmhlaWdodFNlZ21lbnRzLCBoLm9wZW5FbmRlZCwgaC50aGV0YVN0YXJ0LCBoLnRoZXRhTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkNvbmVHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDb25lQnVmZmVyR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBNYVtoLnR5cGVdKGgucmFkaXVzLCBoLmhlaWdodCwgaC5yYWRpYWxTZWdtZW50cywgaC5oZWlnaHRTZWdtZW50cywgaC5vcGVuRW5kZWQsIGgudGhldGFTdGFydCwgaC50aGV0YUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTcGhlcmVHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTcGhlcmVCdWZmZXJHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gbmV3IE1hW2gudHlwZV0oaC5yYWRpdXMsIGgud2lkdGhTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguaGVpZ2h0U2VnbWVudHMsIGgucGhpU3RhcnQsIGgucGhpTGVuZ3RoLCBoLnRoZXRhU3RhcnQsIGgudGhldGFMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRG9kZWNhaGVkcm9uR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSWNvc2FoZWRyb25HZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJPY3RhaGVkcm9uR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVGV0cmFoZWRyb25HZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gbmV3IE1hW2gudHlwZV0oaC5yYWRpdXMsIGguZGV0YWlsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlJpbmdHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSaW5nQnVmZmVyR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBNYVtoLnR5cGVdKGguaW5uZXJSYWRpdXMsIGgub3V0ZXJSYWRpdXMsIGgudGhldGFTZWdtZW50cywgaC5waGlTZWdtZW50cywgaC50aGV0YVN0YXJ0LCBoLnRoZXRhTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRvcnVzR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVG9ydXNCdWZmZXJHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gbmV3IE1hW2gudHlwZV0oaC5yYWRpdXMsIGgudHViZSwgaC5yYWRpYWxTZWdtZW50cywgaC50dWJ1bGFyU2VnbWVudHMsIGguYXJjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRvcnVzS25vdEdlb21ldHJ5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgTWFbaC50eXBlXShoLnJhZGl1cywgaC50dWJlLCBoLnR1YnVsYXJTZWdtZW50cywgaC5yYWRpYWxTZWdtZW50cywgaC5wLCBoLnEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTGF0aGVHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMYXRoZUJ1ZmZlckdlb21ldHJ5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgTWFbaC50eXBlXShoLnBvaW50cywgaC5zZWdtZW50cywgaC5waGlTdGFydCwgaC5waGlMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQnVmZmVyR2VvbWV0cnlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGQucGFyc2UoaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJHZW9tZXRyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gYy5wYXJzZShoLmRhdGEsIHRoaXMudGV4dHVyZVBhdGgpLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcIicgKyBoLnR5cGUgKyAnXCInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGcudXVpZCA9IGgudXVpZDtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gaC5uYW1lICYmIChnLm5hbWUgPSBoLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgYltoLnV1aWRdID0gZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgfSwgcGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0ge307XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IEhkO1xyXG4gICAgICAgICAgICAgICAgZC5zZXRUZXh0dXJlcyhiKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwLCBmID0gYS5sZW5ndGg7IGUgPCBmOyBlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGQucGFyc2UoYVtlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY1tnLnV1aWRdID0gZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgfSwgcGFyc2VBbmltYXRpb25zOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gW10sIGMgPSAwOyBjIDwgYS5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBxYS5wYXJzZShhW2NdKTtcclxuICAgICAgICAgICAgICAgIGIucHVzaChkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgfSwgcGFyc2VJbWFnZXM6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGMoYSkge1xyXG4gICAgICAgICAgICAgICAgZC5tYW5hZ2VyLml0ZW1TdGFydChhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnLmxvYWQoYSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQubWFuYWdlci5pdGVtRW5kKGEpXHJcbiAgICAgICAgICAgICAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkLm1hbmFnZXIuaXRlbUVycm9yKGEpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMsIGUgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSAmJiAwIDwgYS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gbmV3ICRkKGIpLCBnID0gbmV3IFljKGYpO1xyXG4gICAgICAgICAgICAgICAgZy5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSAwLCBoID0gYS5sZW5ndGg7IGYgPCBoOyBmKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGFbZl0sIGsgPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QobS51cmwpID8gbS51cmwgOiBkLnRleHR1cmVQYXRoICsgbS51cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgZVttLnV1aWRdID0gYyhrKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgfSwgcGFyc2VUZXh0dXJlczogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gYyhhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIGEpcmV0dXJuIGE7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLlwiLCBhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiW2FdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkID0ge1xyXG4gICAgICAgICAgICAgICAgVVZNYXBwaW5nOiAzMDAsXHJcbiAgICAgICAgICAgICAgICBDdWJlUmVmbGVjdGlvbk1hcHBpbmc6IDMwMSxcclxuICAgICAgICAgICAgICAgIEN1YmVSZWZyYWN0aW9uTWFwcGluZzogMzAyLFxyXG4gICAgICAgICAgICAgICAgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IDMwMyxcclxuICAgICAgICAgICAgICAgIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiAzMDQsXHJcbiAgICAgICAgICAgICAgICBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzogMzA1LFxyXG4gICAgICAgICAgICAgICAgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IDMwNixcclxuICAgICAgICAgICAgICAgIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOiAzMDdcclxuICAgICAgICAgICAgfSwgZSA9IHtSZXBlYXRXcmFwcGluZzogMUUzLCBDbGFtcFRvRWRnZVdyYXBwaW5nOiAxMDAxLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOiAxMDAyfSwgZiA9IHtcclxuICAgICAgICAgICAgICAgIE5lYXJlc3RGaWx0ZXI6IDEwMDMsXHJcbiAgICAgICAgICAgICAgICBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjogMTAwNCxcclxuICAgICAgICAgICAgICAgIE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI6IDEwMDUsXHJcbiAgICAgICAgICAgICAgICBMaW5lYXJGaWx0ZXI6IDEwMDYsXHJcbiAgICAgICAgICAgICAgICBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyOiAxMDA3LFxyXG4gICAgICAgICAgICAgICAgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyOiAxMDA4XHJcbiAgICAgICAgICAgIH0sIGcgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSlmb3IgKHZhciBoID0gMCwgbSA9IGEubGVuZ3RoOyBoIDwgbTsgaCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IGFbaF07XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGsuaW1hZ2UgJiYgY29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgay51dWlkKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYltrLmltYWdlXSAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGsuaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBuZXcgZWEoYltrLmltYWdlXSk7XHJcbiAgICAgICAgICAgICAgICBsLm5lZWRzVXBkYXRlID0gITA7XHJcbiAgICAgICAgICAgICAgICBsLnV1aWQgPSBrLnV1aWQ7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGsubmFtZSAmJiAobC5uYW1lID0gay5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gay5tYXBwaW5nICYmIChsLm1hcHBpbmcgPSBjKGsubWFwcGluZywgZCkpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBrLm9mZnNldCAmJiBsLm9mZnNldC5mcm9tQXJyYXkoay5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBrLnJlcGVhdCAmJiBsLnJlcGVhdC5mcm9tQXJyYXkoay5yZXBlYXQpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBrLndyYXAgJiYgKGwud3JhcFMgPSBjKGsud3JhcFswXSwgZSksIGwud3JhcFQgPSBjKGsud3JhcFsxXSwgZSkpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBrLm1pbkZpbHRlciAmJiAobC5taW5GaWx0ZXIgPSBjKGsubWluRmlsdGVyLCBmKSk7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGsubWFnRmlsdGVyICYmIChsLm1hZ0ZpbHRlciA9IGMoay5tYWdGaWx0ZXIsIGYpKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gay5hbmlzb3Ryb3B5ICYmIChsLmFuaXNvdHJvcHkgPSBrLmFuaXNvdHJvcHkpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBrLmZsaXBZICYmIChsLmZsaXBZID0gay5mbGlwWSk7XHJcbiAgICAgICAgICAgICAgICBnW2sudXVpZF0gPVxyXG4gICAgICAgICAgICAgICAgICAgIGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZ1xyXG4gICAgICAgIH0sIHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IFM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZShhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBjW2FdICYmIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5XCIsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjW2FdXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSlyZXR1cm4gdm9pZCAwID09PSBkW2FdICYmIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsXCIsIGEpLCBkW2FdXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGc7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGIudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTY2VuZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gbmV3IG1iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIuYmFja2dyb3VuZCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGIuYmFja2dyb3VuZCkgJiYgKGcuYmFja2dyb3VuZCA9IG5ldyBKKGIuYmFja2dyb3VuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIuZm9nICYmIChcIkZvZ1wiID09PSBiLmZvZy50eXBlID8gZy5mb2cgPSBuZXcgTGIoYi5mb2cuY29sb3IsIGIuZm9nLm5lYXIsIGIuZm9nLmZhcikgOiBcIkZvZ0V4cDJcIiA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZm9nLnR5cGUgJiYgKGcuZm9nID0gbmV3IEtiKGIuZm9nLmNvbG9yLCBiLmZvZy5kZW5zaXR5KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUGVyc3BlY3RpdmVDYW1lcmFcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBGYShiLmZvdiwgYi5hc3BlY3QsIGIubmVhciwgYi5mYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIuZm9jdXMgJiYgKGcuZm9jdXMgPSBiLmZvY3VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiLnpvb20gJiYgKGcuem9vbSA9IGIuem9vbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gYi5maWxtR2F1Z2UgJiYgKGcuZmlsbUdhdWdlID0gYi5maWxtR2F1Z2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIuZmlsbU9mZnNldCAmJiAoZy5maWxtT2Zmc2V0ID0gYi5maWxtT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiLnZpZXcgJiYgKGcudmlldyA9IE9iamVjdC5hc3NpZ24oe30sIGIudmlldykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiT3J0aG9ncmFwaGljQ2FtZXJhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgSmIoYi5sZWZ0LCBiLnJpZ2h0LCBiLnRvcCwgYi5ib3R0b20sIGIubmVhciwgYi5mYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQW1iaWVudExpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgQWQoYi5jb2xvciwgYi5pbnRlbnNpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRGlyZWN0aW9uYWxMaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyB6ZChiLmNvbG9yLCBiLmludGVuc2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludExpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgeGQoYi5jb2xvciwgYi5pbnRlbnNpdHksIGIuZGlzdGFuY2UsIGIuZGVjYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU3BvdExpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgd2QoYi5jb2xvciwgYi5pbnRlbnNpdHksIGIuZGlzdGFuY2UsIGIuYW5nbGUsIGIucGVudW1icmEsIGIuZGVjYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSGVtaXNwaGVyZUxpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgdWQoYi5jb2xvciwgYi5ncm91bmRDb2xvciwgYi5pbnRlbnNpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTWVzaFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gZShiLmdlb21ldHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBmKGIubWF0ZXJpYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gZy5ib25lcyAmJiAwIDwgZy5ib25lcy5sZW5ndGggPyBuZXcgcWQoZywgaCkgOiBuZXcgQWEoZywgaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMT0RcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBFYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkxpbmVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBVYShlKGIuZ2VvbWV0cnkpLCBmKGIubWF0ZXJpYWwpLCBiLm1vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTGluZVNlZ21lbnRzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgZ2EoZShiLmdlb21ldHJ5KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYoYi5tYXRlcmlhbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUG9pbnRDbG91ZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludHNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBNYihlKGIuZ2VvbWV0cnkpLCBmKGIubWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNwcml0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gbmV3IERjKGYoYi5tYXRlcmlhbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBGYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNraW5uZWRNZXNoXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdExvYWRlci5wYXJzZU9iamVjdCgpIGRvZXMgbm90IHN1cHBvcnQgU2tpbm5lZE1lc2ggdHlwZS4gSW5zdGFudGlhdGVzIE9iamVjdDNEIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgeFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZy51dWlkID0gYi51dWlkO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiLm5hbWUgJiYgKGcubmFtZSA9IGIubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIubWF0cml4ID8gKGEuZnJvbUFycmF5KGIubWF0cml4KSwgYS5kZWNvbXBvc2UoZy5wb3NpdGlvbiwgZy5xdWF0ZXJuaW9uLCBnLnNjYWxlKSkgOiAodm9pZCAwICE9PSBiLnBvc2l0aW9uICYmIGcucG9zaXRpb24uZnJvbUFycmF5KGIucG9zaXRpb24pLFxyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiLnJvdGF0aW9uICYmIGcucm90YXRpb24uZnJvbUFycmF5KGIucm90YXRpb24pLCB2b2lkIDAgIT09IGIucXVhdGVybmlvbiAmJiBnLnF1YXRlcm5pb24uZnJvbUFycmF5KGIucXVhdGVybmlvbiksIHZvaWQgMCAhPT0gYi5zY2FsZSAmJiBnLnNjYWxlLmZyb21BcnJheShiLnNjYWxlKSk7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGIuY2FzdFNoYWRvdyAmJiAoZy5jYXN0U2hhZG93ID0gYi5jYXN0U2hhZG93KTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gYi5yZWNlaXZlU2hhZG93ICYmIChnLnJlY2VpdmVTaGFkb3cgPSBiLnJlY2VpdmVTaGFkb3cpO1xyXG4gICAgICAgICAgICAgICAgYi5zaGFkb3cgJiYgKHZvaWQgMCAhPT0gYi5zaGFkb3cuYmlhcyAmJiAoZy5zaGFkb3cuYmlhcyA9IGIuc2hhZG93LmJpYXMpLCB2b2lkIDAgIT09IGIuc2hhZG93LnJhZGl1cyAmJiAoZy5zaGFkb3cucmFkaXVzID0gYi5zaGFkb3cucmFkaXVzKSwgdm9pZCAwICE9PSBiLnNoYWRvdy5tYXBTaXplICYmIGcuc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KGIuc2hhZG93Lm1hcFNpemUpLCB2b2lkIDAgIT09IGIuc2hhZG93LmNhbWVyYSAmJiAoZy5zaGFkb3cuY2FtZXJhID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlT2JqZWN0KGIuc2hhZG93LmNhbWVyYSkpKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gYi52aXNpYmxlICYmIChnLnZpc2libGUgPSBiLnZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBiLnVzZXJEYXRhICYmIChnLnVzZXJEYXRhID0gYi51c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBiLmNoaWxkcmVuKWZvciAodmFyIG0gaW4gYi5jaGlsZHJlbilnLmFkZCh0aGlzLnBhcnNlT2JqZWN0KGIuY2hpbGRyZW5bbV0sIGMsIGQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChcIkxPRFwiID09PSBiLnR5cGUpZm9yIChiID0gYi5sZXZlbHMsIGggPSAwOyBoIDwgYi5sZW5ndGg7IGgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gYltoXTtcclxuICAgICAgICAgICAgICAgICAgICBtID0gZy5nZXRPYmplY3RCeVByb3BlcnR5KFwidXVpZFwiLCBrLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBtICYmIGcuYWRkTGV2ZWwobSwgay5kaXN0YW5jZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KClcclxuICAgIH0pO1xyXG4gICAgdWEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB1YSwgZ2V0UG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkN1cnZlOiBXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfSwgZ2V0UG9pbnRBdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldFV0b1RtYXBwaW5nKGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludChhKVxyXG4gICAgICAgIH0sIGdldFBvaW50czogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaXNOYU4oYSkgJiYgKGEgPSA1KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IFtdLCBjID0gMDsgYyA8PSBhOyBjKyspYi5wdXNoKHRoaXMuZ2V0UG9pbnQoYyAvIGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICB9LCBnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlzTmFOKGEpICYmIChhID0gNSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSBbXSwgYyA9IDA7IGMgPD0gYTsgYysrKWIucHVzaCh0aGlzLmdldFBvaW50QXQoYyAvIGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICB9LCBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXVxyXG4gICAgICAgIH0sIGdldExlbmd0aHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlzTmFOKGEpICYmIChhID0gdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyA/IHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgOiAyMDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZUFyY0xlbmd0aHMgJiYgdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBhICsgMSAmJiAhdGhpcy5uZWVkc1VwZGF0ZSlyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSAhMTtcclxuICAgICAgICAgICAgdmFyIGIgPSBbXSwgYywgZCA9IHRoaXMuZ2V0UG9pbnQoMCksIGUsIGYgPSAwO1xyXG4gICAgICAgICAgICBiLnB1c2goMCk7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDE7IGUgPD0gYTsgZSsrKWMgPSB0aGlzLmdldFBvaW50KGUgLyBhKSwgZiArPSBjLmRpc3RhbmNlVG8oZCksIGIucHVzaChmKSwgZCA9IGM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGJcclxuICAgICAgICB9LCB1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSAhMDtcclxuICAgICAgICAgICAgdGhpcy5nZXRMZW5ndGhzKClcclxuICAgICAgICB9LCBnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldExlbmd0aHMoKSwgZCwgZSA9IGMubGVuZ3RoLCBmO1xyXG4gICAgICAgICAgICBmID0gYiA/IGIgOiBhICogY1tlIC0gMV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGcgPSAwLCBoID0gZSAtIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgIG07IGcgPD0gaDspaWYgKGQgPSBNYXRoLmZsb29yKGcgKyAoaCAtIGcpIC8gMiksIG0gPSBjW2RdIC0gZiwgMCA+IG0pIGcgPSBkICsgMTsgZWxzZSBpZiAoMCA8IG0pIGggPSBkIC0gMTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoID0gZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZCA9IGg7XHJcbiAgICAgICAgICAgIGlmIChjW2RdID09PSBmKXJldHVybiBkIC8gKGUgLSAxKTtcclxuICAgICAgICAgICAgZyA9IGNbZF07XHJcbiAgICAgICAgICAgIHJldHVybiAoZCArIChmIC0gZykgLyAoY1tkICsgMV0gLSBnKSkgLyAoZSAtIDEpXHJcbiAgICAgICAgfSwgZ2V0VGFuZ2VudDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPVxyXG4gICAgICAgICAgICAgICAgYSAtIDFFLTQ7XHJcbiAgICAgICAgICAgIGEgKz0gMUUtNDtcclxuICAgICAgICAgICAgMCA+IGIgJiYgKGIgPSAwKTtcclxuICAgICAgICAgICAgMSA8IGEgJiYgKGEgPSAxKTtcclxuICAgICAgICAgICAgYiA9IHRoaXMuZ2V0UG9pbnQoYik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBvaW50KGEpLmNsb25lKCkuc3ViKGIpLm5vcm1hbGl6ZSgpXHJcbiAgICAgICAgfSwgZ2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gdGhpcy5nZXRVdG9UbWFwcGluZyhhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFuZ2VudChhKVxyXG4gICAgICAgIH0sIGNvbXB1dGVGcmVuZXRGcmFtZXM6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gbmV3IHEsIGQgPSBbXSwgZSA9IFtdLCBmID0gW10sIGcgPSBuZXcgcSwgaCA9IG5ldyBTLCBtLCBrO1xyXG4gICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDw9IGE7IG0rKylrID0gbSAvIGEsIGRbbV0gPSB0aGlzLmdldFRhbmdlbnRBdChrKSwgZFttXS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgZVswXSA9IG5ldyBxO1xyXG4gICAgICAgICAgICBmWzBdID0gbmV3IHE7XHJcbiAgICAgICAgICAgIG0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICBrID0gTWF0aC5hYnMoZFswXS54KTtcclxuICAgICAgICAgICAgdmFyIGwgPSBNYXRoLmFicyhkWzBdLnkpLCBwID0gTWF0aC5hYnMoZFswXS56KTtcclxuICAgICAgICAgICAgayA8PSBtICYmIChtID0gaywgYy5zZXQoMSwgMCwgMCkpO1xyXG4gICAgICAgICAgICBsIDw9IG0gJiYgKG0gPSBsLCBjLnNldCgwLCAxLCAwKSk7XHJcbiAgICAgICAgICAgIHAgPD0gbSAmJiBjLnNldCgwLCAwLCAxKTtcclxuICAgICAgICAgICAgZy5jcm9zc1ZlY3RvcnMoZFswXSwgYykubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGVbMF0uY3Jvc3NWZWN0b3JzKGRbMF0sIGcpO1xyXG4gICAgICAgICAgICBmWzBdLmNyb3NzVmVjdG9ycyhkWzBdLCBlWzBdKTtcclxuICAgICAgICAgICAgZm9yIChtID0gMTsgbSA8PSBhOyBtKyspZVttXSA9IGVbbSAtIDFdLmNsb25lKCksIGZbbV0gPSBmW20gLSAxXS5jbG9uZSgpLCBnLmNyb3NzVmVjdG9ycyhkW20gLSAxXSwgZFttXSksIGcubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiAmJiAoZy5ub3JtYWxpemUoKSwgYyA9IE1hdGguYWNvcyhOLmNsYW1wKGRbbSAtIDFdLmRvdChkW21dKSwgLTEsIDEpKSwgZVttXS5hcHBseU1hdHJpeDQoaC5tYWtlUm90YXRpb25BeGlzKGcsIGMpKSksIGZbbV0uY3Jvc3NWZWN0b3JzKGRbbV0sIGVbbV0pO1xyXG4gICAgICAgICAgICBpZiAoITAgPT09IGIpZm9yIChjID0gTWF0aC5hY29zKE4uY2xhbXAoZVswXS5kb3QoZVthXSksIC0xLCAxKSksIGMgLz0gYSwgMCA8IGRbMF0uZG90KGcuY3Jvc3NWZWN0b3JzKGVbMF0sIGVbYV0pKSAmJiAoYyA9IC1jKSwgbSA9IDE7IG0gPD0gYTsgbSsrKWVbbV0uYXBwbHlNYXRyaXg0KGgubWFrZVJvdGF0aW9uQXhpcyhkW21dLCBjICogbSkpLFxyXG4gICAgICAgICAgICAgICAgZlttXS5jcm9zc1ZlY3RvcnMoZFttXSwgZVttXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7dGFuZ2VudHM6IGQsIG5vcm1hbHM6IGUsIGJpbm9ybWFsczogZn1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1YS5wcm90b3R5cGUpO1xyXG4gICAgVGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGE7XHJcbiAgICBUYS5wcm90b3R5cGUuaXNMaW5lQ3VydmUgPSAhMDtcclxuICAgIFRhLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKDEgPT09IGEpcmV0dXJuIHRoaXMudjIuY2xvbmUoKTtcclxuICAgICAgICB2YXIgYiA9IHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSk7XHJcbiAgICAgICAgYi5tdWx0aXBseVNjYWxhcihhKS5hZGQodGhpcy52MSk7XHJcbiAgICAgICAgcmV0dXJuIGJcclxuICAgIH07XHJcbiAgICBUYS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQoYSlcclxuICAgIH07XHJcbiAgICBUYS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSkubm9ybWFsaXplKClcclxuICAgIH07XHJcbiAgICBhZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodWEucHJvdG90eXBlKSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBhZCwgYWRkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnZlcy5wdXNoKGEpXHJcbiAgICAgICAgfSwgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5jdXJ2ZXNbMF0uZ2V0UG9pbnQoMCksIGIgPSB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGggLSAxXS5nZXRQb2ludCgxKTtcclxuICAgICAgICAgICAgYS5lcXVhbHMoYikgfHwgdGhpcy5jdXJ2ZXMucHVzaChuZXcgVGEoYiwgYSkpXHJcbiAgICAgICAgfSwgZ2V0UG9pbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYSAqIHRoaXMuZ2V0TGVuZ3RoKCksIGMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG4gICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgYy5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY1thXSA+PSBiKXJldHVybiBiID0gY1thXSAtIGIsIGEgPSB0aGlzLmN1cnZlc1thXSwgYyA9IGEuZ2V0TGVuZ3RoKCksIGEuZ2V0UG9pbnRBdCgwID09PSBjID8gMCA6IDEgLSBiIC8gYyk7XHJcbiAgICAgICAgICAgICAgICBhKytcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgIH0sIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhW2EubGVuZ3RoIC0gMV1cclxuICAgICAgICB9LCB1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPVxyXG4gICAgICAgICAgICAgICAgITA7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGhzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5nZXRMZW5ndGhzKClcclxuICAgICAgICB9LCBnZXRDdXJ2ZUxlbmd0aHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoKXJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBiID0gMCwgYyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGMgPCBkOyBjKyspYiArPSB0aGlzLmN1cnZlc1tjXS5nZXRMZW5ndGgoKSwgYS5wdXNoKGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHMgPSBhXHJcbiAgICAgICAgfSwgZ2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpc05hTihhKSAmJiAoYSA9IDQwKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IFtdLCBjID0gMDsgYyA8PSBhOyBjKyspYi5wdXNoKHRoaXMuZ2V0UG9pbnQoYyAvIGEpKTtcclxuICAgICAgICAgICAgdGhpcy5hdXRvQ2xvc2UgJiYgYi5wdXNoKGJbMF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYlxyXG4gICAgICAgIH0sIGdldFBvaW50czogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSA9IGEgfHwgMTI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSBbXSwgYywgZCA9IDAsIGUgPSB0aGlzLmN1cnZlczsgZCA8IGUubGVuZ3RoOyBkKyspZm9yICh2YXIgZiA9XHJcbiAgICAgICAgICAgICAgICAgICAgZVtkXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gZi5nZXRQb2ludHMoZiAmJiBmLmlzRWxsaXBzZUN1cnZlID8gMiAqIGEgOiBmICYmIGYuaXNMaW5lQ3VydmUgPyAxIDogZiAmJiBmLmlzU3BsaW5lQ3VydmUgPyBhICogZi5wb2ludHMubGVuZ3RoIDogYSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IDA7IGcgPCBmLmxlbmd0aDsgZysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IGZbZ107XHJcbiAgICAgICAgICAgICAgICBjICYmIGMuZXF1YWxzKGgpIHx8IChiLnB1c2goaCksIGMgPSBoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXV0b0Nsb3NlICYmIDEgPCBiLmxlbmd0aCAmJiAhYltiLmxlbmd0aCAtIDFdLmVxdWFscyhiWzBdKSAmJiBiLnB1c2goYlswXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgfSwgY3JlYXRlUG9pbnRzR2VvbWV0cnk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGEgPSB0aGlzLmdldFBvaW50cyhhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoYSlcclxuICAgICAgICB9LCBjcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeShhKVxyXG4gICAgICAgIH0sIGNyZWF0ZUdlb21ldHJ5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gbmV3IFQsIGMgPSAwLCBkID0gYS5sZW5ndGg7IGMgPCBkOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gYVtjXTtcclxuICAgICAgICAgICAgICAgIGIudmVydGljZXMucHVzaChuZXcgcShlLngsIGUueSwgZS56IHx8IDApKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgV2EucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1YS5wcm90b3R5cGUpO1xyXG4gICAgV2EucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2E7XHJcbiAgICBXYS5wcm90b3R5cGUuaXNFbGxpcHNlQ3VydmUgPSAhMDtcclxuICAgIFdhLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYiA9IDIgKiBNYXRoLlBJLCBjID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgIGQgPSBNYXRoLmFicyhjKSA8IE51bWJlci5FUFNJTE9OOyAwID4gYzspYyArPSBiO1xyXG4gICAgICAgIGZvciAoOyBjID4gYjspYyAtPSBiO1xyXG4gICAgICAgIGMgPCBOdW1iZXIuRVBTSUxPTiAmJiAoYyA9IGQgPyAwIDogYik7XHJcbiAgICAgICAgITAgIT09IHRoaXMuYUNsb2Nrd2lzZSB8fCBkIHx8IChjID0gYyA9PT0gYiA/IC1iIDogYyAtIGIpO1xyXG4gICAgICAgIGIgPSB0aGlzLmFTdGFydEFuZ2xlICsgYSAqIGM7XHJcbiAgICAgICAgYSA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyhiKTtcclxuICAgICAgICB2YXIgZSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbihiKTtcclxuICAgICAgICAwICE9PSB0aGlzLmFSb3RhdGlvbiAmJiAoYiA9IE1hdGguY29zKHRoaXMuYVJvdGF0aW9uKSxcclxuICAgICAgICAgICAgYyA9IE1hdGguc2luKHRoaXMuYVJvdGF0aW9uKSwgZCA9IGEgLSB0aGlzLmFYLCBlIC09IHRoaXMuYVksIGEgPSBkICogYiAtIGUgKiBjICsgdGhpcy5hWCwgZSA9IGQgKiBjICsgZSAqIGIgKyB0aGlzLmFZKTtcclxuICAgICAgICByZXR1cm4gbmV3IEQoYSwgZSlcclxuICAgIH07XHJcbiAgICBDYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHVhLnByb3RvdHlwZSk7XHJcbiAgICBDYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYjtcclxuICAgIENiLnByb3RvdHlwZS5pc1NwbGluZUN1cnZlID0gITA7XHJcbiAgICBDYi5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcy5wb2ludHMsIGMgPSAoYi5sZW5ndGggLSAxKSAqIGE7XHJcbiAgICAgICAgYSA9IE1hdGguZmxvb3IoYyk7XHJcbiAgICAgICAgdmFyIGMgPSBjIC0gYSwgZCA9IGJbMCA9PT0gYSA/IGEgOiBhIC0gMV0sIGUgPSBiW2FdLCBmID0gYlthID4gYi5sZW5ndGggLSAyID8gYi5sZW5ndGggLSAxIDogYSArIDFdLFxyXG4gICAgICAgICAgICBiID0gYlthID4gYi5sZW5ndGggLSAzID8gYi5sZW5ndGggLSAxIDogYSArIDJdO1xyXG4gICAgICAgIHJldHVybiBuZXcgRChUZShjLCBkLngsIGUueCwgZi54LCBiLngpLCBUZShjLCBkLnksIGUueSwgZi55LCBiLnkpKVxyXG4gICAgfTtcclxuICAgIGZjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodWEucHJvdG90eXBlKTtcclxuICAgIGZjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9XHJcbiAgICAgICAgZmM7XHJcbiAgICBmYy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcy52MCwgYyA9IHRoaXMudjEsIGQgPSB0aGlzLnYyLCBlID0gdGhpcy52MztcclxuICAgICAgICByZXR1cm4gbmV3IEQoQmIoYSwgYi54LCBjLngsIGQueCwgZS54KSwgQmIoYSwgYi55LCBjLnksIGQueSwgZS55KSlcclxuICAgIH07XHJcbiAgICBnYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHVhLnByb3RvdHlwZSk7XHJcbiAgICBnYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBnYztcclxuICAgIGdjLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdmFyIGIgPSB0aGlzLnYwLCBjID0gdGhpcy52MSwgZCA9IHRoaXMudjI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEKEFiKGEsIGIueCwgYy54LCBkLngpLCBBYihhLCBiLnksIGMueSwgZC55KSlcclxuICAgIH07XHJcbiAgICB2YXIgeGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoYWQucHJvdG90eXBlKSwge1xyXG4gICAgICAgIGZyb21Qb2ludHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKGFbMF0ueCwgYVswXS55KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDEsIGMgPSBhLmxlbmd0aDsgYiA8IGM7IGIrKyl0aGlzLmxpbmVUbyhhW2JdLngsIGFbYl0ueSlcclxuICAgICAgICB9LCBtb3ZlVG86IGZ1bmN0aW9uIChhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnQuc2V0KGEsIGIpXHJcbiAgICAgICAgfSwgbGluZVRvOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBUYSh0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgRChhLCBiKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VydmVzLnB1c2goYyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50LnNldChhLCBiKVxyXG4gICAgICAgIH0sIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGEgPSBuZXcgZ2ModGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IEQoYSwgYiksIG5ldyBEKGMsIGQpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaChhKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnQuc2V0KGMsIGQpXHJcbiAgICAgICAgfSwgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICAgICAgYSA9IG5ldyBmYyh0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgRChhLCBiKSwgbmV3IEQoYywgZCksIG5ldyBEKGUsIGYpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaChhKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnQuc2V0KGUsIGYpXHJcbiAgICAgICAgfSwgc3BsaW5lVGhydTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBbdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKV0uY29uY2F0KGEpLFxyXG4gICAgICAgICAgICAgICAgYiA9IG5ldyBDYihiKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaChiKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnQuY29weShhW2EubGVuZ3RoIC0gMV0pXHJcbiAgICAgICAgfSwgYXJjOiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgICAgICB0aGlzLmFic2FyYyhhICsgdGhpcy5jdXJyZW50UG9pbnQueCwgYiArIHRoaXMuY3VycmVudFBvaW50LnksIGMsIGQsIGUsIGYpXHJcbiAgICAgICAgfSwgYWJzYXJjOiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgICAgICB0aGlzLmFic2VsbGlwc2UoYSwgYiwgYywgYywgZCwgZSwgZilcclxuICAgICAgICB9LCBlbGxpcHNlOiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xyXG4gICAgICAgICAgICB0aGlzLmFic2VsbGlwc2UoYSArIHRoaXMuY3VycmVudFBvaW50LngsIGIgKyB0aGlzLmN1cnJlbnRQb2ludC55LCBjLCBkLCBlLCBmLCBnLCBoKVxyXG4gICAgICAgIH0sIGFic2VsbGlwc2U6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XHJcbiAgICAgICAgICAgIGEgPSBuZXcgV2EoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7XHJcbiAgICAgICAgICAgIDAgPCB0aGlzLmN1cnZlcy5sZW5ndGggJiYgKGIgPSBhLmdldFBvaW50KDApLCBiLmVxdWFscyh0aGlzLmN1cnJlbnRQb2ludCkgfHwgdGhpcy5saW5lVG8oYi54LCBiLnkpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaChhKTtcclxuICAgICAgICAgICAgYSA9IGEuZ2V0UG9pbnQoMSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50LmNvcHkoYSlcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGJkLnByb3RvdHlwZSA9IHhlO1xyXG4gICAgeGUuY29uc3RydWN0b3IgPSBiZDtcclxuICAgIERiLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4ZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogRGIsIGdldFBvaW50c0hvbGVzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gW10sIGMgPSAwLCBkID0gdGhpcy5ob2xlcy5sZW5ndGg7IGMgPCBkOyBjKyspYltjXSA9IHRoaXMuaG9sZXNbY10uZ2V0UG9pbnRzKGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gYlxyXG4gICAgICAgIH0sIGV4dHJhY3RBbGxQb2ludHM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKGEpLCBob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyhhKX1cclxuICAgICAgICB9LCBleHRyYWN0UG9pbnRzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKGEpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBlZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IGJkO1xyXG4gICAgICAgICAgICB0aGlzLnN1YlBhdGhzLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgubW92ZVRvKGEsIGIpXHJcbiAgICAgICAgfSwgbGluZVRvOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVUbyhhLCBiKVxyXG4gICAgICAgIH0sIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgucXVhZHJhdGljQ3VydmVUbyhhLCBiLCBjLCBkKVxyXG4gICAgICAgIH0sIGJlemllckN1cnZlVG86IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyhhLCBiLCBjLCBkLCBlLCBmKVxyXG4gICAgICAgIH0sIHNwbGluZVRocnU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguc3BsaW5lVGhydShhKVxyXG4gICAgICAgIH0sIHRvU2hhcGVzOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjKGEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSBbXSwgYyA9IDAsIGQgPSBhLmxlbmd0aDsgYyA8IGQ7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gYVtjXSwgZiA9IG5ldyBEYjtcclxuICAgICAgICAgICAgICAgICAgICBmLmN1cnZlcyA9IGUuY3VydmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGIucHVzaChmKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gYi5sZW5ndGgsIGQgPSAhMSwgZSA9IGMgLSAxLCBmID0gMDsgZiA8IGM7IGUgPSBmKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGJbZV0sIGggPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiW2ZdLCBrID0gaC54IC0gZy54LCBtID0gaC55IC0gZy55O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhtKSA+IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID4gbSAmJiAoZyA9IGJbZl0sIGsgPSAtaywgaCA9IGJbZV0sIG0gPSAtbSksICEoYS55IDwgZy55IHx8IGEueSA+IGgueSkpaWYgKGEueSA9PT0gZy55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS54ID09PSBnLngpcmV0dXJuICEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbSAqIChhLnggLSBnLngpIC0gayAqIChhLnkgLSBnLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGUpcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA+IGUgfHwgKGQgPSAhZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYS55ID09PSBnLnkgJiYgKGgueCA8PSBhLnggJiYgYS54IDw9IGcueCB8fCBnLnggPD0gYS54ICYmIGEueCA8PSBoLngpKXJldHVybiAhMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGUgPSBJYS5pc0Nsb2NrV2lzZSwgZiA9IHRoaXMuc3ViUGF0aHM7XHJcbiAgICAgICAgICAgIGlmICgwID09PSBmLmxlbmd0aClyZXR1cm4gW107XHJcbiAgICAgICAgICAgIGlmICghMCA9PT0gYilyZXR1cm4gYyhmKTtcclxuICAgICAgICAgICAgdmFyIGcsIGgsIG0sIGsgPSBbXTtcclxuICAgICAgICAgICAgaWYgKDEgPT09IGYubGVuZ3RoKXJldHVybiBoID0gZlswXSwgbSA9IG5ldyBEYiwgbS5jdXJ2ZXMgPSBoLmN1cnZlcywgay5wdXNoKG0pLCBrO1xyXG4gICAgICAgICAgICB2YXIgbCA9ICFlKGZbMF0uZ2V0UG9pbnRzKCkpLCBsID0gYSA/ICFsIDogbDtcclxuICAgICAgICAgICAgbSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcCA9XHJcbiAgICAgICAgICAgICAgICBbXSwgbiA9IFtdLCBxID0gMCwgeDtcclxuICAgICAgICAgICAgcFtxXSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgbltxXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciByID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgQSA9IGYubGVuZ3RoOyByIDwgQTsgcisrKWggPSBmW3JdLCB4ID0gaC5nZXRQb2ludHMoKSwgZyA9IGUoeCksIChnID0gYSA/ICFnIDogZykgPyAoIWwgJiYgcFtxXSAmJiBxKyssIHBbcV0gPSB7XHJcbiAgICAgICAgICAgICAgICBzOiBuZXcgRGIsXHJcbiAgICAgICAgICAgICAgICBwOiB4XHJcbiAgICAgICAgICAgIH0sIHBbcV0ucy5jdXJ2ZXMgPSBoLmN1cnZlcywgbCAmJiBxKyssIG5bcV0gPSBbXSkgOiBuW3FdLnB1c2goe2g6IGgsIHA6IHhbMF19KTtcclxuICAgICAgICAgICAgaWYgKCFwWzBdKXJldHVybiBjKGYpO1xyXG4gICAgICAgICAgICBpZiAoMSA8IHAubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByID0gITE7XHJcbiAgICAgICAgICAgICAgICBoID0gW107XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoZiA9IHAubGVuZ3RoOyBlIDwgZjsgZSsrKW1bZV0gPSBbXTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChmID0gcC5sZW5ndGg7IGUgPCBmOyBlKyspZm9yIChnID0gbltlXSwgbCA9IDA7IGwgPCBnLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IGdbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9ICEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoQSA9IDA7IEEgPCBwLmxlbmd0aDsgQSsrKWQocS5wLCBwW0FdLnApICYmIChlICE9PSBBICYmIGgucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21zOiBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3M6IEEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGU6IGxcclxuICAgICAgICAgICAgICAgICAgICB9KSwgeCA/ICh4ID0gITEsIG1bQV0ucHVzaChxKSkgOiByID0gITApO1xyXG4gICAgICAgICAgICAgICAgICAgIHggJiYgbVtlXS5wdXNoKHEpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAwIDwgaC5sZW5ndGggJiYgKHIgfHwgKG4gPSBtKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByID1cclxuICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IHAubGVuZ3RoOyByIDwgZTsgcisrKWZvciAobSA9IHBbcl0ucywgay5wdXNoKG0pLCBoID0gbltyXSwgZiA9IDAsIGcgPSBoLmxlbmd0aDsgZiA8IGc7IGYrKyltLmhvbGVzLnB1c2goaFtmXS5oKTtcclxuICAgICAgICAgICAgcmV0dXJuIGtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihmZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBpc0ZvbnQ6ICEwLCBnZW5lcmF0ZVNoYXBlczogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMTAwKTtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBjICYmIChjID0gNCk7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICBhID0gU3RyaW5nKGEpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IGIgLyBkLnJlc29sdXRpb24sIGYgPSAoZC5ib3VuZGluZ0JveC55TWF4IC0gZC5ib3VuZGluZ0JveC55TWluICsgZC51bmRlcmxpbmVUaGlja25lc3MpICogZSwgZyA9IDAsXHJcbiAgICAgICAgICAgICAgICBoID0gMDtcclxuICAgICAgICAgICAgYiA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGEubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gYVttXTtcclxuICAgICAgICAgICAgICAgIGlmIChcIlxcblwiID09PSBrKSBnID0gMCwgaCAtPSBmOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbDtcclxuICAgICAgICAgICAgICAgICAgICBsID0gZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGcsIG4gPSBoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrID0gZC5nbHlwaHNba10gfHwgZC5nbHlwaHNbXCI/XCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IGVlLCB4ID0gW10sIHIsIEEsIHcsIHksIHosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LCBELCBJO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoay5vKWZvciAodmFyIEMgPSBrLl9jYWNoZWRPdXRsaW5lIHx8IChrLl9jYWNoZWRPdXRsaW5lID0gay5vLnNwbGl0KFwiIFwiKSksIEYgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEogPSBDLmxlbmd0aDsgRiA8IEo7KXN3aXRjaCAoQ1tGKytdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBDW0YrK10gKiBsICsgcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBID0gQ1tGKytdICogbCArIG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5tb3ZlVG8ociwgQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBDW0YrK10gKiBsICsgcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBID0gQ1tGKytdICogbCArIG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5saW5lVG8ociwgQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBDW0YrK10gKiBsICsgcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBID0gQ1tGKytdICogbCArIG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiA9IENbRisrXSAqIGwgKyBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBDW0YrK10gKiBsICsgbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLnF1YWRyYXRpY0N1cnZlVG8oeiwgdiwgciwgQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPSB4W3gubGVuZ3RoIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHkueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHkueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgSCA9IDE7IEggPD0gYzsgSCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTiA9IEggLyBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWIoTiwgdywgeiwgcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBYihOLCB5LCB2LCBBKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IENbRisrXSAqIGwgKyBwLCBBID0gQ1tGKytdICogbCArIG4sIHogPSBDW0YrK10gKiBsICsgcCwgdiA9IENbRisrXSAqIGwgKyBuLCBEID0gQ1tGKytdICogbCArIHAsIEkgPSBDW0YrK10gKiBsICsgbiwgcS5iZXppZXJDdXJ2ZVRvKHosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LCBELCBJLCByLCBBKSwgeSA9IHhbeC5sZW5ndGggLSAxXSlmb3IgKHcgPSB5LngsIHkgPSB5LnksIEggPSAxOyBIIDw9IGM7IEgrKylOID0gSCAvIGMsIEJiKE4sIHcsIHosIEQsIHIpLCBCYihOLCB5LCB2LCBJLCBBKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB7b2Zmc2V0WDogay5oYSAqIGwsIHBhdGg6IHF9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGwgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZyArPSBsLm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5wdXNoKGwucGF0aClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjID0gW107XHJcbiAgICAgICAgICAgIGQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGEgPSBiLmxlbmd0aDsgZCA8IGE7IGQrKylBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjLCBiW2RdLnRvU2hhcGVzKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gY1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihVZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBsb2FkOiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIChuZXcgc2EodGhpcy5tYW5hZ2VyKSkubG9hZChhLCBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBKU09OLnBhcnNlKGEpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuRm9udExvYWRlcjogdHlwZWZhY2UuanMgc3VwcG9ydCBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgdHlwZWZhY2UuanNvbiBpbnN0ZWFkLlwiKSwgYyA9IEpTT04ucGFyc2UoYS5zdWJzdHJpbmcoNjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEubGVuZ3RoIC0gMikpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhID0gZS5wYXJzZShjKTtcclxuICAgICAgICAgICAgICAgIGIgJiYgYihhKVxyXG4gICAgICAgICAgICB9LCBjLCBkKVxyXG4gICAgICAgIH0sIHBhcnNlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGZlKGEpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgUGQsIGplID0ge1xyXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBQZCAmJiAoUGQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gUGRcclxuICAgICAgICB9LCBzZXRDb250ZXh0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBQZCA9IGFcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihnZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBsb2FkOiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBzYSh0aGlzLm1hbmFnZXIpO1xyXG4gICAgICAgICAgICBlLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xyXG4gICAgICAgICAgICBlLmxvYWQoYSwgZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGplLmdldENvbnRleHQoKS5kZWNvZGVBdWRpb0RhdGEoYSwgZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBiKGEpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LCBjLCBkKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG1hLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogaGUsIGlzUmVjdEFyZWFMaWdodDogITAsXHJcbiAgICAgICAgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgbWEucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBhKTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGEud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gYS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKFZlLnByb3RvdHlwZSwge1xyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYiwgYywgZCwgZSwgZiwgZywgaCA9IG5ldyBTLCBtID0gbmV3IFM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgIT09IHRoaXMgfHwgYiAhPT0gay5mb2N1cyB8fCBjICE9PSBrLmZvdiB8fCBkICE9PSBrLmFzcGVjdCAqIHRoaXMuYXNwZWN0IHx8IGUgIT09IGsubmVhciB8fCBmICE9PSBrLmZhciB8fCBnICE9PSBrLnpvb20pIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBiID0gay5mb2N1cztcclxuICAgICAgICAgICAgICAgICAgICBjID0gay5mb3Y7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IGsuYXNwZWN0ICogdGhpcy5hc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IGsubmVhcjtcclxuICAgICAgICAgICAgICAgICAgICBmID0gay5mYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IGsuem9vbTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGsucHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpLCBwID0gdGhpcy5leWVTZXAgLyAyLCBuID0gcCAqIGUgLyBiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gZSAqIE1hdGgudGFuKE4uREVHMlJBRCAqIGMgKiAuNSkgLyBnLCB4O1xyXG4gICAgICAgICAgICAgICAgICAgIG0uZWxlbWVudHNbMTJdID0gLXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaC5lbGVtZW50c1sxMl0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtcSAqIGQgKyBuO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBxICogZCArIG47XHJcbiAgICAgICAgICAgICAgICAgICAgbC5lbGVtZW50c1swXSA9IDIgKiBlIC8gKHggLSBwKTtcclxuICAgICAgICAgICAgICAgICAgICBsLmVsZW1lbnRzWzhdID0gKHggKyBwKSAvICh4IC0gcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFMLnByb2plY3Rpb25NYXRyaXguY29weShsKTtcclxuICAgICAgICAgICAgICAgICAgICBwID0gLXEgKiBkIC0gbjtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gcSAqIGQgLSBuO1xyXG4gICAgICAgICAgICAgICAgICAgIGwuZWxlbWVudHNbMF0gPSAyICogZSAvICh4IC0gcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbC5lbGVtZW50c1s4XSA9ICh4ICsgcCkgLyAoeCAtIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkobClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhTC5tYXRyaXhXb3JsZC5jb3B5KGsubWF0cml4V29ybGQpLm11bHRpcGx5KG0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFSLm1hdHJpeFdvcmxkLmNvcHkoay5tYXRyaXhXb3JsZCkubXVsdGlwbHkoaClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKVxyXG4gICAgfSk7XHJcbiAgICBJZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHgucHJvdG90eXBlKTtcclxuICAgIElkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElkO1xyXG4gICAgaWUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHgucHJvdG90eXBlKSwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBpZSwgZ2V0SW5wdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2FpblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlRmlsdGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG51bGwgIT09IHRoaXMuZmlsdGVyICYmICh0aGlzLmdhaW4uZGlzY29ubmVjdCh0aGlzLmZpbHRlciksIHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKSwgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKSwgdGhpcy5maWx0ZXIgPSBudWxsKVxyXG4gICAgICAgIH0sIGdldEZpbHRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJcclxuICAgICAgICB9LCBzZXRGaWx0ZXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIG51bGwgIT09IHRoaXMuZmlsdGVyID8gKHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuZmlsdGVyKSwgdGhpcy5maWx0ZXIuZGlzY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pKSA6IHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gYTtcclxuICAgICAgICAgICAgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5maWx0ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlci5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbilcclxuICAgICAgICB9LCBnZXRNYXN0ZXJWb2x1bWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRNYXN0ZXJWb2x1bWU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gYVxyXG4gICAgICAgIH0sIHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbmV3IHEsIGIgPSBuZXcgY2EsIGMgPSBuZXcgcSwgZCA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHgucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLnVwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoYSwgYiwgYyk7XHJcbiAgICAgICAgICAgICAgICBkLnNldCgwLCAwLCAtMSkuYXBwbHlRdWF0ZXJuaW9uKGIpO1xyXG4gICAgICAgICAgICAgICAgZS5wb3NpdGlvblggPyAoZS5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUoYS54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUpLCBlLnBvc2l0aW9uWS5zZXRWYWx1ZUF0VGltZShhLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSksIGUucG9zaXRpb25aLnNldFZhbHVlQXRUaW1lKGEueiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lKSwgZS5mb3J3YXJkWC5zZXRWYWx1ZUF0VGltZShkLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSksXHJcbiAgICAgICAgICAgICAgICAgICAgZS5mb3J3YXJkWS5zZXRWYWx1ZUF0VGltZShkLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSksIGUuZm9yd2FyZFouc2V0VmFsdWVBdFRpbWUoZC56LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUpLCBlLnVwWC5zZXRWYWx1ZUF0VGltZShmLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSksIGUudXBZLnNldFZhbHVlQXRUaW1lKGYueSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lKSwgZS51cFouc2V0VmFsdWVBdFRpbWUoZi56LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUpKSA6IChlLnNldFBvc2l0aW9uKGEueCwgYS55LCBhLnopLCBlLnNldE9yaWVudGF0aW9uKGQueCwgZC55LCBkLnosIGYueCwgZi55LCBmLnopKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpXHJcbiAgICB9KTtcclxuICAgIGhjLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogaGMsIGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nYWluXHJcbiAgICAgICAgfSwgc2V0Tm9kZVNvdXJjZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPVxyXG4gICAgICAgICAgICAgICAgITE7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlVHlwZSA9IFwiYXVkaW9Ob2RlXCI7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gYTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgc2V0QnVmZmVyOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlVHlwZSA9IFwiYnVmZmVyXCI7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0b3BsYXkgJiYgdGhpcy5wbGF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcGxheTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoITAgPT09IHRoaXMuaXNQbGF5aW5nKSBjb25zb2xlLndhcm4oXCJUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLlwiKTsgZWxzZSBpZiAoITEgPT09IHRoaXMuaGFzUGxheWJhY2tDb250cm9sKSBjb25zb2xlLndhcm4oXCJUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC5cIik7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgICAgICBhLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgYS5sb29wID0gdGhpcy5sb29wO1xyXG4gICAgICAgICAgICAgICAgYS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBhLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZSh0aGlzLnBsYXliYWNrUmF0ZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICBhLnN0YXJ0KDAsIHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gITA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZSA9IGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHBhdXNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghMSA9PT0gdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wpIGNvbnNvbGUud2FybihcIlRIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLlwiKTsgZWxzZSByZXR1cm4gdGhpcy5zb3VyY2Uuc3RvcCgpLCB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgdGhpcy5pc1BsYXlpbmcgPSAhMSwgdGhpc1xyXG4gICAgICAgIH0sIHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCExID09PSB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCkgY29uc29sZS53YXJuKFwiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuXCIpOyBlbHNlIHJldHVybiB0aGlzLnNvdXJjZS5zdG9wKCksIHRoaXMuc3RhcnRUaW1lID0gMCwgdGhpcy5pc1BsYXlpbmcgPSAhMSwgdGhpc1xyXG4gICAgICAgIH0sIGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKDAgPFxyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLmZpbHRlcnNbMF0pO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDEsIGIgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBhIDwgYjsgYSsrKXRoaXMuZmlsdGVyc1thIC0gMV0uY29ubmVjdCh0aGlzLmZpbHRlcnNbYV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzW3RoaXMuZmlsdGVycy5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpXHJcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKDAgPCB0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMSwgYiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGEgPCBiOyBhKyspdGhpcy5maWx0ZXJzW2EgLSAxXS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1thXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDFdLmRpc2Nvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSlcclxuICAgICAgICAgICAgfSBlbHNlIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZ2V0RmlsdGVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzXHJcbiAgICAgICAgfSwgc2V0RmlsdGVyczogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSB8fCAoYSA9IFtdKTtcclxuICAgICAgICAgICAgITAgPT09IHRoaXMuaXNQbGF5aW5nID8gKHRoaXMuZGlzY29ubmVjdCgpLCB0aGlzLmZpbHRlcnMgPSBhLCB0aGlzLmNvbm5lY3QoKSkgOiB0aGlzLmZpbHRlcnMgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldEZpbHRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbMF1cclxuICAgICAgICB9LCBzZXRGaWx0ZXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEZpbHRlcnMoYSA/IFthXSA6IFtdKVxyXG4gICAgICAgIH0sIHNldFBsYXliYWNrUmF0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKCExID09PSB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCkgY29uc29sZS53YXJuKFwiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuXCIpOyBlbHNlIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZSA9IGEsICEwID09PSB0aGlzLmlzUGxheWluZyAmJiB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUodGhpcy5wbGF5YmFja1JhdGUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUpLCB0aGlzXHJcbiAgICAgICAgfSwgZ2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZVxyXG4gICAgICAgIH0sIG9uRW5kZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSAhMVxyXG4gICAgICAgIH0sIGdldExvb3A6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICExID09PSB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA/IChjb25zb2xlLndhcm4oXCJUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC5cIiksICExKSA6IHRoaXMubG9vcFxyXG4gICAgICAgIH0sIHNldExvb3A6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmICghMSA9PT0gdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wpIGNvbnNvbGUud2FybihcIlRIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLlwiKTsgZWxzZSByZXR1cm4gdGhpcy5sb29wID0gYSwgITAgPT09IHRoaXMuaXNQbGF5aW5nICYmICh0aGlzLnNvdXJjZS5sb29wID0gdGhpcy5sb29wKSwgdGhpc1xyXG4gICAgICAgIH0sIGdldFZvbHVtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFZvbHVtZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAga2UucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGhjLnByb3RvdHlwZSksIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcjoga2UsIGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5uZXJcclxuICAgICAgICB9LCBnZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2VcclxuICAgICAgICB9LCBzZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSBhXHJcbiAgICAgICAgfSwgZ2V0Um9sbG9mZkZhY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvclxyXG4gICAgICAgIH0sIHNldFJvbGxvZmZGYWN0b3I6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSBhXHJcbiAgICAgICAgfSwgZ2V0RGlzdGFuY2VNb2RlbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbFxyXG4gICAgICAgIH0sIHNldERpc3RhbmNlTW9kZWw6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWwgPVxyXG4gICAgICAgICAgICAgICAgYVxyXG4gICAgICAgIH0sIGdldE1heERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhbm5lci5tYXhEaXN0YW5jZVxyXG4gICAgICAgIH0sIHNldE1heERpc3RhbmNlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IGFcclxuICAgICAgICB9LCB1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgICAgIHgucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwodGhpcywgYik7XHJcbiAgICAgICAgICAgICAgICBhLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFubmVyLnNldFBvc2l0aW9uKGEueCwgYS55LCBhLnopXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KClcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihsZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBnZXRGcmVxdWVuY3lEYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVxyXG4gICAgICAgIH0sIGdldEF2ZXJhZ2VGcmVxdWVuY3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDAsIGIgPSB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKSwgYyA9IDA7IGMgPCBiLmxlbmd0aDsgYysrKWEgKz1cclxuICAgICAgICAgICAgICAgIGJbY107XHJcbiAgICAgICAgICAgIHJldHVybiBhIC8gYi5sZW5ndGhcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIEpkLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogSmQsIGFjY3VtdWxhdGU6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnZhbHVlU2l6ZSwgZSA9IGEgKiBkICsgZCwgZiA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcclxuICAgICAgICAgICAgaWYgKDAgPT09IGYpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoZiA9IDA7IGYgIT09IGQ7ICsrZiljW2UgKyBmXSA9IGNbZl07XHJcbiAgICAgICAgICAgICAgICBmID0gYlxyXG4gICAgICAgICAgICB9IGVsc2UgZiArPSBiLCB0aGlzLl9taXhCdWZmZXJSZWdpb24oYywgZSwgMCwgYiAvIGYsIGQpO1xyXG4gICAgICAgICAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBmXHJcbiAgICAgICAgfSwgYXBwbHk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy52YWx1ZVNpemUsIGMgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICAgICAgYSA9IGEgKiBiICsgYjtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQsIGUgPSB0aGlzLmJpbmRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIDEgPiBkICYmIHRoaXMuX21peEJ1ZmZlclJlZ2lvbihjLCBhLCAzICogYiwgMSAtIGQsIGIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBkID0gYiwgZiA9IGIgKyBiOyBkICE9PSBmOyArK2QpaWYgKGNbZF0gIT09IGNbZCArIGJdKSB7XHJcbiAgICAgICAgICAgICAgICBlLnNldFZhbHVlKGMsIGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2F2ZU9yaWdpbmFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmJ1ZmZlciwgYiA9IHRoaXMudmFsdWVTaXplLCBjID0gMyAqIGI7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZGluZy5nZXRWYWx1ZShhLCBjKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IGI7IGQgIT09IGM7ICsrZClhW2RdID0gYVtjICsgZCAlIGJdO1xyXG4gICAgICAgICAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwXHJcbiAgICAgICAgfSwgcmVzdG9yZU9yaWdpbmFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kaW5nLnNldFZhbHVlKHRoaXMuYnVmZmVyLCAzICogdGhpcy52YWx1ZVNpemUpXHJcbiAgICAgICAgfSwgX3NlbGVjdDogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUpIHtcclxuICAgICAgICAgICAgaWYgKC41IDw9IGQpZm9yIChkID0gMDsgZCAhPT0gZTsgKytkKWFbYiArIGRdID0gYVtjICsgZF1cclxuICAgICAgICB9LCBfc2xlcnA6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIGNhLnNsZXJwRmxhdChhLCBiLCBhLCBiLCBhLCBjLCBkKVxyXG4gICAgICAgIH0sIF9sZXJwOiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBmID0gMSAtIGQsIGcgPSAwOyBnICE9PSBlOyArK2cpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoID0gYiArIGc7XHJcbiAgICAgICAgICAgICAgICBhW2hdID0gYVtoXSAqIGYgKyBhW2MgKyBnXSAqIGRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBrYS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGthLCBnZXRWYWx1ZTogZnVuY3Rpb24gKGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoYSwgYilcclxuICAgICAgICB9LCBzZXRWYWx1ZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoYSwgYilcclxuICAgICAgICB9LCBiaW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5ub2RlLCBiID0gdGhpcy5wYXJzZWRQYXRoLCBjID0gYi5vYmplY3ROYW1lLCBkID0gYi5wcm9wZXJ0eU5hbWUsIGUgPSBiLnByb3BlcnR5SW5kZXg7XHJcbiAgICAgICAgICAgIGEgfHwgKHRoaXMubm9kZSA9IGEgPSBrYS5maW5kTm9kZSh0aGlzLnJvb3ROb2RlLCBiLm5vZGVOYW1lKSB8fCB0aGlzLnJvb3ROb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5hdmFpbGFibGU7XHJcbiAgICAgICAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gYi5vYmplY3RJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hdGVyaWFsc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhLm1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsXCIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhLm1hdGVyaWFsLm1hdGVyaWFscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIgIGNhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGEubWF0ZXJpYWwubWF0ZXJpYWxzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib25lc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhLnNrZWxldG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiAgY2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uXCIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGEuc2tlbGV0b24uYm9uZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGMgPSAwOyBjIDwgYS5sZW5ndGg7IGMrKylpZiAoYVtjXS5uYW1lID09PSBmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYVtjXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIgIGNhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUsIHVuZGVmaW5lZFwiLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhW2NdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYVtmXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiAgdHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZDpcIiwgdGhpcywgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYVtmXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGYgPSBhW2RdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZikgY29uc29sZS5lcnJvcihcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6IFwiICtcclxuICAgICAgICAgICAgICAgICAgICBiLm5vZGVOYW1lICsgXCIuXCIgKyBkICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIiwgYSk7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLlZlcnNpb25pbmcuTm9uZTtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGEubmVlZHNVcGRhdGUgPyAoYiA9IHRoaXMuVmVyc2lvbmluZy5OZWVkc1VwZGF0ZSwgdGhpcy50YXJnZXRPYmplY3QgPSBhKSA6IHZvaWQgMCAhPT0gYS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICYmIChiID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGUsIHRoaXMudGFyZ2V0T2JqZWN0ID0gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuQmluZGluZ1R5cGUuRGlyZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIgPT09IGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYS5nZW9tZXRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIgIGNhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXN1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnlcIiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEuZ2VvbWV0cnkubW9ycGhUYXJnZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaFRhcmdldHNcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGMgPSAwOyBjIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGMrKylpZiAoYS5nZW9tZXRyeS5tb3JwaFRhcmdldHNbY10ubmFtZSA9PT0gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuQmluZGluZ1R5cGUuQXJyYXlFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5SW5kZXggPSBlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHZvaWQgMCAhPT0gZi5mcm9tQXJyYXkgJiYgdm9pZCAwICE9PSBmLnRvQXJyYXkgPyAoYyA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXksIHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IGYpIDogdm9pZCAwICE9PSBmLmxlbmd0aCA/IChjID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheSwgdGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gZikgOiB0aGlzLnByb3BlcnR5TmFtZSA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuR2V0dGVyQnlCaW5kaW5nVHlwZVtjXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1tjXVtiXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgY29uc29sZS5lcnJvcihcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogXCIgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIilcclxuICAgICAgICB9LCB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmJvdW5kXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oa2EucHJvdG90eXBlLCB7XHJcbiAgICAgICAgX2dldFZhbHVlX3VuYXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRWYWx1ZV91bmJvdW5kOiBrYS5wcm90b3R5cGUuZ2V0VmFsdWUsXHJcbiAgICAgICAgX3NldFZhbHVlX3VuYm91bmQ6IGthLnByb3RvdHlwZS5zZXRWYWx1ZSxcclxuICAgICAgICBCaW5kaW5nVHlwZToge0RpcmVjdDogMCwgRW50aXJlQXJyYXk6IDEsIEFycmF5RWxlbWVudDogMiwgSGFzRnJvbVRvQXJyYXk6IDN9LFxyXG4gICAgICAgIFZlcnNpb25pbmc6IHtOb25lOiAwLCBOZWVkc1VwZGF0ZTogMSwgTWF0cml4V29ybGROZWVkc1VwZGF0ZTogMn0sXHJcbiAgICAgICAgR2V0dGVyQnlCaW5kaW5nVHlwZTogW2Z1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGFbYl0gPSB0aGlzLm5vZGVbdGhpcy5wcm9wZXJ0eU5hbWVdXHJcbiAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSB0aGlzLnJlc29sdmVkUHJvcGVydHksIGQgPSAwLCBlID0gYy5sZW5ndGg7IGQgIT09IGU7ICsrZClhW2IrK10gPSBjW2RdXHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBhW2JdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF1cclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS50b0FycmF5KGEsIGIpXHJcbiAgICAgICAgICAgIH1dLFxyXG4gICAgICAgIFNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nOiBbW2Z1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZVt0aGlzLnByb3BlcnR5TmFtZV0gPSBhW2JdXHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlW3RoaXMucHJvcGVydHlOYW1lXSA9IGFbYl07XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gITBcclxuICAgICAgICB9LCBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVbdGhpcy5wcm9wZXJ0eU5hbWVdID0gYVtiXTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9ICEwXHJcbiAgICAgICAgfV0sIFtmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICBkID0gMCwgZSA9IGMubGVuZ3RoOyBkICE9PSBlOyArK2QpY1tkXSA9IGFbYisrXVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSB0aGlzLnJlc29sdmVkUHJvcGVydHksIGQgPSAwLCBlID0gYy5sZW5ndGg7IGQgIT09IGU7ICsrZCljW2RdID0gYVtiKytdO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9ICEwXHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSwgZCA9IDAsIGUgPSBjLmxlbmd0aDsgZCAhPT0gZTsgKytkKWNbZF0gPSBhW2IrK107XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSAhMFxyXG4gICAgICAgIH1dLCBbZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF0gPSBhW2JdXHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF0gPSBhW2JdO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9ICEwXHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF0gPSBhW2JdO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gITBcclxuICAgICAgICB9XSwgW2Z1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoYSwgYilcclxuICAgICAgICB9LCBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KGEsIGIpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9ICEwXHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheShhLCBiKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9ICEwXHJcbiAgICAgICAgfV1dXHJcbiAgICB9KTtcclxuICAgIGthLkNvbXBvc2l0ZSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgYyA9IGMgfHwga2EucGFyc2VUcmFja05hbWUoYik7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0R3JvdXAgPSBhO1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzID0gYS5zdWJzY3JpYmVfKGIsIGMpXHJcbiAgICB9O1xyXG4gICAga2EuQ29tcG9zaXRlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcjoga2EuQ29tcG9zaXRlLCBnZXRWYWx1ZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fYmluZGluZ3NbdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfXTtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBjICYmIGMuZ2V0VmFsdWUoYSwgYilcclxuICAgICAgICB9LCBzZXRWYWx1ZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IHRoaXMuX2JpbmRpbmdzLCBkID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxyXG4gICAgICAgICAgICAgICAgICAgICBlID0gYy5sZW5ndGg7IGQgIT09IGU7ICsrZCljW2RdLnNldFZhbHVlKGEsIGIpXHJcbiAgICAgICAgfSwgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gdGhpcy5fYmluZGluZ3MsIGIgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIGMgPSBhLmxlbmd0aDsgYiAhPT0gYzsgKytiKWFbYl0uYmluZCgpXHJcbiAgICAgICAgfSwgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSB0aGlzLl9iaW5kaW5ncywgYiA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgYyA9IGEubGVuZ3RoOyBiICE9PSBjOyArK2IpYVtiXS51bmJpbmQoKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBrYS5jcmVhdGUgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgIHJldHVybiBhICYmIGEuaXNBbmltYXRpb25PYmplY3RHcm91cCA/IG5ldyBrYS5Db21wb3NpdGUoYSwgYiwgYykgOiBuZXcga2EoYSwgYiwgYylcclxuICAgIH07XHJcbiAgICBrYS5wYXJzZVRyYWNrTmFtZSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdmFyIGIgPVxyXG4gICAgICAgICAgICAvXigoPzpbXFx3LV0rW1xcLzpdKSopKFtcXHctXSspPyg/OlxcLihbXFx3LV0rKSg/OlxcWyguKylcXF0pPyk/XFwuKFtcXHctXSspKD86XFxbKC4rKVxcXSk/JC8uZXhlYyhhKTtcclxuICAgICAgICBpZiAoIWIpdGhyb3cgRXJyb3IoXCJjYW5ub3QgcGFyc2UgdHJhY2tOYW1lIGF0IGFsbDogXCIgKyBhKTtcclxuICAgICAgICBiID0ge25vZGVOYW1lOiBiWzJdLCBvYmplY3ROYW1lOiBiWzNdLCBvYmplY3RJbmRleDogYls0XSwgcHJvcGVydHlOYW1lOiBiWzVdLCBwcm9wZXJ0eUluZGV4OiBiWzZdfTtcclxuICAgICAgICBpZiAobnVsbCA9PT0gYi5wcm9wZXJ0eU5hbWUgfHwgMCA9PT0gYi5wcm9wZXJ0eU5hbWUubGVuZ3RoKXRocm93IEVycm9yKFwiY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6IFwiICsgYSk7XHJcbiAgICAgICAgcmV0dXJuIGJcclxuICAgIH07XHJcbiAgICBrYS5maW5kTm9kZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKCFiIHx8IFwiXCIgPT09IGIgfHwgXCJyb290XCIgPT09IGIgfHwgXCIuXCIgPT09IGIgfHwgLTEgPT09IGIgfHwgYiA9PT0gYS5uYW1lIHx8IGIgPT09IGEudXVpZClyZXR1cm4gYTtcclxuICAgICAgICBpZiAoYS5za2VsZXRvbikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID1cclxuICAgICAgICAgICAgICAgICAgICAwOyBjIDwgYS5ib25lcy5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gYS5ib25lc1tjXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZC5uYW1lID09PSBiKXJldHVybiBkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICB9KGEuc2tlbGV0b24pO1xyXG4gICAgICAgICAgICBpZiAoYylyZXR1cm4gY1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB2YXIgZCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGEubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGFbY107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGcubmFtZSA9PT0gYiB8fCBnLnV1aWQgPT09IGIgfHwgKGcgPSBkKGcuY2hpbGRyZW4pKSlyZXR1cm4gZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGMgPSBkKGEuY2hpbGRyZW4pKXJldHVybiBjXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9O1xyXG4gICAgbWUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBtZSwgaXNBbmltYXRpb25PYmplY3RHcm91cDogITAsIGFkZDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMuX29iamVjdHMsIGMgPSBiLmxlbmd0aCwgZCA9IHRoaXMubkNhY2hlZE9iamVjdHNfLCBlID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcclxuICAgICAgICAgICAgICAgICAgICAgZiA9IHRoaXMuX3BhdGhzLCBnID0gdGhpcy5fcGFyc2VkUGF0aHMsIGggPSB0aGlzLl9iaW5kaW5ncywgbSA9IGgubGVuZ3RoLCBrID0gMCwgbCA9XHJcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aDsgayAhPT0gbDsgKytrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGFyZ3VtZW50c1trXSwgbiA9IHAudXVpZCwgcSA9IGVbbl07XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IGMrKztcclxuICAgICAgICAgICAgICAgICAgICBlW25dID0gcTtcclxuICAgICAgICAgICAgICAgICAgICBiLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDAsIHggPSBtOyBuICE9PSB4OyArK24paFtuXS5wdXNoKG5ldyBrYShwLCBmW25dLCBnW25dKSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocSA8IGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IC0tZCwgeCA9IGJbcl07XHJcbiAgICAgICAgICAgICAgICAgICAgZVt4LnV1aWRdID0gcTtcclxuICAgICAgICAgICAgICAgICAgICBiW3FdID0geDtcclxuICAgICAgICAgICAgICAgICAgICBlW25dID0gcjtcclxuICAgICAgICAgICAgICAgICAgICBiW3JdID0gcDtcclxuICAgICAgICAgICAgICAgICAgICBuID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHggPSBtOyBuICE9PSB4OyArK24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHogPSBoW25dLCB3ID0geltxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeltxXSA9IHpbcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdyAmJiAodyA9IG5ldyBrYShwLCBmW25dLCBnW25dKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpbcl0gPSB3XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHZvaWQgMCAhPT0gYltxXSAmJiBjb25zb2xlLmVycm9yKFwiRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEIGRldGVjdGVkLiBDbGVhbiB0aGUgY2FjaGVzIG9yIHJlY3JlYXRlIHlvdXIgaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLi4uXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBkXHJcbiAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RzLCBjID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sIGQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELCBlID0gdGhpcy5fYmluZGluZ3MsIGYgPSBlLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgZyA9IDAsIGggPSBhcmd1bWVudHMubGVuZ3RoOyBnICE9PSBoOyArK2cpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gYXJndW1lbnRzW2ddLCBrID0gbS51dWlkLCBsID0gZFtrXTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGwgJiYgbCA+PSBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBjKyssIG4gPSBiW3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRbbi51dWlkXSA9IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYltsXSA9IG47XHJcbiAgICAgICAgICAgICAgICAgICAgZFtrXSA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgYltwXSA9IG07XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gZjsgbSAhPT0gazsgKyttKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZVttXSwgcSA9IG5bbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5bbF0gPSBuW3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuW3BdID0gcVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm5DYWNoZWRPYmplY3RzXyA9IGNcclxuICAgICAgICB9LCB1bmNhY2hlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5fb2JqZWN0cywgYyA9IGIubGVuZ3RoLCBkID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sIGUgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxyXG4gICAgICAgICAgICAgICAgICAgICBmID0gdGhpcy5fYmluZGluZ3MsIGcgPSBmLmxlbmd0aCwgaCA9IDAsIG0gPSBhcmd1bWVudHMubGVuZ3RoOyBoICE9PSBtOyArK2gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gYXJndW1lbnRzW2hdLnV1aWQsIGwgPSBlW2tdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gbClpZiAoZGVsZXRlIGVba10sIGwgPCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSAtLWQsIHAgPSBiW2tdLCBuID0gLS1jLCBxID0gYltuXTtcclxuICAgICAgICAgICAgICAgICAgICBlW3AudXVpZF0gPSBsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJbbF0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGVbcS51dWlkXSA9IGs7XHJcbiAgICAgICAgICAgICAgICAgICAgYltrXSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBwID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSBnOyBwICE9PSBxOyArK3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBmW3BdLCByID0geFtuXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeFtsXSA9IHhba107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhba10gPSByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LnBvcCgpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGZvciAobiA9IC0tYywgcSA9IGJbbl0sIGVbcS51dWlkXSA9IGwsIGJbbF0gPSBxLCBiLnBvcCgpLCBwID0gMCwgcSA9IGc7IHAgIT09IHE7ICsrcCl4ID0gZltwXSwgeFtsXSA9IHhbbl0sIHgucG9wKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm5DYWNoZWRPYmplY3RzXyA9IGRcclxuICAgICAgICB9LCBzdWJzY3JpYmVfOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCwgZCA9IGNbYV0sIGUgPSB0aGlzLl9iaW5kaW5ncztcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZClyZXR1cm4gZVtkXTtcclxuICAgICAgICAgICAgdmFyIGYgPSB0aGlzLl9wYXRocywgZyA9IHRoaXMuX3BhcnNlZFBhdGhzLCBoID0gdGhpcy5fb2JqZWN0cywgbCA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxyXG4gICAgICAgICAgICAgICAgayA9IEFycmF5KGgubGVuZ3RoKSwgZCA9IGUubGVuZ3RoO1xyXG4gICAgICAgICAgICBjW2FdID0gZDtcclxuICAgICAgICAgICAgZi5wdXNoKGEpO1xyXG4gICAgICAgICAgICBnLnB1c2goYik7XHJcbiAgICAgICAgICAgIGUucHVzaChrKTtcclxuICAgICAgICAgICAgYyA9IGw7XHJcbiAgICAgICAgICAgIGZvciAoZCA9IGgubGVuZ3RoOyBjICE9PSBkOyArK2Mpa1tjXSA9IG5ldyBrYShoW2NdLCBhLCBiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGtcclxuICAgICAgICB9LCB1bnN1YnNjcmliZV86IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLCBjID0gYlthXTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLl9wYXRocywgZSA9IHRoaXMuX3BhcnNlZFBhdGhzLCBmID0gdGhpcy5fYmluZGluZ3MsIGcgPSBmLmxlbmd0aCAtIDEsIGggPSBmW2ddO1xyXG4gICAgICAgICAgICAgICAgYlthW2ddXSA9IGM7XHJcbiAgICAgICAgICAgICAgICBmW2NdID0gaDtcclxuICAgICAgICAgICAgICAgIGYucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBlW2NdID0gZVtnXTtcclxuICAgICAgICAgICAgICAgIGUucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBkW2NdID0gZFtnXTtcclxuICAgICAgICAgICAgICAgIGQucG9wKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBuZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IG5lLCBwbGF5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21peGVyLl9hY3RpdmF0ZUFjdGlvbih0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21peGVyLl9kZWFjdGl2YXRlQWN0aW9uKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpXHJcbiAgICAgICAgfSwgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPVxyXG4gICAgICAgICAgICAgICAgITE7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9ICEwO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wQ291bnQgPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKClcclxuICAgICAgICB9LCBpc1J1bm5pbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZCAmJiAhdGhpcy5wYXVzZWQgJiYgMCAhPT0gdGhpcy50aW1lU2NhbGUgJiYgbnVsbCA9PT0gdGhpcy5fc3RhcnRUaW1lICYmIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbih0aGlzKVxyXG4gICAgICAgIH0sIGlzU2NoZWR1bGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24odGhpcylcclxuICAgICAgICB9LCBzdGFydEF0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldExvb3A6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMucmVwZXRpdGlvbnMgPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy53ZWlnaHQgPSBhO1xyXG4gICAgICAgICAgICB0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLmVuYWJsZWQgP1xyXG4gICAgICAgICAgICAgICAgYSA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKVxyXG4gICAgICAgIH0sIGdldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWZmZWN0aXZlV2VpZ2h0XHJcbiAgICAgICAgfSwgZmFkZUluOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoYSwgMCwgMSlcclxuICAgICAgICB9LCBmYWRlT3V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoYSwgMSwgMClcclxuICAgICAgICB9LCBjcm9zc0ZhZGVGcm9tOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBhLmZhZGVPdXQoYik7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZUluKGIpO1xyXG4gICAgICAgICAgICBpZiAoYykge1xyXG4gICAgICAgICAgICAgICAgYyA9IHRoaXMuX2NsaXAuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGEuX2NsaXAuZHVyYXRpb24sIGUgPSBjIC8gZDtcclxuICAgICAgICAgICAgICAgIGEud2FycCgxLCBkIC8gYywgYik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhcnAoZSwgMSwgYilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNyb3NzRmFkZVRvOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5jcm9zc0ZhZGVGcm9tKHRoaXMsIGIsIGMpXHJcbiAgICAgICAgfSwgc3RvcEZhZGluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xyXG4gICAgICAgICAgICBudWxsICE9PSBhICYmICh0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9XHJcbiAgICAgICAgICAgICAgICBudWxsLCB0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoYSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lU2NhbGUgPSBhO1xyXG4gICAgICAgICAgICB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOiBhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9wV2FycGluZygpXHJcbiAgICAgICAgfSwgZ2V0RWZmZWN0aXZlVGltZVNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGVcclxuICAgICAgICB9LCBzZXREdXJhdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lU2NhbGUgPSB0aGlzLl9jbGlwLmR1cmF0aW9uIC8gYTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKVxyXG4gICAgICAgIH0sIHN5bmNXaXRoOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWUgPSBhLnRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMudGltZVNjYWxlID0gYS50aW1lU2NhbGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKClcclxuICAgICAgICB9LCBoYWx0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YXJwKHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSwgMCwgYSlcclxuICAgICAgICB9LCB3YXJwOiBmdW5jdGlvbiAoYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuX21peGVyLCBlID0gZC50aW1lLCBmID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQsIGcgPSB0aGlzLnRpbWVTY2FsZTtcclxuICAgICAgICAgICAgbnVsbCA9PT0gZiAmJiAodGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBmID0gZC5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpKTtcclxuICAgICAgICAgICAgZCA9IGYucGFyYW1ldGVyUG9zaXRpb25zO1xyXG4gICAgICAgICAgICBmID0gZi5zYW1wbGVWYWx1ZXM7XHJcbiAgICAgICAgICAgIGRbMF0gPSBlO1xyXG4gICAgICAgICAgICBkWzFdID0gZSArIGM7XHJcbiAgICAgICAgICAgIGZbMF0gPSBhIC8gZztcclxuICAgICAgICAgICAgZlsxXSA9IGIgLyBnO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHN0b3BXYXJwaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XHJcbiAgICAgICAgICAgIG51bGwgIT09IGEgJiYgKHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbCwgdGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBnZXRNaXhlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWl4ZXJcclxuICAgICAgICB9LCBnZXRDbGlwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwXHJcbiAgICAgICAgfSwgZ2V0Um9vdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxSb290IHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9taXhlci5fcm9vdFxyXG4gICAgICAgIH0sIF91cGRhdGU6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5fc3RhcnRUaW1lO1xyXG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IChhIC0gZSkgKiBjO1xyXG4gICAgICAgICAgICAgICAgaWYgKDAgPiBiIHx8IDAgPT09IGMpcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGIgKj0gY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKGEpO1xyXG4gICAgICAgICAgICBjID0gdGhpcy5fdXBkYXRlVGltZShiKTtcclxuICAgICAgICAgICAgYSA9IHRoaXMuX3VwZGF0ZVdlaWdodChhKTtcclxuICAgICAgICAgICAgaWYgKDAgPCBhKSB7XHJcbiAgICAgICAgICAgICAgICBiID0gdGhpcy5faW50ZXJwb2xhbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMuX3Byb3BlcnR5QmluZGluZ3MsIGYgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGIubGVuZ3RoOyBmICE9PSBnOyArK2YpYltmXS5ldmFsdWF0ZShjKSwgZVtmXS5hY2N1bXVsYXRlKGQsIGEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBfdXBkYXRlV2VpZ2h0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy53ZWlnaHQsIGMgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBjLmV2YWx1YXRlKGEpWzBdLCBiID0gYiAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA+IGMucGFyYW1ldGVyUG9zaXRpb25zWzFdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3RvcEZhZGluZygpLCAwID09PSBkICYmICh0aGlzLmVuYWJsZWQgPSAhMSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IGJcclxuICAgICAgICB9LCBfdXBkYXRlVGltZVNjYWxlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy50aW1lU2NhbGUsIGMgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBjLmV2YWx1YXRlKGEpWzBdLCBiID0gYiAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA+IGMucGFyYW1ldGVyUG9zaXRpb25zWzFdICYmICh0aGlzLnN0b3BXYXJwaW5nKCksIDAgPT09IGIgPyB0aGlzLnBhdXNlZCA9ICEwIDogdGhpcy50aW1lU2NhbGUgPSBiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSBiXHJcbiAgICAgICAgfSwgX3VwZGF0ZVRpbWU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy50aW1lICsgYTtcclxuICAgICAgICAgICAgaWYgKDAgPT09IGEpcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fY2xpcC5kdXJhdGlvbiwgZCA9IHRoaXMubG9vcCwgZSA9IHRoaXMuX2xvb3BDb3VudDtcclxuICAgICAgICAgICAgaWYgKDIyMDAgPT09IGQpYTp7XHJcbiAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGUgJiYgKHRoaXMuX2xvb3BDb3VudCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIHRoaXMuX3NldEVuZGluZ3MoITAsICEwLCAhMSkpLCBiID49IGMpIGIgPSBjOyBlbHNlIGlmICgwID4gYikgYiA9IDA7IGVsc2UgYnJlYWsgYTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgPyB0aGlzLnBhdXNlZCA9ICEwIDogdGhpcy5lbmFibGVkID0gITE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KHt0eXBlOiBcImZpbmlzaGVkXCIsIGFjdGlvbjogdGhpcywgZGlyZWN0aW9uOiAwID4gYSA/IC0xIDogMX0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkID0gMjIwMiA9PT0gZDtcclxuICAgICAgICAgICAgICAgIC0xID09PSBlICYmICgwIDw9IGEgPyAoZSA9IDAsIHRoaXMuX3NldEVuZGluZ3MoITAsIDAgPT09IHRoaXMucmVwZXRpdGlvbnMsIGQpKSA6IHRoaXMuX3NldEVuZGluZ3MoMCA9PT0gdGhpcy5yZXBldGl0aW9ucywgITAsIGQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChiID49IGMgfHwgMCA+IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IE1hdGguZmxvb3IoYiAvIGMpLCBiID0gYiAtIGMgKiBmLCBlID0gZSArIE1hdGguYWJzKGYpLCBnID0gdGhpcy5yZXBldGl0aW9ucyAtIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgMCA+IGcgPyAodGhpcy5jbGFtcFdoZW5GaW5pc2hlZCA/IHRoaXMucGF1c2VkID0gITAgOiB0aGlzLmVuYWJsZWQgPSAhMSwgYiA9IDAgPCBhID8gYyA6IDAsIHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaGVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcywgZGlyZWN0aW9uOiAwIDwgYSA/IDEgOiAtMVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSA6ICgwID09PSBnID8gKGEgPSAwID4gYSwgdGhpcy5fc2V0RW5kaW5ncyhhLCAhYSwgZCkpIDogdGhpcy5fc2V0RW5kaW5ncyghMSwgITEsIGQpLCB0aGlzLl9sb29wQ291bnQgPSBlLCB0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsb29wXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcERlbHRhOiBmXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZCAmJiAxID09PSAoZSAmIDEpKXJldHVybiB0aGlzLnRpbWUgPSBiLCBjIC0gYlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWUgPSBiXHJcbiAgICAgICAgfSwgX3NldEVuZGluZ3M6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncztcclxuICAgICAgICAgICAgYyA/IChkLmVuZGluZ1N0YXJ0ID0gMjQwMSwgZC5lbmRpbmdFbmQgPSAyNDAxKSA6IChkLmVuZGluZ1N0YXJ0ID0gYSA/IHRoaXMuemVyb1Nsb3BlQXRTdGFydCA/IDI0MDEgOiAyNDAwIDogMjQwMiwgZC5lbmRpbmdFbmQgPSBiID8gdGhpcy56ZXJvU2xvcGVBdEVuZCA/IDI0MDEgOiAyNDAwIDogMjQwMilcclxuICAgICAgICB9LCBfc2NoZWR1bGVGYWRpbmc6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5fbWl4ZXIsIGUgPSBkLnRpbWUsXHJcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XHJcbiAgICAgICAgICAgIG51bGwgPT09IGYgJiYgKHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gZiA9IGQuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSk7XHJcbiAgICAgICAgICAgIGQgPSBmLnBhcmFtZXRlclBvc2l0aW9ucztcclxuICAgICAgICAgICAgZiA9IGYuc2FtcGxlVmFsdWVzO1xyXG4gICAgICAgICAgICBkWzBdID0gZTtcclxuICAgICAgICAgICAgZlswXSA9IGI7XHJcbiAgICAgICAgICAgIGRbMV0gPSBlICsgYTtcclxuICAgICAgICAgICAgZlsxXSA9IGM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNkLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogY2QsIGNsaXBBY3Rpb246IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYiB8fCB0aGlzLl9yb290LCBkID0gYy51dWlkLCBlID0gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGEgPyBxYS5maW5kQnlOYW1lKGMsIGEpIDogYSxcclxuICAgICAgICAgICAgICAgIGMgPSBudWxsICE9PSBlID8gZS51dWlkIDogYSwgZiA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbY10sIGcgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBmKSB7XHJcbiAgICAgICAgICAgICAgICBnID0gZi5hY3Rpb25CeVJvb3RbZF07XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBnKXJldHVybiBnO1xyXG4gICAgICAgICAgICAgICAgZyA9IGYua25vd25BY3Rpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gZSAmJiAoZSA9IGcuX2NsaXApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG51bGwgPT09IGUpcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGUgPSBuZXcgbmUodGhpcywgZSwgYik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JpbmRBY3Rpb24oZSxcclxuICAgICAgICAgICAgICAgIGcpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbihlLCBjLCBkKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVcclxuICAgICAgICB9LCBleGlzdGluZ0FjdGlvbjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBiIHx8IHRoaXMuX3Jvb3QsIGQgPSBjLnV1aWQsIGMgPSBcInN0cmluZ1wiID09PSB0eXBlb2YgYSA/IHFhLmZpbmRCeU5hbWUoYywgYSkgOiBhLFxyXG4gICAgICAgICAgICAgICAgYyA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbYyA/IGMudXVpZCA6IGFdO1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBjID8gYy5hY3Rpb25CeVJvb3RbZF0gfHwgbnVsbCA6IG51bGxcclxuICAgICAgICB9LCBzdG9wQWxsQWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSB0aGlzLl9hY3Rpb25zLCBiID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsIGMgPSB0aGlzLl9iaW5kaW5ncywgZCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncyxcclxuICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDsgZSAhPT0gYjsgKytlKWFbZV0ucmVzZXQoKTtcclxuICAgICAgICAgICAgZm9yIChlID0gMDsgZSAhPT0gZDsgKytlKWNbZV0udXNlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHVwZGF0ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYSAqPSB0aGlzLnRpbWVTY2FsZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucywgYyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLCBkID0gdGhpcy50aW1lICs9IGEsIGUgPSBNYXRoLnNpZ24oYSksIGYgPSB0aGlzLl9hY2N1SW5kZXggXj0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgZyA9IDA7IGcgIT09IGM7ICsrZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBiW2ddO1xyXG4gICAgICAgICAgICAgICAgaC5lbmFibGVkICYmIGguX3VwZGF0ZShkLCBhLCBlLCBmKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGEgPSB0aGlzLl9iaW5kaW5ncztcclxuICAgICAgICAgICAgYiA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncztcclxuICAgICAgICAgICAgZm9yIChnID0gMDsgZyAhPT0gYjsgKytnKWFbZ10uYXBwbHkoZik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgZ2V0Um9vdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFxyXG4gICAgICAgIH0sIHVuY2FjaGVDbGlwOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuX2FjdGlvbnM7XHJcbiAgICAgICAgICAgIGEgPSBhLnV1aWQ7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCwgZCA9IGNbYV07XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSBkLmtub3duQWN0aW9ucywgZSA9IDAsIGYgPSBkLmxlbmd0aDsgZSAhPT0gZjsgKytlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBkW2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBnLl9jYWNoZUluZGV4LCBsID0gYltiLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGcuX2NhY2hlSW5kZXggPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGcuX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGwuX2NhY2hlSW5kZXggPSBoO1xyXG4gICAgICAgICAgICAgICAgICAgIGJbaF0gPSBsO1xyXG4gICAgICAgICAgICAgICAgICAgIGIucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbihnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNbYV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHVuY2FjaGVSb290OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYS51dWlkO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsIGM7XHJcbiAgICAgICAgICAgIGZvciAoYyBpbiBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGJbY10uYWN0aW9uQnlSb290W2FdO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBkICYmICh0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKGQpLCB0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbihkKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lW2FdO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBjKWZvciAodmFyIGUgaW4gYylhID0gY1tlXSwgYS5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpLCB0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoYSlcclxuICAgICAgICB9LCB1bmNhY2hlQWN0aW9uOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oYSwgYik7XHJcbiAgICAgICAgICAgIG51bGwgIT09IGMgJiYgKHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oYyksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbihjKSlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihjZC5wcm90b3R5cGUsIHtcclxuICAgICAgICBfYmluZEFjdGlvbjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBhLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCwgZCA9IGEuX2NsaXAudHJhY2tzLCBlID0gZC5sZW5ndGgsIGYgPSBhLl9wcm9wZXJ0eUJpbmRpbmdzLFxyXG4gICAgICAgICAgICAgICAgZyA9IGEuX2ludGVycG9sYW50cywgaCA9IGMudXVpZCwgbCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSwgayA9IGxbaF07XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gayAmJiAoayA9IHt9LCBsW2hdID0gayk7XHJcbiAgICAgICAgICAgIGZvciAobCA9IDA7IGwgIT09IGU7ICsrbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHEgPSBkW2xdLCBwID0gcS5uYW1lLCBuID0ga1twXTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gZltsXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT09IG4uX2NhY2hlSW5kZXggJiYgKCsrbi5yZWZlcmVuY2VDb3VudCwgdGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKG4sIGgsIHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IG5ldyBKZChrYS5jcmVhdGUoYywgcCwgYiAmJiBiLl9wcm9wZXJ0eUJpbmRpbmdzW2xdLmJpbmRpbmcucGFyc2VkUGF0aCksIHEuVmFsdWVUeXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcS5nZXRWYWx1ZVNpemUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgKytuLnJlZmVyZW5jZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyhuLCBoLCBwKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZltsXSA9IG47XHJcbiAgICAgICAgICAgICAgICBnW2xdLnJlc3VsdEJ1ZmZlciA9IG4uYnVmZmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNBY3RpdmVBY3Rpb24oYSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBhLl9jYWNoZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAoYS5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QpLnV1aWQsIGMgPSBhLl9jbGlwLnV1aWQsIGQgPSB0aGlzLl9hY3Rpb25zQnlDbGlwW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRBY3Rpb24oYSwgZCAmJiBkLmtub3duQWN0aW9uc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oYSwgYywgYilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGIgPSBhLl9wcm9wZXJ0eUJpbmRpbmdzO1xyXG4gICAgICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSBiLmxlbmd0aDsgYyAhPT0gZDsgKytjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBiW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IGUudXNlQ291bnQrKyAmJiAodGhpcy5fbGVuZEJpbmRpbmcoZSksIGUuc2F2ZU9yaWdpbmFsU3RhdGUoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmRBY3Rpb24oYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIF9kZWFjdGl2YXRlQWN0aW9uOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNBY3RpdmVBY3Rpb24oYSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPVxyXG4gICAgICAgICAgICAgICAgICAgIGEuX3Byb3BlcnR5QmluZGluZ3MsIGMgPSAwLCBkID0gYi5sZW5ndGg7IGMgIT09IGQ7ICsrYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gYltjXTtcclxuICAgICAgICAgICAgICAgICAgICAwID09PSAtLWUudXNlQ291bnQgJiYgKGUucmVzdG9yZU9yaWdpbmFsU3RhdGUoKSwgdGhpcy5fdGFrZUJhY2tCaW5kaW5nKGUpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFrZUJhY2tBY3Rpb24oYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIF9pbml0TWVtb3J5TWFuYWdlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fY29udHJvbEludGVycG9sYW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyA9IDA7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5zdGF0cyA9IHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9hY3Rpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldCBpblVzZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuX25BY3RpdmVBY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgYmluZGluZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9iaW5kaW5ncy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGdldCBpblVzZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuX25BY3RpdmVCaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGNvbnRyb2xJbnRlcnBvbGFudHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9jb250cm9sSW50ZXJwb2xhbnRzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldCBpblVzZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgX2lzQWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYS5fY2FjaGVJbmRleDtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT09IGEgJiYgYSA8IHRoaXMuX25BY3RpdmVBY3Rpb25zXHJcbiAgICAgICAgfSwgX2FkZEluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuX2FjdGlvbnMsIGUgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLCBmID0gZVtiXTtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBmID8gKGYgPSB7XHJcbiAgICAgICAgICAgICAgICBrbm93bkFjdGlvbnM6IFthXSxcclxuICAgICAgICAgICAgICAgIGFjdGlvbkJ5Um9vdDoge31cclxuICAgICAgICAgICAgfSwgYS5fYnlDbGlwQ2FjaGVJbmRleCA9IDAsIGVbYl0gPSBmKSA6IChiID0gZi5rbm93bkFjdGlvbnMsIGEuX2J5Q2xpcENhY2hlSW5kZXggPSBiLmxlbmd0aCwgYi5wdXNoKGEpKTtcclxuICAgICAgICAgICAgYS5fY2FjaGVJbmRleCA9IGQubGVuZ3RoO1xyXG4gICAgICAgICAgICBkLnB1c2goYSk7XHJcbiAgICAgICAgICAgIGYuYWN0aW9uQnlSb290W2NdID0gYVxyXG4gICAgICAgIH0sIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9hY3Rpb25zLCBjID0gYltiLmxlbmd0aCAtIDFdLCBkID0gYS5fY2FjaGVJbmRleDtcclxuICAgICAgICAgICAgYy5fY2FjaGVJbmRleCA9IGQ7XHJcbiAgICAgICAgICAgIGJbZF0gPSBjO1xyXG4gICAgICAgICAgICBiLnBvcCgpO1xyXG4gICAgICAgICAgICBhLl9jYWNoZUluZGV4ID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGMgPSBhLl9jbGlwLnV1aWQsIGQgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLCBlID0gZFtjXSwgZiA9IGUua25vd25BY3Rpb25zLCBnID0gZltmLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgaCA9IGEuX2J5Q2xpcENhY2hlSW5kZXg7XHJcbiAgICAgICAgICAgIGcuX2J5Q2xpcENhY2hlSW5kZXggPSBoO1xyXG4gICAgICAgICAgICBmW2hdID0gZztcclxuICAgICAgICAgICAgZi5wb3AoKTtcclxuICAgICAgICAgICAgYS5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBlLmFjdGlvbkJ5Um9vdFsoYi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QpLnV1aWRdO1xyXG4gICAgICAgICAgICAwID09PSBmLmxlbmd0aCAmJiBkZWxldGUgZFtjXTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbihhKVxyXG4gICAgICAgIH0sIF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBhID0gYS5fcHJvcGVydHlCaW5kaW5ncztcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDAsIGMgPSBhLmxlbmd0aDsgYiAhPT0gYzsgKytiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGFbYl07XHJcbiAgICAgICAgICAgICAgICAwID09PSAtLWQucmVmZXJlbmNlQ291bnQgJiYgdGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKGQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBfbGVuZEFjdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9hY3Rpb25zLCBjID0gYS5fY2FjaGVJbmRleCwgZCA9IHRoaXMuX25BY3RpdmVBY3Rpb25zKyssIGUgPSBiW2RdO1xyXG4gICAgICAgICAgICBhLl9jYWNoZUluZGV4ID0gZDtcclxuICAgICAgICAgICAgYltkXSA9IGE7XHJcbiAgICAgICAgICAgIGUuX2NhY2hlSW5kZXggPSBjO1xyXG4gICAgICAgICAgICBiW2NdID0gZVxyXG4gICAgICAgIH0sIF90YWtlQmFja0FjdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9hY3Rpb25zLCBjID0gYS5fY2FjaGVJbmRleCwgZCA9IC0tdGhpcy5fbkFjdGl2ZUFjdGlvbnMsIGUgPSBiW2RdO1xyXG4gICAgICAgICAgICBhLl9jYWNoZUluZGV4ID0gZDtcclxuICAgICAgICAgICAgYltkXSA9IGE7XHJcbiAgICAgICAgICAgIGUuX2NhY2hlSW5kZXggPSBjO1xyXG4gICAgICAgICAgICBiW2NdID0gZVxyXG4gICAgICAgIH0sIF9hZGRJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLCBlID0gZFtiXSwgZiA9IHRoaXMuX2JpbmRpbmdzO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB7fSwgZFtiXSA9XHJcbiAgICAgICAgICAgICAgICBlKTtcclxuICAgICAgICAgICAgZVtjXSA9IGE7XHJcbiAgICAgICAgICAgIGEuX2NhY2hlSW5kZXggPSBmLmxlbmd0aDtcclxuICAgICAgICAgICAgZi5wdXNoKGEpXHJcbiAgICAgICAgfSwgX3JlbW92ZUluYWN0aXZlQmluZGluZzogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9iaW5kaW5ncywgYyA9IGEuYmluZGluZywgZCA9IGMucm9vdE5vZGUudXVpZCwgYyA9IGMucGF0aCwgZSA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcclxuICAgICAgICAgICAgICAgIGYgPSBlW2RdLCBnID0gYltiLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBhID0gYS5fY2FjaGVJbmRleDtcclxuICAgICAgICAgICAgZy5fY2FjaGVJbmRleCA9IGE7XHJcbiAgICAgICAgICAgIGJbYV0gPSBnO1xyXG4gICAgICAgICAgICBiLnBvcCgpO1xyXG4gICAgICAgICAgICBkZWxldGUgZltjXTtcclxuICAgICAgICAgICAgYTp7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBoIGluIGYpYnJlYWsgYTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlW2RdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBfbGVuZEJpbmRpbmc6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fYmluZGluZ3MsIGMgPSBhLl9jYWNoZUluZGV4LCBkID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzKyssIGUgPSBiW2RdO1xyXG4gICAgICAgICAgICBhLl9jYWNoZUluZGV4ID0gZDtcclxuICAgICAgICAgICAgYltkXSA9IGE7XHJcbiAgICAgICAgICAgIGUuX2NhY2hlSW5kZXggPSBjO1xyXG4gICAgICAgICAgICBiW2NdID0gZVxyXG4gICAgICAgIH0sIF90YWtlQmFja0JpbmRpbmc6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fYmluZGluZ3MsIGMgPSBhLl9jYWNoZUluZGV4LCBkID1cclxuICAgICAgICAgICAgICAgIC0tdGhpcy5fbkFjdGl2ZUJpbmRpbmdzLCBlID0gYltkXTtcclxuICAgICAgICAgICAgYS5fY2FjaGVJbmRleCA9IGQ7XHJcbiAgICAgICAgICAgIGJbZF0gPSBhO1xyXG4gICAgICAgICAgICBlLl9jYWNoZUluZGV4ID0gYztcclxuICAgICAgICAgICAgYltjXSA9IGVcclxuICAgICAgICB9LCBfbGVuZENvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsIGIgPSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cysrLCBjID0gYVtiXTtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBjICYmIChjID0gbmV3IFpjKG5ldyBGbG9hdDMyQXJyYXkoMiksIG5ldyBGbG9hdDMyQXJyYXkoMiksIDEsIHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIpLCBjLl9fY2FjaGVJbmRleCA9IGIsIGFbYl0gPSBjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNcclxuICAgICAgICB9LCBfdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cywgYyA9IGEuX19jYWNoZUluZGV4LCBkID0gLS10aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cywgZSA9IGJbZF07XHJcbiAgICAgICAgICAgIGEuX19jYWNoZUluZGV4ID0gZDtcclxuICAgICAgICAgICAgYltkXSA9IGE7XHJcbiAgICAgICAgICAgIGUuX19jYWNoZUluZGV4ID0gYztcclxuICAgICAgICAgICAgYltjXSA9IGVcclxuICAgICAgICB9LCBfY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheSgxKVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKGNkLnByb3RvdHlwZSwgcGEucHJvdG90eXBlKTtcclxuICAgIEtkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEtkKHZvaWQgMCA9PT0gdGhpcy52YWx1ZS5jbG9uZSA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmNsb25lKCkpXHJcbiAgICB9O1xyXG4gICAgRWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJLnByb3RvdHlwZSk7XHJcbiAgICBFYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFYjtcclxuICAgIEViLnByb3RvdHlwZS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gITA7XHJcbiAgICBFYi5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzLnB1c2goe3N0YXJ0OiBhLCBjb3VudDogYiwgbWF0ZXJpYWxJbmRleDogY30pXHJcbiAgICB9O1xyXG4gICAgRWIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBiID0gYS5pbmRleDtcclxuICAgICAgICBudWxsICE9PSBiICYmIHRoaXMuc2V0SW5kZXgoYi5jbG9uZSgpKTtcclxuICAgICAgICB2YXIgYiA9IGEuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgYztcclxuICAgICAgICBmb3IgKGMgaW4gYil0aGlzLmFkZEF0dHJpYnV0ZShjLCBiW2NdLmNsb25lKCkpO1xyXG4gICAgICAgIGEgPSBhLmdyb3VwcztcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICBmb3IgKGIgPSBhLmxlbmd0aDsgYyA8IGI7IGMrKykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IGFbY107XHJcbiAgICAgICAgICAgIHRoaXMuYWRkR3JvdXAoZC5zdGFydCwgZC5jb3VudCwgZC5tYXRlcmlhbEluZGV4KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIG9lLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcjogb2UsIGlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6ICEwLCBnZXQgY291bnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuY291bnRcclxuICAgICAgICB9LCBnZXQgYXJyYXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlcclxuICAgICAgICB9LCBzZXRYOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuYXJyYXlbYSAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldF0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFk6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hcnJheVthICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMV0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFo6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hcnJheVthICogdGhpcy5kYXRhLnN0cmlkZSArXHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICsgMl0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFc6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hcnJheVthICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgM10gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGdldFg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbYSAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldF1cclxuICAgICAgICB9LCBnZXRZOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5W2EgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxXVxyXG4gICAgICAgIH0sIGdldFo6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbYSAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDJdXHJcbiAgICAgICAgfSwgZ2V0VzogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVthICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgM11cclxuICAgICAgICB9LCBzZXRYWTogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgYSA9IGEgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hcnJheVthICsgMF0gPSBiO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuYXJyYXlbYSArXHJcbiAgICAgICAgICAgIDFdID0gYztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRYWVo6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGEgPSBhICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuYXJyYXlbYSArIDBdID0gYjtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmFycmF5W2EgKyAxXSA9IGM7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hcnJheVthICsgMl0gPSBkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldFhZWlc6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIGEgPSBhICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuYXJyYXlbYSArIDBdID0gYjtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmFycmF5W2EgKyAxXSA9IGM7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hcnJheVthICsgMl0gPSBkO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuYXJyYXlbYSArIDNdID0gZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWMucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBpYywgaXNJbnRlcmxlYXZlZEJ1ZmZlcjogITAsIHNldCBuZWVkc1VwZGF0ZShhKSB7XHJcbiAgICAgICAgICAgICEwID09PSBhICYmIHRoaXMudmVyc2lvbisrXHJcbiAgICAgICAgfSwgc2V0QXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LlwiKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCA9IHZvaWQgMCAhPT0gYSA/IGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gYVxyXG4gICAgICAgIH0sIHNldER5bmFtaWM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHluYW1pYyA9IGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBhLmFycmF5LmNvbnN0cnVjdG9yKGEuYXJyYXkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gYS5jb3VudDtcclxuICAgICAgICAgICAgdGhpcy5zdHJpZGUgPSBhLnN0cmlkZTtcclxuICAgICAgICAgICAgdGhpcy5keW5hbWljID0gYS5keW5hbWljO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNvcHlBdDogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgYSAqPSB0aGlzLnN0cmlkZTtcclxuICAgICAgICAgICAgYyAqPSBiLnN0cmlkZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDAsIGUgPSB0aGlzLnN0cmlkZTsgZCA8IGU7IGQrKyl0aGlzLmFycmF5W2EgKyBkXSA9IGIuYXJyYXlbYyArIGRdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXkuc2V0KGEsIGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcylcclxuICAgICAgICB9LCBvblVwbG9hZDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5vblVwbG9hZENhbGxiYWNrID1cclxuICAgICAgICAgICAgICAgIGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGpjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoaWMucHJvdG90eXBlKTtcclxuICAgIGpjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGpjO1xyXG4gICAgamMucHJvdG90eXBlLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSAhMDtcclxuICAgIGpjLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBpYy5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIGEpO1xyXG4gICAgICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IGEubWVzaFBlckF0dHJpYnV0ZTtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIGtjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVS5wcm90b3R5cGUpO1xyXG4gICAga2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga2M7XHJcbiAgICBrYy5wcm90b3R5cGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSAhMDtcclxuICAgIGtjLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBVLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgYSk7XHJcbiAgICAgICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gYS5tZXNoUGVyQXR0cmlidXRlO1xyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9O1xyXG4gICAgcGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBwZSwgbGluZVByZWNpc2lvbjogMSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmF5LnNldChhLCBiKVxyXG4gICAgICAgIH0sIHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGIgJiYgYi5pc1BlcnNwZWN0aXZlQ2FtZXJhID8gKHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oYi5tYXRyaXhXb3JsZCksIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoYS54LCBhLnksIC41KS51bnByb2plY3QoYikuc3ViKHRoaXMucmF5Lm9yaWdpbikubm9ybWFsaXplKCkpIDogYiAmJiBiLmlzT3J0aG9ncmFwaGljQ2FtZXJhID8gKHRoaXMucmF5Lm9yaWdpbi5zZXQoYS54LCBhLnksIChiLm5lYXIgKyBiLmZhcikgLyAoYi5uZWFyIC0gYi5mYXIpKS51bnByb2plY3QoYiksIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoMCwgMCwgLTEpLnRyYW5zZm9ybURpcmVjdGlvbihiLm1hdHJpeFdvcmxkKSkgOiBjb25zb2xlLmVycm9yKFwiVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS5cIilcclxuICAgICAgICB9LCBpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gW107XHJcbiAgICAgICAgICAgIHFlKGEsIHRoaXMsIGMsXHJcbiAgICAgICAgICAgICAgICBiKTtcclxuICAgICAgICAgICAgYy5zb3J0KFdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNcclxuICAgICAgICB9LCBpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoITEgPT09IEFycmF5LmlzQXJyYXkoYSkpcmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS5cIiksIGM7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwLCBlID0gYS5sZW5ndGg7IGQgPCBlOyBkKyspcWUoYVtkXSwgdGhpcywgYywgYik7XHJcbiAgICAgICAgICAgIGMuc29ydChXZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogcmUsIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lID0gKHBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpO1xyXG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gITBcclxuICAgICAgICB9LCBzdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gITFcclxuICAgICAgICB9LCBnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldERlbHRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsYXBzZWRUaW1lXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXREZWx0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0b1N0YXJ0ICYmICF0aGlzLnJ1bm5pbmcgJiYgdGhpcy5zdGFydCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IChwZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKSwgYSA9IChiIC0gdGhpcy5vbGRUaW1lKSAvIDFFMztcclxuICAgICAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IGI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBzZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IHNlLCBzZXQ6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gYTtcclxuICAgICAgICAgICAgdGhpcy5waGkgPSBiO1xyXG4gICAgICAgICAgICB0aGlzLnRoZXRhID0gYztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpXHJcbiAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBhLnJhZGl1cztcclxuICAgICAgICAgICAgdGhpcy5waGkgPSBhLnBoaTtcclxuICAgICAgICAgICAgdGhpcy50aGV0YSA9IGEudGhldGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbWFrZVNhZmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5waGkgPSBNYXRoLm1heCgxRS02LCBNYXRoLm1pbihNYXRoLlBJIC0gMUUtNiwgdGhpcy5waGkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBhLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICAwID09PSB0aGlzLnJhZGl1cyA/IHRoaXMucGhpID0gdGhpcy50aGV0YSA9IDAgOiAodGhpcy50aGV0YSA9IE1hdGguYXRhbjIoYS54LCBhLnopLCB0aGlzLnBoaSA9IE1hdGguYWNvcyhOLmNsYW1wKGEueSAvIHRoaXMucmFkaXVzLCAtMSwgMSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0ZSwgc2V0OiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGE7XHJcbiAgICAgICAgICAgIHRoaXMudGhldGEgPSBiO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBjO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcylcclxuICAgICAgICB9LCBjb3B5OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGEucmFkaXVzO1xyXG4gICAgICAgICAgICB0aGlzLnRoZXRhID0gYS50aGV0YTtcclxuICAgICAgICAgICAgdGhpcy55ID0gYS55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IE1hdGguc3FydChhLnggKiBhLnggKyBhLnogKiBhLnopO1xyXG4gICAgICAgICAgICB0aGlzLnRoZXRhID0gTWF0aC5hdGFuMihhLngsIGEueik7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGEueTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgb2EucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBYS5wcm90b3R5cGUpO1xyXG4gICAgb2EucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2E7XHJcbiAgICBvYS5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICBiID0ge1xyXG4gICAgICAgICAgICBzdGFydDogYixcclxuICAgICAgICAgICAgZW5kOiBjLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGMgLSBiICsgMSxcclxuICAgICAgICAgICAgZnBzOiBkLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogKGMgLSBiKSAvIGQsXHJcbiAgICAgICAgICAgIGxhc3RGcmFtZTogMCxcclxuICAgICAgICAgICAgY3VycmVudEZyYW1lOiAwLFxyXG4gICAgICAgICAgICBhY3RpdmU6ICExLFxyXG4gICAgICAgICAgICB0aW1lOiAwLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IDEsXHJcbiAgICAgICAgICAgIHdlaWdodDogMSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uQmFja3dhcmRzOiAhMSxcclxuICAgICAgICAgICAgbWlycm9yZWRMb29wOiAhMVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zTWFwW2FdID0gYjtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goYilcclxuICAgIH07XHJcbiAgICBvYS5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGZvciAodmFyIGIgPSAvKFthLXpdKylfPyhcXGQrKS9pLCBjLCBkID0ge30sIGUgPSB0aGlzLmdlb21ldHJ5LCBmID0gMCwgZyA9IGUubW9ycGhUYXJnZXRzLmxlbmd0aDsgZiA8XHJcbiAgICAgICAgZzsgZisrKSB7XHJcbiAgICAgICAgICAgIHZhciBoID0gZS5tb3JwaFRhcmdldHNbZl0ubmFtZS5tYXRjaChiKTtcclxuICAgICAgICAgICAgaWYgKGggJiYgMSA8IGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGhbMV07XHJcbiAgICAgICAgICAgICAgICBkW2xdIHx8IChkW2xdID0ge3N0YXJ0OiBJbmZpbml0eSwgZW5kOiAtSW5maW5pdHl9KTtcclxuICAgICAgICAgICAgICAgIGggPSBkW2xdO1xyXG4gICAgICAgICAgICAgICAgZiA8IGguc3RhcnQgJiYgKGguc3RhcnQgPSBmKTtcclxuICAgICAgICAgICAgICAgIGYgPiBoLmVuZCAmJiAoaC5lbmQgPSBmKTtcclxuICAgICAgICAgICAgICAgIGMgfHwgKGMgPSBsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobCBpbiBkKWggPSBkW2xdLCB0aGlzLmNyZWF0ZUFuaW1hdGlvbihsLCBoLnN0YXJ0LCBoLmVuZCwgYSk7XHJcbiAgICAgICAgdGhpcy5maXJzdEFuaW1hdGlvbiA9IGNcclxuICAgIH07XHJcbiAgICBvYS5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uRm9yd2FyZCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGEgPSB0aGlzLmFuaW1hdGlvbnNNYXBbYV0pIGEuZGlyZWN0aW9uID0gMSwgYS5kaXJlY3Rpb25CYWNrd2FyZHMgPSAhMVxyXG4gICAgfTtcclxuICAgIG9hLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGEgPSB0aGlzLmFuaW1hdGlvbnNNYXBbYV0pIGEuZGlyZWN0aW9uID0gLTEsIGEuZGlyZWN0aW9uQmFja3dhcmRzID0gITBcclxuICAgIH07XHJcbiAgICBvYS5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTID1cclxuICAgICAgICBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuYW5pbWF0aW9uc01hcFthXTtcclxuICAgICAgICAgICAgYyAmJiAoYy5mcHMgPSBiLCBjLmR1cmF0aW9uID0gKGMuZW5kIC0gYy5zdGFydCkgLyBjLmZwcylcclxuICAgICAgICB9O1xyXG4gICAgb2EucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuYW5pbWF0aW9uc01hcFthXTtcclxuICAgICAgICBjICYmIChjLmR1cmF0aW9uID0gYiwgYy5mcHMgPSAoYy5lbmQgLSBjLnN0YXJ0KSAvIGMuZHVyYXRpb24pXHJcbiAgICB9O1xyXG4gICAgb2EucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmFuaW1hdGlvbnNNYXBbYV07XHJcbiAgICAgICAgYyAmJiAoYy53ZWlnaHQgPSBiKVxyXG4gICAgfTtcclxuICAgIG9hLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuYW5pbWF0aW9uc01hcFthXTtcclxuICAgICAgICBjICYmIChjLnRpbWUgPSBiKVxyXG4gICAgfTtcclxuICAgIG9hLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgYiA9IDA7XHJcbiAgICAgICAgaWYgKGEgPSB0aGlzLmFuaW1hdGlvbnNNYXBbYV0pIGIgPSBhLnRpbWU7XHJcbiAgICAgICAgcmV0dXJuIGJcclxuICAgIH07XHJcbiAgICBvYS5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPVxyXG4gICAgICAgIGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gLTE7XHJcbiAgICAgICAgICAgIGlmIChhID0gdGhpcy5hbmltYXRpb25zTWFwW2FdKSBiID0gYS5kdXJhdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIGJcclxuICAgICAgICB9O1xyXG4gICAgb2EucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcy5hbmltYXRpb25zTWFwW2FdO1xyXG4gICAgICAgIGIgPyAoYi50aW1lID0gMCwgYi5hY3RpdmUgPSAhMCkgOiBjb25zb2xlLndhcm4oXCJUSFJFRS5Nb3JwaEJsZW5kTWVzaDogYW5pbWF0aW9uW1wiICsgYSArIFwiXSB1bmRlZmluZWQgaW4gLnBsYXlBbmltYXRpb24oKVwiKVxyXG4gICAgfTtcclxuICAgIG9hLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBpZiAoYSA9IHRoaXMuYW5pbWF0aW9uc01hcFthXSkgYS5hY3RpdmUgPSAhMVxyXG4gICAgfTtcclxuICAgIG9hLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGZvciAodmFyIGIgPSAwLCBjID0gdGhpcy5hbmltYXRpb25zTGlzdC5sZW5ndGg7IGIgPCBjOyBiKyspIHtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmFuaW1hdGlvbnNMaXN0W2JdO1xyXG4gICAgICAgICAgICBpZiAoZC5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gZC5kdXJhdGlvbiAvIGQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZC50aW1lICs9IGQuZGlyZWN0aW9uICogYTtcclxuICAgICAgICAgICAgICAgIGlmIChkLm1pcnJvcmVkTG9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnRpbWUgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkLmR1cmF0aW9uIHx8IDAgPiBkLnRpbWUpIGQuZGlyZWN0aW9uICo9IC0xLCBkLnRpbWUgPiBkLmR1cmF0aW9uICYmIChkLnRpbWUgPSBkLmR1cmF0aW9uLCBkLmRpcmVjdGlvbkJhY2t3YXJkcyA9ICEwKSwgMCA+IGQudGltZSAmJiAoZC50aW1lID0gMCwgZC5kaXJlY3Rpb25CYWNrd2FyZHMgPSAhMSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBkLnRpbWUgJT0gZC5kdXJhdGlvbiwgMCA+IGQudGltZSAmJiAoZC50aW1lICs9IGQuZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBkLnN0YXJ0ICsgTi5jbGFtcChNYXRoLmZsb29yKGQudGltZSAvIGUpLCAwLCBkLmxlbmd0aCAtIDEpLCBnID0gZC53ZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBmICE9PSBkLmN1cnJlbnRGcmFtZSAmJiAodGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZC5sYXN0RnJhbWVdID0gMCwgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZC5jdXJyZW50RnJhbWVdID0gMSAqIGcsIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ZdID0gMCwgZC5sYXN0RnJhbWUgPSBkLmN1cnJlbnRGcmFtZSwgZC5jdXJyZW50RnJhbWUgPSBmKTtcclxuICAgICAgICAgICAgICAgIGUgPSBkLnRpbWUgJSBlIC8gZTtcclxuICAgICAgICAgICAgICAgIGQuZGlyZWN0aW9uQmFja3dhcmRzICYmIChlID0gMSAtIGUpO1xyXG4gICAgICAgICAgICAgICAgZC5jdXJyZW50RnJhbWUgIT09XHJcbiAgICAgICAgICAgICAgICBkLmxhc3RGcmFtZSA/ICh0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tkLmN1cnJlbnRGcmFtZV0gPSBlICogZywgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZC5sYXN0RnJhbWVdID0gKDEgLSBlKSAqIGcpIDogdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZC5jdXJyZW50RnJhbWVdID0gZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoeC5wcm90b3R5cGUpO1xyXG4gICAgZGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZGQ7XHJcbiAgICBkZC5wcm90b3R5cGUuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgPSAhMDtcclxuICAgIGVkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZ2EucHJvdG90eXBlKTtcclxuICAgIGVkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGVkO1xyXG4gICAgZWQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYSA9IG5ldyBxLCBiID0gbmV3IHEsIGMgPSBuZXcgeWE7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBbXCJhXCIsIFwiYlwiLCBcImNcIl07XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCEwKTtcclxuICAgICAgICAgICAgYy5nZXROb3JtYWxNYXRyaXgodGhpcy5vYmplY3QubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkLCBmID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLCBnID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgIGlmIChnICYmIGcuaXNHZW9tZXRyeSlmb3IgKHZhciBoID0gZy52ZXJ0aWNlcywgbCA9IGcuZmFjZXMsIGsgPSBnID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBsLmxlbmd0aDsgayA8IHE7IGsrKylmb3IgKHZhciBwID0gbFtrXSwgbiA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHAudmVydGV4Tm9ybWFscy5sZW5ndGg7IG4gPCB1OyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gcC52ZXJ0ZXhOb3JtYWxzW25dO1xyXG4gICAgICAgICAgICAgICAgYS5jb3B5KGhbcFtkW25dXV0pLmFwcGx5TWF0cml4NChlKTtcclxuICAgICAgICAgICAgICAgIGIuY29weSh4KS5hcHBseU1hdHJpeDMoYykubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zaXplKS5hZGQoYSk7XHJcbiAgICAgICAgICAgICAgICBmLnNldFhZWihnLCBhLngsIGEueSwgYS56KTtcclxuICAgICAgICAgICAgICAgIGcgKz0gMTtcclxuICAgICAgICAgICAgICAgIGYuc2V0WFlaKGcsIGIueCwgYi55LCBiLnopO1xyXG4gICAgICAgICAgICAgICAgZyArPSAxXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZyAmJiBnLmlzQnVmZmVyR2VvbWV0cnkpZm9yIChkID0gZy5hdHRyaWJ1dGVzLnBvc2l0aW9uLCBoID0gZy5hdHRyaWJ1dGVzLm5vcm1hbCwgbiA9IGcgPSAwLCB1ID0gZC5jb3VudDsgbiA8XHJcbiAgICAgICAgICAgIHU7IG4rKylhLnNldChkLmdldFgobiksIGQuZ2V0WShuKSwgZC5nZXRaKG4pKS5hcHBseU1hdHJpeDQoZSksIGIuc2V0KGguZ2V0WChuKSwgaC5nZXRZKG4pLCBoLmdldFoobikpLCBiLmFwcGx5TWF0cml4MyhjKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcih0aGlzLnNpemUpLmFkZChhKSwgZi5zZXRYWVooZywgYS54LCBhLnksIGEueiksIGcgKz0gMSwgZi5zZXRYWVooZywgYi54LCBiLnksIGIueiksIGcgKz0gMTtcclxuICAgICAgICAgICAgZi5uZWVkc1VwZGF0ZSA9ICEwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH0oKTtcclxuICAgIGxjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoeC5wcm90b3R5cGUpO1xyXG4gICAgbGMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbGM7XHJcbiAgICBsYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKClcclxuICAgIH07XHJcbiAgICBsYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhID0gbmV3IHEsIGIgPSBuZXcgcTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMubGlnaHQuZGlzdGFuY2UgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saWdodC5kaXN0YW5jZSA6IDFFMywgZCA9IGMgKiBNYXRoLnRhbih0aGlzLmxpZ2h0LmFuZ2xlKTtcclxuICAgICAgICAgICAgdGhpcy5jb25lLnNjYWxlLnNldChkLCBkLCBjKTtcclxuICAgICAgICAgICAgYS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgIGIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgdGhpcy5jb25lLmxvb2tBdChiLnN1YihhKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KVxyXG4gICAgICAgIH1cclxuICAgIH0oKTtcclxuICAgIG1jLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZ2EucHJvdG90eXBlKTtcclxuICAgIG1jLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1jO1xyXG4gICAgbWMucHJvdG90eXBlLmdldEJvbmVMaXN0ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgYiA9IFtdO1xyXG4gICAgICAgIGEgJiYgYS5pc0JvbmUgJiYgYi5wdXNoKGEpO1xyXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYS5jaGlsZHJlbi5sZW5ndGg7IGMrKyliLnB1c2guYXBwbHkoYiwgdGhpcy5nZXRCb25lTGlzdChhLmNoaWxkcmVuW2NdKSk7XHJcbiAgICAgICAgcmV0dXJuIGJcclxuICAgIH07XHJcbiAgICBtYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhID0gbmV3IHEsIGIgPSBuZXcgUywgYyA9IG5ldyBTO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5nZW9tZXRyeSwgZSA9IGQuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgICAgIGMuZ2V0SW52ZXJzZSh0aGlzLnJvb3QubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBmID0gMCwgZyA9IDA7IGYgPCB0aGlzLmJvbmVzLmxlbmd0aDsgZisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuYm9uZXNbZl07XHJcbiAgICAgICAgICAgICAgICBoLnBhcmVudCAmJiBoLnBhcmVudC5pc0JvbmUgJiYgKGIubXVsdGlwbHlNYXRyaWNlcyhjLCBoLm1hdHJpeFdvcmxkKSwgYS5zZXRGcm9tTWF0cml4UG9zaXRpb24oYiksIGUuc2V0WFlaKGcsIGEueCwgYS55LCBhLnopLCBiLm11bHRpcGx5TWF0cmljZXMoYywgaC5wYXJlbnQubWF0cml4V29ybGQpLCBhLnNldEZyb21NYXRyaXhQb3NpdGlvbihiKSwgZS5zZXRYWVooZyArIDEsIGEueCwgYS55LCBhLnopLCBnICs9IDIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZC5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKS5uZWVkc1VwZGF0ZSA9ICEwXHJcbiAgICAgICAgfVxyXG4gICAgfSgpO1xyXG4gICAgbmMucHJvdG90eXBlID1cclxuICAgICAgICBPYmplY3QuY3JlYXRlKEFhLnByb3RvdHlwZSk7XHJcbiAgICBuYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBuYztcclxuICAgIG5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpXHJcbiAgICB9O1xyXG4gICAgbmMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcikubXVsdGlwbHlTY2FsYXIodGhpcy5saWdodC5pbnRlbnNpdHkpXHJcbiAgICB9O1xyXG4gICAgb2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSk7XHJcbiAgICBvYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYztcclxuICAgIG9jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0ubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMV0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMV0ubWF0ZXJpYWwuZGlzcG9zZSgpXHJcbiAgICB9O1xyXG4gICAgb2MucHJvdG90eXBlLnVwZGF0ZSA9XHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBxLCBiID0gbmV3IHE7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY2hpbGRyZW5bMF0sIGQgPSB0aGlzLmNoaWxkcmVuWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlnaHQudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gYi5jbG9uZSgpLnN1YihhKTtcclxuICAgICAgICAgICAgICAgICAgICBjLmxvb2tBdChlKTtcclxuICAgICAgICAgICAgICAgICAgICBkLmxvb2tBdChlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYy5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgICAgIGQubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IC41ICogdGhpcy5saWdodC53aWR0aCwgZSA9IC41ICogdGhpcy5saWdodC5oZWlnaHQsIGMgPSBjLmdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBjLmFycmF5O1xyXG4gICAgICAgICAgICAgICAgZlswXSA9IGQ7XHJcbiAgICAgICAgICAgICAgICBmWzFdID0gLWU7XHJcbiAgICAgICAgICAgICAgICBmWzJdID0gMDtcclxuICAgICAgICAgICAgICAgIGZbM10gPSBkO1xyXG4gICAgICAgICAgICAgICAgZls0XSA9IGU7XHJcbiAgICAgICAgICAgICAgICBmWzVdID0gMDtcclxuICAgICAgICAgICAgICAgIGZbNl0gPSAtZDtcclxuICAgICAgICAgICAgICAgIGZbN10gPSBlO1xyXG4gICAgICAgICAgICAgICAgZls4XSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmWzldID0gLWQ7XHJcbiAgICAgICAgICAgICAgICBmWzEwXSA9IGU7XHJcbiAgICAgICAgICAgICAgICBmWzExXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmWzEyXSA9IC1kO1xyXG4gICAgICAgICAgICAgICAgZlsxM10gPSAtZTtcclxuICAgICAgICAgICAgICAgIGZbMTRdID0gMDtcclxuICAgICAgICAgICAgICAgIGZbMTVdID0gZDtcclxuICAgICAgICAgICAgICAgIGZbMTZdID0gLWU7XHJcbiAgICAgICAgICAgICAgICBmWzE3XSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjLm5lZWRzVXBkYXRlID0gITBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKTtcclxuICAgIHBjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoeC5wcm90b3R5cGUpO1xyXG4gICAgcGMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gcGM7XHJcbiAgICBwYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLm1hdGVyaWFsLmRpc3Bvc2UoKVxyXG4gICAgfTtcclxuICAgIHBjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBKLCBjID0gbmV3IEo7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmNoaWxkcmVuWzBdLCBlID0gZC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJjb2xvclwiKTtcclxuICAgICAgICAgICAgYi5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgYy5jb3B5KHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZiA9IDAsIGcgPSBlLmNvdW50OyBmIDwgZzsgZisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IGYgPCBnIC8gMiA/IGIgOiBjO1xyXG4gICAgICAgICAgICAgICAgZS5zZXRYWVooZiwgaC5yLCBoLmcsIGguYilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkLmxvb2tBdChhLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkKS5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIGUubmVlZHNVcGRhdGUgPSAhMFxyXG4gICAgICAgIH1cclxuICAgIH0oKTtcclxuICAgIGZkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZ2EucHJvdG90eXBlKTtcclxuICAgIGZkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZkO1xyXG4gICAgTGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShnYS5wcm90b3R5cGUpO1xyXG4gICAgTGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGQ7XHJcbiAgICBnZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGdhLnByb3RvdHlwZSk7XHJcbiAgICBnZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBnZDtcclxuICAgIGdkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxLCBjID0gbmV3IHlhO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCEwKTtcclxuICAgICAgICAgICAgYy5nZXROb3JtYWxNYXRyaXgodGhpcy5vYmplY3QubWF0cml4V29ybGQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQsIGUgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24sIGYgPSB0aGlzLm9iamVjdC5nZW9tZXRyeSxcclxuICAgICAgICAgICAgICAgICAgICAgZyA9IGYudmVydGljZXMsIGYgPSBmLmZhY2VzLCBoID0gMCwgbCA9IDAsIGsgPSBmLmxlbmd0aDsgbCA8IGs7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHEgPSBmW2xdLCBwID0gcS5ub3JtYWw7XHJcbiAgICAgICAgICAgICAgICBhLmNvcHkoZ1txLmFdKS5hZGQoZ1txLmJdKS5hZGQoZ1txLmNdKS5kaXZpZGVTY2FsYXIoMykuYXBwbHlNYXRyaXg0KGQpO1xyXG4gICAgICAgICAgICAgICAgYi5jb3B5KHApLmFwcGx5TWF0cml4MyhjKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcih0aGlzLnNpemUpLmFkZChhKTtcclxuICAgICAgICAgICAgICAgIGUuc2V0WFlaKGgsIGEueCwgYS55LCBhLnopO1xyXG4gICAgICAgICAgICAgICAgaCArPSAxO1xyXG4gICAgICAgICAgICAgICAgZS5zZXRYWVooaCwgYi54LCBiLnksIGIueik7XHJcbiAgICAgICAgICAgICAgICBoICs9IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlLm5lZWRzVXBkYXRlID0gITA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfSgpO1xyXG4gICAgcWMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh4LnByb3RvdHlwZSk7XHJcbiAgICBxYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPVxyXG4gICAgICAgIHFjO1xyXG4gICAgcWMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoaWxkcmVuWzBdLCBiID0gdGhpcy5jaGlsZHJlblsxXTtcclxuICAgICAgICBhLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgICBhLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgICAgICBiLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgICBiLm1hdGVyaWFsLmRpc3Bvc2UoKVxyXG4gICAgfTtcclxuICAgIHFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGEgPSBuZXcgcSwgYiA9IG5ldyBxLCBjID0gbmV3IHE7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgIGIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgYy5zdWJWZWN0b3JzKGIsIGEpO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuY2hpbGRyZW5bMF0sIGUgPSB0aGlzLmNoaWxkcmVuWzFdO1xyXG4gICAgICAgICAgICBkLmxvb2tBdChjKTtcclxuICAgICAgICAgICAgZC5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgZS5sb29rQXQoYyk7XHJcbiAgICAgICAgICAgIGUuc2NhbGUueiA9IGMubGVuZ3RoKClcclxuICAgICAgICB9XHJcbiAgICB9KCk7XHJcbiAgICBoZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGdhLnByb3RvdHlwZSk7XHJcbiAgICBoZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBoZDtcclxuICAgIGhkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYShhLCBnLCBoLCBsKSB7XHJcbiAgICAgICAgICAgIGQuc2V0KGcsIGgsIGwpLnVucHJvamVjdChlKTtcclxuICAgICAgICAgICAgYSA9IGNbYV07XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGEpZm9yIChnID0gYi5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKSwgaCA9IDAsIGwgPSBhLmxlbmd0aDsgaCA8IGw7IGgrKylnLnNldFhZWihhW2hdLCBkLngsIGQueSwgZC56KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGIsIGMsIGQgPSBuZXcgcSwgZSA9IG5ldyByYTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy5nZW9tZXRyeTtcclxuICAgICAgICAgICAgYyA9IHRoaXMucG9pbnRNYXA7XHJcbiAgICAgICAgICAgIGUucHJvamVjdGlvbk1hdHJpeC5jb3B5KHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICBhKFwiY1wiLCAwLCAwLCAtMSk7XHJcbiAgICAgICAgICAgIGEoXCJ0XCIsIDAsIDAsIDEpO1xyXG4gICAgICAgICAgICBhKFwibjFcIiwgLTEsIC0xLCAtMSk7XHJcbiAgICAgICAgICAgIGEoXCJuMlwiLCAxLCAtMSwgLTEpO1xyXG4gICAgICAgICAgICBhKFwibjNcIiwgLTEsIDEsIC0xKTtcclxuICAgICAgICAgICAgYShcIm40XCIsIDEsIDEsIC0xKTtcclxuICAgICAgICAgICAgYShcImYxXCIsXHJcbiAgICAgICAgICAgICAgICAtMSwgLTEsIDEpO1xyXG4gICAgICAgICAgICBhKFwiZjJcIiwgMSwgLTEsIDEpO1xyXG4gICAgICAgICAgICBhKFwiZjNcIiwgLTEsIDEsIDEpO1xyXG4gICAgICAgICAgICBhKFwiZjRcIiwgMSwgMSwgMSk7XHJcbiAgICAgICAgICAgIGEoXCJ1MVwiLCAuNywgMS4xLCAtMSk7XHJcbiAgICAgICAgICAgIGEoXCJ1MlwiLCAtLjcsIDEuMSwgLTEpO1xyXG4gICAgICAgICAgICBhKFwidTNcIiwgMCwgMiwgLTEpO1xyXG4gICAgICAgICAgICBhKFwiY2YxXCIsIC0xLCAwLCAxKTtcclxuICAgICAgICAgICAgYShcImNmMlwiLCAxLCAwLCAxKTtcclxuICAgICAgICAgICAgYShcImNmM1wiLCAwLCAtMSwgMSk7XHJcbiAgICAgICAgICAgIGEoXCJjZjRcIiwgMCwgMSwgMSk7XHJcbiAgICAgICAgICAgIGEoXCJjbjFcIiwgLTEsIDAsIC0xKTtcclxuICAgICAgICAgICAgYShcImNuMlwiLCAxLCAwLCAtMSk7XHJcbiAgICAgICAgICAgIGEoXCJjbjNcIiwgMCwgLTEsIC0xKTtcclxuICAgICAgICAgICAgYShcImNuNFwiLCAwLCAxLCAtMSk7XHJcbiAgICAgICAgICAgIGIuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIikubmVlZHNVcGRhdGUgPSAhMFxyXG4gICAgICAgIH1cclxuICAgIH0oKTtcclxuICAgIHJjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZ2EucHJvdG90eXBlKTtcclxuICAgIHJjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHJjO1xyXG4gICAgcmMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYSA9IG5ldyBQYTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgYiAmJiBiLmlzQm94MyA/IGEuY29weShiKSA6IGEuc2V0RnJvbU9iamVjdChiKTtcclxuICAgICAgICAgICAgaWYgKCFhLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGEubWluO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBhLm1heCwgZCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBlID0gZC5hcnJheTtcclxuICAgICAgICAgICAgICAgIGVbMF0gPSBjLng7XHJcbiAgICAgICAgICAgICAgICBlWzFdID0gYy55O1xyXG4gICAgICAgICAgICAgICAgZVsyXSA9IGMuejtcclxuICAgICAgICAgICAgICAgIGVbM10gPSBiLng7XHJcbiAgICAgICAgICAgICAgICBlWzRdID0gYy55O1xyXG4gICAgICAgICAgICAgICAgZVs1XSA9IGMuejtcclxuICAgICAgICAgICAgICAgIGVbNl0gPSBiLng7XHJcbiAgICAgICAgICAgICAgICBlWzddID0gYi55O1xyXG4gICAgICAgICAgICAgICAgZVs4XSA9IGMuejtcclxuICAgICAgICAgICAgICAgIGVbOV0gPSBjLng7XHJcbiAgICAgICAgICAgICAgICBlWzEwXSA9IGIueTtcclxuICAgICAgICAgICAgICAgIGVbMTFdID0gYy56O1xyXG4gICAgICAgICAgICAgICAgZVsxMl0gPSBjLng7XHJcbiAgICAgICAgICAgICAgICBlWzEzXSA9IGMueTtcclxuICAgICAgICAgICAgICAgIGVbMTRdID0gYi56O1xyXG4gICAgICAgICAgICAgICAgZVsxNV0gPSBiLng7XHJcbiAgICAgICAgICAgICAgICBlWzE2XSA9IGMueTtcclxuICAgICAgICAgICAgICAgIGVbMTddID0gYi56O1xyXG4gICAgICAgICAgICAgICAgZVsxOF0gPSBiLng7XHJcbiAgICAgICAgICAgICAgICBlWzE5XSA9IGIueTtcclxuICAgICAgICAgICAgICAgIGVbMjBdID0gYi56O1xyXG4gICAgICAgICAgICAgICAgZVsyMV0gPSBjLng7XHJcbiAgICAgICAgICAgICAgICBlWzIyXSA9IGIueTtcclxuICAgICAgICAgICAgICAgIGVbMjNdID0gYi56O1xyXG4gICAgICAgICAgICAgICAgZC5uZWVkc1VwZGF0ZSA9ICEwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSgpO1xyXG4gICAgdmFyIE1kLCB1ZTtcclxuICAgIEZiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoeC5wcm90b3R5cGUpO1xyXG4gICAgRmIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmI7XHJcbiAgICBGYi5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhID0gbmV3IHEsIGI7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIC45OTk5OSA8IGMueSA/IHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSkgOiAtLjk5OTk5ID4gYy55ID8gdGhpcy5xdWF0ZXJuaW9uLnNldCgxLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMCkgOiAoYS5zZXQoYy56LCAwLCAtYy54KS5ub3JtYWxpemUoKSwgYiA9IE1hdGguYWNvcyhjLnkpLCB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShhLCBiKSlcclxuICAgICAgICB9XHJcbiAgICB9KCk7XHJcbiAgICBGYi5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSAuMiAqIGEpO1xyXG4gICAgICAgIHZvaWQgMCA9PT0gYyAmJiAoYyA9IC4yICogYik7XHJcbiAgICAgICAgdGhpcy5saW5lLnNjYWxlLnNldCgxLCBNYXRoLm1heCgwLCBhIC0gYiksIDEpO1xyXG4gICAgICAgIHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcclxuICAgICAgICB0aGlzLmNvbmUuc2NhbGUuc2V0KGMsIGIsIGMpO1xyXG4gICAgICAgIHRoaXMuY29uZS5wb3NpdGlvbi55ID0gYTtcclxuICAgICAgICB0aGlzLmNvbmUudXBkYXRlTWF0cml4KClcclxuICAgIH07XHJcbiAgICBGYi5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KGEpO1xyXG4gICAgICAgIHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KGEpXHJcbiAgICB9O1xyXG4gICAgTmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShnYS5wcm90b3R5cGUpO1xyXG4gICAgTmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmQ7XHJcbiAgICB2YXIgUWQgPSBuZXcgcSxcclxuICAgICAgICB5ZSA9IG5ldyB2ZSwgemUgPSBuZXcgdmUsIEFlID0gbmV3IHZlO1xyXG4gICAgdmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1YS5wcm90b3R5cGUpO1xyXG4gICAgdmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdmE7XHJcbiAgICB2YS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcy5wb2ludHMsIGMgPSBiLmxlbmd0aDtcclxuICAgICAgICAyID4gYyAmJiBjb25zb2xlLmxvZyhcImR1aCwgeW91IG5lZWQgYXQgbGVhc3QgMiBwb2ludHNcIik7XHJcbiAgICAgICAgYSAqPSBjIC0gKHRoaXMuY2xvc2VkID8gMCA6IDEpO1xyXG4gICAgICAgIHZhciBkID0gTWF0aC5mbG9vcihhKTtcclxuICAgICAgICBhIC09IGQ7XHJcbiAgICAgICAgdGhpcy5jbG9zZWQgPyBkICs9IDAgPCBkID8gMCA6IChNYXRoLmZsb29yKE1hdGguYWJzKGQpIC8gYi5sZW5ndGgpICsgMSkgKiBiLmxlbmd0aCA6IDAgPT09IGEgJiYgZCA9PT0gYyAtIDEgJiYgKGQgPSBjIC0gMiwgYSA9IDEpO1xyXG4gICAgICAgIHZhciBlLCBmLCBnO1xyXG4gICAgICAgIHRoaXMuY2xvc2VkIHx8IDAgPCBkID8gZSA9IGJbKGQgLSAxKSAlIGNdIDogKFFkLnN1YlZlY3RvcnMoYlswXSwgYlsxXSkuYWRkKGJbMF0pLCBlID0gUWQpO1xyXG4gICAgICAgIGYgPSBiW2QgJSBjXTtcclxuICAgICAgICBnID0gYlsoZCArIDEpICUgY107XHJcbiAgICAgICAgdGhpcy5jbG9zZWQgfHwgZCArIDIgPCBjID8gYiA9IGJbKGQgKyAyKSAlIGNdIDogKFFkLnN1YlZlY3RvcnMoYltjIC1cclxuICAgICAgICAxXSwgYltjIC0gMl0pLmFkZChiW2MgLSAxXSksIGIgPSBRZCk7XHJcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gdGhpcy50eXBlIHx8IFwiY2VudHJpcGV0YWxcIiA9PT0gdGhpcy50eXBlIHx8IFwiY2hvcmRhbFwiID09PSB0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGggPSBcImNob3JkYWxcIiA9PT0gdGhpcy50eXBlID8gLjUgOiAuMjUsIGMgPSBNYXRoLnBvdyhlLmRpc3RhbmNlVG9TcXVhcmVkKGYpLCBoKSxcclxuICAgICAgICAgICAgICAgIGQgPSBNYXRoLnBvdyhmLmRpc3RhbmNlVG9TcXVhcmVkKGcpLCBoKSwgaCA9IE1hdGgucG93KGcuZGlzdGFuY2VUb1NxdWFyZWQoYiksIGgpO1xyXG4gICAgICAgICAgICAxRS00ID4gZCAmJiAoZCA9IDEpO1xyXG4gICAgICAgICAgICAxRS00ID4gYyAmJiAoYyA9IGQpO1xyXG4gICAgICAgICAgICAxRS00ID4gaCAmJiAoaCA9IGQpO1xyXG4gICAgICAgICAgICB5ZS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oZS54LCBmLngsIGcueCwgYi54LCBjLCBkLCBoKTtcclxuICAgICAgICAgICAgemUuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKGUueSwgZi55LCBnLnksIGIueSwgYywgZCwgaCk7XHJcbiAgICAgICAgICAgIEFlLmluaXROb251bmlmb3JtQ2F0bXVsbFJvbShlLnosIGYueiwgZy56LCBiLnosIGMsIGQsIGgpXHJcbiAgICAgICAgfSBlbHNlXCJjYXRtdWxscm9tXCIgPT09IHRoaXMudHlwZSAmJiAoYyA9IHZvaWQgMCAhPT0gdGhpcy50ZW5zaW9uID8gdGhpcy50ZW5zaW9uIDpcclxuICAgICAgICAgICAgLjUsIHllLmluaXRDYXRtdWxsUm9tKGUueCwgZi54LCBnLngsIGIueCwgYyksIHplLmluaXRDYXRtdWxsUm9tKGUueSwgZi55LCBnLnksIGIueSwgYyksIEFlLmluaXRDYXRtdWxsUm9tKGUueiwgZi56LCBnLnosIGIueiwgYykpO1xyXG4gICAgICAgIHJldHVybiBuZXcgcSh5ZS5jYWxjKGEpLCB6ZS5jYWxjKGEpLCBBZS5jYWxjKGEpKVxyXG4gICAgfTtcclxuICAgIGlkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodWEucHJvdG90eXBlKTtcclxuICAgIGlkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGlkO1xyXG4gICAgaWQucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgYiA9IHRoaXMudjAsIGMgPSB0aGlzLnYxLCBkID0gdGhpcy52MiwgZSA9IHRoaXMudjM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBxKEJiKGEsIGIueCwgYy54LCBkLngsIGUueCksIEJiKGEsIGIueSwgYy55LCBkLnksIGUueSksIEJiKGEsIGIueiwgYy56LCBkLnosIGUueikpXHJcbiAgICB9O1xyXG4gICAgamQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1YS5wcm90b3R5cGUpO1xyXG4gICAgamQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gamQ7XHJcbiAgICBqZC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcy52MCxcclxuICAgICAgICAgICAgYyA9IHRoaXMudjEsIGQgPSB0aGlzLnYyO1xyXG4gICAgICAgIHJldHVybiBuZXcgcShBYihhLCBiLngsIGMueCwgZC54KSwgQWIoYSwgYi55LCBjLnksIGQueSksIEFiKGEsIGIueiwgYy56LCBkLnopKVxyXG4gICAgfTtcclxuICAgIGtkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodWEucHJvdG90eXBlKTtcclxuICAgIGtkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGtkO1xyXG4gICAga2QucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBpZiAoMSA9PT0gYSlyZXR1cm4gdGhpcy52Mi5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBiID0gbmV3IHE7XHJcbiAgICAgICAgYi5zdWJWZWN0b3JzKHRoaXMudjIsIHRoaXMudjEpO1xyXG4gICAgICAgIGIubXVsdGlwbHlTY2FsYXIoYSk7XHJcbiAgICAgICAgYi5hZGQodGhpcy52MSk7XHJcbiAgICAgICAgcmV0dXJuIGJcclxuICAgIH07XHJcbiAgICBPZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdhLnByb3RvdHlwZSk7XHJcbiAgICBPZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPZDtcclxuICAgIHVhLmNyZWF0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJUSFJFRS5DdXJ2ZS5jcmVhdGUoKSBoYXMgYmVlbiBkZXByZWNhdGVkXCIpO1xyXG4gICAgICAgIGEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1YS5wcm90b3R5cGUpO1xyXG4gICAgICAgIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID1cclxuICAgICAgICAgICAgYTtcclxuICAgICAgICBhLnByb3RvdHlwZS5nZXRQb2ludCA9IGI7XHJcbiAgICAgICAgcmV0dXJuIGFcclxuICAgIH07XHJcbiAgICBYZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHZhLnByb3RvdHlwZSk7XHJcbiAgICBZZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHZhLnByb3RvdHlwZSk7XHJcbiAgICB3ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHZhLnByb3RvdHlwZSk7XHJcbiAgICBPYmplY3QuYXNzaWduKHdlLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGluaXRGcm9tQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5TcGxpbmU6IC5pbml0RnJvbUFycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC5cIilcclxuICAgICAgICB9LCBnZXRDb250cm9sUG9pbnRzQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5TcGxpbmU6IC5nZXRDb250cm9sUG9pbnRzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLlwiKVxyXG4gICAgICAgIH0sIHJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlNwbGluZTogLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBmZC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5HcmlkSGVscGVyOiBzZXRDb2xvcnMoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCBwYXNzIHRoZW0gaW4gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQuXCIpXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihzYy5wcm90b3R5cGUsIHtcclxuICAgICAgICBjZW50ZXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJveDI6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbnRlcihhKVxyXG4gICAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJveDI6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKVxyXG4gICAgICAgIH0sIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5Cb3gyOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KGEpXHJcbiAgICAgICAgfSwgc2l6ZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQm94MjogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaXplKGEpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKFBhLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGNlbnRlcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQm94MzogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyKGEpXHJcbiAgICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQm94MzogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpXHJcbiAgICAgICAgfSwgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goYSlcclxuICAgICAgICB9LCBpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShhKVxyXG4gICAgICAgIH0sIHNpemU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJveDM6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2l6ZShhKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaGIucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGluZTM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS5cIik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyKGEpXHJcbiAgICB9O1xyXG4gICAgTi5yYW5kb20xNiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRoLnJhbmRvbTE2KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIE1hdGgucmFuZG9tKCkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKClcclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHlhLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXgzOiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheShhLCBiKVxyXG4gICAgICAgIH0sIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGEuYXBwbHlNYXRyaXgzKHRoaXMpXHJcbiAgICAgICAgfSwgbXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheShhKVxyXG4gICAgICAgIH0sIGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDM6IC5hcHBseVRvQnVmZmVyKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZShhKVxyXG4gICAgICAgIH0sIGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb1ZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKFMucHJvdG90eXBlLCB7XHJcbiAgICAgICAgZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheShhLCBiKVxyXG4gICAgICAgIH0sIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gbmV3IHEpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSwgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oYSlcclxuICAgICAgICB9LCBtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmFwcGx5TWF0cml4NCh0aGlzKVxyXG4gICAgICAgIH0sIG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGEuYXBwbHlNYXRyaXg0KHRoaXMpXHJcbiAgICAgICAgfSwgbXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheShhKVxyXG4gICAgICAgIH0sIHJvdGF0ZUF4aXM6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgYS50cmFuc2Zvcm1EaXJlY3Rpb24odGhpcylcclxuICAgICAgICB9LCBjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5hcHBseU1hdHJpeDQodGhpcylcclxuICAgICAgICB9LCB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLlwiKVxyXG4gICAgICAgIH0sIHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIilcclxuICAgICAgICB9LCByb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgfSwgcm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiAucm90YXRlQnlBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIilcclxuICAgICAgICB9LCBhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAuYXBwbHlUb0J1ZmZlcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoYSlcclxuICAgICAgICB9LCBhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuTWF0cml4NDogLmFwcGx5VG9WZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLlwiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWFrZUZydXN0dW06IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tYWtlRnJ1c3R1bSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlUGVyc3BlY3RpdmUoYSwgYiwgZCwgYywgZSwgZilcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGxhLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbkxpbmUgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS5cIik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c0xpbmUoYSlcclxuICAgIH07XHJcbiAgICBjYS5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3IzID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIGEuYXBwbHlRdWF0ZXJuaW9uKHRoaXMpXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihjYi5wcm90b3R5cGUsIHtcclxuICAgICAgICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KGEpXHJcbiAgICAgICAgfSwgaXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25QbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNQbGFuZSgpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1BsYW5lKGEpXHJcbiAgICAgICAgfSwgaXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShhKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihEYi5wcm90b3R5cGUsIHtcclxuICAgICAgICBleHRydWRlOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5TaGFwZTogLmV4dHJ1ZGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXh0cnVkZUdlb21ldHJ5KCkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGEodGhpcywgYSlcclxuICAgICAgICB9LCBtYWtlR2VvbWV0cnk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlNoYXBlOiAubWFrZUdlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFNoYXBlR2VvbWV0cnkoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBZYih0aGlzLCBhKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihELnByb3RvdHlwZSwge1xyXG4gICAgICAgIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5WZWN0b3IyOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYSwgYiwgYylcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5hc3NpZ24ocS5wcm90b3R5cGUsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLlwiKVxyXG4gICAgICAgICAgICB9LCBzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuXCIpXHJcbiAgICAgICAgfSwgZ2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oYSlcclxuICAgICAgICB9LCBnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZShhKVxyXG4gICAgICAgIH0sIGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihiLCBhKVxyXG4gICAgICAgIH0sIGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLmFwcGx5UHJvamVjdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuYXBwbHlNYXRyaXg0KCBtICkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChhKVxyXG4gICAgICAgIH0sIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5WZWN0b3IzOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYSxcclxuICAgICAgICAgICAgICAgIGIsIGMpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihmYS5wcm90b3R5cGUsIHtcclxuICAgICAgICBmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuVmVjdG9yNDogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKGEsIGIsIGMpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBULnByb3RvdHlwZS5jb21wdXRlVGFuZ2VudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLlwiKVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oeC5wcm90b3R5cGUsIHtcclxuICAgICAgICBnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKGEpXHJcbiAgICAgICAgfSwgcmVuZGVyRGVwdGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC5yZW5kZXJEZXB0aCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnJlbmRlck9yZGVyLCBpbnN0ZWFkLlwiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoYiwgYSlcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHgucHJvdG90eXBlLCB7XHJcbiAgICAgICAgZXVsZXJPcmRlcjoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24ub3JkZXIgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB1c2VRdWF0ZXJuaW9uOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuXCIpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVjLnByb3RvdHlwZSwge1xyXG4gICAgICAgIG9iamVjdHM6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbHNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgRmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnNldExlbnMgaXMgZGVwcmVjYXRlZC4gVXNlIC5zZXRGb2NhbExlbmd0aCBhbmQgLmZpbG1HYXVnZSBmb3IgYSBwaG90b2dyYXBoaWMgc2V0dXAuXCIpO1xyXG4gICAgICAgIHZvaWQgMCAhPT0gYiAmJiAodGhpcy5maWxtR2F1Z2UgPSBiKTtcclxuICAgICAgICB0aGlzLnNldEZvY2FsTGVuZ3RoKGEpXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobWEucHJvdG90eXBlLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb25seVNoYWRvdzoge1xyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHNoYWRvd0NhbWVyYUZvdjoge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZvdiBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZm92LlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93LmNhbWVyYS5mb3YgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzaGFkb3dDYW1lcmFMZWZ0OiB7XHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTGVmdCBpcyBub3cgLnNoYWRvdy5jYW1lcmEubGVmdC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHNoYWRvd0NhbWVyYVJpZ2h0OiB7XHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhUmlnaHQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLnJpZ2h0LlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHNoYWRvd0NhbWVyYVRvcDoge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVRvcCBpcyBub3cgLnNoYWRvdy5jYW1lcmEudG9wLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93LmNhbWVyYS50b3AgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzaGFkb3dDYW1lcmFCb3R0b206IHtcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFCb3R0b20gaXMgbm93IC5zaGFkb3cuY2FtZXJhLmJvdHRvbS5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc2hhZG93Q2FtZXJhTmVhcjoge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYU5lYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLm5lYXIuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3cuY2FtZXJhLm5lYXIgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzaGFkb3dDYW1lcmFGYXI6IHtcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFGYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmZhci5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEuZmFyID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc2hhZG93Q2FtZXJhVmlzaWJsZToge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVmlzaWJsZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggbGlnaHQuc2hhZG93LmNhbWVyYSApIGluc3RlYWQuXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaGFkb3dCaWFzOiB7XHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5zaGFkb3dCaWFzIGlzIG5vdyAuc2hhZG93LmJpYXMuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93LmJpYXMgPSBhXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHNoYWRvd0RhcmtuZXNzOiB7XHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5zaGFkb3dEYXJrbmVzcyBoYXMgYmVlbiByZW1vdmVkLlwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc2hhZG93TWFwV2lkdGg6IHtcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBXaWR0aCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLndpZHRoLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzaGFkb3dNYXBIZWlnaHQ6IHtcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBIZWlnaHQgaXMgbm93IC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhVLnByb3RvdHlwZSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxlbmd0aDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuY291bnQgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIE9iamVjdC5hc3NpZ24oSS5wcm90b3R5cGUsIHtcclxuICAgICAgICBhZGRJbmRleDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRJbmRleCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEluZGV4KCkuXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEluZGV4KGEpXHJcbiAgICAgICAgfSwgYWRkRHJhd0NhbGw6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gYyAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIGluZGV4T2Zmc2V0LlwiKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkR3JvdXAoYSxcclxuICAgICAgICAgICAgICAgIGIpXHJcbiAgICAgICAgfSwgY2xlYXJEcmF3Q2FsbHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jbGVhckRyYXdDYWxscygpIGlzIG5vdyAuY2xlYXJHcm91cHMoKS5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJHcm91cHMoKVxyXG4gICAgICAgIH0sIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgfSwgY29tcHV0ZU9mZnNldHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhJLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGRyYXdjYWxsczoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvZmZzZXRzOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5vZmZzZXRzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoS2QucHJvdG90eXBlLCB7XHJcbiAgICAgICAgZHluYW1pYzoge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlVuaWZvcm06IC5keW5hbWljIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBvYmplY3Qub25CZWZvcmVSZW5kZXIoKSBpbnN0ZWFkLlwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgb25VcGRhdGU6IHtcclxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlVuaWZvcm06IC5vblVwZGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBvYmplY3Qub25CZWZvcmVSZW5kZXIoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFgucHJvdG90eXBlLCB7XHJcbiAgICAgICAgd3JhcEFyb3VuZDoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLlwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgd3JhcFJHQjoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENhLnByb3RvdHlwZSwge1xyXG4gICAgICAgIG1ldGFsOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITFcclxuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhhLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGRlcml2YXRpdmVzOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLiBTaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihZZC5wcm90b3R5cGUsIHtcclxuICAgICAgICBzdXBwb3J0c0Zsb2F0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KFwiT0VTX3RleHR1cmVfZmxvYXRcIilcclxuICAgICAgICB9LCBzdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIilcclxuICAgICAgICB9LCBzdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldChcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKVxyXG4gICAgICAgIH0sIHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpXHJcbiAgICAgICAgfSwgc3VwcG9ydHNCbGVuZE1pbk1heDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoXCJFWFRfYmxlbmRfbWlubWF4XCIpXHJcbiAgICAgICAgfSwgc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcygpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzXHJcbiAgICAgICAgfSwgc3VwcG9ydHNJbnN0YW5jZWRBcnJheXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldChcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIilcclxuICAgICAgICB9LCBlbmFibGVTY2lzc29yVGVzdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLlwiKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTY2lzc29yVGVzdChhKVxyXG4gICAgICAgIH0sIGluaXRNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIilcclxuICAgICAgICB9LCBhZGRQcmVQbHVnaW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQb3N0UGx1Z2luOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIilcclxuICAgICAgICB9LCB1cGRhdGVTaGFkb3dNYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhZZC5wcm90b3R5cGUsIHtcclxuICAgICAgICBzaGFkb3dNYXBFbmFibGVkOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhZG93TWFwLmVuYWJsZWRcclxuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd01hcC5lbmFibGVkID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc2hhZG93TWFwVHlwZToge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd01hcC50eXBlXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBUeXBlIGlzIG5vdyAuc2hhZG93TWFwLnR5cGUuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dNYXAudHlwZSA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHNoYWRvd01hcEN1bGxGYWNlOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhZG93TWFwLmN1bGxGYWNlXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoS2UucHJvdG90eXBlLCB7XHJcbiAgICAgICAgY3VsbEZhY2U6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPyAyIDogMVxyXG4gICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gMSAhPT0gYTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAuY3VsbEZhY2UgaXMgZGVwcmVjYXRlZC4gU2V0IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIHRvIFwiICsgYSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhZYS5wcm90b3R5cGUsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3cmFwUzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUud3JhcFNcclxuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLndyYXBTID0gYVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB3cmFwVDoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUud3JhcFRcclxuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLndyYXBUID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgbWFnRmlsdGVyOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlclxyXG4gICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBtaW5GaWx0ZXI6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUubWluRmlsdGVyXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGFuaXNvdHJvcHk6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5XHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9mZnNldDoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5vZmZzZXRcclxuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUub2Zmc2V0ID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgcmVwZWF0OiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLnJlcGVhdFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5yZXBlYXQgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBmb3JtYXQ6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUuZm9ybWF0XHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmZvcm1hdCA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHR5cGU6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS50eXBlXHJcbiAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUudHlwZSA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGdlbmVyYXRlTWlwbWFwczoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHNcclxuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgaGMucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkF1ZGlvOiAubG9hZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQXVkaW9Mb2FkZXIgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgdmFyIGIgPSB0aGlzO1xyXG4gICAgICAgIChuZXcgZ2UpLmxvYWQoYSwgZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgYi5zZXRCdWZmZXIoYSlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfTtcclxuICAgIGxlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkF1ZGlvQW5hbHlzZXI6IC5nZXREYXRhKCkgaXMgbm93IC5nZXRGcmVxdWVuY3lEYXRhKCkuXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKVxyXG4gICAgfTtcclxuICAgIGwuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gR2I7XHJcbiAgICBsLldlYkdMUmVuZGVyVGFyZ2V0ID0gWWE7XHJcbiAgICBsLldlYkdMUmVuZGVyZXIgPSBZZDtcclxuICAgIGwuU2hhZGVyTGliID0gYmI7XHJcbiAgICBsLlVuaWZvcm1zTGliID0gVjtcclxuICAgIGwuVW5pZm9ybXNVdGlscyA9IEphO1xyXG4gICAgbC5TaGFkZXJDaHVuayA9IFo7XHJcbiAgICBsLkZvZ0V4cDIgPSBLYjtcclxuICAgIGwuRm9nID0gTGI7XHJcbiAgICBsLlNjZW5lID0gbWI7XHJcbiAgICBsLkxlbnNGbGFyZSA9IFpkO1xyXG4gICAgbC5TcHJpdGUgPSBEYztcclxuICAgIGwuTE9EID0gRWM7XHJcbiAgICBsLlNraW5uZWRNZXNoID0gcWQ7XHJcbiAgICBsLlNrZWxldG9uID0gb2Q7XHJcbiAgICBsLkJvbmUgPSBwZDtcclxuICAgIGwuTWVzaCA9IEFhO1xyXG4gICAgbC5MaW5lU2VnbWVudHMgPSBnYTtcclxuICAgIGwuTGluZSA9IFVhO1xyXG4gICAgbC5Qb2ludHMgPSBNYjtcclxuICAgIGwuR3JvdXAgPSBGYztcclxuICAgIGwuVmlkZW9UZXh0dXJlID0gcmQ7XHJcbiAgICBsLkRhdGFUZXh0dXJlID0gZWI7XHJcbiAgICBsLkNvbXByZXNzZWRUZXh0dXJlID1cclxuICAgICAgICBOYjtcclxuICAgIGwuQ3ViZVRleHR1cmUgPSBaYTtcclxuICAgIGwuQ2FudmFzVGV4dHVyZSA9IHNkO1xyXG4gICAgbC5EZXB0aFRleHR1cmUgPSBHYztcclxuICAgIGwuVGV4dHVyZSA9IGVhO1xyXG4gICAgbC5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IFJlO1xyXG4gICAgbC5EYXRhVGV4dHVyZUxvYWRlciA9IGFlO1xyXG4gICAgbC5DdWJlVGV4dHVyZUxvYWRlciA9IGJlO1xyXG4gICAgbC5UZXh0dXJlTG9hZGVyID0gdGQ7XHJcbiAgICBsLk9iamVjdExvYWRlciA9IFNlO1xyXG4gICAgbC5NYXRlcmlhbExvYWRlciA9IEhkO1xyXG4gICAgbC5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IGNlO1xyXG4gICAgbC5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSB0YTtcclxuICAgIGwuTG9hZGluZ01hbmFnZXIgPSAkZDtcclxuICAgIGwuSlNPTkxvYWRlciA9IGRlO1xyXG4gICAgbC5JbWFnZUxvYWRlciA9IFljO1xyXG4gICAgbC5Gb250TG9hZGVyID0gVWU7XHJcbiAgICBsLkZpbGVMb2FkZXIgPSBzYTtcclxuICAgIGwuTG9hZGVyID0gemI7XHJcbiAgICBsLkNhY2hlID0gbGQ7XHJcbiAgICBsLkF1ZGlvTG9hZGVyID0gZ2U7XHJcbiAgICBsLlNwb3RMaWdodFNoYWRvdyA9IHZkO1xyXG4gICAgbC5TcG90TGlnaHQgPSB3ZDtcclxuICAgIGwuUG9pbnRMaWdodCA9IHhkO1xyXG4gICAgbC5SZWN0QXJlYUxpZ2h0ID0gaGU7XHJcbiAgICBsLkhlbWlzcGhlcmVMaWdodCA9IHVkO1xyXG4gICAgbC5EaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0geWQ7XHJcbiAgICBsLkRpcmVjdGlvbmFsTGlnaHQgPVxyXG4gICAgICAgIHpkO1xyXG4gICAgbC5BbWJpZW50TGlnaHQgPSBBZDtcclxuICAgIGwuTGlnaHRTaGFkb3cgPSB3YjtcclxuICAgIGwuTGlnaHQgPSBtYTtcclxuICAgIGwuU3RlcmVvQ2FtZXJhID0gVmU7XHJcbiAgICBsLlBlcnNwZWN0aXZlQ2FtZXJhID0gRmE7XHJcbiAgICBsLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IEpiO1xyXG4gICAgbC5DdWJlQ2FtZXJhID0gSWQ7XHJcbiAgICBsLkNhbWVyYSA9IHJhO1xyXG4gICAgbC5BdWRpb0xpc3RlbmVyID0gaWU7XHJcbiAgICBsLlBvc2l0aW9uYWxBdWRpbyA9IGtlO1xyXG4gICAgbC5BdWRpb0NvbnRleHQgPSBqZTtcclxuICAgIGwuQXVkaW9BbmFseXNlciA9IGxlO1xyXG4gICAgbC5BdWRpbyA9IGhjO1xyXG4gICAgbC5WZWN0b3JLZXlmcmFtZVRyYWNrID0gZGM7XHJcbiAgICBsLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBFZDtcclxuICAgIGwuUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPSAkYztcclxuICAgIGwuTnVtYmVyS2V5ZnJhbWVUcmFjayA9IGVjO1xyXG4gICAgbC5Db2xvcktleWZyYW1lVHJhY2sgPSBHZDtcclxuICAgIGwuQm9vbGVhbktleWZyYW1lVHJhY2sgPSBGZDtcclxuICAgIGwuUHJvcGVydHlNaXhlciA9IEpkO1xyXG4gICAgbC5Qcm9wZXJ0eUJpbmRpbmcgPSBrYTtcclxuICAgIGwuS2V5ZnJhbWVUcmFjayA9IHliO1xyXG4gICAgbC5BbmltYXRpb25VdGlscyA9IG5hO1xyXG4gICAgbC5BbmltYXRpb25PYmplY3RHcm91cCA9IG1lO1xyXG4gICAgbC5BbmltYXRpb25NaXhlciA9XHJcbiAgICAgICAgY2Q7XHJcbiAgICBsLkFuaW1hdGlvbkNsaXAgPSBxYTtcclxuICAgIGwuVW5pZm9ybSA9IEtkO1xyXG4gICAgbC5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IEViO1xyXG4gICAgbC5CdWZmZXJHZW9tZXRyeSA9IEk7XHJcbiAgICBsLkdlb21ldHJ5SWRDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gVmQrK1xyXG4gICAgfTtcclxuICAgIGwuR2VvbWV0cnkgPSBUO1xyXG4gICAgbC5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IG9lO1xyXG4gICAgbC5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IGpjO1xyXG4gICAgbC5JbnRlcmxlYXZlZEJ1ZmZlciA9IGljO1xyXG4gICAgbC5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBrYztcclxuICAgIGwuRmFjZTMgPSBoYTtcclxuICAgIGwuT2JqZWN0M0QgPSB4O1xyXG4gICAgbC5SYXljYXN0ZXIgPSBwZTtcclxuICAgIGwuTGF5ZXJzID0gbmQ7XHJcbiAgICBsLkV2ZW50RGlzcGF0Y2hlciA9IHBhO1xyXG4gICAgbC5DbG9jayA9IHJlO1xyXG4gICAgbC5RdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQgPSBEZDtcclxuICAgIGwuTGluZWFySW50ZXJwb2xhbnQgPSBaYztcclxuICAgIGwuRGlzY3JldGVJbnRlcnBvbGFudCA9IENkO1xyXG4gICAgbC5DdWJpY0ludGVycG9sYW50ID0gQmQ7XHJcbiAgICBsLkludGVycG9sYW50ID0geGE7XHJcbiAgICBsLlRyaWFuZ2xlID0gemE7XHJcbiAgICBsLk1hdGggPSBOO1xyXG4gICAgbC5TcGhlcmljYWwgPSBzZTtcclxuICAgIGwuQ3lsaW5kcmljYWwgPVxyXG4gICAgICAgIHRlO1xyXG4gICAgbC5QbGFuZSA9IGxhO1xyXG4gICAgbC5GcnVzdHVtID0gdGM7XHJcbiAgICBsLlNwaGVyZSA9IE5hO1xyXG4gICAgbC5SYXkgPSBjYjtcclxuICAgIGwuTWF0cml4NCA9IFM7XHJcbiAgICBsLk1hdHJpeDMgPSB5YTtcclxuICAgIGwuQm94MyA9IFBhO1xyXG4gICAgbC5Cb3gyID0gc2M7XHJcbiAgICBsLkxpbmUzID0gaGI7XHJcbiAgICBsLkV1bGVyID0gZGI7XHJcbiAgICBsLlZlY3RvcjQgPSBmYTtcclxuICAgIGwuVmVjdG9yMyA9IHE7XHJcbiAgICBsLlZlY3RvcjIgPSBEO1xyXG4gICAgbC5RdWF0ZXJuaW9uID0gY2E7XHJcbiAgICBsLkNvbG9yID0gSjtcclxuICAgIGwuTW9ycGhCbGVuZE1lc2ggPSBvYTtcclxuICAgIGwuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZGQ7XHJcbiAgICBsLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBlZDtcclxuICAgIGwuU3BvdExpZ2h0SGVscGVyID0gbGM7XHJcbiAgICBsLlNrZWxldG9uSGVscGVyID0gbWM7XHJcbiAgICBsLlBvaW50TGlnaHRIZWxwZXIgPSBuYztcclxuICAgIGwuUmVjdEFyZWFMaWdodEhlbHBlciA9IG9jO1xyXG4gICAgbC5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBwYztcclxuICAgIGwuR3JpZEhlbHBlciA9IGZkO1xyXG4gICAgbC5Qb2xhckdyaWRIZWxwZXIgPSBMZDtcclxuICAgIGwuRmFjZU5vcm1hbHNIZWxwZXIgPSBnZDtcclxuICAgIGwuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IHFjO1xyXG4gICAgbC5DYW1lcmFIZWxwZXIgPSBoZDtcclxuICAgIGwuQm94SGVscGVyID0gcmM7XHJcbiAgICBsLkFycm93SGVscGVyID0gRmI7XHJcbiAgICBsLkF4aXNIZWxwZXIgPSBOZDtcclxuICAgIGwuQ2F0bXVsbFJvbUN1cnZlMyA9IHZhO1xyXG4gICAgbC5DdWJpY0JlemllckN1cnZlMyA9IGlkO1xyXG4gICAgbC5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBqZDtcclxuICAgIGwuTGluZUN1cnZlMyA9IGtkO1xyXG4gICAgbC5BcmNDdXJ2ZSA9IE9kO1xyXG4gICAgbC5FbGxpcHNlQ3VydmUgPSBXYTtcclxuICAgIGwuU3BsaW5lQ3VydmUgPSBDYjtcclxuICAgIGwuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZjO1xyXG4gICAgbC5RdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGdjO1xyXG4gICAgbC5MaW5lQ3VydmUgPSBUYTtcclxuICAgIGwuU2hhcGUgPSBEYjtcclxuICAgIGwuUGF0aCA9IGJkO1xyXG4gICAgbC5TaGFwZVBhdGggPSBlZTtcclxuICAgIGwuRm9udCA9IGZlO1xyXG4gICAgbC5DdXJ2ZVBhdGggPSBhZDtcclxuICAgIGwuQ3VydmUgPSB1YTtcclxuICAgIGwuU2hhcGVVdGlscyA9IElhO1xyXG4gICAgbC5TY2VuZVV0aWxzID0ge1xyXG4gICAgICAgIGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSBuZXcgRmMsIGQgPSAwLCBlID0gYi5sZW5ndGg7IGQgPCBlOyBkKyspYy5hZGQobmV3IEFhKGEsIGJbZF0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNcclxuICAgICAgICB9LCBkZXRhY2g6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgIGEuYXBwbHlNYXRyaXgoYi5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgIGIucmVtb3ZlKGEpO1xyXG4gICAgICAgICAgICBjLmFkZChhKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXR0YWNoOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBTO1xyXG4gICAgICAgICAgICBkLmdldEludmVyc2UoYy5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgIGEuYXBwbHlNYXRyaXgoZCk7XHJcbiAgICAgICAgICAgIGIucmVtb3ZlKGEpO1xyXG4gICAgICAgICAgICBjLmFkZChhKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBsLldpcmVmcmFtZUdlb21ldHJ5ID0gT2I7XHJcbiAgICBsLlBhcmFtZXRyaWNHZW9tZXRyeSA9IEhjO1xyXG4gICAgbC5QYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkgPSBQYjtcclxuICAgIGwuVGV0cmFoZWRyb25HZW9tZXRyeSA9IEpjO1xyXG4gICAgbC5UZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gUWI7XHJcbiAgICBsLk9jdGFoZWRyb25HZW9tZXRyeSA9IEtjO1xyXG4gICAgbC5PY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBvYjtcclxuICAgIGwuSWNvc2FoZWRyb25HZW9tZXRyeSA9IExjO1xyXG4gICAgbC5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gUmI7XHJcbiAgICBsLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gTWM7XHJcbiAgICBsLkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gU2I7XHJcbiAgICBsLlBvbHloZWRyb25HZW9tZXRyeSA9IEljO1xyXG4gICAgbC5Qb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBCYTtcclxuICAgIGwuVHViZUdlb21ldHJ5ID0gTmM7XHJcbiAgICBsLlR1YmVCdWZmZXJHZW9tZXRyeSA9IFRiO1xyXG4gICAgbC5Ub3J1c0tub3RHZW9tZXRyeSA9XHJcbiAgICAgICAgT2M7XHJcbiAgICBsLlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5ID0gVWI7XHJcbiAgICBsLlRvcnVzR2VvbWV0cnkgPSBQYztcclxuICAgIGwuVG9ydXNCdWZmZXJHZW9tZXRyeSA9IFZiO1xyXG4gICAgbC5UZXh0R2VvbWV0cnkgPSBRYztcclxuICAgIGwuU3BoZXJlR2VvbWV0cnkgPSBSYztcclxuICAgIGwuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBwYjtcclxuICAgIGwuUmluZ0dlb21ldHJ5ID0gU2M7XHJcbiAgICBsLlJpbmdCdWZmZXJHZW9tZXRyeSA9IFdiO1xyXG4gICAgbC5QbGFuZUdlb21ldHJ5ID0gQWM7XHJcbiAgICBsLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBsYjtcclxuICAgIGwuTGF0aGVHZW9tZXRyeSA9IFRjO1xyXG4gICAgbC5MYXRoZUJ1ZmZlckdlb21ldHJ5ID0gWGI7XHJcbiAgICBsLlNoYXBlR2VvbWV0cnkgPSBZYjtcclxuICAgIGwuU2hhcGVCdWZmZXJHZW9tZXRyeSA9IFpiO1xyXG4gICAgbC5FeHRydWRlR2VvbWV0cnkgPSBMYTtcclxuICAgIGwuRWRnZXNHZW9tZXRyeSA9ICRiO1xyXG4gICAgbC5Db25lR2VvbWV0cnkgPSBVYztcclxuICAgIGwuQ29uZUJ1ZmZlckdlb21ldHJ5ID0gVmM7XHJcbiAgICBsLkN5bGluZGVyR2VvbWV0cnkgPSBxYjtcclxuICAgIGwuQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSA9IFZhO1xyXG4gICAgbC5DaXJjbGVHZW9tZXRyeSA9IFdjO1xyXG4gICAgbC5DaXJjbGVCdWZmZXJHZW9tZXRyeSA9IGFjO1xyXG4gICAgbC5Cb3hHZW9tZXRyeSA9XHJcbiAgICAgICAgSWI7XHJcbiAgICBsLkJveEJ1ZmZlckdlb21ldHJ5ID0ga2I7XHJcbiAgICBsLlNoYWRvd01hdGVyaWFsID0gYmM7XHJcbiAgICBsLlNwcml0ZU1hdGVyaWFsID0gbmI7XHJcbiAgICBsLlJhd1NoYWRlck1hdGVyaWFsID0gY2M7XHJcbiAgICBsLlNoYWRlck1hdGVyaWFsID0gSGE7XHJcbiAgICBsLlBvaW50c01hdGVyaWFsID0gT2E7XHJcbiAgICBsLk11bHRpTWF0ZXJpYWwgPSBYYztcclxuICAgIGwuTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSByYjtcclxuICAgIGwuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSBRYTtcclxuICAgIGwuTWVzaFBob25nTWF0ZXJpYWwgPSBDYTtcclxuICAgIGwuTWVzaFRvb25NYXRlcmlhbCA9IHNiO1xyXG4gICAgbC5NZXNoTm9ybWFsTWF0ZXJpYWwgPSB0YjtcclxuICAgIGwuTWVzaExhbWJlcnRNYXRlcmlhbCA9IHViO1xyXG4gICAgbC5NZXNoRGVwdGhNYXRlcmlhbCA9IGFiO1xyXG4gICAgbC5NZXNoQmFzaWNNYXRlcmlhbCA9IEthO1xyXG4gICAgbC5MaW5lRGFzaGVkTWF0ZXJpYWwgPSB2YjtcclxuICAgIGwuTGluZUJhc2ljTWF0ZXJpYWwgPSBpYTtcclxuICAgIGwuTWF0ZXJpYWwgPSBYO1xyXG4gICAgbC5GbG9hdDY0QnVmZmVyQXR0cmlidXRlID0gemM7XHJcbiAgICBsLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgPSB6O1xyXG4gICAgbC5VaW50MzJCdWZmZXJBdHRyaWJ1dGUgPSBqYjtcclxuICAgIGwuSW50MzJCdWZmZXJBdHRyaWJ1dGUgPVxyXG4gICAgICAgIHljO1xyXG4gICAgbC5VaW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBpYjtcclxuICAgIGwuSW50MTZCdWZmZXJBdHRyaWJ1dGUgPSB4YztcclxuICAgIGwuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlID0gd2M7XHJcbiAgICBsLlVpbnQ4QnVmZmVyQXR0cmlidXRlID0gdmM7XHJcbiAgICBsLkludDhCdWZmZXJBdHRyaWJ1dGUgPSB1YztcclxuICAgIGwuQnVmZmVyQXR0cmlidXRlID0gVTtcclxuICAgIGwuUkVWSVNJT04gPSBcIjg0XCI7XHJcbiAgICBsLk1PVVNFID0ge0xFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDJ9O1xyXG4gICAgbC5DdWxsRmFjZU5vbmUgPSAwO1xyXG4gICAgbC5DdWxsRmFjZUJhY2sgPSAxO1xyXG4gICAgbC5DdWxsRmFjZUZyb250ID0gMjtcclxuICAgIGwuQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xyXG4gICAgbC5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XHJcbiAgICBsLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XHJcbiAgICBsLkJhc2ljU2hhZG93TWFwID0gMDtcclxuICAgIGwuUENGU2hhZG93TWFwID0gMTtcclxuICAgIGwuUENGU29mdFNoYWRvd01hcCA9IDI7XHJcbiAgICBsLkZyb250U2lkZSA9IDA7XHJcbiAgICBsLkJhY2tTaWRlID0gMTtcclxuICAgIGwuRG91YmxlU2lkZSA9IDI7XHJcbiAgICBsLkZsYXRTaGFkaW5nID0gMTtcclxuICAgIGwuU21vb3RoU2hhZGluZyA9IDI7XHJcbiAgICBsLk5vQ29sb3JzID0gMDtcclxuICAgIGwuRmFjZUNvbG9ycyA9IDE7XHJcbiAgICBsLlZlcnRleENvbG9ycyA9XHJcbiAgICAgICAgMjtcclxuICAgIGwuTm9CbGVuZGluZyA9IDA7XHJcbiAgICBsLk5vcm1hbEJsZW5kaW5nID0gMTtcclxuICAgIGwuQWRkaXRpdmVCbGVuZGluZyA9IDI7XHJcbiAgICBsLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xyXG4gICAgbC5NdWx0aXBseUJsZW5kaW5nID0gNDtcclxuICAgIGwuQ3VzdG9tQmxlbmRpbmcgPSA1O1xyXG4gICAgbC5BZGRFcXVhdGlvbiA9IDEwMDtcclxuICAgIGwuU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcclxuICAgIGwuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XHJcbiAgICBsLk1pbkVxdWF0aW9uID0gMTAzO1xyXG4gICAgbC5NYXhFcXVhdGlvbiA9IDEwNDtcclxuICAgIGwuWmVyb0ZhY3RvciA9IDIwMDtcclxuICAgIGwuT25lRmFjdG9yID0gMjAxO1xyXG4gICAgbC5TcmNDb2xvckZhY3RvciA9IDIwMjtcclxuICAgIGwuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcclxuICAgIGwuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcbiAgICBsLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcbiAgICBsLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG4gICAgbC5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG4gICAgbC5Ec3RDb2xvckZhY3RvciA9IDIwODtcclxuICAgIGwuT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcclxuICAgIGwuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcclxuICAgIGwuTmV2ZXJEZXB0aCA9XHJcbiAgICAgICAgMDtcclxuICAgIGwuQWx3YXlzRGVwdGggPSAxO1xyXG4gICAgbC5MZXNzRGVwdGggPSAyO1xyXG4gICAgbC5MZXNzRXF1YWxEZXB0aCA9IDM7XHJcbiAgICBsLkVxdWFsRGVwdGggPSA0O1xyXG4gICAgbC5HcmVhdGVyRXF1YWxEZXB0aCA9IDU7XHJcbiAgICBsLkdyZWF0ZXJEZXB0aCA9IDY7XHJcbiAgICBsLk5vdEVxdWFsRGVwdGggPSA3O1xyXG4gICAgbC5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XHJcbiAgICBsLk1peE9wZXJhdGlvbiA9IDE7XHJcbiAgICBsLkFkZE9wZXJhdGlvbiA9IDI7XHJcbiAgICBsLk5vVG9uZU1hcHBpbmcgPSAwO1xyXG4gICAgbC5MaW5lYXJUb25lTWFwcGluZyA9IDE7XHJcbiAgICBsLlJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xyXG4gICAgbC5VbmNoYXJ0ZWQyVG9uZU1hcHBpbmcgPSAzO1xyXG4gICAgbC5DaW5lb25Ub25lTWFwcGluZyA9IDQ7XHJcbiAgICBsLlVWTWFwcGluZyA9IDMwMDtcclxuICAgIGwuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xyXG4gICAgbC5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XHJcbiAgICBsLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xyXG4gICAgbC5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcclxuICAgIGwuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDU7XHJcbiAgICBsLkN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xyXG4gICAgbC5DdWJlVVZSZWZyYWN0aW9uTWFwcGluZyA9IDMwNztcclxuICAgIGwuUmVwZWF0V3JhcHBpbmcgPSAxRTM7XHJcbiAgICBsLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xyXG4gICAgbC5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcclxuICAgIGwuTmVhcmVzdEZpbHRlciA9IDEwMDM7XHJcbiAgICBsLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcclxuICAgIGwuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XHJcbiAgICBsLkxpbmVhckZpbHRlciA9IDEwMDY7XHJcbiAgICBsLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xyXG4gICAgbC5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xyXG4gICAgbC5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcclxuICAgIGwuQnl0ZVR5cGUgPSAxMDEwO1xyXG4gICAgbC5TaG9ydFR5cGUgPSAxMDExO1xyXG4gICAgbC5VbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XHJcbiAgICBsLkludFR5cGUgPSAxMDEzO1xyXG4gICAgbC5VbnNpZ25lZEludFR5cGUgPSAxMDE0O1xyXG4gICAgbC5GbG9hdFR5cGUgPSAxMDE1O1xyXG4gICAgbC5IYWxmRmxvYXRUeXBlID0gMTAxNjtcclxuICAgIGwuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcclxuICAgIGwuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxODtcclxuICAgIGwuVW5zaWduZWRTaG9ydDU2NVR5cGUgPVxyXG4gICAgICAgIDEwMTk7XHJcbiAgICBsLlVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XHJcbiAgICBsLkFscGhhRm9ybWF0ID0gMTAyMTtcclxuICAgIGwuUkdCRm9ybWF0ID0gMTAyMjtcclxuICAgIGwuUkdCQUZvcm1hdCA9IDEwMjM7XHJcbiAgICBsLkx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XHJcbiAgICBsLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyNTtcclxuICAgIGwuUkdCRUZvcm1hdCA9IDEwMjM7XHJcbiAgICBsLkRlcHRoRm9ybWF0ID0gMTAyNjtcclxuICAgIGwuRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcclxuICAgIGwuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xyXG4gICAgbC5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xyXG4gICAgbC5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xyXG4gICAgbC5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xyXG4gICAgbC5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XHJcbiAgICBsLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcclxuICAgIGwuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcclxuICAgIGwuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcclxuICAgIGwuUkdCX0VUQzFfRm9ybWF0ID0gMjE1MTtcclxuICAgIGwuTG9vcE9uY2UgPSAyMjAwO1xyXG4gICAgbC5Mb29wUmVwZWF0ID0gMjIwMTtcclxuICAgIGwuTG9vcFBpbmdQb25nID1cclxuICAgICAgICAyMjAyO1xyXG4gICAgbC5JbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcclxuICAgIGwuSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xyXG4gICAgbC5JbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XHJcbiAgICBsLlplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xyXG4gICAgbC5aZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xyXG4gICAgbC5XcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcclxuICAgIGwuVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xyXG4gICAgbC5UcmlhbmdsZVN0cmlwRHJhd01vZGUgPSAxO1xyXG4gICAgbC5UcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcclxuICAgIGwuTGluZWFyRW5jb2RpbmcgPSAzRTM7XHJcbiAgICBsLnNSR0JFbmNvZGluZyA9IDMwMDE7XHJcbiAgICBsLkdhbW1hRW5jb2RpbmcgPSAzMDA3O1xyXG4gICAgbC5SR0JFRW5jb2RpbmcgPSAzMDAyO1xyXG4gICAgbC5Mb2dMdXZFbmNvZGluZyA9IDMwMDM7XHJcbiAgICBsLlJHQk03RW5jb2RpbmcgPSAzMDA0O1xyXG4gICAgbC5SR0JNMTZFbmNvZGluZyA9IDMwMDU7XHJcbiAgICBsLlJHQkRFbmNvZGluZyA9IDMwMDY7XHJcbiAgICBsLkJhc2ljRGVwdGhQYWNraW5nID0gMzIwMDtcclxuICAgIGwuUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XHJcbiAgICBsLkN1YmVHZW9tZXRyeSA9IEliO1xyXG4gICAgbC5GYWNlNCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBoYShhLCBiLCBjLCBlLCBmLCBnKVxyXG4gICAgfTtcclxuICAgIGwuTGluZVN0cmlwID0gMDtcclxuICAgIGwuTGluZVBpZWNlcyA9IDE7XHJcbiAgICBsLk1lc2hGYWNlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5NdWx0aU1hdGVyaWFsLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IFhjKGEpXHJcbiAgICB9O1xyXG4gICAgbC5Qb2ludENsb3VkID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IE1iKGEsIGIpXHJcbiAgICB9O1xyXG4gICAgbC5QYXJ0aWNsZSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuUGFydGljbGUgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5TcHJpdGUuXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGMoYSlcclxuICAgIH07XHJcbiAgICBsLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYihhLCBiKVxyXG4gICAgfTtcclxuICAgIGwuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYShhKVxyXG4gICAgfTtcclxuICAgIGwuUGFydGljbGVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYShhKVxyXG4gICAgfTtcclxuICAgIGwuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IE9hKGEpXHJcbiAgICB9O1xyXG4gICAgbC5WZXJ0ZXggPSBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlZlcnRleCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuVmVjdG9yMyBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IHEoYSwgYiwgYylcclxuICAgIH07XHJcbiAgICBsLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoKS5zZXREeW5hbWljKCB0cnVlICkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIChuZXcgVShhLCBiKSkuc2V0RHluYW1pYyghMClcclxuICAgIH07XHJcbiAgICBsLkludDhBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQ4QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB1YyhhLCBiKVxyXG4gICAgfTtcclxuICAgIGwuVWludDhBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlVpbnQ4QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IHZjKGEsXHJcbiAgICAgICAgICAgIGIpXHJcbiAgICB9O1xyXG4gICAgbC5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgd2MoYSwgYilcclxuICAgIH07XHJcbiAgICBsLkludDE2QXR0cmlidXRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5JbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB4YyhhLCBiKVxyXG4gICAgfTtcclxuICAgIGwuVWludDE2QXR0cmlidXRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5VaW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50MTZCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IGliKGEsIGIpXHJcbiAgICB9O1xyXG4gICAgbC5JbnQzMkF0dHJpYnV0ZSA9XHJcbiAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuSW50MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHljKGEsIGIpXHJcbiAgICAgICAgfTtcclxuICAgIGwuVWludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5VaW50MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IGpiKGEsIGIpXHJcbiAgICB9O1xyXG4gICAgbC5GbG9hdDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5GbG9hdDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgeihhLCBiKVxyXG4gICAgfTtcclxuICAgIGwuRmxvYXQ2NEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IHpjKGEsIGIpXHJcbiAgICB9O1xyXG4gICAgbC5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBYZTtcclxuICAgIGwuU3BsaW5lQ3VydmUzID0gWWU7XHJcbiAgICBsLlNwbGluZSA9IHdlO1xyXG4gICAgbC5Cb3VuZGluZ0JveEhlbHBlciA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgaGFzIGJlZW4gZGVwcmVjYXRlZC4gQ3JlYXRpbmcgYSBUSFJFRS5Cb3hIZWxwZXIgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByYyhhLCBiKVxyXG4gICAgfTtcclxuICAgIGwuRWRnZXNIZWxwZXIgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkVkZ2VzSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5FZGdlc0dlb21ldHJ5IGluc3RlYWQuXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgZ2EobmV3ICRiKGEuZ2VvbWV0cnkpLCBuZXcgaWEoe2NvbG9yOiB2b2lkIDAgIT09IGIgPyBiIDogMTY3NzcyMTV9KSlcclxuICAgIH07XHJcbiAgICBsLldpcmVmcmFtZUhlbHBlciA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2lyZWZyYW1lSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IGdhKG5ldyBPYihhLmdlb21ldHJ5KSwgbmV3IGlhKHtjb2xvcjogdm9pZCAwICE9PSBiID8gYiA6IDE2Nzc3MjE1fSkpXHJcbiAgICB9O1xyXG4gICAgbC5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlhIUkxvYWRlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkZpbGVMb2FkZXIuXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgc2EoYSlcclxuICAgIH07XHJcbiAgICBsLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5EYXRhVGV4dHVyZUxvYWRlci5cIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhZShhKVxyXG4gICAgfTtcclxuICAgIGwuR2VvbWV0cnlVdGlscyA9IHtcclxuICAgICAgICBtZXJnZTogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgdmFyIGQ7XHJcbiAgICAgICAgICAgIGIuaXNNZXNoICYmIChiLm1hdHJpeEF1dG9VcGRhdGUgJiYgYi51cGRhdGVNYXRyaXgoKSwgZCA9IGIubWF0cml4LCBiID0gYi5nZW9tZXRyeSk7XHJcbiAgICAgICAgICAgIGEubWVyZ2UoYiwgZCwgYylcclxuICAgICAgICB9LCBjZW50ZXI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5jZW50ZXIoKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBsLkltYWdlVXRpbHMgPSB7XHJcbiAgICAgICAgY3Jvc3NPcmlnaW46IHZvaWQgMCwgbG9hZFRleHR1cmU6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLlRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgdGQ7XHJcbiAgICAgICAgICAgIGUuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7XHJcbiAgICAgICAgICAgIGEgPSBlLmxvYWQoYSwgYywgdm9pZCAwLCBkKTtcclxuICAgICAgICAgICAgYiAmJiAoYS5tYXBwaW5nID0gYik7XHJcbiAgICAgICAgICAgIHJldHVybiBhXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBiZTtcclxuICAgICAgICAgICAgZS5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcclxuICAgICAgICAgICAgYSA9IGUubG9hZChhLCBjLCB2b2lkIDAsIGQpO1xyXG4gICAgICAgICAgICBiICYmIChhLm1hcHBpbmcgPSBiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCBsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC5cIilcclxuICAgICAgICB9LCBsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLlwiKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBsLlByb2plY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLlwiKTtcclxuICAgICAgICB0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5Qcm9qZWN0b3I6IC5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci5wcm9qZWN0KCkuXCIpO1xyXG4gICAgICAgICAgICBhLnByb2plY3QoYilcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS5cIik7XHJcbiAgICAgICAgICAgIGEudW5wcm9qZWN0KGIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGwuQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanNcIik7XHJcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImNhbnZhc1wiKTtcclxuICAgICAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pXHJcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdmVuZG9yL3RocmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==