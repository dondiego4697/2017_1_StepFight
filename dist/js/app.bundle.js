/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 75);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__http_Http__ = __webpack_require__(10);
/**
 * Created by Denis on 05.03.2017.
 */

class UserService {
    constructor() {
        this.http = new __WEBPACK_IMPORTED_MODULE_0__http_Http__["a" /* default */]();
        this.url = this.http.BaseUrl;
    }

    getUser() {
        const address = `${this.url}/user/get`;
        return new Promise((resolve, reject) => {
            this._createRequest(address, null, 'GET', null).then(response => {
                resolve(response.user);
            }).catch(e => {
                reject(e);
            });
        });
    }

    login(body) {
        const address = `${this.url}/user/login`;
        let headers = {'Content-Type': 'application/json'};
        return new Promise((resolve, reject) => {
            this._createRequest(address, headers, 'POST', body).then(response => {
                resolve(response.user);
            }).catch(e => {
                reject(e);
            });
        });
    }

    signup(body) {
        const address = `${this.url}/user/signup`;
        let headers = {'Content-Type': 'application/json'};
        return new Promise((resolve, reject) => {
            this._createRequest(address, headers, 'POST', body).then(response => {
                resolve({result: 'success'});
            }).catch(e => {
                if(!e){
                    reject({result: 'no-conn'});
                } else {
                    reject({result: 'error'});
                }
            });
        });
    }

    getLeaders() {
        const address = `${this.url}/user/leaders`;
        return new Promise((resolve, reject) => {
            this._createRequest(address, null, 'GET', null).then(response => {
                resolve(response);
            }).catch(e => {
                reject(e);
            });
        });
    }

    logOutUser() {
        const address = `${this.url}/user/logout`;
        return new Promise((resolve, reject) => {
            this._createRequest(address, null, 'GET', null).then(response => {
                resolve(response);
            }).catch(e => {
                reject(e);
            });
        });
    }

    _createRequest(address, headers = {}, type = 'GET', body = {}) {
        const http = this.http;
        return new Promise(function (resolve, reject) {
            http.request(address, headers, type, body).then(response => {
                if (response.status === '200 OK') {
                    resolve(response);
                } else {
                    console.log(response.status);
                    reject(response);
                }
            }).catch(e => {
                console.error(e.status);
                reject({});
            });
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UserService;



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 17.03.2017.
 */
class BaseView {

    constructor(node) {
        this.node = node;
    }

    destroyView(){
        while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BaseView;


/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, exports) {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 07.03.2017.
 */

class ProgressBar {
    constructor() {
        this.el = document.createElement('div');
    }

    getElem() {
        this.el.setAttribute('class', 'loader');
        return this.el;
    }

    getElemParent() {
        this.el.setAttribute('class', 'loader_parent');
        return this.el;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ProgressBar;


/***/ }),
/* 6 */,
/* 7 */,
/* 8 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__support_router_RouterUrls__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__GameStates__ = __webpack_require__(64);
/**
 * Created by Denis on 06.03.2017.
 */




class Storage {
    constructor(){
        this.urlsObj = new __WEBPACK_IMPORTED_MODULE_0__support_router_RouterUrls__["a" /* default */]();
        this.gameStatesObj = new __WEBPACK_IMPORTED_MODULE_1__GameStates__["a" /* default */]();
        this.objUser = null;
        Storage.__instance = this;
    }

    set user(user){
        this.objUser = user;
    }

    get user(){
        return this.objUser;
    }

    get urls(){
        return this.urlsObj;
    }

    get gameStates(){
        return this.gameStatesObj;
    }
}

const storage = new Storage();
/* harmony default export */ __webpack_exports__["a"] = storage;


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 05.03.2017.
 */

class Http {
    constructor() {
        if (Http.instance) {
            return Http.instance;
        }

        this._baseUrl = 'http://localhost:8000/api';
        //this._baseUrl = 'https://tp-server-java.herokuapp.com/api';

        Http.instance = this;
    }

    get BaseUrl() {
        return this._baseUrl;
    }

    set BaseUrl(value) {
        this._baseUrl = value;
    }

    request(address = '', headers = {}, type = 'GET', body = {}) {
        let fetchObj = {
            method: type,
            mode: 'cors',
            headers: headers,
            credentials: 'include'
        };
        if (body) {
            fetchObj.body = JSON.stringify(body);
        }

        return new Promise(function (resolve, reject) {
            fetch(address, fetchObj).then(response => {
                return response.json();
            }).then(json => {
                resolve(json);
            }).catch(err => {
                reject({});
                console.error(err || err.statusText);
            });
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Http;



/***/ }),
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() { return SpotLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function() { return LightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryIdCount", function() { return GeometryIdCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face3", function() { return Face3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return _Math; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MorphBlendMesh", function() { return MorphBlendMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexNormalsHelper", function() { return VertexNormalsHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLightHelper", function() { return RectAreaLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceNormalsHelper", function() { return FaceNormalsHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face4", function() { return Face4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() { return SplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spline", function() { return Spline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() { return GeometryUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Projector", function() { return Projector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	( function () {

		Object.assign = function ( target ) {

			'use strict';

			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			var output = Object( target );

			for ( var index = 1; index < arguments.length; index ++ ) {

				var source = arguments[ index ];

				if ( source !== undefined && source !== null ) {

					for ( var nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	} )();

}

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

EventDispatcher.prototype = {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [], i = 0;
			var length = listenerArray.length;

			for ( i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

var REVISION = '84';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RGB_S3TC_DXT1_Format = 2001;
var RGBA_S3TC_DXT1_Format = 2002;
var RGBA_S3TC_DXT3_Format = 2003;
var RGBA_S3TC_DXT5_Format = 2004;
var RGB_PVRTC_4BPPV1_Format = 2100;
var RGB_PVRTC_2BPPV1_Format = 2101;
var RGBA_PVRTC_4BPPV1_Format = 2102;
var RGBA_PVRTC_2BPPV1_Format = 2103;
var RGB_ETC1_Format = 2151;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function generateUUID() {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * _Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * _Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

}

Vector2.prototype = {

	constructor: Vector2,

	isVector2: true,

	get width() {

		return this.x;

	},

	set width( value ) {

		this.x = value;

	},

	get height() {

		return this.y;

	},

	set height( value ) {

		this.y = value;

	},

	//

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector2();
				max = new Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( this.y, this.x );

		if ( angle < 0 ) angle += 2 * Math.PI;

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	distanceToManhattan: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var textureId = 0;

function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : RGBAFormat;
	this.type = type !== undefined ? type : UnsignedByteType;

	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype = {

	constructor: Texture,

	isTexture: true,

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = _Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== UVMapping ) return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

};

Object.assign( Texture.prototype, EventDispatcher.prototype );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

}

Vector4.prototype = {

	constructor: Vector4,

	isVector4: true,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector4();
				max = new Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

};

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget( width, height, options ) {

	this.uuid = _Math.generateUUID();

	this.width = width;
	this.height = height;

	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new Vector4( 0, 0, width, height );

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

}

WebGLRenderTarget.prototype = {

	constructor: WebGLRenderTarget,

	isWebGLRenderTarget: true,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype );

/**
 * @author alteredq / http://alteredqualia.com
 */

function WebGLRenderTargetCube( width, height, options ) {

	WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	this.activeMipMapLevel = 0;

}

WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Quaternion.prototype = {

	constructor: Quaternion,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( (euler && euler.isEuler) === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		var order = euler.order;

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function setFromUnitVectors( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			return this.normalize();

		};

	}(),

	inverse: function () {

		return this.conjugate().normalize();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

Object.assign( Quaternion, {

	slerp: function( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function(
			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Vector3.prototype = {

	constructor: Vector3,

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( (euler && euler.isEuler) === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new Quaternion();

			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new Quaternion();

			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
		var w =  e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ];

		return this.divideScalar( w );

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyMatrix4( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyMatrix4( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector3();
				max = new Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( vector ) {

		var scalar = vector.dot( this ) / vector.lengthSq();

		return this.copy( vector ).multiplyScalar( scalar );

	},

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		};

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		};

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

		// clamp, to handle numerical problems

		return Math.acos( _Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	distanceToManhattan: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function( s ) {

		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

		this.x = sinPhiRadius * Math.sin( s.theta );
		this.y = Math.cos( s.phi ) * s.radius;
		this.z = sinPhiRadius * Math.cos( s.theta );

		return this;

	},

	setFromCylindrical: function( c ) {

		this.x = c.radius * Math.sin( c.theta );
		this.y = c.y;
		this.z = c.radius * Math.cos( c.theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		return this.setFromMatrixColumn( m, 3 );

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		if ( typeof m === 'number' ) {

			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
			var temp = m;
			m = index;
			index = temp;

		}

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Matrix4.prototype = {

	constructor: Matrix4,

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1;

		return function extractRotation( m ) {

			if ( v1 === undefined ) v1 = new Vector3();

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( (euler && euler.isEuler) === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x, y, z;

		return function lookAt( eye, target, up ) {

			if ( x === undefined ) {

				x = new Vector3();
				y = new Vector3();
				z = new Vector3();

			}

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.lengthSq() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.lengthSq() === 0 ) {

				z.z += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToBufferAttribute: function () {

		var v1;

		return function applyToBufferAttribute( attribute ) {

			if ( v1 === undefined ) v1 = new Vector3();

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix4( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector, matrix;

		return function decompose( position, quaternion, scale ) {

			if ( vector === undefined ) {

				vector = new Vector3();
				matrix = new Matrix4();

			}

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {

				sx = - sx;

			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makePerspective: function ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

}

CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty( CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

/**
 * @author tschw
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyCubeTexture = new CubeTexture();

// --- Base for inner nodes (including the root) ---

function UniformContainer() {

	this.seq = [];
	this.map = {};

}

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = [];

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	var firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	var n = nBlocks * blockSize,
		r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

// Texture unit allocation

function allocTexUnits( renderer, n ) {

	var r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( var i = 0; i !== n; ++ i )
		r[ i ] = renderer.allocTextureUnit();

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

// Single float vector (from flat array or THREE.VectorN)

function setValue2fv( gl, v ) {

	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
	else gl.uniform2f( this.addr, v.x, v.y );

}

function setValue3fv( gl, v ) {

	if ( v.x !== undefined )
		gl.uniform3f( this.addr, v.x, v.y, v.z );
	else if ( v.r !== undefined )
		gl.uniform3f( this.addr, v.r, v.g, v.b );
	else
		gl.uniform3fv( this.addr, v );

}

function setValue4fv( gl, v ) {

	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

}

// Single matrix (from flat array or MatrixN)

function setValue2fm( gl, v ) {

	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

}

function setValue3fm( gl, v ) {

	gl.uniformMatrix3fv( this.addr, false, v.elements || v );

}

function setValue4fm( gl, v ) {

	gl.uniformMatrix4fv( this.addr, false, v.elements || v );

}

// Single texture (2D / Cube)

function setValueT1( gl, v, renderer ) {

	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTexture2D( v || emptyTexture, unit );

}

function setValueT6( gl, v, renderer ) {

	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1f; // FLOAT
		case 0x8b50: return setValue2fv; // _VEC2
		case 0x8b51: return setValue3fv; // _VEC3
		case 0x8b52: return setValue4fv; // _VEC4

		case 0x8b5a: return setValue2fm; // _MAT2
		case 0x8b5b: return setValue3fm; // _MAT3
		case 0x8b5c: return setValue4fm; // _MAT4

		case 0x8b5e: return setValueT1; // SAMPLER_2D
		case 0x8b60: return setValueT6; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// Array of scalars

function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

// Array of vectors (flat or from THREE classes)

function setValueV2a( gl, v ) {

	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

}

function setValueV3a( gl, v ) {

	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

}

function setValueV4a( gl, v ) {

	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

}

// Array of matrices (flat or from THREE clases)

function setValueM2a( gl, v ) {

	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

}

function setValueM3a( gl, v ) {

	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

}

function setValueM4a( gl, v ) {

	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

}

// Array of textures (2D / Cube)

function setValueT1a( gl, v, renderer ) {

	var n = v.length,
		units = allocTexUnits( renderer, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6a( gl, v, renderer ) {

	var n = v.length,
		units = allocTexUnits( renderer, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1fv; // FLOAT
		case 0x8b50: return setValueV2a; // _VEC2
		case 0x8b51: return setValueV3a; // _VEC3
		case 0x8b52: return setValueV4a; // _VEC4

		case 0x8b5a: return setValueM2a; // _MAT2
		case 0x8b5b: return setValueM3a; // _MAT3
		case 0x8b5c: return setValueM4a; // _MAT4

		case 0x8b5e: return setValueT1a; // SAMPLER_2D
		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function StructuredUniform( id ) {

	this.id = id;

	UniformContainer.call( this ); // mix-in

}

StructuredUniform.prototype.setValue = function( gl, value ) {

	// Note: Don't need an extra 'renderer' parameter, since samplers
	// are not allowed in structured uniforms.

	var seq = this.seq;

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		u.setValue( gl, value[ u.id ] );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	var path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	for (; ;) {

		var match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex,

			id = match[ 1 ],
			idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined ||
				subscript === '[' && matchEnd + 2 === pathLength ) {
			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {
			// step into inner node / create it in case it doesn't exist

			var map = container.map,
				next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program, renderer ) {

	UniformContainer.call( this );

	this.renderer = renderer;

	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

	for ( var i = 0; i < n; ++ i ) {

		var info = gl.getActiveUniform( program, i ),
			path = info.name,
			addr = gl.getUniformLocation( program, path );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function( gl, name, value ) {

	var u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

};

WebGLUniforms.prototype.set = function( gl, object, name ) {

	var u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

};

WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

	var v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function( gl, seq, values, renderer ) {

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {
			// note: always updating when .needsUpdate is undefined

			u.setValue( gl, v.value, renderer );

		}

	}

};

WebGLUniforms.seqWithValue = function( seq, values ) {

	var r = [];

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

/**
 * Uniform Utilities
 */

var UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src && ( parameter_src.isColor ||
					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
					parameter_src.isTexture ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "\nvec3 transformed = vec3( position );\n";

var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";

var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

var ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars: lights_pars,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_template: lights_template,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_flip: normal_flip,
	normal_fragment: normal_fragment,
	normalmap_pars_fragment: normalmap_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert
};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Color( r, g, b ) {

	if ( g === undefined && b === undefined ) {

		// r is THREE.Color, hex or string
		return this.set( r );

	}

	return this.setRGB( r, g, b );

}

Color.prototype = {

	constructor: Color,

	isColor: true,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function setHSL( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = _Math.euclideanModulo( h, 1 );
			s = _Math.clamp( s, 0, 1 );
			l = _Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	sub: function( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	},

	toJSON: function () {

		return this.getHex();

	}

};

var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.generateMipmaps  = false;
	this.flipY = false;
	this.unpackAlignment = 1;

}

DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;

/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

		specularMap: { value: null },
		alphaMap: { value: null },

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib = {

	basic: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 0.5 },
				metalness: { value: 0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	points: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	equirect: {

		uniforms: {
			tEquirect: { value: null },
			tFlip: { value: - 1 }
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: {
			lightPos: { value: new Vector3() }
		},

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	}

};

ShaderLib.physical = {

	uniforms: UniformsUtils.merge( [
		ShaderLib.standard.uniforms,
		{
			clearCoat: { value: 0 },
			clearCoatRoughness: { value: 0 }
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

/**
 * @author bhouston / http://clara.io
 */

function Box2( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

}

Box2.prototype = {

	constructor: Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new Vector2();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new Vector2();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function LensFlarePlugin( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var shader, program, attributes, uniforms;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		shader = {

			vertexShader: [

				"uniform lowp int renderType;",

				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",

				"uniform sampler2D occlusionMap;",

				"attribute vec2 position;",
				"attribute vec2 uv;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					"vUV = uv;",

					"vec2 pos = position;",

					"if ( renderType == 2 ) {",

						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

						"vVisibility =        visibility.r / 9.0;",
						"vVisibility *= 1.0 - visibility.g / 9.0;",
						"vVisibility *=       visibility.b / 9.0;",
						"vVisibility *= 1.0 - visibility.a / 9.0;",

						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

					"}",

					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform lowp int renderType;",

				"uniform sampler2D map;",
				"uniform float opacity;",
				"uniform vec3 color;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					// pink square

					"if ( renderType == 0 ) {",

						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

					// restore

					"} else if ( renderType == 1 ) {",

						"gl_FragColor = texture2D( map, vUV );",

					// flare

					"} else {",

						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * vVisibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",

					"}",

				"}"

			].join( "\n" )

		};

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewport ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new Vector3();

		var invAspect = viewport.w / viewport.z,
			halfViewportWidth = viewport.z * 0.5,
			halfViewportHeight = viewport.w * 0.5;

		var size = 16 / viewport.w,
			scale = new Vector2( size * invAspect, size );

		var screenPosition = new Vector3( 1, 1, 0 ),
			screenPositionPixels = new Vector2( 1, 1 );

		var validArea = new Box2();

		validArea.min.set( viewport.x, viewport.y );
		validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		state.setDepthWrite( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewport.w;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyMatrix4( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

			// screen cull

			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewport.w;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture2D( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		state.setDepthWrite( true );

		renderer.resetGLState();

	};

	function createProgram( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

}

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function SpritePlugin( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new Vector3();
	var spriteRotation = new Quaternion();
	var spriteScale = new Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog.isFog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog.isFogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			if ( material.visible === false ) continue;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );

			if ( material.map ) {

				renderer.setTexture2D( material.map, 0 );

			} else {

				renderer.setTexture2D( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram() {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;
	this.lights = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this._needsUpdate = true;

}

Material.prototype = {

	constructor: Material,

	isMaterial: true,

	get needsUpdate() {

		return this._needsUpdate;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.update();
		this._needsUpdate = value;

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = meta === undefined;

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.4,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
		if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale.toArray();

		}
		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.shading !== SmoothShading ) data.shading = this.shading;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		data.skinning = this.skinning;
		data.morphTargets = this.morphTargets;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;
		this.lights = source.lights;

		this.blending = source.blending;
		this.side = source.side;
		this.shading = source.shading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.alphaTest = source.alphaTest;

		this.premultipliedAlpha = source.premultipliedAlpha;

		this.overdraw = source.overdraw;

		this.visible = source.visible;
		this.clipShadows = source.clipShadows;
		this.clipIntersection = source.clipIntersection;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();

		}

		this.clippingPlanes = dstPlanes;

		return this;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

Object.assign( Material.prototype, EventDispatcher.prototype );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = UniformsUtils.clone( source.uniforms );

	this.defines = source.defines;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

}

Box3.prototype = {

	constructor: Box3,

	isBox3: true,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromBufferAttribute: function ( attribute ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new Vector3();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function ( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	expandByObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new Vector3();

		return function expandByObject( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			object.traverse( function ( node ) {

				var i, l;

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			} );

			return this;

		};

	}(),

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	},

	intersectsSphere: ( function () {

		var closestPoint;

		return function intersectsSphere( sphere ) {

			if ( closestPoint === undefined ) closestPoint = new Vector3();

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, closestPoint );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		};

	} )(),

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= plane.constant && max >= plane.constant );

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new Vector3();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new Vector3();

		return function getBoundingSphere( optionalTarget ) {

			var result = optionalTarget || new Sphere();

			this.getCenter( result.center );

			result.radius = this.getSize( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if( this.isEmpty() ) this.makeEmpty();

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3()
		];

		return function applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere( center, radius ) {

	this.center = ( center !== undefined ) ? center : new Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

}

Sphere.prototype = {

	constructor: Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box;

		return function setFromPoints( points, optionalCenter ) {

			if ( box === undefined ) box = new Box3(); // see #10547

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).getCenter( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		// We use the following equation to compute the signed distance from
		// the center of the sphere to the plane.
		//
		// distance = q * n - d
		//
		// If this distance is greater than the radius of the sphere,
		// then there is no intersection.

		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new Vector3();

		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Matrix3.prototype = {

	constructor: Matrix3,

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	setFromMatrix4: function( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[  8 ],
			me[ 1 ], me[ 5 ], me[  9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToBufferAttribute: function () {

		var v1;

		return function applyToBufferAttribute( attribute ) {

			if ( v1 === undefined ) v1 = new Vector3();

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix3( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix && matrix.isMatrix4 ) {

			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();
		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	}

};

/**
 * @author bhouston / http://clara.io
 */

function Plane( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

}

Plane.prototype = {

	constructor: Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new Vector3();
		var v2 = new Vector3();

		return function setFromCoplanarPoints( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	intersectLine: function () {

		var v1 = new Vector3();

		return function intersectLine( line, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new Vector3();
		var m1 = new Matrix3();

		return function applyMatrix4( matrix, optionalNormalMatrix ) {

			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

			// transform normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			// recalculate constant (like in setFromNormalAndCoplanarPoint)
			this.constant = - referencePoint.dot( normal );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

function Frustum( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new Plane(),
		( p1 !== undefined ) ? p1 : new Plane(),
		( p2 !== undefined ) ? p2 : new Plane(),
		( p3 !== undefined ) ? p3 : new Plane(),
		( p4 !== undefined ) ? p4 : new Plane(),
		( p5 !== undefined ) ? p5 : new Plane()

	];

}

Frustum.prototype = {

	constructor: Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new Sphere();

		return function intersectsObject( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere )
				.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSprite: function () {

		var sphere = new Sphere();

		return function intersectsSprite( sprite ) {

			sphere.center.set( 0, 0, 0 );
			sphere.radius = 0.7071067811865476;
			sphere.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new Vector3(),
			p2 = new Vector3();

		return function intersectsBox( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

	var _gl = _renderer.context,
	_state = _renderer.state,
	_frustum = new Frustum(),
	_projScreenMatrix = new Matrix4(),

	_lightShadows = _lights.shadows,

	_shadowMapSize = new Vector2(),
	_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

	_lookTarget = new Vector3(),
	_lightPositionWorld = new Vector3(),

	_renderList = [],

	_MorphingFlag = 1,
	_SkinningFlag = 2,

	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

	_depthMaterials = new Array( _NumberOfMaterialVariants ),
	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

	_materialCache = {};

	var cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new Vector4(), new Vector4(), new Vector4(),
		new Vector4(), new Vector4(), new Vector4()
	];

	// init

	var depthMaterialTemplate = new MeshDepthMaterial();
	depthMaterialTemplate.depthPacking = RGBADepthPacking;
	depthMaterialTemplate.clipping = true;

	var distanceShader = ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = depthMaterialTemplate.clone();
		depthMaterial.morphTargets = useMorphing;
		depthMaterial.skinning = useSkinning;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new ShaderMaterial( {
			defines: {
				'USE_SHADOWMAP': ''
			},
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning,
			clipping: true
		} );

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.renderReverseSided = true;
	this.renderSingleSided = true;

	this.render = function ( scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( _lightShadows.length === 0 ) return;

		// Set GL state for depth map.
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.disable( _gl.BLEND );
		_state.setDepthTest( true );
		_state.setScissorTest( false );

		// render depth map

		var faceCount, isPointLight;

		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

			var light = _lightShadows[ i ];
			var shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			var shadowCamera = shadow.camera;

			_shadowMapSize.copy( shadow.mapSize );
			_shadowMapSize.min( _maxShadowMapSize );

			if ( light && light.isPointLight ) {

				faceCount = 6;
				isPointLight = true;

				var vpWidth = _shadowMapSize.x;
				var vpHeight = _shadowMapSize.y;

				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
				// negative X
				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
				// positive Z
				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
				// negative Z
				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
				// positive Y
				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
				// negative Y
				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				_shadowMapSize.x *= 4.0;
				_shadowMapSize.y *= 2.0;

			} else {

				faceCount = 1;
				isPointLight = false;

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadowCamera.updateProjectionMatrix();

			}

			if ( shadow.isSpotLightShadow ) {

				shadow.update( light );

			}

			// TODO (abelnation / sam-g-steel): is this needed?
			if (shadow && shadow.isRectAreaLightShadow ) {

				shadow.update( light );

			}

			var shadowMap = shadow.map;
			var shadowMatrix = shadow.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// render shadow map for each cube face (if omni-directional) or
			// run a single pass if not

			for ( var face = 0; face < faceCount; face ++ ) {

				if ( isPointLight ) {

					_lookTarget.copy( shadowCamera.position );
					_lookTarget.add( cubeDirections[ face ] );
					shadowCamera.up.copy( cubeUps[ face ] );
					shadowCamera.lookAt( _lookTarget );

					var vpDimensions = cube2DViewPorts[ face ];
					_state.viewport( vpDimensions );

				} else {

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );

				}

				shadowCamera.updateMatrixWorld();
				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, camera, shadowCamera );

				// render shadow map
				// render regular objects

				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

					var object = _renderList[ j ];
					var geometry = _objects.update( object );
					var material = object.material;

					if ( material && material.isMultiMaterial ) {

						var groups = geometry.groups;
						var materials = material.materials;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = materials[ group.materialIndex ];

							if ( groupMaterial.visible === true ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

		}

		// Restore GL state.
		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var result = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = false;

			if ( material.morphTargets ) {

				if ( geometry && geometry.isBufferGeometry ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				} else if ( geometry && geometry.isGeometry ) {

					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

				}

			}

			var useSkinning = object.isSkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			result = materialVariants[ variantIndex ];

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
			 material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		var side = material.side;

		if ( scope.renderSingleSided && side == DoubleSide ) {

			side = FrontSide;

		}

		if ( scope.renderReverseSided ) {

			if ( side === FrontSide ) side = BackSide;
			else if ( side === BackSide ) side = FrontSide;

		}

		result.side = side;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

			result.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return result;

	}

	function projectObject( object, camera, shadowCamera ) {

		if ( object.visible === false ) return;

		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

				var material = object.material;

				if ( material.visible === true ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( object );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, shadowCamera );

		}

	}

}

/**
 * @author bhouston / http://clara.io
 */

function Ray( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new Vector3();
	this.direction = ( direction !== undefined ) ? direction : new Vector3();

}

Ray.prototype = {

	constructor: Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	},

	recast: function () {

		var v1 = new Vector3();

		return function recast( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new Vector3();

		return function distanceSqToPoint( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new Vector3();
		var segDir = new Vector3();
		var diff = new Vector3();

		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),

	intersectSphere: function () {

		var v1 = new Vector3();

		return function intersectSphere( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );
			var tca = v1.dot( this.direction );
			var d2 = v1.dot( v1 ) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},



	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, optionalTarget ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectsBox: ( function () {

		var v = new Vector3();

		return function intersectsBox( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	} )(),

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new Vector3();
		var edge1 = new Vector3();
		var edge2 = new Vector3();
		var normal = new Vector3();

		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Euler.prototype = {

	constructor: Euler,

	isEuler: true,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = _Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function setFromQuaternion( q, order, update ) {

			if ( matrix === undefined ) matrix = new Matrix4();

			matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( matrix, order, update );

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new Quaternion();

		return function reorder( newOrder ) {

			q.setFromEuler( this );

			return this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1;

}

Layers.prototype = {

	constructor: Layers,

	set: function ( channel ) {

		this.mask = 1 << channel;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel );

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

var object3DId = 0;

function Object3D() {

	Object.defineProperty( this, 'id', { value: object3DId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new Vector3();
	var rotation = new Euler();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

	this.onBeforeRender = function () {};
	this.onAfterRender = function () {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = {

	constructor: Object3D,

	isObject3D: true,

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new Quaternion();

		return function rotateOnAxis( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function rotateX( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function rotateY( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function rotateZ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new Vector3();

		return function translateOnAxis( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function translateX( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function translateY( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function translateZ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new Matrix4();

		return function worldToLocal( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new Matrix4();

		return function lookAt( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new Vector3();
		var scale = new Vector3();

		return function getWorldQuaternion( optionalTarget ) {

			var result = optionalTarget || new Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new Quaternion();

		return function getWorldRotation( optionalTarget ) {

			var result = optionalTarget || new Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new Vector3();
		var quaternion = new Quaternion();

		return function getWorldScale( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new Quaternion();

		return function getWorldDirection( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		// meta is '' when called from JSON.stringify
		var isRootObject = ( meta === undefined || meta === '' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.4,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		if ( this.geometry !== undefined ) {

			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

			}

			object.geometry = this.geometry.uuid;

		}

		if ( this.material !== undefined ) {

			if ( meta.materials[ this.material.uuid ] === undefined ) {

				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

			}

			object.material = this.material.uuid;

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

};

Object.assign( Object3D.prototype, EventDispatcher.prototype );

/**
 * @author bhouston / http://clara.io
 */

function Line3( start, end ) {

	this.start = ( start !== undefined ) ? start : new Vector3();
	this.end = ( end !== undefined ) ? end : new Vector3();

}

Line3.prototype = {

	constructor: Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new Vector3();
		var startEnd = new Vector3();

		return function closestPointToPointParameter( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = _Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

};

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new Vector3();
	this.b = ( b !== undefined ) ? b : new Vector3();
	this.c = ( c !== undefined ) ? c : new Vector3();

}

Triangle.normal = function () {

	var v0 = new Vector3();

	return function normal( a, b, c, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
Triangle.barycoordFromPoint = function () {

	var v0 = new Vector3();
	var v1 = new Vector3();
	var v2 = new Vector3();

	return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new Vector3();

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

Triangle.containsPoint = function () {

	var v1 = new Vector3();

	return function containsPoint( point, a, b, c ) {

		var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

Triangle.prototype = {

	constructor: Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new Vector3();
		var v1 = new Vector3();

		return function area() {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	closestPointToPoint: function () {

		var plane, edgeList, projectedPoint, closestPoint;

		return function closestPointToPoint( point, optionalTarget ) {

			if ( plane === undefined ) {

				plane = new Plane();
				edgeList = [ new Line3(), new Line3(), new Line3() ];
				projectedPoint = new Vector3();
				closestPoint = new Vector3();

			}

			var result = optionalTarget || new Vector3();
			var minDistance = Infinity;

			// project the point onto the plane of the triangle

			plane.setFromCoplanarPoints( this.a, this.b, this.c );
			plane.projectPoint( point, projectedPoint );

			// check if the projection lies within the triangle

			if( this.containsPoint( projectedPoint ) === true ) {

				// if so, this is the closest point

				result.copy( projectedPoint );

			} else {

				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

				edgeList[ 0 ].set( this.a, this.b );
				edgeList[ 1 ].set( this.b, this.c );
				edgeList[ 2 ].set( this.c, this.a );

				for( var i = 0; i < edgeList.length; i ++ ) {

					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

					var distance = projectedPoint.distanceToSquared( closestPoint );

					if( distance < minDistance ) {

						minDistance = distance;

						result.copy( closestPoint );

					}

				}

			}

			return result;

		};

	}(),

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = (normal && normal.isVector3) ? normal : new Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = (color && color.isColor) ? color : new Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

}

Face3.prototype = {

	constructor: Face3,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.lights = false;

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.uuid = _Math.generateUUID();

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.onUploadCallback = function () {};

	this.version = 0;

}

BufferAttribute.prototype = {

	constructor: BufferAttribute,

	isBufferAttribute: true,

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setArray: function ( array ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.count = array !== undefined ? array.length / this.itemSize : 0;
		this.array = array;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

};

//

function Int8BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


function Float32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( DirectGeometry.prototype, {

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex = undefined;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	}

} );

// http://stackoverflow.com/questions/1669190/javascript-min-max-array-values/13440842#13440842

function arrayMax( array ) {

	var length = array.length, max = - Infinity;

	while ( length -- ) {

		if ( array[ length ] > max ) {

			max = array[ length ];

		}

	}

	return max;

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var count = 0;
function GeometryIdCount() { return count++; }

function Geometry() {

	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Geometry.prototype = {

	constructor: Geometry,

	isGeometry: true,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		}

		if ( indices !== undefined ) {

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

					}

				}

			} else {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			}

		} else {

			for ( var i = 0; i < positions.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.getCenter().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new Vector3(), ab = new Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) areaWeighted = true;

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new Vector3(), ab = new Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeFlatVertexNormals: function () {

		var f, fl, face;

		this.computeFaceNormals();

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );

			} else {

				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new Vector3();
					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( ( geometry && geometry.isGeometry ) === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ],
		colors1 = this.colors,
		colors2 = geometry.colors;

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// colors

		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

			colors1.push( colors2[ i ].clone() );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( ( mesh && mesh.isMesh ) === false ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new Geometry().copy( this );

	},

	copy: function ( source ) {

		var i, il, j, jl, k, kl;

		// reset

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// vertices

		var vertices = source.vertices;

		for ( i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		// colors

		var colors = source.colors;

		for ( i = 0, il = colors.length; i < il; i ++ ) {

			this.colors.push( colors[ i ].clone() );

		}

		// faces

		var faces = source.faces;

		for ( i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		// face vertex uvs

		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		// morph targets

		var morphTargets = source.morphTargets;

		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = {};
			morphTarget.name = morphTargets[ i ].name;

			// vertices

			if ( morphTargets[ i ].vertices !== undefined ) {

				morphTarget.vertices = [];

				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

				}

			}

			// normals

			if ( morphTargets[ i ].normals !== undefined ) {

				morphTarget.normals = [];

				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

				}

			}

			this.morphTargets.push( morphTarget );

		}

		// morph normals

		var morphNormals = source.morphNormals;

		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

			var morphNormal = {};

			// vertex normals

			if ( morphNormals[ i ].vertexNormals !== undefined ) {

				morphNormal.vertexNormals = [];

				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
					var destVertexNormal = {};

					destVertexNormal.a = srcVertexNormal.a.clone();
					destVertexNormal.b = srcVertexNormal.b.clone();
					destVertexNormal.c = srcVertexNormal.c.clone();

					morphNormal.vertexNormals.push( destVertexNormal );

				}

			}

			// face normals

			if ( morphNormals[ i ].faceNormals !== undefined ) {

				morphNormal.faceNormals = [];

				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

				}

			}

			this.morphNormals.push( morphNormal );

		}

		// skin weights

		var skinWeights = source.skinWeights;

		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

			this.skinWeights.push( skinWeights[ i ].clone() );

		}

		// skin indices

		var skinIndices = source.skinIndices;

		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

			this.skinIndices.push( skinIndices[ i ].clone() );

		}

		// line distances

		var lineDistances = source.lineDistances;

		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

			this.lineDistances.push( lineDistances[ i ] );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// update flags

		this.elementsNeedUpdate = source.elementsNeedUpdate;
		this.verticesNeedUpdate = source.verticesNeedUpdate;
		this.uvsNeedUpdate = source.uvsNeedUpdate;
		this.normalsNeedUpdate = source.normalsNeedUpdate;
		this.colorsNeedUpdate = source.colorsNeedUpdate;
		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
		this.groupsNeedUpdate = source.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

Object.assign( Geometry.prototype, EventDispatcher.prototype );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

}

BufferGeometry.prototype = {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

	},

	addAttribute: function ( name, attribute ) {

		if ( ( attribute && attribute.isBufferAttribute ) === false && ( attribute && attribute.isInterleavedBufferAttribute ) === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToBufferAttribute( position );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToBufferAttribute( normal );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.getCenter().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object.isPoints || object.isLine ) {

			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object.isMesh ) {

			if ( geometry && geometry.isGeometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object.isMesh ) {

			var direct = geometry.__directGeometry;

			if ( geometry.elementsNeedUpdate === true ) {

				direct = undefined;
				geometry.elementsNeedUpdate = false;

			}

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		var attribute;

		if ( geometry.verticesNeedUpdate === true ) {

			attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		var position = this.attributes.position;

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		var box = new Box3();
		var vector = new Vector3();

		return function computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			var position = this.attributes.position;

			if ( position ) {

				var center = this.boundingSphere.center;

				box.setFromBufferAttribute( position );
				box.getCenter( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = position.count; i < il; i ++ ) {

					vector.x = position.getX( i );
					vector.y = position.getY( i );
					vector.z = position.getZ( i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC;
			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			var cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ( geometry && geometry.isBufferGeometry ) === false ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	toNonIndexed: function () {

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var array = attribute.array;
			var itemSize = attribute.itemSize;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array,
				normalized: attribute.normalized
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var name, i, l;

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// index

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		// attributes

		var attributes = source.attributes;

		for ( name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		// morph attributes

		var morphAttributes = source.morphAttributes;

		for ( name in morphAttributes ) {

			var array = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone() );

			}

			this.morphAttributes[ name ] = array;

		}

		// groups

		var groups = source.groups;

		for ( i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

BufferGeometry.MaxIndex = 65535;

Object.assign( BufferGeometry.prototype, EventDispatcher.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

function Mesh( geometry, material ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.drawMode = TrianglesDrawMode;

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	setDrawMode: function ( value ) {

		this.drawMode = value;

	},

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.drawMode = source.drawMode;

		return this;

	},

	updateMorphTargets: function () {

		var morphTargets = this.geometry.morphTargets;

		if ( morphTargets !== undefined && morphTargets.length > 0 ) {

			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

			}

		}

	},

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		var vA = new Vector3();
		var vB = new Vector3();
		var vC = new Vector3();

		var tempA = new Vector3();
		var tempB = new Vector3();
		var tempC = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		var barycoord = new Vector3();

		var intersectionPoint = new Vector3();
		var intersectionPointWorld = new Vector3();

		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );

			uv1.add( uv2 ).add( uv3 );

			return uv1.clone();

		}

		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

			var intersect;
			var material = object.material;

			if ( material.side === BackSide ) {

				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

			} else {

				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

			}

			if ( intersect === null ) return null;

			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

			vA.fromBufferAttribute( position, a );
			vB.fromBufferAttribute( position, b );
			vC.fromBufferAttribute( position, c );

			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

			if ( intersection ) {

				if ( uv ) {

					uvA.fromBufferAttribute( uv, a );
					uvB.fromBufferAttribute( uv, b );
					uvC.fromBufferAttribute( uv, c );

					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC, uvA, uvB, uvC );

				}

				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;

			}

			return intersection;

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			var intersection;

			if ( geometry.isBufferGeometry ) {

				var a, b, c;
				var index = geometry.index;
				var position = geometry.attributes.position;
				var uv = geometry.attributes.uv;
				var i, l;

				if ( index !== null ) {

					// indexed buffer geometry

					for ( i = 0, l = index.count; i < l; i += 3 ) {

						a = index.getX( i );
						b = index.getX( i + 1 );
						c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );

						}

					}

				} else {

					// non-indexed buffer geometry

					for ( i = 0, l = position.count; i < l; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

						if ( intersection ) {

							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				var fvA, fvB, fvC;
				var isFaceMaterial = ( material && material.isMultiMaterial );
				var materials = isFaceMaterial === true ? material.materials : null;

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var uvs;

				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

						}

						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );

						fvA = vA;
						fvB = vB;
						fvC = vC;

					}

					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

					if ( intersection ) {

						if ( uvs ) {

							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );

							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
	this.mergeVertices();

}

BoxGeometry.prototype = Object.create( Geometry.prototype );
BoxGeometry.prototype.constructor = BoxGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	BufferGeometry.call( this );

	this.type = 'BoxBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	var scope = this;

	// segments

	widthSegments = Math.floor( widthSegments ) || 1;
	heightSegments = Math.floor( heightSegments ) || 1;
	depthSegments = Math.floor( depthSegments ) || 1;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var numberOfVertices = 0;
	var groupStart = 0;

	// build each side of the box geometry

	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

		var segmentWidth = width / gridX;
		var segmentHeight = height / gridY;

		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var vertexCounter = 0;
		var groupCount = 0;

		var ix, iy;

		var vector = new Vector3();

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segmentHeight - heightHalf;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segmentWidth - widthHalf;

				// set values to correct vector component

				vector[ u ] = x * udir;
				vector[ v ] = y * vdir;
				vector[ w ] = depthHalf;

				// now apply vector to vertex buffer

				vertices.push( vector.x, vector.y, vector.z );

				// set values to correct vector component

				vector[ u ] = 0;
				vector[ v ] = 0;
				vector[ w ] = depth > 0 ? 1 : - 1;

				// now apply vector to normal buffer

				normals.push( vector.x, vector.y, vector.z );

				// uvs

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

				// counters

				vertexCounter += 1;

			}

		}

		// indices

		// 1. you need three indices to draw a single face
		// 2. a single segment consists of two faces
		// 3. so we need to generate six (2*3) indices per segment

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

				// increase counter

				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, materialIndex );

		// calculate new start value for groups

		groupStart += groupCount;

		// update total number of vertices

		numberOfVertices += vertexCounter;

	}

}

BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

function PlaneGeometry( width, height, widthSegments, heightSegments ) {

	Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

}

PlaneGeometry.prototype = Object.create( Geometry.prototype );
PlaneGeometry.prototype.constructor = PlaneGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

	BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var ix, iy;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices.push( x, - y, 0 );

			normals.push( 0, 0, 1 );

			uvs.push( ix / gridX );
			uvs.push( 1 - ( iy / gridY ) );

		}

	}

	// indices

	for ( iy = 0; iy < gridY; iy ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();
	this.projectionMatrix = new Matrix4();

}

Camera.prototype = Object.create( Object3D.prototype );
Camera.prototype.constructor = Camera;

Camera.prototype.isCamera = true;

Camera.prototype.getWorldDirection = function () {

	var quaternion = new Quaternion();

	return function getWorldDirection( optionalTarget ) {

		var result = optionalTarget || new Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	};

}();

Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new Matrix4();

	return function lookAt( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

Camera.prototype.clone = function () {

	return new this.constructor().copy( this );

};

Camera.prototype.copy = function ( source ) {

	Object3D.prototype.copy.call( this, source );

	this.matrixWorldInverse.copy( source.matrixWorldInverse );
	this.projectionMatrix.copy( source.projectionMatrix );

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera( fov, aspect, near, far ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source ) {

		Camera.prototype.copy.call( this, source );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function() {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var near = this.near,
			top = near * Math.tan(
					_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;

		if ( view !== null ) {

			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		var skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera( left, right, top, bottom, near, far ) {

	Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

}

OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: OrthographicCamera,

	isOrthographicCamera: true,

	copy: function ( source ) {

		Camera.prototype.copy.call( this, source );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function() {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;

		if ( this.view !== null ) {

			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
			var scaleW = ( this.right - this.left ) / this.view.width;
			var scaleH = ( this.top - this.bottom ) / this.view.height;

			left += scaleW * ( this.view.offsetX / zoomW );
			right = left + scaleW * ( this.view.width / zoomW );
			top -= scaleH * ( this.view.offsetY / zoomH );
			bottom = top - scaleH * ( this.view.height / zoomH );

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, size;

	function setIndex( index ) {

		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

			type = gl.UNSIGNED_INT;
			size = 4;

		} else if ( index.array instanceof Uint16Array ) {

			type = gl.UNSIGNED_SHORT;
			size = 2;

		} else {

			type = gl.UNSIGNED_BYTE;
			size = 1;

		}

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * size );

		infoRender.calls ++;
		infoRender.vertices += count;

		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

	}

	function renderInstances( geometry, start, count ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;

		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	return {

		setMode: setMode,
		setIndex: setIndex,
		render: render,
		renderInstances: renderInstances

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBufferRenderer( gl, extensions, infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		infoRender.calls ++;
		infoRender.vertices += count;

		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		var count = 0;

		if ( position.isInterleavedBufferAttribute ) {

			count = position.data.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		} else {

			count = position.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		}

		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;

		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	return {
		setMode: setMode,
		render: render,
		renderInstances: renderInstances
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLLights() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color(),

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
						// TODO (abelnation): set RectAreaLight shadow uniforms
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function addLineNumbers( string ) {

	var lines = string.split( '\n' );

	for ( var i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function WebGLShader( gl, type, string ) {

	var shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

	}

	if ( gl.getShaderInfoLog( shader ) !== '' ) {

		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

	}

	// --enable-privileged-webgl-extension
	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	return shader;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

var programIdCount = 0;

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear','( value )' ];
		case sRGBEncoding:
			return [ 'sRGB','( value )' ];
		case RGBEEncoding:
			return [ 'RGBE','( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM','( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM','( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD','( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
		default:
			throw new Error( 'unsupported encoding: ' + encoding );

	}

}

function getTexelDecodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

}

function getTexelEncodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

}

function getToneMappingFunction( functionName, toneMapping ) {

	var toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = "Linear";
			break;

		case ReinhardToneMapping:
			toneMappingName = "Reinhard";
			break;

		case Uncharted2ToneMapping:
			toneMappingName = "Uncharted2";
			break;

		case CineonToneMapping:
			toneMappingName = "OptimizedCineon";
			break;

		default:
			throw new Error( 'unsupported toneMapping: ' + toneMapping );

	}

	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

}

function generateExtensions( extensions, parameters, rendererExtensions ) {

	extensions = extensions || {};

	var chunks = [
		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	var chunks = [];

	for ( var name in defines ) {

		var value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program, identifiers ) {

	var attributes = {};

	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( var i = 0; i < n; i ++ ) {

		var info = gl.getActiveAttrib( program, i );
		var name = info.name;

		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

}

function parseIncludes( string ) {

	var pattern = /#include +<([\w\d.]+)>/g;

	function replace( match, include ) {

		var replace = ShaderChunk[ include ];

		if ( replace === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return parseIncludes( replace );

	}

	return string.replace( pattern, replace );

}

function unrollLoops( string ) {

	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

	function replace( match, start, end, snippet ) {

		var unroll = '';

		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

		}

		return unroll;

	}

	return string.replace( pattern, replace );

}

function WebGLProgram( renderer, code, material, parameters ) {

	var gl = renderer.context;

	var extensions = material.extensions;
	var defines = material.defines;

	var vertexShader = material.__webglShader.vertexShader;
	var fragmentShader = material.__webglShader.fragmentShader;

	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	}

	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

	if ( parameters.envMap ) {

		switch ( material.envMap.mapping ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;

		}

		switch ( material.envMap.mapping ) {

			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

		switch ( material.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	// console.log( 'building new program ' );

	//

	var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

	var customDefines = generateDefines( defines );

	//

	var program = gl.createProgram();

	var prefixVertex, prefixFragment;

	if ( material.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines,

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,
			customDefines,

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	} else {

		prefixVertex = [

        
			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + material.__webglShader.name,

			customDefines,

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',


			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + material.__webglShader.name,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
			'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',

			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = parseIncludes( vertexShader, parameters );
	vertexShader = replaceLightNums( vertexShader, parameters );

	fragmentShader = parseIncludes( fragmentShader, parameters );
	fragmentShader = replaceLightNums( fragmentShader, parameters );

	if ( ! material.isShaderMaterial ) {

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

	}

	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( material.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, material.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	var programLog = gl.getProgramInfoLog( program );
	var vertexLog = gl.getShaderInfoLog( glVertexShader );
	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

	var runnable = true;
	var haveDiagnostics = true;

	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

		runnable = false;

		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

	} else if ( programLog !== '' ) {

		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

	} else if ( vertexLog === '' || fragmentLog === '' ) {

		haveDiagnostics = false;

	}

	if ( haveDiagnostics ) {

		this.diagnostics = {

			runnable: runnable,
			material: material,

			programLog: programLog,

			vertexShader: {

				log: vertexLog,
				prefix: prefixVertex

			},

			fragmentShader: {

				log: fragmentLog,
				prefix: prefixFragment

			}

		};

	}

	// clean up

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	var cachedUniforms;

	this.getUniforms = function() {

		if ( cachedUniforms === undefined ) {

			cachedUniforms =
				new WebGLUniforms( gl, program, renderer );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	var cachedAttributes;

	this.getAttributes = function() {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function() {

		gl.deleteProgram( program );
		this.program = undefined;

	};

	// DEPRECATED

	Object.defineProperties( this, {

		uniforms: {
			get: function() {

				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
				return this.getUniforms();

			}
		},

		attributes: {
			get: function() {

				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
				return this.getAttributes();

			}
		}

	} );


	//

	this.id = programIdCount ++;
	this.code = code;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLPrograms( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
	];


	function allocateBones( object ) {

		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && (object && object.isSkinnedMesh) ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

		var encoding;

		if ( ! map ) {

			encoding = LinearEncoding;

		} else if ( map.isTexture ) {

			encoding = map.encoding;

		} else if ( map.isWebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

			encoding = GammaEncoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = allocateBones( object );
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var currentRenderTarget = renderer.getCurrentRenderTarget();

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: !! fog,
			useFog: material.fog,
			fogExp: (fog && fog.isFogExp2),

			flatShading: material.shading === FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,

			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( material.fragmentShader );
			array.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				array.push( name );
				array.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			array.push( parameters[ parameterNames[ i ] ] );

		}

		return array.join();

	};

	this.acquireProgram = function ( material, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, code, material, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLGeometries( gl, properties, info ) {

	var geometries = {};

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry.index !== null ) {

			deleteAttribute( buffergeometry.index );

		}

		deleteAttributes( buffergeometry.attributes );

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		// TODO

		var property = properties.get( geometry );

		if ( property.wireframe ) {

			deleteAttribute( property.wireframe );

		}

		properties.delete( geometry );

		var bufferproperty = properties.get( buffergeometry );

		if ( bufferproperty.wireframe ) {

			deleteAttribute( bufferproperty.wireframe );

		}

		properties.delete( buffergeometry );

		//

		info.memory.geometries --;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function deleteAttribute( attribute ) {

		var buffer = getAttributeBuffer( attribute );

		if ( buffer !== undefined ) {

			gl.deleteBuffer( buffer );
			removeAttributeBuffer( attribute );

		}

	}

	function deleteAttributes( attributes ) {

		for ( var name in attributes ) {

			deleteAttribute( attributes[ name ] );

		}

	}

	function removeAttributeBuffer( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			properties.delete( attribute.data );

		} else {

			properties.delete( attribute );

		}

	}

	return {

		get: function ( object ) {

			var geometry = object.geometry;

			if ( geometries[ geometry.id ] !== undefined ) {

				return geometries[ geometry.id ];

			}

			geometry.addEventListener( 'dispose', onGeometryDispose );

			var buffergeometry;

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLObjects( gl, properties, info ) {

	var geometries = new WebGLGeometries( gl, properties, info );

	//

	function update( object ) {

		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

		var geometry = geometries.get( object );

		if ( object.geometry.isGeometry ) {

			geometry.updateFromObject( object );

		}

		var index = geometry.index;
		var attributes = geometry.attributes;

		if ( index !== null ) {

			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in attributes ) {

			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

			}

		}

		return geometry;

	}

	function updateAttribute( attribute, bufferType ) {

		var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

		var attributeProperties = properties.get( data );

		if ( attributeProperties.__webglBuffer === undefined ) {

			createBuffer( attributeProperties, data, bufferType );

		} else if ( attributeProperties.version !== data.version ) {

			updateBuffer( attributeProperties, data, bufferType );

		}

	}

	function createBuffer( attributeProperties, data, bufferType ) {

		attributeProperties.__webglBuffer = gl.createBuffer();
		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		gl.bufferData( bufferType, data.array, usage );

		var type = gl.FLOAT;
		var array = data.array;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Float64Array ) {

			console.warn( "Unsupported data buffer format: Float64Array" );

		} else if ( array instanceof Uint16Array ) {

			type = gl.UNSIGNED_SHORT;

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		}

		attributeProperties.bytesPerElement = array.BYTES_PER_ELEMENT;
		attributeProperties.type = type;
		attributeProperties.version = data.version;

		data.onUploadCallback();

	}

	function updateBuffer( attributeProperties, data, bufferType ) {

		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		if ( data.dynamic === false ) {

			gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );

		} else if ( data.updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, data.array );

		} else if ( data.updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

			data.updateRange.count = 0; // reset range

		}

		attributeProperties.version = data.version;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function getAttributeProperties( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			return properties.get( attribute.data );

		}

		return properties.get( attribute );

	}

	function getWireframeAttribute( geometry ) {

		var property = properties.get( geometry );

		if ( property.wireframe !== undefined ) {

			return property.wireframe;

		}

		var indices = [];

		var index = geometry.index;
		var attributes = geometry.attributes;

		// console.time( 'wireframe' );

		if ( index !== null ) {

			var array = index.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			var array = attributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

		property.wireframe = attribute;

		return attribute;

	}

	return {

		getAttributeBuffer: getAttributeBuffer,
		getAttributeProperties: getAttributeProperties,
		getWireframeAttribute: getWireframeAttribute,

		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

	var _infoMemory = info.memory;
	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

	//

	function clampToMaxSize( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = _Math.nearestPowerOfTwo( image.width );
			canvas.height = _Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function textureNeedsPowerOfTwo( texture ) {

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	//

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_infoMemory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.delete( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

		}

		properties.delete( renderTarget.texture );
		properties.delete( renderTarget );

	}

	//



	function setTexture2D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = ( texture && texture.isCompressedTexture );
				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setTextureCubeDynamic( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

		var extension;

		if ( isPowerOfTwoImage ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

			image = makePowerOfTwo( image );

		}

		var isPowerOfTwoImage = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			var internalFormat = _gl.DEPTH_COMPONENT;

			if ( texture.type === FloatType ) {

				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
				internalFormat = _gl.DEPTH_COMPONENT32F;

			} else if ( _isWebGL2 ) {

				// WebGL 2.0 requires signed internalformat for glTexImage2D
				internalFormat = _gl.DEPTH_COMPONENT16;

			}

			if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

				        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = paramThreeToGL( texture.type );

				}

			}

			// Depth stencil textures need the DEPTH_STENCIL internal format
			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
			if ( texture.format === DepthStencilFormat ) {

				internalFormat = _gl.DEPTH_STENCIL;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

				        console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = paramThreeToGL( texture.type );

				}

			}

			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture.isCompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

			}

		}

		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = paramThreeToGL( renderTarget.texture.format );
		var glType = paramThreeToGL( renderTarget.texture.type );
		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			// FIXME: We don't support !depth !stencil
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

		}

		// upload an empty depth texture with framebuffer size
		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}

		setTexture2D( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else {

			throw new Error('Unknown depthTexture format')

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

				}

			} else {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

			}

		}

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		_infoMemory.textures ++;

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

			}

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
			state.bindTexture( _gl.TEXTURE_2D, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		var texture = renderTarget.texture;

		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
				texture.minFilter !== NearestFilter &&
				texture.minFilter !== LinearFilter ) {

			var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );

		}

	}

	this.setTexture2D = setTexture2D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

}

/**
 * @author fordacious / fordacious.github.io
 */

function WebGLProperties() {

	var properties = {};

	return {

		get: function ( object ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			if ( map === undefined ) {

				map = {};
				properties[ uuid ] = map;

			}

			return map;

		},

		delete: function ( object ) {

			delete properties[ object.uuid ];

		},

		clear: function () {

			properties = {};

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLState( gl, extensions, paramThreeToGL ) {

	function ColorBuffer() {

		var locked = false;

		var color = new Vector4();
		var currentColorMask = null;
		var currentColorClear = new Vector4();

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( 0, 0, 0, 1 );

			}

		};

	}

	function DepthBuffer() {

		var locked = false;

		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( gl.NEVER );
								break;

							case AlwaysDepth:

								gl.depthFunc( gl.ALWAYS );
								break;

							case LessDepth:

								gl.depthFunc( gl.LESS );
								break;

							case LessEqualDepth:

								gl.depthFunc( gl.LEQUAL );
								break;

							case EqualDepth:

								gl.depthFunc( gl.EQUAL );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( gl.GEQUAL );
								break;

							case GreaterDepth:

								gl.depthFunc( gl.GREATER );
								break;

							case NotEqualDepth:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

					} else {

						gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		var locked = false;

		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( stencilTest ) {

					enable( gl.STENCIL_TEST );

				} else {

					disable( gl.STENCIL_TEST );

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef 	!== stencilRef 	||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail	 !== stencilFail 	||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	var colorBuffer = new ColorBuffer();
	var depthBuffer = new DepthBuffer();
	var stencilBuffer = new StencilBuffer();

	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentFlipSided = null;
	var currentCullFace = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var currentScissorTest = null;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

	var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
	var lineWidthAvailable = parseFloat( version ) >= 1.0;

	var currentTextureSlot = null;
	var currentBoundTextures = {};

	var currentScissor = new Vector4();
	var currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		var texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( var i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

		}

		return texture;

	}

	var emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

	//

	function init() {

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		setDepthFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		enable( gl.BLEND );
		setBlending( NormalBlending );

	}

	function initAttributes() {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function enable( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	}

	function getCompressedTextureFormats() {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	}

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending !== NoBlending ) {

			enable( gl.BLEND );

		} else {

			disable( gl.BLEND );

		}

		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

			if ( blending === AdditiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				}

			} else if ( blending === SubtractiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				}

			} else if ( blending === MultiplyBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				}

			} else {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		if ( blending === CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	}

	// TODO Deprecate

	function setColorWrite( colorWrite ) {

		colorBuffer.setMask( colorWrite );

	}

	function setDepthTest( depthTest ) {

		depthBuffer.setTest( depthTest );

	}

	function setDepthWrite( depthWrite ) {

		depthBuffer.setMask( depthWrite );

	}

	function setDepthFunc( depthFunc ) {

		depthBuffer.setFunc( depthFunc );

	}

	function setStencilTest( stencilTest ) {

		stencilBuffer.setTest( stencilTest );

	}

	function setStencilWrite( stencilWrite ) {

		stencilBuffer.setMask( stencilWrite );

	}

	function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

		stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

	}

	function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

		stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function getScissorTest() {

		return currentScissorTest;

	}

	function setScissorTest( scissorTest ) {

		currentScissorTest = scissorTest;

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBlending = null;

		currentFlipSided = null;
		currentCullFace = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		init: init,
		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		enableAttributeAndDivisor: enableAttributeAndDivisor,
		disableUnusedAttributes: disableUnusedAttributes,
		enable: enable,
		disable: disable,
		getCompressedTextureFormats: getCompressedTextureFormats,

		setBlending: setBlending,

		setColorWrite: setColorWrite,
		setDepthTest: setDepthTest,
		setDepthWrite: setDepthWrite,
		setDepthFunc: setDepthFunc,
		setStencilTest: setStencilTest,
		setStencilWrite: setStencilWrite,
		setStencilFunc: setStencilFunc,
		setStencilOp: setStencilOp,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		getScissorTest: getScissorTest,
		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLCapabilities( gl, extensions, parameters ) {

	var maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	var maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	var vertexTextures = maxVertexTextures > 0;
	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	var floatVertexTextures = vertexTextures && floatFragmentTextures;

	return {

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLExtensions( gl ) {

	var extensions = {};

	return {

		get: function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		}

	};

}

/**
 * @author tschw
 */

function WebGLClipping() {

	var scope = this,

		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,

		plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function( planes, enableLocalClipping, camera ) {

		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function() {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function() {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

		if ( ! localClippingEnabled ||
				planes === null || planes.length === 0 ||
				renderingShadows && ! clipShadows ) {
			// there's no local clipping

			if ( renderingShadows ) {
				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();
			}

		} else {

			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			cache.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset;
									i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).
							applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		
		return dstArray;

	}

}

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer( parameters ) {

	console.log( 'THREE.WebGLRenderer', REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

	var lights = [];

	var opaqueObjects = [];
	var opaqueObjectsLastIndex = - 1;
	var transparentObjects = [];
	var transparentObjectsLastIndex = - 1;

	var morphInfluences = new Float32Array( 8 );

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	var _this = this,

		// internal state cache

		_currentProgram = null,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,

		_currentScissor = new Vector4(),
		_currentScissorTest = null,

		_currentViewport = new Vector4(),

		//

		_usedTextureUnits = 0,

		//

		_clearColor = new Color( 0x000000 ),
		_clearAlpha = 0,

		_width = _canvas.width,
		_height = _canvas.height,

		_pixelRatio = 1,

		_scissor = new Vector4( 0, 0, _width, _height ),
		_scissorTest = false,

		_viewport = new Vector4( 0, 0, _width, _height ),

		// frustum

		_frustum = new Frustum(),

		// clipping

		_clipping = new WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,

		_sphere = new Sphere(),

		// camera matrices cache

		_projScreenMatrix = new Matrix4(),

		_vector3 = new Vector3(),
		_matrix4 = new Matrix4(),
		_matrix42 = new Matrix4(),

		// light arrays cache

		_lights = {

			hash: '',

		ambient: [ 0, 0, 0 ],
		directional: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		point: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],

			shadows: []

		},

		// info

		_infoRender = {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		};

	this.info = {

		render: _infoRender,
		memory: {

			geometries: 0,
			textures: 0

		},
		programs: null

	};


	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error );

	}

	var extensions = new WebGLExtensions( _gl );

	extensions.get( 'WEBGL_depth_texture' );
	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

	var state = new WebGLState( _gl, extensions, paramThreeToGL );
	var properties = new WebGLProperties();
	var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
	var objects = new WebGLObjects( _gl, properties, this.info );
	var programCache = new WebGLPrograms( this, capabilities );
	var lightCache = new WebGLLights();

	this.info.programs = programCache.programs;

	var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	var backgroundPlaneCamera, backgroundPlaneMesh;
	var backgroundBoxCamera, backgroundBoxMesh;

	//

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	function setDefaultGLState() {

		state.init();

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.properties = properties;
	this.state = state;

	// shadow map

	var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new SpritePlugin( this, sprites );
	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.getMaxAnisotropy = function () {

		return capabilities.getMaxAnisotropy();

	};

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _viewport.z, _viewport.w, false );

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		_width = width;
		_height = height;

		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		state.viewport( _viewport.set( x, y, width, height ) );

	};

	this.setScissor = function ( x, y, width, height ) {

		state.scissor( _scissor.set( x, y, width, height ) );

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );

		_clearAlpha = alpha !== undefined ? alpha : 1;

		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function() {

		transparentObjects = [];
		transparentObjectsLastIndex = -1;
		opaqueObjects = [];
		opaqueObjectsLastIndex = -1;

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.delete( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var attributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( ! material.isMeshPhongMaterial &&
				! material.isMeshStandardMaterial &&
				! material.isMeshNormalMaterial &&
				material.shading === FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.normal );

			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.color );

			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

		setMaterial( material );

		var program = setProgram( camera, fog, material, object );

		var updateBuffers = false;
		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( absNumericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

				morphInfluences[ i ] = 0.0;

			}

			program.getUniforms().setValue(
				_gl, 'morphTargetInfluences', morphInfluences );

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;
		var rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = objects.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		var renderer;

		if ( index !== null ) {

			renderer = indexedBufferRenderer;
			renderer.setIndex( index );

		} else {

			renderer = bufferRenderer;

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

			}

		}

		//

		var dataCount = 0;

		if ( index !== null ) {

			dataCount = index.count;

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start * rangeFactor;
		var rangeCount = geometry.drawRange.count * rangeFactor;

		var groupStart = group !== null ? group.start * rangeFactor : 0;
		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

		var drawStart = Math.max( rangeStart, groupStart );
		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );

			} else {

				switch ( object.drawMode ) {

					case TrianglesDrawMode:
						renderer.setMode( _gl.TRIANGLES );
						break;

					case TriangleStripDrawMode:
						renderer.setMode( _gl.TRIANGLE_STRIP );
						break;

					case TriangleFanDrawMode:
						renderer.setMode( _gl.TRIANGLE_FAN );
						break;

				}

			}


		} else if ( object.isLine ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( _gl.POINTS );

		}

		if ( geometry && geometry.isInstancedBufferGeometry ) {

			if ( geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry, drawStart, drawCount );

			}

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var extension;

		if ( geometry && geometry.isInstancedBufferGeometry ) {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;

					var attributeProperties = objects.getAttributeProperties( geometryAttribute );

					var buffer = attributeProperties.__webglBuffer;
					var type = attributeProperties.type;
					var bytesPerElement = attributeProperties.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Sorting

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

	}

	function painterSortStable( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

			return a.material.program.id - b.material.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;

		opaqueObjectsLastIndex = - 1;
		transparentObjectsLastIndex = - 1;

		sprites.length = 0;
		lensFlares.length = 0;

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		projectObject( scene, camera );

		opaqueObjects.length = opaqueObjectsLastIndex + 1;
		transparentObjects.length = transparentObjectsLastIndex + 1;

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		//

		if ( _clippingEnabled ) _clipping.beginShadows();

		setupShadows( lights );

		shadowMap.render( scene, camera );

		setupLights( lights, camera );

		if ( _clippingEnabled ) _clipping.endShadows();

		//

		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		if ( renderTarget === undefined ) {

			renderTarget = null;

		}

		this.setRenderTarget( renderTarget );

		//

		var background = scene.background;

		if ( background === null ) {

			state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

		} else if ( background && background.isColor ) {

			state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );
			forceClear = true;

		}

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		if ( background && background.isCubeTexture ) {

			if ( backgroundBoxCamera === undefined ) {

				backgroundBoxCamera = new PerspectiveCamera();

				backgroundBoxMesh = new Mesh(
					new BoxBufferGeometry( 5, 5, 5 ),
					new ShaderMaterial( {
						uniforms: ShaderLib.cube.uniforms,
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

			}

			backgroundBoxCamera.projectionMatrix.copy( camera.projectionMatrix );

			backgroundBoxCamera.matrixWorld.extractRotation( camera.matrixWorld );
			backgroundBoxCamera.matrixWorldInverse.getInverse( backgroundBoxCamera.matrixWorld );


			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundBoxCamera.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

			objects.update( backgroundBoxMesh );

			_this.renderBufferDirect( backgroundBoxCamera, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

		} else if ( background && background.isTexture ) {

			if ( backgroundPlaneCamera === undefined ) {

				backgroundPlaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				backgroundPlaneMesh = new Mesh(
					new PlaneBufferGeometry( 2, 2 ),
					new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
				);

			}

			backgroundPlaneMesh.material.map = background;

			objects.update( backgroundPlaneMesh );

			_this.renderBufferDirect( backgroundPlaneCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

		}

		//

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			renderObjects( opaqueObjects, scene, camera, overrideMaterial );
			renderObjects( transparentObjects, scene, camera, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			state.setBlending( NoBlending );
			renderObjects( opaqueObjects, scene, camera );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, scene, camera );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentViewport );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			textures.updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );
		state.setColorWrite( true );

		// _gl.finish();

	};

	function pushRenderItem( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparentObjects;
			index = ++ transparentObjectsLastIndex;

		} else {

			array = opaqueObjects;
			index = ++ opaqueObjectsLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem !== undefined ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.z = _vector3.z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				z: _vector3.z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	// TODO Duplicated code (Frustum)

	function isObjectViewable( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null )
			geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere ).
		applyMatrix4( object.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSpriteViewable( sprite ) {

		_sphere.center.set( 0, 0, 0 );
		_sphere.radius = 0.7071067811865476;
		_sphere.applyMatrix4( sprite.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSphereViewable( sphere ) {

		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

		var numPlanes = _clipping.numPlanes;

		if ( numPlanes === 0 ) return true;

		var planes = _this.clippingPlanes,

			center = sphere.center,
			negRad = - sphere.radius,
			i = 0;

		do {

			// out when deeper than radius in the negative halfspace
			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

		} while ( ++ i !== numPlanes );

		return true;

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

		if ( visible ) {

			if ( object.isLight ) {

				lights.push( object );

			} else if ( object.isSprite ) {

				if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

					sprites.push( object );

				}

			} else if ( object.isLensFlare ) {

				lensFlares.push( object );

			} else if ( object.isImmediateRenderObject ) {

				if ( _this.sortObjects === true ) {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyMatrix4( _projScreenMatrix );

				}

				pushRenderItem( object, null, object.material, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material.isMultiMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

	function renderObjects( renderList, scene, camera, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			if ( object.isImmediateRenderObject ) {

				setMaterial( material );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );


		}

	}

	function initMaterial( material, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters(
			material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );

		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = ShaderLib[ parameters.shaderID ];

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.__webglShader = materialProperties.__webglShader;

			program = programCache.acquireProgram( material, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var attributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.__webglShader.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;

		}

		materialProperties.fog = fog;

		// store the light setup it was created for

		materialProperties.lightsHash = _lights.hash;

		if ( material.lights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = _lights.ambient;
			uniforms.directionalLights.value = _lights.directional;
			uniforms.spotLights.value = _lights.spot;
			uniforms.rectAreaLights.value = _lights.rectArea;
			uniforms.pointLights.value = _lights.point;
			uniforms.hemisphereLights.value = _lights.hemi;

			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
			uniforms.spotShadowMap.value = _lights.spotShadowMap;
			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
			uniforms.pointShadowMap.value = _lights.pointShadowMap;
			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setMaterial( material ) {

		material.side === DoubleSide
			? state.disable( _gl.CULL_FACE )
			: state.enable( _gl.CULL_FACE );

		state.setFlipSided( material.side === BackSide );

		material.transparent === true
			? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
			: state.setBlending( NoBlending );

		state.setDepthFunc( material.depthFunc );
		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setColorWrite( material.colorWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	function setProgram( camera, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				_clipping.setState(
					material.clippingPlanes, material.clipIntersection, material.clipShadows,
					camera, materialProperties, useCache );

			}

		}

		if ( material.needsUpdate === false ) {

			if ( materialProperties.program === undefined ) {

				material.needsUpdate = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				material.needsUpdate = true;

			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

				material.needsUpdate = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
				materialProperties.numIntersection  !== _clipping.numIntersection ) ) {

				material.needsUpdate = true;

			}

		}

		if ( material.needsUpdate ) {

			initMaterial( material, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			p_uniforms.set( _gl, camera, 'projectionMatrix' );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

					p_uniforms.set( _gl, skeleton, 'boneTexture' );
					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial ) {

			if ( material.lights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshBasicMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.isMeshNormalMaterial ||
				material.isMeshDepthMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material.isLineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsToon( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( m_uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsStandard( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				if ( material.displacementMap ) {

					m_uniforms.displacementMap.value = material.displacementMap;
					m_uniforms.displacementScale.value = material.displacementScale;
					m_uniforms.displacementBias.value = material.displacementBias;

				}

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsNormal( m_uniforms, material );

			}

			// RectAreaLight Texture
			// TODO (mrdoob): Find a nicer implementation

			if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE;
			if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE;

			WebGLUniforms.upload(
				_gl, materialProperties.uniformsList, m_uniforms, _this );

		}


		// common matrices

		p_uniforms.set( _gl, object, 'modelViewMatrix' );
		p_uniforms.set( _gl, object, 'normalMatrix' );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;

		// don't flip CubeTexture envMaps, flip everything else:
		//  WebGLRenderTargetCube will be flipped for backwards compatibility
		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _height * 0.5;

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		refreshUniformsPhong( uniforms, material );

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		refreshUniformsStandard( uniforms, material );

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	// Lighting

	function setupShadows( lights ) {

		var lightShadowsLength = 0;

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			if ( light.castShadow ) {

				_lights.shadows[ lightShadowsLength ++ ] = light;

			}

		}

		_lights.shadows.length = lightShadowsLength;

	}

	function setupLights( lights, camera ) {

		var l, ll, light,
			r = 0, g = 0, b = 0,
			color,
			intensity,
			distance,
			shadowMap,

			viewMatrix = camera.matrixWorldInverse,

		directionalLength = 0,
		pointLength = 0,
		spotLength = 0,
		rectAreaLength = 0,
		hemiLength = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isDirectionalLight ) {

				var uniforms = lightCache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
				_lights.directional[ directionalLength ++ ] = uniforms;

			} else if ( light.isSpotLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.spotShadowMap[ spotLength ] = shadowMap;
				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
				_lights.spot[ spotLength ++ ] = uniforms;

			} else if ( light.isRectAreaLight ) {

				var uniforms = lightCache.get( light );

				// (a) intensity controls irradiance of entire light
				uniforms.color
					.copy( color )
					.multiplyScalar( intensity / ( light.width * light.height ) );

				// (b) intensity controls the radiance per light area
				// uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				_matrix42.identity();
				_matrix4.copy( light.matrixWorld );
				_matrix4.premultiply( viewMatrix );
				_matrix42.extractRotation( _matrix4 );

				uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
				uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( _matrix42 );
				uniforms.halfHeight.applyMatrix4( _matrix42 );

				// TODO (abelnation): RectAreaLight distance?
				// uniforms.distance = distance;

				_lights.rectArea[ rectAreaLength ++ ] = uniforms;

			} else if ( light.isPointLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.pointShadowMap[ pointLength ] = shadowMap;

				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

					_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

				}

				// for point lights we set the shadow matrix to be a translation-only matrix
				// equal to inverse of the light's position
				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

				_lights.point[ pointLength ++ ] = uniforms;

			} else if ( light.isHemisphereLight ) {

				var uniforms = lightCache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				_lights.hemi[ hemiLength ++ ] = uniforms;

			}

		}

		_lights.ambient[ 0 ] = r;
		_lights.ambient[ 1 ] = g;
		_lights.ambient[ 2 ] = b;

		_lights.directional.length = directionalLength;
		_lights.spot.length = spotLength;
		_lights.rectArea.length = rectAreaLength;
		_lights.point.length = pointLength;
		_lights.hemi.length = hemiLength;

		// TODO (sam-g-steel) why aren't we using join
		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		state.setCullFace( cullFace );
		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

	};

	// Textures

	function allocTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	this.allocTextureUnit = allocTextureUnit;

	// this.setTexture2D = setTexture2D;
	this.setTexture2D = ( function() {

		var warned = false;

		// backwards compatibility: peel texture.texture
		return function setTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTexture = ( function() {

		var warned = false;

		return function setTexture( texture, slot ) {

			if ( ! warned ) {

				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
				warned = true;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTextureCube = ( function() {

		var warned = false;

		return function setTextureCube( texture, slot ) {

			// backwards compatibility: peel texture.texture
			if ( texture && texture.isWebGLRenderTargetCube ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( ( texture && texture.isCubeTexture ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

				// CompressedTexture can have Array in image :/

				// this function alone should take care of cube textures
				textures.setTextureCube( texture, slot );

			} else {

				// assumed: texture property of THREE.WebGLRenderTargetCube

				textures.setTextureCubeDynamic( texture, slot );

			}

		};

	}() );

	this.getCurrentRenderTarget = function() {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget ) {

		_currentRenderTarget = renderTarget;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		var framebuffer;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

			_currentViewport.copy( renderTarget.viewport );

		} else {

			framebuffer = null;

			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
			_currentScissorTest = _scissorTest;

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		state.viewport( _currentViewport );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;

				if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL( p ) {

		var extension;

		if ( p === RepeatWrapping ) return _gl.REPEAT;
		if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === NearestFilter ) return _gl.NEAREST;
		if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === LinearFilter ) return _gl.LINEAR;
		if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === ByteType ) return _gl.BYTE;
		if ( p === ShortType ) return _gl.SHORT;
		if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === IntType ) return _gl.INT;
		if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === FloatType ) return _gl.FLOAT;

		if ( p === HalfFloatType ) {

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) return extension.HALF_FLOAT_OES;

		}

		if ( p === AlphaFormat ) return _gl.ALPHA;
		if ( p === RGBFormat ) return _gl.RGB;
		if ( p === RGBAFormat ) return _gl.RGBA;
		if ( p === LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

		if ( p === AddEquation ) return _gl.FUNC_ADD;
		if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === ZeroFactor ) return _gl.ZERO;
		if ( p === OneFactor ) return _gl.ONE;
		if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === DstColorFactor ) return _gl.DST_COLOR;
		if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

		}

		if ( p === MinEquation || p === MaxEquation ) {

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === MinEquation ) return extension.MIN_EXT;
				if ( p === MaxEquation ) return extension.MAX_EXT;

			}

		}

		if ( p === UnsignedInt248Type ) {

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

		}

		return 0;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function FogExp2 ( color, density ) {

	this.name = '';

	this.color = new Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

}

FogExp2.prototype.isFogExp2 = true;

FogExp2.prototype.clone = function () {

	return new FogExp2( this.color.getHex(), this.density );

};

FogExp2.prototype.toJSON = function ( meta ) {

	return {
		type: 'FogExp2',
		color: this.color.getHex(),
		density: this.density
	};

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog ( color, near, far ) {

	this.name = '';

	this.color = new Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

}

Fog.prototype.isFog = true;

Fog.prototype.clone = function () {

	return new Fog( this.color.getHex(), this.near, this.far );

};

Fog.prototype.toJSON = function ( meta ) {

	return {
		type: 'Fog',
		color: this.color.getHex(),
		near: this.near,
		far: this.far
	};

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene () {

	Object3D.call( this );

	this.type = 'Scene';

	this.background = null;
	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

}

Scene.prototype = Object.create( Object3D.prototype );

Scene.prototype.constructor = Scene;

Scene.prototype.copy = function ( source, recursive ) {

	Object3D.prototype.copy.call( this, source, recursive );

	if ( source.background !== null ) this.background = source.background.clone();
	if ( source.fog !== null ) this.fog = source.fog.clone();
	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

	this.autoUpdate = source.autoUpdate;
	this.matrixAutoUpdate = source.matrixAutoUpdate;

	return this;

};

Scene.prototype.toJSON = function ( meta ) {

	var data = Object3D.prototype.toJSON.call( this, meta );

	if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
	if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

	return data;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function LensFlare( texture, size, distance, blending, color ) {

	Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

}

LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LensFlare,

	isLensFlare: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;

		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

			this.lensFlares.push( source.lensFlares[ i ] );

		}

		return this;

	},

	add: function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new Color( 0xffffff );
		if ( blending === undefined ) blending = NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );

	},

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	updateLensFlares: function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2()
 * }
 */

function SpriteMaterial( parameters ) {

	Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

SpriteMaterial.prototype = Object.create( Material.prototype );
SpriteMaterial.prototype.constructor = SpriteMaterial;

SpriteMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	return this;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function Sprite( material ) {

	Object3D.call( this );

	this.type = 'Sprite';

	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

}

Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Sprite,

	isSprite: true,

	raycast: ( function () {

		var matrixPosition = new Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y / 4;

			if ( distanceSq > guessSizeSq ) {

				return;

			}

			intersects.push( {

				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() ),

	clone: function () {

		return new this.constructor( this.material ).copy( this );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function LOD() {

	Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

}


LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LOD,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		return this;

	},

	addLevel: function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

	},

	getObjectForDistance: function ( distance ) {

		var levels = this.levels;

		for ( var i = 1, l = levels.length; i < l; i ++ ) {

			if ( distance < levels[ i ].distance ) {

				break;

			}

		}

		return levels[ i - 1 ].object;

	},

	raycast: ( function () {

		var matrixPosition = new Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() ),

	update: function () {

		var v1 = new Vector3();
		var v2 = new Vector3();

		return function update( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		};

	}(),

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

function Skeleton( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = _Math.nextPowerOfTwo( Math.ceil( size ) );
		size = Math.max( size, 4 );

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new Matrix4() );

			}

		}

	}

}

Object.assign( Skeleton.prototype, {

	calculateInverses: function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: ( function () {

		var offsetMatrix = new Matrix4();

		return function update() {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.toArray( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}

		};

	} )(),

	clone: function () {

		return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh( geometry, material, useVertexTexture ) {

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			bone = new Bone();
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.fromArray( gbone.pos );
			bone.quaternion.fromArray( gbone.rotq );
			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 && gbone.parent !== null &&
					bones[ gbone.parent ] !== undefined ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

}


SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	bind: function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		if ( this.geometry && this.geometry.isGeometry ) {

			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1, 0, 0, 0 ); // do something reasonable

				}

			}

		} else if ( this.geometry && this.geometry.isBufferGeometry ) {

			var vec = new Vector4();

			var skinWeight = this.geometry.attributes.skinWeight;

			for ( var i = 0; i < skinWeight.count; i ++ ) {

				vec.x = skinWeight.getX( i );
				vec.y = skinWeight.getY( i );
				vec.z = skinWeight.getZ( i );
				vec.w = skinWeight.getW( i );

				var scale = 1.0 / vec.lengthManhattan();

				if ( scale !== Infinity ) {

					vec.multiplyScalar( scale );

				} else {

					vec.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

			}

		}

	},

	updateMatrixWorld: function( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

		}

	},

	clone: function() {

		return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.lights = false;

	this.setValues( parameters );

}

LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Line( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new LineSegments( geometry, material );

	}

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = (this && this.isLineSegments) ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function PointsMaterial( parameters ) {

	Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.lights = false;

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Points( geometry, material ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) return;

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {

	Object3D.call( this );

	this.type = 'Group';

}

Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Group

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

}

VideoTexture.prototype = Object.create( Texture.prototype );
VideoTexture.prototype.constructor = VideoTexture;

/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

}

CompressedTexture.prototype = Object.create( Texture.prototype );
CompressedTexture.prototype.constructor = CompressedTexture;

CompressedTexture.prototype.isCompressedTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

}

CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;

/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

	format = format !== undefined ? format : DepthFormat;

	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

	}

	if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
	if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.flipY = false;
	this.generateMipmaps	= false;

}

DepthTexture.prototype = Object.create( Texture.prototype );
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry( geometry ) {

	BufferGeometry.call( this );

	this.type = 'WireframeGeometry';

	// buffer

	var vertices = [];

	// helper variables

	var i, j, l, o, ol;
	var edge = [ 0, 0 ], edges = {}, e;
	var key, keys = [ 'a', 'b', 'c' ];
	var vertex;

	// different logic for Geometry and BufferGeometry

	if ( geometry && geometry.isGeometry ) {

		// create a data structure that contains all edges without duplicates

		var faces = geometry.faces;

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction ); // sorting prevents duplicates

				key = edge.toString();

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			e = edges[ key ];

			vertex = geometry.vertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = geometry.vertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	} else if ( geometry && geometry.isBufferGeometry ) {

		var position, indices, groups;
		var group, start, count;
		var index1, index2;

		vertex = new Vector3();

		if ( geometry.index !== null ) {

			// indexed BufferGeometry

			position = geometry.attributes.position;
			indices = geometry.index;
			groups = geometry.groups;

			if ( groups.length === 0 ) {

				geometry.addGroup( 0, indices.count );

			}

			// create a data structure that contains all eges without duplicates

			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

				group = groups[ o ];

				start = group.start;
				count = group.count;

				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

					for ( j = 0; j < 3; j ++ ) {

						edge[ 0 ] = indices.getX( i + j );
						edge[ 1 ] = indices.getX( i + ( j + 1 ) % 3 );
						edge.sort( sortFunction ); // sorting prevents duplicates

						key = edge.toString();

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else {

			// non-indexed BufferGeometry

			position = geometry.attributes.position;

			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

				for ( j = 0; j < 3; j ++ ) {

					// three edges per triangle, an edge is represented as (index1, index2)
					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

					index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

		}

	}

	// build geometry

	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	// custom array sort function

	function sortFunction( a, b ) {

		return a - b;

	}

}

WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
WireframeGeometry.prototype.constructor = WireframeGeometry;

/**
 * @author zz85 / https://github.com/zz85
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */

function ParametricGeometry( func, slices, stacks ) {

	Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
	this.mergeVertices();

}

ParametricGeometry.prototype = Object.create( Geometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */

function ParametricBufferGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricBufferGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	var indices = [];
	var vertices = [];
	var uvs = [];

	var i, j;

	// generate vertices and uvs

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		var v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			var u = j / slices;

			var p = func( u, v );
			vertices.push( p.x, p.y, p.z );

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			var a = i * sliceCount + j;
			var b = i * sliceCount + j + 1;
			var c = ( i + 1 ) * sliceCount + j + 1;
			var d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// generate normals

	this.computeVertexNormals();

}

ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

function PolyhedronGeometry( vertices, indices, radius, detail ) {

	Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
	this.mergeVertices();

}

PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

	BufferGeometry.call( this );

	this.type = 'PolyhedronBufferGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	// default buffer data

	var vertexBuffer = [];
	var uvBuffer = [];

	// the subdivision creates the vertex buffer data

	subdivide( detail );

	// all vertices should lie on a conceptual sphere with a given radius

	appplyRadius( radius );

	// finally, create the uv data

	generateUVs();

	// build non-indexed geometry

	this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
	this.normalizeNormals();

	// helper functions

	function subdivide( detail ) {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		// iterate over all faces and apply a subdivison with the given detail value

		for ( var i = 0; i < indices.length; i += 3 ) {

			// get the vertices of the face

			getVertexByIndex( indices[ i + 0 ], a );
			getVertexByIndex( indices[ i + 1 ], b );
			getVertexByIndex( indices[ i + 2 ], c );

			// perform subdivision

			subdivideFace( a, b, c, detail );

		}

	}

	function subdivideFace( a, b, c, detail ) {

		var cols = Math.pow( 2, detail );

		// we use this multidimensional array as a data structure for creating the subdivision

		var v = [];

		var i, j;

		// construct all of the vertices for this subdivision

		for ( i = 0; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = a.clone().lerp( c, i / cols );
			var bj = b.clone().lerp( c, i / cols );

			var rows = cols - i;

			for ( j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

				}

			}

		}

		// construct all of the faces

		for ( i = 0; i < cols; i ++ ) {

			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );
					pushVertex( v[ i ][ k ] );

				} else {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );

				}

			}

		}

	}

	function appplyRadius( radius ) {

		var vertex = new Vector3();

		// iterate over the entire buffer and apply the radius to each vertex

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			vertex.normalize().multiplyScalar( radius );

			vertexBuffer[ i + 0 ] = vertex.x;
			vertexBuffer[ i + 1 ] = vertex.y;
			vertexBuffer[ i + 2 ] = vertex.z;

		}

	}

	function generateUVs() {

		var vertex = new Vector3();

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
			var v = inclination( vertex ) / Math.PI + 0.5;
			uvBuffer.push( u, 1 - v );

		}

		correctUVs();

		correctSeam();

	}

	function correctSeam() {

		// handle case when face straddles the seam, see #3269

		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

			// uv data of a single face

			var x0 = uvBuffer[ i + 0 ];
			var x1 = uvBuffer[ i + 2 ];
			var x2 = uvBuffer[ i + 4 ];

			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );

			// 0.9 is somewhat arbitrary

			if ( max > 0.9 && min < 0.1 ) {

				if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
				if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
				if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

			}

		}

	}

	function pushVertex( vertex ) {

		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

	}

	function getVertexByIndex( index, vertex ) {

		var stride = index * 3;

		vertex.x = vertices[ stride + 0 ];
		vertex.y = vertices[ stride + 1 ];
		vertex.z = vertices[ stride + 2 ];

	}

	function correctUVs() {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		var centroid = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

			var azi = azimuth( centroid );

			correctUV( uvA, j + 0, a, azi );
			correctUV( uvB, j + 2, b, azi );
			correctUV( uvC, j + 4, c, azi );

		}

	}

	function correctUV( uv, stride, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

			uvBuffer[ stride ] = uv.x - 1;

		}

		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

		}

	}

	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}

}

PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 */

function TetrahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function TetrahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 */

function OctahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

OctahedronGeometry.prototype = Object.create( Geometry.prototype );
OctahedronGeometry.prototype.constructor = OctahedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function OctahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 */

function IcosahedronGeometry( radius, detail ) {

 	Geometry.call( this );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function IcosahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

/**
 * @author Abe Pazos / https://hamoid.com
 */

function DodecahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function DodecahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		  1, - 1, - 1,     1, - 1,  1,
		  1,  1, - 1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Creates a tube which extrudes along a 3d spline.
 */

function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

	Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

	// expose internals

	this.tangents = bufferGeometry.tangents;
	this.normals = bufferGeometry.normals;
	this.binormals = bufferGeometry.binormals;

	// create geometry

	this.fromBufferGeometry( bufferGeometry );
	this.mergeVertices();

}

TubeGeometry.prototype = Object.create( Geometry.prototype );
TubeGeometry.prototype.constructor = TubeGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

	BufferGeometry.call( this );

	this.type = 'TubeBufferGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	tubularSegments = tubularSegments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var frames = path.computeFrenetFrames( tubularSegments, closed );

	// expose internals

	this.tangents = frames.tangents;
	this.normals = frames.normals;
	this.binormals = frames.binormals;

	// helper variables

	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();

	var i, j;

	// buffer

	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];

	// create buffer data

	generateBufferData();

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// functions

	function generateBufferData() {

		for ( i = 0; i < tubularSegments; i ++ ) {

			generateSegment( i );

		}

		// if the geometry is not closed, generate the last row of vertices and normals
		// at the regular position on the given path
		//
		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

		generateSegment( ( closed === false ) ? tubularSegments : 0 );

		// uvs are generated in a separate function.
		// this makes it easy compute correct values for closed geometries

		generateUVs();

		// finally create faces

		generateIndices();

	}

	function generateSegment( i ) {

		// we use getPointAt to sample evenly distributed points from the given path

		var P = path.getPointAt( i / tubularSegments );

		// retrieve corresponding normal and binormal

		var N = frames.normals[ i ];
		var B = frames.binormals[ i ];

		// generate normals and vertices for the current segment

		for ( j = 0; j <= radialSegments; j ++ ) {

			var v = j / radialSegments * Math.PI * 2;

			var sin =   Math.sin( v );
			var cos = - Math.cos( v );

			// normal

			normal.x = ( cos * N.x + sin * B.x );
			normal.y = ( cos * N.y + sin * B.y );
			normal.z = ( cos * N.z + sin * B.z );
			normal.normalize();

			normals.push( normal.x, normal.y, normal.z );

			// vertex

			vertex.x = P.x + radius * normal.x;
			vertex.y = P.y + radius * normal.y;
			vertex.z = P.z + radius * normal.z;

			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	function generateIndices() {

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

	}

	function generateUVs() {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			for ( j = 0; j <= radialSegments; j ++ ) {

				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;

				uvs.push( uv.x, uv.y );

			}

		}

	}

}

TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

/**
 * @author oosmoxiecode
 */

function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

	Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();

}

TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 * see: http://www.blackpawn.com/texts/pqtorus/
 */

function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

	BufferGeometry.call( this );

	this.type = 'TorusKnotBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	radius = radius || 100;
	tube = tube || 40;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, j;

	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();

	var P1 = new Vector3();
	var P2 = new Vector3();

	var B = new Vector3();
	var T = new Vector3();
	var N = new Vector3();

	// generate vertices, normals and uvs

	for ( i = 0; i <= tubularSegments; ++ i ) {

		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

		var u = i / tubularSegments * p * Math.PI * 2;

		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

		// calculate orthonormal basis

		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );

		// normalize B, N. T can be ignored, we don't use it

		B.normalize();
		N.normalize();

		for ( j = 0; j <= radialSegments; ++ j ) {

			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );

			// now calculate the final vertex position.
			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

			normal.subVectors( vertex, P1 ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= tubularSegments; j ++ ) {

		for ( i = 1; i <= radialSegments; i ++ ) {

			// indices

			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// this function calculates the current position on the torus curve

	function calculatePositionOnCurve( u, p, q, radius, position ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );

		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;

	}

}

TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

}

TorusGeometry.prototype = Object.create( Geometry.prototype );
TorusGeometry.prototype.constructor = TorusGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	BufferGeometry.call( this );

	this.type = 'TorusBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var center = new Vector3();
	var vertex = new Vector3();
	var normal = new Vector3();

	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= radialSegments; j ++ ) {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			// vertex

			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );
			normal.subVectors( vertex, center ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= radialSegments; j ++ ) {

		for ( i = 1; i <= tubularSegments; i ++ ) {

			// indices

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

var ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function triangulate( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function removeDupEndPts(points) {

			var l = points.length;

			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

				points.pop();

			}

		}

		removeDupEndPts( contour );
		holes.forEach( removeDupEndPts );

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *  frames: <Object> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

function ExtrudeGeometry( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

}

ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

};

ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new Vector3();
		normal = new Vector3();
		position2 = new Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2( pt, vec, size ) {

		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return	new Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * Math.cos( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * Math.cos ( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

		scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
		scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new Vector2( a.x, a.y ),
			new Vector2( b.x, b.y ),
			new Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {

			return [
				new Vector2( a.x, 1 - a.z ),
				new Vector2( b.x, 1 - b.z ),
				new Vector2( c.x, 1 - c.z ),
				new Vector2( d.x, 1 - d.z )
			];

		} else {

			return [
				new Vector2( a.y, 1 - a.z ),
				new Vector2( b.y, 1 - b.z ),
				new Vector2( c.y, 1 - c.z ),
				new Vector2( d.y, 1 - d.z )
			];

		}

	}
};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */

function TextGeometry( text, parameters ) {

	parameters = parameters || {};

	var font = parameters.font;

	if ( ( font && font.isFont ) === false ) {

		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
		return new Geometry();

	}

	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	ExtrudeGeometry.call( this, shapes, parameters );

	this.type = 'TextGeometry';

}

TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
TextGeometry.prototype.constructor = TextGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

}

SphereGeometry.prototype = Object.create( Geometry.prototype );
SphereGeometry.prototype.constructor = SphereGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */

function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var ix, iy;

	var index = 0;
	var grid = [];

	var vertex = new Vector3();
	var normal = new Vector3();

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy <= heightSegments; iy ++ ) {

		var verticesRow = [];

		var v = iy / heightSegments;

		for ( ix = 0; ix <= widthSegments; ix ++ ) {

			var u = ix / widthSegments;

			// vertex

			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, 1 - v );

			verticesRow.push( index ++ );

		}

		grid.push( verticesRow );

	}

	// indices

	for ( iy = 0; iy < heightSegments; iy ++ ) {

		for ( ix = 0; ix < widthSegments; ix ++ ) {

			var a = grid[ iy ][ ix + 1 ];
			var b = grid[ iy ][ ix ];
			var c = grid[ iy + 1 ][ ix ];
			var d = grid[ iy + 1 ][ ix + 1 ];

			if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

/**
 * @author Kaleb Murphy
 */

function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

}

RingGeometry.prototype = Object.create( Geometry.prototype );
RingGeometry.prototype.constructor = RingGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'RingBufferGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 20;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// some helper variables

	var segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new Vector3();
	var uv = new Vector2();
	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= phiSegments; j ++ ) {

		for ( i = 0; i <= thetaSegments; i ++ ) {

			// values are generate from the inside of the ring to the outside

			segment = thetaStart + i / thetaSegments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uv

			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// increase the radius for next row of vertices

		radius += radiusStep;

	}

	// indices

	for ( j = 0; j < phiSegments; j ++ ) {

		var thetaSegmentLevel = j * ( thetaSegments + 1 );

		for ( i = 0; i < thetaSegments; i ++ ) {

			segment = i + thetaSegmentLevel;

			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
RingBufferGeometry.prototype.constructor = RingBufferGeometry;

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.

function LatheGeometry( points, segments, phiStart, phiLength ) {

	Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();

}

LatheGeometry.prototype = Object.create( Geometry.prototype );
LatheGeometry.prototype.constructor = LatheGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

	BufferGeometry.call( this );

	this.type = 'LatheBufferGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;

	// clamp phiLength so it's in range of [ 0, 2PI ]

	phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


	// buffers

	var indices = [];
	var vertices = [];
	var uvs = [];

	// helper variables

	var base;
	var inverseSegments = 1.0 / segments;
	var vertex = new Vector3();
	var uv = new Vector2();
	var i, j;

	// generate vertices and uvs

	for ( i = 0; i <= segments; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var sin = Math.sin( phi );
		var cos = Math.cos( phi );

		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

			// vertex

			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;

			vertices.push( vertex.x, vertex.y, vertex.z );

			// uv

			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );

			uvs.push( uv.x, uv.y );


		}

	}

	// indices

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

			base = j + i * points.length;

			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// generate normals

	this.computeVertexNormals();

	// if the geometry is closed, we need to average the normals along the seam.
	// because the corresponding vertices are identical (but still have different UVs).

	if ( phiLength === Math.PI * 2 ) {

		var normals = this.attributes.normal.array;
		var n1 = new Vector3();
		var n2 = new Vector3();
		var n = new Vector3();

		// this is the buffer offset for the last line of vertices

		base = segments * points.length * 3;

		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

			// select the normal of the vertex in the first line

			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];

			// select the normal of the vertex in the last line

			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];

			// average normals

			n.addVectors( n1, n2 ).normalize();

			// assign the new values to both normals

			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

		}

	}

}

LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

/**
 * @author jonobr1 / http://jonobr1.com
 */

function ShapeGeometry( shapes, curveSegments ) {

	Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( typeof curveSegments === 'object' ) {

		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

		curveSegments = curveSegments.curveSegments;

	}

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
	this.mergeVertices();

}

ShapeGeometry.prototype = Object.create( Geometry.prototype );
ShapeGeometry.prototype.constructor = ShapeGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function ShapeBufferGeometry( shapes, curveSegments ) {

	BufferGeometry.call( this );

	this.type = 'ShapeBufferGeometry';

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	curveSegments = curveSegments || 12;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var groupStart = 0;
	var groupCount = 0;

	// allow single and array values for "shapes" parameter

	if ( Array.isArray( shapes ) === false ) {

		addShape( shapes );

	} else {

		for ( var i = 0; i < shapes.length; i ++ ) {

			addShape( shapes[ i ] );

			this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

			groupStart += groupCount;
			groupCount = 0;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


	// helper functions

	function addShape( shape ) {

		var i, l, shapeHole;

		var indexOffset = vertices.length / 3;
		var points = shape.extractPoints( curveSegments );

		var shapeVertices = points.shape;
		var shapeHoles = points.holes;

		// check direction of vertices

		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

			shapeVertices = shapeVertices.reverse();

			// also check if holes are in the opposite direction

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

		}

		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

		// join vertices of inner and outer paths to a single array

		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

			shapeHole = shapeHoles[ i ];
			shapeVertices = shapeVertices.concat( shapeHole );

		}

		// vertices, normals, uvs

		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

			var vertex = shapeVertices[ i ];

			vertices.push( vertex.x, vertex.y, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( vertex.x, vertex.y ); // world uvs

		}

		// incides

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var a = face[ 0 ] + indexOffset;
			var b = face[ 1 ] + indexOffset;
			var c = face[ 2 ] + indexOffset;

			indices.push( a, b, c );
			groupCount += 3;

		}

	}

}

ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

function EdgesGeometry( geometry, thresholdAngle ) {

	BufferGeometry.call( this );

	this.type = 'EdgesGeometry';

	this.parameters = {
		thresholdAngle: thresholdAngle
	};

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	// buffer

	var vertices = [];

	// helper variables

	var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
	var edge = [ 0, 0 ], edges = {};
	var key, keys = [ 'a', 'b', 'c' ];

	// prepare source geometry

	var geometry2;

	if ( geometry.isBufferGeometry ) {

		geometry2 = new Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var sourceVertices = geometry2.vertices;
	var faces = geometry2.faces;

	// now create a data structure where each entry represents an edge with its adjoining faces

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			key = edge.toString();

			if ( edges[ key ] === undefined ) {

				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				edges[ key ].face2 = i;

			}

		}

	}

	// generate vertices

	for ( key in edges ) {

		var e = edges[ key ];

		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

			var vertex = sourceVertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = sourceVertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	// build geometry

	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	// custom array sort function

	function sortFunction( a, b ) {

		return a - b;

	}

}

EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
EdgesGeometry.prototype.constructor = EdgesGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CylinderGeometry.prototype = Object.create( Geometry.prototype );
CylinderGeometry.prototype.constructor = CylinderGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CylinderBufferGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	var scope = this;

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var index = 0;
	var indexOffset = 0;
	var indexArray = [];
	var halfHeight = height / 2;
	var groupStart = 0;

	// generate geometry

	generateTorso();

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	function generateTorso() {

		var x, y;
		var normal = new Vector3();
		var vertex = new Vector3();

		var groupCount = 0;

		// this will be used to calculate the normal
		var slope = ( radiusBottom - radiusTop ) / height;

		// generate vertices, normals and uvs

		for ( y = 0; y <= heightSegments; y ++ ) {

			var indexRow = [];

			var v = y / heightSegments;

			// calculate the radius of the current row

			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var theta = u * thetaLength + thetaStart;

				var sinTheta = Math.sin( theta );
				var cosTheta = Math.cos( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( sinTheta, slope, cosTheta ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				// save index of vertex in respective row

				indexRow.push( index ++ );

			}

			// now save vertices of the row in our index array

			indexArray.push( indexRow );

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			for ( y = 0; y < heightSegments; y ++ ) {

				// we use the index array to access the correct indices

				var a = indexArray[ y ][ x ];
				var b = indexArray[ y + 1 ][ x ];
				var c = indexArray[ y + 1 ][ x + 1 ];
				var d = indexArray[ y ][ x + 1 ];

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

				// update group counter

				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, 0 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

	function generateCap( top ) {

		var x, centerIndexStart, centerIndexEnd;

		var uv = new Vector2();
		var vertex = new Vector3();

		var groupCount = 0;

		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;

		// save the index of the first center vertex
		centerIndexStart = index;

		// first we generate the center vertex data of the cap.
		// because the geometry needs one set of uvs per face,
		// we must generate a center vertex per face/segment

		for ( x = 1; x <= radialSegments; x ++ ) {

			// vertex

			vertices.push( 0, halfHeight * sign, 0 );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uvs.push( 0.5, 0.5 );

			// increase index

			index ++;

		}

		// save the index of the last center vertex

		centerIndexEnd = index;

		// now we generate the surrounding vertices, normals and uvs

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;
			var theta = u * thetaLength + thetaStart;

			var cosTheta = Math.cos( theta );
			var sinTheta = Math.sin( theta );

			// vertex

			vertex.x = radius * sinTheta;
			vertex.y = halfHeight * sign;
			vertex.z = radius * cosTheta;
			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uv.x = ( cosTheta * 0.5 ) + 0.5;
			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
			uvs.push( uv.x, uv.y );

			// increase index

			index ++;

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;

			if ( top === true ) {

				// face top

				indices.push( i, i + 1, c );

			} else {

				// face bottom

				indices.push( i + 1, i, c );

			}

			groupCount += 3;

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

}

CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

/**
 * @author abelnation / http://github.com/abelnation
 */

function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
ConeGeometry.prototype.constructor = ConeGeometry;

/**
 * @author: abelnation / http://github.com/abelnation
 */

function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeBufferGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

/**
 * @author hughes
 */

function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

}

CircleGeometry.prototype = Object.create( Geometry.prototype );
CircleGeometry.prototype.constructor = CircleGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */

function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, s;
	var vertex = new Vector3();
	var uv = new Vector2();

	// center point

	vertices.push( 0, 0, 0 );
	normals.push( 0, 0, 1 );
	uvs.push( 0.5, 0.5 );

	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

		var segment = thetaStart + s / segments * thetaLength;

		// vertex

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		vertices.push( vertex.x, vertex.y, vertex.z );

		// normal

		normals.push( 0, 0, 1 );

		// uvs

		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

		uvs.push( uv.x, uv.y );

	}

	// indices

	for ( i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



var Geometries = Object.freeze({
	WireframeGeometry: WireframeGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TextGeometry: TextGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeBufferGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	EdgesGeometry: EdgesGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxBufferGeometry
});

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ShadowMaterial() {

	ShaderMaterial.call( this, {
		uniforms: UniformsUtils.merge( [
			UniformsLib.lights,
			{
				opacity: { value: 1.0 }
			}
		] ),
		vertexShader: ShaderChunk[ 'shadow_vert' ],
		fragmentShader: ShaderChunk[ 'shadow_frag' ]
	} );

	this.lights = true;
	this.transparent = true;

	Object.defineProperties( this, {
		opacity: {
			enumerable: true,
			get: function () {
				return this.uniforms.opacity.value;
			},
			set: function ( value ) {
				this.uniforms.opacity.value = value;
			}
		}
	} );

}

ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
ShadowMaterial.prototype.constructor = ShadowMaterial;

ShadowMaterial.prototype.isShadowMaterial = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function RawShaderMaterial( parameters ) {

	ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

}

RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
RawShaderMaterial.prototype.constructor = RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function MultiMaterial( materials ) {

	this.uuid = _Math.generateUUID();

	this.type = 'MultiMaterial';

	this.materials = Array.isArray( materials ) ? materials : [];

	this.visible = true;

}

MultiMaterial.prototype = {

	constructor: MultiMaterial,

	isMultiMaterial: true,

	toJSON: function ( meta ) {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		var materials = this.materials;

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			var material = materials[ i ].toJSON( meta );
			delete material.metadata;

			output.materials.push( material );

		}

		output.visible = this.visible;

		return output;

	},

	clone: function () {

		var material = new this.constructor();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		material.visible = this.visible;

		return material;

	}

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.roughness = 0.5;
	this.metalness = 0.5;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = { 'PHYSICAL': '' };

	this.type = 'MeshPhysicalMaterial';

	this.reflectivity = 0.5; // maps to F0 = 0.04

	this.clearCoat = 0.0;
	this.clearCoatRoughness = 0.0;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = { 'PHYSICAL': '' };

	this.reflectivity = source.reflectivity;

	this.clearCoat = source.clearCoat;
	this.clearCoatRoughness = source.clearCoatRoughness;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshPhongMaterial.prototype = Object.create( Material.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */

function MeshToonMaterial( parameters ) {

	MeshPhongMaterial.call( this );

	this.defines = { 'TOON': '' };

	this.type = 'MeshToonMaterial';

	this.gradientMap = null;

	this.setValues( parameters );

}

MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
MeshToonMaterial.prototype.constructor = MeshToonMaterial;

MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function ( source ) {

	MeshPhongMaterial.prototype.copy.call( this, source );

	this.gradientMap = source.gradientMap;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial( parameters ) {

	Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshNormalMaterial.prototype = Object.create( Material.prototype );
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshLambertMaterial.prototype = Object.create( Material.prototype );
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.lights = false;

	this.setValues( parameters );

}

LineDashedMaterial.prototype = Object.create( Material.prototype );
LineDashedMaterial.prototype.constructor = LineDashedMaterial;

LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	return this;

};



var Materials = Object.freeze({
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MultiMaterial: MultiMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LoadingManager( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

}

var DefaultLoadingManager = new LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FileLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( FileLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check for data: URI
		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		var dataUriRegexResult = url.match( dataUriRegex );

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			var mimeType = dataUriRegexResult[ 1 ];
			var isBase64 = !! dataUriRegexResult[ 2 ];
			var data = dataUriRegexResult[ 3 ];

			data = window.decodeURIComponent( data );

			if ( isBase64 ) data = window.atob( data );

			try {

				var response;
				var responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

					 	response = new ArrayBuffer( data.length );

						var view = new Uint8Array( response );

						for ( var i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ response ], { type: mimeType } );

						}

						break;

					case 'document':

						var parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick
				window.setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick
				window.setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );

				}, 0 );

			}

		} else {

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				var response = event.target.response;

				Cache.add( url, response );

				if ( this.status === 200 ) {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				} else if ( this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				} else {

					if ( onError ) onError( event );

					scope.manager.itemError( url );

				}

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			request.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

function CompressedTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

}

Object.assign( CompressedTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new CompressedTexture();
		texture.image = images;

		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

function DataTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

}

Object.assign( DataTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new DataTexture();

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( ImageLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		image.addEventListener( 'load', function () {

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}, false );

		/*
		image.addEventListener( 'progress', function ( event ) {

			if ( onProgress ) onProgress( event );

		}, false );
		*/

		image.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( CubeTextureLoader.prototype, {

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new CubeTexture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( TextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new Texture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );
		loader.load( url, function ( image ) {

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light( color, intensity ) {

	Object3D.call( this );

	this.type = 'Light';

	this.color = new Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;

}

Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Light,

	isLight: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight( skyColor, groundColor, intensity ) {

	Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.groundColor = new Color( groundColor );

}

HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: HemisphereLight,

	isHemisphereLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new Vector2( 512, 512 );

	this.map = null;
	this.matrix = new Matrix4();

}

Object.assign( LightShadow.prototype, {

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		var object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

}

SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: SpotLightShadow,

	isSpotLightShadow: true,

	update: function ( light ) {

		var fov = _Math.RAD2DEG * 2 * light.angle;
		var aspect = this.mapSize.width / this.mapSize.height;
		var far = light.distance || 500;

		var camera = this.camera;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

	Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * Math.PI;
		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / Math.PI;
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new SpotLightShadow();

}

SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: SpotLight,

	isSpotLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */


function PointLight( color, intensity, distance, decay ) {

	Light.call( this, color, intensity );

	this.type = 'PointLight';

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * 4 * Math.PI;

		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / ( 4 * Math.PI );
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

}

PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: PointLight,

	isPointLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow( ) {

	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

}

DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: DirectionalLightShadow

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	this.shadow = new DirectionalLightShadow();

}

DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: DirectionalLight,

	isDirectionalLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

}

AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: AmbientLight,

	isAmbientLight: true

} );

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			return new array.constructor( array.subarray( from, to ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function( object ) {

		return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function( values, stride, order ) {

		var nValues = values.length;
		var result = new values.constructor( nValues );

		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			var srcOffset = order[ i ] * stride;

			for ( var j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

		var i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		var value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {
			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {
			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

function Interpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Interpolant.prototype = {

	constructor: Interpolant,

	evaluate: function( t ) {

		var pp = this.parameterPositions,
			i1 = this._cachedIndex,

			t1 = pp[   i1   ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				var right;

				linear_scan: {
//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( var giveUpAt = i1 + 2; ;) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						var t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( var giveUpAt = i1 - 2; ;) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					var mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[   i1   ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function() {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function( index ) {

		// copies a sample value to the result buffer

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function( i1, t0, t, t1 ) {

		throw new Error( "call to abstract method" );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function( i1, t0, t1 ) {

		// empty

	}

};

Object.assign( Interpolant.prototype, {

	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
		Interpolant.prototype.copySampleValue_,

	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
		Interpolant.prototype.copySampleValue_

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = -0;
	this._offsetPrev = -0;
	this._weightNext = -0;
	this._offsetNext = -0;

}

CubicInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: 	ZeroCurvatureEnding,
		endingEnd:		ZeroCurvatureEnding

	},

	intervalChanged_: function( i1, t0, t1 ) {

		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
		var sN =       wN   * ppp   -           wN      * pp;

		// combine data linearly

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

/**
 * @author tschw
 */

function LinearInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

var KeyframeTrackPrototype;

KeyframeTrackPrototype = {

	TimeBufferType: Float32Array,
	ValueBufferType: Float32Array,

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function ( result ) {

		return new DiscreteInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function ( result ) {

		return new LinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function ( result ) {

		return new CubicInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function ( interpolation ) {

		var factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( message );
			return;

		}

		this.createInterpolant = factoryMethod;

	},

	getInterpolation: function () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	},

	getValueSize: function () {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function ( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
		while ( to !== - 1 && times[ to ] > endTime ) -- to;

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

			var stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.
					arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function () {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( "invalid value size in track", this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( "track is empty", this );
			valid = false;

		}

		var prevTime = null;

		for ( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( "time is not a valid number", this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( "out of order keys", this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( var i = 0, n = values.length; i !== n; ++ i ) {

					var value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( "value is not a valid number", this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function () {

		var times = this.times,
			values = this.values,
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			writeIndex = 1,
			lastIndex = times.length - 1;

		for ( var i = 1; i < lastIndex; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( var j = 0; j !== stride; ++ j ) {

						var value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else keep = true;

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j = 0; j !== stride; ++ j )

						values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

				values[ writeOffset + j ] = values[ readOffset + j ];

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		}

		return this;

	}

};

function KeyframeTrackConstructor( name, times, values, interpolation ) {

	if( name === undefined ) throw new Error( "track name is undefined" );

	if( times === undefined || times.length === 0 ) {

		throw new Error( "no keyframes in track named " + name );

	}

	this.name = name;

	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

	this.validate();
	this.optimize();

}

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

VectorKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset = i1 * stride,

			alpha = ( t - t0 ) / ( t1 - t0 );

		for ( var end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0,
					values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

QuaternionKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodLinear: function( result ) {

		return new QuaternionLinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

NumberKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: NumberKeyframeTrack,

	ValueTypeName: 'number'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

StringKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack( name, times, values ) {

	KeyframeTrackConstructor.call( this, name, times, values );

}

BooleanKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

ColorKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited


	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.apply( this, arguments );

}

KeyframeTrack.prototype = KeyframeTrackPrototype;
KeyframeTrackPrototype.constructor = KeyframeTrack;

// Static methods:

Object.assign( KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	parse: function( json ) {

		if( json.type === undefined ) {

			throw new Error( "track type undefined, can not parse" );

		}

		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we asssume a constructor compatible with the base
			return new trackType(
					json.name, json.times, json.values, json.interpolation );

		}

	},

	toJSON: function( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	},

	_getTrackTypeForValueTypeName: function( typeName ) {

		switch( typeName.toLowerCase() ) {

			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":

				return NumberKeyframeTrack;

			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":

				return VectorKeyframeTrack;

			case "color":

				return ColorKeyframeTrack;

			case "quaternion":

				return QuaternionKeyframeTrack;

			case "bool":
			case "boolean":

				return BooleanKeyframeTrack;

			case "string":

				return StringKeyframeTrack;

		}

		throw new Error( "Unsupported typeName: " + typeName );

	}

} );

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : -1;

	this.uuid = _Math.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

	this.optimize();

}

AnimationClip.prototype = {

	constructor: AnimationClip,

	resetDuration: function() {

		var tracks = this.tracks,
			duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

	},

	trim: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

};

// Static methods:

Object.assign( AnimationClip, {

	parse: function( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new AnimationClip( json.name, json.duration, tracks );

	},


	toJSON: function( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},


	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );
		}

		return new AnimationClip( name, -1, tracks );

	},

	findByName: function( objectOrClipArray, name ) {

		var clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}
		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function( animation, bones ) {

		if ( ! animation ) {

			console.error( "  no animation in JSONLoader data" );
			return null;

		}

		var addNonemptyTrack = function(
				trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				AnimationUtils.flattenJSON(
						animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		// automatic length determination in AnimationClip.
		var duration = animation.length || -1;
		var fps = animation.fps || 30;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets in a way exactly compatible
			// with AnimationHandler.init( animation )
			if ( animationKeys[0].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};
				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[k].morphTargets ) {

						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m = 0; m !== animationKeys[k].morphTargets.length; ++ m ) {

						var animationKey = animationKeys[k];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {
				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

				addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

				addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new AnimationClip( clipName, duration, tracks );

		return clip;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.textures = {};

}

Object.assign( MaterialLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	parse: function ( json ) {

		var textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		var material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
		if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalScale !== undefined ) {

			var normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		// MultiMaterial

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( BufferGeometryLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var geometry = new BufferGeometry();

		var index = json.data.index;

		var TYPED_ARRAYS = {
			'Int8Array': Int8Array,
			'Uint8Array': Uint8Array,
			'Uint8ClampedArray': Uint8ClampedArray,
			'Int16Array': Int16Array,
			'Uint16Array': Uint16Array,
			'Int32Array': Int32Array,
			'Uint32Array': Uint32Array,
			'Float32Array': Float32Array,
			'Float64Array': Float64Array
		};

		if ( index !== undefined ) {

			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Loader() {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

}

Loader.prototype = {

	constructor: Loader,

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var BlendingMode = {
			NoBlending: NoBlending,
			NormalBlending: NormalBlending,
			AdditiveBlending: AdditiveBlending,
			SubtractiveBlending: SubtractiveBlending,
			MultiplyBlending: MultiplyBlending,
			CustomBlending: CustomBlending
		};

		var color, textureLoader, materialLoader;

		return function createMaterial( m, texturePath, crossOrigin ) {

			if ( color === undefined ) color = new Color();
			if ( textureLoader === undefined ) textureLoader = new TextureLoader();
			if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = _Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: _Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {

					case 'DbgColor':
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = BlendingMode[ value ];
						break;
					case 'colorAmbient':
					case 'mapAmbient':
						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapEmissive':
						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
						break;
					case 'mapEmissiveRepeat':
					case 'mapEmissiveOffset':
					case 'mapEmissiveWrap':
					case 'mapEmissiveAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapMetalness':
						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
						break;
					case 'mapMetalnessRepeat':
					case 'mapMetalnessOffset':
					case 'mapMetalnessWrap':
					case 'mapMetalnessAnisotropy':
						break;
					case 'mapRoughness':
						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
						break;
					case 'mapRoughnessRepeat':
					case 'mapRoughnessOffset':
					case 'mapRoughnessWrap':
					case 'mapRoughnessAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = BackSide;
						break;
					case 'doubleSided':
						json.side = DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'depthTest':
					case 'depthWrite':
					case 'colorWrite':
					case 'opacity':
					case 'reflectivity':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = VertexColors;
						if ( value === 'face' ) json.vertexColors = FaceColors;
						break;
					default:
						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
						break;

				}

			}

			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

};

Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function JSONLoader( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.withCredentials = false;

}

Object.assign( JSONLoader.prototype, {

	load: function( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

		var loader = new FileLoader( this.manager );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				var type = metadata.type;

				if ( type !== undefined ) {

					if ( type.toLowerCase() === 'object' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;

					}

					if ( type.toLowerCase() === 'scene' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;

					}

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: function ( json, texturePath ) {

		var geometry = new Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );
		parseAnimations();

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		}

		function parseSkin() {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		}

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations() {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];

			if ( json.animation !== undefined ) {

				animations.push( json.animation );

			}

			if ( json.animations !== undefined ) {

				if ( json.animations.length ) {

					animations = animations.concat( json.animations );

				} else {

					animations.push( json.animations );

				}

			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		}

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

			return { geometry: geometry, materials: materials };

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.texturePath = '';

}

Object.assign( ObjectLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			var json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			var metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new JSONLoader();
			var bufferGeometryLoader = new BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'IcosahedronGeometry':
					case 'OctahedronGeometry':
					case 'TetrahedronGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var material = loader.parse( json[ i ] );
				materials[ material.uuid ] = material;

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new LoadingManager( onLoad );

			var loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		var TextureMapping = {
			UVMapping: UVMapping,
			CubeReflectionMapping: CubeReflectionMapping,
			CubeRefractionMapping: CubeRefractionMapping,
			EquirectangularReflectionMapping: EquirectangularReflectionMapping,
			EquirectangularRefractionMapping: EquirectangularRefractionMapping,
			SphericalReflectionMapping: SphericalReflectionMapping,
			CubeUVReflectionMapping: CubeUVReflectionMapping,
			CubeUVRefractionMapping: CubeUVRefractionMapping
		};

		var TextureWrapping = {
			RepeatWrapping: RepeatWrapping,
			ClampToEdgeWrapping: ClampToEdgeWrapping,
			MirroredRepeatWrapping: MirroredRepeatWrapping
		};

		var TextureFilter = {
			NearestFilter: NearestFilter,
			NearestMipMapNearestFilter: NearestMipMapNearestFilter,
			NearestMipMapLinearFilter: NearestMipMapLinearFilter,
			LinearFilter: LinearFilter,
			LinearMipMapNearestFilter: LinearMipMapNearestFilter,
			LinearMipMapLinearFilter: LinearMipMapLinearFilter
		};

		function parseConstant( value, type ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture = new Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

				}

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new Matrix4();

		return function parseObject( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.' );

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		};

	}()

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	var v0 = ( p2 - p0 ) * 0.5;
	var v1 = ( p3 - p1 ) * 0.5;
	var t2 = t * t;
	var t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	var k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTangentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.CatmullRomCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {}

Curve.prototype = {

	constructor: Curve,

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( isNaN( divisions ) ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( isNaN( divisions ) ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( isNaN( divisions ) ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	},

	updateArcLengths: function() {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		var normal = new Vector3();

		var tangents = [];
		var normals = [];
		var binormals = [];

		var vec = new Vector3();
		var mat = new Matrix4();

		var i, u, theta;

		// compute the tangent vectors for each segment on the curve

		for ( i = 0; i <= segments; i ++ ) {

			u = i / segments;

			tangents[ i ] = this.getTangentAt( u );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		var min = Number.MAX_VALUE;
		var tx = Math.abs( tangents[ 0 ].x );
		var ty = Math.abs( tangents[ 0 ].y );
		var tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

};

function LineCurve( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

}

LineCurve.prototype = Object.create( Curve.prototype );
LineCurve.prototype.constructor = LineCurve;

LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function ( t ) {

	if ( t === 1 ) {

		return this.v2.clone();

	}

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

LineCurve.prototype.getTangent = function ( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

}

CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

	constructor: CurvePath,

	add: function ( curve ) {

		this.curves.push( curve );

	},

	closePath: function () {

		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	},

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint: function ( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];

				var segmentLength = curve.getLength();
				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	},

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength: function () {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	},

	// cacheLengths must be recalculated.
	updateArcLengths: function () {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getLengths();

	},

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths: function () {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	},

	getSpacedPoints: function ( divisions ) {

		if ( isNaN( divisions ) ) divisions = 40;

		var points = [];

		for ( var i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	getPoints: function ( divisions ) {

		divisions = divisions || 12;

		var points = [], last;

		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

			var curve = curves[ i ];
			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
				: (curve && curve.isLineCurve) ? 1
				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
				: divisions;

			var pts = curve.getPoints( resolution );

			for ( var j = 0; j < pts.length; j++ ) {

				var point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	createPointsGeometry: function ( divisions ) {

		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );

	},

	// Generate geometry from equidistant sampling along the path

	createSpacedPointsGeometry: function ( divisions ) {

		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );

	},

	createGeometry: function ( points ) {

		var geometry = new Geometry();

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	}

} );

function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

	this.aRotation = aRotation || 0;

}

EllipseCurve.prototype = Object.create( Curve.prototype );
EllipseCurve.prototype.constructor = EllipseCurve;

EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function ( t ) {

	var twoPi = Math.PI * 2;
	var deltaAngle = this.aEndAngle - this.aStartAngle;
	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

	// ensures that deltaAngle is 0 .. 2 PI
	while ( deltaAngle < 0 ) deltaAngle += twoPi;
	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

	if ( deltaAngle < Number.EPSILON ) {

		if ( samePoints ) {

			deltaAngle = 0;

		} else {

			deltaAngle = twoPi;

		}

	}

	if ( this.aClockwise === true && ! samePoints ) {

		if ( deltaAngle === twoPi ) {

			deltaAngle = - twoPi;

		} else {

			deltaAngle = deltaAngle - twoPi;

		}

	}

	var angle = this.aStartAngle + t * deltaAngle;
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x - this.aX;
		var ty = y - this.aY;

		// Rotate the point about the center of the ellipse.
		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;

	}

	return new Vector2( x, y );

};

function SplineCurve( points /* array of Vector2 */ ) {

	this.points = ( points === undefined ) ? [] : points;

}

SplineCurve.prototype = Object.create( Curve.prototype );
SplineCurve.prototype.constructor = SplineCurve;

SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	return new Vector2(
		CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
		CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
	);

};

function CubicBezierCurve( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

}

CubicBezierCurve.prototype = Object.create( Curve.prototype );
CubicBezierCurve.prototype.constructor = CubicBezierCurve;

CubicBezierCurve.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	return new Vector2(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
	);

};

function QuadraticBezierCurve( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

}

QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	return new Vector2(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y )
	);

};

var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

	fromPoints: function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

			this.lineTo( vectors[ i ].x, vectors[ i ].y );

		}

	},

	moveTo: function ( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

	},

	lineTo: function ( x, y ) {

		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		var curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		var curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

	},

	splineThru: function ( pts /*Array of Vector*/ ) {

		var npts = [ this.currentPoint.clone() ].concat( pts );

		var curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

	},

	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	},

	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	},

	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

	},

	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			var firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path( points ) {

	CurvePath.call( this );
	this.currentPoint = new Vector2();

	if ( points ) {

		this.fromPoints( points );

	}

}

Path.prototype = PathPrototype;
PathPrototype.constructor = Path;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape() {

	Path.apply( this, arguments );

	this.holes = [];

}

Shape.prototype = Object.assign( Object.create( PathPrototype ), {

	constructor: Shape,

	getPointsHoles: function ( divisions ) {

		var holesPts = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	},

	// Get points of shape and holes (keypoints based on segments parameter)

	extractAllPoints: function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	},

	extractPoints: function ( divisions ) {

		return this.extractAllPoints( divisions );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath() {

	this.subPaths = [];
	this.currentPath = null;

}

ShapePath.prototype = {

	moveTo: function ( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

	},

	lineTo: function ( x, y ) {

		this.currentPath.lineTo( x, y );

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

	},

	splineThru: function ( pts ) {

		this.currentPath.splineThru( pts );

	},

	toShapes: function ( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		var isClockWise = ShapeUtils.isClockWise;

		var subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];

				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;

					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles;

		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

function Font( data ) {

	this.data = data;

}

Object.assign( Font.prototype, {

	isFont: true,

	generateShapes: function ( text, size, divisions ) {

		function createPaths( text ) {

			var chars = String( text ).split( '' );
			var scale = size / data.resolution;
			var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

			var offsetX = 0, offsetY = 0;

			var paths = [];

			for ( var i = 0; i < chars.length; i ++ ) {

				var char = chars[ i ];

				if ( char === '\n' ) {

					offsetX = 0;
					offsetY -= line_height;

				} else {

					var ret = createPath( char, scale, offsetX, offsetY );
					offsetX += ret.offsetX;
					paths.push( ret.path );

				}

			}

			return paths;

		}

		function createPath( c, scale, offsetX, offsetY ) {

			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

			if ( ! glyph ) return;

			var path = new ShapePath();

			var pts = [];
			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

			if ( glyph.o ) {

				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

				for ( var i = 0, l = outline.length; i < l; ) {

					var action = outline[ i ++ ];

					switch ( action ) {

						case 'm': // moveTo

							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;

							path.moveTo( x, y );

							break;

						case 'l': // lineTo

							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;

							path.lineTo( x, y );

							break;

						case 'q': // quadraticCurveTo

							cpx  = outline[ i ++ ] * scale + offsetX;
							cpy  = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;

							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									QuadraticBezier( t, cpx0, cpx1, cpx );
									QuadraticBezier( t, cpy0, cpy1, cpy );

								}

							}

							break;

						case 'b': // bezierCurveTo

							cpx  = outline[ i ++ ] * scale + offsetX;
							cpy  = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;
							cpx2 = outline[ i ++ ] * scale + offsetX;
							cpy2 = outline[ i ++ ] * scale + offsetY;

							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									CubicBezier( t, cpx0, cpx1, cpx2, cpx );
									CubicBezier( t, cpy0, cpy1, cpy2, cpy );

								}

							}

							break;

					}

				}

			}

			return { offsetX: glyph.ha * scale, path: path };

		}

		//

		if ( size === undefined ) size = 100;
		if ( divisions === undefined ) divisions = 4;

		var data = this.data;

		var paths = createPaths( text );
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FontLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( FontLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( this.manager );
		loader.load( url, function ( text ) {

			var json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			var font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		return new Font( json );

	}

} );

var context;

var AudioContext = {

	getContext: function () {

		if ( context === undefined ) {

			context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return context;

	},

	setContext: function ( value ) {

		context = value;

	}

};

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function AudioLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( AudioLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.load( url, function ( buffer ) {

			var context = AudioContext.getContext();

			context.decodeAudioData( buffer, function ( audioBuffer ) {

				onLoad( audioBuffer );

			} );

		}, onProgress, onError );

	}

} );

/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight ( color, intensity, width, height ) {

	Light.call( this, color, intensity );

	this.type = 'RectAreaLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.width = ( width !== undefined ) ? width : 10;
	this.height = ( height !== undefined ) ? height : 10;

	// TODO (abelnation): distance/decay

	// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

	// TODO (abelnation): shadows
	// this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );

}

// TODO (abelnation): RectAreaLight update when light shape is changed
RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: RectAreaLight,

	isRectAreaLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.width = source.width;
		this.height = source.height;

		// this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function StereoCamera() {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.eyeSep = 0.064;

	this.cameraL = new PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

}

Object.assign( StereoCamera.prototype, {

	update: ( function () {

		var instance, focus, fov, aspect, near, far, zoom;

		var eyeRight = new Matrix4();
		var eyeLeft = new Matrix4();

		return function update( camera ) {

			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
												aspect !== camera.aspect * this.aspect || near !== camera.near ||
												far !== camera.far || zoom !== camera.zoom;

			if ( needsUpdate ) {

				instance = this;
				focus = camera.focus;
				fov = camera.fov;
				aspect = camera.aspect * this.aspect;
				near = camera.near;
				far = camera.far;
				zoom = camera.zoom;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				var eyeSep = this.eyeSep / 2;
				var eyeSepOnProjection = eyeSep * near / focus;
				var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
				var xmin, xmax;

				// translate xOffset

				eyeLeft.elements[ 12 ] = - eyeSep;
				eyeRight.elements[ 12 ] = eyeSep;

				// for left eye

				xmin = - ymax * aspect + eyeSepOnProjection;
				xmax = ymax * aspect + eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = - ymax * aspect - eyeSepOnProjection;
				xmax = ymax * aspect - eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

		};

	} )()

} );

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

function CubeCamera( near, far, cubeResolution ) {

	Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

}

CubeCamera.prototype = Object.create( Object3D.prototype );
CubeCamera.prototype.constructor = CubeCamera;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioListener() {

	Object3D.call( this );

	this.type = 'AudioListener';

	this.context = AudioContext.getContext();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.filter = null;

}

AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: AudioListener,

	getInput: function () {

		return this.gain;

	},

	removeFilter: function ( ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

	},

	getFilter: function () {

		return this.filter;

	},

	setFilter: function ( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

	},

	getMasterVolume: function () {

		return this.gain.gain.value;

	},

	setMasterVolume: function ( value ) {

		this.gain.gain.value = value;

	},

	updateMatrixWorld: ( function () {

		var position = new Vector3();
		var quaternion = new Quaternion();
		var scale = new Vector3();

		var orientation = new Vector3();

		return function updateMatrixWorld( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			if ( listener.positionX ) {

				listener.positionX.setValueAtTime( position.x, this.context.currentTime );
				listener.positionY.setValueAtTime( position.y, this.context.currentTime );
				listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
				listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
				listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
				listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
				listener.upX.setValueAtTime( up.x, this.context.currentTime );
				listener.upY.setValueAtTime( up.y, this.context.currentTime );
				listener.upZ.setValueAtTime( up.z, this.context.currentTime );

			} else {

				listener.setPosition( position.x, position.y, position.z );
				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

			}

		};

	} )()

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio( listener ) {

	Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;

	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );

	this.autoplay = false;

	this.buffer = null;
	this.loop = false;
	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';

	this.filters = [];

}

Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Audio,

	getOutput: function () {

		return this.gain;

	},

	setNodeSource: function ( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	},

	setBuffer: function ( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	},

	play: function () {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.buffer;
		source.loop = this.loop;
		source.onended = this.onEnded.bind( this );
		source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
		source.start( 0, this.startTime );

		this.isPlaying = true;

		this.source = source;

		return this.connect();

	},

	pause: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = this.context.currentTime;
		this.isPlaying = false;

		return this;

	},

	stop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = 0;
		this.isPlaying = false;

		return this;

	},

	connect: function () {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		return this;

	},

	disconnect: function () {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		return this;

	},

	getFilters: function () {

		return this.filters;

	},

	setFilters: function ( value ) {

		if ( ! value ) value = [];

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filters = value;
			this.connect();

		} else {

			this.filters = value;

		}

		return this;

	},

	getFilter: function () {

		return this.getFilters()[ 0 ];

	},

	setFilter: function ( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	},

	setPlaybackRate: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

		}

		return this;

	},

	getPlaybackRate: function () {

		return this.playbackRate;

	},

	onEnded: function () {

		this.isPlaying = false;

	},

	getLoop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	},

	setLoop: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	},

	getVolume: function () {

		return this.gain.gain.value;

	},


	setVolume: function ( value ) {

		this.gain.gain.value = value;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function PositionalAudio( listener ) {

	Audio.call( this, listener );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

}

PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

	constructor: PositionalAudio,

	getOutput: function () {

		return this.panner;

	},

	getRefDistance: function () {

		return this.panner.refDistance;

	},

	setRefDistance: function ( value ) {

		this.panner.refDistance = value;

	},

	getRolloffFactor: function () {

		return this.panner.rolloffFactor;

	},

	setRolloffFactor: function ( value ) {

		this.panner.rolloffFactor = value;

	},

	getDistanceModel: function () {

		return this.panner.distanceModel;

	},

	setDistanceModel: function ( value ) {

		this.panner.distanceModel = value;

	},

	getMaxDistance: function () {

		return this.panner.maxDistance;

	},

	setMaxDistance: function ( value ) {

		this.panner.maxDistance = value;

	},

	updateMatrixWorld: ( function () {

		var position = new Vector3();

		return function updateMatrixWorld( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )()


} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser( audio, fftSize ) {

	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

	this.data = new Uint8Array( this.analyser.frequencyBinCount );

	audio.getOutput().connect( this.analyser );

}

Object.assign( AudioAnalyser.prototype, {

	getFrequencyData: function () {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	},

	getAverageFrequency: function () {

		var value = 0, data = this.getFrequencyData();

		for ( var i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

} );

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	var bufferType = Float64Array,
		mixFunction;

	switch ( typeName ) {

		case 'quaternion':
			mixFunction = this._slerp;
			break;

		case 'string':
		case 'bool':
			bufferType = Array;
			mixFunction = this._select;
			break;

		default:
			mixFunction = this._lerp;

	}

	this.buffer = new bufferType( valueSize * 4 );
	// layout: [ incoming | accu0 | accu1 | orig ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property

	this._mixBufferRegion = mixFunction;

	this.cumulativeWeight = 0;

	this.useCount = 0;
	this.referenceCount = 0;

}

PropertyMixer.prototype = {

	constructor: PropertyMixer,

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,

			currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function( accuIndex ) {

		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,

			binding = this.binding;

		this.cumulativeWeight = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			var originalValueOffset = stride * 3;

			this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function() {

		var binding = this.binding;

		var buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * 3;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		this.cumulativeWeight = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function() {

		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},


	// mix functions

	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		Quaternion.slerpFlat( buffer, dstOffset,
				buffer, dstOffset, buffer, srcOffset, t );

	},

	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		var s = 1 - t;

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

};

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath ||
			PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode(
			rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

PropertyBinding.prototype = {

	constructor: PropertyBinding,

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function() {

		var targetObject = this.node,
			parsedPath = this.parsedPath,

			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode(
					this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

 		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
			return;

		}

		if ( objectName ) {

			var objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( '  can not bind to material as node does not have a material', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( '  can not bind to bones as node does not have a skeleton', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( '  can not bind to objectName of node, undefined', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		var nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			var nodeName = parsedPath.nodeName;

			console.error( "  trying to update property for track: " + nodeName +
					'.' + propertyName + " but it wasn't found.", targetObject );
			return;

		}

		// determine versioning scheme
		var versioning = this.Versioning.None;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;
			this.targetObject = targetObject;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;
			this.targetObject = targetObject;

		}

		// determine how the property gets bound
		var bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {
			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
					return;

				}

				if ( ! targetObject.geometry.morphTargets ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
					return;

				}

				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

						propertyIndex = i;
						break;

					}

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( nodeProperty.length !== undefined ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

};

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function() {},
	_setValue_unavailable: function() {},

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			var source = this.resolvedProperty;

			for ( var i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	]

} );

PropertyBinding.Composite =
		function( targetGroup, path, optionalParsedPath ) {

	var parsedPath = optionalParsedPath ||
			PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

};

PropertyBinding.Composite.prototype = {

	constructor: PropertyBinding.Composite,

	getValue: function( array, offset ) {

		this.bind(); // bind all binding

		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function( array, offset ) {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

};

PropertyBinding.create = function( root, path, parsedPath ) {

	if ( ! ( root && root.isAnimationObjectGroup ) ) {

		return new PropertyBinding( root, path, parsedPath );

	} else {

		return new PropertyBinding.Composite( root, path, parsedPath );

	}

};

PropertyBinding.parseTrackName = function( trackName ) {

	// matches strings in the form of:
	//    nodeName.property
	//    nodeName.property[accessor]
	//    nodeName.material.property[accessor]
	//    uuid.property[accessor]
	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
	//    parentName/nodeName.property
	//    parentName/parentName/nodeName.property[index]
	//    .bone[Armature.DEF_cog].position
	//    scene:helium_balloon_model:helium_balloon_model.position
	// created and tested via https://regex101.com/#javascript

	var re = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/;
	var matches = re.exec( trackName );

	if ( ! matches ) {

		throw new Error( "cannot parse trackName at all: " + trackName );

	}

	var results = {
		// directoryName: matches[ 1 ], // (tschw) currently unused
		nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
		objectName: matches[ 3 ],
		objectIndex: matches[ 4 ],
		propertyName: matches[ 5 ],
		propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
	};

	if ( results.propertyName === null || results.propertyName.length === 0 ) {

		throw new Error( "can not parse propertyName from trackName: " + trackName );

	}

	return results;

};

PropertyBinding.findNode = function( root, nodeName ) {

	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

		return root;

	}

	// search into skeleton bones.
	if ( root.skeleton ) {

		var searchSkeleton = function( skeleton ) {

			for( var i = 0; i < skeleton.bones.length; i ++ ) {

				var bone = skeleton.bones[ i ];

				if ( bone.name === nodeName ) {

					return bone;

				}
			}

			return null;

		};

		var bone = searchSkeleton( root.skeleton );

		if ( bone ) {

			return bone;

		}
	}

	// search into node subtree.
	if ( root.children ) {

		var searchNodeSubtree = function( children ) {

			for( var i = 0; i < children.length; i ++ ) {

				var childNode = children[ i ];

				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

					return childNode;

				}

				var result = searchNodeSubtree( childNode.children );

				if ( result ) return result;

			}

			return null;

		};

		var subTreeNode = searchNodeSubtree( root.children );

		if ( subTreeNode ) {

			return subTreeNode;

		}

	}

	return null;

};

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 * 	-	Add objects you would otherwise pass as 'root' to the
 * 		constructor or the .clipAction method of AnimationMixer.
 *
 * 	-	Instead pass this object as 'root'.
 *
 * 	-	You can also add and remove objects later when the mixer
 * 		is running.
 *
 * Note:
 *
 *  	Objects of this class appear as one object to the mixer,
 *  	so cache control of the individual objects must be done
 *  	on the group.
 *
 * Limitation:
 *
 * 	- 	The animated properties must be compatible among the
 * 		all objects in the group.
 *
 *  -	A single property can either be controlled through a
 *  	target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup( var_args ) {

	this.uuid = _Math.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0;			// threshold
	// note: read by PropertyBinding.Composite

	var indices = {};
	this._indicesByUUID = indices;		// for bookkeeping

	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = [];					// inside: string
	this._parsedPaths = [];				// inside: { we don't care, here }
	this._bindings = []; 				// inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

	var scope = this;

	this.stats = {

		objects: {
			get total() { return scope._objects.length; },
			get inUse() { return this.total - scope.nCachedObjects_;  }
		},

		get bindingsPerObject() { return scope._bindings.length; }

	};

}

AnimationObjectGroup.prototype = {

	constructor: AnimationObjectGroup,

	isAnimationObjectGroup: true,

	add: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ],
				knownObject = undefined;

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push(
							new PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject) {

				console.error( "Different objects with the same UUID " +
						"detected. Clean the caches or recreate your " +
						"infrastructure when reloading scenes..." );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function( var_args ) {

		var objects = this._objects,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function( path, parsedPath ) {
		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( var i = nCachedObjects,
				n = objects.length; i !== n; ++ i ) {

			var object = objects[ i ];

			bindingsForPath[ i ] =
					new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function( path ) {
		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

};

/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction( mixer, clip, localRoot ) {

	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;

	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );

	var interpolantSettings = {
			endingStart: 	ZeroCurvatureEnding,
			endingEnd:		ZeroCurvatureEnding
	};

	for ( var i = 0; i !== nTracks; ++ i ) {

		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings;

	}

	this._interpolantSettings = interpolantSettings;

	this._interpolants = interpolants;	// bound by the mixer

	// inside: PropertyMixer (managed by the mixer)
	this._propertyBindings = new Array( nTracks );

	this._cacheIndex = null;			// for the memory manager
	this._byClipCacheIndex = null;		// for the memory manager

	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;

	this.loop = LoopRepeat;
	this._loopCount = -1;

	// global mixer time when the action is to be started
	// it's set back to 'null' upon start of the action
	this._startTime = null;

	// scaled local time of the action
	// gets clamped or wrapped to 0..clip.duration according to loop
	this.time = 0;

	this.timeScale = 1;
	this._effectiveTimeScale = 1;

	this.weight = 1;
	this._effectiveWeight = 1;

	this.repetitions = Infinity; 		// no. of repetitions when looping

	this.paused = false;				// false -> zero effective time scale
	this.enabled = true;				// true -> zero effective weight

	this.clampWhenFinished 	= false;	// keep feeding the last frame?

	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

}

AnimationAction.prototype = {

	constructor: AnimationAction,

	// State & Scheduling

	play: function() {

		this._mixer._activateAction( this );

		return this;

	},

	stop: function() {

		this._mixer._deactivateAction( this );

		return this.reset();

	},

	reset: function() {

		this.paused = false;
		this.enabled = true;

		this.time = 0;			// restart clip
		this._loopCount = -1;	// forget previous loops
		this._startTime = null;	// forget scheduling

		return this.stopFading().stopWarping();

	},

	isRunning: function() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

	},

	// return true when play has been called
	isScheduled: function() {

		return this._mixer._isActiveAction( this );

	},

	startAt: function( time ) {

		this._startTime = time;

		return this;

	},

	setLoop: function( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	},

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight: function( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	},

	// return the weight considering fading and .enabled
	getEffectiveWeight: function() {

		return this._effectiveWeight;

	},

	fadeIn: function( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	},

	fadeOut: function( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	},

	crossFadeFrom: function( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if( warp ) {

			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	},

	crossFadeTo: function( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	},

	stopFading: function() {

		var weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	},

	// Time Scale Control

	// set the weight stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale: function( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 :timeScale;

		return this.stopWarping();

	},

	// return the time scale considering warping and .paused
	getEffectiveTimeScale: function() {

		return this._effectiveTimeScale;

	},

	setDuration: function( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	},

	syncWith: function( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	},

	halt: function( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	},

	warp: function( startTimeScale, endTimeScale, duration ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,

			timeScale = this.timeScale;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	},

	stopWarping: function() {

		var timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	},

	// Object Accessors

	getMixer: function() {

		return this._mixer;

	},

	getClip: function() {

		return this._clip;

	},

	getRoot: function() {

		return this._localRoot || this._mixer._root;

	},

	// Interna

	_update: function( time, deltaTime, timeDirection, accuIndex ) {
		// called by the mixer

		var startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		var weight = this._updateWeight( time );

		if ( weight > 0 ) {

			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;

			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

				interpolants[ j ].evaluate( clipTime );
				propertyMixers[ j ].accumulate( accuIndex, weight );

			}

		}

	},

	_updateWeight: function( time ) {

		var weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			var interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	},

	_updateTimeScale: function( time ) {

		var timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			var interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	},

	_updateTime: function( deltaTime ) {

		var time = this.time + deltaTime;

		if ( deltaTime === 0 ) return time;

		var duration = this._clip.duration,

			loop = this.loop,
			loopCount = this._loopCount;

		if ( loop === LoopOnce ) {

			if ( loopCount === -1 ) {
				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else break handle_stop;

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? -1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			var pingPong = ( loop === LoopPingPong );

			if ( loopCount === -1 ) {
				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings(
							true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings(
							this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {
				// wrap around

				var loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				var pending = this.repetitions - loopCount;

				if ( pending < 0 ) {
					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : -1
					} );

				} else {
					// keep running

					if ( pending === 0 ) {
						// entering the last round

						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {
				// invert time for the "pong round"

				this.time = time;
				return duration - time;

			}

		}

		this.time = time;
		return time;

	},

	_setEndings: function( atStart, atEnd, pingPong ) {

		var settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart 	= ZeroSlopeEnding;
			settings.endingEnd		= ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ?
						ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ?
						ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	},

	_scheduleFading: function( duration, weightNow, weightThen ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now; 				values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

		return this;

	}

};

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

}

AnimationMixer.prototype = {

	constructor: AnimationMixer,

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function ( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject !== null ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ],
			prototypeAction = null;

		if ( actionsForClip !== undefined ) {

			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		var newAction = new AnimationAction( this, clipObject, optionalRoot );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function ( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function () {

		var actions = this._actions,
			nActions = this._nActiveActions,
			bindings = this._bindings,
			nBindings = this._nActiveBindings;

		this._nActiveActions = 0;
		this._nActiveBindings = 0;

		for ( var i = 0; i !== nActions; ++ i ) {

			actions[ i ].reset();

		}

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].useCount = 0;

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function ( deltaTime ) {

		deltaTime *= this.timeScale;

		var actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( var i = 0; i !== nActions; ++ i ) {

			var action = actions[ i ];

			if ( action.enabled ) {

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

		}

		// update scene graph

		var bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// return this mixer's root target object
	getRoot: function () {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function ( clip ) {

		var actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			var actionsToRemove = actionsForClip.knownActions;

			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				var action = actionsToRemove[ i ];

				this._deactivateAction( action );

				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function ( root ) {

		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( var clipUuid in actionsByClip ) {

			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( var trackName in bindingByName ) {

				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function ( clip, optionalRoot ) {

		var action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

};

// Implementation details:

Object.assign( AnimationMixer.prototype, {

	_bindAction: function ( action, prototypeAction ) {

		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( var i = 0; i !== nTracks; ++ i ) {

			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function ( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			var bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function ( action ) {

		if ( this._isActiveAction( action ) ) {

			var bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function () {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 		knownActions: Array< AnimationAction >	- used as prototypes
		// 		actionByRoot: AnimationAction			- lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		var scope = this;

		this.stats = {

			actions: {
				get total() { return scope._actions.length; },
				get inUse() { return scope._nActiveActions; }
			},
			bindings: {
				get total() { return scope._bindings.length; },
				get inUse() { return scope._nActiveBindings; }
			},
			controlInterpolants: {
				get total() { return scope._controlInterpolants.length; },
				get inUse() { return scope._nActiveControlInterpolants; }
			}

		};

	},

	// Memory management for AnimationAction objects

	_isActiveAction: function ( action ) {

		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			var knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function ( action ) {

		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		var clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( actions._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function ( action ) {

		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

			var binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function ( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function ( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			bindings = this._bindings;

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function ( binding ) {

		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		remove_empty_map: {

			for ( var _ in bindingByName ) break remove_empty_map;

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function () {

		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
						1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function ( interpolant ) {

		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 )

} );

Object.assign( AnimationMixer.prototype, EventDispatcher.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform( value ) {

	if ( typeof value === 'string' ) {

		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];

	}

	this.value = value;

}

Uniform.prototype.clone = function () {

	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

}

InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {

	this.groups.push( {

		start: start,
		count: count,
		materialIndex: materialIndex

	} );

};

InstancedBufferGeometry.prototype.copy = function ( source ) {

	var index = source.index;

	if ( index !== null ) {

		this.setIndex( index.clone() );

	}

	var attributes = source.attributes;

	for ( var name in attributes ) {

		var attribute = attributes[ name ];
		this.addAttribute( name, attribute.clone() );

	}

	var groups = source.groups;

	for ( var i = 0, l = groups.length; i < l; i ++ ) {

		var group = groups[ i ];
		this.addGroup( group.start, group.count, group.materialIndex );

	}

	return this;

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.uuid = _Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}


InterleavedBufferAttribute.prototype = {

	constructor: InterleavedBufferAttribute,

	isInterleavedBufferAttribute: true,

	get count() {

		return this.data.count;

	},

	get array() {

		return this.data.array;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer( array, stride ) {

	this.uuid = _Math.generateUUID();

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.onUploadCallback = function () {};

	this.version = 0;

}

InterleavedBuffer.prototype = {

	constructor: InterleavedBuffer,

	isInterleavedBuffer: true,

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setArray: function ( array ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.count = array !== undefined ? array.length / this.stride : 0;
		this.array = array;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

InstancedInterleavedBuffer.prototype.copy = function ( source ) {

	InterleavedBuffer.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

	BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

InstancedBufferAttribute.prototype.copy = function ( source ) {

	BufferAttribute.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster( origin, direction, near, far ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near || 0;
	this.far = far || Infinity;

	this.params = {
		Mesh: {},
		Line: {},
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {
				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;
			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.visible === false ) return;

	object.raycast( raycaster, intersects );

	if ( recursive === true ) {

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

//

Raycaster.prototype = {

	constructor: Raycaster,

	linePrecision: 1,

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( (camera && camera.isPerspectiveCamera) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

		} else if ( (camera && camera.isOrthographicCamera) ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	},

	intersectObject: function ( object, recursive ) {

		var intersects = [];

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive ) {

		var intersects = [];

		if ( Array.isArray( objects ) === false ) {

			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;

		}

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

}

Clock.prototype = {

	constructor: Clock,

	start: function () {

		this.startTime = ( performance || Date ).now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = ( performance || Date ).now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */

function Spherical( radius, phi, theta ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

	return this;

}

Spherical.prototype = {

	constructor: Spherical,

	set: function ( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	},

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe: function() {

		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	},

	setFromVector3: function( vec3 ) {

		this.radius = vec3.length();

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
			this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

		}

		return this;

	}

};

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical( radius, theta, y ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

	return this;

}

Cylindrical.prototype = {

	constructor: Cylindrical,

	set: function ( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	},

	setFromVector3: function( vec3 ) {

		this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
		this.theta = Math.atan2( vec3.x, vec3.z );
		this.y = vec3.y;

		return this;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function MorphBlendMesh( geometry, material ) {

	Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

}

MorphBlendMesh.prototype = Object.create( Mesh.prototype );
MorphBlendMesh.prototype.constructor = MorphBlendMesh;

MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/i;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function VertexNormalsHelper( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry && objGeometry.isGeometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry && objGeometry.isBufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count;

	}

	//

	var geometry = new BufferGeometry();

	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

}

VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

		return this;

	};

}() );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function SpotLightHelper( light ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new BufferGeometry();

	var positions = [
		0, 0, 0,   0,   0,   1,
		0, 0, 0,   1,   0,   1,
		0, 0, 0, - 1,   0,   1,
		0, 0, 0,   0,   1,   1,
		0, 0, 0,   0, - 1,   1
	];

	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;

		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	var material = new LineBasicMaterial( { fog: false } );

	this.cone = new LineSegments( geometry, material );
	this.add( this.cone );

	this.update();

}

SpotLightHelper.prototype = Object.create( Object3D.prototype );
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

SpotLightHelper.prototype.update = function () {

	var vector = new Vector3();
	var vector2 = new Vector3();

	return function update() {

		var coneLength = this.light.distance ? this.light.distance : 1000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */

function SkeletonHelper( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new BufferGeometry();

	var vertices = [];
	var colors = [];

	var color1 = new Color( 0, 0, 1 );
	var color2 = new Color( 0, 1, 0 );

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent && bone.parent.isBone ) {

			vertices.push( 0, 0, 0 );
			vertices.push( 0, 0, 0 );
			colors.push( color1.r, color1.g, color1.b );
			colors.push( color2.r, color2.g, color2.b );

		}

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	LineSegments.call( this, geometry, material );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

}


SkeletonHelper.prototype = Object.create( LineSegments.prototype );
SkeletonHelper.prototype.constructor = SkeletonHelper;

SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

SkeletonHelper.prototype.update = function () {

	var vector = new Vector3();

	var boneMatrix = new Matrix4();
	var matrixWorldInv = new Matrix4();

	return function update() {

		var geometry = this.geometry;
		var position = geometry.getAttribute( 'position' );

		matrixWorldInv.getInverse( this.root.matrixWorld );

		for ( var i = 0, j = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j, vector.x, vector.y, vector.z );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j + 1, vector.x, vector.y, vector.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function PointLightHelper( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

}

PointLightHelper.prototype = Object.create( Mesh.prototype );
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 */

function RectAreaLightHelper( light ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	var materialFront = new MeshBasicMaterial( {
		color: light.color,
		fog: false
	} );

	var materialBack = new MeshBasicMaterial( {
		color: light.color,
		fog: false,
		wireframe: true
	} );

	var geometry = new BufferGeometry();

	geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 6 * 3 ), 3 ) );

	// shows the "front" of the light, e.g. where light comes from

	this.add( new Mesh( geometry, materialFront ) );

	// shows the "back" of the light, which does not emit light

	this.add( new Mesh( geometry, materialBack ) );

	this.update();

}

RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

RectAreaLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();
	this.children[ 1 ].geometry.dispose();
	this.children[ 1 ].material.dispose();

};

RectAreaLightHelper.prototype.update = function () {

	var vector1 = new Vector3();
	var vector2 = new Vector3();

	return function update() {

		var mesh1 = this.children[ 0 ];
		var mesh2 = this.children[ 1 ];

		if ( this.light.target ) {

			vector1.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			var lookVec = vector2.clone().sub( vector1 );
			mesh1.lookAt( lookVec );
			mesh2.lookAt( lookVec );

		}

		// update materials

		mesh1.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
		mesh2.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		// calculate new dimensions of the helper

		var hx = this.light.width * 0.5;
		var hy = this.light.height * 0.5;

		// because the buffer attribute is shared over both geometries, we only have to update once

		var position = mesh1.geometry.getAttribute( 'position' );
		var array = position.array;

		// first face

		array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
		array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
		array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;

		// second face

		array[  9 ] = - hx; array[ 10 ] =   hy; array[ 11 ] = 0;
		array[ 12 ] = - hx; array[ 13 ] = - hy; array[ 14 ] = 0;
		array[ 15 ] =   hx; array[ 16 ] = - hy; array[ 17 ] = 0;

		position.needsUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function HemisphereLightHelper( light, size ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new OctahedronBufferGeometry( size );
	geometry.rotateY( Math.PI * 0.5 );

	var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );

	var position = geometry.getAttribute( 'position' );
	var colors = new Float32Array( position.count * 3 );

	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

	this.add( new Mesh( geometry, material ) );

	this.update();

}

HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();

};

HemisphereLightHelper.prototype.update = function () {

	var vector = new Vector3();

	var color1 = new Color();
	var color2 = new Color();

	return function update() {

		var mesh = this.children[ 0 ];

		var colors = mesh.geometry.getAttribute( 'color' );

		color1.copy( this.light.color ).multiplyScalar( this.light.intensity );
		color2.copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		for ( var i = 0, l = colors.count; i < l; i ++ ) {

			var color = ( i < ( l / 2 ) ) ? color1 : color2;

			colors.setXYZ( i, color.r, color.g, color.b );

		}

		mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		colors.needsUpdate = true;

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function GridHelper( size, divisions, color1, color2 ) {

	size = size || 10;
	divisions = divisions || 10;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var center = divisions / 2;
	var step = size / divisions;
	var halfSize = size / 2;

	var vertices = [], colors = [];

	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

		vertices.push( - halfSize, 0, k, halfSize, 0, k );
		vertices.push( k, 0, - halfSize, k, 0, halfSize );

		var color = i === center ? color1 : color2;

		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;

	}

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

GridHelper.prototype = Object.create( LineSegments.prototype );
GridHelper.prototype.constructor = GridHelper;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

	radius = radius || 10;
	radials = radials || 16;
	circles = circles || 8;
	divisions = divisions || 64;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var vertices = [];
	var colors = [];

	var x, z;
	var v, i, j, r, color;

	// create the radials

	for ( i = 0; i <= radials; i ++ ) {

		v = ( i / radials ) * ( Math.PI * 2 );

		x = Math.sin( v ) * radius;
		z = Math.cos( v ) * radius;

		vertices.push( 0, 0, 0 );
		vertices.push( x, 0, z );

		color = ( i & 1 ) ? color1 : color2;

		colors.push( color.r, color.g, color.b );
		colors.push( color.r, color.g, color.b );

	}

	// create the circles

	for ( i = 0; i <= circles; i ++ ) {

		color = ( i & 1 ) ? color1 : color2;

		r = radius - ( radius / circles * i );

		for ( j = 0; j < divisions; j ++ ) {

			// first vertex

			v = ( j / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

			// second vertex

			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

		}

	}

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

PolarGridHelper.prototype = Object.create( LineSegments.prototype );
PolarGridHelper.prototype.constructor = PolarGridHelper;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function FaceNormalsHelper( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports THREE.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry && objGeometry.isGeometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new BufferGeometry();

	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

}

FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

		return this;

	};

}() );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function DirectionalLightHelper( light, size ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	if ( size === undefined ) size = 1;

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [
		- size,   size, 0,
		  size,   size, 0,
		  size, - size, 0,
		- size, - size, 0,
		- size,   size, 0
	], 3 ) );

	var material = new LineBasicMaterial( { fog: false } );

	this.add( new Line( geometry, material ) );

	geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

	this.add( new Line( geometry, material ));

	this.update();

}

DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {

	var lightPlane = this.children[ 0 ];
	var targetLine = this.children[ 1 ];

	lightPlane.geometry.dispose();
	lightPlane.material.dispose();
	targetLine.geometry.dispose();
	targetLine.material.dispose();

};

DirectionalLightHelper.prototype.update = function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var v3 = new Vector3();

	return function update() {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		var lightPlane = this.children[ 0 ];
		var targetLine = this.children[ 1 ];

		lightPlane.lookAt( v3 );
		lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		targetLine.lookAt( v3 );
		targetLine.scale.z = v3.length();

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

function CameraHelper( camera ) {

	var geometry = new BufferGeometry();
	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

	var vertices = [];
	var colors = [];

	var pointMap = {};

	// colors

	var colorFrustum = new Color( 0xffaa00 );
	var colorCone = new Color( 0xff0000 );
	var colorUp = new Color( 0x00aaff );
	var colorTarget = new Color( 0xffffff );
	var colorCross = new Color( 0x333333 );

	// near

	addLine( "n1", "n2", colorFrustum );
	addLine( "n2", "n4", colorFrustum );
	addLine( "n4", "n3", colorFrustum );
	addLine( "n3", "n1", colorFrustum );

	// far

	addLine( "f1", "f2", colorFrustum );
	addLine( "f2", "f4", colorFrustum );
	addLine( "f4", "f3", colorFrustum );
	addLine( "f3", "f1", colorFrustum );

	// sides

	addLine( "n1", "f1", colorFrustum );
	addLine( "n2", "f2", colorFrustum );
	addLine( "n3", "f3", colorFrustum );
	addLine( "n4", "f4", colorFrustum );

	// cone

	addLine( "p", "n1", colorCone );
	addLine( "p", "n2", colorCone );
	addLine( "p", "n3", colorCone );
	addLine( "p", "n4", colorCone );

	// up

	addLine( "u1", "u2", colorUp );
	addLine( "u2", "u3", colorUp );
	addLine( "u3", "u1", colorUp );

	// target

	addLine( "c", "t", colorTarget );
	addLine( "p", "c", colorCross );

	// cross

	addLine( "cn1", "cn2", colorCross );
	addLine( "cn3", "cn4", colorCross );

	addLine( "cf1", "cf2", colorCross );
	addLine( "cf3", "cf4", colorCross );

	function addLine( a, b, color ) {

		addPoint( a, color );
		addPoint( b, color );

	}

	function addPoint( id, color ) {

		vertices.push( 0, 0, 0 );
		colors.push( color.r, color.g, color.b );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	LineSegments.call( this, geometry, material );

	this.camera = camera;
	if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

}

CameraHelper.prototype = Object.create( LineSegments.prototype );
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new Vector3();
	var camera = new Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			var position = geometry.getAttribute( 'position' );

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

			}

		}

	}

	return function update() {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BoxHelper( object, color ) {

	if ( color === undefined ) color = 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new BufferGeometry();
	geometry.setIndex( new BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

	if ( object !== undefined ) {

		this.update( object );

	}

}

BoxHelper.prototype = Object.create( LineSegments.prototype );
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = ( function () {

	var box = new Box3();

	return function update( object ) {

		if ( object && object.isBox3 ) {

			box.copy( object );

		} else {

			box.setFromObject( object );

		}

		if ( box.isEmpty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	};

} )();

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

var lineGeometry;
var coneGeometry;

function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

	// dir is assumed to be normalized

	Object3D.call( this );

	if ( color === undefined ) color = 0xffff00;
	if ( length === undefined ) length = 1;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	if ( lineGeometry === undefined ) {

		lineGeometry = new BufferGeometry();
		lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

		coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

	}

	this.position.copy( origin );

	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

}

ArrowHelper.prototype = Object.create( Object3D.prototype );
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = ( function () {

	var axis = new Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.copy( color );
	this.cone.material.color.copy( color );

};

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

function AxisHelper( size ) {

	size = size || 1;

	var vertices = [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	];

	var colors = [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	];

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

AxisHelper.prototype = Object.create( LineSegments.prototype );
AxisHelper.prototype.constructor = AxisHelper;

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			var t2 = t * t;
			var t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();

function CatmullRomCurve3( p /* array of Vector3 */ ) {

	this.points = p || [];
	this.closed = false;

}

CatmullRomCurve3.prototype = Object.create( Curve.prototype );
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

CatmullRomCurve3.prototype.getPoint = function ( t ) {

	var points = this.points;
	var l = points.length;

	if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

	var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	if ( this.closed ) {

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

	} else if ( weight === 0 && intPoint === l - 1 ) {

		intPoint = l - 2;
		weight = 1;

	}

	var p0, p1, p2, p3; // 4 points

	if ( this.closed || intPoint > 0 ) {

		p0 = points[ ( intPoint - 1 ) % l ];

	} else {

		// extrapolate first point
		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
		p0 = tmp;

	}

	p1 = points[ intPoint % l ];
	p2 = points[ ( intPoint + 1 ) % l ];

	if ( this.closed || intPoint + 2 < l ) {

		p3 = points[ ( intPoint + 2 ) % l ];

	} else {

		// extrapolate last point
		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
		p3 = tmp;

	}

	if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

		// init Centripetal / Chordal Catmull-Rom
		var pow = this.type === 'chordal' ? 0.5 : 0.25;
		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

		// safety check for repeated points
		if ( dt1 < 1e-4 ) dt1 = 1.0;
		if ( dt0 < 1e-4 ) dt0 = dt1;
		if ( dt2 < 1e-4 ) dt2 = dt1;

		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

	} else if ( this.type === 'catmullrom' ) {

		var tension = this.tension !== undefined ? this.tension : 0.5;
		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

	}

	return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );

};

function CubicBezierCurve3( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

}

CubicBezierCurve3.prototype = Object.create( Curve.prototype );
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

CubicBezierCurve3.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	return new Vector3(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
	);

};

function QuadraticBezierCurve3( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

}

QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

QuadraticBezierCurve3.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	return new Vector3(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y ),
		QuadraticBezier( t, v0.z, v1.z, v2.z )
	);

};

function LineCurve3( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

}

LineCurve3.prototype = Object.create( Curve.prototype );
LineCurve3.prototype.constructor = LineCurve3;

LineCurve3.prototype.getPoint = function ( t ) {

	if ( t === 1 ) {

		return this.v2.clone();

	}

	var vector = new Vector3();

	vector.subVectors( this.v2, this.v1 ); // diff
	vector.multiplyScalar( t );
	vector.add( this.v1 );

	return vector;

};

function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

}

ArcCurve.prototype = Object.create( EllipseCurve.prototype );
ArcCurve.prototype.constructor = ArcCurve;

/**
 * @author alteredq / http://alteredqualia.com/
 */

var SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new Face3( a, b, c, normal, color, materialIndex );

}

var LineStrip = 0;

var LinePieces = 1;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.' );
	return new MultiMaterial( materials );

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
	return new BufferAttribute( array, itemSize ).setDynamic( true );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

function ClosedSplineCurve3( points ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

}

ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function SplineCurve3( points ) {

	console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function Spline( points ) {

	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

Spline.prototype = Object.create( CatmullRomCurve3.prototype );

Object.assign( Spline.prototype, {

	initFromArray: function ( a ) {

		console.error( 'THREE.Spline: .initFromArray() has been removed.' );

	},
	getControlPointsArray: function ( optionalTarget ) {

		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

	},
	reparametrizeByArcLength: function ( samplingCoef ) {

		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

	}

} );

//
function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

//

Object.assign( Box2.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Box3.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

_Math.random16 = function () {

	console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
	return Math.random();

};

Object.assign( Matrix3.prototype, {

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},
	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},
	applyToBuffer: function( buffer, offset, length ) {

		console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );

	},
	applyToVector3Array: function( array, offset, length ) {

		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

	}

} );

Object.assign( Matrix4.prototype, {

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},
	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	getPosition: function () {

		var v1;

		return function getPosition() {

			if ( v1 === undefined ) v1 = new Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
			return v1.setFromMatrixColumn( this, 3 );

		};

	}(),
	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},
	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	},
	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	translate: function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},
	rotateX: function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},
	rotateY: function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},
	rotateZ: function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},
	rotateByAxis: function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},
	applyToBuffer: function( buffer, offset, length ) {

		console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );

	},
	applyToVector3Array: function( array, offset, length ) {

		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

	},
	makeFrustum: function( left, right, bottom, top, near, far ) {

		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );

	}

} );

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Object.assign( Ray.prototype, {

	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionPlane: function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	}

} );

Object.assign( Shape.prototype, {

	extrude: function ( options ) {

		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );

	},
	makeGeometry: function ( options ) {

		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );

	}

} );

Object.assign( Vector2.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	}

} );

Object.assign( Vector3.prototype, {

	setEulerFromRotationMatrix: function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},
	setEulerFromQuaternion: function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},
	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	},
	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	},
	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	},
	applyProjection: function ( m ) {

		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );

	},
	fromAttribute: function ( attribute, index, offset ) {

		console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	}

} );

Object.assign( Vector4.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	}

} );

//

Geometry.prototype.computeTangents = function () {

	console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

};

Object.assign( Object3D.prototype, {

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},
	renderDepth: function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},
	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	}

} );

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Object.defineProperties( LOD.prototype, {

	objects: {
		get: function () {

			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	}

} );

Object.assign( BufferGeometry.prototype, {

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},
	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}
		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},
	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},
	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},
	computeOffsets: function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	}

} );

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

//

Object.defineProperties( Uniform.prototype, {

	dynamic: {
		set: function () {

			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

		}
	},
	onUpdate: {
		value: function () {

			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;

		}
	}

} );

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		}
	},
	wrapRGB: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
			return new Color();

		}
	}

} );

Object.defineProperties( MeshPhongMaterial.prototype, {

	metal: {
		get: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

Object.assign( WebGLRenderer.prototype, {

	supportsFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	},
	supportsHalfFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	},
	supportsStandardDerivatives: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	},
	supportsCompressedTextureS3TC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	},
	supportsCompressedTexturePVRTC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	},
	supportsBlendMinMax: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	},
	supportsVertexTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	},
	supportsInstancedArrays: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	},
	enableScissorTest: function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	},
	initMaterial: function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	},
	addPrePlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	},
	addPostPlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	},
	updateShadowMap: function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	}

} );

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			return this.shadowMap.cullFace;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
			this.shadowMap.cullFace = value;

		}
	}
} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			return this.renderReverseSided ? CullFaceFront : CullFaceBack;

		},
		set: function ( cullFace ) {

			var value = ( cullFace !== CullFaceBack );
			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
			this.renderReverseSided = value;

		}
	}

} );

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Audio.prototype.load = function ( file ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	var scope = this;
	var audioLoader = new AudioLoader();
	audioLoader.load( file, function ( buffer ) {

		scope.setBuffer( buffer );

	} );
	return this;

};

AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

var GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
		var matrix;

		if ( geometry2.isMesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

var ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	}

};

//

function Projector() {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function () {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

}

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

}




/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__button_form_button__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__input_form_input__ = __webpack_require__(58);
/**
 * Created by Denis on 02.03.2017.
 */


class Form {
    constructor(options = {data: {}}) {
        this.data = options.data;
        this.el = document.createElement('form');
        this.fields = [];
        this.controls = [];
        this._render();
    }

    _render() {
        this._setAttrs(this.data.form.attrs, this.el);
        let title = document.createElement(this.data.title.type);
        this._setAttrs(this.data.title.attrs, title);
        title.innerHTML = this.data.title.text;
        this.el.appendChild(title);


        this.fields = this._getFields();
        this.controls = this._getControls();
        this._fieldsAppendTo(this.fields, this.el);

        this._controlsAppendTo(this.controls, this.el);
    }

    getElem(){
        return this;
    }

    _getFields() {
        let {fields = []}=this.data;
        return fields.map(data => {
            return new __WEBPACK_IMPORTED_MODULE_1__input_form_input__["a" /* default */](data).getElem();
        });
    }

    _setAttrs(attrs, elem) {
        Object.keys(attrs).forEach(name => {
            elem.setAttribute(name, attrs[name]);
        })
    }

    _fieldsAppendTo(array, elem) {
        array.forEach(item => {
            elem.appendChild(item.el);
            elem.appendChild(item.help_el);
        })
    }

    _controlsAppendTo(array, elem) {
        array.forEach(item => {
            elem.appendChild(item.el);
        })
    }

    _getControls() {
        let {controls = []}=this.data;
        return controls.map(data => {
            return new __WEBPACK_IMPORTED_MODULE_0__button_form_button__["a" /* default */](data).getElem();
        });
    }

    toString() {
        return this.el.outerHTML;
    }

    getFormData() {
        let elements = this.el.elements;
        let fields = {};

        Object.keys(elements).forEach(element => {
            let name = elements[element].name;
            let value = elements[element].value;

            if (!name) {
                return;
            }

            fields[name] = value;
        });
        return fields;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Form;




/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 02.04.2017.
 */
class SinglePlayerStrategy{
    constructor() {

    }

    gameLoop(){

    }

    startGameLoop() {
        this.inteval = setInterval(() => this.gameLoop(), 100);
    }


}
/* harmony export (immutable) */ __webpack_exports__["a"] = SinglePlayerStrategy;


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 03.03.2017.
 */
class CheckFields {
    constructor() {

    }

    static _checkLatin(value) {
        return value.match(/[а-яА-ЯёЁ]+/) === null;
    }

    static checkLogin(obj) {
        let arr = [];
        if (!this._checkLatin(obj.field.value)) {
            arr.push({
                err_text: 'Only Latin',
            })
        }
        if (obj.field.value.length < 4) {
            arr.push({
                err_text: '4 - min length',
            });
        }

        obj.help.textContent = '';
        arr.forEach(item => {
            this.fieldSetErr(obj.field);
            this.fieldRemoveOk(obj.field);

            if (obj.help.textContent === '') {
                obj.help.textContent = item.err_text;
            } else {
                obj.help.textContent = `${obj.help.textContent},${item.err_text}`;
                console.log(obj.help.textContent);
            }
        });

        if (arr.length === 0) {
            this.fieldSetOk(obj.field);
        }

        return arr.length === 0;
    }

    static _checkPassLength(value) {
        return value.length >= 8;
    }

    static _checkPassEquals(value1, value2) {
        return value1 === value2;
    }

    static checkEmpty(value) {
        return value.length === 0;
    }


    static checkPassword(obj1, obj2) {
        let arr = [];
        let check = true;

        if (check) {
            if (!this._checkPassLength(obj1.field.value)) {
                arr.push({
                    err_text: '8 - min length',
                    field: obj1.field,
                    help: obj1.help
                })
            }
            if (!this._checkPassEquals(obj1.field.value, obj2.field.value)) {
                arr.push({
                    err_text: 'Passwords not equals',
                    field: obj1.field,
                    help: obj1.help
                });
                arr.push({
                    err_text: 'Passwords not equals',
                    field: obj2.field,
                    help: obj2.help
                });
            }
        }

        obj1.help.textContent = '';
        obj2.help.textContent = '';
        arr.forEach(item => {
            this.fieldSetErr(item.field);
            this.fieldRemoveOk(item.field);

            if (item.help.textContent === '') {
                item.help.textContent = item.err_text;
            } else {
                item.help.textContent = `${item.help.textContent}.${item.err_text}`;
            }
        });

        if (arr.length === 0) {
            this.fieldSetOk(obj1.field);
            this.fieldSetOk(obj2.field);
        }
        return arr.length === 0;
    }

    static helpSetText(elem, value) {
        elem.textContent = value;
    }

    static fieldSetText(elem, value) {
        elem.value = value;
    }

    static fieldSetErr(elem) {
        elem.classList.add('form__input_error');
    }

    static fieldRemoveErr(elem) {
        elem.classList.remove('form__input_error');
    }

    static fieldSetOk(elem) {
        elem.classList.add('form__input_ok');
    }

    static fieldRemoveOk(elem) {
        elem.classList.remove('form__input_ok');
    }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CheckFields;



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 24.03.2017.
 */
class RouterUrls{
    constructor(){
        this.MAIN = '/';
        this.LOGIN = '/login';
        this.SIGNUP = '/signup';
        this.LEADERBOARD = '/leaderboard';
        this.ABOUT = '/about';
        this.PROFILE = '/profile';

        this.GAME = '/game';
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RouterUrls;


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__support_router_Router__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__views_menu_view_MenuView__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__views_enter_views_LoginView__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__views_enter_views_SignUpView__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__views_leaderboard_view_LeaderBoardView__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__views_about_view_AboutView__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__views_profile_view_ProfileView__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__views_game_view_GameView__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__support_service_UserService__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__game_object_Storage__ = __webpack_require__(9);
/**
 * Created by Denis on 04.03.2017.
 */












new __WEBPACK_IMPORTED_MODULE_8__support_service_UserService__["a" /* default */]().getUser().then(user => {
    __WEBPACK_IMPORTED_MODULE_9__game_object_Storage__["a" /* default */].user = user;
    startRoute();
}).catch(err => {
    console.log(err);
    startRoute();
});


function startRoute() {
    let router = new __WEBPACK_IMPORTED_MODULE_0__support_router_Router__["a" /* default */](window.document.documentElement);
    router.init({
        '/': {
            View: __WEBPACK_IMPORTED_MODULE_1__views_menu_view_MenuView__["a" /* default */],
            el: document.getElementById('menu-view'),
        },
        '/login': {
            View: __WEBPACK_IMPORTED_MODULE_2__views_enter_views_LoginView__["a" /* default */],
            el: document.getElementById('login-view')
        },
        '/signup': {
            View: __WEBPACK_IMPORTED_MODULE_3__views_enter_views_SignUpView__["a" /* default */],
            el: document.getElementById('signup-view')
        },
        '/leaderboard': {
            View: __WEBPACK_IMPORTED_MODULE_4__views_leaderboard_view_LeaderBoardView__["a" /* default */],
            el: document.getElementById('leaderboard-view')
        },
        '/about': {
            View: __WEBPACK_IMPORTED_MODULE_5__views_about_view_AboutView__["a" /* default */],
            el: document.getElementById('about-view')
        },
        '/profile': {
            View: __WEBPACK_IMPORTED_MODULE_6__views_profile_view_ProfileView__["a" /* default */],
            el: document.getElementById('profile-view')
        },
        '/game': {
            View: __WEBPACK_IMPORTED_MODULE_7__views_game_view_GameView__["a" /* default */],
            el: document.getElementById('game-view')
        }
    });

    router.start();
}






/***/ }),
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * iziToast | v1.1.0
 * http://izitoast.marcelodolce.com
 * by Marcelo Dolce.
 */ 
(function (root, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory(root)),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof exports === 'object') {
		module.exports = factory(root);
	} else {
		root.iziToast = factory(root);
	}
})(typeof global !== "undefined" ? global : this.window || this.global, function (root) {

	'use strict';

	//
	// Variables
	//
	var $iziToast = {},
		PLUGIN_NAME = 'iziToast',
		BODY = document.querySelector('body'),
		ISMOBILE = (/Mobi/.test(navigator.userAgent)) ? true : false,
		ISCHROME = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor),
		ISFIREFOX = typeof InstallTrigger !== 'undefined',
		ACCEPTSTOUCH = 'ontouchstart' in document.documentElement,
		POSITIONS = ['bottomRight','bottomLeft','bottomCenter','topRight','topLeft','topCenter','center'],
		THEMES = {
			info: {
				color: "blue",
				icon: "ico-info"
			},
			success: {
				color: "green",
				icon: "ico-check",
			},
			warning: {
				color: "yellow",
				icon: "ico-warning",
			},
			error: {
				color: "red",
				icon: "ico-error",
			}
		},
		MOBILEWIDTH = 568,
		CONFIG = {};

	// Default settings
	var defaults = {
		class: '',
		title: '',
		titleColor: '',
		message: '',
		messageColor: '',
		backgroundColor: '',
		color: '', // blue, red, green, yellow
		icon: '',
		iconText: '',
		iconColor: '',
		image: '',
		imageWidth: 50,
		zindex: 99999,
		layout: 1,
		balloon: false,
		close: true,
		rtl: false,
		position: 'bottomRight', // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
		target: '',
		targetFirst: true,
		timeout: 5000,
		drag: true,
		pauseOnHover: true,
		resetOnHover: false,
		progressBar: true,
		progressBarColor: '',
		animateInside: true,
		buttons: {},
		transitionIn: 'fadeInUp', // bounceInLeft, bounceInRight, bounceInUp, bounceInDown, fadeIn, fadeInDown, fadeInUp, fadeInLeft, fadeInRight, flipInX
		transitionOut: 'fadeOut', // fadeOut, fadeOutUp, fadeOutDown, fadeOutLeft, fadeOutRight, flipOutX
		transitionInMobile: 'fadeInUp',
		transitionOutMobile: 'fadeOutDown',
		onOpen: function () {},
		onClose: function () {}
	};

	//
	// Methods
	//


	/**
	 * Polyfill for remove() method
	 */
	if (!('remove' in Element.prototype)) {
	    Element.prototype.remove = function() {
	        if (this.parentNode) {
	            this.parentNode.removeChild(this);
	        }
	    };
	}

	/**
	 * A simple forEach() implementation for Arrays, Objects and NodeLists
	 * @private
	 * @param {Array|Object|NodeList} collection Collection of items to iterate
	 * @param {Function} callback Callback function for each iteration
	 * @param {Array|Object|NodeList} scope Object/NodeList/Array that forEach is iterating over (aka `this`)
	 */
	var forEach = function (collection, callback, scope) {
		if (Object.prototype.toString.call(collection) === '[object Object]') {
			for (var prop in collection) {
				if (Object.prototype.hasOwnProperty.call(collection, prop)) {
					callback.call(scope, collection[prop], prop, collection);
				}
			}
		} else {
			if(collection){
				for (var i = 0, len = collection.length; i < len; i++) {
					callback.call(scope, collection[i], i, collection);
				}
			}
		}
	};

	/**
	 * Merge defaults with user options
	 * @private
	 * @param {Object} defaults Default settings
	 * @param {Object} options User options
	 * @returns {Object} Merged values of defaults and options
	 */
	var extend = function (defaults, options) {
		var extended = {};
		forEach(defaults, function (value, prop) {
			extended[prop] = defaults[prop];
		});
		forEach(options, function (value, prop) {
			extended[prop] = options[prop];
		});
		return extended;
	};


	/**
	 * Create a fragment DOM elements
	 * @private
	 */
	var createFragElem = function(htmlStr) {
		var frag = document.createDocumentFragment(),
			temp = document.createElement('div');
		temp.innerHTML = htmlStr;
		while (temp.firstChild) {
			frag.appendChild(temp.firstChild);
		}
		return frag;
	};


	/**
	 * Check if is a color
	 * @private
	 */
	var isColor = function(color){
		if( color.substring(0,1) == "#" || color.substring(0,3) == "rgb" || color.substring(0,3) == "hsl" ){
			return true;
		} else {
			return false;
		}
	};


	/**
	 * Drag method of toasts
	 * @private
	 */
	var drag = function() {
	    
	    return {
	        move: function(toast, instance, settings, xpos) {

	        	var opacity,
	        		opacityRange = 0.3,
	        		distance = 180;
	            
	            toast.style.transform = 'translateX('+xpos + 'px)';

	            if(xpos > 0){
	            	opacity = (distance-xpos) / distance;
	            	if(opacity < opacityRange){
						instance.hide(extend(settings, { transitionOut: 'fadeOutRight', transitionOutMobile: 'fadeOutRight' }), toast, 'drag');
					}
	            } else {
	            	opacity = (distance+xpos) / distance;
	            	if(opacity < opacityRange){
						instance.hide(extend(settings, { transitionOut: 'fadeOutLeft', transitionOutMobile: 'fadeOutLeft' }), toast, 'drag');
					}
	            }
				toast.style.opacity = opacity;
		
				if(opacity < opacityRange){

					if(ISCHROME || ISFIREFOX)
						toast.style.left = xpos+'px';

					toast.parentNode.style.opacity = opacityRange;

	                this.stopMoving(toast, null);
				}
				
	        },
	        startMoving: function(toast, instance, settings, e) {

	            e = e || window.event;
	            var posX = ((ACCEPTSTOUCH) ? e.touches[0].clientX : e.clientX),
	                toastLeft = toast.style.transform.replace('px)', '');
	                toastLeft = toastLeft.replace('translateX(', '');
	            var offsetX = posX - toastLeft;

				toast.classList.remove(settings.transitionIn);
				toast.classList.remove(settings.transitionInMobile);
				toast.style.transition = "";

	            if (ACCEPTSTOUCH) {
	                document.ontouchmove = function(e) {
	                    e.preventDefault();
	                    e = e || window.event;
	                    var posX = e.touches[0].clientX,
	                        finalX = posX - offsetX;
                        drag.move(toast, instance, settings, finalX);
	                };
	            } else {
	                document.onmousemove = function(e) {
	                    e.preventDefault();
	                    e = e || window.event;
	                    var posX = e.clientX,
	                        finalX = posX - offsetX;
                        drag.move(toast, instance, settings, finalX);
	                };
	            }

	        },
	        stopMoving: function(toast, e) {

	            if (ACCEPTSTOUCH) {
	                document.ontouchmove = function() {};
	            } else {
	            	document.onmousemove = function() {};
	            }
				toast.style.transition = "transform 0.4s ease, opacity 0.4s ease";
				toast.style.opacity = "";
				toast.style.transform = "";
				window.setTimeout(function() {
					toast.style.transition = "";
				}, 400);
	        }
	    };

	}();


	/**
	 * Do the calculation to move the progress bar
	 * @private
	 */
	var moveProgress = function(toast, settings, callback){

		var isPaused = false;
		var isReseted = false;
		var isClosed = false;
		var timerTimeout = null;
		var elem = toast.querySelector("."+PLUGIN_NAME+"-progressbar div");
		var progressBar = {
			hideEta: null,
			maxHideTime: null,
			currentTime: new Date().getTime(),
			updateProgress: function()
			{
				isPaused = toast.classList.contains(PLUGIN_NAME+'-paused') ? true : false;
				isReseted = toast.classList.contains(PLUGIN_NAME+'-reseted') ? true : false;
				isClosed = toast.classList.contains(PLUGIN_NAME+'-closed') ? true : false;

				if(isReseted){
					clearTimeout(timerTimeout);
					elem.style.width = '100%';
					moveProgress(toast, settings, callback);
					toast.classList.remove(PLUGIN_NAME+'-reseted');
				}
				if(isClosed){
					clearTimeout(timerTimeout);
					toast.classList.remove(PLUGIN_NAME+'-closed');
				}

				if(!isPaused && !isReseted && !isClosed){
					progressBar.currentTime = progressBar.currentTime+10;
					var percentage = ((progressBar.hideEta - (progressBar.currentTime)) / progressBar.maxHideTime) * 100;
					elem.style.width = percentage + '%';

					if(Math.round(percentage) < 0 || typeof toast != 'object'){
						clearTimeout(timerTimeout);
						callback.apply();
					}
				}

			}
		};
		if (settings.timeout > 0) {
			progressBar.maxHideTime = parseFloat(settings.timeout);
			progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
			timerTimeout = setInterval(progressBar.updateProgress, 10);
		}
	};

	/**
	 * Destroy the current initialization.
	 * @public
	 */
	$iziToast.destroy = function () {

		forEach(document.querySelectorAll('.'+PLUGIN_NAME+'-wrapper'), function(element, index) {
			element.remove();
		});

		forEach(document.querySelectorAll('.'+PLUGIN_NAME), function(element, index) {
			element.remove();
		});

		// Remove event listeners
		document.removeEventListener(PLUGIN_NAME+'-open', {}, false);
		document.removeEventListener(PLUGIN_NAME+'-close', {}, false);

		// Reset variables
		CONFIG = {};
	};

	/**
	 * Initialize Plugin
	 * @public
	 * @param {Object} options User settings
	 */
	$iziToast.settings = function (options) {

		// Destroy any existing initializations
		$iziToast.destroy();

		CONFIG = options;
		defaults = extend(defaults, options || {});
	};


	/**
	 * Building themes functions.
	 * @public
	 * @param {Object} options User settings
	 */
	forEach(THEMES, function (theme, name) {

		$iziToast[name] = function (options) {

			var settings = extend(CONFIG, options || {});
			settings = extend(theme, settings || {});

			this.show(settings);
		};

	});


	/**
	 * Close the specific Toast
	 * @public
	 * @param {Object} options User settings
	 */
	$iziToast.hide = function (options, $toast, closedBy) {

		var settings = extend(defaults, options || {});
			closedBy = closedBy || false;

		if(typeof $toast != 'object'){
			$toast = document.querySelector($toast);
		}
		$toast.classList.add(PLUGIN_NAME+'-closed');

		if(settings.transitionIn || settings.transitionInMobile){
			$toast.classList.remove(settings.transitionIn);
			$toast.classList.remove(settings.transitionInMobile);
		}

		if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
			if(settings.transitionOutMobile)
				$toast.classList.add(settings.transitionOutMobile);
		} else{
			if(settings.transitionOut)
				$toast.classList.add(settings.transitionOut);
		}
		var H = $toast.parentNode.offsetHeight;
				$toast.parentNode.style.height = H+'px';
				$toast.style.pointerEvents = 'none';
		
		if(!ISMOBILE || window.innerWidth > MOBILEWIDTH){
			$toast.parentNode.style.transitionDelay = '0.2s';
		}

		setTimeout(function() {
			$toast.parentNode.style.height = '0px';
			$toast.parentNode.style.overflow = '';
			window.setTimeout(function(){
				$toast.parentNode.remove();
			},1000);
		},200);

		if (settings.class){
			try {
				var event;
				if (window.CustomEvent) {
					event = new CustomEvent(PLUGIN_NAME+'-close', {detail: {class: settings.class}});
				} else {
					event = document.createEvent('CustomEvent');
					event.initCustomEvent(PLUGIN_NAME+'-close', true, true, {class: settings.class});
				}
				document.dispatchEvent(event);
			} catch(ex){
				console.warn(ex);
			}
		}

		if(typeof settings.onClose !== "undefined"){
			settings.onClose.apply(null, [settings, $toast, closedBy]);
		}
	};

	/**
	 * Create and show the Toast
	 * @public
	 * @param {Object} options User settings
	 */
	$iziToast.show = function (options) {

		var that = this;

		// Merge user options with defaults
		var settings = extend(CONFIG, options || {});
			settings = extend(defaults, settings);

		var $toastCapsule = document.createElement("div");
			$toastCapsule.classList.add(PLUGIN_NAME+"-capsule");

		var $toast = document.createElement("div");
			$toast.classList.add(PLUGIN_NAME);

		if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
			if(settings.transitionInMobile.length>0)
				$toast.classList.add(settings.transitionInMobile);
		} else {
			if(settings.transitionIn.length>0)
				$toast.classList.add(settings.transitionIn);
		}

		if(settings.rtl){
			$toast.classList.add(PLUGIN_NAME + '-rtl');
		}

		if (settings.color.length > 0) { //#, rgb, rgba, hsl
			
			if( isColor(settings.color) ){
				$toast.style.background = settings.color;
			} else {
				$toast.classList.add(PLUGIN_NAME+'-color-'+settings.color);
			}
		}
		if (settings.backgroundColor.length > 0) {
			$toast.style.background = settings.backgroundColor;
		}

		if (settings.class){
			$toast.classList.add(settings.class);
		}

		if (settings.image) {
			var $cover = document.createElement("div");
			$cover.classList.add(PLUGIN_NAME + '-cover');
			$cover.style.width = settings.imageWidth + "px";
			$cover.style.backgroundImage = 'url(' + settings.image + ')';
			$toast.appendChild($cover);
		}

		var $buttonClose;
		if(settings.close){
			$buttonClose = document.createElement("button");
			$buttonClose.classList.add(PLUGIN_NAME + '-close');
			$toast.appendChild($buttonClose);
		} else {
			if(settings.rtl){
				$toast.style.paddingLeft = "30px";
			} else {
				$toast.style.paddingRight = "30px";
			}
		}

		if (settings.progressBar) {

			var $progressBar = document.createElement("div");
				$progressBar.classList.add(PLUGIN_NAME + '-progressbar');

			var $progressBarDiv = document.createElement("div");
				$progressBarDiv.style.background = settings.progressBarColor;

			$progressBar.appendChild($progressBarDiv);
			$toast.appendChild($progressBar);
			
			setTimeout(function() {
				moveProgress($toast, settings, function(){
					that.hide(settings, $toast);
				});
			},300);
		}
		else if( settings.progressBar === false && settings.timeout > 0){
			setTimeout(function() {
				that.hide(settings, $toast);
			}, settings.timeout);
		}

		var $toastBody = document.createElement("div");
			$toastBody.classList.add(PLUGIN_NAME + '-body');

		if (settings.image) {
			if(settings.rtl){
				$toastBody.style.marginRight = (settings.imageWidth + 10) + 'px';
			} else {
				$toastBody.style.marginLeft = (settings.imageWidth + 10) + 'px';				
			}
		}

		if (settings.icon) {
			var $icon = document.createElement("i");
				$icon.setAttribute("class", PLUGIN_NAME + '-icon ' + settings.icon);
			
			if (settings.iconText){
				$icon.appendChild(document.createTextNode(settings.iconText));
			}

			if(settings.rtl){
				$toastBody.style.paddingRight = '33px';
			} else {
				$toastBody.style.paddingLeft = '33px';				
			}
			
			if (settings.iconColor){
				$icon.style.color = settings.iconColor;
			}
			$toastBody.appendChild($icon);
		}

		var $strong = document.createElement("strong");
		if (settings.titleColor.length > 0) {
			$strong.style.color = settings.titleColor;
		}
		$strong.appendChild(createFragElem(settings.title));

		var $p = document.createElement("p");
		if (settings.messageColor.length > 0) {
			$p.style.color = settings.messageColor;
		}
		$p.appendChild(createFragElem(settings.message));

		if(settings.layout > 1){
			$toast.classList.add(PLUGIN_NAME+"-layout"+settings.layout);
		}

		if(settings.balloon){
			$toast.classList.add(PLUGIN_NAME+"-balloon");
		}

		$toastBody.appendChild($strong);
		$toastBody.appendChild($p);

		var $buttons;
		if (settings.buttons.length > 0) {

			$buttons = document.createElement("div");
			$buttons.classList.add(PLUGIN_NAME + '-buttons');

			$p.style.marginRight = '15px';

			var i = 0;
			forEach(settings.buttons, function (value, index) {
				$buttons.appendChild(createFragElem(value[0]));

				var $btns = $buttons.childNodes;

				$btns[i].addEventListener('click', function (e) {
					e.preventDefault();
					var ts = value[1];
					return new ts(that, $toast); 
				});

				i++;
			});
			$toastBody.appendChild($buttons);
		}

		$toast.appendChild($toastBody);
		$toastCapsule.style.visibility = 'hidden';
		$toastCapsule.appendChild($toast);

		setTimeout(function() {
			var H = $toast.offsetHeight;
			var style = $toast.currentStyle || window.getComputedStyle($toast);
			var marginTop = style.marginTop;
				marginTop = marginTop.split("px");
				marginTop = parseInt(marginTop[0]);
			var marginBottom = style.marginBottom;
				marginBottom = marginBottom.split("px");
				marginBottom = parseInt(marginBottom[0]);

			$toastCapsule.style.visibility = '';
			$toastCapsule.style.height = (H+marginBottom+marginTop)+'px';
			setTimeout(function() {
				$toastCapsule.style.height = 'auto';
				if(settings.target){
					$toastCapsule.style.overflow = 'visible';
				}
			},1000);
		}, 100);

		var position = settings.position,
			$wrapper;

		if(settings.target){

			$wrapper = document.querySelector(settings.target);
			$wrapper.classList.add(PLUGIN_NAME + '-target');

			if (settings.targetFirst) {
				$wrapper.insertBefore($toastCapsule, $wrapper.firstChild);
			} else {
				$wrapper.appendChild($toastCapsule);
			}

		} else {

			if( POSITIONS.indexOf(settings.position) == -1 ){
				console.warn("["+PLUGIN_NAME+"] Incorrect position.\nIt can be › " + POSITIONS);
				return;
			}

			if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
				if(settings.position == "bottomLeft" || settings.position == "bottomRight" || settings.position == "bottomCenter"){
					position = PLUGIN_NAME+'-wrapper-bottomCenter';
				}
				else if(settings.position == "topLeft" || settings.position == "topRight" || settings.position == "topCenter"){
					position = PLUGIN_NAME+'-wrapper-topCenter';
				}
				else{
					position = PLUGIN_NAME+'-wrapper-center';
				}
			} else {
				position = PLUGIN_NAME+'-wrapper-'+position;
			}
			$wrapper = document.querySelector('.' + PLUGIN_NAME + '-wrapper.'+position);

			if (!$wrapper) {
				$wrapper = document.createElement("div");
				$wrapper.classList.add(PLUGIN_NAME + '-wrapper');
				$wrapper.classList.add(position);
				document.body.appendChild($wrapper);
			}
			if(settings.position == "topLeft" || settings.position == "topCenter" || settings.position == "topRight"){
				$wrapper.insertBefore($toastCapsule, $wrapper.firstChild);
			} else {
				$wrapper.appendChild($toastCapsule);
			}
		}

		if (!isNaN(settings.zindex)) {
			$wrapper.style.zIndex = settings.zindex;
		} else {
			console.warn("["+PLUGIN_NAME+"] Invalid zIndex.");
		}

		settings.onOpen.apply(null, [settings, $toast]);

		try {
			var event;
			if (window.CustomEvent) {
				event = new CustomEvent(PLUGIN_NAME+'-open', {detail: {class: settings.class}});
			} else {
				event = document.createEvent('CustomEvent');
				event.initCustomEvent(PLUGIN_NAME+'-open', true, true, {class: settings.class});
			}
			document.dispatchEvent(event);
		} catch(ex){
			console.warn(ex);
		}

		if(settings.animateInside){
			$toast.classList.add(PLUGIN_NAME+'-animateInside');
		
			var timeAnimation1 = 200;
			var timeAnimation2 = 100;
			var timeAnimation3 = 300;
			if(settings.transitionIn == "bounceInLeft"){
				timeAnimation1 = 400;
				timeAnimation2 = 200;
				timeAnimation3 = 400;
			}

			window.setTimeout(function(){
				$strong.classList.add('slideIn');
			},timeAnimation1);

			window.setTimeout(function(){
				$p.classList.add('slideIn');
			},timeAnimation2);

			if (settings.icon) {
				window.setTimeout(function(){
					$icon.classList.add('revealIn');
				},timeAnimation3);
			}

			if (settings.buttons.length > 0 && $buttons) {
				var counter = 150;
				forEach($buttons.childNodes, function(element, index) {

					window.setTimeout(function(){
						element.classList.add('revealIn');
					},counter);
					counter = counter + counter;
				});
			}
		}
		
		if($buttonClose){
			$buttonClose.addEventListener('click', function (e) {
				var button = e.target;
				that.hide(settings, $toast, 'button');
			});
		}

		if(settings.pauseOnHover){
			
			$toast.addEventListener('mouseenter', function (e) {
				this.classList.add(PLUGIN_NAME+'-paused');
			});
			$toast.addEventListener('mouseleave', function (e) {
				this.classList.remove(PLUGIN_NAME+'-paused');
			});
		}

		if(settings.resetOnHover){

			$toast.addEventListener('mouseenter', function (e) {
				this.classList.add(PLUGIN_NAME+'-reseted');
			});
			$toast.addEventListener('mouseleave', function (e) {
				this.classList.remove(PLUGIN_NAME+'-reseted');
			});
		}

		if(settings.drag){

			if (ACCEPTSTOUCH) {

			    $toast.addEventListener('touchstart', function(e) {
			        drag.startMoving(this, that, settings, e);
			    }, false);

			    $toast.addEventListener('touchend', function(e) {
			        drag.stopMoving(this, e);
			    }, false);
			} else {

			    $toast.addEventListener('mousedown', function(e) {
			    	e.preventDefault();
			        drag.startMoving(this, that, settings, e);
			    }, false);

			    $toast.addEventListener('mouseup', function(e) {
			    	e.preventDefault();
			        drag.stopMoving(this, e);
			    }, false);
			}
		}


	};

	return $iziToast;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Math */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Vec3; });
/* unused harmony export Quat */
/* unused harmony export Mat33 */
/* unused harmony export Shape */
/* unused harmony export Box */
/* unused harmony export Sphere */
/* unused harmony export Cylinder */
/* unused harmony export Plane */
/* unused harmony export Particle */
/* unused harmony export ShapeConfig */
/* unused harmony export LimitMotor */
/* unused harmony export HingeJoint */
/* unused harmony export BallAndSocketJoint */
/* unused harmony export DistanceJoint */
/* unused harmony export PrismaticJoint */
/* unused harmony export SliderJoint */
/* unused harmony export WheelJoint */
/* unused harmony export JointConfig */
/* unused harmony export RigidBody */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return World; });
/* unused harmony export REVISION */
/* unused harmony export BR_NULL */
/* unused harmony export BR_BRUTE_FORCE */
/* unused harmony export BR_SWEEP_AND_PRUNE */
/* unused harmony export BR_BOUNDING_VOLUME_TREE */
/* unused harmony export BODY_NULL */
/* unused harmony export BODY_DYNAMIC */
/* unused harmony export BODY_STATIC */
/* unused harmony export BODY_KINEMATIC */
/* unused harmony export BODY_GHOST */
/* unused harmony export SHAPE_NULL */
/* unused harmony export SHAPE_SPHERE */
/* unused harmony export SHAPE_BOX */
/* unused harmony export SHAPE_CYLINDER */
/* unused harmony export SHAPE_PLANE */
/* unused harmony export SHAPE_PARTICLE */
/* unused harmony export SHAPE_TETRA */
/* unused harmony export JOINT_NULL */
/* unused harmony export JOINT_DISTANCE */
/* unused harmony export JOINT_BALL_AND_SOCKET */
/* unused harmony export JOINT_HINGE */
/* unused harmony export JOINT_WHEEL */
/* unused harmony export JOINT_SLIDER */
/* unused harmony export JOINT_PRISMATIC */
/* unused harmony export AABB_PROX */
/* unused harmony export printError */
/* unused harmony export InfoDisplay */
// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	( function () {

		Object.assign = function ( target ) {

			'use strict';

			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			var output = Object( target );

			for ( var index = 1; index < arguments.length; index ++ ) {

				var source = arguments[ index ];

				if ( source !== undefined && source !== null ) {

					for ( var nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	} )();

}

/*
 * A list of constants built-in for
 * the physics engine.
 */

var REVISION = '1.0.9';

// BroadPhase
var BR_NULL = 0;
var BR_BRUTE_FORCE = 1;
var BR_SWEEP_AND_PRUNE = 2;
var BR_BOUNDING_VOLUME_TREE = 3;

// Body type
var BODY_NULL = 0;
var BODY_DYNAMIC = 1;
var BODY_STATIC = 2;
var BODY_KINEMATIC = 3;
var BODY_GHOST = 4;

// Shape type
var SHAPE_NULL = 0;
var SHAPE_SPHERE = 1;
var SHAPE_BOX = 2;
var SHAPE_CYLINDER = 3;
var SHAPE_PLANE = 4;
var SHAPE_PARTICLE = 5;
var SHAPE_TETRA = 6;

// Joint type
var JOINT_NULL = 0;
var JOINT_DISTANCE = 1;
var JOINT_BALL_AND_SOCKET = 2;
var JOINT_HINGE = 3;
var JOINT_WHEEL = 4;
var JOINT_SLIDER = 5;
var JOINT_PRISMATIC = 6;

// AABB aproximation
var AABB_PROX = 0.005;

var _Math = {

    sqrt   : Math.sqrt,
    abs    : Math.abs,
    floor  : Math.floor,
    cos    : Math.cos,
    sin    : Math.sin,
    acos   : Math.acos,
    asin   : Math.asin,
    atan2  : Math.atan2,
    round  : Math.round,
    pow    : Math.pow,
    max    : Math.max,
    min    : Math.min,
    random : Math.random,

    degtorad : 0.0174532925199432957,
    radtodeg : 57.295779513082320876,
    PI       : 3.141592653589793,
    TwoPI    : 6.283185307179586,
    PI90     : 1.570796326794896,
    PI270    : 4.712388980384689,

    INF      : Infinity,
    EPZ      : 0.00001,
    EPZ2      : 0.000001,

    lerp: function ( x, y, t ) { 

        return ( 1 - t ) * x + t * y; 

    },

    randInt: function ( low, high ) { 

        return low + _Math.floor( _Math.random() * ( high - low + 1 ) ); 

    },

    rand: function ( low, high ) { 

        return low + _Math.random() * ( high - low ); 

    },
    
    generateUUID: function () {

        // http://www.broofa.com/Tools/Math.uuid.htm

        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
        var uuid = new Array( 36 );
        var rnd = 0, r;

        return function generateUUID() {

            for ( var i = 0; i < 36; i ++ ) {

                if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

                    uuid[ i ] = '-';

                } else if ( i === 14 ) {

                    uuid[ i ] = '4';

                } else {

                    if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

                }

            }

            return uuid.join( '' );

        };

    }(),

    int: function( x ) { 

        return _Math.floor(x); 

    },

    fix: function( x, n ) { 

        return x.toFixed(n || 3, 10); 

    },

    clamp: function ( value, min, max ) { 

        return _Math.max( min, _Math.min( max, value ) ); 

    },
    
    //clamp: function ( x, a, b ) { return ( x < a ) ? a : ( ( x > b ) ? b : x ); },

    

    distance: function( p1, p2 ){

        var xd = p2[0]-p1[0];
        var yd = p2[1]-p1[1];
        var zd = p2[2]-p1[2];
        return _Math.sqrt(xd*xd + yd*yd + zd*zd);

    },

    /*unwrapDegrees: function ( r ) {

        r = r % 360;
        if (r > 180) r -= 360;
        if (r < -180) r += 360;
        return r;

    },

    unwrapRadian: function( r ){

        r = r % _Math.TwoPI;
        if (r > _Math.PI) r -= _Math.TwoPI;
        if (r < -_Math.PI) r += _Math.TwoPI;
        return r;

    },*/

    acosClamp: function ( cos ) {

        if(cos>1)return 0;
        else if(cos<-1)return _Math.PI;
        else return _Math.acos(cos);

    },

    distanceVector: function( v1, v2 ){

        var xd = v1.x - v2.x;
        var yd = v1.y - v2.y;
        var zd = v1.z - v2.z;
        return xd * xd + yd * yd + zd * zd;

    },

    dotVectors: function ( a, b ) {

        return a.x * b.x + a.y * b.y + a.z * b.z;

    },

};

function printError( clazz, msg ){
    console.error("[OIMO] " + clazz + ": " + msg);
}

// A performance evaluator

function InfoDisplay(world){

    this.parent = world;

    this.infos = new Float32Array( 13 );
    this.f = [0,0,0];

    this.times = [0,0,0,0];

    this.broadPhase = this.parent.broadPhaseType;

    this.version = REVISION;

    this.fps = 0;

    this.tt = 0;

    this.broadPhaseTime = 0;
    this.narrowPhaseTime = 0;
    this.solvingTime = 0;
    this.totalTime = 0;
    this.updateTime = 0;

    this.MaxBroadPhaseTime = 0;
    this.MaxNarrowPhaseTime = 0;
    this.MaxSolvingTime = 0;
    this.MaxTotalTime = 0;
    this.MaxUpdateTime = 0;
}

Object.assign( InfoDisplay.prototype, {

    setTime: function(n){
        this.times[ n || 0 ] = performance.now();
    },

    resetMax: function(){

        this.MaxBroadPhaseTime = 0;
        this.MaxNarrowPhaseTime = 0;
        this.MaxSolvingTime = 0;
        this.MaxTotalTime = 0;
        this.MaxUpdateTime = 0;

    },

    calcBroadPhase: function () {

        this.setTime( 2 );
        this.broadPhaseTime = this.times[ 2 ] - this.times[ 1 ];

    },

    calcNarrowPhase: function () {

        this.setTime( 3 );
        this.narrowPhaseTime = this.times[ 3 ] - this.times[ 2 ];

    },

    calcEnd: function () {

        this.setTime( 2 );
        this.solvingTime = this.times[ 2 ] - this.times[ 1 ];
        this.totalTime = this.times[ 2 ] - this.times[ 0 ];
        this.updateTime = this.totalTime - ( this.broadPhaseTime + this.narrowPhaseTime + this.solvingTime );

        if( this.tt === 100 ) this.resetMax();

        if( this.tt > 100 ){
            if( this.broadPhaseTime > this.MaxBroadPhaseTime ) this.MaxBroadPhaseTime = this.broadPhaseTime;
            if( this.narrowPhaseTime > this.MaxNarrowPhaseTime ) this.MaxNarrowPhaseTime = this.narrowPhaseTime;
            if( this.solvingTime > this.MaxSolvingTime ) this.MaxSolvingTime = this.solvingTime;
            if( this.totalTime > this.MaxTotalTime ) this.MaxTotalTime = this.totalTime;
            if( this.updateTime > this.MaxUpdateTime ) this.MaxUpdateTime = this.updateTime;
        }


        this.upfps();

        this.tt ++;
        if(this.tt > 500) this.tt = 0;

    },


    upfps : function(){
        this.f[1] = Date.now();
        if (this.f[1]-1000>this.f[0]){ this.f[0] = this.f[1]; this.fps = this.f[2]; this.f[2] = 0; } this.f[2]++;
    },

    show: function(){
        var info =[
            "Oimo.js "+this.version+"<br>",
            this.broadPhase + "<br><br>",
            "FPS: " + this.fps +" fps<br><br>",
            "rigidbody "+this.parent.numRigidBodies+"<br>",
            "contact &nbsp;&nbsp;"+this.parent.numContacts+"<br>",
            "ct-point &nbsp;"+this.parent.numContactPoints+"<br>",
            "paircheck "+this.parent.broadPhase.numPairChecks+"<br>",
            "island &nbsp;&nbsp;&nbsp;"+this.parent.numIslands +"<br><br>",
            "Time in milliseconds<br><br>",
            "broadphase &nbsp;"+ _Math.fix(this.broadPhaseTime) + " | " + _Math.fix(this.MaxBroadPhaseTime) +"<br>",
            "narrowphase "+ _Math.fix(this.narrowPhaseTime)  + " | " + _Math.fix(this.MaxNarrowPhaseTime) + "<br>",
            "solving &nbsp;&nbsp;&nbsp;&nbsp;"+ _Math.fix(this.solvingTime)+ " | " + _Math.fix(this.MaxSolvingTime) + "<br>",
            "total &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"+ _Math.fix(this.totalTime) + " | " + _Math.fix(this.MaxTotalTime) + "<br>",
            "updating &nbsp;&nbsp;&nbsp;"+ _Math.fix(this.updateTime) + " | " + _Math.fix(this.MaxUpdateTime) + "<br>"
        ].join("\n");
        return info;
    },

    toArray: function(){
        this.infos[0] = this.parent.broadPhase.types;
        this.infos[1] = this.parent.numRigidBodies;
        this.infos[2] = this.parent.numContacts;
        this.infos[3] = this.parent.broadPhase.numPairChecks;
        this.infos[4] = this.parent.numContactPoints;
        this.infos[5] = this.parent.numIslands;
        this.infos[6] = this.broadPhaseTime;
        this.infos[7] = this.narrowPhaseTime;
        this.infos[8] = this.solvingTime;
        this.infos[9] = this.updateTime;
        this.infos[10] = this.totalTime;
        this.infos[11] = this.fps;
        return this.infos;
    }
    
});

function Vec3 ( x, y, z ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    
}

Object.assign( Vec3.prototype, {

    Vec3: true,

    set: function( x, y, z ){

        this.x = x;
        this.y = y;
        this.z = z;
        return this;

    },

    add: function ( a, b ) {

        if ( b !== undefined ) return this.addVectors( a, b );

        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this;

    },

    addVectors: function ( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;

    },

    addEqual: function ( v ) {

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;

    },

    sub: function ( a, b ) {

        if ( b !== undefined ) return this.subVectors( a, b );

        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this;

    },

    subVectors: function ( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;

    },

    subEqual: function ( v ) {

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;

    },

    scale: function ( v, s ) {

        this.x = v.x * s;
        this.y = v.y * s;
        this.z = v.z * s;
        return this;

    },

    scaleEqual: function( s ){

        this.x *= s;
        this.y *= s;
        this.z *= s;
        return this;

    },

    multiply: function( v ){

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;

    },

    multiplyScalar: function( s ){

        this.x *= s;
        this.y *= s;
        this.z *= s;
        return this;

    },

    /*scaleV: function( v ){

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;

    },

    scaleVectorEqual: function( v ){

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;

    },*/

    addScaledVector: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;

        return this;

    },

    subScaledVector: function ( v, s ) {

        this.x -= v.x * s;
        this.y -= v.y * s;
        this.z -= v.z * s;

        return this;

    },

    /*addTime: function ( v, t ) {

        this.x += v.x * t;
        this.y += v.y * t;
        this.z += v.z * t;
        return this;

    },
    
    addScale: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;

    },

    subScale: function ( v, s ) {

        this.x -= v.x * s;
        this.y -= v.y * s;
        this.z -= v.z * s;
        return this;

    },*/
   
    cross: function( a, b ) {

        if ( b !== undefined ) return this.crossVectors( a, b );

        var x = this.x, y = this.y, z = this.z;

        this.x = y * a.z - z * a.y;
        this.y = z * a.x - x * a.z;
        this.z = x * a.y - y * a.x;

        return this;

    },

    crossVectors: function ( a, b ) {

        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;

    },

    tangent: function ( a ) {

        var ax = a.x, ay = a.y, az = a.z;

        this.x = ay * ax - az * az;
        this.y = - az * ay - ax * ax;
        this.z = ax * az + ay * ay;

        return this;

    },

    

    

    invert: function ( v ) {

        this.x=-v.x;
        this.y=-v.y;
        this.z=-v.z;
        return this;

    },

    negate: function () {

        this.x = - this.x;
        this.y = - this.y;
        this.z = - this.z;

        return this;

    },

    dot: function ( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z;

    },

    addition: function () {

        return this.x + this.y + this.z;

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y + this.z * this.z;

    },

    length: function () {

        return _Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    },

    copy: function( v ){

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;

    },

    /*mul: function( b, a, m ){

        return this.mulMat( m, a ).add( b );

    },

    mulMat: function( m, a ){

        var e = m.elements;
        var x = a.x, y = a.y, z = a.z;

        this.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;
        this.y = e[ 3 ] * x + e[ 4 ] * y + e[ 5 ] * z;
        this.z = e[ 6 ] * x + e[ 7 ] * y + e[ 8 ] * z;
        return this;

    },*/

    applyMatrix3: function ( m, transpose ) {

        //if( transpose ) m = m.clone().transpose();
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;

        if( transpose ){
            
            this.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;
            this.y = e[ 3 ] * x + e[ 4 ] * y + e[ 5 ] * z;
            this.z = e[ 6 ] * x + e[ 7 ] * y + e[ 8 ] * z;

        } else {
      
            this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
            this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
            this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
        }

        return this;

    },

    applyQuaternion: function ( q ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vector

        var ix =  qw * x + qy * z - qz * y;
        var iy =  qw * y + qz * x - qx * z;
        var iz =  qw * z + qx * y - qy * x;
        var iw = - qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
        this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
        this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

        return this;

    },

    testZero: function () {

        if(this.x!==0 || this.y!==0 || this.z!==0) return true;
        else return false;

    },

    testDiff: function( v ){

        return this.equals( v ) ? false : true;

    },

    equals: function ( v ) {

        return v.x === this.x && v.y === this.y && v.z === this.z;

    },

    clone: function () {

        return new this.constructor( this.x, this.y, this.z );

    },

    toString: function(){

        return"Vec3["+this.x.toFixed(4)+", "+this.y.toFixed(4)+", "+this.z.toFixed(4)+"]";
        
    },

    multiplyScalar: function ( scalar ) {

        if ( isFinite( scalar ) ) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }

        return this;

    },

    divideScalar: function ( scalar ) {

        return this.multiplyScalar( 1 / scalar );

    },

    normalize: function () {

        return this.divideScalar( this.length() );

    },

    toArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

    },

    fromArray: function( array, offset ){

        if ( offset === undefined ) offset = 0;
        
        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];
        return this;

    },


} );

function Quat ( x, y, z, w ){

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quat.prototype, {

    Quat: true,

    set: function ( x, y, z, w ) {

        
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;

    },

    addTime: function( v, t ){

        var ax = v.x, ay = v.y, az = v.z;
        var qw = this.w, qx = this.x, qy = this.y, qz = this.z;
        t *= 0.5;    
        this.x += t * (  ax*qw + ay*qz - az*qy );
        this.y += t * (  ay*qw + az*qx - ax*qz );
        this.z += t * (  az*qw + ax*qy - ay*qx );
        this.w += t * ( -ax*qx - ay*qy - az*qz );
        this.normalize();
        return this;

    },

    /*mul: function( q1, q2 ){

        var ax = q1.x, ay = q1.y, az = q1.z, as = q1.w,
        bx = q2.x, by = q2.y, bz = q2.z, bs = q2.w;
        this.x = ax * bs + as * bx + ay * bz - az * by;
        this.y = ay * bs + as * by + az * bx - ax * bz;
        this.z = az * bs + as * bz + ax * by - ay * bx;
        this.w = as * bs - ax * bx - ay * by - az * bz;
        return this;

    },*/

    multiply: function ( q, p ) {

        if ( p !== undefined ) return this.multiplyQuaternions( q, p );
        return this.multiplyQuaternions( this, q );

    },

    multiplyQuaternions: function ( a, b ) {

        var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
        var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        return this;

    },

    setFromUnitVectors: function( v1, v2 ) {

        var vx = new Vec3();
        var r = v1.dot( v2 ) + 1;

        if ( r < _Math.EPS2 ) {

            r = 0;
            if ( _Math.abs( v1.x ) > _Math.abs( v1.z ) ) vx.set( - v1.y, v1.x, 0 );
            else vx.set( 0, - v1.z, v1.y );

        } else {

            vx.crossVectors( v1, v2 );

        }

        this._x = vx.x;
        this._y = vx.y;
        this._z = vx.z;
        this._w = r;

        return this.normalize();

    },

    arc: function( v1, v2 ){

        var x1 = v1.x;
        var y1 = v1.y;
        var z1 = v1.z;
        var x2 = v2.x;
        var y2 = v2.y;
        var z2 = v2.z;
        var d = x1*x2 + y1*y2 + z1*z2;
        if( d==-1 ){
            x2 = y1*x1 - z1*z1;
            y2 = -z1*y1 - x1*x1;
            z2 = x1*z1 + y1*y1;
            d = 1 / _Math.sqrt( x2*x2 + y2*y2 + z2*z2 );
            this.w = 0;
            this.x = x2*d;
            this.y = y2*d;
            this.z = z2*d;
            return this;
        }
        var cx = y1*z2 - z1*y2;
        var cy = z1*x2 - x1*z2;
        var cz = x1*y2 - y1*x2;
        this.w = _Math.sqrt( ( 1 + d) * 0.5 );
        d = 0.5 / this.w;
        this.x = cx * d;
        this.y = cy * d;
        this.z = cz * d;
        return this;

    },

    normalize: function(){

        var l = this.length();
        if ( l === 0 ) {
            this.set( 0, 0, 0, 1 );
        } else {
            l = 1 / l;
            this.x = this.x * l;
            this.y = this.y * l;
            this.z = this.z * l;
            this.w = this.w * l;
        }
        return this;

    },

    inverse: function () {

        return this.conjugate().normalize();

    },

    invert: function ( q ) {

        this.x = q.x;
        this.y = q.y;
        this.z = q.z;
        this.w = q.w;
        this.conjugate().normalize();
        return this;

    },

    conjugate: function () {

        this.x *= - 1;
        this.y *= - 1;
        this.z *= - 1;
        return this;

    },

    length: function(){

        return _Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w  );

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    },
    
    copy: function( q ){
        
        this.x = q.x;
        this.y = q.y;
        this.z = q.z;
        this.w = q.w;
        return this;

    },

    clone: function( q ){

        return new Quat( this.x, this.y, this.z, this.w );

    },

    testDiff: function ( q ) {

        return this.equals( q ) ? false : true;

    },

    equals: function ( q ) {

        return this.x === q.x && this.y === q.y && this.z === q.z && this.w === q.w;

    },

    toString: function(){

        return"Quat["+this.x.toFixed(4)+", ("+this.y.toFixed(4)+", "+this.z.toFixed(4)+", "+this.w.toFixed(4)+")]";
        
    },

    setFromEuler: function ( x, y, z ){

        var c1 = Math.cos( x * 0.5 );
        var c2 = Math.cos( y * 0.5 );
        var c3 = Math.cos( z * 0.5 );
        var s1 = Math.sin( x * 0.5 );
        var s2 = Math.sin( y * 0.5 );
        var s3 = Math.sin( z * 0.5 );

        // XYZ
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

        return this;

    },
    
    setFromAxis: function ( axis, rad ) {

        axis.normalize();
        rad = rad * 0.5;
        var s = _Math.sin( rad );
        this.x = s * axis.x;
        this.y = s * axis.y;
        this.z = s * axis.z;
        this.w = _Math.cos( rad );
        return this;

    },

    setFromMat33: function ( m ) {

        var trace = m[0] + m[4] + m[8];
        var s;

        if ( trace > 0 ) {

            s = _Math.sqrt( trace + 1.0 );
            this.w = 0.5 / s;
            s = 0.5 / s;
            this.x = ( m[5] - m[7] ) * s;
            this.y = ( m[6] - m[2] ) * s;
            this.z = ( m[1] - m[3] ) * s;

        } else {

            var out = [];
            var i = 0;
            if ( m[4] > m[0] ) i = 1;
            if ( m[8] > m[i*3+i] ) i = 2;

            var j = (i+1)%3;
            var k = (i+2)%3;
            
            s = _Math.sqrt( m[i*3+i] - m[j*3+j] - m[k*3+k] + 1.0 );
            out[i] = 0.5 * fRoot;
            s = 0.5 / fRoot;
            this.w = ( m[j*3+k] - m[k*3+j] ) * s;
            out[j] = ( m[j*3+i] + m[i*3+j] ) * s;
            out[k] = ( m[k*3+i] + m[i*3+k] ) * s;

            this.x = out[1];
            this.y = out[2];
            this.z = out[3];

        }

        return this;

    },

    toArray: function ( array, offset ) {

        offset = offset || 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;
        array[ offset + 3 ] = this.w;

    },

    fromArray: function( array, offset ){

        offset = offset || 0;
        this.set( array[ offset ], array[ offset + 1 ], array[ offset + 2 ], array[ offset + 3 ] );
        return this;

    }

});

function Mat33 ( e00, e01, e02, e10, e11, e12, e20, e21, e22 ){

    this.elements = [
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
    ];

    if ( arguments.length > 0 ) {

        console.error( 'OIMO.Mat33: the constructor no longer reads arguments. use .set() instead.' );

    }

}

Object.assign( Mat33.prototype, {

    Mat33: true,

    set: function ( e00, e01, e02, e10, e11, e12, e20, e21, e22 ){

        var te = this.elements;
        te[0] = e00; te[1] = e01; te[2] = e02;
        te[3] = e10; te[4] = e11; te[5] = e12;
        te[6] = e20; te[7] = e21; te[8] = e22;
        return this;

    },
    
    add: function ( a, b ) {

        if( b !== undefined ) return this.addMatrixs( a, b );

        var e = this.elements, te = a.elements;
        e[0] += te[0]; e[1] += te[1]; e[2] += te[2];
        e[3] += te[3]; e[4] += te[4]; e[5] += te[5];
        e[6] += te[6]; e[7] += te[7]; e[8] += te[8];
        return this;

    },

    addMatrixs: function ( a, b ) {

        var te = this.elements, tem1 = a.elements, tem2 = b.elements;
        te[0] = tem1[0] + tem2[0]; te[1] = tem1[1] + tem2[1]; te[2] = tem1[2] + tem2[2];
        te[3] = tem1[3] + tem2[3]; te[4] = tem1[4] + tem2[4]; te[5] = tem1[5] + tem2[5];
        te[6] = tem1[6] + tem2[6]; te[7] = tem1[7] + tem2[7]; te[8] = tem1[8] + tem2[8];
        return this;

    },

    addEqual: function( m ){

        var te = this.elements, tem = m.elements;
        te[0] += tem[0]; te[1] += tem[1]; te[2] += tem[2];
        te[3] += tem[3]; te[4] += tem[4]; te[5] += tem[5];
        te[6] += tem[6]; te[7] += tem[7]; te[8] += tem[8];
        return this;

    },

    sub: function ( a, b ) {

        if( b !== undefined ) return this.subMatrixs( a, b );

        var e = this.elements, te = a.elements;
        e[0] -= te[0]; e[1] -= te[1]; e[2] -= te[2];
        e[3] -= te[3]; e[4] -= te[4]; e[5] -= te[5];
        e[6] -= te[6]; e[7] -= te[7]; e[8] -= te[8];
        return this;

    },

    subMatrixs: function ( a, b ) {

        var te = this.elements, tem1 = a.elements, tem2 = b.elements;
        te[0] = tem1[0] - tem2[0]; te[1] = tem1[1] - tem2[1]; te[2] = tem1[2] - tem2[2];
        te[3] = tem1[3] - tem2[3]; te[4] = tem1[4] - tem2[4]; te[5] = tem1[5] - tem2[5];
        te[6] = tem1[6] - tem2[6]; te[7] = tem1[7] - tem2[7]; te[8] = tem1[8] - tem2[8];
        return this;

    },

    subEqual: function ( m ) {

        var te = this.elements, tem = m.elements;
        te[0] -= tem[0]; te[1] -= tem[1]; te[2] -= tem[2];
        te[3] -= tem[3]; te[4] -= tem[4]; te[5] -= tem[5];
        te[6] -= tem[6]; te[7] -= tem[7]; te[8] -= tem[8];
        return this;

    },

    scale: function ( m, s ) {

        var te = this.elements, tm = m.elements;
        te[0] = tm[0] * s; te[1] = tm[1] * s; te[2] = tm[2] * s;
        te[3] = tm[3] * s; te[4] = tm[4] * s; te[5] = tm[5] * s;
        te[6] = tm[6] * s; te[7] = tm[7] * s; te[8] = tm[8] * s;
        return this;

    },

    scaleEqual: function ( s ){// multiplyScalar

        var te = this.elements;
        te[0] *= s; te[1] *= s; te[2] *= s;
        te[3] *= s; te[4] *= s; te[5] *= s;
        te[6] *= s; te[7] *= s; te[8] *= s;
        return this;

    },

    multiplyMatrices: function ( m1, m2, transpose ) {

        if( transpose ) m2 = m2.clone().transpose();

        var te = this.elements;
        var tm1 = m1.elements;
        var tm2 = m2.elements;

        var a0 = tm1[0], a3 = tm1[3], a6 = tm1[6];
        var a1 = tm1[1], a4 = tm1[4], a7 = tm1[7];
        var a2 = tm1[2], a5 = tm1[5], a8 = tm1[8];

        var b0 = tm2[0], b3 = tm2[3], b6 = tm2[6];
        var b1 = tm2[1], b4 = tm2[4], b7 = tm2[7];
        var b2 = tm2[2], b5 = tm2[5], b8 = tm2[8];

        te[0] = a0*b0 + a1*b3 + a2*b6;
        te[1] = a0*b1 + a1*b4 + a2*b7;
        te[2] = a0*b2 + a1*b5 + a2*b8;
        te[3] = a3*b0 + a4*b3 + a5*b6;
        te[4] = a3*b1 + a4*b4 + a5*b7;
        te[5] = a3*b2 + a4*b5 + a5*b8;
        te[6] = a6*b0 + a7*b3 + a8*b6;
        te[7] = a6*b1 + a7*b4 + a8*b7;
        te[8] = a6*b2 + a7*b5 + a8*b8;

        return this;

    },

    /*mul: function ( m1, m2, transpose ) {

        if( transpose ) m2 = m2.clone().transpose();

        var te = this.elements;
        var tm1 = m1.elements;
        var tm2 = m2.elements;
        //var tmp;

        var a0 = tm1[0], a3 = tm1[3], a6 = tm1[6];
        var a1 = tm1[1], a4 = tm1[4], a7 = tm1[7];
        var a2 = tm1[2], a5 = tm1[5], a8 = tm1[8];

        var b0 = tm2[0], b3 = tm2[3], b6 = tm2[6];
        var b1 = tm2[1], b4 = tm2[4], b7 = tm2[7];
        var b2 = tm2[2], b5 = tm2[5], b8 = tm2[8];

        /*if( transpose ){

            tmp = b1; b1 = b3; b3 = tmp;
            tmp = b2; b2 = b6; b6 = tmp;
            tmp = b5; b5 = b7; b7 = tmp;

        }

        te[0] = a0*b0 + a1*b3 + a2*b6;
        te[1] = a0*b1 + a1*b4 + a2*b7;
        te[2] = a0*b2 + a1*b5 + a2*b8;
        te[3] = a3*b0 + a4*b3 + a5*b6;
        te[4] = a3*b1 + a4*b4 + a5*b7;
        te[5] = a3*b2 + a4*b5 + a5*b8;
        te[6] = a6*b0 + a7*b3 + a8*b6;
        te[7] = a6*b1 + a7*b4 + a8*b7;
        te[8] = a6*b2 + a7*b5 + a8*b8;

        return this;

    },*/

    transpose: function ( m ) {
        
        if( m !== undefined ){
            var a = m.elements;
            this.set( a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8] );
            return this;
        }

        var te = this.elements;
        var a01 = te[1], a02 = te[2], a12 = te[5];
        te[1] = te[3];
        te[2] = te[6];
        te[3] = a01;
        te[5] = te[7];
        te[6] = a02;
        te[7] = a12;
        return this;

    },



    /*mulScale: function ( m, sx, sy, sz, Prepend ) {

        var prepend = Prepend || false;
        var te = this.elements, tm = m.elements;
        if(prepend){
            te[0] = sx*tm[0]; te[1] = sx*tm[1]; te[2] = sx*tm[2];
            te[3] = sy*tm[3]; te[4] = sy*tm[4]; te[5] = sy*tm[5];
            te[6] = sz*tm[6]; te[7] = sz*tm[7]; te[8] = sz*tm[8];
        }else{
            te[0] = tm[0]*sx; te[1] = tm[1]*sy; te[2] = tm[2]*sz;
            te[3] = tm[3]*sx; te[4] = tm[4]*sy; te[5] = tm[5]*sz;
            te[6] = tm[6]*sx; te[7] = tm[7]*sy; te[8] = tm[8]*sz;
        }
        return this;

    },

    transpose: function ( m ) {

        var te = this.elements, tm = m.elements;
        te[0] = tm[0]; te[1] = tm[3]; te[2] = tm[6];
        te[3] = tm[1]; te[4] = tm[4]; te[5] = tm[7];
        te[6] = tm[2]; te[7] = tm[5]; te[8] = tm[8];
        return this;

    },*/

    setQuat: function ( q ) {

        var te = this.elements;
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x,  y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;
        
        te[0] = 1 - ( yy + zz );
        te[1] = xy - wz;
        te[2] = xz + wy;

        te[3] = xy + wz;
        te[4] = 1 - ( xx + zz );
        te[5] = yz - wx;

        te[6] = xz - wy;
        te[7] = yz + wx;
        te[8] = 1 - ( xx + yy );

        return this;

    },

    invert: function( m ) {

        var te = this.elements, tm = m.elements,
        a00 = tm[0], a10 = tm[3], a20 = tm[6],
        a01 = tm[1], a11 = tm[4], a21 = tm[7],
        a02 = tm[2], a12 = tm[5], a22 = tm[8],
        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,
        det = a00 * b01 + a01 * b11 + a02 * b21;

        if ( det === 0 ) {
            console.log( "can't invert matrix, determinant is 0");
            return this.identity();
        }

        det = 1.0 / det;
        te[0] = b01 * det;
        te[1] = (-a22 * a01 + a02 * a21) * det;
        te[2] = (a12 * a01 - a02 * a11) * det;
        te[3] = b11 * det;
        te[4] = (a22 * a00 - a02 * a20) * det;
        te[5] = (-a12 * a00 + a02 * a10) * det;
        te[6] = b21 * det;
        te[7] = (-a21 * a00 + a01 * a20) * det;
        te[8] = (a11 * a00 - a01 * a10) * det;
        return this;

    },

    addOffset: function ( m, v ) {

        var relX = v.x;
        var relY = v.y;
        var relZ = v.z;

        var te = this.elements;
        te[0] += m * ( relY * relY + relZ * relZ );
        te[4] += m * ( relX * relX + relZ * relZ );
        te[8] += m * ( relX * relX + relY * relY );
        var xy = m * relX * relY;
        var yz = m * relY * relZ;
        var zx = m * relZ * relX;
        te[1] -= xy;
        te[3] -= xy;
        te[2] -= yz;
        te[6] -= yz;
        te[5] -= zx;
        te[7] -= zx;
        return this;

    },

    subOffset: function ( m, v ) {

        var relX = v.x;
        var relY = v.y;
        var relZ = v.z;

        var te = this.elements;
        te[0] -= m * ( relY * relY + relZ * relZ );
        te[4] -= m * ( relX * relX + relZ * relZ );
        te[8] -= m * ( relX * relX + relY * relY );
        var xy = m * relX * relY;
        var yz = m * relY * relZ;
        var zx = m * relZ * relX;
        te[1] += xy;
        te[3] += xy;
        te[2] += yz;
        te[6] += yz;
        te[5] += zx;
        te[7] += zx;
        return this;

    },

    // OK 

    multiplyScalar: function ( s ) {

        var te = this.elements;

        te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
        te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
        te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

        return this;

    },

    identity: function () {

        this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 );
        return this;

    },


    clone: function () {

        return new Mat33().fromArray( this.elements );

    },

    copy: function ( m ) {

        for ( var i = 0; i < 9; i ++ ) this.elements[ i ] = m.elements[ i ];
        return this;

    },

    determinant: function () {

        var te = this.elements;
        var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
            d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
            g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        for( var i = 0; i < 9; i ++ ) {

            this.elements[ i ] = array[ i + offset ];

        }

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ] = te[ 8 ];

        return array;

    }


} );

/**
 * An axis-aligned bounding box.
 *
 * @author saharan
 * @author lo-th
 */

function AABB( minX, maxX, minY, maxY, minZ, maxZ ){

    this.elements = new Float32Array( 6 );
    var te = this.elements;

    te[0] = minX || 0; te[1] = minY || 0; te[2] = minZ || 0;
    te[3] = maxX || 0; te[4] = maxY || 0; te[5] = maxZ || 0;

}

Object.assign( AABB.prototype, {

	AABB: true,

	set: function(minX, maxX, minY, maxY, minZ, maxZ){

		var te = this.elements;
		te[0] = minX;
		te[3] = maxX;
		te[1] = minY;
		te[4] = maxY;
		te[2] = minZ;
		te[5] = maxZ;
		return this;
	},

	intersectTest: function ( aabb ) {

		var te = this.elements;
		var ue = aabb.elements;
		return te[0] > ue[3] || te[1] > ue[4] || te[2] > ue[5] || te[3] < ue[0] || te[4] < ue[1] || te[5] < ue[2] ? true : false;

	},

	intersectTestTwo: function ( aabb ) {

		var te = this.elements;
		var ue = aabb.elements;
		return te[0] < ue[0] || te[1] < ue[1] || te[2] < ue[2] || te[3] > ue[3] || te[4] > ue[4] || te[5] > ue[5] ? true : false;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( aabb, margin ) {

		var m = margin || 0;
		var me = aabb.elements;
		this.set( me[ 0 ]-m, me[ 3 ]+m, me[ 1 ]-m, me[ 4 ]+m, me[ 2 ]-m, me[ 5 ]+m );
		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );
		return this;

	},

	// Set this AABB to the combined AABB of aabb1 and aabb2.

	combine: function( aabb1, aabb2 ) {

		var a = aabb1.elements;
		var b = aabb2.elements;
		var te = this.elements;

		te[0] = a[0] < b[0] ? a[0] : b[0];
		te[1] = a[1] < b[1] ? a[1] : b[1];
		te[2] = a[2] < b[2] ? a[2] : b[2];

		te[3] = a[3] > b[3] ? a[3] : b[3];
		te[4] = a[4] > b[4] ? a[4] : b[4];
		te[5] = a[5] > b[5] ? a[5] : b[5];

		return this;

	},


	// Get the surface area.

	surfaceArea: function () {

		var te = this.elements;
		var a = te[3] - te[0];
		var h = te[4] - te[1];
		var d = te[5] - te[2];
		return 2 * (a * (h + d) + h * d );

	},


	// Get whether the AABB intersects with the point or not.

	intersectsWithPoint:function(x,y,z){

		var te = this.elements;
		return x>=te[0] && x<=te[3] && y>=te[1] && y<=te[4] && z>=te[2] && z<=te[5];

	},

	/**
	 * Set the AABB from an array
	 * of vertices. From THREE.
	 * @author WestLangley
	 * @author xprogram
	 */

	setFromPoints: function(arr){
		this.makeEmpty();
		for(var i = 0; i < arr.length; i++){
			this.expandByPoint(arr[i]);
		}
	},

	makeEmpty: function(){
		this.set(-Infinity, -Infinity, -Infinity, Infinity, Infinity, Infinity);
	},

	expandByPoint: function(pt){
		var te = this.elements;
		this.set(
			_Math.min(te[ 0 ], pt.x), _Math.min(te[ 1 ], pt.y), _Math.min(te[ 2 ], pt.z),
			_Math.max(te[ 3 ], pt.x), _Math.max(te[ 4 ], pt.y), _Math.max(te[ 5 ], pt.z)
		);
	},

	expandByScalar: function(s){

		var te = this.elements;
		te[0] += -s;
		te[1] += -s;
		te[2] += -s;
		te[3] += s;
		te[4] += s;
		te[5] += s;
	}

});

var count = 0;
function ShapeIdCount() { return count++; }

/**
 * A shape is used to detect collisions of rigid bodies.
 *
 * @author saharan
 * @author lo-th
 */

function Shape ( config ) {

    this.type = SHAPE_NULL;

    // global identification of the shape should be unique to the shape.
    this.id = ShapeIdCount();

    // previous shape in parent rigid body. Used for fast interations.
    this.prev = null;

    // next shape in parent rigid body. Used for fast interations.
    this.next = null;

    // proxy of the shape used for broad-phase collision detection.
    this.proxy = null;

    // parent rigid body of the shape.
    this.parent = null;

    // linked list of the contacts with the shape.
    this.contactLink = null;

    // number of the contacts with the shape.
    this.numContacts = 0;

    // center of gravity of the shape in world coordinate system.
    this.position = new Vec3();

    // rotation matrix of the shape in world coordinate system.
    this.rotation = new Mat33();

    // position of the shape in parent's coordinate system.
    this.relativePosition = new Vec3().copy( config.relativePosition );

    // rotation matrix of the shape in parent's coordinate system.
    this.relativeRotation = new Mat33().copy( config.relativeRotation );

    // axis-aligned bounding box of the shape.
    this.aabb = new AABB();

    // density of the shape.
    this.density = config.density;

    // coefficient of friction of the shape.
    this.friction = config.friction;

    // coefficient of restitution of the shape.
    this.restitution = config.restitution;

    // bits of the collision groups to which the shape belongs.
    this.belongsTo = config.belongsTo;

    // bits of the collision groups with which the shape collides.
    this.collidesWith = config.collidesWith;

}

Object.assign( Shape.prototype, {

    Shape: true,

    // Calculate the mass information of the shape.

    calculateMassInfo: function( out ){

        printError("Shape", "Inheritance error.");

    },

    // Update the proxy of the shape.

    updateProxy: function(){

        printError("Shape", "Inheritance error.");

    }

});

/**
 * Box shape.
 * @author saharan
 * @author lo-th
 */
 
function Box ( config, Width, Height, Depth ) {

    Shape.call( this, config );

    this.type = SHAPE_BOX;

    this.width = Width;
    this.height = Height;
    this.depth = Depth;

    this.halfWidth = Width * 0.5;
    this.halfHeight = Height * 0.5;
    this.halfDepth = Depth * 0.5;

    this.dimentions = new Float32Array( 18 );
    this.elements = new Float32Array( 24 );

}

Box.prototype = Object.assign( Object.create( Shape.prototype ), {

	constructor: Box,

	calculateMassInfo: function ( out ) {

		var mass = this.width * this.height * this.depth * this.density;
		var divid = 1/12;
		out.mass = mass;
		out.inertia.set(
			mass * ( this.height * this.height + this.depth * this.depth ) * divid, 0, 0,
			0, mass * ( this.width * this.width + this.depth * this.depth ) * divid, 0,
			0, 0, mass * ( this.width * this.width + this.height * this.height ) * divid
		);

	},

	updateProxy: function () {

		var te = this.rotation.elements;
		var di = this.dimentions;
		// Width
		di[0] = te[0];
		di[1] = te[3];
		di[2] = te[6];
		// Height
		di[3] = te[1];
		di[4] = te[4];
		di[5] = te[7];
		// Depth
		di[6] = te[2];
		di[7] = te[5];
		di[8] = te[8];
		// half Width
		di[9] = te[0] * this.halfWidth;
		di[10] = te[3] * this.halfWidth;
		di[11] = te[6] * this.halfWidth;
		// half Height
		di[12] = te[1] * this.halfHeight;
		di[13] = te[4] * this.halfHeight;
		di[14] = te[7] * this.halfHeight;
		// half Depth
		di[15] = te[2] * this.halfDepth;
		di[16] = te[5] * this.halfDepth;
		di[17] = te[8] * this.halfDepth;

		var wx = di[9];
		var wy = di[10];
		var wz = di[11];
		var hx = di[12];
		var hy = di[13];
		var hz = di[14];
		var dx = di[15];
		var dy = di[16];
		var dz = di[17];

		var x = this.position.x;
		var y = this.position.y;
		var z = this.position.z;

		var v = this.elements;
		//v1
		v[0] = x + wx + hx + dx;
		v[1] = y + wy + hy + dy;
		v[2] = z + wz + hz + dz;
		//v2
		v[3] = x + wx + hx - dx;
		v[4] = y + wy + hy - dy;
		v[5] = z + wz + hz - dz;
		//v3
		v[6] = x + wx - hx + dx;
		v[7] = y + wy - hy + dy;
		v[8] = z + wz - hz + dz;
		//v4
		v[9] = x + wx - hx - dx;
		v[10] = y + wy - hy - dy;
		v[11] = z + wz - hz - dz;
		//v5
		v[12] = x - wx + hx + dx;
		v[13] = y - wy + hy + dy;
		v[14] = z - wz + hz + dz;
		//v6
		v[15] = x - wx + hx - dx;
		v[16] = y - wy + hy - dy;
		v[17] = z - wz + hz - dz;
		//v7
		v[18] = x - wx - hx + dx;
		v[19] = y - wy - hy + dy;
		v[20] = z - wz - hz + dz;
		//v8
		v[21] = x - wx - hx - dx;
		v[22] = y - wy - hy - dy;
		v[23] = z - wz - hz - dz;

		var w = di[9] < 0 ? -di[9] : di[9];
		var h = di[10] < 0 ? -di[10] : di[10];
		var d = di[11] < 0 ? -di[11] : di[11];

		w = di[12] < 0 ? w - di[12] : w + di[12];
		h = di[13] < 0 ? h - di[13] : h + di[13];
		d = di[14] < 0 ? d - di[14] : d + di[14];

		w = di[15] < 0 ? w - di[15] : w + di[15];
		h = di[16] < 0 ? h - di[16] : h + di[16];
		d = di[17] < 0 ? d - di[17] : d + di[17];

		var p = AABB_PROX;

		this.aabb.set(
			this.position.x - w - p, this.position.x + w + p,
			this.position.y - h - p, this.position.y + h + p,
			this.position.z - d - p, this.position.z + d + p
		);

		if ( this.proxy != null ) this.proxy.update();

	}
});

/**
 * Sphere shape
 * @author saharan
 * @author lo-th
 */

function Sphere( config, radius ) {

    Shape.call( this, config );

    this.type = SHAPE_SPHERE;

    // radius of the shape.
    this.radius = radius;

}

Sphere.prototype = Object.assign( Object.create( Shape.prototype ), {

	constructor: Sphere,

	volume: function () {

		return _Math.PI * this.radius * 1.333333;

	},

	calculateMassInfo: function ( out ) {

		var mass = this.volume() * this.radius * this.radius * this.density; //1.333 * _Math.PI * this.radius * this.radius * this.radius * this.density;
		out.mass = mass;
		var inertia = mass * this.radius * this.radius * 0.4;
		out.inertia.set( inertia, 0, 0, 0, inertia, 0, 0, 0, inertia );

	},

	updateProxy: function () {

		var p = AABB_PROX;

		this.aabb.set(
			this.position.x - this.radius - p, this.position.x + this.radius + p,
			this.position.y - this.radius - p, this.position.y + this.radius + p,
			this.position.z - this.radius - p, this.position.z + this.radius + p
		);

		if ( this.proxy != null ) this.proxy.update();

	}

});

/**
 * Cylinder shape
 * @author saharan
 * @author lo-th
 */

function Cylinder ( config, radius, height ) {

    Shape.call( this, config );

    this.type = SHAPE_CYLINDER;

    this.radius = radius;
    this.height = height;
    this.halfHeight = height * 0.5;

    this.normalDirection = new Vec3();
    this.halfDirection = new Vec3();

}

Cylinder.prototype = Object.assign( Object.create( Shape.prototype ), {

    constructor: Cylinder,

    calculateMassInfo: function ( out ) {

        var rsq = this.radius * this.radius;
        var mass = _Math.PI * rsq * this.height * this.density;
        var inertiaXZ = ( ( 0.25 * rsq ) + ( 0.0833 * this.height * this.height ) ) * mass;
        var inertiaY = 0.5 * rsq;
        out.mass = mass;
        out.inertia.set( inertiaXZ, 0, 0,  0, inertiaY, 0,  0, 0, inertiaXZ );

    },

    updateProxy: function () {

        var te = this.rotation.elements;
        var len, wx, hy, dz, xx, yy, zz, w, h, d, p;

        xx = te[1] * te[1];
        yy = te[4] * te[4];
        zz = te[7] * te[7];

        this.normalDirection.set( te[1], te[4], te[7] );
        this.halfDirection.scale( this.normalDirection, this.halfHeight );

        wx = 1 - xx;
        len = _Math.sqrt(wx*wx + xx*yy + xx*zz);
        if(len>0) len = this.radius/len;
        wx *= len;
        hy = 1 - yy;
        len = _Math.sqrt(yy*xx + hy*hy + yy*zz);
        if(len>0) len = this.radius/len;
        hy *= len;
        dz = 1 - zz;
        len = _Math.sqrt(zz*xx + zz*yy + dz*dz);
        if(len>0) len = this.radius/len;
        dz *= len;

        w = this.halfDirection.x < 0 ? -this.halfDirection.x : this.halfDirection.x;
        h = this.halfDirection.y < 0 ? -this.halfDirection.y : this.halfDirection.y;
        d = this.halfDirection.z < 0 ? -this.halfDirection.z : this.halfDirection.z;

        w = wx < 0 ? w - wx : w + wx;
        h = hy < 0 ? h - hy : h + hy;
        d = dz < 0 ? d - dz : d + dz;

        p = AABB_PROX;

        this.aabb.set(
            this.position.x - w - p, this.position.x + w + p,
            this.position.y - h - p, this.position.y + h + p,
            this.position.z - d - p, this.position.z + d + p
        );

        if ( this.proxy != null ) this.proxy.update();

    }

});

/**
 * Plane shape.
 * @author lo-th
 */

function Plane( config, normal ) {

    Shape.call( this, config );

    this.type = SHAPE_PLANE;

    // radius of the shape.
    this.normal = new Vec3( 0, 1, 0 );

}

Plane.prototype = Object.assign( Object.create( Shape.prototype ), {

    constructor: Plane,

    volume: function () {

        return Number.MAX_VALUE;

    },

    calculateMassInfo: function ( out ) {

        out.mass = this.density;//0.0001;
        var inertia = 1;
        out.inertia.set( inertia, 0, 0, 0, inertia, 0, 0, 0, inertia );

    },

    updateProxy: function () {

        var p = AABB_PROX;

        var min = -_Math.INF;
        var max = _Math.INF;
        var n = this.normal;
        // The plane AABB is infinite, except if the normal is pointing along any axis
        this.aabb.set(
            n.x === -1 ? this.position.x - p : min, n.x === 1 ? this.position.x + p : max,
            n.y === -1 ? this.position.y - p : min, n.y === 1 ? this.position.y + p : max,
            n.z === -1 ? this.position.z - p : min, n.z === 1 ? this.position.z + p : max
        );

        if ( this.proxy != null ) this.proxy.update();

    }

});

/**
 * A Particule shape
 * @author lo-th
 */

function Particle( config, normal ) {

    Shape.call( this, config );

    this.type = SHAPE_PARTICLE;

}

Particle.prototype = Object.assign( Object.create( Shape.prototype ), {

    constructor: Particle,

    volume: function () {

        return Number.MAX_VALUE;

    },

    calculateMassInfo: function ( out ) {

        var inertia = 0;
        out.inertia.set( inertia, 0, 0, 0, inertia, 0, 0, 0, inertia );

    },

    updateProxy: function () {

        var p = 0;//AABB_PROX;

        this.aabb.set(
            this.position.x - p, this.position.x + p,
            this.position.y - p, this.position.y + p,
            this.position.z - p, this.position.z + p
        );

        if ( this.proxy != null ) this.proxy.update();

    }

});

/**
 * A shape configuration holds common configuration data for constructing a shape.
 * These configurations can be reused safely.
 *
 * @author saharan
 * @author lo-th
 */
 
function ShapeConfig(){

    // position of the shape in parent's coordinate system.
    this.relativePosition = new Vec3();
    // rotation matrix of the shape in parent's coordinate system.
    this.relativeRotation = new Mat33();
    // coefficient of friction of the shape.
    this.friction = 0.2; // 0.4
    // coefficient of restitution of the shape.
    this.restitution = 0.2;
    // density of the shape.
    this.density = 1;
    // bits of the collision groups to which the shape belongs.
    this.belongsTo = 1;
    // bits of the collision groups with which the shape collides.
    this.collidesWith = 0xffffffff;

}

/**
* An information of limit and motor.
*
* @author saharan
*/

function LimitMotor ( axis, fixed ) {

    fixed = fixed || false;
    // The axis of the constraint.
    this.axis = axis;
    // The current angle for rotational constraints.
    this.angle = 0;
    // The lower limit. Set lower > upper to disable
    this.lowerLimit = fixed ? 0 : 1;

    //  The upper limit. Set lower > upper to disable.
    this.upperLimit = 0;
    // The target motor speed.
    this.motorSpeed = 0;
    // The maximum motor force or torque. Set 0 to disable.
    this.maxMotorForce = 0;
    // The frequency of the spring. Set 0 to disable.
    this.frequency = 0;
    // The damping ratio of the spring. Set 0 for no damping, 1 for critical damping.
    this.dampingRatio = 0;

}

Object.assign( LimitMotor.prototype, {

    LimitMotor: true,

    // Set limit data into this constraint.
    setLimit:function ( lowerLimit, upperLimit ) {

        this.lowerLimit = lowerLimit;
        this.upperLimit = upperLimit;

    },

    // Set motor data into this constraint.
    setMotor:function ( motorSpeed, maxMotorForce ) {
        
        this.motorSpeed = motorSpeed;
        this.maxMotorForce = maxMotorForce;

    },

    // Set spring data into this constraint.
    setSpring:function ( frequency, dampingRatio ) {
        
        this.frequency = frequency;
        this.dampingRatio = dampingRatio;
        
    }

});

/**
 * The base class of all type of the constraints.
 *
 * @author saharan
 * @author lo-th
 */

function Constraint(){

    // parent world of the constraint.
    this.parent = null;

    // first body of the constraint.
    this.body1 = null;

    // second body of the constraint.
    this.body2 = null;

    // Internal
    this.addedToIsland = false;
    
}

Object.assign( Constraint.prototype, {

    Constraint: true,

    // Prepare for solving the constraint
    preSolve: function( timeStep, invTimeStep ){

        printError("Constraint", "Inheritance error.");

    },

    // Solve the constraint. This is usually called iteratively.
    solve: function(){

        printError("Constraint", "Inheritance error.");

    },

    // Do the post-processing.
    postSolve: function(){

        printError("Constraint", "Inheritance error.");

    }

});

function JointLink ( joint ){
    
    // The previous joint link.
    this.prev = null;
    // The next joint link.
    this.next = null;
    // The other rigid body connected to the joint.
    this.body = null;
    // The joint of the link.
    this.joint = joint;

}

/**
 * Joints are used to constrain the motion between two rigid bodies.
 *
 * @author saharan
 * @author lo-th
 */

function Joint ( config ){

    Constraint.call( this );

    this.scale = 1;
    this.invScale = 1;

    // joint name
    this.name = "";
    this.id = NaN;

    // The type of the joint.
    this.type = JOINT_NULL;
    //  The previous joint in the world.
    this.prev = null;
    // The next joint in the world.
    this.next = null;

    this.body1 = config.body1;
    this.body2 = config.body2;

    // anchor point on the first rigid body in local coordinate system.
    this.localAnchorPoint1 = new Vec3().copy( config.localAnchorPoint1 );
    // anchor point on the second rigid body in local coordinate system.
    this.localAnchorPoint2 = new Vec3().copy( config.localAnchorPoint2 );
    // anchor point on the first rigid body in world coordinate system relative to the body's origin.
    this.relativeAnchorPoint1 = new Vec3();
    // anchor point on the second rigid body in world coordinate system relative to the body's origin.
    this.relativeAnchorPoint2 = new Vec3();
    //  anchor point on the first rigid body in world coordinate system.
    this.anchorPoint1 = new Vec3();
    // anchor point on the second rigid body in world coordinate system.
    this.anchorPoint2 = new Vec3();
    // Whether allow collision between connected rigid bodies or not.
    this.allowCollision = config.allowCollision;

    this.b1Link = new JointLink( this );
    this.b2Link = new JointLink( this );

}

Joint.prototype = Object.assign( Object.create( Constraint.prototype ), {

    constructor: Joint,

    setId: function ( n ) { 

        this.id = i; 

    },

    setParent: function ( world ) {

        this.parent = world;
        this.scale = this.parent.scale;
        this.invScale = this.parent.invScale;
        this.id = this.parent.numJoints;
        if( !this.name ) this.name = 'J' +  this.id;

    },

    // Update all the anchor points.

    updateAnchorPoints: function () {

        this.relativeAnchorPoint1.copy( this.localAnchorPoint1 ).applyMatrix3( this.body1.rotation, true );
        this.relativeAnchorPoint2.copy( this.localAnchorPoint2 ).applyMatrix3( this.body2.rotation, true );

        this.anchorPoint1.add( this.relativeAnchorPoint1, this.body1.position );
        this.anchorPoint2.add( this.relativeAnchorPoint2, this.body2.position );

    },

    // Attach the joint from the bodies.

    attach: function ( isX ) {

        this.b1Link.body = this.body2;
        this.b2Link.body = this.body1;

        if(isX){

            this.body1.jointLink.push( this.b1Link );
            this.body2.jointLink.push( this.b2Link );

        } else {

            if(this.body1.jointLink != null) (this.b1Link.next=this.body1.jointLink).prev = this.b1Link;
            else this.b1Link.next = null;
            this.body1.jointLink = this.b1Link;
            this.body1.numJoints++;
            if(this.body2.jointLink != null) (this.b2Link.next=this.body2.jointLink).prev = this.b2Link;
            else this.b2Link.next = null;
            this.body2.jointLink = this.b2Link;
            this.body2.numJoints++;

        }

    },

    // Detach the joint from the bodies.

    detach: function ( isX ) {

        if( isX ){

            this.body1.jointLink.splice( this.body1.jointLink.indexOf( this.b1Link ), 1 );
            this.body2.jointLink.splice( this.body2.jointLink.indexOf( this.b2Link ), 1 );

        } else {

            var prev = this.b1Link.prev;
            var next = this.b1Link.next;
            if(prev != null) prev.next = next;
            if(next != null) next.prev = prev;
            if(this.body1.jointLink == this.b1Link) this.body1.jointLink = next;
            this.b1Link.prev = null;
            this.b1Link.next = null;
            this.b1Link.body = null;
            this.body1.numJoints--;

            prev = this.b2Link.prev;
            next = this.b2Link.next;
            if(prev != null) prev.next = next;
            if(next != null) next.prev = prev;
            if(this.body2.jointLink==this.b2Link) this.body2.jointLink = next;
            this.b2Link.prev = null;
            this.b2Link.next = null;
            this.b2Link.body = null;
            this.body2.numJoints--;

        }

        this.b1Link.body = null;
        this.b2Link.body = null;

    },


    // Awake the bodies.

    awake: function () {

        this.body1.awake();
        this.body2.awake();

    },

    // calculation function

    preSolve: function ( timeStep, invTimeStep ) {

    },

    solve: function () {

    },

    postSolve: function () {

    },

    // Delete process

    remove: function () {

        this.dispose();

    },

    dispose: function () {

        this.parent.removeJoint( this );

    },


    // Three js add

    getPosition: function () {

        var p1 = new Vec3().scale( this.anchorPoint1, this.scale );
        var p2 = new Vec3().scale( this.anchorPoint2, this.scale );
        return [ p1, p2 ];

    }

});

/**
* A linear constraint for all axes for various joints.
* @author saharan
*/
function LinearConstraint ( joint ){

    this.m1=NaN;
    this.m2=NaN;

    this.ii1 = null;
    this.ii2 = null;
    this.dd = null;

    this.r1x=NaN;
    this.r1y=NaN;
    this.r1z=NaN;

    this.r2x=NaN;
    this.r2y=NaN;
    this.r2z=NaN;

    this.ax1x=NaN;
    this.ax1y=NaN;
    this.ax1z=NaN;
    this.ay1x=NaN;
    this.ay1y=NaN;
    this.ay1z=NaN;
    this.az1x=NaN;
    this.az1y=NaN;
    this.az1z=NaN;

    this.ax2x=NaN;
    this.ax2y=NaN;
    this.ax2z=NaN;
    this.ay2x=NaN;
    this.ay2y=NaN;
    this.ay2z=NaN;
    this.az2x=NaN;
    this.az2y=NaN;
    this.az2z=NaN;

    this.vel=NaN;
    this.velx=NaN;
    this.vely=NaN;
    this.velz=NaN;


    this.joint = joint;
    this.r1 = joint.relativeAnchorPoint1;
    this.r2 = joint.relativeAnchorPoint2;
    this.p1 = joint.anchorPoint1;
    this.p2 = joint.anchorPoint2;
    this.b1 = joint.body1;
    this.b2 = joint.body2;
    this.l1 = this.b1.linearVelocity;
    this.l2 = this.b2.linearVelocity;
    this.a1 = this.b1.angularVelocity;
    this.a2 = this.b2.angularVelocity;
    this.i1 = this.b1.inverseInertia;
    this.i2 = this.b2.inverseInertia;
    this.impx = 0;
    this.impy = 0;
    this.impz = 0;

}

Object.assign( LinearConstraint.prototype, {

    LinearConstraint: true,

    preSolve: function ( timeStep, invTimeStep ) {
        
        this.r1x = this.r1.x;
        this.r1y = this.r1.y;
        this.r1z = this.r1.z;

        this.r2x = this.r2.x;
        this.r2y = this.r2.y;
        this.r2z = this.r2.z;

        this.m1 = this.b1.inverseMass;
        this.m2 = this.b2.inverseMass;

        this.ii1 = this.i1.clone();
        this.ii2 = this.i2.clone();

        var ii1 = this.ii1.elements;
        var ii2 = this.ii2.elements;

        this.ax1x = this.r1z*ii1[1]+-this.r1y*ii1[2];
        this.ax1y = this.r1z*ii1[4]+-this.r1y*ii1[5];
        this.ax1z = this.r1z*ii1[7]+-this.r1y*ii1[8];
        this.ay1x = -this.r1z*ii1[0]+this.r1x*ii1[2];
        this.ay1y = -this.r1z*ii1[3]+this.r1x*ii1[5];
        this.ay1z = -this.r1z*ii1[6]+this.r1x*ii1[8];
        this.az1x = this.r1y*ii1[0]+-this.r1x*ii1[1];
        this.az1y = this.r1y*ii1[3]+-this.r1x*ii1[4];
        this.az1z = this.r1y*ii1[6]+-this.r1x*ii1[7];
        this.ax2x = this.r2z*ii2[1]+-this.r2y*ii2[2];
        this.ax2y = this.r2z*ii2[4]+-this.r2y*ii2[5];
        this.ax2z = this.r2z*ii2[7]+-this.r2y*ii2[8];
        this.ay2x = -this.r2z*ii2[0]+this.r2x*ii2[2];
        this.ay2y = -this.r2z*ii2[3]+this.r2x*ii2[5];
        this.ay2z = -this.r2z*ii2[6]+this.r2x*ii2[8];
        this.az2x = this.r2y*ii2[0]+-this.r2x*ii2[1];
        this.az2y = this.r2y*ii2[3]+-this.r2x*ii2[4];
        this.az2z = this.r2y*ii2[6]+-this.r2x*ii2[7];

        // calculate point-to-point mass matrix
        // from impulse equation
        // 
        // M = ([/m] - [r^][/I][r^]) ^ -1
        // 
        // where
        // 
        // [/m] = |1/m, 0, 0|
        //        |0, 1/m, 0|
        //        |0, 0, 1/m|
        // 
        // [r^] = |0, -rz, ry|
        //        |rz, 0, -rx|
        //        |-ry, rx, 0|
        // 
        // [/I] = Inverted moment inertia

        var rxx = this.m1+this.m2;

        var kk = new Mat33().set( rxx, 0, 0,  0, rxx, 0,  0, 0, rxx );
        var k = kk.elements;

        k[0] += ii1[4]*this.r1z*this.r1z-(ii1[7]+ii1[5])*this.r1y*this.r1z+ii1[8]*this.r1y*this.r1y;
        k[1] += (ii1[6]*this.r1y+ii1[5]*this.r1x)*this.r1z-ii1[3]*this.r1z*this.r1z-ii1[8]*this.r1x*this.r1y;
        k[2] += (ii1[3]*this.r1y-ii1[4]*this.r1x)*this.r1z-ii1[6]*this.r1y*this.r1y+ii1[7]*this.r1x*this.r1y;
        k[3] += (ii1[2]*this.r1y+ii1[7]*this.r1x)*this.r1z-ii1[1]*this.r1z*this.r1z-ii1[8]*this.r1x*this.r1y;
        k[4] += ii1[0]*this.r1z*this.r1z-(ii1[6]+ii1[2])*this.r1x*this.r1z+ii1[8]*this.r1x*this.r1x;
        k[5] += (ii1[1]*this.r1x-ii1[0]*this.r1y)*this.r1z-ii1[7]*this.r1x*this.r1x+ii1[6]*this.r1x*this.r1y;
        k[6] += (ii1[1]*this.r1y-ii1[4]*this.r1x)*this.r1z-ii1[2]*this.r1y*this.r1y+ii1[5]*this.r1x*this.r1y;
        k[7] += (ii1[3]*this.r1x-ii1[0]*this.r1y)*this.r1z-ii1[5]*this.r1x*this.r1x+ii1[2]*this.r1x*this.r1y;
        k[8] += ii1[0]*this.r1y*this.r1y-(ii1[3]+ii1[1])*this.r1x*this.r1y+ii1[4]*this.r1x*this.r1x;

        k[0] += ii2[4]*this.r2z*this.r2z-(ii2[7]+ii2[5])*this.r2y*this.r2z+ii2[8]*this.r2y*this.r2y;
        k[1] += (ii2[6]*this.r2y+ii2[5]*this.r2x)*this.r2z-ii2[3]*this.r2z*this.r2z-ii2[8]*this.r2x*this.r2y;
        k[2] += (ii2[3]*this.r2y-ii2[4]*this.r2x)*this.r2z-ii2[6]*this.r2y*this.r2y+ii2[7]*this.r2x*this.r2y;
        k[3] += (ii2[2]*this.r2y+ii2[7]*this.r2x)*this.r2z-ii2[1]*this.r2z*this.r2z-ii2[8]*this.r2x*this.r2y;
        k[4] += ii2[0]*this.r2z*this.r2z-(ii2[6]+ii2[2])*this.r2x*this.r2z+ii2[8]*this.r2x*this.r2x;
        k[5] += (ii2[1]*this.r2x-ii2[0]*this.r2y)*this.r2z-ii2[7]*this.r2x*this.r2x+ii2[6]*this.r2x*this.r2y;
        k[6] += (ii2[1]*this.r2y-ii2[4]*this.r2x)*this.r2z-ii2[2]*this.r2y*this.r2y+ii2[5]*this.r2x*this.r2y;
        k[7] += (ii2[3]*this.r2x-ii2[0]*this.r2y)*this.r2z-ii2[5]*this.r2x*this.r2x+ii2[2]*this.r2x*this.r2y;
        k[8] += ii2[0]*this.r2y*this.r2y-(ii2[3]+ii2[1])*this.r2x*this.r2y+ii2[4]*this.r2x*this.r2x;

        var inv=1/( k[0]*(k[4]*k[8]-k[7]*k[5]) + k[3]*(k[7]*k[2]-k[1]*k[8]) + k[6]*(k[1]*k[5]-k[4]*k[2]) );
        this.dd = new Mat33().set(
            k[4]*k[8]-k[5]*k[7], k[2]*k[7]-k[1]*k[8], k[1]*k[5]-k[2]*k[4],
            k[5]*k[6]-k[3]*k[8], k[0]*k[8]-k[2]*k[6], k[2]*k[3]-k[0]*k[5],
            k[3]*k[7]-k[4]*k[6], k[1]*k[6]-k[0]*k[7], k[0]*k[4]-k[1]*k[3]
        ).scaleEqual( inv );

        this.velx = this.p2.x-this.p1.x;
        this.vely = this.p2.y-this.p1.y;
        this.velz = this.p2.z-this.p1.z;
        var len = _Math.sqrt(this.velx*this.velx+this.vely*this.vely+this.velz*this.velz);
        if(len>0.005){
            len = (0.005-len)/len*invTimeStep*0.05;
            this.velx *= len;
            this.vely *= len;
            this.velz *= len;
        }else{
            this.velx = 0;
            this.vely = 0;
            this.velz = 0;
        }

        this.impx *= 0.95;
        this.impy *= 0.95;
        this.impz *= 0.95;
        
        this.l1.x += this.impx*this.m1;
        this.l1.y += this.impy*this.m1;
        this.l1.z += this.impz*this.m1;
        this.a1.x += this.impx*this.ax1x+this.impy*this.ay1x+this.impz*this.az1x;
        this.a1.y += this.impx*this.ax1y+this.impy*this.ay1y+this.impz*this.az1y;
        this.a1.z += this.impx*this.ax1z+this.impy*this.ay1z+this.impz*this.az1z;
        this.l2.x -= this.impx*this.m2;
        this.l2.y -= this.impy*this.m2;
        this.l2.z -= this.impz*this.m2;
        this.a2.x -= this.impx*this.ax2x+this.impy*this.ay2x+this.impz*this.az2x;
        this.a2.y -= this.impx*this.ax2y+this.impy*this.ay2y+this.impz*this.az2y;
        this.a2.z -= this.impx*this.ax2z+this.impy*this.ay2z+this.impz*this.az2z;
    },

    solve: function () {

        var d = this.dd.elements;
        var rvx = this.l2.x-this.l1.x+this.a2.y*this.r2z-this.a2.z*this.r2y-this.a1.y*this.r1z+this.a1.z*this.r1y-this.velx;
        var rvy = this.l2.y-this.l1.y+this.a2.z*this.r2x-this.a2.x*this.r2z-this.a1.z*this.r1x+this.a1.x*this.r1z-this.vely;
        var rvz = this.l2.z-this.l1.z+this.a2.x*this.r2y-this.a2.y*this.r2x-this.a1.x*this.r1y+this.a1.y*this.r1x-this.velz;
        var nimpx = rvx*d[0]+rvy*d[1]+rvz*d[2];
        var nimpy = rvx*d[3]+rvy*d[4]+rvz*d[5];
        var nimpz = rvx*d[6]+rvy*d[7]+rvz*d[8];
        this.impx += nimpx;
        this.impy += nimpy;
        this.impz += nimpz;
        this.l1.x += nimpx*this.m1;
        this.l1.y += nimpy*this.m1;
        this.l1.z += nimpz*this.m1;
        this.a1.x += nimpx*this.ax1x+nimpy*this.ay1x+nimpz*this.az1x;
        this.a1.y += nimpx*this.ax1y+nimpy*this.ay1y+nimpz*this.az1y;
        this.a1.z += nimpx*this.ax1z+nimpy*this.ay1z+nimpz*this.az1z;
        this.l2.x -= nimpx*this.m2;
        this.l2.y -= nimpy*this.m2;
        this.l2.z -= nimpz*this.m2;
        this.a2.x -= nimpx*this.ax2x+nimpy*this.ay2x+nimpz*this.az2x;
        this.a2.y -= nimpx*this.ax2y+nimpy*this.ay2y+nimpz*this.az2y;
        this.a2.z -= nimpx*this.ax2z+nimpy*this.ay2z+nimpz*this.az2z;

    }

} );

/**
* A three-axis rotational constraint for various joints.
* @author saharan
*/

function Rotational3Constraint ( joint, limitMotor1, limitMotor2, limitMotor3 ) {
    
    this.cfm1=NaN;
    this.cfm2=NaN;
    this.cfm3=NaN;
    this.i1e00=NaN;
    this.i1e01=NaN;
    this.i1e02=NaN;
    this.i1e10=NaN;
    this.i1e11=NaN;
    this.i1e12=NaN;
    this.i1e20=NaN;
    this.i1e21=NaN;
    this.i1e22=NaN;
    this.i2e00=NaN;
    this.i2e01=NaN;
    this.i2e02=NaN;
    this.i2e10=NaN;
    this.i2e11=NaN;
    this.i2e12=NaN;
    this.i2e20=NaN;
    this.i2e21=NaN;
    this.i2e22=NaN;
    this.ax1=NaN;
    this.ay1=NaN;
    this.az1=NaN;
    this.ax2=NaN;
    this.ay2=NaN;
    this.az2=NaN;
    this.ax3=NaN;
    this.ay3=NaN;
    this.az3=NaN;

    this.a1x1=NaN; // jacoians
    this.a1y1=NaN;
    this.a1z1=NaN;
    this.a2x1=NaN;
    this.a2y1=NaN;
    this.a2z1=NaN;
    this.a1x2=NaN;
    this.a1y2=NaN;
    this.a1z2=NaN;
    this.a2x2=NaN;
    this.a2y2=NaN;
    this.a2z2=NaN;
    this.a1x3=NaN;
    this.a1y3=NaN;
    this.a1z3=NaN;
    this.a2x3=NaN;
    this.a2y3=NaN;
    this.a2z3=NaN;

    this.lowerLimit1=NaN;
    this.upperLimit1=NaN;
    this.limitVelocity1=NaN;
    this.limitState1=0; // -1: at lower, 0: locked, 1: at upper, 2: free
    this.enableMotor1=false;
    this.motorSpeed1=NaN;
    this.maxMotorForce1=NaN;
    this.maxMotorImpulse1=NaN;
    this.lowerLimit2=NaN;
    this.upperLimit2=NaN;
    this.limitVelocity2=NaN;
    this.limitState2=0; // -1: at lower, 0: locked, 1: at upper, 2: free
    this.enableMotor2=false;
    this.motorSpeed2=NaN;
    this.maxMotorForce2=NaN;
    this.maxMotorImpulse2=NaN;
    this.lowerLimit3=NaN;
    this.upperLimit3=NaN;
    this.limitVelocity3=NaN;
    this.limitState3=0; // -1: at lower, 0: locked, 1: at upper, 2: free
    this.enableMotor3=false;
    this.motorSpeed3=NaN;
    this.maxMotorForce3=NaN;
    this.maxMotorImpulse3=NaN;

    this.k00=NaN; // K = J*M*JT
    this.k01=NaN;
    this.k02=NaN;
    this.k10=NaN;
    this.k11=NaN;
    this.k12=NaN;
    this.k20=NaN;
    this.k21=NaN;
    this.k22=NaN;

    this.kv00=NaN; // diagonals without CFMs
    this.kv11=NaN;
    this.kv22=NaN;

    this.dv00=NaN; // ...inverted
    this.dv11=NaN;
    this.dv22=NaN;

    this.d00=NaN;  // K^-1
    this.d01=NaN;
    this.d02=NaN;
    this.d10=NaN;
    this.d11=NaN;
    this.d12=NaN;
    this.d20=NaN;
    this.d21=NaN;
    this.d22=NaN;

    this.limitMotor1=limitMotor1;
    this.limitMotor2=limitMotor2;
    this.limitMotor3=limitMotor3;
    this.b1=joint.body1;
    this.b2=joint.body2;
    this.a1=this.b1.angularVelocity;
    this.a2=this.b2.angularVelocity;
    this.i1=this.b1.inverseInertia;
    this.i2=this.b2.inverseInertia;
    this.limitImpulse1=0;
    this.motorImpulse1=0;
    this.limitImpulse2=0;
    this.motorImpulse2=0;
    this.limitImpulse3=0;
    this.motorImpulse3=0;

}

Object.assign( Rotational3Constraint.prototype, {

    Rotational3Constraint: true,

    preSolve: function( timeStep, invTimeStep ){

        this.ax1=this.limitMotor1.axis.x;
        this.ay1=this.limitMotor1.axis.y;
        this.az1=this.limitMotor1.axis.z;
        this.ax2=this.limitMotor2.axis.x;
        this.ay2=this.limitMotor2.axis.y;
        this.az2=this.limitMotor2.axis.z;
        this.ax3=this.limitMotor3.axis.x;
        this.ay3=this.limitMotor3.axis.y;
        this.az3=this.limitMotor3.axis.z;
        this.lowerLimit1=this.limitMotor1.lowerLimit;
        this.upperLimit1=this.limitMotor1.upperLimit;
        this.motorSpeed1=this.limitMotor1.motorSpeed;
        this.maxMotorForce1=this.limitMotor1.maxMotorForce;
        this.enableMotor1=this.maxMotorForce1>0;
        this.lowerLimit2=this.limitMotor2.lowerLimit;
        this.upperLimit2=this.limitMotor2.upperLimit;
        this.motorSpeed2=this.limitMotor2.motorSpeed;
        this.maxMotorForce2=this.limitMotor2.maxMotorForce;
        this.enableMotor2=this.maxMotorForce2>0;
        this.lowerLimit3=this.limitMotor3.lowerLimit;
        this.upperLimit3=this.limitMotor3.upperLimit;
        this.motorSpeed3=this.limitMotor3.motorSpeed;
        this.maxMotorForce3=this.limitMotor3.maxMotorForce;
        this.enableMotor3=this.maxMotorForce3>0;

        var ti1 = this.i1.elements;
        var ti2 = this.i2.elements;
        this.i1e00=ti1[0];
        this.i1e01=ti1[1];
        this.i1e02=ti1[2];
        this.i1e10=ti1[3];
        this.i1e11=ti1[4];
        this.i1e12=ti1[5];
        this.i1e20=ti1[6];
        this.i1e21=ti1[7];
        this.i1e22=ti1[8];

        this.i2e00=ti2[0];
        this.i2e01=ti2[1];
        this.i2e02=ti2[2];
        this.i2e10=ti2[3];
        this.i2e11=ti2[4];
        this.i2e12=ti2[5];
        this.i2e20=ti2[6];
        this.i2e21=ti2[7];
        this.i2e22=ti2[8];

        var frequency1=this.limitMotor1.frequency;
        var frequency2=this.limitMotor2.frequency;
        var frequency3=this.limitMotor3.frequency;
        var enableSpring1=frequency1>0;
        var enableSpring2=frequency2>0;
        var enableSpring3=frequency3>0;
        var enableLimit1=this.lowerLimit1<=this.upperLimit1;
        var enableLimit2=this.lowerLimit2<=this.upperLimit2;
        var enableLimit3=this.lowerLimit3<=this.upperLimit3;
        var angle1=this.limitMotor1.angle;
        if(enableLimit1){
            if(this.lowerLimit1==this.upperLimit1){
                if(this.limitState1!=0){
                    this.limitState1=0;
                    this.limitImpulse1=0;
                }
                this.limitVelocity1=this.lowerLimit1-angle1;
            }else if(angle1<this.lowerLimit1){
                if(this.limitState1!=-1){
                    this.limitState1=-1;
                    this.limitImpulse1=0;
                }
                this.limitVelocity1=this.lowerLimit1-angle1;
            }else if(angle1>this.upperLimit1){
                if(this.limitState1!=1){
                    this.limitState1=1;
                    this.limitImpulse1=0;
                }
                this.limitVelocity1=this.upperLimit1-angle1;
            }else{
                this.limitState1=2;
                this.limitImpulse1=0;
                this.limitVelocity1=0;
            }
            if(!enableSpring1){
                if(this.limitVelocity1>0.02)this.limitVelocity1-=0.02;
                else if(this.limitVelocity1<-0.02)this.limitVelocity1+=0.02;
                else this.limitVelocity1=0;
            }
        }else{
            this.limitState1=2;
            this.limitImpulse1=0;
        }

        var angle2=this.limitMotor2.angle;
        if(enableLimit2){
            if(this.lowerLimit2==this.upperLimit2){
                if(this.limitState2!=0){
                    this.limitState2=0;
                    this.limitImpulse2=0;
                }
                this.limitVelocity2=this.lowerLimit2-angle2;
            }else if(angle2<this.lowerLimit2){
                if(this.limitState2!=-1){
                    this.limitState2=-1;
                    this.limitImpulse2=0;
                }
                this.limitVelocity2=this.lowerLimit2-angle2;
            }else if(angle2>this.upperLimit2){
                if(this.limitState2!=1){
                    this.limitState2=1;
                    this.limitImpulse2=0;
                }
                this.limitVelocity2=this.upperLimit2-angle2;
            }else{
                this.limitState2=2;
                this.limitImpulse2=0;
                this.limitVelocity2=0;
            }
            if(!enableSpring2){
                if(this.limitVelocity2>0.02)this.limitVelocity2-=0.02;
                else if(this.limitVelocity2<-0.02)this.limitVelocity2+=0.02;
                else this.limitVelocity2=0;
            }
        }else{
            this.limitState2=2;
            this.limitImpulse2=0;
        }

        var angle3=this.limitMotor3.angle;
        if(enableLimit3){
            if(this.lowerLimit3==this.upperLimit3){
                if(this.limitState3!=0){
                    this.limitState3=0;
                    this.limitImpulse3=0;
                }
                this.limitVelocity3=this.lowerLimit3-angle3;
            }else if(angle3<this.lowerLimit3){
                if(this.limitState3!=-1){
                    this.limitState3=-1;
                    this.limitImpulse3=0;
                }
                this.limitVelocity3=this.lowerLimit3-angle3;
            }else if(angle3>this.upperLimit3){
                if(this.limitState3!=1){
                    this.limitState3=1;
                    this.limitImpulse3=0;
                }
                this.limitVelocity3=this.upperLimit3-angle3;
            }else{
                this.limitState3=2;
                this.limitImpulse3=0;
                this.limitVelocity3=0;
                }
            if(!enableSpring3){
                if(this.limitVelocity3>0.02)this.limitVelocity3-=0.02;
                else if(this.limitVelocity3<-0.02)this.limitVelocity3+=0.02;
                else this.limitVelocity3=0;
            }
        }else{
            this.limitState3=2;
            this.limitImpulse3=0;
        }

        if(this.enableMotor1&&(this.limitState1!=0||enableSpring1)){
            this.maxMotorImpulse1=this.maxMotorForce1*timeStep;
        }else{
            this.motorImpulse1=0;
            this.maxMotorImpulse1=0;
        }
        if(this.enableMotor2&&(this.limitState2!=0||enableSpring2)){
            this.maxMotorImpulse2=this.maxMotorForce2*timeStep;
        }else{
            this.motorImpulse2=0;
            this.maxMotorImpulse2=0;
        }
        if(this.enableMotor3&&(this.limitState3!=0||enableSpring3)){
            this.maxMotorImpulse3=this.maxMotorForce3*timeStep;
        }else{
            this.motorImpulse3=0;
            this.maxMotorImpulse3=0;
        }

        // build jacobians
        this.a1x1=this.ax1*this.i1e00+this.ay1*this.i1e01+this.az1*this.i1e02;
        this.a1y1=this.ax1*this.i1e10+this.ay1*this.i1e11+this.az1*this.i1e12;
        this.a1z1=this.ax1*this.i1e20+this.ay1*this.i1e21+this.az1*this.i1e22;
        this.a2x1=this.ax1*this.i2e00+this.ay1*this.i2e01+this.az1*this.i2e02;
        this.a2y1=this.ax1*this.i2e10+this.ay1*this.i2e11+this.az1*this.i2e12;
        this.a2z1=this.ax1*this.i2e20+this.ay1*this.i2e21+this.az1*this.i2e22;

        this.a1x2=this.ax2*this.i1e00+this.ay2*this.i1e01+this.az2*this.i1e02;
        this.a1y2=this.ax2*this.i1e10+this.ay2*this.i1e11+this.az2*this.i1e12;
        this.a1z2=this.ax2*this.i1e20+this.ay2*this.i1e21+this.az2*this.i1e22;
        this.a2x2=this.ax2*this.i2e00+this.ay2*this.i2e01+this.az2*this.i2e02;
        this.a2y2=this.ax2*this.i2e10+this.ay2*this.i2e11+this.az2*this.i2e12;
        this.a2z2=this.ax2*this.i2e20+this.ay2*this.i2e21+this.az2*this.i2e22;

        this.a1x3=this.ax3*this.i1e00+this.ay3*this.i1e01+this.az3*this.i1e02;
        this.a1y3=this.ax3*this.i1e10+this.ay3*this.i1e11+this.az3*this.i1e12;
        this.a1z3=this.ax3*this.i1e20+this.ay3*this.i1e21+this.az3*this.i1e22;
        this.a2x3=this.ax3*this.i2e00+this.ay3*this.i2e01+this.az3*this.i2e02;
        this.a2y3=this.ax3*this.i2e10+this.ay3*this.i2e11+this.az3*this.i2e12;
        this.a2z3=this.ax3*this.i2e20+this.ay3*this.i2e21+this.az3*this.i2e22;

        // build an impulse matrix
        this.k00=this.ax1*(this.a1x1+this.a2x1)+this.ay1*(this.a1y1+this.a2y1)+this.az1*(this.a1z1+this.a2z1);
        this.k01=this.ax1*(this.a1x2+this.a2x2)+this.ay1*(this.a1y2+this.a2y2)+this.az1*(this.a1z2+this.a2z2);
        this.k02=this.ax1*(this.a1x3+this.a2x3)+this.ay1*(this.a1y3+this.a2y3)+this.az1*(this.a1z3+this.a2z3);
        this.k10=this.ax2*(this.a1x1+this.a2x1)+this.ay2*(this.a1y1+this.a2y1)+this.az2*(this.a1z1+this.a2z1);
        this.k11=this.ax2*(this.a1x2+this.a2x2)+this.ay2*(this.a1y2+this.a2y2)+this.az2*(this.a1z2+this.a2z2);
        this.k12=this.ax2*(this.a1x3+this.a2x3)+this.ay2*(this.a1y3+this.a2y3)+this.az2*(this.a1z3+this.a2z3);
        this.k20=this.ax3*(this.a1x1+this.a2x1)+this.ay3*(this.a1y1+this.a2y1)+this.az3*(this.a1z1+this.a2z1);
        this.k21=this.ax3*(this.a1x2+this.a2x2)+this.ay3*(this.a1y2+this.a2y2)+this.az3*(this.a1z2+this.a2z2);
        this.k22=this.ax3*(this.a1x3+this.a2x3)+this.ay3*(this.a1y3+this.a2y3)+this.az3*(this.a1z3+this.a2z3);

        this.kv00=this.k00;
        this.kv11=this.k11;
        this.kv22=this.k22;
        this.dv00=1/this.kv00;
        this.dv11=1/this.kv11;
        this.dv22=1/this.kv22;

        if(enableSpring1&&this.limitState1!=2){
            var omega=6.2831853*frequency1;
            var k=omega*omega*timeStep;
            var dmp=invTimeStep/(k+2*this.limitMotor1.dampingRatio*omega);
            this.cfm1=this.kv00*dmp;
            this.limitVelocity1*=k*dmp;
        }else{
            this.cfm1=0;
            this.limitVelocity1*=invTimeStep*0.05;
        }

        if(enableSpring2&&this.limitState2!=2){
            omega=6.2831853*frequency2;
            k=omega*omega*timeStep;
            dmp=invTimeStep/(k+2*this.limitMotor2.dampingRatio*omega);
            this.cfm2=this.kv11*dmp;
            this.limitVelocity2*=k*dmp;
        }else{
            this.cfm2=0;
            this.limitVelocity2*=invTimeStep*0.05;
        }

        if(enableSpring3&&this.limitState3!=2){
            omega=6.2831853*frequency3;
            k=omega*omega*timeStep;
            dmp=invTimeStep/(k+2*this.limitMotor3.dampingRatio*omega);
            this.cfm3=this.kv22*dmp;
            this.limitVelocity3*=k*dmp;
        }else{
            this.cfm3=0;
            this.limitVelocity3*=invTimeStep*0.05;
        }

        this.k00+=this.cfm1;
        this.k11+=this.cfm2;
        this.k22+=this.cfm3;

        var inv=1/(
        this.k00*(this.k11*this.k22-this.k21*this.k12)+
        this.k10*(this.k21*this.k02-this.k01*this.k22)+
        this.k20*(this.k01*this.k12-this.k11*this.k02)
        );
        this.d00=(this.k11*this.k22-this.k12*this.k21)*inv;
        this.d01=(this.k02*this.k21-this.k01*this.k22)*inv;
        this.d02=(this.k01*this.k12-this.k02*this.k11)*inv;
        this.d10=(this.k12*this.k20-this.k10*this.k22)*inv;
        this.d11=(this.k00*this.k22-this.k02*this.k20)*inv;
        this.d12=(this.k02*this.k10-this.k00*this.k12)*inv;
        this.d20=(this.k10*this.k21-this.k11*this.k20)*inv;
        this.d21=(this.k01*this.k20-this.k00*this.k21)*inv;
        this.d22=(this.k00*this.k11-this.k01*this.k10)*inv;
        
        this.limitImpulse1*=0.95;
        this.motorImpulse1*=0.95;
        this.limitImpulse2*=0.95;
        this.motorImpulse2*=0.95;
        this.limitImpulse3*=0.95;
        this.motorImpulse3*=0.95;
        var totalImpulse1=this.limitImpulse1+this.motorImpulse1;
        var totalImpulse2=this.limitImpulse2+this.motorImpulse2;
        var totalImpulse3=this.limitImpulse3+this.motorImpulse3;
        this.a1.x+=totalImpulse1*this.a1x1+totalImpulse2*this.a1x2+totalImpulse3*this.a1x3;
        this.a1.y+=totalImpulse1*this.a1y1+totalImpulse2*this.a1y2+totalImpulse3*this.a1y3;
        this.a1.z+=totalImpulse1*this.a1z1+totalImpulse2*this.a1z2+totalImpulse3*this.a1z3;
        this.a2.x-=totalImpulse1*this.a2x1+totalImpulse2*this.a2x2+totalImpulse3*this.a2x3;
        this.a2.y-=totalImpulse1*this.a2y1+totalImpulse2*this.a2y2+totalImpulse3*this.a2y3;
        this.a2.z-=totalImpulse1*this.a2z1+totalImpulse2*this.a2z2+totalImpulse3*this.a2z3;
    },
    solve_:function(){

        var rvx=this.a2.x-this.a1.x;
        var rvy=this.a2.y-this.a1.y;
        var rvz=this.a2.z-this.a1.z;

        this.limitVelocity3=30;
        var rvn1=rvx*this.ax1+rvy*this.ay1+rvz*this.az1-this.limitVelocity1;
        var rvn2=rvx*this.ax2+rvy*this.ay2+rvz*this.az2-this.limitVelocity2;
        var rvn3=rvx*this.ax3+rvy*this.ay3+rvz*this.az3-this.limitVelocity3;

        var dLimitImpulse1=rvn1*this.d00+rvn2*this.d01+rvn3*this.d02;
        var dLimitImpulse2=rvn1*this.d10+rvn2*this.d11+rvn3*this.d12;
        var dLimitImpulse3=rvn1*this.d20+rvn2*this.d21+rvn3*this.d22;

        this.limitImpulse1+=dLimitImpulse1;
        this.limitImpulse2+=dLimitImpulse2;
        this.limitImpulse3+=dLimitImpulse3;

        this.a1.x+=dLimitImpulse1*this.a1x1+dLimitImpulse2*this.a1x2+dLimitImpulse3*this.a1x3;
        this.a1.y+=dLimitImpulse1*this.a1y1+dLimitImpulse2*this.a1y2+dLimitImpulse3*this.a1y3;
        this.a1.z+=dLimitImpulse1*this.a1z1+dLimitImpulse2*this.a1z2+dLimitImpulse3*this.a1z3;
        this.a2.x-=dLimitImpulse1*this.a2x1+dLimitImpulse2*this.a2x2+dLimitImpulse3*this.a2x3;
        this.a2.y-=dLimitImpulse1*this.a2y1+dLimitImpulse2*this.a2y2+dLimitImpulse3*this.a2y3;
        this.a2.z-=dLimitImpulse1*this.a2z1+dLimitImpulse2*this.a2z2+dLimitImpulse3*this.a2z3;
    },
    solve:function(){

        var rvx=this.a2.x-this.a1.x;
        var rvy=this.a2.y-this.a1.y;
        var rvz=this.a2.z-this.a1.z;

        var rvn1=rvx*this.ax1+rvy*this.ay1+rvz*this.az1;
        var rvn2=rvx*this.ax2+rvy*this.ay2+rvz*this.az2;
        var rvn3=rvx*this.ax3+rvy*this.ay3+rvz*this.az3;

        var oldMotorImpulse1=this.motorImpulse1;
        var oldMotorImpulse2=this.motorImpulse2;
        var oldMotorImpulse3=this.motorImpulse3;

        var dMotorImpulse1=0;
        var dMotorImpulse2=0;
        var dMotorImpulse3=0;

        if(this.enableMotor1){
            dMotorImpulse1=(rvn1-this.motorSpeed1)*this.dv00;
            this.motorImpulse1+=dMotorImpulse1;
            if(this.motorImpulse1>this.maxMotorImpulse1){ // clamp motor impulse
            this.motorImpulse1=this.maxMotorImpulse1;
            }else if(this.motorImpulse1<-this.maxMotorImpulse1){
            this.motorImpulse1=-this.maxMotorImpulse1;
            }
            dMotorImpulse1=this.motorImpulse1-oldMotorImpulse1;
        }
        if(this.enableMotor2){
            dMotorImpulse2=(rvn2-this.motorSpeed2)*this.dv11;
            this.motorImpulse2+=dMotorImpulse2;
            if(this.motorImpulse2>this.maxMotorImpulse2){ // clamp motor impulse
                this.motorImpulse2=this.maxMotorImpulse2;
            }else if(this.motorImpulse2<-this.maxMotorImpulse2){
                this.motorImpulse2=-this.maxMotorImpulse2;
            }
            dMotorImpulse2=this.motorImpulse2-oldMotorImpulse2;
        }
        if(this.enableMotor3){
            dMotorImpulse3=(rvn3-this.motorSpeed3)*this.dv22;
            this.motorImpulse3+=dMotorImpulse3;
            if(this.motorImpulse3>this.maxMotorImpulse3){ // clamp motor impulse
                this.motorImpulse3=this.maxMotorImpulse3;
            }else if(this.motorImpulse3<-this.maxMotorImpulse3){
                this.motorImpulse3=-this.maxMotorImpulse3;
            }
            dMotorImpulse3=this.motorImpulse3-oldMotorImpulse3;
        }

        // apply motor impulse to relative velocity
        rvn1+=dMotorImpulse1*this.kv00+dMotorImpulse2*this.k01+dMotorImpulse3*this.k02;
        rvn2+=dMotorImpulse1*this.k10+dMotorImpulse2*this.kv11+dMotorImpulse3*this.k12;
        rvn3+=dMotorImpulse1*this.k20+dMotorImpulse2*this.k21+dMotorImpulse3*this.kv22;

        // subtract target velocity and applied impulse
        rvn1-=this.limitVelocity1+this.limitImpulse1*this.cfm1;
        rvn2-=this.limitVelocity2+this.limitImpulse2*this.cfm2;
        rvn3-=this.limitVelocity3+this.limitImpulse3*this.cfm3;

        var oldLimitImpulse1=this.limitImpulse1;
        var oldLimitImpulse2=this.limitImpulse2;
        var oldLimitImpulse3=this.limitImpulse3;

        var dLimitImpulse1=rvn1*this.d00+rvn2*this.d01+rvn3*this.d02;
        var dLimitImpulse2=rvn1*this.d10+rvn2*this.d11+rvn3*this.d12;
        var dLimitImpulse3=rvn1*this.d20+rvn2*this.d21+rvn3*this.d22;

        this.limitImpulse1+=dLimitImpulse1;
        this.limitImpulse2+=dLimitImpulse2;
        this.limitImpulse3+=dLimitImpulse3;

        // clamp
        var clampState=0;
        if(this.limitState1==2||this.limitImpulse1*this.limitState1<0){
            dLimitImpulse1=-oldLimitImpulse1;
            rvn2+=dLimitImpulse1*this.k10;
            rvn3+=dLimitImpulse1*this.k20;
            clampState|=1;
        }
        if(this.limitState2==2||this.limitImpulse2*this.limitState2<0){
            dLimitImpulse2=-oldLimitImpulse2;
            rvn1+=dLimitImpulse2*this.k01;
            rvn3+=dLimitImpulse2*this.k21;
            clampState|=2;
        }
        if(this.limitState3==2||this.limitImpulse3*this.limitState3<0){
            dLimitImpulse3=-oldLimitImpulse3;
            rvn1+=dLimitImpulse3*this.k02;
            rvn2+=dLimitImpulse3*this.k12;
            clampState|=4;
        }

        // update un-clamped impulse
        // TODO: isolate division
        var det;
        switch(clampState){
            case 1: // update 2 3
            det=1/(this.k11*this.k22-this.k12*this.k21);
            dLimitImpulse2=(this.k22*rvn2+-this.k12*rvn3)*det;
            dLimitImpulse3=(-this.k21*rvn2+this.k11*rvn3)*det;
            break;
            case 2: // update 1 3
            det=1/(this.k00*this.k22-this.k02*this.k20);
            dLimitImpulse1=(this.k22*rvn1+-this.k02*rvn3)*det;
            dLimitImpulse3=(-this.k20*rvn1+this.k00*rvn3)*det;
            break;
            case 3: // update 3
            dLimitImpulse3=rvn3/this.k22;
            break;
            case 4: // update 1 2
            det=1/(this.k00*this.k11-this.k01*this.k10);
            dLimitImpulse1=(this.k11*rvn1+-this.k01*rvn2)*det;
            dLimitImpulse2=(-this.k10*rvn1+this.k00*rvn2)*det;
            break;
            case 5: // update 2
            dLimitImpulse2=rvn2/this.k11;
            break;
            case 6: // update 1
            dLimitImpulse1=rvn1/this.k00;
            break;
        }

        this.limitImpulse1=dLimitImpulse1+oldLimitImpulse1;
        this.limitImpulse2=dLimitImpulse2+oldLimitImpulse2;
        this.limitImpulse3=dLimitImpulse3+oldLimitImpulse3;

        var dImpulse1=dMotorImpulse1+dLimitImpulse1;
        var dImpulse2=dMotorImpulse2+dLimitImpulse2;
        var dImpulse3=dMotorImpulse3+dLimitImpulse3;

        // apply impulse
        this.a1.x+=dImpulse1*this.a1x1+dImpulse2*this.a1x2+dImpulse3*this.a1x3;
        this.a1.y+=dImpulse1*this.a1y1+dImpulse2*this.a1y2+dImpulse3*this.a1y3;
        this.a1.z+=dImpulse1*this.a1z1+dImpulse2*this.a1z2+dImpulse3*this.a1z3;
        this.a2.x-=dImpulse1*this.a2x1+dImpulse2*this.a2x2+dImpulse3*this.a2x3;
        this.a2.y-=dImpulse1*this.a2y1+dImpulse2*this.a2y2+dImpulse3*this.a2y3;
        this.a2.z-=dImpulse1*this.a2z1+dImpulse2*this.a2z2+dImpulse3*this.a2z3;
        rvx=this.a2.x-this.a1.x;
        rvy=this.a2.y-this.a1.y;
        rvz=this.a2.z-this.a1.z;

        rvn2=rvx*this.ax2+rvy*this.ay2+rvz*this.az2;
    }
    
} );

/**
 * A hinge joint allows only for relative rotation of rigid bodies along the axis.
 *
 * @author saharan
 * @author lo-th
 */

function HingeJoint ( config, lowerAngleLimit, upperAngleLimit ) {

    Joint.call( this, config );

    this.type = JOINT_HINGE;

    // The axis in the first body's coordinate system.
    this.localAxis1 = config.localAxis1.clone().normalize();
    // The axis in the second body's coordinate system.
    this.localAxis2 = config.localAxis2.clone().normalize();

    // make angle axis
    var arc = new Mat33().setQuat( new Quat().setFromUnitVectors( this.localAxis1, this.localAxis2 ) );
    this.localAngle1 = new Vec3().tangent( this.localAxis1 ).normalize();
    this.localAngle2 = this.localAngle1.clone().applyMatrix3( arc, true );

    this.ax1 = new Vec3();
    this.ax2 = new Vec3();
    this.an1 = new Vec3();
    this.an2 = new Vec3();

    this.tmp = new Vec3();

    this.nor = new Vec3();
    this.tan = new Vec3();
    this.bin = new Vec3();

    // The rotational limit and motor information of the joint.
    this.limitMotor = new LimitMotor( this.nor, false );
    this.limitMotor.lowerLimit = lowerAngleLimit;
    this.limitMotor.upperLimit = upperAngleLimit;

    this.lc = new LinearConstraint( this );
    this.r3 = new Rotational3Constraint( this, this.limitMotor, new LimitMotor( this.tan, true ), new LimitMotor( this.bin, true ) );
}

HingeJoint.prototype = Object.assign( Object.create( Joint.prototype ), {

    constructor: HingeJoint,


    preSolve: function ( timeStep, invTimeStep ) {

        this.updateAnchorPoints();

        this.ax1.copy( this.localAxis1 ).applyMatrix3( this.body1.rotation, true );
        this.ax2.copy( this.localAxis2 ).applyMatrix3( this.body2.rotation, true );

        this.an1.copy( this.localAngle1 ).applyMatrix3( this.body1.rotation, true );
        this.an2.copy( this.localAngle2 ).applyMatrix3( this.body2.rotation, true );

        // normal tangent binormal

        this.nor.set(
            this.ax1.x*this.body2.inverseMass + this.ax2.x*this.body1.inverseMass,
            this.ax1.y*this.body2.inverseMass + this.ax2.y*this.body1.inverseMass,
            this.ax1.z*this.body2.inverseMass + this.ax2.z*this.body1.inverseMass
        ).normalize();

        this.tan.tangent( this.nor ).normalize();

        this.bin.crossVectors( this.nor, this.tan );

        // calculate hinge angle

        var limite = _Math.acosClamp( _Math.dotVectors( this.an1, this.an2 ) );

        this.tmp.crossVectors( this.an1, this.an2 );

        if( _Math.dotVectors( this.nor, this.tmp ) < 0 ) this.limitMotor.angle = -limite;
        else this.limitMotor.angle = limite;

        this.tmp.crossVectors( this.ax1, this.ax2 );

        this.r3.limitMotor2.angle = _Math.dotVectors( this.tan, this.tmp );
        this.r3.limitMotor3.angle = _Math.dotVectors( this.bin, this.tmp );

        // preSolve
        
        this.r3.preSolve( timeStep, invTimeStep );
        this.lc.preSolve( timeStep, invTimeStep );

    },

    solve: function () {

        this.r3.solve();
        this.lc.solve();

    },

    postSolve: function () {

    }

});

/**
 * A ball-and-socket joint limits relative translation on two anchor points on rigid bodies.
 *
 * @author saharan
 * @author lo-th
 */

function BallAndSocketJoint ( config ){

    Joint.call( this, config );

    this.type = JOINT_BALL_AND_SOCKET;
    
    this.lc = new LinearConstraint( this );

}

BallAndSocketJoint.prototype = Object.assign( Object.create( Joint.prototype ), {

    constructor: BallAndSocketJoint,

    preSolve: function ( timeStep, invTimeStep ) {

        this.updateAnchorPoints();

        // preSolve

        this.lc.preSolve( timeStep, invTimeStep );

    },

    solve: function () {

        this.lc.solve();

    },

    postSolve: function () {

    }

});

/**
* A translational constraint for various joints.
* @author saharan
*/
function TranslationalConstraint ( joint, limitMotor ){
    this.cfm=NaN;
    this.m1=NaN;
    this.m2=NaN;
    this.i1e00=NaN;
    this.i1e01=NaN;
    this.i1e02=NaN;
    this.i1e10=NaN;
    this.i1e11=NaN;
    this.i1e12=NaN;
    this.i1e20=NaN;
    this.i1e21=NaN;
    this.i1e22=NaN;
    this.i2e00=NaN;
    this.i2e01=NaN;
    this.i2e02=NaN;
    this.i2e10=NaN;
    this.i2e11=NaN;
    this.i2e12=NaN;
    this.i2e20=NaN;
    this.i2e21=NaN;
    this.i2e22=NaN;
    this.motorDenom=NaN;
    this.invMotorDenom=NaN;
    this.invDenom=NaN;
    this.ax=NaN;
    this.ay=NaN;
    this.az=NaN;
    this.r1x=NaN;
    this.r1y=NaN;
    this.r1z=NaN;
    this.r2x=NaN;
    this.r2y=NaN;
    this.r2z=NaN;
    this.t1x=NaN;
    this.t1y=NaN;
    this.t1z=NaN;
    this.t2x=NaN;
    this.t2y=NaN;
    this.t2z=NaN;
    this.l1x=NaN;
    this.l1y=NaN;
    this.l1z=NaN;
    this.l2x=NaN;
    this.l2y=NaN;
    this.l2z=NaN;
    this.a1x=NaN;
    this.a1y=NaN;
    this.a1z=NaN;
    this.a2x=NaN;
    this.a2y=NaN;
    this.a2z=NaN;
    this.lowerLimit=NaN;
    this.upperLimit=NaN;
    this.limitVelocity=NaN;
    this.limitState=0; // -1: at lower, 0: locked, 1: at upper, 2: free
    this.enableMotor=false;
    this.motorSpeed=NaN;
    this.maxMotorForce=NaN;
    this.maxMotorImpulse=NaN;

    this.limitMotor=limitMotor;
    this.b1=joint.body1;
    this.b2=joint.body2;
    this.p1=joint.anchorPoint1;
    this.p2=joint.anchorPoint2;
    this.r1=joint.relativeAnchorPoint1;
    this.r2=joint.relativeAnchorPoint2;
    this.l1=this.b1.linearVelocity;
    this.l2=this.b2.linearVelocity;
    this.a1=this.b1.angularVelocity;
    this.a2=this.b2.angularVelocity;
    this.i1=this.b1.inverseInertia;
    this.i2=this.b2.inverseInertia;
    this.limitImpulse=0;
    this.motorImpulse=0;
}

Object.assign( TranslationalConstraint.prototype, {

    TranslationalConstraint: true,

    preSolve:function(timeStep,invTimeStep){
        this.ax=this.limitMotor.axis.x;
        this.ay=this.limitMotor.axis.y;
        this.az=this.limitMotor.axis.z;
        this.lowerLimit=this.limitMotor.lowerLimit;
        this.upperLimit=this.limitMotor.upperLimit;
        this.motorSpeed=this.limitMotor.motorSpeed;
        this.maxMotorForce=this.limitMotor.maxMotorForce;
        this.enableMotor=this.maxMotorForce>0;
        this.m1=this.b1.inverseMass;
        this.m2=this.b2.inverseMass;

        var ti1 = this.i1.elements;
        var ti2 = this.i2.elements;
        this.i1e00=ti1[0];
        this.i1e01=ti1[1];
        this.i1e02=ti1[2];
        this.i1e10=ti1[3];
        this.i1e11=ti1[4];
        this.i1e12=ti1[5];
        this.i1e20=ti1[6];
        this.i1e21=ti1[7];
        this.i1e22=ti1[8];

        this.i2e00=ti2[0];
        this.i2e01=ti2[1];
        this.i2e02=ti2[2];
        this.i2e10=ti2[3];
        this.i2e11=ti2[4];
        this.i2e12=ti2[5];
        this.i2e20=ti2[6];
        this.i2e21=ti2[7];
        this.i2e22=ti2[8];

        var dx=this.p2.x-this.p1.x;
        var dy=this.p2.y-this.p1.y;
        var dz=this.p2.z-this.p1.z;
        var d=dx*this.ax+dy*this.ay+dz*this.az;
        var frequency=this.limitMotor.frequency;
        var enableSpring=frequency>0;
        var enableLimit=this.lowerLimit<=this.upperLimit;
        if(enableSpring&&d>20||d<-20){
            enableSpring=false;
        }

        if(enableLimit){
            if(this.lowerLimit==this.upperLimit){
                if(this.limitState!=0){
                    this.limitState=0;
                    this.limitImpulse=0;
                }
                this.limitVelocity=this.lowerLimit-d;
                if(!enableSpring)d=this.lowerLimit;
            }else if(d<this.lowerLimit){
                if(this.limitState!=-1){
                    this.limitState=-1;
                    this.limitImpulse=0;
                }
                this.limitVelocity=this.lowerLimit-d;
                if(!enableSpring)d=this.lowerLimit;
            }else if(d>this.upperLimit){
                if(this.limitState!=1){
                    this.limitState=1;
                    this.limitImpulse=0;
                }
                this.limitVelocity=this.upperLimit-d;
                if(!enableSpring)d=this.upperLimit;
            }else{
                this.limitState=2;
                this.limitImpulse=0;
                this.limitVelocity=0;
            }
            if(!enableSpring){
                if(this.limitVelocity>0.005)this.limitVelocity-=0.005;
                else if(this.limitVelocity<-0.005)this.limitVelocity+=0.005;
                else this.limitVelocity=0;
            }
        }else{
            this.limitState=2;
            this.limitImpulse=0;
        }

        if(this.enableMotor&&(this.limitState!=0||enableSpring)){
            this.maxMotorImpulse=this.maxMotorForce*timeStep;
        }else{
            this.motorImpulse=0;
            this.maxMotorImpulse=0;
        }

        var rdx=d*this.ax;
        var rdy=d*this.ay;
        var rdz=d*this.az;
        var w1=this.m1/(this.m1+this.m2);
        var w2=1-w1;
        this.r1x=this.r1.x+rdx*w1;
        this.r1y=this.r1.y+rdy*w1;
        this.r1z=this.r1.z+rdz*w1;
        this.r2x=this.r2.x-rdx*w2;
        this.r2y=this.r2.y-rdy*w2;
        this.r2z=this.r2.z-rdz*w2;

        this.t1x=this.r1y*this.az-this.r1z*this.ay;
        this.t1y=this.r1z*this.ax-this.r1x*this.az;
        this.t1z=this.r1x*this.ay-this.r1y*this.ax;
        this.t2x=this.r2y*this.az-this.r2z*this.ay;
        this.t2y=this.r2z*this.ax-this.r2x*this.az;
        this.t2z=this.r2x*this.ay-this.r2y*this.ax;
        this.l1x=this.ax*this.m1;
        this.l1y=this.ay*this.m1;
        this.l1z=this.az*this.m1;
        this.l2x=this.ax*this.m2;
        this.l2y=this.ay*this.m2;
        this.l2z=this.az*this.m2;
        this.a1x=this.t1x*this.i1e00+this.t1y*this.i1e01+this.t1z*this.i1e02;
        this.a1y=this.t1x*this.i1e10+this.t1y*this.i1e11+this.t1z*this.i1e12;
        this.a1z=this.t1x*this.i1e20+this.t1y*this.i1e21+this.t1z*this.i1e22;
        this.a2x=this.t2x*this.i2e00+this.t2y*this.i2e01+this.t2z*this.i2e02;
        this.a2y=this.t2x*this.i2e10+this.t2y*this.i2e11+this.t2z*this.i2e12;
        this.a2z=this.t2x*this.i2e20+this.t2y*this.i2e21+this.t2z*this.i2e22;
        this.motorDenom=
        this.m1+this.m2+
            this.ax*(this.a1y*this.r1z-this.a1z*this.r1y+this.a2y*this.r2z-this.a2z*this.r2y)+
            this.ay*(this.a1z*this.r1x-this.a1x*this.r1z+this.a2z*this.r2x-this.a2x*this.r2z)+
            this.az*(this.a1x*this.r1y-this.a1y*this.r1x+this.a2x*this.r2y-this.a2y*this.r2x);

        this.invMotorDenom=1/this.motorDenom;

        if(enableSpring&&this.limitState!=2){
            var omega=6.2831853*frequency;
            var k=omega*omega*timeStep;
            var dmp=invTimeStep/(k+2*this.limitMotor.dampingRatio*omega);
            this.cfm=this.motorDenom*dmp;
            this.limitVelocity*=k*dmp;
        }else{
            this.cfm=0;
            this.limitVelocity*=invTimeStep*0.05;
        }

        this.invDenom=1/(this.motorDenom+this.cfm);

        var totalImpulse=this.limitImpulse+this.motorImpulse;
        this.l1.x+=totalImpulse*this.l1x;
        this.l1.y+=totalImpulse*this.l1y;
        this.l1.z+=totalImpulse*this.l1z;
        this.a1.x+=totalImpulse*this.a1x;
        this.a1.y+=totalImpulse*this.a1y;
        this.a1.z+=totalImpulse*this.a1z;
        this.l2.x-=totalImpulse*this.l2x;
        this.l2.y-=totalImpulse*this.l2y;
        this.l2.z-=totalImpulse*this.l2z;
        this.a2.x-=totalImpulse*this.a2x;
        this.a2.y-=totalImpulse*this.a2y;
        this.a2.z-=totalImpulse*this.a2z;
    },
    solve:function(){
        var rvn=
            this.ax*(this.l2.x-this.l1.x)+this.ay*(this.l2.y-this.l1.y)+this.az*(this.l2.z-this.l1.z)+
            this.t2x*this.a2.x-this.t1x*this.a1.x+this.t2y*this.a2.y-this.t1y*this.a1.y+this.t2z*this.a2.z-this.t1z*this.a1.z;

        // motor part
        var newMotorImpulse;
        if(this.enableMotor){
            newMotorImpulse=(rvn-this.motorSpeed)*this.invMotorDenom;
            var oldMotorImpulse=this.motorImpulse;
            this.motorImpulse+=newMotorImpulse;
            if(this.motorImpulse>this.maxMotorImpulse)this.motorImpulse=this.maxMotorImpulse;
            else if(this.motorImpulse<-this.maxMotorImpulse)this.motorImpulse=-this.maxMotorImpulse;
            newMotorImpulse=this.motorImpulse-oldMotorImpulse;
            rvn-=newMotorImpulse*this.motorDenom;
        }else newMotorImpulse=0;

        // limit part
        var newLimitImpulse;
        if(this.limitState!=2){
            newLimitImpulse=(rvn-this.limitVelocity-this.limitImpulse*this.cfm)*this.invDenom;
            var oldLimitImpulse=this.limitImpulse;
            this.limitImpulse+=newLimitImpulse;
            if(this.limitImpulse*this.limitState<0)this.limitImpulse=0;
            newLimitImpulse=this.limitImpulse-oldLimitImpulse;
        }else newLimitImpulse=0;
        
        var totalImpulse=newLimitImpulse+newMotorImpulse;
        this.l1.x+=totalImpulse*this.l1x;
        this.l1.y+=totalImpulse*this.l1y;
        this.l1.z+=totalImpulse*this.l1z;
        this.a1.x+=totalImpulse*this.a1x;
        this.a1.y+=totalImpulse*this.a1y;
        this.a1.z+=totalImpulse*this.a1z;
        this.l2.x-=totalImpulse*this.l2x;
        this.l2.y-=totalImpulse*this.l2y;
        this.l2.z-=totalImpulse*this.l2z;
        this.a2.x-=totalImpulse*this.a2x;
        this.a2.y-=totalImpulse*this.a2y;
        this.a2.z-=totalImpulse*this.a2z;
    }
} );

/**
 * A distance joint limits the distance between two anchor points on rigid bodies.
 *
 * @author saharan
 * @author lo-th
 */

function DistanceJoint ( config, minDistance, maxDistance ){

    Joint.call( this, config );

    this.type = JOINT_DISTANCE;
    
    this.nor = new Vec3();

    // The limit and motor information of the joint.
    this.limitMotor = new LimitMotor( this.nor, true );
    this.limitMotor.lowerLimit = minDistance;
    this.limitMotor.upperLimit = maxDistance;

    this.t = new TranslationalConstraint( this, this.limitMotor );

}

DistanceJoint.prototype = Object.assign( Object.create( Joint.prototype ), {

    constructor: DistanceJoint,

    preSolve: function ( timeStep, invTimeStep ) {

        this.updateAnchorPoints();

        this.nor.sub( this.anchorPoint2, this.anchorPoint1 ).normalize();

        // preSolve

        this.t.preSolve( timeStep, invTimeStep );

    },

    solve: function () {

        this.t.solve();

    },

    postSolve: function () {

    }

});

/**
* An angular constraint for all axes for various joints.
* @author saharan
*/

function AngularConstraint( joint, targetOrientation ) {

    this.joint = joint;

    this.targetOrientation = new Quat().invert( targetOrientation );

    this.relativeOrientation = new Quat();

    this.ii1 = null;
    this.ii2 = null;
    this.dd = null;

    this.vel = new Vec3();
    this.imp = new Vec3();

    this.rn0 = new Vec3();
    this.rn1 = new Vec3();
    this.rn2 = new Vec3();

    this.b1 = joint.body1;
    this.b2 = joint.body2;
    this.a1 = this.b1.angularVelocity;
    this.a2 = this.b2.angularVelocity;
    this.i1 = this.b1.inverseInertia;
    this.i2 = this.b2.inverseInertia;

}

Object.assign( AngularConstraint.prototype, {

    AngularConstraint: true,

    preSolve: function ( timeStep, invTimeStep ) {

        var inv, len, v;

        this.ii1 = this.i1.clone();
        this.ii2 = this.i2.clone();

        v = new Mat33().add(this.ii1, this.ii2).elements;
        inv = 1/( v[0]*(v[4]*v[8]-v[7]*v[5])  +  v[3]*(v[7]*v[2]-v[1]*v[8])  +  v[6]*(v[1]*v[5]-v[4]*v[2]) );
        this.dd = new Mat33().set(
            v[4]*v[8]-v[5]*v[7], v[2]*v[7]-v[1]*v[8], v[1]*v[5]-v[2]*v[4],
            v[5]*v[6]-v[3]*v[8], v[0]*v[8]-v[2]*v[6], v[2]*v[3]-v[0]*v[5],
            v[3]*v[7]-v[4]*v[6], v[1]*v[6]-v[0]*v[7], v[0]*v[4]-v[1]*v[3]
        ).multiplyScalar( inv );
        
        this.relativeOrientation.invert( this.b1.orientation ).multiply( this.targetOrientation ).multiply( this.b2.orientation );

        inv = this.relativeOrientation.w*2;

        this.vel.copy( this.relativeOrientation ).multiplyScalar( inv );

        len = this.vel.length();

        if( len > 0.02 ) {
            len = (0.02-len)/len*invTimeStep*0.05;
            this.vel.multiplyScalar( len );
        }else{
            this.vel.set(0,0,0);
        }

        this.rn1.copy( this.imp ).applyMatrix3( this.ii1, true );
        this.rn2.copy( this.imp ).applyMatrix3( this.ii2, true );

        this.a1.add( this.rn1 );
        this.a2.sub( this.rn2 );

    },

    solve: function () {

        var r = this.a2.clone().sub( this.a1 ).sub( this.vel );

        this.rn0.copy( r ).applyMatrix3( this.dd, true );
        this.rn1.copy( this.rn0 ).applyMatrix3( this.ii1, true );
        this.rn2.copy( this.rn0 ).applyMatrix3( this.ii2, true );

        this.imp.add( this.rn0 );
        this.a1.add( this.rn1 );
        this.a2.sub( this.rn2 );

    }

} );

/**
* A three-axis translational constraint for various joints.
* @author saharan
*/
function Translational3Constraint (joint,limitMotor1,limitMotor2,limitMotor3){

    this.m1=NaN;
    this.m2=NaN;
    this.i1e00=NaN;
    this.i1e01=NaN;
    this.i1e02=NaN;
    this.i1e10=NaN;
    this.i1e11=NaN;
    this.i1e12=NaN;
    this.i1e20=NaN;
    this.i1e21=NaN;
    this.i1e22=NaN;
    this.i2e00=NaN;
    this.i2e01=NaN;
    this.i2e02=NaN;
    this.i2e10=NaN;
    this.i2e11=NaN;
    this.i2e12=NaN;
    this.i2e20=NaN;
    this.i2e21=NaN;
    this.i2e22=NaN;
    this.ax1=NaN;
    this.ay1=NaN;
    this.az1=NaN;
    this.ax2=NaN;
    this.ay2=NaN;
    this.az2=NaN;
    this.ax3=NaN;
    this.ay3=NaN;
    this.az3=NaN;
    this.r1x=NaN;
    this.r1y=NaN;
    this.r1z=NaN;
    this.r2x=NaN;
    this.r2y=NaN;
    this.r2z=NaN;
    this.t1x1=NaN;// jacobians
    this.t1y1=NaN;
    this.t1z1=NaN;
    this.t2x1=NaN;
    this.t2y1=NaN;
    this.t2z1=NaN;
    this.l1x1=NaN;
    this.l1y1=NaN;
    this.l1z1=NaN;
    this.l2x1=NaN;
    this.l2y1=NaN;
    this.l2z1=NaN;
    this.a1x1=NaN;
    this.a1y1=NaN;
    this.a1z1=NaN;
    this.a2x1=NaN;
    this.a2y1=NaN;
    this.a2z1=NaN;
    this.t1x2=NaN;
    this.t1y2=NaN;
    this.t1z2=NaN;
    this.t2x2=NaN;
    this.t2y2=NaN;
    this.t2z2=NaN;
    this.l1x2=NaN;
    this.l1y2=NaN;
    this.l1z2=NaN;
    this.l2x2=NaN;
    this.l2y2=NaN;
    this.l2z2=NaN;
    this.a1x2=NaN;
    this.a1y2=NaN;
    this.a1z2=NaN;
    this.a2x2=NaN;
    this.a2y2=NaN;
    this.a2z2=NaN;
    this.t1x3=NaN;
    this.t1y3=NaN;
    this.t1z3=NaN;
    this.t2x3=NaN;
    this.t2y3=NaN;
    this.t2z3=NaN;
    this.l1x3=NaN;
    this.l1y3=NaN;
    this.l1z3=NaN;
    this.l2x3=NaN;
    this.l2y3=NaN;
    this.l2z3=NaN;
    this.a1x3=NaN;
    this.a1y3=NaN;
    this.a1z3=NaN;
    this.a2x3=NaN;
    this.a2y3=NaN;
    this.a2z3=NaN;
    this.lowerLimit1=NaN;
    this.upperLimit1=NaN;
    this.limitVelocity1=NaN;
    this.limitState1=0; // -1: at lower, 0: locked, 1: at upper, 2: unlimited
    this.enableMotor1=false;
    this.motorSpeed1=NaN;
    this.maxMotorForce1=NaN;
    this.maxMotorImpulse1=NaN;
    this.lowerLimit2=NaN;
    this.upperLimit2=NaN;
    this.limitVelocity2=NaN;
    this.limitState2=0; // -1: at lower, 0: locked, 1: at upper, 2: unlimited
    this.enableMotor2=false;
    this.motorSpeed2=NaN;
    this.maxMotorForce2=NaN;
    this.maxMotorImpulse2=NaN;
    this.lowerLimit3=NaN;
    this.upperLimit3=NaN;
    this.limitVelocity3=NaN;
    this.limitState3=0; // -1: at lower, 0: locked, 1: at upper, 2: unlimited
    this.enableMotor3=false;
    this.motorSpeed3=NaN;
    this.maxMotorForce3=NaN;
    this.maxMotorImpulse3=NaN;
    this.k00=NaN; // K = J*M*JT
    this.k01=NaN;
    this.k02=NaN;
    this.k10=NaN;
    this.k11=NaN;
    this.k12=NaN;
    this.k20=NaN;
    this.k21=NaN;
    this.k22=NaN;
    this.kv00=NaN; // diagonals without CFMs
    this.kv11=NaN;
    this.kv22=NaN;
    this.dv00=NaN; // ...inverted
    this.dv11=NaN;
    this.dv22=NaN;
    this.d00=NaN; // K^-1
    this.d01=NaN;
    this.d02=NaN;
    this.d10=NaN;
    this.d11=NaN;
    this.d12=NaN;
    this.d20=NaN;
    this.d21=NaN;
    this.d22=NaN;

    this.limitMotor1=limitMotor1;
    this.limitMotor2=limitMotor2;
    this.limitMotor3=limitMotor3;
    this.b1=joint.body1;
    this.b2=joint.body2;
    this.p1=joint.anchorPoint1;
    this.p2=joint.anchorPoint2;
    this.r1=joint.relativeAnchorPoint1;
    this.r2=joint.relativeAnchorPoint2;
    this.l1=this.b1.linearVelocity;
    this.l2=this.b2.linearVelocity;
    this.a1=this.b1.angularVelocity;
    this.a2=this.b2.angularVelocity;
    this.i1=this.b1.inverseInertia;
    this.i2=this.b2.inverseInertia;
    this.limitImpulse1=0;
    this.motorImpulse1=0;
    this.limitImpulse2=0;
    this.motorImpulse2=0;
    this.limitImpulse3=0;
    this.motorImpulse3=0;
    this.cfm1=0;// Constraint Force Mixing
    this.cfm2=0;
    this.cfm3=0;
    this.weight=-1;
}

Object.assign( Translational3Constraint.prototype, {

    Translational3Constraint: true,

    preSolve:function(timeStep,invTimeStep){
        this.ax1=this.limitMotor1.axis.x;
        this.ay1=this.limitMotor1.axis.y;
        this.az1=this.limitMotor1.axis.z;
        this.ax2=this.limitMotor2.axis.x;
        this.ay2=this.limitMotor2.axis.y;
        this.az2=this.limitMotor2.axis.z;
        this.ax3=this.limitMotor3.axis.x;
        this.ay3=this.limitMotor3.axis.y;
        this.az3=this.limitMotor3.axis.z;
        this.lowerLimit1=this.limitMotor1.lowerLimit;
        this.upperLimit1=this.limitMotor1.upperLimit;
        this.motorSpeed1=this.limitMotor1.motorSpeed;
        this.maxMotorForce1=this.limitMotor1.maxMotorForce;
        this.enableMotor1=this.maxMotorForce1>0;
        this.lowerLimit2=this.limitMotor2.lowerLimit;
        this.upperLimit2=this.limitMotor2.upperLimit;
        this.motorSpeed2=this.limitMotor2.motorSpeed;
        this.maxMotorForce2=this.limitMotor2.maxMotorForce;
        this.enableMotor2=this.maxMotorForce2>0;
        this.lowerLimit3=this.limitMotor3.lowerLimit;
        this.upperLimit3=this.limitMotor3.upperLimit;
        this.motorSpeed3=this.limitMotor3.motorSpeed;
        this.maxMotorForce3=this.limitMotor3.maxMotorForce;
        this.enableMotor3=this.maxMotorForce3>0;
        this.m1=this.b1.inverseMass;
        this.m2=this.b2.inverseMass;

        var ti1 = this.i1.elements;
        var ti2 = this.i2.elements;
        this.i1e00=ti1[0];
        this.i1e01=ti1[1];
        this.i1e02=ti1[2];
        this.i1e10=ti1[3];
        this.i1e11=ti1[4];
        this.i1e12=ti1[5];
        this.i1e20=ti1[6];
        this.i1e21=ti1[7];
        this.i1e22=ti1[8];

        this.i2e00=ti2[0];
        this.i2e01=ti2[1];
        this.i2e02=ti2[2];
        this.i2e10=ti2[3];
        this.i2e11=ti2[4];
        this.i2e12=ti2[5];
        this.i2e20=ti2[6];
        this.i2e21=ti2[7];
        this.i2e22=ti2[8];

        var dx=this.p2.x-this.p1.x;
        var dy=this.p2.y-this.p1.y;
        var dz=this.p2.z-this.p1.z;
        var d1=dx*this.ax1+dy*this.ay1+dz*this.az1;
        var d2=dx*this.ax2+dy*this.ay2+dz*this.az2;
        var d3=dx*this.ax3+dy*this.ay3+dz*this.az3;
        var frequency1=this.limitMotor1.frequency;
        var frequency2=this.limitMotor2.frequency;
        var frequency3=this.limitMotor3.frequency;
        var enableSpring1=frequency1>0;
        var enableSpring2=frequency2>0;
        var enableSpring3=frequency3>0;
        var enableLimit1=this.lowerLimit1<=this.upperLimit1;
        var enableLimit2=this.lowerLimit2<=this.upperLimit2;
        var enableLimit3=this.lowerLimit3<=this.upperLimit3;

        // for stability
        if(enableSpring1&&d1>20||d1<-20){
            enableSpring1=false;
        }
        if(enableSpring2&&d2>20||d2<-20){
            enableSpring2=false;
        }
        if(enableSpring3&&d3>20||d3<-20){
            enableSpring3=false;
        }

        if(enableLimit1){
            if(this.lowerLimit1==this.upperLimit1){
                if(this.limitState1!=0){
                    this.limitState1=0;
                    this.limitImpulse1=0;
                }
                this.limitVelocity1=this.lowerLimit1-d1;
                if(!enableSpring1)d1=this.lowerLimit1;
            }else if(d1<this.lowerLimit1){
                if(this.limitState1!=-1){
                    this.limitState1=-1;
                    this.limitImpulse1=0;
                }
                this.limitVelocity1=this.lowerLimit1-d1;
                if(!enableSpring1)d1=this.lowerLimit1;
            }else if(d1>this.upperLimit1){
                if(this.limitState1!=1){
                    this.limitState1=1;
                    this.limitImpulse1=0;
                }
                this.limitVelocity1=this.upperLimit1-d1;
                if(!enableSpring1)d1=this.upperLimit1;
            }else{
                this.limitState1=2;
                this.limitImpulse1=0;
                this.limitVelocity1=0;
            }
            if(!enableSpring1){
                if(this.limitVelocity1>0.005)this.limitVelocity1-=0.005;
                else if(this.limitVelocity1<-0.005)this.limitVelocity1+=0.005;
                else this.limitVelocity1=0;
            }
        }else{
            this.limitState1=2;
            this.limitImpulse1=0;
        }

        if(enableLimit2){
            if(this.lowerLimit2==this.upperLimit2){
                if(this.limitState2!=0){
                    this.limitState2=0;
                    this.limitImpulse2=0;
                }
                this.limitVelocity2=this.lowerLimit2-d2;
                if(!enableSpring2)d2=this.lowerLimit2;
            }else if(d2<this.lowerLimit2){
                if(this.limitState2!=-1){
                    this.limitState2=-1;
                    this.limitImpulse2=0;
                }
                this.limitVelocity2=this.lowerLimit2-d2;
                if(!enableSpring2)d2=this.lowerLimit2;
            }else if(d2>this.upperLimit2){
                if(this.limitState2!=1){
                    this.limitState2=1;
                    this.limitImpulse2=0;
                }
                this.limitVelocity2=this.upperLimit2-d2;
                if(!enableSpring2)d2=this.upperLimit2;
            }else{
                this.limitState2=2;
                this.limitImpulse2=0;
                this.limitVelocity2=0;
            }
            if(!enableSpring2){
                if(this.limitVelocity2>0.005)this.limitVelocity2-=0.005;
                else if(this.limitVelocity2<-0.005)this.limitVelocity2+=0.005;
                else this.limitVelocity2=0;
            }
        }else{
            this.limitState2=2;
            this.limitImpulse2=0;
        }

        if(enableLimit3){
            if(this.lowerLimit3==this.upperLimit3){
                if(this.limitState3!=0){
                    this.limitState3=0;
                    this.limitImpulse3=0;
                }
                this.limitVelocity3=this.lowerLimit3-d3;
                if(!enableSpring3)d3=this.lowerLimit3;
                }else if(d3<this.lowerLimit3){
                if(this.limitState3!=-1){
                    this.limitState3=-1;
                    this.limitImpulse3=0;
                }
                this.limitVelocity3=this.lowerLimit3-d3;
                if(!enableSpring3)d3=this.lowerLimit3;
            }else if(d3>this.upperLimit3){
                if(this.limitState3!=1){
                    this.limitState3=1;
                    this.limitImpulse3=0;
                }
                this.limitVelocity3=this.upperLimit3-d3;
                if(!enableSpring3)d3=this.upperLimit3;
            }else{
                this.limitState3=2;
                this.limitImpulse3=0;
                this.limitVelocity3=0;
            }
            if(!enableSpring3){
                if(this.limitVelocity3>0.005)this.limitVelocity3-=0.005;
                else if(this.limitVelocity3<-0.005)this.limitVelocity3+=0.005;
                else this.limitVelocity3=0;
            }
        }else{
            this.limitState3=2;
            this.limitImpulse3=0;
        }

        if(this.enableMotor1&&(this.limitState1!=0||enableSpring1)){
            this.maxMotorImpulse1=this.maxMotorForce1*timeStep;
        }else{
            this.motorImpulse1=0;
            this.maxMotorImpulse1=0;
        }

        if(this.enableMotor2&&(this.limitState2!=0||enableSpring2)){
            this.maxMotorImpulse2=this.maxMotorForce2*timeStep;
        }else{
            this.motorImpulse2=0;
            this.maxMotorImpulse2=0;
        }

        if(this.enableMotor3&&(this.limitState3!=0||enableSpring3)){
            this.maxMotorImpulse3=this.maxMotorForce3*timeStep;
        }else{
            this.motorImpulse3=0;
            this.maxMotorImpulse3=0;
        }
        
        var rdx=d1*this.ax1+d2*this.ax2+d3*this.ax2;
        var rdy=d1*this.ay1+d2*this.ay2+d3*this.ay2;
        var rdz=d1*this.az1+d2*this.az2+d3*this.az2;
        var w1=this.m2/(this.m1+this.m2);
        if(this.weight>=0)w1=this.weight; // use given weight
        var w2=1-w1;
        this.r1x=this.r1.x+rdx*w1;
        this.r1y=this.r1.y+rdy*w1;
        this.r1z=this.r1.z+rdz*w1;
        this.r2x=this.r2.x-rdx*w2;
        this.r2y=this.r2.y-rdy*w2;
        this.r2z=this.r2.z-rdz*w2;

        // build jacobians
        this.t1x1=this.r1y*this.az1-this.r1z*this.ay1;
        this.t1y1=this.r1z*this.ax1-this.r1x*this.az1;
        this.t1z1=this.r1x*this.ay1-this.r1y*this.ax1;
        this.t2x1=this.r2y*this.az1-this.r2z*this.ay1;
        this.t2y1=this.r2z*this.ax1-this.r2x*this.az1;
        this.t2z1=this.r2x*this.ay1-this.r2y*this.ax1;
        this.l1x1=this.ax1*this.m1;
        this.l1y1=this.ay1*this.m1;
        this.l1z1=this.az1*this.m1;
        this.l2x1=this.ax1*this.m2;
        this.l2y1=this.ay1*this.m2;
        this.l2z1=this.az1*this.m2;
        this.a1x1=this.t1x1*this.i1e00+this.t1y1*this.i1e01+this.t1z1*this.i1e02;
        this.a1y1=this.t1x1*this.i1e10+this.t1y1*this.i1e11+this.t1z1*this.i1e12;
        this.a1z1=this.t1x1*this.i1e20+this.t1y1*this.i1e21+this.t1z1*this.i1e22;
        this.a2x1=this.t2x1*this.i2e00+this.t2y1*this.i2e01+this.t2z1*this.i2e02;
        this.a2y1=this.t2x1*this.i2e10+this.t2y1*this.i2e11+this.t2z1*this.i2e12;
        this.a2z1=this.t2x1*this.i2e20+this.t2y1*this.i2e21+this.t2z1*this.i2e22;

        this.t1x2=this.r1y*this.az2-this.r1z*this.ay2;
        this.t1y2=this.r1z*this.ax2-this.r1x*this.az2;
        this.t1z2=this.r1x*this.ay2-this.r1y*this.ax2;
        this.t2x2=this.r2y*this.az2-this.r2z*this.ay2;
        this.t2y2=this.r2z*this.ax2-this.r2x*this.az2;
        this.t2z2=this.r2x*this.ay2-this.r2y*this.ax2;
        this.l1x2=this.ax2*this.m1;
        this.l1y2=this.ay2*this.m1;
        this.l1z2=this.az2*this.m1;
        this.l2x2=this.ax2*this.m2;
        this.l2y2=this.ay2*this.m2;
        this.l2z2=this.az2*this.m2;
        this.a1x2=this.t1x2*this.i1e00+this.t1y2*this.i1e01+this.t1z2*this.i1e02;
        this.a1y2=this.t1x2*this.i1e10+this.t1y2*this.i1e11+this.t1z2*this.i1e12;
        this.a1z2=this.t1x2*this.i1e20+this.t1y2*this.i1e21+this.t1z2*this.i1e22;
        this.a2x2=this.t2x2*this.i2e00+this.t2y2*this.i2e01+this.t2z2*this.i2e02;
        this.a2y2=this.t2x2*this.i2e10+this.t2y2*this.i2e11+this.t2z2*this.i2e12;
        this.a2z2=this.t2x2*this.i2e20+this.t2y2*this.i2e21+this.t2z2*this.i2e22;

        this.t1x3=this.r1y*this.az3-this.r1z*this.ay3;
        this.t1y3=this.r1z*this.ax3-this.r1x*this.az3;
        this.t1z3=this.r1x*this.ay3-this.r1y*this.ax3;
        this.t2x3=this.r2y*this.az3-this.r2z*this.ay3;
        this.t2y3=this.r2z*this.ax3-this.r2x*this.az3;
        this.t2z3=this.r2x*this.ay3-this.r2y*this.ax3;
        this.l1x3=this.ax3*this.m1;
        this.l1y3=this.ay3*this.m1;
        this.l1z3=this.az3*this.m1;
        this.l2x3=this.ax3*this.m2;
        this.l2y3=this.ay3*this.m2;
        this.l2z3=this.az3*this.m2;
        this.a1x3=this.t1x3*this.i1e00+this.t1y3*this.i1e01+this.t1z3*this.i1e02;
        this.a1y3=this.t1x3*this.i1e10+this.t1y3*this.i1e11+this.t1z3*this.i1e12;
        this.a1z3=this.t1x3*this.i1e20+this.t1y3*this.i1e21+this.t1z3*this.i1e22;
        this.a2x3=this.t2x3*this.i2e00+this.t2y3*this.i2e01+this.t2z3*this.i2e02;
        this.a2y3=this.t2x3*this.i2e10+this.t2y3*this.i2e11+this.t2z3*this.i2e12;
        this.a2z3=this.t2x3*this.i2e20+this.t2y3*this.i2e21+this.t2z3*this.i2e22;

        // build an impulse matrix
        var m12=this.m1+this.m2;
        this.k00=(this.ax1*this.ax1+this.ay1*this.ay1+this.az1*this.az1)*m12;
        this.k01=(this.ax1*this.ax2+this.ay1*this.ay2+this.az1*this.az2)*m12;
        this.k02=(this.ax1*this.ax3+this.ay1*this.ay3+this.az1*this.az3)*m12;
        this.k10=(this.ax2*this.ax1+this.ay2*this.ay1+this.az2*this.az1)*m12;
        this.k11=(this.ax2*this.ax2+this.ay2*this.ay2+this.az2*this.az2)*m12;
        this.k12=(this.ax2*this.ax3+this.ay2*this.ay3+this.az2*this.az3)*m12;
        this.k20=(this.ax3*this.ax1+this.ay3*this.ay1+this.az3*this.az1)*m12;
        this.k21=(this.ax3*this.ax2+this.ay3*this.ay2+this.az3*this.az2)*m12;
        this.k22=(this.ax3*this.ax3+this.ay3*this.ay3+this.az3*this.az3)*m12;

        this.k00+=this.t1x1*this.a1x1+this.t1y1*this.a1y1+this.t1z1*this.a1z1;
        this.k01+=this.t1x1*this.a1x2+this.t1y1*this.a1y2+this.t1z1*this.a1z2;
        this.k02+=this.t1x1*this.a1x3+this.t1y1*this.a1y3+this.t1z1*this.a1z3;
        this.k10+=this.t1x2*this.a1x1+this.t1y2*this.a1y1+this.t1z2*this.a1z1;
        this.k11+=this.t1x2*this.a1x2+this.t1y2*this.a1y2+this.t1z2*this.a1z2;
        this.k12+=this.t1x2*this.a1x3+this.t1y2*this.a1y3+this.t1z2*this.a1z3;
        this.k20+=this.t1x3*this.a1x1+this.t1y3*this.a1y1+this.t1z3*this.a1z1;
        this.k21+=this.t1x3*this.a1x2+this.t1y3*this.a1y2+this.t1z3*this.a1z2;
        this.k22+=this.t1x3*this.a1x3+this.t1y3*this.a1y3+this.t1z3*this.a1z3;

        this.k00+=this.t2x1*this.a2x1+this.t2y1*this.a2y1+this.t2z1*this.a2z1;
        this.k01+=this.t2x1*this.a2x2+this.t2y1*this.a2y2+this.t2z1*this.a2z2;
        this.k02+=this.t2x1*this.a2x3+this.t2y1*this.a2y3+this.t2z1*this.a2z3;
        this.k10+=this.t2x2*this.a2x1+this.t2y2*this.a2y1+this.t2z2*this.a2z1;
        this.k11+=this.t2x2*this.a2x2+this.t2y2*this.a2y2+this.t2z2*this.a2z2;
        this.k12+=this.t2x2*this.a2x3+this.t2y2*this.a2y3+this.t2z2*this.a2z3;
        this.k20+=this.t2x3*this.a2x1+this.t2y3*this.a2y1+this.t2z3*this.a2z1;
        this.k21+=this.t2x3*this.a2x2+this.t2y3*this.a2y2+this.t2z3*this.a2z2;
        this.k22+=this.t2x3*this.a2x3+this.t2y3*this.a2y3+this.t2z3*this.a2z3;

        this.kv00=this.k00;
        this.kv11=this.k11;
        this.kv22=this.k22;

        this.dv00=1/this.kv00;
        this.dv11=1/this.kv11;
        this.dv22=1/this.kv22;

        if(enableSpring1&&this.limitState1!=2){
            var omega=6.2831853*frequency1;
            var k=omega*omega*timeStep;
            var dmp=invTimeStep/(k+2*this.limitMotor1.dampingRatio*omega);
            this.cfm1=this.kv00*dmp;
            this.limitVelocity1*=k*dmp;
        }else{
            this.cfm1=0;
            this.limitVelocity1*=invTimeStep*0.05;
        }
        if(enableSpring2&&this.limitState2!=2){
            omega=6.2831853*frequency2;
            k=omega*omega*timeStep;
            dmp=invTimeStep/(k+2*this.limitMotor2.dampingRatio*omega);
            this.cfm2=this.kv11*dmp;
            this.limitVelocity2*=k*dmp;
        }else{
            this.cfm2=0;
            this.limitVelocity2*=invTimeStep*0.05;
        }
        if(enableSpring3&&this.limitState3!=2){
            omega=6.2831853*frequency3;
            k=omega*omega*timeStep;
            dmp=invTimeStep/(k+2*this.limitMotor3.dampingRatio*omega);
            this.cfm3=this.kv22*dmp;
            this.limitVelocity3*=k*dmp;
        }else{
            this.cfm3=0;
            this.limitVelocity3*=invTimeStep*0.05;
        }
        this.k00+=this.cfm1;
        this.k11+=this.cfm2;
        this.k22+=this.cfm3;

        var inv=1/(
        this.k00*(this.k11*this.k22-this.k21*this.k12)+
        this.k10*(this.k21*this.k02-this.k01*this.k22)+
        this.k20*(this.k01*this.k12-this.k11*this.k02)
        );
        this.d00=(this.k11*this.k22-this.k12*this.k21)*inv;
        this.d01=(this.k02*this.k21-this.k01*this.k22)*inv;
        this.d02=(this.k01*this.k12-this.k02*this.k11)*inv;
        this.d10=(this.k12*this.k20-this.k10*this.k22)*inv;
        this.d11=(this.k00*this.k22-this.k02*this.k20)*inv;
        this.d12=(this.k02*this.k10-this.k00*this.k12)*inv;
        this.d20=(this.k10*this.k21-this.k11*this.k20)*inv;
        this.d21=(this.k01*this.k20-this.k00*this.k21)*inv;
        this.d22=(this.k00*this.k11-this.k01*this.k10)*inv;

        // warm starting
        var totalImpulse1=this.limitImpulse1+this.motorImpulse1;
        var totalImpulse2=this.limitImpulse2+this.motorImpulse2;
        var totalImpulse3=this.limitImpulse3+this.motorImpulse3;
        this.l1.x+=totalImpulse1*this.l1x1+totalImpulse2*this.l1x2+totalImpulse3*this.l1x3;
        this.l1.y+=totalImpulse1*this.l1y1+totalImpulse2*this.l1y2+totalImpulse3*this.l1y3;
        this.l1.z+=totalImpulse1*this.l1z1+totalImpulse2*this.l1z2+totalImpulse3*this.l1z3;
        this.a1.x+=totalImpulse1*this.a1x1+totalImpulse2*this.a1x2+totalImpulse3*this.a1x3;
        this.a1.y+=totalImpulse1*this.a1y1+totalImpulse2*this.a1y2+totalImpulse3*this.a1y3;
        this.a1.z+=totalImpulse1*this.a1z1+totalImpulse2*this.a1z2+totalImpulse3*this.a1z3;
        this.l2.x-=totalImpulse1*this.l2x1+totalImpulse2*this.l2x2+totalImpulse3*this.l2x3;
        this.l2.y-=totalImpulse1*this.l2y1+totalImpulse2*this.l2y2+totalImpulse3*this.l2y3;
        this.l2.z-=totalImpulse1*this.l2z1+totalImpulse2*this.l2z2+totalImpulse3*this.l2z3;
        this.a2.x-=totalImpulse1*this.a2x1+totalImpulse2*this.a2x2+totalImpulse3*this.a2x3;
        this.a2.y-=totalImpulse1*this.a2y1+totalImpulse2*this.a2y2+totalImpulse3*this.a2y3;
        this.a2.z-=totalImpulse1*this.a2z1+totalImpulse2*this.a2z2+totalImpulse3*this.a2z3;
    },

    solve:function(){
        var rvx=this.l2.x-this.l1.x+this.a2.y*this.r2z-this.a2.z*this.r2y-this.a1.y*this.r1z+this.a1.z*this.r1y;
        var rvy=this.l2.y-this.l1.y+this.a2.z*this.r2x-this.a2.x*this.r2z-this.a1.z*this.r1x+this.a1.x*this.r1z;
        var rvz=this.l2.z-this.l1.z+this.a2.x*this.r2y-this.a2.y*this.r2x-this.a1.x*this.r1y+this.a1.y*this.r1x;
        var rvn1=rvx*this.ax1+rvy*this.ay1+rvz*this.az1;
        var rvn2=rvx*this.ax2+rvy*this.ay2+rvz*this.az2;
        var rvn3=rvx*this.ax3+rvy*this.ay3+rvz*this.az3;
        var oldMotorImpulse1=this.motorImpulse1;
        var oldMotorImpulse2=this.motorImpulse2;
        var oldMotorImpulse3=this.motorImpulse3;
        var dMotorImpulse1=0;
        var dMotorImpulse2=0;
        var dMotorImpulse3=0;
        if(this.enableMotor1){
            dMotorImpulse1=(rvn1-this.motorSpeed1)*this.dv00;
            this.motorImpulse1+=dMotorImpulse1;
            if(this.motorImpulse1>this.maxMotorImpulse1){ // clamp motor impulse
                this.motorImpulse1=this.maxMotorImpulse1;
            }else if(this.motorImpulse1<-this.maxMotorImpulse1){
                this.motorImpulse1=-this.maxMotorImpulse1;
            }
            dMotorImpulse1=this.motorImpulse1-oldMotorImpulse1;
        }
        if(this.enableMotor2){
            dMotorImpulse2=(rvn2-this.motorSpeed2)*this.dv11;
            this.motorImpulse2+=dMotorImpulse2;
            if(this.motorImpulse2>this.maxMotorImpulse2){ // clamp motor impulse
                this.motorImpulse2=this.maxMotorImpulse2;
            }else if(this.motorImpulse2<-this.maxMotorImpulse2){
                this.motorImpulse2=-this.maxMotorImpulse2;
            }
            dMotorImpulse2=this.motorImpulse2-oldMotorImpulse2;
        }
        if(this.enableMotor3){
            dMotorImpulse3=(rvn3-this.motorSpeed3)*this.dv22;
            this.motorImpulse3+=dMotorImpulse3;
            if(this.motorImpulse3>this.maxMotorImpulse3){ // clamp motor impulse
                this.motorImpulse3=this.maxMotorImpulse3;
            }else if(this.motorImpulse3<-this.maxMotorImpulse3){
                this.motorImpulse3=-this.maxMotorImpulse3;
            }
            dMotorImpulse3=this.motorImpulse3-oldMotorImpulse3;
        }

        // apply motor impulse to relative velocity
        rvn1+=dMotorImpulse1*this.kv00+dMotorImpulse2*this.k01+dMotorImpulse3*this.k02;
        rvn2+=dMotorImpulse1*this.k10+dMotorImpulse2*this.kv11+dMotorImpulse3*this.k12;
        rvn3+=dMotorImpulse1*this.k20+dMotorImpulse2*this.k21+dMotorImpulse3*this.kv22;

        // subtract target velocity and applied impulse
        rvn1-=this.limitVelocity1+this.limitImpulse1*this.cfm1;
        rvn2-=this.limitVelocity2+this.limitImpulse2*this.cfm2;
        rvn3-=this.limitVelocity3+this.limitImpulse3*this.cfm3;

        var oldLimitImpulse1=this.limitImpulse1;
        var oldLimitImpulse2=this.limitImpulse2;
        var oldLimitImpulse3=this.limitImpulse3;

        var dLimitImpulse1=rvn1*this.d00+rvn2*this.d01+rvn3*this.d02;
        var dLimitImpulse2=rvn1*this.d10+rvn2*this.d11+rvn3*this.d12;
        var dLimitImpulse3=rvn1*this.d20+rvn2*this.d21+rvn3*this.d22;

        this.limitImpulse1+=dLimitImpulse1;
        this.limitImpulse2+=dLimitImpulse2;
        this.limitImpulse3+=dLimitImpulse3;

        // clamp
        var clampState=0;
        if(this.limitState1==2||this.limitImpulse1*this.limitState1<0){
            dLimitImpulse1=-oldLimitImpulse1;
            rvn2+=dLimitImpulse1*this.k10;
            rvn3+=dLimitImpulse1*this.k20;
            clampState|=1;
        }
        if(this.limitState2==2||this.limitImpulse2*this.limitState2<0){
            dLimitImpulse2=-oldLimitImpulse2;
            rvn1+=dLimitImpulse2*this.k01;
            rvn3+=dLimitImpulse2*this.k21;
            clampState|=2;
        }
        if(this.limitState3==2||this.limitImpulse3*this.limitState3<0){
            dLimitImpulse3=-oldLimitImpulse3;
            rvn1+=dLimitImpulse3*this.k02;
            rvn2+=dLimitImpulse3*this.k12;
            clampState|=4;
        }

        // update un-clamped impulse
        // TODO: isolate division
        var det;
        switch(clampState){
            case 1:// update 2 3
            det=1/(this.k11*this.k22-this.k12*this.k21);
            dLimitImpulse2=(this.k22*rvn2+-this.k12*rvn3)*det;
            dLimitImpulse3=(-this.k21*rvn2+this.k11*rvn3)*det;
            break;
            case 2:// update 1 3
            det=1/(this.k00*this.k22-this.k02*this.k20);
            dLimitImpulse1=(this.k22*rvn1+-this.k02*rvn3)*det;
            dLimitImpulse3=(-this.k20*rvn1+this.k00*rvn3)*det;
            break;
            case 3:// update 3
            dLimitImpulse3=rvn3/this.k22;
            break;
            case 4:// update 1 2
            det=1/(this.k00*this.k11-this.k01*this.k10);
            dLimitImpulse1=(this.k11*rvn1+-this.k01*rvn2)*det;
            dLimitImpulse2=(-this.k10*rvn1+this.k00*rvn2)*det;
            break;
            case 5:// update 2
            dLimitImpulse2=rvn2/this.k11;
            break;
            case 6:// update 1
            dLimitImpulse1=rvn1/this.k00;
            break;
        }

        this.limitImpulse1=oldLimitImpulse1+dLimitImpulse1;
        this.limitImpulse2=oldLimitImpulse2+dLimitImpulse2;
        this.limitImpulse3=oldLimitImpulse3+dLimitImpulse3;

        var dImpulse1=dMotorImpulse1+dLimitImpulse1;
        var dImpulse2=dMotorImpulse2+dLimitImpulse2;
        var dImpulse3=dMotorImpulse3+dLimitImpulse3;

        // apply impulse
        this.l1.x+=dImpulse1*this.l1x1+dImpulse2*this.l1x2+dImpulse3*this.l1x3;
        this.l1.y+=dImpulse1*this.l1y1+dImpulse2*this.l1y2+dImpulse3*this.l1y3;
        this.l1.z+=dImpulse1*this.l1z1+dImpulse2*this.l1z2+dImpulse3*this.l1z3;
        this.a1.x+=dImpulse1*this.a1x1+dImpulse2*this.a1x2+dImpulse3*this.a1x3;
        this.a1.y+=dImpulse1*this.a1y1+dImpulse2*this.a1y2+dImpulse3*this.a1y3;
        this.a1.z+=dImpulse1*this.a1z1+dImpulse2*this.a1z2+dImpulse3*this.a1z3;
        this.l2.x-=dImpulse1*this.l2x1+dImpulse2*this.l2x2+dImpulse3*this.l2x3;
        this.l2.y-=dImpulse1*this.l2y1+dImpulse2*this.l2y2+dImpulse3*this.l2y3;
        this.l2.z-=dImpulse1*this.l2z1+dImpulse2*this.l2z2+dImpulse3*this.l2z3;
        this.a2.x-=dImpulse1*this.a2x1+dImpulse2*this.a2x2+dImpulse3*this.a2x3;
        this.a2.y-=dImpulse1*this.a2y1+dImpulse2*this.a2y2+dImpulse3*this.a2y3;
        this.a2.z-=dImpulse1*this.a2z1+dImpulse2*this.a2z2+dImpulse3*this.a2z3;
    }
    
} );

/**
 * A prismatic joint allows only for relative translation of rigid bodies along the axis.
 *
 * @author saharan
 * @author lo-th
 */

function PrismaticJoint( config, lowerTranslation, upperTranslation ){

    Joint.call( this, config );

    this.type = JOINT_PRISMATIC;

    // The axis in the first body's coordinate system.
    this.localAxis1 = config.localAxis1.clone().normalize();
    // The axis in the second body's coordinate system.
    this.localAxis2 = config.localAxis2.clone().normalize();

    this.ax1 = new Vec3();
    this.ax2 = new Vec3();
    
    this.nor = new Vec3();
    this.tan = new Vec3();
    this.bin = new Vec3();

    this.ac = new AngularConstraint( this, new Quat().setFromUnitVectors( this.localAxis1, this.localAxis2 ) );

    // The translational limit and motor information of the joint.
    this.limitMotor = new LimitMotor( this.nor, true );
    this.limitMotor.lowerLimit = lowerTranslation;
    this.limitMotor.upperLimit = upperTranslation;
    this.t3 = new Translational3Constraint( this, this.limitMotor, new LimitMotor( this.tan, true ), new LimitMotor( this.bin, true ) );

}

PrismaticJoint.prototype = Object.assign( Object.create( Joint.prototype ), {

    constructor: PrismaticJoint,

    preSolve: function ( timeStep, invTimeStep ) {

        this.updateAnchorPoints();

        this.ax1.copy( this.localAxis1 ).applyMatrix3( this.body1.rotation, true );
        this.ax2.copy( this.localAxis2 ).applyMatrix3( this.body2.rotation, true );

        // normal tangent binormal

        this.nor.set(
            this.ax1.x*this.body2.inverseMass + this.ax2.x*this.body1.inverseMass,
            this.ax1.y*this.body2.inverseMass + this.ax2.y*this.body1.inverseMass,
            this.ax1.z*this.body2.inverseMass + this.ax2.z*this.body1.inverseMass
        ).normalize();
        this.tan.tangent( this.nor ).normalize();
        this.bin.crossVectors( this.nor, this.tan );

        // preSolve

        this.ac.preSolve( timeStep, invTimeStep );
        this.t3.preSolve( timeStep, invTimeStep );

    },

    solve: function () {

        this.ac.solve();
        this.t3.solve();
        
    },

    postSolve: function () {

    }

});

/**
 * A slider joint allows for relative translation and relative rotation between two rigid bodies along the axis.
 *
 * @author saharan
 * @author lo-th
 */

function SliderJoint( config, lowerTranslation, upperTranslation ){

    Joint.call( this, config );

    this.type = JOINT_SLIDER;

    // The axis in the first body's coordinate system.
    this.localAxis1 = config.localAxis1.clone().normalize();
    // The axis in the second body's coordinate system.
    this.localAxis2 = config.localAxis2.clone().normalize();

    // make angle axis
    var arc = new Mat33().setQuat( new Quat().setFromUnitVectors( this.localAxis1, this.localAxis2 ) );
    this.localAngle1 = new Vec3().tangent( this.localAxis1 ).normalize();
    this.localAngle2 = this.localAngle1.clone().applyMatrix3( arc, true );

    this.ax1 = new Vec3();
    this.ax2 = new Vec3();
    this.an1 = new Vec3();
    this.an2 = new Vec3();

    this.tmp = new Vec3();
    
    this.nor = new Vec3();
    this.tan = new Vec3();
    this.bin = new Vec3();

    // The limit and motor for the rotation
    this.rotationalLimitMotor = new LimitMotor( this.nor, false );
    this.r3 = new Rotational3Constraint( this, this.rotationalLimitMotor, new LimitMotor( this.tan, true ), new LimitMotor( this.bin, true ) );

    // The limit and motor for the translation.
    this.translationalLimitMotor = new LimitMotor( this.nor, true );
    this.translationalLimitMotor.lowerLimit = lowerTranslation;
    this.translationalLimitMotor.upperLimit = upperTranslation;
    this.t3 = new Translational3Constraint( this, this.translationalLimitMotor, new LimitMotor( this.tan, true ), new LimitMotor( this.bin, true ) );

}

SliderJoint.prototype = Object.assign( Object.create( Joint.prototype ), {

    constructor: SliderJoint,

    preSolve: function ( timeStep, invTimeStep ) {

        this.updateAnchorPoints();

        this.ax1.copy( this.localAxis1 ).applyMatrix3( this.body1.rotation, true );
        this.an1.copy( this.localAngle1 ).applyMatrix3( this.body1.rotation, true );

        this.ax2.copy( this.localAxis2 ).applyMatrix3( this.body2.rotation, true );
        this.an2.copy( this.localAngle2 ).applyMatrix3( this.body2.rotation, true );

        // normal tangent binormal

        this.nor.set(
            this.ax1.x*this.body2.inverseMass + this.ax2.x*this.body1.inverseMass,
            this.ax1.y*this.body2.inverseMass + this.ax2.y*this.body1.inverseMass,
            this.ax1.z*this.body2.inverseMass + this.ax2.z*this.body1.inverseMass
        ).normalize();
        this.tan.tangent( this.nor ).normalize();
        this.bin.crossVectors( this.nor, this.tan );

        // calculate hinge angle

        this.tmp.crossVectors( this.an1, this.an2 );

        var limite = _Math.acosClamp( _Math.dotVectors( this.an1, this.an2 ) );

        if( _Math.dotVectors( this.nor, this.tmp ) < 0 ) this.rotationalLimitMotor.angle = -limite;
        else this.rotationalLimitMotor.angle = limite;

        // angular error

        this.tmp.crossVectors( this.ax1, this.ax2 );
        this.r3.limitMotor2.angle = _Math.dotVectors( this.tan, this.tmp );
        this.r3.limitMotor3.angle = _Math.dotVectors( this.bin, this.tmp );

        // preSolve
        
        this.r3.preSolve( timeStep, invTimeStep );
        this.t3.preSolve( timeStep, invTimeStep );

    },

    solve: function () {

        this.r3.solve();
        this.t3.solve();

    },

    postSolve: function () {

    }

});

/**
 * A wheel joint allows for relative rotation between two rigid bodies along two axes.
 * The wheel joint also allows for relative translation for the suspension.
 *
 * @author saharan
 * @author lo-th
 */

function WheelJoint ( config ){

    Joint.call( this, config );

    this.type = JOINT_WHEEL;

    // The axis in the first body's coordinate system.
    this.localAxis1 = config.localAxis1.clone().normalize();
    // The axis in the second body's coordinate system.
    this.localAxis2 = config.localAxis2.clone().normalize();

    this.localAngle1 = new Vec3();
    this.localAngle2 = new Vec3();

    var dot = _Math.dotVectors( this.localAxis1, this.localAxis2 );

    if( dot > -1 && dot < 1 ){

        this.localAngle1.set(
            this.localAxis2.x - dot*this.localAxis1.x,
            this.localAxis2.y - dot*this.localAxis1.y,
            this.localAxis2.z - dot*this.localAxis1.z
        ).normalize();

        this.localAngle2.set(
            this.localAxis1.x - dot*this.localAxis2.x,
            this.localAxis1.y - dot*this.localAxis2.y,
            this.localAxis1.z - dot*this.localAxis2.z
        ).normalize();

    } else {

        var arc = new Mat33().setQuat( new Quat().setFromUnitVectors( this.localAxis1, this.localAxis2 ) );
        this.localAngle1.tangent( this.localAxis1 ).normalize();
        this.localAngle2 = this.localAngle1.clone().applyMatrix3( arc, true );

    }

    this.ax1 = new Vec3();
    this.ax2 = new Vec3();
    this.an1 = new Vec3();
    this.an2 = new Vec3();

    this.tmp = new Vec3();

    this.nor = new Vec3();
    this.tan = new Vec3();
    this.bin = new Vec3();

    // The translational limit and motor information of the joint.
    this.translationalLimitMotor = new LimitMotor( this.tan,true );
    this.translationalLimitMotor.frequency = 8;
    this.translationalLimitMotor.dampingRatio = 1;
    // The first rotational limit and motor information of the joint.
    this.rotationalLimitMotor1 = new LimitMotor( this.tan, false );
    // The second rotational limit and motor information of the joint.
    this.rotationalLimitMotor2 = new LimitMotor( this.bin, false );

    this.t3 = new Translational3Constraint( this, new LimitMotor( this.nor, true ),this.translationalLimitMotor,new LimitMotor( this.bin, true ));
    this.t3.weight = 1;
    this.r3 = new Rotational3Constraint(this,new LimitMotor( this.nor, true ),this.rotationalLimitMotor1,this.rotationalLimitMotor2);

}

WheelJoint.prototype = Object.assign( Object.create( Joint.prototype ), {

    constructor: WheelJoint,

    preSolve: function ( timeStep, invTimeStep ) {

        this.updateAnchorPoints();

        this.ax1.copy( this.localAxis1 ).applyMatrix3( this.body1.rotation, true );
        this.an1.copy( this.localAngle1 ).applyMatrix3( this.body1.rotation, true );

        this.ax2.copy( this.localAxis2 ).applyMatrix3( this.body2.rotation, true );
        this.an2.copy( this.localAngle2 ).applyMatrix3( this.body2.rotation, true );

        this.r3.limitMotor1.angle = _Math.dotVectors( this.ax1, this.ax2 );

        var limite = _Math.dotVectors( this.an1, this.ax2 );

        if( _Math.dotVectors( this.ax1, this.tmp.crossVectors( this.an1, this.ax2 ) ) < 0 ) this.rotationalLimitMotor1.angle = -limite;
        else this.rotationalLimitMotor1.angle = limite;

        limite = _Math.dotVectors( this.an2, this.ax1 );

        if( _Math.dotVectors( this.ax2, this.tmp.crossVectors( this.an2, this.ax1 ) ) < 0 ) this.rotationalLimitMotor2.angle = -limite;
        else this.rotationalLimitMotor2.angle = limite;

        this.nor.crossVectors( this.ax1, this.ax2 ).normalize();
        this.tan.crossVectors( this.nor, this.ax2 ).normalize();
        this.bin.crossVectors( this.nor, this.ax1 ).normalize();
        
        this.r3.preSolve(timeStep,invTimeStep);
        this.t3.preSolve(timeStep,invTimeStep);

    },

    solve: function () {

        this.r3.solve();
        this.t3.solve();

    },

    postSolve: function () {

    }

});

function JointConfig(){

    this.scale = 1;
    this.invScale = 1;

    // The first rigid body of the joint.
    this.body1 = null;
    // The second rigid body of the joint.
    this.body2 = null;
    // The anchor point on the first rigid body in local coordinate system.
    this.localAnchorPoint1 = new Vec3();
    //  The anchor point on the second rigid body in local coordinate system.
    this.localAnchorPoint2 = new Vec3();
    // The axis in the first body's coordinate system.
    // his property is available in some joints.
    this.localAxis1 = new Vec3();
    // The axis in the second body's coordinate system.
    // This property is available in some joints.
    this.localAxis2 = new Vec3();
    //  Whether allow collision between connected rigid bodies or not.
    this.allowCollision = false;

}

/**
 * This class holds mass information of a shape.
 * @author lo-th
 * @author saharan
 */

function MassInfo (){

    // Mass of the shape.
    this.mass = 0;

    // The moment inertia of the shape.
    this.inertia = new Mat33();

}

/**
* A link list of contacts.
* @author saharan
*/
function ContactLink ( contact ){
    
	// The previous contact link.
    this.prev = null;
    // The next contact link.
    this.next = null;
    // The shape of the contact.
    this.shape = null;
    // The other rigid body.
    this.body = null;
    // The contact of the link.
    this.contact = contact;

}

function ImpulseDataBuffer (){

    this.lp1X = NaN;
    this.lp1Y = NaN;
    this.lp1Z = NaN;
    this.lp2X = NaN;
    this.lp2Y = NaN;
    this.lp2Z = NaN;
    this.impulse = NaN;

}

/**
* The class holds details of the contact point.
* @author saharan
*/

function ManifoldPoint(){

    // Whether this manifold point is persisting or not.
    this.warmStarted = false;
    //  The position of this manifold point.
    this.position = new Vec3();
    // The position in the first shape's coordinate.
    this.localPoint1 = new Vec3();
    //  The position in the second shape's coordinate.
    this.localPoint2 = new Vec3();
    // The normal vector of this manifold point.
    this.normal = new Vec3();
    // The tangent vector of this manifold point.
    this.tangent = new Vec3();
    // The binormal vector of this manifold point.
    this.binormal = new Vec3();
    // The impulse in normal direction.
    this.normalImpulse = 0;
    // The impulse in tangent direction.
    this.tangentImpulse = 0;
    // The impulse in binormal direction.
    this.binormalImpulse = 0;
    // The denominator in normal direction.
    this.normalDenominator = 0;
    // The denominator in tangent direction.
    this.tangentDenominator = 0;
    // The denominator in binormal direction.
    this.binormalDenominator = 0;
    // The depth of penetration.
    this.penetration = 0;

}

/**
* A contact manifold between two shapes.
* @author saharan
* @author lo-th
*/

function ContactManifold () {

    // The first rigid body.
    this.body1 = null;
    // The second rigid body.
    this.body2 = null;
    // The number of manifold points.
    this.numPoints = 0;
    // The manifold points.
    this.points = [
        new ManifoldPoint(),
        new ManifoldPoint(),
        new ManifoldPoint(),
        new ManifoldPoint()
    ];

}

ContactManifold.prototype = {

    constructor: ContactManifold,

    //Reset the manifold.
    reset:function( shape1, shape2 ){

        this.body1 = shape1.parent;
        this.body2 = shape2.parent;
        this.numPoints = 0;

    },

    //  Add a point into this manifold.
    addPointVec: function ( pos, norm, penetration, flip ) {
        
        var p = this.points[ this.numPoints++ ];

        p.position.copy( pos );
        p.localPoint1.sub( pos, this.body1.position ).applyMatrix3( this.body1.rotation );
        p.localPoint2.sub( pos, this.body2.position ).applyMatrix3( this.body2.rotation );

        p.normal.copy( norm );
        if( flip ) p.normal.negate();

        p.normalImpulse = 0;
        p.penetration = penetration;
        p.warmStarted = false;
        
    },

    //  Add a point into this manifold.
    addPoint: function ( x, y, z, nx, ny, nz, penetration, flip ) {
        
        var p = this.points[ this.numPoints++ ];

        p.position.set( x, y, z );
        p.localPoint1.sub( p.position, this.body1.position ).applyMatrix3( this.body1.rotation );
        p.localPoint2.sub( p.position, this.body2.position ).applyMatrix3( this.body2.rotation );

        p.normalImpulse = 0;

        p.normal.set( nx, ny, nz );
        if( flip ) p.normal.negate();

        p.penetration = penetration;
        p.warmStarted = false;
        
    }
};

function ContactPointDataBuffer (){

    this.nor = new Vec3();
    this.tan = new Vec3();
    this.bin = new Vec3();

    this.norU1 = new Vec3();
    this.tanU1 = new Vec3();
    this.binU1 = new Vec3();

    this.norU2 = new Vec3();
    this.tanU2 = new Vec3();
    this.binU2 = new Vec3();

    this.norT1 = new Vec3();
    this.tanT1 = new Vec3();
    this.binT1 = new Vec3();

    this.norT2 = new Vec3();
    this.tanT2 = new Vec3();
    this.binT2 = new Vec3();

    this.norTU1 = new Vec3();
    this.tanTU1 = new Vec3();
    this.binTU1 = new Vec3();

    this.norTU2 = new Vec3();
    this.tanTU2 = new Vec3();
    this.binTU2 = new Vec3();

    this.norImp = 0;
    this.tanImp = 0;
    this.binImp = 0;

    this.norDen = 0;
    this.tanDen = 0;
    this.binDen = 0;

    this.norTar = 0;

    this.next = null;
    this.last = false;

}

/**
* ...
* @author saharan
*/
function ContactConstraint ( manifold ){
    
    Constraint.call( this );
    // The contact manifold of the constraint.
    this.manifold = manifold;
    // The coefficient of restitution of the constraint.
    this.restitution=NaN;
    // The coefficient of friction of the constraint.
    this.friction=NaN;
    this.p1=null;
    this.p2=null;
    this.lv1=null;
    this.lv2=null;
    this.av1=null;
    this.av2=null;
    this.i1=null;
    this.i2=null;

    //this.ii1 = null;
    //this.ii2 = null;

    this.tmp = new Vec3();
    this.tmpC1 = new Vec3();
    this.tmpC2 = new Vec3();

    this.tmpP1 = new Vec3();
    this.tmpP2 = new Vec3();

    this.tmplv1 = new Vec3();
    this.tmplv2 = new Vec3();
    this.tmpav1 = new Vec3();
    this.tmpav2 = new Vec3();

    this.m1=NaN;
    this.m2=NaN;
    this.num=0;
    
    this.ps = manifold.points;
    this.cs = new ContactPointDataBuffer();
    this.cs.next = new ContactPointDataBuffer();
    this.cs.next.next = new ContactPointDataBuffer();
    this.cs.next.next.next = new ContactPointDataBuffer();
}

ContactConstraint.prototype = Object.assign( Object.create( Constraint.prototype ), {

    constructor: ContactConstraint,

    // Attach the constraint to the bodies.
    attach: function(){

        this.p1=this.body1.position;
        this.p2=this.body2.position;
        this.lv1=this.body1.linearVelocity;
        this.av1=this.body1.angularVelocity;
        this.lv2=this.body2.linearVelocity;
        this.av2=this.body2.angularVelocity;
        this.i1=this.body1.inverseInertia;
        this.i2=this.body2.inverseInertia;

    },

    // Detach the constraint from the bodies.
    detach: function(){

        this.p1=null;
        this.p2=null;
        this.lv1=null;
        this.lv2=null;
        this.av1=null;
        this.av2=null;
        this.i1=null;
        this.i2=null;

    },

    preSolve: function( timeStep, invTimeStep ){

        this.m1 = this.body1.inverseMass;
        this.m2 = this.body2.inverseMass;

        var m1m2 = this.m1 + this.m2;

        this.num = this.manifold.numPoints;

        var c = this.cs;
        var p, rvn, len, norImp, norTar, sepV, i1, i2;

        for( var i=0; i < this.num; i++ ){

            p = this.ps[i];

            this.tmpP1.sub( p.position, this.p1 );
            this.tmpP2.sub( p.position, this.p2 );

            this.tmpC1.crossVectors( this.av1, this.tmpP1 );
            this.tmpC2.crossVectors( this.av2, this.tmpP2 );

            c.norImp = p.normalImpulse;
            c.tanImp = p.tangentImpulse;
            c.binImp = p.binormalImpulse;

            c.nor.copy( p.normal );

            this.tmp.set(

                ( this.lv2.x + this.tmpC2.x ) - ( this.lv1.x + this.tmpC1.x ),
                ( this.lv2.y + this.tmpC2.y ) - ( this.lv1.y + this.tmpC1.y ),
                ( this.lv2.z + this.tmpC2.z ) - ( this.lv1.z + this.tmpC1.z )

            );

            rvn = _Math.dotVectors( c.nor, this.tmp );

            c.tan.set(
                this.tmp.x - rvn * c.nor.x,
                this.tmp.y - rvn * c.nor.y,
                this.tmp.z - rvn * c.nor.z
            );

            len = _Math.dotVectors( c.tan, c.tan );

            if( len <= 0.04 ) {
                c.tan.tangent( c.nor );
            }

            c.tan.normalize();

            c.bin.crossVectors( c.nor, c.tan );

            c.norU1.scale( c.nor, this.m1 );
            c.norU2.scale( c.nor, this.m2 );

            c.tanU1.scale( c.tan, this.m1 );
            c.tanU2.scale( c.tan, this.m2 );

            c.binU1.scale( c.bin, this.m1 );
            c.binU2.scale( c.bin, this.m2 );

            c.norT1.crossVectors( this.tmpP1, c.nor );
            c.tanT1.crossVectors( this.tmpP1, c.tan );
            c.binT1.crossVectors( this.tmpP1, c.bin );

            c.norT2.crossVectors( this.tmpP2, c.nor );
            c.tanT2.crossVectors( this.tmpP2, c.tan );
            c.binT2.crossVectors( this.tmpP2, c.bin );

            i1 = this.i1;
            i2 = this.i2;

            c.norTU1.copy( c.norT1 ).applyMatrix3( i1, true );
            c.tanTU1.copy( c.tanT1 ).applyMatrix3( i1, true );
            c.binTU1.copy( c.binT1 ).applyMatrix3( i1, true );

            c.norTU2.copy( c.norT2 ).applyMatrix3( i2, true );
            c.tanTU2.copy( c.tanT2 ).applyMatrix3( i2, true );
            c.binTU2.copy( c.binT2 ).applyMatrix3( i2, true );

            /*c.norTU1.mulMat( this.i1, c.norT1 );
            c.tanTU1.mulMat( this.i1, c.tanT1 );
            c.binTU1.mulMat( this.i1, c.binT1 );

            c.norTU2.mulMat( this.i2, c.norT2 );
            c.tanTU2.mulMat( this.i2, c.tanT2 );
            c.binTU2.mulMat( this.i2, c.binT2 );*/

            this.tmpC1.crossVectors( c.norTU1, this.tmpP1 );
            this.tmpC2.crossVectors( c.norTU2, this.tmpP2 );
            this.tmp.add( this.tmpC1, this.tmpC2 );
            c.norDen = 1 / ( m1m2 +_Math.dotVectors( c.nor, this.tmp ));

            this.tmpC1.crossVectors( c.tanTU1, this.tmpP1 );
            this.tmpC2.crossVectors( c.tanTU2, this.tmpP2 );
            this.tmp.add( this.tmpC1, this.tmpC2 );
            c.tanDen = 1 / ( m1m2 +_Math.dotVectors( c.tan, this.tmp ));

            this.tmpC1.crossVectors( c.binTU1, this.tmpP1 );
            this.tmpC2.crossVectors( c.binTU2, this.tmpP2 );
            this.tmp.add( this.tmpC1, this.tmpC2 );
            c.binDen = 1 / ( m1m2 +_Math.dotVectors( c.bin, this.tmp ));

            if( p.warmStarted ){

                norImp = p.normalImpulse;

                this.lv1.addScaledVector( c.norU1, norImp );
                this.av1.addScaledVector( c.norTU1, norImp );

                this.lv2.subScaledVector( c.norU2, norImp );
                this.av2.subScaledVector( c.norTU2, norImp );

                c.norImp = norImp;
                c.tanImp = 0;
                c.binImp = 0;
                rvn = 0; // disable bouncing

            } else {

                c.norImp=0;
                c.tanImp=0;
                c.binImp=0;

            }


            if(rvn>-1) rvn=0; // disable bouncing
            
            norTar = this.restitution*-rvn;
            sepV = -(p.penetration+0.005)*invTimeStep*0.05; // allow 0.5cm error
            if(norTar<sepV) norTar=sepV;
            c.norTar = norTar;
            c.last = i==this.num-1;
            c = c.next;
        }
    },

    solve: function(){

        this.tmplv1.copy( this.lv1 );
        this.tmplv2.copy( this.lv2 );
        this.tmpav1.copy( this.av1 );
        this.tmpav2.copy( this.av2 );

        var oldImp1, newImp1, oldImp2, newImp2, rvn, norImp, tanImp, binImp, max, len;

        var c = this.cs;

        while(true){

            norImp = c.norImp;
            tanImp = c.tanImp;
            binImp = c.binImp;
            max = -norImp * this.friction;

            this.tmp.sub( this.tmplv2, this.tmplv1 );

            rvn = _Math.dotVectors( this.tmp, c.tan ) + _Math.dotVectors( this.tmpav2, c.tanT2 ) - _Math.dotVectors( this.tmpav1, c.tanT1 );
        
            oldImp1 = tanImp;
            newImp1 = rvn*c.tanDen;
            tanImp += newImp1;

            rvn = _Math.dotVectors( this.tmp, c.bin ) + _Math.dotVectors( this.tmpav2, c.binT2 ) - _Math.dotVectors( this.tmpav1, c.binT1 );
      
            oldImp2 = binImp;
            newImp2 = rvn*c.binDen;
            binImp += newImp2;

            // cone friction clamp
            len = tanImp*tanImp + binImp*binImp;
            if(len > max * max ){
                len = max/_Math.sqrt(len);
                tanImp *= len;
                binImp *= len;
            }

            newImp1 = tanImp-oldImp1;
            newImp2 = binImp-oldImp2;

            //

            this.tmp.set( 
                c.tanU1.x*newImp1 + c.binU1.x*newImp2,
                c.tanU1.y*newImp1 + c.binU1.y*newImp2,
                c.tanU1.z*newImp1 + c.binU1.z*newImp2
            );

            this.tmplv1.addEqual( this.tmp );

            this.tmp.set(
                c.tanTU1.x*newImp1 + c.binTU1.x*newImp2,
                c.tanTU1.y*newImp1 + c.binTU1.y*newImp2,
                c.tanTU1.z*newImp1 + c.binTU1.z*newImp2
            );

            this.tmpav1.addEqual( this.tmp );

            this.tmp.set(
                c.tanU2.x*newImp1 + c.binU2.x*newImp2,
                c.tanU2.y*newImp1 + c.binU2.y*newImp2,
                c.tanU2.z*newImp1 + c.binU2.z*newImp2
            );

            this.tmplv2.subEqual( this.tmp );

            this.tmp.set(
                c.tanTU2.x*newImp1 + c.binTU2.x*newImp2,
                c.tanTU2.y*newImp1 + c.binTU2.y*newImp2,
                c.tanTU2.z*newImp1 + c.binTU2.z*newImp2
            );

            this.tmpav2.subEqual( this.tmp );

            // restitution part

            this.tmp.sub( this.tmplv2, this.tmplv1 );

            rvn = _Math.dotVectors( this.tmp, c.nor ) + _Math.dotVectors( this.tmpav2, c.norT2 ) - _Math.dotVectors( this.tmpav1, c.norT1 );

            oldImp1 = norImp;
            newImp1 = (rvn-c.norTar)*c.norDen;
            norImp += newImp1;
            if( norImp > 0 ) norImp = 0;

            newImp1 = norImp - oldImp1;

            this.tmplv1.addScaledVector( c.norU1, newImp1 );
            this.tmpav1.addScaledVector( c.norTU1, newImp1 );
            this.tmplv2.subScaledVector( c.norU2, newImp1 );
            this.tmpav2.subScaledVector( c.norTU2, newImp1 );

            c.norImp = norImp;
            c.tanImp = tanImp;
            c.binImp = binImp;

            if(c.last)break;
            c = c.next;
        }

        this.lv1.copy( this.tmplv1 );
        this.lv2.copy( this.tmplv2 );
        this.av1.copy( this.tmpav1 );
        this.av2.copy( this.tmpav2 );

    },

    postSolve: function(){

        var c = this.cs, p;
        var i = this.num;
        while(i--){
        //for(var i=0;i<this.num;i++){
            p = this.ps[i];
            p.normal.copy( c.nor );
            p.tangent.copy( c.tan );
            p.binormal.copy( c.bin );

            p.normalImpulse = c.norImp;
            p.tangentImpulse = c.tanImp;
            p.binormalImpulse = c.binImp;
            p.normalDenominator = c.norDen;
            p.tangentDenominator = c.tanDen;
            p.binormalDenominator = c.binDen;
            c=c.next;
        }
    }

});

/**
* A contact is a pair of shapes whose axis-aligned bounding boxes are overlapping.
* @author saharan
*/

function Contact(){

    // The first shape.
    this.shape1 = null;
    // The second shape.
    this.shape2 = null;
    // The first rigid body.
    this.body1 = null;
    // The second rigid body.
    this.body2 = null;
    // The previous contact in the world.
    this.prev = null;
    // The next contact in the world.
    this.next = null;
    // Internal
    this.persisting = false;
    // Whether both the rigid bodies are sleeping or not.
    this.sleeping = false;
    // The collision detector between two shapes.
    this.detector = null;
    // The contact constraint of the contact.
    this.constraint = null;
    // Whether the shapes are touching or not.
    this.touching = false;
    // shapes is very close and touching 
    this.close = false;

    this.dist = _Math.INF;

    this.b1Link = new ContactLink( this );
    this.b2Link = new ContactLink( this );
    this.s1Link = new ContactLink( this );
    this.s2Link = new ContactLink( this );

    // The contact manifold of the contact.
    this.manifold = new ContactManifold();

    this.buffer = [

        new ImpulseDataBuffer(),
        new ImpulseDataBuffer(),
        new ImpulseDataBuffer(),
        new ImpulseDataBuffer()

    ];

    this.points = this.manifold.points;
    this.constraint = new ContactConstraint( this.manifold );
    
}

Object.assign( Contact.prototype, {

    Contact: true,

    mixRestitution: function ( restitution1, restitution2 ) {

        return _Math.sqrt(restitution1*restitution2);

    },
    mixFriction: function ( friction1, friction2 ) {

        return _Math.sqrt(friction1*friction2);

    },

    /**
    * Update the contact manifold.
    */
    updateManifold: function () {

        this.constraint.restitution =this.mixRestitution(this.shape1.restitution,this.shape2.restitution);
        this.constraint.friction=this.mixFriction(this.shape1.friction,this.shape2.friction);
        var numBuffers=this.manifold.numPoints;
        var i = numBuffers;
        while(i--){
        //for(var i=0;i<numBuffers;i++){
            var b = this.buffer[i];
            var p = this.points[i];
            b.lp1X=p.localPoint1.x;
            b.lp1Y=p.localPoint1.y;
            b.lp1Z=p.localPoint1.z;
            b.lp2X=p.localPoint2.x;
            b.lp2Y=p.localPoint2.y;
            b.lp2Z=p.localPoint2.z;
            b.impulse=p.normalImpulse;
        }
        this.manifold.numPoints=0;
        this.detector.detectCollision(this.shape1,this.shape2,this.manifold);
        var num=this.manifold.numPoints;
        if(num==0){
            this.touching = false;
            this.close = false;
            this.dist = _Math.INF;
            return;
        }

        if( this.touching || this.dist < 0.001 ) this.close = true;
        this.touching=true;
        i = num;
        while(i--){
        //for(i=0; i<num; i++){
            p=this.points[i];
            var lp1x=p.localPoint1.x;
            var lp1y=p.localPoint1.y;
            var lp1z=p.localPoint1.z;
            var lp2x=p.localPoint2.x;
            var lp2y=p.localPoint2.y;
            var lp2z=p.localPoint2.z;
            var index=-1;
            var minDistance=0.0004;
            var j = numBuffers;
            while(j--){
            //for(var j=0;j<numBuffers;j++){
                b=this.buffer[j];
                var dx=b.lp1X-lp1x;
                var dy=b.lp1Y-lp1y;
                var dz=b.lp1Z-lp1z;
                var distance1=dx*dx+dy*dy+dz*dz;
                dx=b.lp2X-lp2x;
                dy=b.lp2Y-lp2y;
                dz=b.lp2Z-lp2z;
                var distance2=dx*dx+dy*dy+dz*dz;
                if(distance1<distance2){
                    if(distance1<minDistance){
                        minDistance=distance1;
                        index=j;
                    }
                }else{
                    if(distance2<minDistance){
                        minDistance=distance2;
                        index=j;
                    }
                }

                if( minDistance < this.dist ) this.dist = minDistance;

            }
            if(index!=-1){
                var tmp=this.buffer[index];
                this.buffer[index]=this.buffer[--numBuffers];
                this.buffer[numBuffers]=tmp;
                p.normalImpulse=tmp.impulse;
                p.warmStarted=true;
            }else{
                p.normalImpulse=0;
                p.warmStarted=false;
            }
        }
    },
    /**
    * Attach the contact to the shapes.
    * @param   shape1
    * @param   shape2
    */
    attach:function(shape1,shape2){
        this.shape1=shape1;
        this.shape2=shape2;
        this.body1=shape1.parent;
        this.body2=shape2.parent;

        this.manifold.body1=this.body1;
        this.manifold.body2=this.body2;
        this.constraint.body1=this.body1;
        this.constraint.body2=this.body2;
        this.constraint.attach();

        this.s1Link.shape=shape2;
        this.s1Link.body=this.body2;
        this.s2Link.shape=shape1;
        this.s2Link.body=this.body1;

        if(shape1.contactLink!=null)(this.s1Link.next=shape1.contactLink).prev=this.s1Link;
        else this.s1Link.next=null;
        shape1.contactLink=this.s1Link;
        shape1.numContacts++;

        if(shape2.contactLink!=null)(this.s2Link.next=shape2.contactLink).prev=this.s2Link;
        else this.s2Link.next=null;
        shape2.contactLink=this.s2Link;
        shape2.numContacts++;

        this.b1Link.shape=shape2;
        this.b1Link.body=this.body2;
        this.b2Link.shape=shape1;
        this.b2Link.body=this.body1;

        if(this.body1.contactLink!=null)(this.b1Link.next=this.body1.contactLink).prev=this.b1Link;
        else this.b1Link.next=null;
        this.body1.contactLink=this.b1Link;
        this.body1.numContacts++;

        if(this.body2.contactLink!=null)(this.b2Link.next=this.body2.contactLink).prev=this.b2Link;
        else this.b2Link.next=null;
        this.body2.contactLink=this.b2Link;
        this.body2.numContacts++;

        this.prev=null;
        this.next=null;

        this.persisting=true;
        this.sleeping=this.body1.sleeping&&this.body2.sleeping;
        this.manifold.numPoints=0;
    },
    /**
    * Detach the contact from the shapes.
    */
    detach:function(){
        var prev=this.s1Link.prev;
        var next=this.s1Link.next;
        if(prev!==null)prev.next=next;
        if(next!==null)next.prev=prev;
        if(this.shape1.contactLink==this.s1Link)this.shape1.contactLink=next;
        this.s1Link.prev=null;
        this.s1Link.next=null;
        this.s1Link.shape=null;
        this.s1Link.body=null;
        this.shape1.numContacts--;

        prev=this.s2Link.prev;
        next=this.s2Link.next;
        if(prev!==null)prev.next=next;
        if(next!==null)next.prev=prev;
        if(this.shape2.contactLink==this.s2Link)this.shape2.contactLink=next;
        this.s2Link.prev=null;
        this.s2Link.next=null;
        this.s2Link.shape=null;
        this.s2Link.body=null;
        this.shape2.numContacts--;

        prev=this.b1Link.prev;
        next=this.b1Link.next;
        if(prev!==null)prev.next=next;
        if(next!==null)next.prev=prev;
        if(this.body1.contactLink==this.b1Link)this.body1.contactLink=next;
        this.b1Link.prev=null;
        this.b1Link.next=null;
        this.b1Link.shape=null;
        this.b1Link.body=null;
        this.body1.numContacts--;

        prev=this.b2Link.prev;
        next=this.b2Link.next;
        if(prev!==null)prev.next=next;
        if(next!==null)next.prev=prev;
        if(this.body2.contactLink==this.b2Link)this.body2.contactLink=next;
        this.b2Link.prev=null;
        this.b2Link.next=null;
        this.b2Link.shape=null;
        this.b2Link.body=null;
        this.body2.numContacts--;

        this.manifold.body1=null;
        this.manifold.body2=null;
        this.constraint.body1=null;
        this.constraint.body2=null;
        this.constraint.detach();

        this.shape1=null;
        this.shape2=null;
        this.body1=null;
        this.body2=null;
    }

} );

/**
* The class of rigid body.
* Rigid body has the shape of a single or multiple collision processing,
* I can set the parameters individually.
* @author saharan
* @author lo-th
*/

function RigidBody ( Position, Rotation ) {

    this.position = Position || new Vec3();
    this.orientation = Rotation || new Quat();

    this.scale = 1;
    this.invScale = 1;

    // possible link to three Mesh;
    this.mesh = null;

    this.id = NaN;
    this.name = "";
    // The maximum number of shapes that can be added to a one rigid.
    //this.MAX_SHAPES = 64;//64;

    this.prev = null;
    this.next = null;

    // I represent the kind of rigid body.
    // Please do not change from the outside this variable.
    // If you want to change the type of rigid body, always
    // Please specify the type you want to set the arguments of setupMass method.
    this.type = BODY_NULL;

    this.massInfo = new MassInfo();

    this.newPosition = new Vec3();
    this.controlPos = false;
    this.newOrientation = new Quat();
    this.newRotation = new Vec3();
    this.currentRotation = new Vec3();
    this.controlRot = false;
    this.controlRotInTime = false;

    this.quaternion = new Quat();
    this.pos = new Vec3();



    // Is the translational velocity.
    this.linearVelocity = new Vec3();
    // Is the angular velocity.
    this.angularVelocity = new Vec3();

    //--------------------------------------------
    //  Please do not change from the outside this variables.
    //--------------------------------------------

    // It is a world that rigid body has been added.
    this.parent = null;
    this.contactLink = null;
    this.numContacts = 0;

    // An array of shapes that are included in the rigid body.
    this.shapes = null;
    // The number of shapes that are included in the rigid body.
    this.numShapes = 0;

    // It is the link array of joint that is connected to the rigid body.
    this.jointLink = null;
    // The number of joints that are connected to the rigid body.
    this.numJoints = 0;

    // It is the world coordinate of the center of gravity in the sleep just before.
    this.sleepPosition = new Vec3();
    // It is a quaternion that represents the attitude of sleep just before.
    this.sleepOrientation = new Quat();
    // I will show this rigid body to determine whether it is a rigid body static.
    this.isStatic = false;
    // I indicates that this rigid body to determine whether it is a rigid body dynamic.
    this.isDynamic = false;

    this.isKinematic = false;

    // It is a rotation matrix representing the orientation.
    this.rotation = new Mat33();

    //--------------------------------------------
    // It will be recalculated automatically from the shape, which is included.
    //--------------------------------------------

    // This is the weight.
    this.mass = 0;
    // It is the reciprocal of the mass.
    this.inverseMass = 0;
    // It is the inverse of the inertia tensor in the world system.
    this.inverseInertia = new Mat33();
    // It is the inertia tensor in the initial state.
    this.localInertia = new Mat33();
    // It is the inverse of the inertia tensor in the initial state.
    this.inverseLocalInertia = new Mat33();

    this.tmpInertia = new Mat33();


    // I indicates rigid body whether it has been added to the simulation Island.
    this.addedToIsland = false;
    // It shows how to sleep rigid body.
    this.allowSleep = true;
    // This is the time from when the rigid body at rest.
    this.sleepTime = 0;
    // I shows rigid body to determine whether it is a sleep state.
    this.sleeping = false;

}

Object.assign( RigidBody.prototype, {

    setParent: function ( world ) {

        this.parent = world;
        this.scale = this.parent.scale;
        this.invScale = this.parent.invScale;
        this.id = this.parent.numRigidBodies;
        if( !this.name ) this.name = this.id;

        this.updateMesh();

    },

    /**
     * I'll add a shape to rigid body.
     * If you add a shape, please call the setupMass method to step up to the start of the next.
     * @param   shape shape to Add
     */
    addShape:function(shape){

        if(shape.parent){
			printError("RigidBody", "It is not possible that you add a shape which already has an associated body.");
		}

        if(this.shapes!=null)( this.shapes.prev = shape ).next = this.shapes;
        this.shapes = shape;
        shape.parent = this;
        if(this.parent) this.parent.addShape( shape );
        this.numShapes++;

    },
    /**
     * I will delete the shape from the rigid body.
     * If you delete a shape, please call the setupMass method to step up to the start of the next.
     * @param shape {Shape} to delete
     * @return void
     */
    removeShape:function(shape){

        var remove = shape;
        if(remove.parent!=this)return;
        var prev=remove.prev;
        var next=remove.next;
        if(prev!=null) prev.next=next;
        if(next!=null) next.prev=prev;
        if(this.shapes==remove)this.shapes=next;
        remove.prev=null;
        remove.next=null;
        remove.parent=null;
        if(this.parent)this.parent.removeShape(remove);
        this.numShapes--;

    },

    remove: function () {

        this.dispose();

    },

    dispose: function () {

        this.parent.removeRigidBody( this );

    },

    checkContact: function( name ) {

        this.parent.checkContact( this.name, name );

    },

    /**
     * Calulates mass datas(center of gravity, mass, moment inertia, etc...).
     * If the parameter type is set to BODY_STATIC, the rigid body will be fixed to the space.
     * If the parameter adjustPosition is set to true, the shapes' relative positions and
     * the rigid body's position will be adjusted to the center of gravity.
     * @param type
     * @param adjustPosition
     * @return void
     */
    setupMass: function ( type, AdjustPosition ) {

        var adjustPosition = ( AdjustPosition !== undefined ) ? AdjustPosition : true;

        this.type = type || BODY_STATIC;
        this.isDynamic = this.type === BODY_DYNAMIC;
        this.isStatic = this.type === BODY_STATIC;

        this.mass = 0;
        this.localInertia.set(0,0,0,0,0,0,0,0,0);


        var tmpM = new Mat33();
        var tmpV = new Vec3();

        for( var shape = this.shapes; shape !== null; shape = shape.next ){

            shape.calculateMassInfo( this.massInfo );
            var shapeMass = this.massInfo.mass;
            tmpV.addScaledVector(shape.relativePosition, shapeMass);
            this.mass += shapeMass;
            this.rotateInertia( shape.relativeRotation, this.massInfo.inertia, tmpM );
            this.localInertia.add( tmpM );

            // add offset inertia
            this.localInertia.addOffset( shapeMass, shape.relativePosition );

        }

        this.inverseMass = 1 / this.mass;
        tmpV.scaleEqual( this.inverseMass );

        if( adjustPosition ){
            this.position.add( tmpV );
            for( shape=this.shapes; shape !== null; shape = shape.next ){
                shape.relativePosition.subEqual(tmpV);
            }

            // subtract offset inertia
            this.localInertia.subOffset( this.mass, tmpV );

        }

        this.inverseLocalInertia.invert( this.localInertia );

        //}

        if( this.type === BODY_STATIC ){
            this.inverseMass = 0;
            this.inverseLocalInertia.set(0,0,0,0,0,0,0,0,0);
        }

        this.syncShapes();
        this.awake();

    },
    /**
     * Awake the rigid body.
     */
    awake:function(){

        if( !this.allowSleep || !this.sleeping ) return;
        this.sleeping = false;
        this.sleepTime = 0;
        // awake connected constraints
        var cs = this.contactLink;
        while(cs != null){
            cs.body.sleepTime = 0;
            cs.body.sleeping = false;
            cs = cs.next;
        }
        var js = this.jointLink;
        while(js != null){
            js.body.sleepTime = 0;
            js.body.sleeping = false;
            js = js.next;
        }
        for(var shape = this.shapes; shape!=null; shape = shape.next){
            shape.updateProxy();
        }

    },
    /**
     * Sleep the rigid body.
     */
    sleep:function(){

        if( !this.allowSleep || this.sleeping ) return;

        this.linearVelocity.set(0,0,0);
        this.angularVelocity.set(0,0,0);
        this.sleepPosition.copy( this.position );
        this.sleepOrientation.copy( this.orientation );

        this.sleepTime = 0;
        this.sleeping = true;
        for( var shape = this.shapes; shape != null; shape = shape.next ) {
            shape.updateProxy();
        }
    },

    testWakeUp: function(){

        if( this.linearVelocity.testZero() || this.angularVelocity.testZero() || this.position.testDiff( this.sleepPosition ) || this.orientation.testDiff( this.sleepOrientation )) this.awake(); // awake the body

    },

    /**
     * Get whether the rigid body has not any connection with others.
     * @return {void}
     */
    isLonely: function () {
        return this.numJoints==0 && this.numContacts==0;
    },

    /**
     * The time integration of the motion of a rigid body, you can update the information such as the shape.
     * This method is invoked automatically when calling the step of the World,
     * There is no need to call from outside usually.
     * @param  timeStep time
     * @return {void}
     */

    updatePosition: function ( timeStep ) {
        switch(this.type){
            case BODY_STATIC:
                this.linearVelocity.set(0,0,0);
                this.angularVelocity.set(0,0,0);

                // ONLY FOR TEST
                if(this.controlPos){
                    this.position.copy(this.newPosition);
                    this.controlPos = false;
                }
                if(this.controlRot){
                    this.orientation.copy(this.newOrientation);
                    this.controlRot = false;
                }
                /*this.linearVelocity.x=0;
                this.linearVelocity.y=0;
                this.linearVelocity.z=0;
                this.angularVelocity.x=0;
                this.angularVelocity.y=0;
                this.angularVelocity.z=0;*/
            break;
            case BODY_DYNAMIC:

                if( this.isKinematic ){

                    this.linearVelocity.set(0,0,0);
                    this.angularVelocity.set(0,0,0);

                }

                if(this.controlPos){

                    this.linearVelocity.subVectors( this.newPosition, this.position ).multiplyScalar(1/timeStep);
                    this.controlPos = false;

                }
                if(this.controlRot){

                    this.angularVelocity.copy( this.getAxis() );
                    this.orientation.copy( this.newOrientation );
                    this.controlRot = false;

                }

                this.position.addScaledVector(this.linearVelocity, timeStep);
                this.orientation.addTime(this.angularVelocity, timeStep);

                this.updateMesh();

            break;
            default: printError("RigidBody", "Invalid type.");
        }

        this.syncShapes();
        this.updateMesh();

    },

    getAxis: function () {

        return new Vec3( 0,1,0 ).applyMatrix3( this.inverseLocalInertia, true ).normalize();

    },

    rotateInertia: function ( rot, inertia, out ) {

        this.tmpInertia.multiplyMatrices( rot, inertia );
        out.multiplyMatrices( this.tmpInertia, rot, true );

    },

    syncShapes: function () {

        this.rotation.setQuat( this.orientation );
        this.rotateInertia( this.rotation, this.inverseLocalInertia, this.inverseInertia );
        
        for(var shape = this.shapes; shape!=null; shape = shape.next){

            shape.position.copy( shape.relativePosition ).applyMatrix3( this.rotation, true ).add( this.position );
            // add by QuaziKb
            shape.rotation.multiplyMatrices( this.rotation, shape.relativeRotation );
            shape.updateProxy();
        }
    },


    //---------------------------------------------
    // APPLY IMPULSE FORCE
    //---------------------------------------------

    applyImpulse: function(position, force){
        this.linearVelocity.addScaledVector(force, this.inverseMass);
        var rel = new Vec3().copy( position ).sub( this.position ).cross( force ).applyMatrix3( this.inverseInertia, true );
        this.angularVelocity.add( rel );
    },


    //---------------------------------------------
    // SET DYNAMIQUE POSITION AND ROTATION
    //---------------------------------------------

    setPosition: function(pos){
        this.newPosition.copy( pos ).multiplyScalar( this.invScale );
        this.controlPos = true;
        if( !this.isKinematic ) this.isKinematic = true;
    },

    setQuaternion: function(q){
        this.newOrientation.set(q.x, q.y, q.z, q.w);
        this.controlRot = true;
        if( !this.isKinematic ) this.isKinematic = true;
    },

    setRotation: function ( rot ) {

        this.newOrientation = new Quat().setFromEuler( rot.x * _Math.degtorad, rot.y * _Math.degtorad, rot.y * _Math.degtorad );//this.rotationVectToQuad( rot );
        this.controlRot = true;

    },

    //---------------------------------------------
    // RESET DYNAMIQUE POSITION AND ROTATION
    //---------------------------------------------

    resetPosition:function(x,y,z){

        this.linearVelocity.set( 0, 0, 0 );
        this.angularVelocity.set( 0, 0, 0 );
        this.position.set( x, y, z ).multiplyScalar( this.invScale );
        //this.position.set( x*OIMO.WorldScale.invScale, y*OIMO.WorldScale.invScale, z*OIMO.WorldScale.invScale );
        this.awake();
    },

    resetQuaternion:function( q ){

        this.angularVelocity.set(0,0,0);
        this.orientation = new Quat( q.x, q.y, q.z, q.w );
        this.awake();

    },

    resetRotation:function(x,y,z){

        this.angularVelocity.set(0,0,0);
        this.orientation = new Quat().setFromEuler( x * _Math.degtorad, y * _Math.degtorad,  z * _Math.degtorad );//this.rotationVectToQuad( new Vec3(x,y,z) );
        this.awake();

    },

    //---------------------------------------------
    // GET POSITION AND ROTATION
    //---------------------------------------------

    getPosition:function () {

        return this.pos;

    },

    getQuaternion: function () {

        return this.quaternion;

    },

    //---------------------------------------------
    // AUTO UPDATE THREE MESH
    //---------------------------------------------

    connectMesh: function ( mesh ) {

        this.mesh = mesh;
        this.updateMesh();

    },

    updateMesh: function(){

        this.pos.scale( this.position, this.scale );
        this.quaternion.copy( this.orientation );

        if( this.mesh === null ) return;

        this.mesh.position.copy( this.getPosition() );
        this.mesh.quaternion.copy( this.getQuaternion() );

    },

} );

/**
* A pair of shapes that may collide.
* @author saharan
*/
function Pair ( s1, s2 ){

    // The first shape.
    this.shape1 = s1 || null;
    // The second shape.
    this.shape2 = s2 || null;

}

/**
* The broad-phase is used for collecting all possible pairs for collision.
*/

 function BroadPhase(){

    this.types = BR_NULL;
    this.numPairChecks = 0;
    this.numPairs = 0;
    this.pairs = [];

}

Object.assign( BroadPhase.prototype, {

    BroadPhase: true,

    // Create a new proxy.
    createProxy: function ( shape ) {

        printError("BroadPhase","Inheritance error.");

    },

    // Add the proxy into the broad-phase.
    addProxy: function ( proxy ) {

        printError("BroadPhase","Inheritance error.");
    },

    // Remove the proxy from the broad-phase.
    removeProxy: function ( proxy ) {

        printError("BroadPhase","Inheritance error.");

    },

    // Returns whether the pair is available or not.
    isAvailablePair: function ( s1, s2 ) {

        var b1 = s1.parent;
        var b2 = s2.parent;
        if( b1 == b2 || // same parents
            (!b1.isDynamic && !b2.isDynamic) || // static or kinematic object
            (s1.belongsTo&s2.collidesWith)==0 ||
            (s2.belongsTo&s1.collidesWith)==0 // collision filtering
        ){ return false; }
        var js;
        if(b1.numJoints<b2.numJoints) js = b1.jointLink;
        else js = b2.jointLink;
        while(js!==null){
           var joint = js.joint;
           if( !joint.allowCollision && ((joint.body1==b1 && joint.body2==b2) || (joint.body1==b2 && joint.body2==b1)) ){ return false; }
           js = js.next;
        }

        return true;

    },

    // Detect overlapping pairs.
    detectPairs: function () {

        // clear old
        this.pairs = [];
        this.numPairs = 0;
        this.numPairChecks = 0;
        this.collectPairs();

    },

    collectPairs: function () {

        Error("BroadPhase", "Inheritance error.");

    },

    addPair: function ( s1, s2 ) {

        var pair = new Pair( s1, s2 );
        this.pairs.push(pair);
        this.numPairs++;

    }

});

var count$1 = 0;
function ProxyIdCount() { return count$1++; }

/**
 * A proxy is used for broad-phase collecting pairs that can be colliding.
 *
 * @author lo-th
 */

function Proxy( shape ) {

	//The parent shape.
    this.shape = shape;

    //The axis-aligned bounding box.
    this.aabb = shape.aabb;

}

Object.assign( Proxy.prototype, {

    Proxy: true,

	// Update the proxy. Must be inherited by a child.

    update: function(){

        printError("Proxy","Inheritance error.");

    }

});

/**
* A basic implementation of proxies.
*
* @author saharan
*/

function BasicProxy ( shape ) {

    Proxy.call( this, shape );

    this.id = ProxyIdCount();

}

BasicProxy.prototype = Object.assign( Object.create( Proxy.prototype ), {

    constructor: BasicProxy,

    update: function () {

    }

});

/**
* A broad-phase algorithm with brute-force search.
* This always checks for all possible pairs.
*/

function BruteForceBroadPhase(){

    BroadPhase.call( this );
    this.types = BR_BRUTE_FORCE;
    //this.numProxies=0;
    ///this.maxProxies = 256;
    this.proxies = [];
    //this.proxies.length = 256;

}


BruteForceBroadPhase.prototype = Object.assign( Object.create( BroadPhase.prototype ), {

    constructor: BruteForceBroadPhase,

    createProxy: function ( shape ) {

        return new BasicProxy( shape );

    },

    addProxy: function ( proxy ) {

        /*if(this.numProxies==this.maxProxies){
            //this.maxProxies<<=1;
            this.maxProxies*=2;
            var newProxies=[];
            newProxies.length = this.maxProxies;
            var i = this.numProxies;
            while(i--){
            //for(var i=0, l=this.numProxies;i<l;i++){
                newProxies[i]=this.proxies[i];
            }
            this.proxies=newProxies;
        }*/
        //this.proxies[this.numProxies++] = proxy;
        this.proxies.push( proxy );
        //this.numProxies++;

    },

    removeProxy: function ( proxy ) {

        var n = this.proxies.indexOf( proxy );
        if ( n > -1 ){
            this.proxies.splice( n, 1 );
            //this.numProxies--;
        }

        /*var i = this.numProxies;
        while(i--){
        //for(var i=0, l=this.numProxies;i<l;i++){
            if(this.proxies[i] == proxy){
                this.proxies[i] = this.proxies[--this.numProxies];
                this.proxies[this.numProxies] = null;
                return;
            }
        }*/

    },

    collectPairs: function () {

        var i = 0, j, p1, p2;

        var px = this.proxies;
        var l = px.length;//this.numProxies;
        //var ar1 = [];
        //var ar2 = [];

        //for( i = px.length ; i-- ; ar1[ i ] = px[ i ] ){};
        //for( i = px.length ; i-- ; ar2[ i ] = px[ i ] ){};

        //var ar1 = JSON.parse(JSON.stringify(this.proxies))
        //var ar2 = JSON.parse(JSON.stringify(this.proxies))

        this.numPairChecks = l*(l-1)>>1;
        //this.numPairChecks=this.numProxies*(this.numProxies-1)*0.5;

        while( i < l ){
            p1 = px[i++];
            j = i + 1;
            while( j < l ){
                p2 = px[j++];
                if ( p1.aabb.intersectTest( p2.aabb ) || !this.isAvailablePair( p1.shape, p2.shape ) ) continue;
                this.addPair( p1.shape, p2.shape );
            }
        }

    }

});

/**
 * A projection axis for sweep and prune broad-phase.
 * @author saharan
 */

function SAPAxis (){

    this.numElements = 0;
    this.bufferSize = 256;
    this.elements = [];
    this.elements.length = this.bufferSize;
    this.stack = new Float32Array( 64 );

}

Object.assign( SAPAxis.prototype, {

    SAPAxis: true,

    addElements: function ( min, max ) {

        if(this.numElements+2>=this.bufferSize){
            //this.bufferSize<<=1;
            this.bufferSize*=2;
            var newElements=[];
            var i = this.numElements;
            while(i--){
            //for(var i=0, l=this.numElements; i<l; i++){
                newElements[i] = this.elements[i];
            }
        }
        this.elements[this.numElements++] = min;
        this.elements[this.numElements++] = max;

    },

    removeElements: function ( min, max ) {

        var minIndex=-1;
        var maxIndex=-1;
        for(var i=0, l=this.numElements; i<l; i++){
            var e=this.elements[i];
            if(e==min||e==max){
                if(minIndex==-1){
                    minIndex=i;
                }else{
                    maxIndex=i;
                break;
                }
            }
        }
        for(i = minIndex+1, l = maxIndex; i < l; i++){
            this.elements[i-1] = this.elements[i];
        }
        for(i = maxIndex+1, l = this.numElements; i < l; i++){
            this.elements[i-2] = this.elements[i];
        }

        this.elements[--this.numElements] = null;
        this.elements[--this.numElements] = null;

    },

    sort: function () {

        var count = 0;
        var threshold = 1;
        while((this.numElements >> threshold) != 0 ) threshold++;
        threshold = threshold * this.numElements >> 2;
        count = 0;

        var giveup = false;
        var elements = this.elements;
        for( var i = 1, l = this.numElements; i < l; i++){ // try insertion sort
            var tmp=elements[i];
            var pivot=tmp.value;
            var tmp2=elements[i-1];
            if(tmp2.value>pivot){
                var j=i;
                do{
                    elements[j]=tmp2;
                    if(--j==0)break;
                    tmp2=elements[j-1];
                }while(tmp2.value>pivot);
                elements[j]=tmp;
                count+=i-j;
                if(count>threshold){
                    giveup=true; // stop and use quick sort
                    break;
                }
            }
        }
        if(!giveup)return;
        count=2;var stack=this.stack;
        stack[0]=0;
        stack[1]=this.numElements-1;
        while(count>0){
            var right=stack[--count];
            var left=stack[--count];
            var diff=right-left;
            if(diff>16){  // quick sort
                //var mid=left+(diff>>1);
                var mid = left + (_Math.floor(diff*0.5));
                tmp = elements[mid];
                elements[mid] = elements[right];
                elements[right] = tmp;
                pivot = tmp.value;
                i = left-1;
                j = right;
                while( true ){
                    var ei;
                    var ej;
                    do{ ei = elements[++i]; } while( ei.value < pivot);
                    do{ ej = elements[--j]; } while( pivot < ej.value && j != left );
                    if( i >= j ) break;
                    elements[i] = ej;
                    elements[j] = ei;
                }

                elements[right] = elements[i];
                elements[i] = tmp;
                if( i - left > right - i ) {
                    stack[count++] = left;
                    stack[count++] = i - 1;
                    stack[count++] = i + 1;
                    stack[count++] = right;
                }else{
                    stack[count++] = i + 1;
                    stack[count++] = right;
                    stack[count++] = left;
                    stack[count++] = i - 1;
                }
            }else{
                for( i = left + 1; i <= right; i++ ) {
                    tmp = elements[i];
                    pivot = tmp.value;
                    tmp2 = elements[i-1];
                    if( tmp2.value > pivot ) {
                        j = i;
                        do{
                            elements[j] = tmp2;
                            if( --j == 0 ) break;
                            tmp2 = elements[j-1];
                        }while( tmp2.value > pivot );
                        elements[j] = tmp;
                    }
                }
            }
        }
        
    },

    calculateTestCount: function () {

        var num = 1;
        var sum = 0;
        for(var i = 1, l = this.numElements; i<l; i++){
            if(this.elements[i].max){
                num--;
            }else{
                sum += num;
                num++;
            }
        }
        return sum;

    }

});

/**
 * An element of proxies.
 * @author saharan
 */

function SAPElement ( proxy, max ) {

    // The parent proxy
    this.proxy = proxy;
	// The pair element.
    this.pair = null;
    // The minimum element on other axis.
    this.min1 = null;
    // The maximum element on other axis.
    this.max1 = null;
    // The minimum element on other axis.
    this.min2 = null;
    // The maximum element on other axis.
    this.max2 = null;
    // Whether the element has maximum value or not.
    this.max = max;
    // The value of the element.
    this.value = 0;

}

/**
 * A proxy for sweep and prune broad-phase.
 * @author saharan
 * @author lo-th
 */

function SAPProxy ( sap, shape ){

    Proxy.call( this, shape );
    // Type of the axis to which the proxy belongs to. [0:none, 1:dynamic, 2:static]
    this.belongsTo = 0;
    // The maximum elements on each axis.
    this.max = [];
    // The minimum elements on each axis.
    this.min = [];
    
    this.sap = sap;
    this.min[0] = new SAPElement( this, false );
    this.max[0] = new SAPElement( this, true );
    this.min[1] = new SAPElement( this, false );
    this.max[1] = new SAPElement( this, true );
    this.min[2] = new SAPElement( this, false );
    this.max[2] = new SAPElement( this, true );
    this.max[0].pair = this.min[0];
    this.max[1].pair = this.min[1];
    this.max[2].pair = this.min[2];
    this.min[0].min1 = this.min[1];
    this.min[0].max1 = this.max[1];
    this.min[0].min2 = this.min[2];
    this.min[0].max2 = this.max[2];
    this.min[1].min1 = this.min[0];
    this.min[1].max1 = this.max[0];
    this.min[1].min2 = this.min[2];
    this.min[1].max2 = this.max[2];
    this.min[2].min1 = this.min[0];
    this.min[2].max1 = this.max[0];
    this.min[2].min2 = this.min[1];
    this.min[2].max2 = this.max[1];

}

SAPProxy.prototype = Object.assign( Object.create( Proxy.prototype ), {

    constructor: SAPProxy,


    // Returns whether the proxy is dynamic or not.
    isDynamic: function () {

        var body = this.shape.parent;
        return body.isDynamic && !body.sleeping;

    },

    update: function () {

        var te = this.aabb.elements;
        this.min[0].value = te[0];
        this.min[1].value = te[1];
        this.min[2].value = te[2];
        this.max[0].value = te[3];
        this.max[1].value = te[4];
        this.max[2].value = te[5];

        if( this.belongsTo == 1 && !this.isDynamic() || this.belongsTo == 2 && this.isDynamic() ){
            this.sap.removeProxy(this);
            this.sap.addProxy(this);
        }

    }

});

/**
 * A broad-phase collision detection algorithm using sweep and prune.
 * @author saharan
 * @author lo-th
 */

function SAPBroadPhase () {

    BroadPhase.call( this);
    this.types = BR_SWEEP_AND_PRUNE;

    this.numElementsD = 0;
    this.numElementsS = 0;
    // dynamic proxies
    this.axesD = [
       new SAPAxis(),
       new SAPAxis(),
       new SAPAxis()
    ];
    // static or sleeping proxies
    this.axesS = [
       new SAPAxis(),
       new SAPAxis(),
       new SAPAxis()
    ];

    this.index1 = 0;
    this.index2 = 1;

}

SAPBroadPhase.prototype = Object.assign( Object.create( BroadPhase.prototype ), {

    constructor: SAPBroadPhase,

    createProxy: function ( shape ) {

        return new SAPProxy( this, shape );

    },

    addProxy: function ( proxy ) {

        var p = proxy;
        if(p.isDynamic()){
            this.axesD[0].addElements( p.min[0], p.max[0] );
            this.axesD[1].addElements( p.min[1], p.max[1] );
            this.axesD[2].addElements( p.min[2], p.max[2] );
            p.belongsTo = 1;
            this.numElementsD += 2;
        } else {
            this.axesS[0].addElements( p.min[0], p.max[0] );
            this.axesS[1].addElements( p.min[1], p.max[1] );
            this.axesS[2].addElements( p.min[2], p.max[2] );
            p.belongsTo = 2;
            this.numElementsS += 2;
        }

    },

    removeProxy: function ( proxy ) {

        var p = proxy;
        if ( p.belongsTo == 0 ) return;

        /*else if ( p.belongsTo == 1 ) {
            this.axesD[0].removeElements( p.min[0], p.max[0] );
            this.axesD[1].removeElements( p.min[1], p.max[1] );
            this.axesD[2].removeElements( p.min[2], p.max[2] );
            this.numElementsD -= 2;
        } else if ( p.belongsTo == 2 ) {
            this.axesS[0].removeElements( p.min[0], p.max[0] );
            this.axesS[1].removeElements( p.min[1], p.max[1] );
            this.axesS[2].removeElements( p.min[2], p.max[2] );
            this.numElementsS -= 2;
        }*/

        switch( p.belongsTo ){
            case 1:
            this.axesD[0].removeElements( p.min[0], p.max[0] );
            this.axesD[1].removeElements( p.min[1], p.max[1] );
            this.axesD[2].removeElements( p.min[2], p.max[2] );
            this.numElementsD -= 2;
            break;
            case 2:
            this.axesS[0].removeElements( p.min[0], p.max[0] );
            this.axesS[1].removeElements( p.min[1], p.max[1] );
            this.axesS[2].removeElements( p.min[2], p.max[2] );
            this.numElementsS -= 2;
            break;
        }

        p.belongsTo = 0;

    },

    collectPairs: function () {

        if( this.numElementsD == 0 ) return;

        var axis1 = this.axesD[this.index1];
        var axis2 = this.axesD[this.index2];

        axis1.sort();
        axis2.sort();

        var count1 = axis1.calculateTestCount();
        var count2 = axis2.calculateTestCount();
        var elementsD;
        var elementsS;
        if( count1 <= count2 ){// select the best axis
            axis2 = this.axesS[this.index1];
            axis2.sort();
            elementsD = axis1.elements;
            elementsS = axis2.elements;
        }else{
            axis1 = this.axesS[this.index2];
            axis1.sort();
            elementsD = axis2.elements;
            elementsS = axis1.elements;
            this.index1 ^= this.index2;
            this.index2 ^= this.index1;
            this.index1 ^= this.index2;
        }
        var activeD;
        var activeS;
        var p = 0;
        var q = 0;
        while( p < this.numElementsD ){
            var e1;
            var dyn;
            if (q == this.numElementsS ){
                e1 = elementsD[p];
                dyn = true;
                p++;
            }else{
                var d = elementsD[p];
                var s = elementsS[q];
                if( d.value < s.value ){
                    e1 = d;
                    dyn = true;
                    p++;
                }else{
                    e1 = s;
                    dyn = false;
                    q++;
                }
            }
            if( !e1.max ){
                var s1 = e1.proxy.shape;
                var min1 = e1.min1.value;
                var max1 = e1.max1.value;
                var min2 = e1.min2.value;
                var max2 = e1.max2.value;

                for( var e2 = activeD; e2 != null; e2 = e2.pair ) {// test for dynamic
                    var s2 = e2.proxy.shape;

                    this.numPairChecks++;
                    if( min1 > e2.max1.value || max1 < e2.min1.value || min2 > e2.max2.value || max2 < e2.min2.value || !this.isAvailablePair( s1, s2 ) ) continue;
                    this.addPair( s1, s2 );
                }
                if( dyn ){
                    for( e2 = activeS; e2 != null; e2 = e2.pair ) {// test for static
                        s2 = e2.proxy.shape;

                        this.numPairChecks++;

                        if( min1 > e2.max1.value || max1 < e2.min1.value|| min2 > e2.max2.value || max2 < e2.min2.value || !this.isAvailablePair(s1,s2) ) continue;
                        this.addPair( s1, s2 );
                    }
                    e1.pair = activeD;
                    activeD = e1;
                }else{
                    e1.pair = activeS;
                    activeS = e1;
                }
            }else{
                var min = e1.pair;
                if( dyn ){
                    if( min == activeD ){
                        activeD = activeD.pair;
                        continue;
                    }else{
                        e1 = activeD;
                    }
                }else{
                    if( min == activeS ){
                        activeS = activeS.pair;
                        continue;
                    }else{
                        e1 = activeS;
                    }
                }
                do{
                    e2 = e1.pair;
                    if( e2 == min ){
                        e1.pair = e2.pair;
                        break;
                    }
                    e1 = e2;
                }while( e1 != null );
            }
        }
        this.index2 = (this.index1|this.index2)^3;
        
    }

});

/**
* A node of the dynamic bounding volume tree.
* @author saharan
*/

function DBVTNode(){
    
	// The first child node of this node.
    this.child1 = null;
    // The second child node of this node.
    this.child2 = null;
    //  The parent node of this tree.
    this.parent = null;
    // The proxy of this node. This has no value if this node is not leaf.
    this.proxy = null;
    // The maximum distance from leaf nodes.
    this.height = 0;
    // The AABB of this node.
    this.aabb = new AABB();

}

/**
 * A dynamic bounding volume tree for the broad-phase algorithm.
 *
 * @author saharan
 * @author lo-th
 */

function DBVT(){

    // The root of the tree.
    this.root = null;
    this.freeNodes = [];
    this.freeNodes.length = 16384;
    this.numFreeNodes = 0;
    this.aabb = new AABB();

}

Object.assign( DBVT.prototype, {

    DBVT: true,

    moveLeaf: function( leaf ) {

        this.deleteLeaf( leaf );
        this.insertLeaf( leaf );
    
    },

    insertLeaf: function ( leaf ) {

        if(this.root == null){
            this.root = leaf;
            return;
        }
        var lb = leaf.aabb;
        var sibling = this.root;
        var oldArea;
        var newArea;
        while(sibling.proxy == null){ // descend the node to search the best pair
            var c1 = sibling.child1;
            var c2 = sibling.child2;
            var b = sibling.aabb;
            var c1b = c1.aabb;
            var c2b = c2.aabb;
            oldArea = b.surfaceArea();
            this.aabb.combine(lb,b);
            newArea = this.aabb.surfaceArea();
            var creatingCost = newArea*2;
            var incrementalCost = (newArea-oldArea)*2; // cost of creating a new pair with the node
            var discendingCost1 = incrementalCost;
            this.aabb.combine(lb,c1b);
            if(c1.proxy!=null){
                // leaf cost = area(combined aabb)
                discendingCost1+=this.aabb.surfaceArea();
            }else{
                // node cost = area(combined aabb) - area(old aabb)
                discendingCost1+=this.aabb.surfaceArea()-c1b.surfaceArea();
            }
            var discendingCost2=incrementalCost;
            this.aabb.combine(lb,c2b);
            if(c2.proxy!=null){
                // leaf cost = area(combined aabb)
                discendingCost2+=this.aabb.surfaceArea();
            }else{
                // node cost = area(combined aabb) - area(old aabb)
                discendingCost2+=this.aabb.surfaceArea()-c2b.surfaceArea();
            }
            if(discendingCost1<discendingCost2){
                if(creatingCost<discendingCost1){
                    break;// stop descending
                }else{
                    sibling = c1;// descend into first child
                }
            }else{
                if(creatingCost<discendingCost2){
                    break;// stop descending
                }else{
                    sibling = c2;// descend into second child
                }
            }
        }
        var oldParent = sibling.parent;
        var newParent;
        if(this.numFreeNodes>0){
            newParent = this.freeNodes[--this.numFreeNodes];
        }else{
            newParent = new DBVTNode();
        }

        newParent.parent = oldParent;
        newParent.child1 = leaf;
        newParent.child2 = sibling;
        newParent.aabb.combine(leaf.aabb,sibling.aabb);
        newParent.height = sibling.height+1;
        sibling.parent = newParent;
        leaf.parent = newParent;
        if(sibling == this.root){
            // replace root
            this.root = newParent;
        }else{
            // replace child
            if(oldParent.child1 == sibling){
                oldParent.child1 = newParent;
            }else{
                oldParent.child2 = newParent;
            }
        }
        // update whole tree
        do{
            newParent = this.balance(newParent);
            this.fix(newParent);
            newParent = newParent.parent;
        }while(newParent != null);
    },

    getBalance: function( node ) {

        if(node.proxy!=null)return 0;
        return node.child1.height-node.child2.height;

    },

    deleteLeaf: function( leaf ) {

        if(leaf == this.root){
            this.root = null;
            return;
        }
        var parent = leaf.parent;
        var sibling;
        if(parent.child1==leaf){
            sibling=parent.child2;
        }else{
            sibling=parent.child1;
        }
        if(parent==this.root){
            this.root=sibling;
            sibling.parent=null;
            return;
        }
        var grandParent = parent.parent;
        sibling.parent = grandParent;
        if(grandParent.child1 == parent ) {
            grandParent.child1 = sibling;
        }else{
            grandParent.child2 = sibling;
        }
        if(this.numFreeNodes<16384){
            this.freeNodes[this.numFreeNodes++] = parent;
        }
        do{
            grandParent = this.balance(grandParent);
            this.fix(grandParent);
            grandParent = grandParent.parent;
        }while( grandParent != null );
    
    },

    balance: function( node ) {

        var nh = node.height;
        if(nh<2){
            return node;
        }
        var p = node.parent;
        var l = node.child1;
        var r = node.child2;
        var lh = l.height;
        var rh = r.height;
        var balance = lh-rh;
        var t;// for bit operation

        //          [ N ]
        //         /     \
        //    [ L ]       [ R ]
        //     / \         / \
        // [L-L] [L-R] [R-L] [R-R]

        // Is the tree balanced?
        if(balance>1){
            var ll = l.child1;
            var lr = l.child2;
            var llh = ll.height;
            var lrh = lr.height;

            // Is L-L higher than L-R?
            if(llh>lrh){
                // set N to L-R
                l.child2 = node;
                node.parent = l;

                //          [ L ]
                //         /     \
                //    [L-L]       [ N ]
                //     / \         / \
                // [...] [...] [ L ] [ R ]
                
                // set L-R
                node.child1 = lr;
                lr.parent = node;

                //          [ L ]
                //         /     \
                //    [L-L]       [ N ]
                //     / \         / \
                // [...] [...] [L-R] [ R ]
                
                // fix bounds and heights
                node.aabb.combine( lr.aabb, r.aabb );
                t = lrh-rh;
                node.height=lrh-(t&t>>31)+1;
                l.aabb.combine(ll.aabb,node.aabb);
                t=llh-nh;
                l.height=llh-(t&t>>31)+1;
            }else{
                // set N to L-L
                l.child1=node;
                node.parent=l;

                //          [ L ]
                //         /     \
                //    [ N ]       [L-R]
                //     / \         / \
                // [ L ] [ R ] [...] [...]
                
                // set L-L
                node.child1 = ll;
                ll.parent = node;

                //          [ L ]
                //         /     \
                //    [ N ]       [L-R]
                //     / \         / \
                // [L-L] [ R ] [...] [...]
                
                // fix bounds and heights
                node.aabb.combine(ll.aabb,r.aabb);
                t = llh - rh;
                node.height=llh-(t&t>>31)+1;

                l.aabb.combine(node.aabb,lr.aabb);
                t=nh-lrh;
                l.height=nh-(t&t>>31)+1;
            }
            // set new parent of L
            if(p!=null){
                if(p.child1==node){
                    p.child1=l;
                }else{
                    p.child2=l;
                }
            }else{
                this.root=l;
            }
            l.parent=p;
            return l;
        }else if(balance<-1){
            var rl = r.child1;
            var rr = r.child2;
            var rlh = rl.height;
            var rrh = rr.height;

            // Is R-L higher than R-R?
            if( rlh > rrh ) {
                // set N to R-R
                r.child2 = node;
                node.parent = r;

                //          [ R ]
                //         /     \
                //    [R-L]       [ N ]
                //     / \         / \
                // [...] [...] [ L ] [ R ]
                
                // set R-R
                node.child2 = rr;
                rr.parent = node;

                //          [ R ]
                //         /     \
                //    [R-L]       [ N ]
                //     / \         / \
                // [...] [...] [ L ] [R-R]
                
                // fix bounds and heights
                node.aabb.combine(l.aabb,rr.aabb);
                t = lh-rrh;
                node.height = lh-(t&t>>31)+1;
                r.aabb.combine(rl.aabb,node.aabb);
                t = rlh-nh;
                r.height = rlh-(t&t>>31)+1;
            }else{
                // set N to R-L
                r.child1 = node;
                node.parent = r;
                //          [ R ]
                //         /     \
                //    [ N ]       [R-R]
                //     / \         / \
                // [ L ] [ R ] [...] [...]
                
                // set R-L
                node.child2 = rl;
                rl.parent = node;

                //          [ R ]
                //         /     \
                //    [ N ]       [R-R]
                //     / \         / \
                // [ L ] [R-L] [...] [...]
                
                // fix bounds and heights
                node.aabb.combine(l.aabb,rl.aabb);
                t=lh-rlh;
                node.height=lh-(t&t>>31)+1;
                r.aabb.combine(node.aabb,rr.aabb);
                t=nh-rrh;
                r.height=nh-(t&t>>31)+1;
            }
            // set new parent of R
            if(p!=null){
                if(p.child1==node){
                    p.child1=r;
                }else{
                    p.child2=r;
                }
            }else{
                this.root=r;
            }
            r.parent=p;
            return r;
        }
        return node;
    },

    fix: function ( node ) {

        var c1 = node.child1;
        var c2 = node.child2;
        node.aabb.combine( c1.aabb, c2.aabb );
        node.height = c1.height < c2.height ? c2.height+1 : c1.height+1; 

    }
    
});

/**
* A proxy for dynamic bounding volume tree broad-phase.
* @author saharan
*/

function DBVTProxy ( shape ) {

    Proxy.call( this, shape);
    // The leaf of the proxy.
    this.leaf = new DBVTNode();
    this.leaf.proxy = this;

}

DBVTProxy.prototype = Object.assign( Object.create( Proxy.prototype ), {

    constructor: DBVTProxy,

    update: function () {

    }

});

/**
 * A broad-phase algorithm using dynamic bounding volume tree.
 *
 * @author saharan
 * @author lo-th
 */

function DBVTBroadPhase(){

    BroadPhase.call( this );

    this.types = BR_BOUNDING_VOLUME_TREE;

    this.tree = new DBVT();
    this.stack = [];
    this.leaves = [];
    this.numLeaves = 0;

}

DBVTBroadPhase.prototype = Object.assign( Object.create( BroadPhase.prototype ), {

    constructor: DBVTBroadPhase,

    createProxy: function ( shape ) {

        return new DBVTProxy( shape );

    },

    addProxy: function ( proxy ) {

        this.tree.insertLeaf( proxy.leaf );
        this.leaves.push( proxy.leaf );
        this.numLeaves++;

    },

    removeProxy: function ( proxy ) {

        this.tree.deleteLeaf( proxy.leaf );
        var n = this.leaves.indexOf( proxy.leaf );
        if ( n > -1 ) {
            this.leaves.splice(n,1);
            this.numLeaves--;
        }

    },

    collectPairs: function () {

        if ( this.numLeaves < 2 ) return;

        var leaf, margin = 0.1, i = this.numLeaves;

        while(i--){

            leaf = this.leaves[i];

            if ( leaf.proxy.aabb.intersectTestTwo( leaf.aabb ) ){

                leaf.aabb.copy( leaf.proxy.aabb, margin );
                this.tree.deleteLeaf( leaf );
                this.tree.insertLeaf( leaf );
                this.collide( leaf, this.tree.root );

            }
        }

    },

    collide: function ( node1, node2 ) {

        var stackCount = 2;
        var s1, s2, n1, n2, l1, l2;
        this.stack[0] = node1;
        this.stack[1] = node2;

        while( stackCount > 0 ){

            n1 = this.stack[--stackCount];
            n2 = this.stack[--stackCount];
            l1 = n1.proxy != null;
            l2 = n2.proxy != null;
            
            this.numPairChecks++;

            if( l1 && l2 ){
                s1 = n1.proxy.shape;
                s2 = n2.proxy.shape;
                if ( s1 == s2 || s1.aabb.intersectTest( s2.aabb ) || !this.isAvailablePair( s1, s2 ) ) continue;

                this.addPair(s1,s2);

            }else{

                if ( n1.aabb.intersectTest( n2.aabb ) ) continue;
                
                /*if(stackCount+4>=this.maxStack){// expand the stack
                    //this.maxStack<<=1;
                    this.maxStack*=2;
                    var newStack = [];// vector
                    newStack.length = this.maxStack;
                    for(var i=0;i<stackCount;i++){
                        newStack[i] = this.stack[i];
                    }
                    this.stack = newStack;
                }*/

                if( l2 || !l1 && (n1.aabb.surfaceArea() > n2.aabb.surfaceArea()) ){
                    this.stack[stackCount++] = n1.child1;
                    this.stack[stackCount++] = n2;
                    this.stack[stackCount++] = n1.child2;
                    this.stack[stackCount++] = n2;
                }else{
                    this.stack[stackCount++] = n1;
                    this.stack[stackCount++] = n2.child1;
                    this.stack[stackCount++] = n1;
                    this.stack[stackCount++] = n2.child2;
                }
            }
        }

    }

});

function CollisionDetector (){

    this.flip = false;

}

Object.assign( CollisionDetector.prototype, {

    CollisionDetector: true,

    detectCollision: function ( shape1, shape2, manifold ) {

        printError("CollisionDetector", "Inheritance error.");

    }

} );

/**
 * A collision detector which detects collisions between two boxes.
 * @author saharan
 */
function BoxBoxCollisionDetector() {

    CollisionDetector.call( this );
    this.clipVertices1 = new Float32Array( 24 ); // 8 vertices x,y,z
    this.clipVertices2 = new Float32Array( 24 );
    this.used = new Float32Array( 8 );
    
    this.INF = 1/0;

}

BoxBoxCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: BoxBoxCollisionDetector,

    detectCollision: function ( shape1, shape2, manifold ) {
        // What you are doing 
        // · I to prepare a separate axis of the fifteen 
        //-Six in each of three normal vectors of the xyz direction of the box both 
        // · Remaining nine 3x3 a vector perpendicular to the side of the box 2 and the side of the box 1 
        // · Calculate the depth to the separation axis 

        // Calculates the distance using the inner product and put the amount of embedment 
        // · However a vertical separation axis and side to weight a little to avoid vibration 
        // And end when there is a separate axis that is remote even one 
        // · I look for separation axis with little to dent most 
        // Men and if separation axis of the first six - end collision 
        // Heng If it separate axis of nine other - side collision 
        // Heng - case of a side collision 
        // · Find points of two sides on which you made ​​the separation axis 

        // Calculates the point of closest approach of a straight line consisting of separate axis points obtained, and the collision point 
        //-Surface - the case of the plane crash 
        //-Box A, box B and the other a box of better made ​​a separate axis 
        // • The surface A and the plane that made the separation axis of the box A, and B to the surface the face of the box B close in the opposite direction to the most isolated axis 

        // When viewed from the front surface A, and the cut part exceeding the area of the surface A is a surface B 
        //-Plane B becomes the 3-8 triangle, I a candidate for the collision point the vertex of surface B 
        // • If more than one candidate 5 exists, scraping up to four 

        // For potential collision points of all, to examine the distance between the surface A 
        // • If you were on the inside surface of A, and the collision point

        var b1;
        var b2;
        if(shape1.id<shape2.id){
            b1=(shape1);
            b2=(shape2);
        }else{
            b1=(shape2);
            b2=(shape1);
        }
        var V1 = b1.elements;
        var V2 = b2.elements;

        var D1 = b1.dimentions;
        var D2 = b2.dimentions;

        var p1=b1.position;
        var p2=b2.position;
        var p1x=p1.x;
        var p1y=p1.y;
        var p1z=p1.z;
        var p2x=p2.x;
        var p2y=p2.y;
        var p2z=p2.z;
        // diff
        var dx=p2x-p1x;
        var dy=p2y-p1y;
        var dz=p2z-p1z;
        // distance
        var w1=b1.halfWidth;
        var h1=b1.halfHeight;
        var d1=b1.halfDepth;
        var w2=b2.halfWidth;
        var h2=b2.halfHeight;
        var d2=b2.halfDepth;
        // direction

        // ----------------------------
        // 15 separating axes
        // 1~6: face
        // 7~f: edge
        // http://marupeke296.com/COL_3D_No13_OBBvsOBB.html
        // ----------------------------
        
        var a1x=D1[0];
        var a1y=D1[1];
        var a1z=D1[2];
        var a2x=D1[3];
        var a2y=D1[4];
        var a2z=D1[5];
        var a3x=D1[6];
        var a3y=D1[7];
        var a3z=D1[8];
        var d1x=D1[9];
        var d1y=D1[10];
        var d1z=D1[11];
        var d2x=D1[12];
        var d2y=D1[13];
        var d2z=D1[14];
        var d3x=D1[15];
        var d3y=D1[16];
        var d3z=D1[17];

        var a4x=D2[0];
        var a4y=D2[1];
        var a4z=D2[2];
        var a5x=D2[3];
        var a5y=D2[4];
        var a5z=D2[5];
        var a6x=D2[6];
        var a6y=D2[7];
        var a6z=D2[8];
        var d4x=D2[9];
        var d4y=D2[10];
        var d4z=D2[11];
        var d5x=D2[12];
        var d5y=D2[13];
        var d5z=D2[14];
        var d6x=D2[15];
        var d6y=D2[16];
        var d6z=D2[17];
        
        var a7x=a1y*a4z-a1z*a4y;
        var a7y=a1z*a4x-a1x*a4z;
        var a7z=a1x*a4y-a1y*a4x;
        var a8x=a1y*a5z-a1z*a5y;
        var a8y=a1z*a5x-a1x*a5z;
        var a8z=a1x*a5y-a1y*a5x;
        var a9x=a1y*a6z-a1z*a6y;
        var a9y=a1z*a6x-a1x*a6z;
        var a9z=a1x*a6y-a1y*a6x;
        var aax=a2y*a4z-a2z*a4y;
        var aay=a2z*a4x-a2x*a4z;
        var aaz=a2x*a4y-a2y*a4x;
        var abx=a2y*a5z-a2z*a5y;
        var aby=a2z*a5x-a2x*a5z;
        var abz=a2x*a5y-a2y*a5x;
        var acx=a2y*a6z-a2z*a6y;
        var acy=a2z*a6x-a2x*a6z;
        var acz=a2x*a6y-a2y*a6x;
        var adx=a3y*a4z-a3z*a4y;
        var ady=a3z*a4x-a3x*a4z;
        var adz=a3x*a4y-a3y*a4x;
        var aex=a3y*a5z-a3z*a5y;
        var aey=a3z*a5x-a3x*a5z;
        var aez=a3x*a5y-a3y*a5x;
        var afx=a3y*a6z-a3z*a6y;
        var afy=a3z*a6x-a3x*a6z;
        var afz=a3x*a6y-a3y*a6x;
        // right or left flags
        var right1;
        var right2;
        var right3;
        var right4;
        var right5;
        var right6;
        var right7;
        var right8;
        var right9;
        var righta;
        var rightb;
        var rightc;
        var rightd;
        var righte;
        var rightf;
        // overlapping distances
        var overlap1;
        var overlap2;
        var overlap3;
        var overlap4;
        var overlap5;
        var overlap6;
        var overlap7;
        var overlap8;
        var overlap9;
        var overlapa;
        var overlapb;
        var overlapc;
        var overlapd;
        var overlape;
        var overlapf;
        // invalid flags
        var invalid7=false;
        var invalid8=false;
        var invalid9=false;
        var invalida=false;
        var invalidb=false;
        var invalidc=false;
        var invalidd=false;
        var invalide=false;
        var invalidf=false;
        // temporary variables
        var len;
        var len1;
        var len2;
        var dot1;
        var dot2;
        var dot3;
        // try axis 1
        len=a1x*dx+a1y*dy+a1z*dz;
        right1=len>0;
        if(!right1)len=-len;
        len1=w1;
        dot1=a1x*a4x+a1y*a4y+a1z*a4z;
        dot2=a1x*a5x+a1y*a5y+a1z*a5z;
        dot3=a1x*a6x+a1y*a6y+a1z*a6z;
        if(dot1<0)dot1=-dot1;
        if(dot2<0)dot2=-dot2;
        if(dot3<0)dot3=-dot3;
        len2=dot1*w2+dot2*h2+dot3*d2;
        overlap1=len-len1-len2;
        if(overlap1>0)return;
        // try axis 2
        len=a2x*dx+a2y*dy+a2z*dz;
        right2=len>0;
        if(!right2)len=-len;
        len1=h1;
        dot1=a2x*a4x+a2y*a4y+a2z*a4z;
        dot2=a2x*a5x+a2y*a5y+a2z*a5z;
        dot3=a2x*a6x+a2y*a6y+a2z*a6z;
        if(dot1<0)dot1=-dot1;
        if(dot2<0)dot2=-dot2;
        if(dot3<0)dot3=-dot3;
        len2=dot1*w2+dot2*h2+dot3*d2;
        overlap2=len-len1-len2;
        if(overlap2>0)return;
        // try axis 3
        len=a3x*dx+a3y*dy+a3z*dz;
        right3=len>0;
        if(!right3)len=-len;
        len1=d1;
        dot1=a3x*a4x+a3y*a4y+a3z*a4z;
        dot2=a3x*a5x+a3y*a5y+a3z*a5z;
        dot3=a3x*a6x+a3y*a6y+a3z*a6z;
        if(dot1<0)dot1=-dot1;
        if(dot2<0)dot2=-dot2;
        if(dot3<0)dot3=-dot3;
        len2=dot1*w2+dot2*h2+dot3*d2;
        overlap3=len-len1-len2;
        if(overlap3>0)return;
        // try axis 4
        len=a4x*dx+a4y*dy+a4z*dz;
        right4=len>0;
        if(!right4)len=-len;
        dot1=a4x*a1x+a4y*a1y+a4z*a1z;
        dot2=a4x*a2x+a4y*a2y+a4z*a2z;
        dot3=a4x*a3x+a4y*a3y+a4z*a3z;
        if(dot1<0)dot1=-dot1;
        if(dot2<0)dot2=-dot2;
        if(dot3<0)dot3=-dot3;
        len1=dot1*w1+dot2*h1+dot3*d1;
        len2=w2;
        overlap4=(len-len1-len2)*1.0;
        if(overlap4>0)return;
        // try axis 5
        len=a5x*dx+a5y*dy+a5z*dz;
        right5=len>0;
        if(!right5)len=-len;
        dot1=a5x*a1x+a5y*a1y+a5z*a1z;
        dot2=a5x*a2x+a5y*a2y+a5z*a2z;
        dot3=a5x*a3x+a5y*a3y+a5z*a3z;
        if(dot1<0)dot1=-dot1;
        if(dot2<0)dot2=-dot2;
        if(dot3<0)dot3=-dot3;
        len1=dot1*w1+dot2*h1+dot3*d1;
        len2=h2;
        overlap5=(len-len1-len2)*1.0;
        if(overlap5>0)return;
        // try axis 6
        len=a6x*dx+a6y*dy+a6z*dz;
        right6=len>0;
        if(!right6)len=-len;
        dot1=a6x*a1x+a6y*a1y+a6z*a1z;
        dot2=a6x*a2x+a6y*a2y+a6z*a2z;
        dot3=a6x*a3x+a6y*a3y+a6z*a3z;
        if(dot1<0)dot1=-dot1;
        if(dot2<0)dot2=-dot2;
        if(dot3<0)dot3=-dot3;
        len1=dot1*w1+dot2*h1+dot3*d1;
        len2=d2;
        overlap6=(len-len1-len2)*1.0;
        if(overlap6>0)return;
        // try axis 7
        len=a7x*a7x+a7y*a7y+a7z*a7z;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            a7x*=len;
            a7y*=len;
            a7z*=len;
            len=a7x*dx+a7y*dy+a7z*dz;
            right7=len>0;
            if(!right7)len=-len;
            dot1=a7x*a2x+a7y*a2y+a7z*a2z;
            dot2=a7x*a3x+a7y*a3y+a7z*a3z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*h1+dot2*d1;
            dot1=a7x*a5x+a7y*a5y+a7z*a5z;
            dot2=a7x*a6x+a7y*a6y+a7z*a6z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*h2+dot2*d2;
            overlap7=len-len1-len2;
            if(overlap7>0)return;
        }else{
            right7=false;
            overlap7=0;
            invalid7=true;
        }
        // try axis 8
        len=a8x*a8x+a8y*a8y+a8z*a8z;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            a8x*=len;
            a8y*=len;
            a8z*=len;
            len=a8x*dx+a8y*dy+a8z*dz;
            right8=len>0;
            if(!right8)len=-len;
            dot1=a8x*a2x+a8y*a2y+a8z*a2z;
            dot2=a8x*a3x+a8y*a3y+a8z*a3z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*h1+dot2*d1;
            dot1=a8x*a4x+a8y*a4y+a8z*a4z;
            dot2=a8x*a6x+a8y*a6y+a8z*a6z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*w2+dot2*d2;
            overlap8=len-len1-len2;
            if(overlap8>0)return;
        }else{
            right8=false;
            overlap8=0;
            invalid8=true;
        }
        // try axis 9
        len=a9x*a9x+a9y*a9y+a9z*a9z;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            a9x*=len;
            a9y*=len;
            a9z*=len;
            len=a9x*dx+a9y*dy+a9z*dz;
            right9=len>0;
            if(!right9)len=-len;
            dot1=a9x*a2x+a9y*a2y+a9z*a2z;
            dot2=a9x*a3x+a9y*a3y+a9z*a3z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*h1+dot2*d1;
            dot1=a9x*a4x+a9y*a4y+a9z*a4z;
            dot2=a9x*a5x+a9y*a5y+a9z*a5z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*w2+dot2*h2;
            overlap9=len-len1-len2;
            if(overlap9>0)return;
        }else{
            right9=false;
            overlap9=0;
            invalid9=true;
        }
        // try axis 10
        len=aax*aax+aay*aay+aaz*aaz;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            aax*=len;
            aay*=len;
            aaz*=len;
            len=aax*dx+aay*dy+aaz*dz;
            righta=len>0;
            if(!righta)len=-len;
            dot1=aax*a1x+aay*a1y+aaz*a1z;
            dot2=aax*a3x+aay*a3y+aaz*a3z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*w1+dot2*d1;
            dot1=aax*a5x+aay*a5y+aaz*a5z;
            dot2=aax*a6x+aay*a6y+aaz*a6z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*h2+dot2*d2;
            overlapa=len-len1-len2;
            if(overlapa>0)return;
        }else{
            righta=false;
            overlapa=0;
            invalida=true;
        }
        // try axis 11
        len=abx*abx+aby*aby+abz*abz;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            abx*=len;
            aby*=len;
            abz*=len;
            len=abx*dx+aby*dy+abz*dz;
            rightb=len>0;
            if(!rightb)len=-len;
            dot1=abx*a1x+aby*a1y+abz*a1z;
            dot2=abx*a3x+aby*a3y+abz*a3z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*w1+dot2*d1;
            dot1=abx*a4x+aby*a4y+abz*a4z;
            dot2=abx*a6x+aby*a6y+abz*a6z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*w2+dot2*d2;
            overlapb=len-len1-len2;
            if(overlapb>0)return;
        }else{
            rightb=false;
            overlapb=0;
            invalidb=true;
        }
        // try axis 12
        len=acx*acx+acy*acy+acz*acz;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            acx*=len;
            acy*=len;
            acz*=len;
            len=acx*dx+acy*dy+acz*dz;
            rightc=len>0;
            if(!rightc)len=-len;
            dot1=acx*a1x+acy*a1y+acz*a1z;
            dot2=acx*a3x+acy*a3y+acz*a3z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*w1+dot2*d1;
            dot1=acx*a4x+acy*a4y+acz*a4z;
            dot2=acx*a5x+acy*a5y+acz*a5z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*w2+dot2*h2;
            overlapc=len-len1-len2;
            if(overlapc>0)return;
        }else{
            rightc=false;
            overlapc=0;
            invalidc=true;
        }
        // try axis 13
        len=adx*adx+ady*ady+adz*adz;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            adx*=len;
            ady*=len;
            adz*=len;
            len=adx*dx+ady*dy+adz*dz;
            rightd=len>0;
            if(!rightd)len=-len;
            dot1=adx*a1x+ady*a1y+adz*a1z;
            dot2=adx*a2x+ady*a2y+adz*a2z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*w1+dot2*h1;
            dot1=adx*a5x+ady*a5y+adz*a5z;
            dot2=adx*a6x+ady*a6y+adz*a6z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*h2+dot2*d2;
            overlapd=len-len1-len2;
            if(overlapd>0)return;
        }else{
            rightd=false;
            overlapd=0;
            invalidd=true;
        }
        // try axis 14
        len=aex*aex+aey*aey+aez*aez;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            aex*=len;
            aey*=len;
            aez*=len;
            len=aex*dx+aey*dy+aez*dz;
            righte=len>0;
            if(!righte)len=-len;
            dot1=aex*a1x+aey*a1y+aez*a1z;
            dot2=aex*a2x+aey*a2y+aez*a2z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*w1+dot2*h1;
            dot1=aex*a4x+aey*a4y+aez*a4z;
            dot2=aex*a6x+aey*a6y+aez*a6z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*w2+dot2*d2;
            overlape=len-len1-len2;
            if(overlape>0)return;
        }else{
            righte=false;
            overlape=0;
            invalide=true;
        }
        // try axis 15
        len=afx*afx+afy*afy+afz*afz;
        if(len>1e-5){
            len=1/_Math.sqrt(len);
            afx*=len;
            afy*=len;
            afz*=len;
            len=afx*dx+afy*dy+afz*dz;
            rightf=len>0;
            if(!rightf)len=-len;
            dot1=afx*a1x+afy*a1y+afz*a1z;
            dot2=afx*a2x+afy*a2y+afz*a2z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len1=dot1*w1+dot2*h1;
            dot1=afx*a4x+afy*a4y+afz*a4z;
            dot2=afx*a5x+afy*a5y+afz*a5z;
            if(dot1<0)dot1=-dot1;
            if(dot2<0)dot2=-dot2;
            len2=dot1*w2+dot2*h2;
            overlapf=len-len1-len2;
            if(overlapf>0)return;
        }else{
            rightf=false;
            overlapf=0;
            invalidf=true;
        }
        // boxes are overlapping
        var depth=overlap1;
        var depth2=overlap1;
        var minIndex=0;
        var right=right1;
        if(overlap2>depth2){
            depth=overlap2;
            depth2=overlap2;
            minIndex=1;
            right=right2;
        }
        if(overlap3>depth2){
            depth=overlap3;
            depth2=overlap3;
            minIndex=2;
            right=right3;
        }
        if(overlap4>depth2){
            depth=overlap4;
            depth2=overlap4;
            minIndex=3;
            right=right4;
        }
        if(overlap5>depth2){
            depth=overlap5;
            depth2=overlap5;
            minIndex=4;
            right=right5;
        }
        if(overlap6>depth2){
            depth=overlap6;
            depth2=overlap6;
            minIndex=5;
            right=right6;
        }
        if(overlap7-0.01>depth2&&!invalid7){
            depth=overlap7;
            depth2=overlap7-0.01;
            minIndex=6;
            right=right7;
        }
        if(overlap8-0.01>depth2&&!invalid8){
            depth=overlap8;
            depth2=overlap8-0.01;
            minIndex=7;
            right=right8;
        }
        if(overlap9-0.01>depth2&&!invalid9){
            depth=overlap9;
            depth2=overlap9-0.01;
            minIndex=8;
            right=right9;
        }
        if(overlapa-0.01>depth2&&!invalida){
            depth=overlapa;
            depth2=overlapa-0.01;
            minIndex=9;
            right=righta;
        }
        if(overlapb-0.01>depth2&&!invalidb){
            depth=overlapb;
            depth2=overlapb-0.01;
            minIndex=10;
            right=rightb;
        }
        if(overlapc-0.01>depth2&&!invalidc){
            depth=overlapc;
            depth2=overlapc-0.01;
            minIndex=11;
            right=rightc;
        }
        if(overlapd-0.01>depth2&&!invalidd){
            depth=overlapd;
            depth2=overlapd-0.01;
            minIndex=12;
            right=rightd;
        }
        if(overlape-0.01>depth2&&!invalide){
            depth=overlape;
            depth2=overlape-0.01;
            minIndex=13;
            right=righte;
        }
        if(overlapf-0.01>depth2&&!invalidf){
            depth=overlapf;
            minIndex=14;
            right=rightf;
        }
        // normal
        var nx=0;
        var ny=0;
        var nz=0;
        // edge line or face side normal
        var n1x=0;
        var n1y=0;
        var n1z=0;
        var n2x=0;
        var n2y=0;
        var n2z=0;
        // center of current face
        var cx=0;
        var cy=0;
        var cz=0;
        // face side
        var s1x=0;
        var s1y=0;
        var s1z=0;
        var s2x=0;
        var s2y=0;
        var s2z=0;
        // swap b1 b2
        var swap=false;

        //_______________________________________

        if(minIndex==0){// b1.x * b2
            if(right){
                cx=p1x+d1x; cy=p1y+d1y;  cz=p1z+d1z;
                nx=a1x; ny=a1y; nz=a1z;
            }else{
                cx=p1x-d1x; cy=p1y-d1y; cz=p1z-d1z;
                nx=-a1x; ny=-a1y; nz=-a1z;
            }
            s1x=d2x; s1y=d2y; s1z=d2z;
            n1x=-a2x; n1y=-a2y; n1z=-a2z;
            s2x=d3x; s2y=d3y; s2z=d3z;
            n2x=-a3x; n2y=-a3y; n2z=-a3z;
        }
        else if(minIndex==1){// b1.y * b2
            if(right){
                cx=p1x+d2x; cy=p1y+d2y; cz=p1z+d2z;
                nx=a2x; ny=a2y; nz=a2z;
            }else{
                cx=p1x-d2x; cy=p1y-d2y; cz=p1z-d2z;
                nx=-a2x; ny=-a2y; nz=-a2z;
            }
            s1x=d1x; s1y=d1y; s1z=d1z;
            n1x=-a1x; n1y=-a1y; n1z=-a1z;
            s2x=d3x; s2y=d3y; s2z=d3z;
            n2x=-a3x; n2y=-a3y; n2z=-a3z;
        }
        else if(minIndex==2){// b1.z * b2
            if(right){
                cx=p1x+d3x; cy=p1y+d3y; cz=p1z+d3z;
                nx=a3x; ny=a3y; nz=a3z;
            }else{
                cx=p1x-d3x; cy=p1y-d3y; cz=p1z-d3z;
                nx=-a3x; ny=-a3y; nz=-a3z;
            }
            s1x=d1x; s1y=d1y; s1z=d1z;
            n1x=-a1x; n1y=-a1y; n1z=-a1z;
            s2x=d2x; s2y=d2y; s2z=d2z;
            n2x=-a2x; n2y=-a2y; n2z=-a2z;
        }
        else if(minIndex==3){// b2.x * b1
            swap=true;
            if(!right){
                cx=p2x+d4x; cy=p2y+d4y; cz=p2z+d4z;
                nx=a4x; ny=a4y; nz=a4z;
            }else{
                cx=p2x-d4x; cy=p2y-d4y; cz=p2z-d4z;
                nx=-a4x; ny=-a4y; nz=-a4z;
            }
            s1x=d5x; s1y=d5y; s1z=d5z;
            n1x=-a5x; n1y=-a5y; n1z=-a5z;
            s2x=d6x; s2y=d6y; s2z=d6z;
            n2x=-a6x; n2y=-a6y; n2z=-a6z;
        }
        else if(minIndex==4){// b2.y * b1
            swap=true;
            if(!right){
                cx=p2x+d5x; cy=p2y+d5y; cz=p2z+d5z;
                nx=a5x; ny=a5y; nz=a5z;
            }else{
                cx=p2x-d5x; cy=p2y-d5y; cz=p2z-d5z;
                nx=-a5x; ny=-a5y; nz=-a5z;
            }
            s1x=d4x; s1y=d4y; s1z=d4z;
            n1x=-a4x; n1y=-a4y; n1z=-a4z;
            s2x=d6x; s2y=d6y; s2z=d6z;
            n2x=-a6x; n2y=-a6y; n2z=-a6z;
        }
        else if(minIndex==5){// b2.z * b1
            swap=true;
            if(!right){
                cx=p2x+d6x; cy=p2y+d6y; cz=p2z+d6z;
                nx=a6x; ny=a6y; nz=a6z;
            }else{
                cx=p2x-d6x; cy=p2y-d6y; cz=p2z-d6z;
                nx=-a6x; ny=-a6y; nz=-a6z;
            }
            s1x=d4x; s1y=d4y; s1z=d4z;
            n1x=-a4x; n1y=-a4y; n1z=-a4z;
            s2x=d5x; s2y=d5y; s2z=d5z;
            n2x=-a5x; n2y=-a5y; n2z=-a5z;
        }
        else if(minIndex==6){// b1.x * b2.x
            nx=a7x; ny=a7y; nz=a7z;
            n1x=a1x; n1y=a1y; n1z=a1z;
            n2x=a4x; n2y=a4y; n2z=a4z;
        }
        else if(minIndex==7){// b1.x * b2.y
            nx=a8x; ny=a8y; nz=a8z;
            n1x=a1x; n1y=a1y; n1z=a1z;
            n2x=a5x; n2y=a5y; n2z=a5z;
        }
        else if(minIndex==8){// b1.x * b2.z
            nx=a9x; ny=a9y; nz=a9z;
            n1x=a1x; n1y=a1y; n1z=a1z;
            n2x=a6x; n2y=a6y; n2z=a6z;
        }
        else if(minIndex==9){// b1.y * b2.x
            nx=aax; ny=aay; nz=aaz;
            n1x=a2x; n1y=a2y; n1z=a2z;
            n2x=a4x; n2y=a4y; n2z=a4z;
        }
        else if(minIndex==10){// b1.y * b2.y
            nx=abx; ny=aby; nz=abz;
            n1x=a2x; n1y=a2y; n1z=a2z;
            n2x=a5x; n2y=a5y; n2z=a5z;
        }
        else if(minIndex==11){// b1.y * b2.z
            nx=acx; ny=acy; nz=acz;
            n1x=a2x; n1y=a2y; n1z=a2z;
            n2x=a6x; n2y=a6y; n2z=a6z;
        }
        else if(minIndex==12){// b1.z * b2.x
            nx=adx;  ny=ady; nz=adz;
            n1x=a3x; n1y=a3y; n1z=a3z;
            n2x=a4x; n2y=a4y; n2z=a4z;
        }
        else if(minIndex==13){// b1.z * b2.y
            nx=aex; ny=aey; nz=aez;
            n1x=a3x; n1y=a3y; n1z=a3z;
            n2x=a5x; n2y=a5y; n2z=a5z;
        }
        else if(minIndex==14){// b1.z * b2.z
            nx=afx; ny=afy; nz=afz;
            n1x=a3x; n1y=a3y; n1z=a3z;
            n2x=a6x; n2y=a6y; n2z=a6z;
        }

        //__________________________________________

        //var v;
        if(minIndex>5){
            if(!right){
                nx=-nx; ny=-ny; nz=-nz;
            }
            var distance;
            var maxDistance;
            var vx;
            var vy;
            var vz;
            var v1x;
            var v1y;
            var v1z;
            var v2x;
            var v2y;
            var v2z;
            //vertex1;
            v1x=V1[0]; v1y=V1[1]; v1z=V1[2];
            maxDistance=nx*v1x+ny*v1y+nz*v1z;
            //vertex2;
            vx=V1[3]; vy=V1[4]; vz=V1[5];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance>maxDistance){
                maxDistance=distance;
                v1x=vx; v1y=vy; v1z=vz;
            }
            //vertex3;
            vx=V1[6]; vy=V1[7]; vz=V1[8];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance>maxDistance){
                maxDistance=distance;
                v1x=vx; v1y=vy; v1z=vz;
            }
            //vertex4;
            vx=V1[9]; vy=V1[10]; vz=V1[11];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance>maxDistance){
                maxDistance=distance;
                v1x=vx; v1y=vy; v1z=vz;
            }
            //vertex5;
            vx=V1[12]; vy=V1[13]; vz=V1[14];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance>maxDistance){
                maxDistance=distance;
                v1x=vx; v1y=vy; v1z=vz;
            }
            //vertex6;
            vx=V1[15]; vy=V1[16]; vz=V1[17];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance>maxDistance){
                maxDistance=distance;
                v1x=vx; v1y=vy; v1z=vz;
            }
            //vertex7;
            vx=V1[18]; vy=V1[19]; vz=V1[20];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance>maxDistance){
                maxDistance=distance;
                v1x=vx; v1y=vy; v1z=vz;
            }
            //vertex8;
            vx=V1[21]; vy=V1[22]; vz=V1[23];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance>maxDistance){
                maxDistance=distance;
                v1x=vx; v1y=vy; v1z=vz;
            }
            //vertex1;
            v2x=V2[0]; v2y=V2[1]; v2z=V2[2];
            maxDistance=nx*v2x+ny*v2y+nz*v2z;
            //vertex2;
            vx=V2[3]; vy=V2[4]; vz=V2[5];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance<maxDistance){
                maxDistance=distance;
                v2x=vx; v2y=vy; v2z=vz;
            }
            //vertex3;
            vx=V2[6]; vy=V2[7]; vz=V2[8];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance<maxDistance){
                maxDistance=distance;
                v2x=vx; v2y=vy; v2z=vz;
            }
            //vertex4;
            vx=V2[9]; vy=V2[10]; vz=V2[11];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance<maxDistance){
                maxDistance=distance;
                v2x=vx; v2y=vy; v2z=vz;
            }
            //vertex5;
            vx=V2[12]; vy=V2[13]; vz=V2[14];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance<maxDistance){
                maxDistance=distance;
                v2x=vx; v2y=vy; v2z=vz;
            }
            //vertex6;
            vx=V2[15]; vy=V2[16]; vz=V2[17];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance<maxDistance){
                maxDistance=distance;
                v2x=vx; v2y=vy; v2z=vz;
            }
            //vertex7;
            vx=V2[18]; vy=V2[19]; vz=V2[20];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance<maxDistance){
                maxDistance=distance;
                v2x=vx; v2y=vy; v2z=vz;
            }
            //vertex8;
            vx=V2[21]; vy=V2[22]; vz=V2[23];
            distance=nx*vx+ny*vy+nz*vz;
            if(distance<maxDistance){
                maxDistance=distance;
                v2x=vx; v2y=vy; v2z=vz;
            }
            vx=v2x-v1x; vy=v2y-v1y; vz=v2z-v1z;
            dot1=n1x*n2x+n1y*n2y+n1z*n2z;
            var t=(vx*(n1x-n2x*dot1)+vy*(n1y-n2y*dot1)+vz*(n1z-n2z*dot1))/(1-dot1*dot1);
            manifold.addPoint(v1x+n1x*t+nx*depth*0.5,v1y+n1y*t+ny*depth*0.5,v1z+n1z*t+nz*depth*0.5,nx,ny,nz,depth,false);
            return;
        }
        // now detect face-face collision...
        // target quad
        var q1x;
        var q1y;
        var q1z;
        var q2x;
        var q2y;
        var q2z;
        var q3x;
        var q3y;
        var q3z;
        var q4x;
        var q4y;
        var q4z;
        // search support face and vertex
        var minDot=1;
        var dot=0;
        var minDotIndex=0;
        if(swap){
            dot=a1x*nx+a1y*ny+a1z*nz;
            if(dot<minDot){
                minDot=dot;
                minDotIndex=0;
            }
            if(-dot<minDot){
                minDot=-dot;
                minDotIndex=1;
            }
            dot=a2x*nx+a2y*ny+a2z*nz;
            if(dot<minDot){
                minDot=dot;
                minDotIndex=2;
            }
            if(-dot<minDot){
                minDot=-dot;
                minDotIndex=3;
            }
            dot=a3x*nx+a3y*ny+a3z*nz;
            if(dot<minDot){
                minDot=dot;
                minDotIndex=4;
            }
            if(-dot<minDot){
                minDot=-dot;
                minDotIndex=5;
            }

            if(minDotIndex==0){// x+ face
                q1x=V1[0]; q1y=V1[1]; q1z=V1[2];//vertex1
                q2x=V1[6]; q2y=V1[7]; q2z=V1[8];//vertex3
                q3x=V1[9]; q3y=V1[10]; q3z=V1[11];//vertex4
                q4x=V1[3]; q4y=V1[4]; q4z=V1[5];//vertex2
            }
            else if(minDotIndex==1){// x- face
                q1x=V1[15]; q1y=V1[16]; q1z=V1[17];//vertex6
                q2x=V1[21]; q2y=V1[22]; q2z=V1[23];//vertex8
                q3x=V1[18]; q3y=V1[19]; q3z=V1[20];//vertex7
                q4x=V1[12]; q4y=V1[13]; q4z=V1[14];//vertex5
            }
            else if(minDotIndex==2){// y+ face
                q1x=V1[12]; q1y=V1[13]; q1z=V1[14];//vertex5
                q2x=V1[0]; q2y=V1[1]; q2z=V1[2];//vertex1
                q3x=V1[3]; q3y=V1[4]; q3z=V1[5];//vertex2
                q4x=V1[15]; q4y=V1[16]; q4z=V1[17];//vertex6
            }
            else if(minDotIndex==3){// y- face
                q1x=V1[21]; q1y=V1[22]; q1z=V1[23];//vertex8
                q2x=V1[9]; q2y=V1[10]; q2z=V1[11];//vertex4
                q3x=V1[6]; q3y=V1[7]; q3z=V1[8];//vertex3
                q4x=V1[18]; q4y=V1[19]; q4z=V1[20];//vertex7
            }
            else if(minDotIndex==4){// z+ face
                q1x=V1[12]; q1y=V1[13]; q1z=V1[14];//vertex5
                q2x=V1[18]; q2y=V1[19]; q2z=V1[20];//vertex7
                q3x=V1[6]; q3y=V1[7]; q3z=V1[8];//vertex3
                q4x=V1[0]; q4y=V1[1]; q4z=V1[2];//vertex1
            }
            else if(minDotIndex==5){// z- face
                q1x=V1[3]; q1y=V1[4]; q1z=V1[5];//vertex2
                //2x=V1[6]; q2y=V1[7]; q2z=V1[8];//vertex4 !!!
                q2x=V2[9]; q2y=V2[10]; q2z=V2[11];//vertex4
                q3x=V1[21]; q3y=V1[22]; q3z=V1[23];//vertex8
                q4x=V1[15]; q4y=V1[16]; q4z=V1[17];//vertex6
            }

        }else{
            dot=a4x*nx+a4y*ny+a4z*nz;
            if(dot<minDot){
                minDot=dot;
                minDotIndex=0;
            }
            if(-dot<minDot){
                minDot=-dot;
                minDotIndex=1;
            }
            dot=a5x*nx+a5y*ny+a5z*nz;
            if(dot<minDot){
                minDot=dot;
                minDotIndex=2;
            }
            if(-dot<minDot){
                minDot=-dot;
                minDotIndex=3;
            }
            dot=a6x*nx+a6y*ny+a6z*nz;
            if(dot<minDot){
                minDot=dot;
                minDotIndex=4;
            }
            if(-dot<minDot){
                minDot=-dot;
                minDotIndex=5;
            }

            //______________________________________________________

            if(minDotIndex==0){// x+ face
                q1x=V2[0]; q1y=V2[1]; q1z=V2[2];//vertex1
                q2x=V2[6]; q2y=V2[7]; q2z=V2[8];//vertex3
                q3x=V2[9]; q3y=V2[10]; q3z=V2[11];//vertex4
                q4x=V2[3]; q4y=V2[4]; q4z=V2[5];//vertex2
            }
            else if(minDotIndex==1){// x- face
                q1x=V2[15]; q1y=V2[16]; q1z=V2[17];//vertex6
                q2x=V2[21]; q2y=V2[22]; q2z=V2[23]; //vertex8
                q3x=V2[18]; q3y=V2[19]; q3z=V2[20];//vertex7
                q4x=V2[12]; q4y=V2[13]; q4z=V2[14];//vertex5
            }
            else if(minDotIndex==2){// y+ face
                q1x=V2[12]; q1y=V2[13]; q1z=V2[14];//vertex5
                q2x=V2[0]; q2y=V2[1]; q2z=V2[2];//vertex1
                q3x=V2[3]; q3y=V2[4]; q3z=V2[5];//vertex2
                q4x=V2[15]; q4y=V2[16]; q4z=V2[17];//vertex6
            }
            else if(minDotIndex==3){// y- face
                q1x=V2[21]; q1y=V2[22]; q1z=V2[23];//vertex8
                q2x=V2[9]; q2y=V2[10]; q2z=V2[11];//vertex4
                q3x=V2[6]; q3y=V2[7]; q3z=V2[8];//vertex3
                q4x=V2[18]; q4y=V2[19]; q4z=V2[20];//vertex7
            }
            else if(minDotIndex==4){// z+ face
                q1x=V2[12]; q1y=V2[13]; q1z=V2[14];//vertex5
                q2x=V2[18]; q2y=V2[19]; q2z=V2[20];//vertex7
                q3x=V2[6]; q3y=V2[7]; q3z=V2[8];//vertex3
                q4x=V2[0]; q4y=V2[1]; q4z=V2[2];//vertex1
            }
            else if(minDotIndex==5){// z- face
                q1x=V2[3]; q1y=V2[4]; q1z=V2[5];//vertex2
                q2x=V2[9]; q2y=V2[10]; q2z=V2[11];//vertex4
                q3x=V2[21]; q3y=V2[22]; q3z=V2[23];//vertex8
                q4x=V2[15]; q4y=V2[16]; q4z=V2[17];//vertex6
            }
      
        }
        // clip vertices
        var numClipVertices;
        var numAddedClipVertices;
        var index;
        var x1;
        var y1;
        var z1;
        var x2;
        var y2;
        var z2;
        this.clipVertices1[0]=q1x;
        this.clipVertices1[1]=q1y;
        this.clipVertices1[2]=q1z;
        this.clipVertices1[3]=q2x;
        this.clipVertices1[4]=q2y;
        this.clipVertices1[5]=q2z;
        this.clipVertices1[6]=q3x;
        this.clipVertices1[7]=q3y;
        this.clipVertices1[8]=q3z;
        this.clipVertices1[9]=q4x;
        this.clipVertices1[10]=q4y;
        this.clipVertices1[11]=q4z;
        numAddedClipVertices=0;
        x1=this.clipVertices1[9];
        y1=this.clipVertices1[10];
        z1=this.clipVertices1[11];
        dot1=(x1-cx-s1x)*n1x+(y1-cy-s1y)*n1y+(z1-cz-s1z)*n1z;

        //var i = 4;
        //while(i--){
        for(var i=0;i<4;i++){
            index=i*3;
            x2=this.clipVertices1[index];
            y2=this.clipVertices1[index+1];
            z2=this.clipVertices1[index+2];
            dot2=(x2-cx-s1x)*n1x+(y2-cy-s1y)*n1y+(z2-cz-s1z)*n1z;
            if(dot1>0){
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices2[index]=x2;
                    this.clipVertices2[index+1]=y2;
                    this.clipVertices2[index+2]=z2;
                }else{
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices2[index]=x1+(x2-x1)*t;
                    this.clipVertices2[index+1]=y1+(y2-y1)*t;
                    this.clipVertices2[index+2]=z1+(z2-z1)*t;
                }
            }else{
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices2[index]=x1+(x2-x1)*t;
                    this.clipVertices2[index+1]=y1+(y2-y1)*t;
                    this.clipVertices2[index+2]=z1+(z2-z1)*t;
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices2[index]=x2;
                    this.clipVertices2[index+1]=y2;
                    this.clipVertices2[index+2]=z2;
                }
            }
            x1=x2;
            y1=y2;
            z1=z2;
            dot1=dot2;
        }

        numClipVertices=numAddedClipVertices;
        if(numClipVertices==0)return;
        numAddedClipVertices=0;
        index=(numClipVertices-1)*3;
        x1=this.clipVertices2[index];
        y1=this.clipVertices2[index+1];
        z1=this.clipVertices2[index+2];
        dot1=(x1-cx-s2x)*n2x+(y1-cy-s2y)*n2y+(z1-cz-s2z)*n2z;

        //i = numClipVertices;
        //while(i--){
        for(i=0;i<numClipVertices;i++){
            index=i*3;
            x2=this.clipVertices2[index];
            y2=this.clipVertices2[index+1];
            z2=this.clipVertices2[index+2];
            dot2=(x2-cx-s2x)*n2x+(y2-cy-s2y)*n2y+(z2-cz-s2z)*n2z;
            if(dot1>0){
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices1[index]=x2;
                    this.clipVertices1[index+1]=y2;
                    this.clipVertices1[index+2]=z2;
                }else{
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices1[index]=x1+(x2-x1)*t;
                    this.clipVertices1[index+1]=y1+(y2-y1)*t;
                    this.clipVertices1[index+2]=z1+(z2-z1)*t;
                }
            }else{
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices1[index]=x1+(x2-x1)*t;
                    this.clipVertices1[index+1]=y1+(y2-y1)*t;
                    this.clipVertices1[index+2]=z1+(z2-z1)*t;
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices1[index]=x2;
                    this.clipVertices1[index+1]=y2;
                    this.clipVertices1[index+2]=z2;
                }
            }
            x1=x2;
            y1=y2;
            z1=z2;
            dot1=dot2;
        }

        numClipVertices=numAddedClipVertices;
        if(numClipVertices==0)return;
        numAddedClipVertices=0;
        index=(numClipVertices-1)*3;
        x1=this.clipVertices1[index];
        y1=this.clipVertices1[index+1];
        z1=this.clipVertices1[index+2];
        dot1=(x1-cx+s1x)*-n1x+(y1-cy+s1y)*-n1y+(z1-cz+s1z)*-n1z;

        //i = numClipVertices;
        //while(i--){
        for(i=0;i<numClipVertices;i++){
            index=i*3;
            x2=this.clipVertices1[index];
            y2=this.clipVertices1[index+1];
            z2=this.clipVertices1[index+2];
            dot2=(x2-cx+s1x)*-n1x+(y2-cy+s1y)*-n1y+(z2-cz+s1z)*-n1z;
            if(dot1>0){
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices2[index]=x2;
                    this.clipVertices2[index+1]=y2;
                    this.clipVertices2[index+2]=z2;
                }else{
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices2[index]=x1+(x2-x1)*t;
                    this.clipVertices2[index+1]=y1+(y2-y1)*t;
                    this.clipVertices2[index+2]=z1+(z2-z1)*t;
                }
            }else{
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices2[index]=x1+(x2-x1)*t;
                    this.clipVertices2[index+1]=y1+(y2-y1)*t;
                    this.clipVertices2[index+2]=z1+(z2-z1)*t;
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices2[index]=x2;
                    this.clipVertices2[index+1]=y2;
                    this.clipVertices2[index+2]=z2;
                }
            }
            x1=x2;
            y1=y2;
            z1=z2;
            dot1=dot2;
        }

        numClipVertices=numAddedClipVertices;
        if(numClipVertices==0)return;
        numAddedClipVertices=0;
        index=(numClipVertices-1)*3;
        x1=this.clipVertices2[index];
        y1=this.clipVertices2[index+1];
        z1=this.clipVertices2[index+2];
        dot1=(x1-cx+s2x)*-n2x+(y1-cy+s2y)*-n2y+(z1-cz+s2z)*-n2z;

        //i = numClipVertices;
        //while(i--){
        for(i=0;i<numClipVertices;i++){
            index=i*3;
            x2=this.clipVertices2[index];
            y2=this.clipVertices2[index+1];
            z2=this.clipVertices2[index+2];
            dot2=(x2-cx+s2x)*-n2x+(y2-cy+s2y)*-n2y+(z2-cz+s2z)*-n2z;
            if(dot1>0){
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices1[index]=x2;
                    this.clipVertices1[index+1]=y2;
                    this.clipVertices1[index+2]=z2;
                }else{
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices1[index]=x1+(x2-x1)*t;
                    this.clipVertices1[index+1]=y1+(y2-y1)*t;
                    this.clipVertices1[index+2]=z1+(z2-z1)*t;
                }
            }else{
                if(dot2>0){
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    t=dot1/(dot1-dot2);
                    this.clipVertices1[index]=x1+(x2-x1)*t;
                    this.clipVertices1[index+1]=y1+(y2-y1)*t;
                    this.clipVertices1[index+2]=z1+(z2-z1)*t;
                    index=numAddedClipVertices*3;
                    numAddedClipVertices++;
                    this.clipVertices1[index]=x2;
                    this.clipVertices1[index+1]=y2;
                    this.clipVertices1[index+2]=z2;
                }
            }
            x1=x2;
            y1=y2;
            z1=z2;
            dot1=dot2;
        }

        numClipVertices=numAddedClipVertices;
        if(swap){
            var tb=b1;
            b1=b2;
            b2=tb;
        }
        if(numClipVertices==0)return;
        var flipped=b1!=shape1;
        if(numClipVertices>4){
            x1=(q1x+q2x+q3x+q4x)*0.25;
            y1=(q1y+q2y+q3y+q4y)*0.25;
            z1=(q1z+q2z+q3z+q4z)*0.25;
            n1x=q1x-x1;
            n1y=q1y-y1;
            n1z=q1z-z1;
            n2x=q2x-x1;
            n2y=q2y-y1;
            n2z=q2z-z1;
            var index1=0;
            var index2=0;
            var index3=0;
            var index4=0;
            var maxDot=-this.INF;
            minDot=this.INF;

            //i = numClipVertices;
            //while(i--){
            for(i=0;i<numClipVertices;i++){
                this.used[i]=false;
                index=i*3;
                x1=this.clipVertices1[index];
                y1=this.clipVertices1[index+1];
                z1=this.clipVertices1[index+2];
                dot=x1*n1x+y1*n1y+z1*n1z;
                if(dot<minDot){
                    minDot=dot;
                    index1=i;
                }
                if(dot>maxDot){
                    maxDot=dot;
                    index3=i;
                }
            }

            this.used[index1]=true;
            this.used[index3]=true;
            maxDot=-this.INF;
            minDot=this.INF;

            //i = numClipVertices;
            //while(i--){
            for(i=0;i<numClipVertices;i++){
                if(this.used[i])continue;
                index=i*3;
                x1=this.clipVertices1[index];
                y1=this.clipVertices1[index+1];
                z1=this.clipVertices1[index+2];
                dot=x1*n2x+y1*n2y+z1*n2z;
                if(dot<minDot){
                    minDot=dot;
                    index2=i;
                }
                if(dot>maxDot){
                    maxDot=dot;
                    index4=i;
                }
            }

            index=index1*3;
            x1=this.clipVertices1[index];
            y1=this.clipVertices1[index+1];
            z1=this.clipVertices1[index+2];
            dot=(x1-cx)*nx+(y1-cy)*ny+(z1-cz)*nz;
            if(dot<0) manifold.addPoint(x1,y1,z1,nx,ny,nz,dot,flipped);
            
            index=index2*3;
            x1=this.clipVertices1[index];
            y1=this.clipVertices1[index+1];
            z1=this.clipVertices1[index+2];
            dot=(x1-cx)*nx+(y1-cy)*ny+(z1-cz)*nz;
            if(dot<0) manifold.addPoint(x1,y1,z1,nx,ny,nz,dot,flipped);
            
            index=index3*3;
            x1=this.clipVertices1[index];
            y1=this.clipVertices1[index+1];
            z1=this.clipVertices1[index+2];
            dot=(x1-cx)*nx+(y1-cy)*ny+(z1-cz)*nz;
            if(dot<0) manifold.addPoint(x1,y1,z1,nx,ny,nz,dot,flipped);
            
            index=index4*3;
            x1=this.clipVertices1[index];
            y1=this.clipVertices1[index+1];
            z1=this.clipVertices1[index+2];
            dot=(x1-cx)*nx+(y1-cy)*ny+(z1-cz)*nz;
            if(dot<0) manifold.addPoint(x1,y1,z1,nx,ny,nz,dot,flipped);
            
        }else{
            //i = numClipVertices;
            //while(i--){
            for(i=0;i<numClipVertices;i++){
                index=i*3;
                x1=this.clipVertices1[index];
                y1=this.clipVertices1[index+1];
                z1=this.clipVertices1[index+2];
                dot=(x1-cx)*nx+(y1-cy)*ny+(z1-cz)*nz;
                if(dot<0)manifold.addPoint(x1,y1,z1,nx,ny,nz,dot,flipped);
            }
        }

    }

});

function BoxCylinderCollisionDetector (flip){

    CollisionDetector.call( this );
    this.flip = flip;

}

BoxCylinderCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: BoxCylinderCollisionDetector,

    getSep: function ( c1, c2, sep, pos, dep ) {

        var t1x;
        var t1y;
        var t1z;
        var t2x;
        var t2y;
        var t2z;
        var sup=new Vec3();
        var len;
        var p1x;
        var p1y;
        var p1z;
        var p2x;
        var p2y;
        var p2z;
        var v01x=c1.position.x;
        var v01y=c1.position.y;
        var v01z=c1.position.z;
        var v02x=c2.position.x;
        var v02y=c2.position.y;
        var v02z=c2.position.z;
        var v0x=v02x-v01x;
        var v0y=v02y-v01y;
        var v0z=v02z-v01z;
        if(v0x*v0x+v0y*v0y+v0z*v0z==0)v0y=0.001;
        var nx=-v0x;
        var ny=-v0y;
        var nz=-v0z;
        this.supportPointB(c1,-nx,-ny,-nz,sup);
        var v11x=sup.x;
        var v11y=sup.y;
        var v11z=sup.z;
        this.supportPointC(c2,nx,ny,nz,sup);
        var v12x=sup.x;
        var v12y=sup.y;
        var v12z=sup.z;
        var v1x=v12x-v11x;
        var v1y=v12y-v11y;
        var v1z=v12z-v11z;
        if(v1x*nx+v1y*ny+v1z*nz<=0){
        return false;
        }
        nx=v1y*v0z-v1z*v0y;
        ny=v1z*v0x-v1x*v0z;
        nz=v1x*v0y-v1y*v0x;
        if(nx*nx+ny*ny+nz*nz==0){
        sep.set( v1x-v0x, v1y-v0y, v1z-v0z ).normalize();
        pos.set( (v11x+v12x)*0.5, (v11y+v12y)*0.5, (v11z+v12z)*0.5 );
        return true;
        }
        this.supportPointB(c1,-nx,-ny,-nz,sup);
        var v21x=sup.x;
        var v21y=sup.y;
        var v21z=sup.z;
        this.supportPointC(c2,nx,ny,nz,sup);
        var v22x=sup.x;
        var v22y=sup.y;
        var v22z=sup.z;
        var v2x=v22x-v21x;
        var v2y=v22y-v21y;
        var v2z=v22z-v21z;
        if(v2x*nx+v2y*ny+v2z*nz<=0){
        return false;
        }
        t1x=v1x-v0x;
        t1y=v1y-v0y;
        t1z=v1z-v0z;
        t2x=v2x-v0x;
        t2y=v2y-v0y;
        t2z=v2z-v0z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        if(nx*v0x+ny*v0y+nz*v0z>0){
        t1x=v1x;
        t1y=v1y;
        t1z=v1z;
        v1x=v2x;
        v1y=v2y;
        v1z=v2z;
        v2x=t1x;
        v2y=t1y;
        v2z=t1z;
        t1x=v11x;
        t1y=v11y;
        t1z=v11z;
        v11x=v21x;
        v11y=v21y;
        v11z=v21z;
        v21x=t1x;
        v21y=t1y;
        v21z=t1z;
        t1x=v12x;
        t1y=v12y;
        t1z=v12z;
        v12x=v22x;
        v12y=v22y;
        v12z=v22z;
        v22x=t1x;
        v22y=t1y;
        v22z=t1z;
        nx=-nx;
        ny=-ny;
        nz=-nz;
        }
        var iterations=0;
        while(true){
        if(++iterations>100){
        return false;
        }
        this.supportPointB(c1,-nx,-ny,-nz,sup);
        var v31x=sup.x;
        var v31y=sup.y;
        var v31z=sup.z;
        this.supportPointC(c2,nx,ny,nz,sup);
        var v32x=sup.x;
        var v32y=sup.y;
        var v32z=sup.z;
        var v3x=v32x-v31x;
        var v3y=v32y-v31y;
        var v3z=v32z-v31z;
        if(v3x*nx+v3y*ny+v3z*nz<=0){
        return false;
        }
        if((v1y*v3z-v1z*v3y)*v0x+(v1z*v3x-v1x*v3z)*v0y+(v1x*v3y-v1y*v3x)*v0z<0){
        v2x=v3x;
        v2y=v3y;
        v2z=v3z;
        v21x=v31x;
        v21y=v31y;
        v21z=v31z;
        v22x=v32x;
        v22y=v32y;
        v22z=v32z;
        t1x=v1x-v0x;
        t1y=v1y-v0y;
        t1z=v1z-v0z;
        t2x=v3x-v0x;
        t2y=v3y-v0y;
        t2z=v3z-v0z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        continue;
        }
        if((v3y*v2z-v3z*v2y)*v0x+(v3z*v2x-v3x*v2z)*v0y+(v3x*v2y-v3y*v2x)*v0z<0){
        v1x=v3x;
        v1y=v3y;
        v1z=v3z;
        v11x=v31x;
        v11y=v31y;
        v11z=v31z;
        v12x=v32x;
        v12y=v32y;
        v12z=v32z;
        t1x=v3x-v0x;
        t1y=v3y-v0y;
        t1z=v3z-v0z;
        t2x=v2x-v0x;
        t2y=v2y-v0y;
        t2z=v2z-v0z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        continue;
        }
        var hit=false;
        while(true){
        t1x=v2x-v1x;
        t1y=v2y-v1y;
        t1z=v2z-v1z;
        t2x=v3x-v1x;
        t2y=v3y-v1y;
        t2z=v3z-v1z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        len=1/_Math.sqrt(nx*nx+ny*ny+nz*nz);
        nx*=len;
        ny*=len;
        nz*=len;
        if(nx*v1x+ny*v1y+nz*v1z>=0&&!hit){
        var b0=(v1y*v2z-v1z*v2y)*v3x+(v1z*v2x-v1x*v2z)*v3y+(v1x*v2y-v1y*v2x)*v3z;
        var b1=(v3y*v2z-v3z*v2y)*v0x+(v3z*v2x-v3x*v2z)*v0y+(v3x*v2y-v3y*v2x)*v0z;
        var b2=(v0y*v1z-v0z*v1y)*v3x+(v0z*v1x-v0x*v1z)*v3y+(v0x*v1y-v0y*v1x)*v3z;
        var b3=(v2y*v1z-v2z*v1y)*v0x+(v2z*v1x-v2x*v1z)*v0y+(v2x*v1y-v2y*v1x)*v0z;
        var sum=b0+b1+b2+b3;
        if(sum<=0){
        b0=0;
        b1=(v2y*v3z-v2z*v3y)*nx+(v2z*v3x-v2x*v3z)*ny+(v2x*v3y-v2y*v3x)*nz;
        b2=(v3y*v2z-v3z*v2y)*nx+(v3z*v2x-v3x*v2z)*ny+(v3x*v2y-v3y*v2x)*nz;
        b3=(v1y*v2z-v1z*v2y)*nx+(v1z*v2x-v1x*v2z)*ny+(v1x*v2y-v1y*v2x)*nz;
        sum=b1+b2+b3;
        }
        var inv=1/sum;
        p1x=(v01x*b0+v11x*b1+v21x*b2+v31x*b3)*inv;
        p1y=(v01y*b0+v11y*b1+v21y*b2+v31y*b3)*inv;
        p1z=(v01z*b0+v11z*b1+v21z*b2+v31z*b3)*inv;
        p2x=(v02x*b0+v12x*b1+v22x*b2+v32x*b3)*inv;
        p2y=(v02y*b0+v12y*b1+v22y*b2+v32y*b3)*inv;
        p2z=(v02z*b0+v12z*b1+v22z*b2+v32z*b3)*inv;
        hit=true;
        }
        this.supportPointB(c1,-nx,-ny,-nz,sup);
        var v41x=sup.x;
        var v41y=sup.y;
        var v41z=sup.z;
        this.supportPointC(c2,nx,ny,nz,sup);
        var v42x=sup.x;
        var v42y=sup.y;
        var v42z=sup.z;
        var v4x=v42x-v41x;
        var v4y=v42y-v41y;
        var v4z=v42z-v41z;
        var separation=-(v4x*nx+v4y*ny+v4z*nz);
        if((v4x-v3x)*nx+(v4y-v3y)*ny+(v4z-v3z)*nz<=0.01||separation>=0){
        if(hit){
        sep.set( -nx, -ny, -nz );
        pos.set( (p1x+p2x)*0.5, (p1y+p2y)*0.5, (p1z+p2z)*0.5 );
        dep.x=separation;
        return true;
        }
        return false;
        }
        if(
        (v4y*v1z-v4z*v1y)*v0x+
        (v4z*v1x-v4x*v1z)*v0y+
        (v4x*v1y-v4y*v1x)*v0z<0
        ){
        if(
        (v4y*v2z-v4z*v2y)*v0x+
        (v4z*v2x-v4x*v2z)*v0y+
        (v4x*v2y-v4y*v2x)*v0z<0
        ){
        v1x=v4x;
        v1y=v4y;
        v1z=v4z;
        v11x=v41x;
        v11y=v41y;
        v11z=v41z;
        v12x=v42x;
        v12y=v42y;
        v12z=v42z;
        }else{
        v3x=v4x;
        v3y=v4y;
        v3z=v4z;
        v31x=v41x;
        v31y=v41y;
        v31z=v41z;
        v32x=v42x;
        v32y=v42y;
        v32z=v42z;
        }
        }else{
        if(
        (v4y*v3z-v4z*v3y)*v0x+
        (v4z*v3x-v4x*v3z)*v0y+
        (v4x*v3y-v4y*v3x)*v0z<0
        ){
        v2x=v4x;
        v2y=v4y;
        v2z=v4z;
        v21x=v41x;
        v21y=v41y;
        v21z=v41z;
        v22x=v42x;
        v22y=v42y;
        v22z=v42z;
        }else{
        v1x=v4x;
        v1y=v4y;
        v1z=v4z;
        v11x=v41x;
        v11y=v41y;
        v11z=v41z;
        v12x=v42x;
        v12y=v42y;
        v12z=v42z;
    }
    }
    }
    }
    //return false;
    },

    supportPointB: function( c, dx, dy, dz, out ) {

        var rot=c.rotation.elements;
        var ldx=rot[0]*dx+rot[3]*dy+rot[6]*dz;
        var ldy=rot[1]*dx+rot[4]*dy+rot[7]*dz;
        var ldz=rot[2]*dx+rot[5]*dy+rot[8]*dz;
        var w=c.halfWidth;
        var h=c.halfHeight;
        var d=c.halfDepth;
        var ox;
        var oy;
        var oz;
        if(ldx<0)ox=-w;
        else ox=w;
        if(ldy<0)oy=-h;
        else oy=h;
        if(ldz<0)oz=-d;
        else oz=d;
        ldx=rot[0]*ox+rot[1]*oy+rot[2]*oz+c.position.x;
        ldy=rot[3]*ox+rot[4]*oy+rot[5]*oz+c.position.y;
        ldz=rot[6]*ox+rot[7]*oy+rot[8]*oz+c.position.z;
        out.set( ldx, ldy, ldz );

    },

    supportPointC: function ( c, dx, dy, dz, out ) {

        var rot=c.rotation.elements;
        var ldx=rot[0]*dx+rot[3]*dy+rot[6]*dz;
        var ldy=rot[1]*dx+rot[4]*dy+rot[7]*dz;
        var ldz=rot[2]*dx+rot[5]*dy+rot[8]*dz;
        var radx=ldx;
        var radz=ldz;
        var len=radx*radx+radz*radz;
        var rad=c.radius;
        var hh=c.halfHeight;
        var ox;
        var oy;
        var oz;
        if(len==0){
        if(ldy<0){
        ox=rad;
        oy=-hh;
        oz=0;
        }else{
        ox=rad;
        oy=hh;
        oz=0;
        }
        }else{
        len=c.radius/_Math.sqrt(len);
        if(ldy<0){
        ox=radx*len;
        oy=-hh;
        oz=radz*len;
        }else{
        ox=radx*len;
        oy=hh;
        oz=radz*len;
        }
        }
        ldx=rot[0]*ox+rot[1]*oy+rot[2]*oz+c.position.x;
        ldy=rot[3]*ox+rot[4]*oy+rot[5]*oz+c.position.y;
        ldz=rot[6]*ox+rot[7]*oy+rot[8]*oz+c.position.z;
        out.set( ldx, ldy, ldz );

    },

    detectCollision: function( shape1, shape2, manifold ) {

        var b;
        var c;
        if(this.flip){
        b=shape2;
        c=shape1;
        }else{
        b=shape1;
        c=shape2;
        }
        var sep=new Vec3();
        var pos=new Vec3();
        var dep=new Vec3();

        if(!this.getSep(b,c,sep,pos,dep))return;
        var pbx=b.position.x;
        var pby=b.position.y;
        var pbz=b.position.z;
        var pcx=c.position.x;
        var pcy=c.position.y;
        var pcz=c.position.z;
        var bw=b.halfWidth;
        var bh=b.halfHeight;
        var bd=b.halfDepth;
        var ch=c.halfHeight;
        var r=c.radius;

        var D = b.dimentions;

        var nwx=D[0];//b.normalDirectionWidth.x;
        var nwy=D[1];//b.normalDirectionWidth.y;
        var nwz=D[2];//b.normalDirectionWidth.z;
        var nhx=D[3];//b.normalDirectionHeight.x;
        var nhy=D[4];//b.normalDirectionHeight.y;
        var nhz=D[5];//b.normalDirectionHeight.z;
        var ndx=D[6];//b.normalDirectionDepth.x;
        var ndy=D[7];//b.normalDirectionDepth.y;
        var ndz=D[8];//b.normalDirectionDepth.z;

        var dwx=D[9];//b.halfDirectionWidth.x;
        var dwy=D[10];//b.halfDirectionWidth.y;
        var dwz=D[11];//b.halfDirectionWidth.z;
        var dhx=D[12];//b.halfDirectionHeight.x;
        var dhy=D[13];//b.halfDirectionHeight.y;
        var dhz=D[14];//b.halfDirectionHeight.z;
        var ddx=D[15];//b.halfDirectionDepth.x;
        var ddy=D[16];//b.halfDirectionDepth.y;
        var ddz=D[17];//b.halfDirectionDepth.z;

        var ncx=c.normalDirection.x;
        var ncy=c.normalDirection.y;
        var ncz=c.normalDirection.z;
        var dcx=c.halfDirection.x;
        var dcy=c.halfDirection.y;
        var dcz=c.halfDirection.z;
        var nx=sep.x;
        var ny=sep.y;
        var nz=sep.z;
        var dotw=nx*nwx+ny*nwy+nz*nwz;
        var doth=nx*nhx+ny*nhy+nz*nhz;
        var dotd=nx*ndx+ny*ndy+nz*ndz;
        var dotc=nx*ncx+ny*ncy+nz*ncz;
        var right1=dotw>0;
        var right2=doth>0;
        var right3=dotd>0;
        var right4=dotc>0;
        if(!right1)dotw=-dotw;
        if(!right2)doth=-doth;
        if(!right3)dotd=-dotd;
        if(!right4)dotc=-dotc;
        var state=0;
        if(dotc>0.999){
        if(dotw>0.999){
        if(dotw>dotc)state=1;
        else state=4;
        }else if(doth>0.999){
        if(doth>dotc)state=2;
        else state=4;
        }else if(dotd>0.999){
        if(dotd>dotc)state=3;
        else state=4;
        }else state=4;
        }else{
        if(dotw>0.999)state=1;
        else if(doth>0.999)state=2;
        else if(dotd>0.999)state=3;
        }
        var cbx;
        var cby;
        var cbz;
        var ccx;
        var ccy;
        var ccz;
        var r00;
        var r01;
        var r02;
        var r10;
        var r11;
        var r12;
        var r20;
        var r21;
        var r22;
        var px;
        var py;
        var pz;
        var pd;
        var dot;
        var len;
        var tx;
        var ty;
        var tz;
        var td;
        var dx;
        var dy;
        var dz;
        var d1x;
        var d1y;
        var d1z;
        var d2x;
        var d2y;
        var d2z;
        var sx;
        var sy;
        var sz;
        var sd;
        var ex;
        var ey;
        var ez;
        var ed;
        var dot1;
        var dot2;
        var t1;
        var dir1x;
        var dir1y;
        var dir1z;
        var dir2x;
        var dir2y;
        var dir2z;
        var dir1l;
        var dir2l;
        if(state==0){
        //manifold.addPoint(pos.x,pos.y,pos.z,nx,ny,nz,dep.x,b,c,0,0,false);
        manifold.addPoint(pos.x,pos.y,pos.z,nx,ny,nz,dep.x,this.flip);
        }else if(state==4){
        if(right4){
        ccx=pcx-dcx;
        ccy=pcy-dcy;
        ccz=pcz-dcz;
        nx=-ncx;
        ny=-ncy;
        nz=-ncz;
        }else{
        ccx=pcx+dcx;
        ccy=pcy+dcy;
        ccz=pcz+dcz;
        nx=ncx;
        ny=ncy;
        nz=ncz;
        }
        var v1x;
        var v1y;
        var v1z;
        var v2x;
        var v2y;
        var v2z;
        var v3x;
        var v3y;
        var v3z;
        var v4x;
        var v4y;
        var v4z;
        
        dot=1;
        state=0;
        dot1=nwx*nx+nwy*ny+nwz*nz;
        if(dot1<dot){
        dot=dot1;
        state=0;
        }
        if(-dot1<dot){
        dot=-dot1;
        state=1;
        }
        dot1=nhx*nx+nhy*ny+nhz*nz;
        if(dot1<dot){
        dot=dot1;
        state=2;
        }
        if(-dot1<dot){
        dot=-dot1;
        state=3;
        }
        dot1=ndx*nx+ndy*ny+ndz*nz;
        if(dot1<dot){
        dot=dot1;
        state=4;
        }
        if(-dot1<dot){
        dot=-dot1;
        state=5;
        }
        var v = b.elements;
        switch(state){
        case 0:
        //v=b.vertex1;
        v1x=v[0];//v.x;
        v1y=v[1];//v.y;
        v1z=v[2];//v.z;
        //v=b.vertex3;
        v2x=v[6];//v.x;
        v2y=v[7];//v.y;
        v2z=v[8];//v.z;
        //v=b.vertex4;
        v3x=v[9];//v.x;
        v3y=v[10];//v.y;
        v3z=v[11];//v.z;
        //v=b.vertex2;
        v4x=v[3];//v.x;
        v4y=v[4];//v.y;
        v4z=v[5];//v.z;
        break;
        case 1:
        //v=b.vertex6;
        v1x=v[15];//v.x;
        v1y=v[16];//v.y;
        v1z=v[17];//v.z;
        //v=b.vertex8;
        v2x=v[21];//v.x;
        v2y=v[22];//v.y;
        v2z=v[23];//v.z;
        //v=b.vertex7;
        v3x=v[18];//v.x;
        v3y=v[19];//v.y;
        v3z=v[20];//v.z;
        //v=b.vertex5;
        v4x=v[12];//v.x;
        v4y=v[13];//v.y;
        v4z=v[14];//v.z;
        break;
        case 2:
        //v=b.vertex5;
        v1x=v[12];//v.x;
        v1y=v[13];//v.y;
        v1z=v[14];//v.z;
        //v=b.vertex1;
        v2x=v[0];//v.x;
        v2y=v[1];//v.y;
        v2z=v[2];//v.z;
        //v=b.vertex2;
        v3x=v[3];//v.x;
        v3y=v[4];//v.y;
        v3z=v[5];//v.z;
        //v=b.vertex6;
        v4x=v[15];//v.x;
        v4y=v[16];//v.y;
        v4z=v[17];//v.z;
        break;
        case 3:
        //v=b.vertex8;
        v1x=v[21];//v.x;
        v1y=v[22];//v.y;
        v1z=v[23];//v.z;
        //v=b.vertex4;
        v2x=v[9];//v.x;
        v2y=v[10];//v.y;
        v2z=v[11];//v.z;
        //v=b.vertex3;
        v3x=v[6];//v.x;
        v3y=v[7];//v.y;
        v3z=v[8];//v.z;
        //v=b.vertex7;
        v4x=v[18];//v.x;
        v4y=v[19];//v.y;
        v4z=v[20];//v.z;
        break;
        case 4:
        //v=b.vertex5;
        v1x=v[12];//v.x;
        v1y=v[13];//v.y;
        v1z=v[14];//v.z;
        //v=b.vertex7;
        v2x=v[18];//v.x;
        v2y=v[19];//v.y;
        v2z=v[20];//v.z;
        //v=b.vertex3;
        v3x=v[6];//v.x;
        v3y=v[7];//v.y;
        v3z=v[8];//v.z;
        //v=b.vertex1;
        v4x=v[0];//v.x;
        v4y=v[1];//v.y;
        v4z=v[2];//v.z;
        break;
        case 5:
        //v=b.vertex2;
        v1x=v[3];//v.x;
        v1y=v[4];//v.y;
        v1z=v[5];//v.z;
        //v=b.vertex4;
        v2x=v[9];//v.x;
        v2y=v[10];//v.y;
        v2z=v[11];//v.z;
        //v=b.vertex8;
        v3x=v[21];//v.x;
        v3y=v[22];//v.y;
        v3z=v[23];//v.z;
        //v=b.vertex6;
        v4x=v[15];//v.x;
        v4y=v[16];//v.y;
        v4z=v[17];//v.z;
        break;
        }
        pd=nx*(v1x-ccx)+ny*(v1y-ccy)+nz*(v1z-ccz);
        if(pd<=0)manifold.addPoint(v1x,v1y,v1z,-nx,-ny,-nz,pd,this.flip);
        pd=nx*(v2x-ccx)+ny*(v2y-ccy)+nz*(v2z-ccz);
        if(pd<=0)manifold.addPoint(v2x,v2y,v2z,-nx,-ny,-nz,pd,this.flip);
        pd=nx*(v3x-ccx)+ny*(v3y-ccy)+nz*(v3z-ccz);
        if(pd<=0)manifold.addPoint(v3x,v3y,v3z,-nx,-ny,-nz,pd,this.flip);
        pd=nx*(v4x-ccx)+ny*(v4y-ccy)+nz*(v4z-ccz);
        if(pd<=0)manifold.addPoint(v4x,v4y,v4z,-nx,-ny,-nz,pd,this.flip);
        }else{
        switch(state){
        case 1:
        if(right1){
        cbx=pbx+dwx;
        cby=pby+dwy;
        cbz=pbz+dwz;
        nx=nwx;
        ny=nwy;
        nz=nwz;
        }else{
        cbx=pbx-dwx;
        cby=pby-dwy;
        cbz=pbz-dwz;
        nx=-nwx;
        ny=-nwy;
        nz=-nwz;
        }
        dir1x=nhx;
        dir1y=nhy;
        dir1z=nhz;
        dir1l=bh;
        dir2x=ndx;
        dir2y=ndy;
        dir2z=ndz;
        dir2l=bd;
        break;
        case 2:
        if(right2){
        cbx=pbx+dhx;
        cby=pby+dhy;
        cbz=pbz+dhz;
        nx=nhx;
        ny=nhy;
        nz=nhz;
        }else{
        cbx=pbx-dhx;
        cby=pby-dhy;
        cbz=pbz-dhz;
        nx=-nhx;
        ny=-nhy;
        nz=-nhz;
        }
        dir1x=nwx;
        dir1y=nwy;
        dir1z=nwz;
        dir1l=bw;
        dir2x=ndx;
        dir2y=ndy;
        dir2z=ndz;
        dir2l=bd;
        break;
        case 3:
        if(right3){
        cbx=pbx+ddx;
        cby=pby+ddy;
        cbz=pbz+ddz;
        nx=ndx;
        ny=ndy;
        nz=ndz;
        }else{
        cbx=pbx-ddx;
        cby=pby-ddy;
        cbz=pbz-ddz;
        nx=-ndx;
        ny=-ndy;
        nz=-ndz;
        }
        dir1x=nwx;
        dir1y=nwy;
        dir1z=nwz;
        dir1l=bw;
        dir2x=nhx;
        dir2y=nhy;
        dir2z=nhz;
        dir2l=bh;
        break;
        }
        dot=nx*ncx+ny*ncy+nz*ncz;
        if(dot<0)len=ch;
        else len=-ch;
        ccx=pcx+len*ncx;
        ccy=pcy+len*ncy;
        ccz=pcz+len*ncz;
        if(dotc>=0.999999){
        tx=-ny;
        ty=nz;
        tz=nx;
        }else{
        tx=nx;
        ty=ny;
        tz=nz;
        }
        len=tx*ncx+ty*ncy+tz*ncz;
        dx=len*ncx-tx;
        dy=len*ncy-ty;
        dz=len*ncz-tz;
        len=_Math.sqrt(dx*dx+dy*dy+dz*dz);
        if(len==0)return;
        len=r/len;
        dx*=len;
        dy*=len;
        dz*=len;
        tx=ccx+dx;
        ty=ccy+dy;
        tz=ccz+dz;
        if(dot<-0.96||dot>0.96){
        r00=ncx*ncx*1.5-0.5;
        r01=ncx*ncy*1.5-ncz*0.866025403;
        r02=ncx*ncz*1.5+ncy*0.866025403;
        r10=ncy*ncx*1.5+ncz*0.866025403;
        r11=ncy*ncy*1.5-0.5;
        r12=ncy*ncz*1.5-ncx*0.866025403;
        r20=ncz*ncx*1.5-ncy*0.866025403;
        r21=ncz*ncy*1.5+ncx*0.866025403;
        r22=ncz*ncz*1.5-0.5;
        px=tx;
        py=ty;
        pz=tz;
        pd=nx*(px-cbx)+ny*(py-cby)+nz*(pz-cbz);
        tx=px-pd*nx-cbx;
        ty=py-pd*ny-cby;
        tz=pz-pd*nz-cbz;
        sd=dir1x*tx+dir1y*ty+dir1z*tz;
        ed=dir2x*tx+dir2y*ty+dir2z*tz;
        if(sd<-dir1l)sd=-dir1l;
        else if(sd>dir1l)sd=dir1l;
        if(ed<-dir2l)ed=-dir2l;
        else if(ed>dir2l)ed=dir2l;
        tx=sd*dir1x+ed*dir2x;
        ty=sd*dir1y+ed*dir2y;
        tz=sd*dir1z+ed*dir2z;
        px=cbx+tx;
        py=cby+ty;
        pz=cbz+tz;
        manifold.addPoint(px,py,pz,nx,ny,nz,pd,this.flip);
        px=dx*r00+dy*r01+dz*r02;
        py=dx*r10+dy*r11+dz*r12;
        pz=dx*r20+dy*r21+dz*r22;
        px=(dx=px)+ccx;
        py=(dy=py)+ccy;
        pz=(dz=pz)+ccz;
        pd=nx*(px-cbx)+ny*(py-cby)+nz*(pz-cbz);
        if(pd<=0){
        tx=px-pd*nx-cbx;
        ty=py-pd*ny-cby;
        tz=pz-pd*nz-cbz;
        sd=dir1x*tx+dir1y*ty+dir1z*tz;
        ed=dir2x*tx+dir2y*ty+dir2z*tz;
        if(sd<-dir1l)sd=-dir1l;
        else if(sd>dir1l)sd=dir1l;
        if(ed<-dir2l)ed=-dir2l;
        else if(ed>dir2l)ed=dir2l;
        tx=sd*dir1x+ed*dir2x;
        ty=sd*dir1y+ed*dir2y;
        tz=sd*dir1z+ed*dir2z;
        px=cbx+tx;
        py=cby+ty;
        pz=cbz+tz;
        //manifold.addPoint(px,py,pz,nx,ny,nz,pd,b,c,2,0,false);
        manifold.addPoint(px,py,pz,nx,ny,nz,pd,this.flip);
        }
        px=dx*r00+dy*r01+dz*r02;
        py=dx*r10+dy*r11+dz*r12;
        pz=dx*r20+dy*r21+dz*r22;
        px=(dx=px)+ccx;
        py=(dy=py)+ccy;
        pz=(dz=pz)+ccz;
        pd=nx*(px-cbx)+ny*(py-cby)+nz*(pz-cbz);
        if(pd<=0){
        tx=px-pd*nx-cbx;
        ty=py-pd*ny-cby;
        tz=pz-pd*nz-cbz;
        sd=dir1x*tx+dir1y*ty+dir1z*tz;
        ed=dir2x*tx+dir2y*ty+dir2z*tz;
        if(sd<-dir1l)sd=-dir1l;
        else if(sd>dir1l)sd=dir1l;
        if(ed<-dir2l)ed=-dir2l;
        else if(ed>dir2l)ed=dir2l;
        tx=sd*dir1x+ed*dir2x;
        ty=sd*dir1y+ed*dir2y;
        tz=sd*dir1z+ed*dir2z;
        px=cbx+tx;
        py=cby+ty;
        pz=cbz+tz;
        //manifold.addPoint(px,py,pz,nx,ny,nz,pd,b,c,3,0,false);
        manifold.addPoint(px,py,pz,nx,ny,nz,pd,this.flip);
        }
        }else{
        sx=tx;
        sy=ty;
        sz=tz;
        sd=nx*(sx-cbx)+ny*(sy-cby)+nz*(sz-cbz);
        sx-=sd*nx;
        sy-=sd*ny;
        sz-=sd*nz;
        if(dot>0){
        ex=tx+dcx*2;
        ey=ty+dcy*2;
        ez=tz+dcz*2;
        }else{
        ex=tx-dcx*2;
        ey=ty-dcy*2;
        ez=tz-dcz*2;
        }
        ed=nx*(ex-cbx)+ny*(ey-cby)+nz*(ez-cbz);
        ex-=ed*nx;
        ey-=ed*ny;
        ez-=ed*nz;
        d1x=sx-cbx;
        d1y=sy-cby;
        d1z=sz-cbz;
        d2x=ex-cbx;
        d2y=ey-cby;
        d2z=ez-cbz;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        td=ed-sd;
        dotw=d1x*dir1x+d1y*dir1y+d1z*dir1z;
        doth=d2x*dir1x+d2y*dir1y+d2z*dir1z;
        dot1=dotw-dir1l;
        dot2=doth-dir1l;
        if(dot1>0){
        if(dot2>0)return;
        t1=dot1/(dot1-dot2);
        sx=sx+tx*t1;
        sy=sy+ty*t1;
        sz=sz+tz*t1;
        sd=sd+td*t1;
        d1x=sx-cbx;
        d1y=sy-cby;
        d1z=sz-cbz;
        dotw=d1x*dir1x+d1y*dir1y+d1z*dir1z;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        td=ed-sd;
        }else if(dot2>0){
        t1=dot1/(dot1-dot2);
        ex=sx+tx*t1;
        ey=sy+ty*t1;
        ez=sz+tz*t1;
        ed=sd+td*t1;
        d2x=ex-cbx;
        d2y=ey-cby;
        d2z=ez-cbz;
        doth=d2x*dir1x+d2y*dir1y+d2z*dir1z;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        td=ed-sd;
        }
        dot1=dotw+dir1l;
        dot2=doth+dir1l;
        if(dot1<0){
        if(dot2<0)return;
        t1=dot1/(dot1-dot2);
        sx=sx+tx*t1;
        sy=sy+ty*t1;
        sz=sz+tz*t1;
        sd=sd+td*t1;
        d1x=sx-cbx;
        d1y=sy-cby;
        d1z=sz-cbz;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        td=ed-sd;
        }else if(dot2<0){
        t1=dot1/(dot1-dot2);
        ex=sx+tx*t1;
        ey=sy+ty*t1;
        ez=sz+tz*t1;
        ed=sd+td*t1;
        d2x=ex-cbx;
        d2y=ey-cby;
        d2z=ez-cbz;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        td=ed-sd;
        }
        dotw=d1x*dir2x+d1y*dir2y+d1z*dir2z;
        doth=d2x*dir2x+d2y*dir2y+d2z*dir2z;
        dot1=dotw-dir2l;
        dot2=doth-dir2l;
        if(dot1>0){
        if(dot2>0)return;
        t1=dot1/(dot1-dot2);
        sx=sx+tx*t1;
        sy=sy+ty*t1;
        sz=sz+tz*t1;
        sd=sd+td*t1;
        d1x=sx-cbx;
        d1y=sy-cby;
        d1z=sz-cbz;
        dotw=d1x*dir2x+d1y*dir2y+d1z*dir2z;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        td=ed-sd;
        }else if(dot2>0){
        t1=dot1/(dot1-dot2);
        ex=sx+tx*t1;
        ey=sy+ty*t1;
        ez=sz+tz*t1;
        ed=sd+td*t1;
        d2x=ex-cbx;
        d2y=ey-cby;
        d2z=ez-cbz;
        doth=d2x*dir2x+d2y*dir2y+d2z*dir2z;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        td=ed-sd;
        }
        dot1=dotw+dir2l;
        dot2=doth+dir2l;
        if(dot1<0){
        if(dot2<0)return;
        t1=dot1/(dot1-dot2);
        sx=sx+tx*t1;
        sy=sy+ty*t1;
        sz=sz+tz*t1;
        sd=sd+td*t1;
        }else if(dot2<0){
        t1=dot1/(dot1-dot2);
        ex=sx+tx*t1;
        ey=sy+ty*t1;
        ez=sz+tz*t1;
        ed=sd+td*t1;
        }
        if(sd<0){
        //manifold.addPoint(sx,sy,sz,nx,ny,nz,sd,b,c,1,0,false);
        manifold.addPoint(sx,sy,sz,nx,ny,nz,sd,this.flip);
        }
        if(ed<0){
        //manifold.addPoint(ex,ey,ez,nx,ny,nz,ed,b,c,4,0,false);
        manifold.addPoint(ex,ey,ez,nx,ny,nz,ed,this.flip);
        }
        }
        }

    }

    });

function CylinderCylinderCollisionDetector() {
    
    CollisionDetector.call( this );

}

CylinderCylinderCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: CylinderCylinderCollisionDetector,


    getSep: function ( c1, c2, sep, pos, dep ) {

        var t1x;
        var t1y;
        var t1z;
        var t2x;
        var t2y;
        var t2z;
        var sup=new Vec3();
        var len;
        var p1x;
        var p1y;
        var p1z;
        var p2x;
        var p2y;
        var p2z;
        var v01x=c1.position.x;
        var v01y=c1.position.y;
        var v01z=c1.position.z;
        var v02x=c2.position.x;
        var v02y=c2.position.y;
        var v02z=c2.position.z;
        var v0x=v02x-v01x;
        var v0y=v02y-v01y;
        var v0z=v02z-v01z;
        if(v0x*v0x+v0y*v0y+v0z*v0z==0)v0y=0.001;
        var nx=-v0x;
        var ny=-v0y;
        var nz=-v0z;
        this.supportPoint(c1,-nx,-ny,-nz,sup);
        var v11x=sup.x;
        var v11y=sup.y;
        var v11z=sup.z;
        this.supportPoint(c2,nx,ny,nz,sup);
        var v12x=sup.x;
        var v12y=sup.y;
        var v12z=sup.z;
        var v1x=v12x-v11x;
        var v1y=v12y-v11y;
        var v1z=v12z-v11z;
        if(v1x*nx+v1y*ny+v1z*nz<=0){
        return false;
        }
        nx=v1y*v0z-v1z*v0y;
        ny=v1z*v0x-v1x*v0z;
        nz=v1x*v0y-v1y*v0x;
        if(nx*nx+ny*ny+nz*nz==0){
        sep.set( v1x-v0x, v1y-v0y, v1z-v0z ).normalize();
        pos.set( (v11x+v12x)*0.5, (v11y+v12y)*0.5, (v11z+v12z)*0.5 );
        return true;
        }
        this.supportPoint(c1,-nx,-ny,-nz,sup);
        var v21x=sup.x;
        var v21y=sup.y;
        var v21z=sup.z;
        this.supportPoint(c2,nx,ny,nz,sup);
        var v22x=sup.x;
        var v22y=sup.y;
        var v22z=sup.z;
        var v2x=v22x-v21x;
        var v2y=v22y-v21y;
        var v2z=v22z-v21z;
        if(v2x*nx+v2y*ny+v2z*nz<=0){
        return false;
        }
        t1x=v1x-v0x;
        t1y=v1y-v0y;
        t1z=v1z-v0z;
        t2x=v2x-v0x;
        t2y=v2y-v0y;
        t2z=v2z-v0z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        if(nx*v0x+ny*v0y+nz*v0z>0){
        t1x=v1x;
        t1y=v1y;
        t1z=v1z;
        v1x=v2x;
        v1y=v2y;
        v1z=v2z;
        v2x=t1x;
        v2y=t1y;
        v2z=t1z;
        t1x=v11x;
        t1y=v11y;
        t1z=v11z;
        v11x=v21x;
        v11y=v21y;
        v11z=v21z;
        v21x=t1x;
        v21y=t1y;
        v21z=t1z;
        t1x=v12x;
        t1y=v12y;
        t1z=v12z;
        v12x=v22x;
        v12y=v22y;
        v12z=v22z;
        v22x=t1x;
        v22y=t1y;
        v22z=t1z;
        nx=-nx;
        ny=-ny;
        nz=-nz;
        }
        var iterations=0;
        while(true){
        if(++iterations>100){
        return false;
        }
        this.supportPoint(c1,-nx,-ny,-nz,sup);
        var v31x=sup.x;
        var v31y=sup.y;
        var v31z=sup.z;
        this.supportPoint(c2,nx,ny,nz,sup);
        var v32x=sup.x;
        var v32y=sup.y;
        var v32z=sup.z;
        var v3x=v32x-v31x;
        var v3y=v32y-v31y;
        var v3z=v32z-v31z;
        if(v3x*nx+v3y*ny+v3z*nz<=0){
        return false;
        }
        if((v1y*v3z-v1z*v3y)*v0x+(v1z*v3x-v1x*v3z)*v0y+(v1x*v3y-v1y*v3x)*v0z<0){
        v2x=v3x;
        v2y=v3y;
        v2z=v3z;
        v21x=v31x;
        v21y=v31y;
        v21z=v31z;
        v22x=v32x;
        v22y=v32y;
        v22z=v32z;
        t1x=v1x-v0x;
        t1y=v1y-v0y;
        t1z=v1z-v0z;
        t2x=v3x-v0x;
        t2y=v3y-v0y;
        t2z=v3z-v0z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        continue;
        }
        if((v3y*v2z-v3z*v2y)*v0x+(v3z*v2x-v3x*v2z)*v0y+(v3x*v2y-v3y*v2x)*v0z<0){
        v1x=v3x;
        v1y=v3y;
        v1z=v3z;
        v11x=v31x;
        v11y=v31y;
        v11z=v31z;
        v12x=v32x;
        v12y=v32y;
        v12z=v32z;
        t1x=v3x-v0x;
        t1y=v3y-v0y;
        t1z=v3z-v0z;
        t2x=v2x-v0x;
        t2y=v2y-v0y;
        t2z=v2z-v0z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        continue;
        }
        var hit=false;
        while(true){
        t1x=v2x-v1x;
        t1y=v2y-v1y;
        t1z=v2z-v1z;
        t2x=v3x-v1x;
        t2y=v3y-v1y;
        t2z=v3z-v1z;
        nx=t1y*t2z-t1z*t2y;
        ny=t1z*t2x-t1x*t2z;
        nz=t1x*t2y-t1y*t2x;
        len=1/_Math.sqrt(nx*nx+ny*ny+nz*nz);
        nx*=len;
        ny*=len;
        nz*=len;
        if(nx*v1x+ny*v1y+nz*v1z>=0&&!hit){
        var b0=(v1y*v2z-v1z*v2y)*v3x+(v1z*v2x-v1x*v2z)*v3y+(v1x*v2y-v1y*v2x)*v3z;
        var b1=(v3y*v2z-v3z*v2y)*v0x+(v3z*v2x-v3x*v2z)*v0y+(v3x*v2y-v3y*v2x)*v0z;
        var b2=(v0y*v1z-v0z*v1y)*v3x+(v0z*v1x-v0x*v1z)*v3y+(v0x*v1y-v0y*v1x)*v3z;
        var b3=(v2y*v1z-v2z*v1y)*v0x+(v2z*v1x-v2x*v1z)*v0y+(v2x*v1y-v2y*v1x)*v0z;
        var sum=b0+b1+b2+b3;
        if(sum<=0){
        b0=0;
        b1=(v2y*v3z-v2z*v3y)*nx+(v2z*v3x-v2x*v3z)*ny+(v2x*v3y-v2y*v3x)*nz;
        b2=(v3y*v2z-v3z*v2y)*nx+(v3z*v2x-v3x*v2z)*ny+(v3x*v2y-v3y*v2x)*nz;
        b3=(v1y*v2z-v1z*v2y)*nx+(v1z*v2x-v1x*v2z)*ny+(v1x*v2y-v1y*v2x)*nz;
        sum=b1+b2+b3;
        }
        var inv=1/sum;
        p1x=(v01x*b0+v11x*b1+v21x*b2+v31x*b3)*inv;
        p1y=(v01y*b0+v11y*b1+v21y*b2+v31y*b3)*inv;
        p1z=(v01z*b0+v11z*b1+v21z*b2+v31z*b3)*inv;
        p2x=(v02x*b0+v12x*b1+v22x*b2+v32x*b3)*inv;
        p2y=(v02y*b0+v12y*b1+v22y*b2+v32y*b3)*inv;
        p2z=(v02z*b0+v12z*b1+v22z*b2+v32z*b3)*inv;
        hit=true;
        }
        this.supportPoint(c1,-nx,-ny,-nz,sup);
        var v41x=sup.x;
        var v41y=sup.y;
        var v41z=sup.z;
        this.supportPoint(c2,nx,ny,nz,sup);
        var v42x=sup.x;
        var v42y=sup.y;
        var v42z=sup.z;
        var v4x=v42x-v41x;
        var v4y=v42y-v41y;
        var v4z=v42z-v41z;
        var separation=-(v4x*nx+v4y*ny+v4z*nz);
        if((v4x-v3x)*nx+(v4y-v3y)*ny+(v4z-v3z)*nz<=0.01||separation>=0){
        if(hit){
        sep.set( -nx, -ny, -nz );
        pos.set( (p1x+p2x)*0.5, (p1y+p2y)*0.5, (p1z+p2z)*0.5 );
        dep.x=separation;
        return true;
        }
        return false;
        }
        if(
        (v4y*v1z-v4z*v1y)*v0x+
        (v4z*v1x-v4x*v1z)*v0y+
        (v4x*v1y-v4y*v1x)*v0z<0
        ){
        if(
        (v4y*v2z-v4z*v2y)*v0x+
        (v4z*v2x-v4x*v2z)*v0y+
        (v4x*v2y-v4y*v2x)*v0z<0
        ){
        v1x=v4x;
        v1y=v4y;
        v1z=v4z;
        v11x=v41x;
        v11y=v41y;
        v11z=v41z;
        v12x=v42x;
        v12y=v42y;
        v12z=v42z;
        }else{
        v3x=v4x;
        v3y=v4y;
        v3z=v4z;
        v31x=v41x;
        v31y=v41y;
        v31z=v41z;
        v32x=v42x;
        v32y=v42y;
        v32z=v42z;
        }
        }else{
        if(
        (v4y*v3z-v4z*v3y)*v0x+
        (v4z*v3x-v4x*v3z)*v0y+
        (v4x*v3y-v4y*v3x)*v0z<0
        ){
        v2x=v4x;
        v2y=v4y;
        v2z=v4z;
        v21x=v41x;
        v21y=v41y;
        v21z=v41z;
        v22x=v42x;
        v22y=v42y;
        v22z=v42z;
        }else{
        v1x=v4x;
        v1y=v4y;
        v1z=v4z;
        v11x=v41x;
        v11y=v41y;
        v11z=v41z;
        v12x=v42x;
        v12y=v42y;
        v12z=v42z;
        }
        }
        }
        }
        //return false;
    },

    supportPoint: function ( c, dx, dy, dz, out ) {

        var rot=c.rotation.elements;
        var ldx=rot[0]*dx+rot[3]*dy+rot[6]*dz;
        var ldy=rot[1]*dx+rot[4]*dy+rot[7]*dz;
        var ldz=rot[2]*dx+rot[5]*dy+rot[8]*dz;
        var radx=ldx;
        var radz=ldz;
        var len=radx*radx+radz*radz;
        var rad=c.radius;
        var hh=c.halfHeight;
        var ox;
        var oy;
        var oz;
        if(len==0){
        if(ldy<0){
        ox=rad;
        oy=-hh;
        oz=0;
        }else{
        ox=rad;
        oy=hh;
        oz=0;
        }
        }else{
        len=c.radius/_Math.sqrt(len);
        if(ldy<0){
        ox=radx*len;
        oy=-hh;
        oz=radz*len;
        }else{
        ox=radx*len;
        oy=hh;
        oz=radz*len;
        }
        }
        ldx=rot[0]*ox+rot[1]*oy+rot[2]*oz+c.position.x;
        ldy=rot[3]*ox+rot[4]*oy+rot[5]*oz+c.position.y;
        ldz=rot[6]*ox+rot[7]*oy+rot[8]*oz+c.position.z;
        out.set( ldx, ldy, ldz );

    },

    detectCollision: function ( shape1, shape2, manifold ) {

        var c1;
        var c2;
        if(shape1.id<shape2.id){
            c1=shape1;
            c2=shape2;
        }else{
            c1=shape2;
            c2=shape1;
        }
        var p1=c1.position;
        var p2=c2.position;
        var p1x=p1.x;
        var p1y=p1.y;
        var p1z=p1.z;
        var p2x=p2.x;
        var p2y=p2.y;
        var p2z=p2.z;
        var h1=c1.halfHeight;
        var h2=c2.halfHeight;
        var n1=c1.normalDirection;
        var n2=c2.normalDirection;
        var d1=c1.halfDirection;
        var d2=c2.halfDirection;
        var r1=c1.radius;
        var r2=c2.radius;
        var n1x=n1.x;
        var n1y=n1.y;
        var n1z=n1.z;
        var n2x=n2.x;
        var n2y=n2.y;
        var n2z=n2.z;
        var d1x=d1.x;
        var d1y=d1.y;
        var d1z=d1.z;
        var d2x=d2.x;
        var d2y=d2.y;
        var d2z=d2.z;
        var dx=p1x-p2x;
        var dy=p1y-p2y;
        var dz=p1z-p2z;
        var len;
        var c1x;
        var c1y;
        var c1z;
        var c2x;
        var c2y;
        var c2z;
        var tx;
        var ty;
        var tz;
        var sx;
        var sy;
        var sz;
        var ex;
        var ey;
        var ez;
        var depth1;
        var depth2;
        var dot;
        var t1;
        var t2;
        var sep=new Vec3();
        var pos=new Vec3();
        var dep=new Vec3();
        if(!this.getSep(c1,c2,sep,pos,dep))return;
        var dot1=sep.x*n1x+sep.y*n1y+sep.z*n1z;
        var dot2=sep.x*n2x+sep.y*n2y+sep.z*n2z;
        var right1=dot1>0;
        var right2=dot2>0;
        if(!right1)dot1=-dot1;
        if(!right2)dot2=-dot2;
        var state=0;
        if(dot1>0.999||dot2>0.999){
        if(dot1>dot2)state=1;
        else state=2;
        }
        var nx;
        var ny;
        var nz;
        var depth=dep.x;
        var r00;
        var r01;
        var r02;
        var r10;
        var r11;
        var r12;
        var r20;
        var r21;
        var r22;
        var px;
        var py;
        var pz;
        var pd;
        var a;
        var b;
        var e;
        var f;
        nx=sep.x;
        ny=sep.y;
        nz=sep.z;
        switch(state){
        case 0:
        manifold.addPoint(pos.x,pos.y,pos.z,nx,ny,nz,depth,false);
        break;
        case 1:
        if(right1){
        c1x=p1x+d1x;
        c1y=p1y+d1y;
        c1z=p1z+d1z;
        nx=n1x;
        ny=n1y;
        nz=n1z;
        }else{
        c1x=p1x-d1x;
        c1y=p1y-d1y;
        c1z=p1z-d1z;
        nx=-n1x;
        ny=-n1y;
        nz=-n1z;
        }
        dot=nx*n2x+ny*n2y+nz*n2z;
        if(dot<0)len=h2;
        else len=-h2;
        c2x=p2x+len*n2x;
        c2y=p2y+len*n2y;
        c2z=p2z+len*n2z;
        if(dot2>=0.999999){
        tx=-ny;
        ty=nz;
        tz=nx;
        }else{
        tx=nx;
        ty=ny;
        tz=nz;
        }
        len=tx*n2x+ty*n2y+tz*n2z;
        dx=len*n2x-tx;
        dy=len*n2y-ty;
        dz=len*n2z-tz;
        len=_Math.sqrt(dx*dx+dy*dy+dz*dz);
        if(len==0)break;
        len=r2/len;
        dx*=len;
        dy*=len;
        dz*=len;
        tx=c2x+dx;
        ty=c2y+dy;
        tz=c2z+dz;
        if(dot<-0.96||dot>0.96){
        r00=n2x*n2x*1.5-0.5;
        r01=n2x*n2y*1.5-n2z*0.866025403;
        r02=n2x*n2z*1.5+n2y*0.866025403;
        r10=n2y*n2x*1.5+n2z*0.866025403;
        r11=n2y*n2y*1.5-0.5;
        r12=n2y*n2z*1.5-n2x*0.866025403;
        r20=n2z*n2x*1.5-n2y*0.866025403;
        r21=n2z*n2y*1.5+n2x*0.866025403;
        r22=n2z*n2z*1.5-0.5;
        px=tx;
        py=ty;
        pz=tz;
        pd=nx*(px-c1x)+ny*(py-c1y)+nz*(pz-c1z);
        tx=px-pd*nx-c1x;
        ty=py-pd*ny-c1y;
        tz=pz-pd*nz-c1z;
        len=tx*tx+ty*ty+tz*tz;
        if(len>r1*r1){
        len=r1/_Math.sqrt(len);
        tx*=len;
        ty*=len;
        tz*=len;
        }
        px=c1x+tx;
        py=c1y+ty;
        pz=c1z+tz;
        manifold.addPoint(px,py,pz,nx,ny,nz,pd,false);
        px=dx*r00+dy*r01+dz*r02;
        py=dx*r10+dy*r11+dz*r12;
        pz=dx*r20+dy*r21+dz*r22;
        px=(dx=px)+c2x;
        py=(dy=py)+c2y;
        pz=(dz=pz)+c2z;
        pd=nx*(px-c1x)+ny*(py-c1y)+nz*(pz-c1z);
        if(pd<=0){
        tx=px-pd*nx-c1x;
        ty=py-pd*ny-c1y;
        tz=pz-pd*nz-c1z;
        len=tx*tx+ty*ty+tz*tz;
        if(len>r1*r1){
        len=r1/_Math.sqrt(len);
        tx*=len;
        ty*=len;
        tz*=len;
        }
        px=c1x+tx;
        py=c1y+ty;
        pz=c1z+tz;
        manifold.addPoint(px,py,pz,nx,ny,nz,pd,false);
        }
        px=dx*r00+dy*r01+dz*r02;
        py=dx*r10+dy*r11+dz*r12;
        pz=dx*r20+dy*r21+dz*r22;
        px=(dx=px)+c2x;
        py=(dy=py)+c2y;
        pz=(dz=pz)+c2z;
        pd=nx*(px-c1x)+ny*(py-c1y)+nz*(pz-c1z);
        if(pd<=0){
        tx=px-pd*nx-c1x;
        ty=py-pd*ny-c1y;
        tz=pz-pd*nz-c1z;
        len=tx*tx+ty*ty+tz*tz;
        if(len>r1*r1){
        len=r1/_Math.sqrt(len);
        tx*=len;
        ty*=len;
        tz*=len;
        }
        px=c1x+tx;
        py=c1y+ty;
        pz=c1z+tz;
        manifold.addPoint(px,py,pz,nx,ny,nz,pd,false);
        }
        }else{
        sx=tx;
        sy=ty;
        sz=tz;
        depth1=nx*(sx-c1x)+ny*(sy-c1y)+nz*(sz-c1z);
        sx-=depth1*nx;
        sy-=depth1*ny;
        sz-=depth1*nz;
        if(dot>0){
        ex=tx+n2x*h2*2;
        ey=ty+n2y*h2*2;
        ez=tz+n2z*h2*2;
        }else{
        ex=tx-n2x*h2*2;
        ey=ty-n2y*h2*2;
        ez=tz-n2z*h2*2;
        }
        depth2=nx*(ex-c1x)+ny*(ey-c1y)+nz*(ez-c1z);
        ex-=depth2*nx;
        ey-=depth2*ny;
        ez-=depth2*nz;
        dx=c1x-sx;
        dy=c1y-sy;
        dz=c1z-sz;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        a=dx*dx+dy*dy+dz*dz;
        b=dx*tx+dy*ty+dz*tz;
        e=tx*tx+ty*ty+tz*tz;
        f=b*b-e*(a-r1*r1);
        if(f<0)break;
        f=_Math.sqrt(f);
        t1=(b+f)/e;
        t2=(b-f)/e;
        if(t2<t1){
        len=t1;
        t1=t2;
        t2=len;
        }
        if(t2>1)t2=1;
        if(t1<0)t1=0;
        tx=sx+(ex-sx)*t1;
        ty=sy+(ey-sy)*t1;
        tz=sz+(ez-sz)*t1;
        ex=sx+(ex-sx)*t2;
        ey=sy+(ey-sy)*t2;
        ez=sz+(ez-sz)*t2;
        sx=tx;
        sy=ty;
        sz=tz;
        len=depth1+(depth2-depth1)*t1;
        depth2=depth1+(depth2-depth1)*t2;
        depth1=len;
        if(depth1<0) manifold.addPoint(sx,sy,sz,nx,ny,nz,pd,false);
        if(depth2<0) manifold.addPoint(ex,ey,ez,nx,ny,nz,pd,false);
        
        }
        break;
        case 2:
        if(right2){
        c2x=p2x-d2x;
        c2y=p2y-d2y;
        c2z=p2z-d2z;
        nx=-n2x;
        ny=-n2y;
        nz=-n2z;
        }else{
        c2x=p2x+d2x;
        c2y=p2y+d2y;
        c2z=p2z+d2z;
        nx=n2x;
        ny=n2y;
        nz=n2z;
        }
        dot=nx*n1x+ny*n1y+nz*n1z;
        if(dot<0)len=h1;
        else len=-h1;
        c1x=p1x+len*n1x;
        c1y=p1y+len*n1y;
        c1z=p1z+len*n1z;
        if(dot1>=0.999999){
        tx=-ny;
        ty=nz;
        tz=nx;
        }else{
        tx=nx;
        ty=ny;
        tz=nz;
        }
        len=tx*n1x+ty*n1y+tz*n1z;
        dx=len*n1x-tx;
        dy=len*n1y-ty;
        dz=len*n1z-tz;
        len=_Math.sqrt(dx*dx+dy*dy+dz*dz);
        if(len==0)break;
        len=r1/len;
        dx*=len;
        dy*=len;
        dz*=len;
        tx=c1x+dx;
        ty=c1y+dy;
        tz=c1z+dz;
        if(dot<-0.96||dot>0.96){
        r00=n1x*n1x*1.5-0.5;
        r01=n1x*n1y*1.5-n1z*0.866025403;
        r02=n1x*n1z*1.5+n1y*0.866025403;
        r10=n1y*n1x*1.5+n1z*0.866025403;
        r11=n1y*n1y*1.5-0.5;
        r12=n1y*n1z*1.5-n1x*0.866025403;
        r20=n1z*n1x*1.5-n1y*0.866025403;
        r21=n1z*n1y*1.5+n1x*0.866025403;
        r22=n1z*n1z*1.5-0.5;
        px=tx;
        py=ty;
        pz=tz;
        pd=nx*(px-c2x)+ny*(py-c2y)+nz*(pz-c2z);
        tx=px-pd*nx-c2x;
        ty=py-pd*ny-c2y;
        tz=pz-pd*nz-c2z;
        len=tx*tx+ty*ty+tz*tz;
        if(len>r2*r2){
        len=r2/_Math.sqrt(len);
        tx*=len;
        ty*=len;
        tz*=len;
        }
        px=c2x+tx;
        py=c2y+ty;
        pz=c2z+tz;
        manifold.addPoint(px,py,pz,-nx,-ny,-nz,pd,false);
        px=dx*r00+dy*r01+dz*r02;
        py=dx*r10+dy*r11+dz*r12;
        pz=dx*r20+dy*r21+dz*r22;
        px=(dx=px)+c1x;
        py=(dy=py)+c1y;
        pz=(dz=pz)+c1z;
        pd=nx*(px-c2x)+ny*(py-c2y)+nz*(pz-c2z);
        if(pd<=0){
        tx=px-pd*nx-c2x;
        ty=py-pd*ny-c2y;
        tz=pz-pd*nz-c2z;
        len=tx*tx+ty*ty+tz*tz;
        if(len>r2*r2){
        len=r2/_Math.sqrt(len);
        tx*=len;
        ty*=len;
        tz*=len;
        }
        px=c2x+tx;
        py=c2y+ty;
        pz=c2z+tz;
        manifold.addPoint(px,py,pz,-nx,-ny,-nz,pd,false);
        }
        px=dx*r00+dy*r01+dz*r02;
        py=dx*r10+dy*r11+dz*r12;
        pz=dx*r20+dy*r21+dz*r22;
        px=(dx=px)+c1x;
        py=(dy=py)+c1y;
        pz=(dz=pz)+c1z;
        pd=nx*(px-c2x)+ny*(py-c2y)+nz*(pz-c2z);
        if(pd<=0){
        tx=px-pd*nx-c2x;
        ty=py-pd*ny-c2y;
        tz=pz-pd*nz-c2z;
        len=tx*tx+ty*ty+tz*tz;
        if(len>r2*r2){
        len=r2/_Math.sqrt(len);
        tx*=len;
        ty*=len;
        tz*=len;
        }
        px=c2x+tx;
        py=c2y+ty;
        pz=c2z+tz;
        manifold.addPoint(px,py,pz,-nx,-ny,-nz,pd,false);
        }
        }else{
        sx=tx;
        sy=ty;
        sz=tz;
        depth1=nx*(sx-c2x)+ny*(sy-c2y)+nz*(sz-c2z);
        sx-=depth1*nx;
        sy-=depth1*ny;
        sz-=depth1*nz;
        if(dot>0){
        ex=tx+n1x*h1*2;
        ey=ty+n1y*h1*2;
        ez=tz+n1z*h1*2;
        }else{
        ex=tx-n1x*h1*2;
        ey=ty-n1y*h1*2;
        ez=tz-n1z*h1*2;
        }
        depth2=nx*(ex-c2x)+ny*(ey-c2y)+nz*(ez-c2z);
        ex-=depth2*nx;
        ey-=depth2*ny;
        ez-=depth2*nz;
        dx=c2x-sx;
        dy=c2y-sy;
        dz=c2z-sz;
        tx=ex-sx;
        ty=ey-sy;
        tz=ez-sz;
        a=dx*dx+dy*dy+dz*dz;
        b=dx*tx+dy*ty+dz*tz;
        e=tx*tx+ty*ty+tz*tz;
        f=b*b-e*(a-r2*r2);
        if(f<0)break;
        f=_Math.sqrt(f);
        t1=(b+f)/e;
        t2=(b-f)/e;
        if(t2<t1){
        len=t1;
        t1=t2;
        t2=len;
        }
        if(t2>1)t2=1;
        if(t1<0)t1=0;
        tx=sx+(ex-sx)*t1;
        ty=sy+(ey-sy)*t1;
        tz=sz+(ez-sz)*t1;
        ex=sx+(ex-sx)*t2;
        ey=sy+(ey-sy)*t2;
        ez=sz+(ez-sz)*t2;
        sx=tx;
        sy=ty;
        sz=tz;
        len=depth1+(depth2-depth1)*t1;
        depth2=depth1+(depth2-depth1)*t2;
        depth1=len;
        if(depth1<0){
        manifold.addPoint(sx,sy,sz,-nx,-ny,-nz,depth1,false);
        }
        if(depth2<0){
        manifold.addPoint(ex,ey,ez,-nx,-ny,-nz,depth2,false);
        }
        }
        break;
        }

    }

});

/**
 * A collision detector which detects collisions between sphere and box.
 * @author saharan
 */
function SphereBoxCollisionDetector ( flip ) {
    
    CollisionDetector.call( this );
    this.flip = flip;

}

SphereBoxCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: SphereBoxCollisionDetector,

    detectCollision: function ( shape1, shape2, manifold ) {

        var s;
        var b;
        if(this.flip){
            s=(shape2);
            b=(shape1);
        }else{
            s=(shape1);
            b=(shape2);
        }

        var D = b.dimentions;

        var ps=s.position;
        var psx=ps.x;
        var psy=ps.y;
        var psz=ps.z;
        var pb=b.position;
        var pbx=pb.x;
        var pby=pb.y;
        var pbz=pb.z;
        var rad=s.radius;

        var hw=b.halfWidth;
        var hh=b.halfHeight;
        var hd=b.halfDepth;

        var dx=psx-pbx;
        var dy=psy-pby;
        var dz=psz-pbz;
        var sx=D[0]*dx+D[1]*dy+D[2]*dz;
        var sy=D[3]*dx+D[4]*dy+D[5]*dz;
        var sz=D[6]*dx+D[7]*dy+D[8]*dz;
        var cx;
        var cy;
        var cz;
        var len;
        var invLen;
        var overlap=0;
        if(sx>hw){
            sx=hw;
        }else if(sx<-hw){
            sx=-hw;
        }else{
            overlap=1;
        }
        if(sy>hh){
            sy=hh;
        }else if(sy<-hh){
            sy=-hh;
        }else{
            overlap|=2;
        }
        if(sz>hd){
            sz=hd;
        }else if(sz<-hd){
            sz=-hd;
        }else{
            overlap|=4;
        }
        if(overlap==7){
            // center of sphere is in the box
            if(sx<0){
                dx=hw+sx;
            }else{
                dx=hw-sx;
            }
            if(sy<0){
                dy=hh+sy;
            }else{
                dy=hh-sy;
            }
            if(sz<0){
                dz=hd+sz;
            }else{
                dz=hd-sz;
            }
            if(dx<dy){
                if(dx<dz){
                    len=dx-hw;
                if(sx<0){
                    sx=-hw;
                    dx=D[0];
                    dy=D[1];
                    dz=D[2];
                }else{
                    sx=hw;
                    dx=-D[0];
                    dy=-D[1];
                    dz=-D[2];
                }
            }else{
                len=dz-hd;
                if(sz<0){
                    sz=-hd;
                    dx=D[6];
                    dy=D[7];
                    dz=D[8];
                }else{
                    sz=hd;
                    dx=-D[6];
                    dy=-D[7];
                    dz=-D[8];
                }
            }
            }else{
                if(dy<dz){
                    len=dy-hh;
                    if(sy<0){
                        sy=-hh;
                        dx=D[3];
                        dy=D[4];
                        dz=D[5];
                    }else{
                        sy=hh;
                        dx=-D[3];
                        dy=-D[4];
                        dz=-D[5];
                    }
                }else{
                    len=dz-hd;
                    if(sz<0){
                        sz=-hd;
                        dx=D[6];
                        dy=D[7];
                        dz=D[8];
                    }else{
                        sz=hd;
                        dx=-D[6];
                        dy=-D[7];
                        dz=-D[8];
                }
            }
        }
        cx=pbx+sx*D[0]+sy*D[3]+sz*D[6];
        cy=pby+sx*D[1]+sy*D[4]+sz*D[7];
        cz=pbz+sx*D[2]+sy*D[5]+sz*D[8];
        manifold.addPoint(psx+rad*dx,psy+rad*dy,psz+rad*dz,dx,dy,dz,len-rad,this.flip);
        }else{
            cx=pbx+sx*D[0]+sy*D[3]+sz*D[6];
            cy=pby+sx*D[1]+sy*D[4]+sz*D[7];
            cz=pbz+sx*D[2]+sy*D[5]+sz*D[8];
            dx=cx-ps.x;
            dy=cy-ps.y;
            dz=cz-ps.z;
            len=dx*dx+dy*dy+dz*dz;
            if(len>0&&len<rad*rad){
                len=_Math.sqrt(len);
                invLen=1/len;
                dx*=invLen;
                dy*=invLen;
                dz*=invLen;
                manifold.addPoint(psx+rad*dx,psy+rad*dy,psz+rad*dz,dx,dy,dz,len-rad,this.flip);
            }
        }

    }

});

function SphereCylinderCollisionDetector ( flip ){
    
    CollisionDetector.call( this );
    this.flip = flip;

}

SphereCylinderCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: SphereCylinderCollisionDetector,

    detectCollision: function ( shape1, shape2, manifold ) {
        
        var s;
        var c;
        if( this.flip ){
            s = shape2;
            c = shape1;
        }else{
            s = shape1;
            c = shape2;
        }
        var ps = s.position;
        var psx = ps.x;
        var psy = ps.y;
        var psz = ps.z;
        var pc = c.position;
        var pcx = pc.x;
        var pcy = pc.y;
        var pcz = pc.z;
        var dirx = c.normalDirection.x;
        var diry = c.normalDirection.y;
        var dirz = c.normalDirection.z;
        var rads = s.radius;
        var radc = c.radius;
        var rad2 = rads + radc;
        var halfh = c.halfHeight;
        var dx = psx - pcx;
        var dy = psy - pcy;
        var dz = psz - pcz;
        var dot = dx * dirx + dy * diry + dz * dirz;
        if ( dot < -halfh - rads || dot > halfh + rads ) return;
        var cx = pcx + dot * dirx;
        var cy = pcy + dot * diry;
        var cz = pcz + dot * dirz;
        var d2x = psx - cx;
        var d2y = psy - cy;
        var d2z = psz - cz;
        var len = d2x * d2x + d2y * d2y + d2z * d2z;
        if ( len > rad2 * rad2 ) return;
        if ( len > radc * radc ) {
            len = radc / _Math.sqrt( len );
            d2x *= len;
            d2y *= len;
            d2z *= len;
        }
        if( dot < -halfh ) dot = -halfh;
        else if( dot > halfh ) dot = halfh;
        cx = pcx + dot * dirx + d2x;
        cy = pcy + dot * diry + d2y;
        cz = pcz + dot * dirz + d2z;
        dx = cx - psx;
        dy = cy - psy;
        dz = cz - psz;
        len = dx * dx + dy * dy + dz * dz;
        var invLen;
        if ( len > 0 && len < rads * rads ) {
            len = _Math.sqrt(len);
            invLen = 1 / len;
            dx *= invLen;
            dy *= invLen;
            dz *= invLen;
            ///result.addContactInfo(psx+dx*rads,psy+dy*rads,psz+dz*rads,dx,dy,dz,len-rads,s,c,0,0,false);
            manifold.addPoint( psx + dx * rads, psy + dy * rads, psz + dz * rads, dx, dy, dz, len - rads, this.flip );
        }

    }


});

/**
 * A collision detector which detects collisions between two spheres.
 * @author saharan
 */
 
function SphereSphereCollisionDetector (){

    CollisionDetector.call( this );

}

SphereSphereCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: SphereSphereCollisionDetector,

    detectCollision: function ( shape1, shape2, manifold ) {

        var s1 = shape1;
        var s2 = shape2;
        var p1 = s1.position;
        var p2 = s2.position;
        var dx = p2.x - p1.x;
        var dy = p2.y - p1.y;
        var dz = p2.z - p1.z;
        var len = dx * dx + dy * dy + dz * dz;
        var r1 = s1.radius;
        var r2 = s2.radius;
        var rad = r1 + r2;
        if ( len > 0 && len < rad * rad ){
            len = _Math.sqrt( len );
            var invLen = 1 / len;
            dx *= invLen;
            dy *= invLen;
            dz *= invLen;
            manifold.addPoint( p1.x + dx * r1, p1.y + dy * r1, p1.z + dz * r1, dx, dy, dz, len - rad, false );
        }

    }

});

/**
 * A collision detector which detects collisions between two spheres.
 * @author saharan 
 * @author lo-th
 */
 
function SpherePlaneCollisionDetector ( flip ){

    CollisionDetector.call( this );

    this.flip = flip;

    this.n = new Vec3();
    this.p = new Vec3();

}

SpherePlaneCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: SpherePlaneCollisionDetector,

    detectCollision: function ( shape1, shape2, manifold ) {

        var n = this.n;
        var p = this.p;

        var s = this.flip ? shape2 : shape1;
        var pn = this.flip ? shape1 : shape2;
        var rad = s.radius;
        var len;

        n.sub( s.position, pn.position );
        //var h = _Math.dotVectors( pn.normal, n );

        n.x *= pn.normal.x;//+ rad;
        n.y *= pn.normal.y;
        n.z *= pn.normal.z;//+ rad;

        
        var len = n.lengthSq();
        
        if( len > 0 && len < rad * rad){//&& h > rad*rad ){

            
            len = _Math.sqrt( len );
            //len = _Math.sqrt( h );
            n.copy(pn.normal).negate();
            //n.scaleEqual( 1/len );

            //(0, -1, 0)

            //n.normalize();
            p.copy( s.position ).addScaledVector( n, rad );
            manifold.addPointVec( p, n, len - rad, this.flip );

        }

    }

});

/**
 * A collision detector which detects collisions between two spheres.
 * @author saharan 
 * @author lo-th
 */
 
function BoxPlaneCollisionDetector ( flip ){

    CollisionDetector.call( this );

    this.flip = flip;

    this.n = new Vec3();
    this.p = new Vec3();

    this.dix = new Vec3();
    this.diy = new Vec3();
    this.diz = new Vec3();

    this.cc = new Vec3();
    this.cc2 = new Vec3();

}

BoxPlaneCollisionDetector.prototype = Object.assign( Object.create( CollisionDetector.prototype ), {

    constructor: BoxPlaneCollisionDetector,

    detectCollision: function ( shape1, shape2, manifold ) {

        var n = this.n;
        var p = this.p;
        var cc = this.cc;

        var b = this.flip ? shape2 : shape1;
        var pn = this.flip ? shape1 : shape2;

        var D = b.dimentions;
        var hw = b.halfWidth;
        var hh = b.halfHeight;
        var hd = b.halfDepth;
        var len;
        var overlap = 0;

        this.dix.set( D[0], D[1], D[2] );
        this.diy.set( D[3], D[4], D[5] );
        this.diz.set( D[6], D[7], D[8] );

        n.sub( b.position, pn.position );

        n.x *= pn.normal.x;//+ rad;
        n.y *= pn.normal.y;
        n.z *= pn.normal.z;//+ rad;

        cc.set(
            _Math.dotVectors( this.dix, n ),
            _Math.dotVectors( this.diy, n ),
            _Math.dotVectors( this.diz, n )
        );


        if( cc.x > hw ) cc.x = hw;
        else if( cc.x < -hw ) cc.x = -hw;
        else overlap = 1;
        
        if( cc.y > hh ) cc.y = hh;
        else if( cc.y < -hh ) cc.y = -hh;
        else overlap |= 2;
        
        if( cc.z > hd ) cc.z = hd;
        else if( cc.z < -hd ) cc.z = -hd;
        else overlap |= 4;

        

        if( overlap === 7 ){

            // center of sphere is in the box
            
            n.set(
                cc.x < 0 ? hw + cc.x : hw - cc.x,
                cc.y < 0 ? hh + cc.y : hh - cc.y,
                cc.z < 0 ? hd + cc.z : hd - cc.z
            );
            
            if( n.x < n.y ){
                if( n.x < n.z ){
                    len = n.x - hw;
                    if( cc.x < 0 ){
                        cc.x = -hw;
                        n.copy( this.dix );
                    }else{
                        cc.x = hw;
                        n.subEqual( this.dix );
                    }
                }else{
                    len = n.z - hd;
                    if( cc.z < 0 ){
                        cc.z = -hd;
                        n.copy( this.diz );
                    }else{
                        cc.z = hd;
                        n.subEqual( this.diz );
                    }
                }
            }else{
                if( n.y < n.z ){
                    len = n.y - hh;
                    if( cc.y < 0 ){
                        cc.y = -hh;
                        n.copy( this.diy );
                    }else{
                        cc.y = hh;
                        n.subEqual( this.diy );
                    }
                }else{
                    len = n.z - hd;
                    if( cc.z < 0 ){
                        cc.z = -hd;
                        n.copy( this.diz );
                    }else{
                        cc.z = hd;
                        n.subEqual( this.diz );
                    }
                }
            }

            p.copy( pn.position ).addScaledVector( n, 1 );
            manifold.addPointVec( p, n, len, this.flip );

        }

    }

});

//import { TetraShape } from '../collision/shape/TetraShape';

/**
 * The class of physical computing world.
 * You must be added to the world physical all computing objects
 *
 * @author saharan
 * @author lo-th
 */

 // timestep, broadphase, iterations, worldscale, random, stat

function World ( o ) {

    if( !(o instanceof Object) ) o = {};

    // this world scale defaut is 0.1 to 10 meters max for dynamique body
    this.scale = o.worldscale || 1;
    this.invScale = 1/this.scale;

    // The time between each step
    this.timeStep = o.timestep || 0.01666; // 1/60;
    this.timerate = this.timeStep * 1000;
    this.timer = null;

    this.preLoop = null;//function(){};
    this.postLoop = null;//function(){};

    // The number of iterations for constraint solvers.
    this.numIterations = o.iterations || 8;

     // It is a wide-area collision judgment that is used in order to reduce as much as possible a detailed collision judgment.
    switch( o.broadphase || 2 ){
        case 1: this.broadPhase = new BruteForceBroadPhase(); break;
        case 2: default: this.broadPhase = new SAPBroadPhase(); break;
        case 3: this.broadPhase = new DBVTBroadPhase(); break;
    }

    this.Btypes = ['None','BruteForce','Sweep & Prune', 'Bounding Volume Tree' ];
    this.broadPhaseType = this.Btypes[ o.broadphase || 2 ];

    // This is the detailed information of the performance.
    this.performance = null;
    this.isStat = o.info === undefined ? false : o.info;
    if( this.isStat ) this.performance = new InfoDisplay( this );

    /**
     * Whether the constraints randomizer is enabled or not.
     *
     * @property enableRandomizer
     * @type {Boolean}
     */
    this.enableRandomizer = o.random !== undefined ? o.random : true;

    // The rigid body list
    this.rigidBodies=null;
    // number of rigid body
    this.numRigidBodies=0;
    // The contact list
    this.contacts=null;
    this.unusedContacts=null;
    // The number of contact
    this.numContacts=0;
    // The number of contact points
    this.numContactPoints=0;
    //  The joint list
    this.joints=null;
    // The number of joints.
    this.numJoints=0;
    // The number of simulation islands.
    this.numIslands=0;


    // The gravity in the world.
    this.gravity = new Vec3(0,-9.8,0);
    if( o.gravity !== undefined ) this.gravity.fromArray( o.gravity );



    var numShapeTypes = 5;//4;//3;
    this.detectors=[];
    this.detectors.length = numShapeTypes;
    var i = numShapeTypes;
    while(i--){
        this.detectors[i]=[];
        this.detectors[i].length = numShapeTypes;
    }

    this.detectors[SHAPE_SPHERE][SHAPE_SPHERE] = new SphereSphereCollisionDetector();
    this.detectors[SHAPE_SPHERE][SHAPE_BOX] = new SphereBoxCollisionDetector(false);
    this.detectors[SHAPE_BOX][SHAPE_SPHERE] = new SphereBoxCollisionDetector(true);
    this.detectors[SHAPE_BOX][SHAPE_BOX] = new BoxBoxCollisionDetector();

    // CYLINDER add
    this.detectors[SHAPE_CYLINDER][SHAPE_CYLINDER] = new CylinderCylinderCollisionDetector();

    this.detectors[SHAPE_CYLINDER][SHAPE_BOX] = new BoxCylinderCollisionDetector(true);
    this.detectors[SHAPE_BOX][SHAPE_CYLINDER] = new BoxCylinderCollisionDetector(false);

    this.detectors[SHAPE_CYLINDER][SHAPE_SPHERE] = new SphereCylinderCollisionDetector(true);
    this.detectors[SHAPE_SPHERE][SHAPE_CYLINDER] = new SphereCylinderCollisionDetector(false);

    // PLANE add

    this.detectors[SHAPE_PLANE][SHAPE_SPHERE] = new SpherePlaneCollisionDetector(true);
    this.detectors[SHAPE_SPHERE][SHAPE_PLANE] = new SpherePlaneCollisionDetector(false);

    this.detectors[SHAPE_PLANE][SHAPE_BOX] = new BoxPlaneCollisionDetector(true);
    this.detectors[SHAPE_BOX][SHAPE_PLANE] = new BoxPlaneCollisionDetector(false);

    // TETRA add
    //this.detectors[SHAPE_TETRA][SHAPE_TETRA] = new TetraTetraCollisionDetector();


    this.randX = 65535;
    this.randA = 98765;
    this.randB = 123456789;

    this.islandRigidBodies = [];
    this.islandStack = [];
    this.islandConstraints = [];

}

Object.assign( World.prototype, {

    World: true,

    play: function(){
 
        if( this.timer !== null ) return;

        var _this = this;
        this.timer = setInterval( function(){ _this.step(); } , this.timerate );
        //this.timer = setInterval( this.loop.bind(this) , this.timerate );

    },

    stop: function(){

        if( this.timer === null ) return;

        clearInterval( this.timer );
        this.timer = null;

    },

    setGravity: function ( ar ) {

        this.gravity.fromArray( ar );

    },

    getInfo: function () {

        return this.isStat ? this.performance.show() : '';

    },

    // Reset the world and remove all rigid bodies, shapes, joints and any object from the world.
    clear:function(){

        this.stop();
        this.preLoop = null;
        this.postLoop = null;

        this.randX = 65535;

        while(this.joints!==null){
            this.removeJoint( this.joints );
        }
        while(this.contacts!==null){
            this.removeContact( this.contacts );
        }
        while(this.rigidBodies!==null){
            this.removeRigidBody( this.rigidBodies );
        }

    },
    /**
    * I'll add a rigid body to the world.
    * Rigid body that has been added will be the operands of each step.
    * @param  rigidBody  Rigid body that you want to add
    */
    addRigidBody:function( rigidBody ){

        if(rigidBody.parent){
            printError("World", "It is not possible to be added to more than one world one of the rigid body");
        }

        rigidBody.setParent( this );
        //rigidBody.awake();

        for(var shape = rigidBody.shapes; shape !== null; shape = shape.next){
            this.addShape( shape );
        }
        if(this.rigidBodies!==null)(this.rigidBodies.prev=rigidBody).next=this.rigidBodies;
        this.rigidBodies = rigidBody;
        this.numRigidBodies++;

    },
    /**
    * I will remove the rigid body from the world.
    * Rigid body that has been deleted is excluded from the calculation on a step-by-step basis.
    * @param  rigidBody  Rigid body to be removed
    */
    removeRigidBody:function( rigidBody ){

        var remove=rigidBody;
        if(remove.parent!==this)return;
        remove.awake();
        var js=remove.jointLink;
        while(js!=null){
	        var joint=js.joint;
	        js=js.next;
	        this.removeJoint(joint);
        }
        for(var shape=rigidBody.shapes; shape!==null; shape=shape.next){
            this.removeShape(shape);
        }
        var prev=remove.prev;
        var next=remove.next;
        if(prev!==null) prev.next=next;
        if(next!==null) next.prev=prev;
        if(this.rigidBodies==remove) this.rigidBodies=next;
        remove.prev=null;
        remove.next=null;
        remove.parent=null;
        this.numRigidBodies--;

    },

    getByName: function( name ){

        var body = this.rigidBodies;
        while( body !== null ){
            if( body.name === name ) return body;
            body=body.next;
        }

        var joint = this.joints;
        while( joint !== null ){
            if( joint.name === name ) return joint;
            joint = joint.next;
        }

        return null;

    },

    /**
    * I'll add a shape to the world..
    * Add to the rigid world, and if you add a shape to a rigid body that has been added to the world,
    * Shape will be added to the world automatically, please do not call from outside this method.
    * @param  shape  Shape you want to add
    */
    addShape:function ( shape ){

        if(!shape.parent || !shape.parent.parent){
            printError("World", "It is not possible to be added alone to shape world");
        }

        shape.proxy = this.broadPhase.createProxy(shape);
        shape.updateProxy();
        this.broadPhase.addProxy(shape.proxy);

    },

    /**
    * I will remove the shape from the world.
    * Add to the rigid world, and if you add a shape to a rigid body that has been added to the world,
    * Shape will be added to the world automatically, please do not call from outside this method.
    * @param  shape  Shape you want to delete
    */
    removeShape: function ( shape ){

        this.broadPhase.removeProxy(shape.proxy);
        shape.proxy = null;

    },

    /**
    * I'll add a joint to the world.
    * Joint that has been added will be the operands of each step.
    * @param  shape Joint to be added
    */
    addJoint: function ( joint ) {

        if(joint.parent){
            printError("World", "It is not possible to be added to more than one world one of the joint");
        }
        if(this.joints!=null)(this.joints.prev=joint).next=this.joints;
        this.joints=joint;
        joint.setParent( this );
        this.numJoints++;
        joint.awake();
        joint.attach();

    },

    /**
    * I will remove the joint from the world.
    * Joint that has been added will be the operands of each step.
    * @param  shape Joint to be deleted
    */
    removeJoint: function ( joint ) {

        var remove=joint;
        var prev=remove.prev;
        var next=remove.next;
        if(prev!==null)prev.next=next;
        if(next!==null)next.prev=prev;
        if(this.joints==remove)this.joints=next;
        remove.prev=null;
        remove.next=null;
        this.numJoints--;
        remove.awake();
        remove.detach();
        remove.parent=null;

    },

    addContact: function ( s1, s2 ) {

        var newContact;
        if(this.unusedContacts!==null){
            newContact=this.unusedContacts;
            this.unusedContacts=this.unusedContacts.next;
        }else{
            newContact = new Contact();
        }
        newContact.attach(s1,s2);
        newContact.detector = this.detectors[s1.type][s2.type];
        if(this.contacts)(this.contacts.prev = newContact).next = this.contacts;
        this.contacts = newContact;
        this.numContacts++;

    },

    removeContact: function ( contact ) {

        var prev = contact.prev;
        var next = contact.next;
        if(next) next.prev = prev;
        if(prev) prev.next = next;
        if(this.contacts == contact) this.contacts = next;
        contact.prev = null;
        contact.next = null;
        contact.detach();
        contact.next = this.unusedContacts;
        this.unusedContacts = contact;
        this.numContacts--;

    },

    getContact: function ( b1, b2 ) {

        b1 = b1.constructor === RigidBody ? b1.name : b1;
        b2 = b2.constructor === RigidBody ? b2.name : b2;

        var n1, n2;
        var contact = this.contacts;
        while(contact!==null){
            n1 = contact.body1.name;
            n2 = contact.body2.name;
            if((n1===b1 && n2===b2) || (n2===b1 && n1===b2)){ if(contact.touching) return contact; else return null;}
            else contact = contact.next;
        }
        return null;

    },

    checkContact: function ( name1, name2 ) {

        var n1, n2;
        var contact = this.contacts;
        while(contact!==null){
            n1 = contact.body1.name || ' ';
            n2 = contact.body2.name || ' ';
            if((n1==name1 && n2==name2) || (n2==name1 && n1==name2)){ if(contact.touching) return true; else return false;}
            else contact = contact.next;
        }
        //return false;

    },

    callSleep: function( body ) {

        if( !body.allowSleep ) return false;
        if( body.linearVelocity.lengthSq() > 0.04 ) return false;
        if( body.angularVelocity.lengthSq() > 0.25 ) return false;
        return true;

    },

    /**
    * I will proceed only time step seconds time of World.
    */
    step: function () {

        var stat = this.isStat;

        if( stat ) this.performance.setTime( 0 );

        var body = this.rigidBodies;

        while( body !== null ){

            body.addedToIsland = false;

            if( body.sleeping ) body.testWakeUp();

            body = body.next;

        }



        //------------------------------------------------------
        //   UPDATE BROADPHASE CONTACT
        //------------------------------------------------------

        if( stat ) this.performance.setTime( 1 );

        this.broadPhase.detectPairs();

        var pairs = this.broadPhase.pairs;

        var i = this.broadPhase.numPairs;
        //do{
        while(i--){
        //for(var i=0, l=numPairs; i<l; i++){
            var pair = pairs[i];
            var s1;
            var s2;
            if(pair.shape1.id<pair.shape2.id){
                s1 = pair.shape1;
                s2 = pair.shape2;
            }else{
                s1 = pair.shape2;
                s2 = pair.shape1;
            }

            var link;
            if( s1.numContacts < s2.numContacts ) link = s1.contactLink;
            else link = s2.contactLink;

            var exists = false;
            while(link){
                var contact = link.contact;
                if( contact.shape1 == s1 && contact.shape2 == s2 ){
                    contact.persisting = true;
                    exists = true;// contact already exists
                    break;
                }
                link = link.next;
            }
            if(!exists){
                this.addContact( s1, s2 );
            }
        }// while(i-- >0);

        if( stat ) this.performance.calcBroadPhase();

        //------------------------------------------------------
        //   UPDATE NARROWPHASE CONTACT
        //------------------------------------------------------

        // update & narrow phase
        this.numContactPoints = 0;
        contact = this.contacts;
        while( contact!==null ){
            if(!contact.persisting){
                if ( contact.shape1.aabb.intersectTest( contact.shape2.aabb ) ) {
                /*var aabb1=contact.shape1.aabb;
                var aabb2=contact.shape2.aabb;
                if(
	                aabb1.minX>aabb2.maxX || aabb1.maxX<aabb2.minX ||
	                aabb1.minY>aabb2.maxY || aabb1.maxY<aabb2.minY ||
	                aabb1.minZ>aabb2.maxZ || aabb1.maxZ<aabb2.minZ
                ){*/
                    var next = contact.next;
                    this.removeContact(contact);
                    contact = next;
                    continue;
                }
            }
            var b1 = contact.body1;
            var b2 = contact.body2;

            if( b1.isDynamic && !b1.sleeping || b2.isDynamic && !b2.sleeping ) contact.updateManifold();

            this.numContactPoints += contact.manifold.numPoints;
            contact.persisting = false;
            contact.constraint.addedToIsland = false;
            contact = contact.next;

        }

        if( stat ) this.performance.calcNarrowPhase();

        //------------------------------------------------------
        //   SOLVE ISLANDS
        //------------------------------------------------------

        var invTimeStep = 1 / this.timeStep;
        var joint;
        var constraint;

        for( joint = this.joints; joint !== null; joint = joint.next ){
            joint.addedToIsland = false;
        }


        // clear old island array
        this.islandRigidBodies = [];
        this.islandConstraints = [];
        this.islandStack = [];

        if( stat ) this.performance.setTime( 1 );

        this.numIslands = 0;

        // build and solve simulation islands

        for( var base = this.rigidBodies; base !== null; base = base.next ){

            if( base.addedToIsland || base.isStatic || base.sleeping ) continue;// ignore

            if( base.isLonely() ){// update single body
                if( base.isDynamic ){
                    base.linearVelocity.addScaledVector( this.gravity, this.timeStep );
                    /*base.linearVelocity.x+=this.gravity.x*this.timeStep;
                    base.linearVelocity.y+=this.gravity.y*this.timeStep;
                    base.linearVelocity.z+=this.gravity.z*this.timeStep;*/
                }
                if( this.callSleep( base ) ) {
                    base.sleepTime += this.timeStep;
                    if( base.sleepTime > 0.5 ) base.sleep();
                    else base.updatePosition( this.timeStep );
                }else{
                    base.sleepTime = 0;
                    base.updatePosition( this.timeStep );
                }
                this.numIslands++;
                continue;
            }

            var islandNumRigidBodies = 0;
            var islandNumConstraints = 0;
            var stackCount = 1;
            // add rigid body to stack
            this.islandStack[0] = base;
            base.addedToIsland = true;

            // build an island
            do{
                // get rigid body from stack
                body = this.islandStack[--stackCount];
                this.islandStack[stackCount] = null;
                body.sleeping = false;
                // add rigid body to the island
                this.islandRigidBodies[islandNumRigidBodies++] = body;
                if(body.isStatic) continue;

                // search connections
                for( var cs = body.contactLink; cs !== null; cs = cs.next ) {
                    var contact = cs.contact;
                    constraint = contact.constraint;
                    if( constraint.addedToIsland || !contact.touching ) continue;// ignore

                    // add constraint to the island
                    this.islandConstraints[islandNumConstraints++] = constraint;
                    constraint.addedToIsland = true;
                    var next = cs.body;

                    if(next.addedToIsland) continue;

                    // add rigid body to stack
                    this.islandStack[stackCount++] = next;
                    next.addedToIsland = true;
                }
                for( var js = body.jointLink; js !== null; js = js.next ) {
                    constraint = js.joint;

                    if(constraint.addedToIsland) continue;// ignore

                    // add constraint to the island
                    this.islandConstraints[islandNumConstraints++] = constraint;
                    constraint.addedToIsland = true;
                    next = js.body;
                    if( next.addedToIsland || !next.isDynamic ) continue;

                    // add rigid body to stack
                    this.islandStack[stackCount++] = next;
                    next.addedToIsland = true;
                }
            } while( stackCount != 0 );

            // update velocities
            var gVel = new Vec3().addScaledVector( this.gravity, this.timeStep );
            /*var gx=this.gravity.x*this.timeStep;
            var gy=this.gravity.y*this.timeStep;
            var gz=this.gravity.z*this.timeStep;*/
            var j = islandNumRigidBodies;
            while (j--){
            //or(var j=0, l=islandNumRigidBodies; j<l; j++){
                body = this.islandRigidBodies[j];
                if(body.isDynamic){
                    body.linearVelocity.addEqual(gVel);
                    /*body.linearVelocity.x+=gx;
                    body.linearVelocity.y+=gy;
                    body.linearVelocity.z+=gz;*/
                }
            }

            // randomizing order
            if(this.enableRandomizer){
                //for(var j=1, l=islandNumConstraints; j<l; j++){
                j = islandNumConstraints;
                while(j--){ if(j!==0){
                        var swap = (this.randX=(this.randX*this.randA+this.randB&0x7fffffff))/2147483648.0*j|0;
                        constraint = this.islandConstraints[j];
                        this.islandConstraints[j] = this.islandConstraints[swap];
                        this.islandConstraints[swap] = constraint;
                    }
                }
            }

            // solve contraints

            j = islandNumConstraints;
            while(j--){
            //for(j=0, l=islandNumConstraints; j<l; j++){
                this.islandConstraints[j].preSolve( this.timeStep, invTimeStep );// pre-solve
            }
            var k = this.numIterations;
            while(k--){
            //for(var k=0, l=this.numIterations; k<l; k++){
                j = islandNumConstraints;
                while(j--){
                //for(j=0, m=islandNumConstraints; j<m; j++){
                    this.islandConstraints[j].solve();// main-solve
                }
            }
            j = islandNumConstraints;
            while(j--){
            //for(j=0, l=islandNumConstraints; j<l; j++){
                this.islandConstraints[j].postSolve();// post-solve
                this.islandConstraints[j] = null;// gc
            }

            // sleeping check

            var sleepTime = 10;
            j = islandNumRigidBodies;
            while(j--){
            //for(j=0, l=islandNumRigidBodies;j<l;j++){
                body = this.islandRigidBodies[j];
                if( this.callSleep( body ) ){
                    body.sleepTime += this.timeStep;
                    if( body.sleepTime < sleepTime ) sleepTime = body.sleepTime;
                }else{
                    body.sleepTime = 0;
                    sleepTime = 0;
                    continue;
                }
            }
            if(sleepTime > 0.5){
                // sleep the island
                j = islandNumRigidBodies;
                while(j--){
                //for(j=0, l=islandNumRigidBodies;j<l;j++){
                    this.islandRigidBodies[j].sleep();
                    this.islandRigidBodies[j] = null;// gc
                }
            }else{
                // update positions
                j = islandNumRigidBodies;
                while(j--){
                //for(j=0, l=islandNumRigidBodies;j<l;j++){
                    this.islandRigidBodies[j].updatePosition( this.timeStep );
                    this.islandRigidBodies[j] = null;// gc
                }
            }
            this.numIslands++;
        }

        //------------------------------------------------------
        //   END SIMULATION
        //------------------------------------------------------

        if( stat ) this.performance.calcEnd();

        if( this.postLoop !== null ) this.postLoop();

    },

    // remove someting to world

    remove: function( obj ){

    },

    // add someting to world
    
    add: function( o ){

        o = o || {};

        var type = o.type || "box";
        if( type.constructor === String ) type = [ type ];
        var isJoint = type[0].substring( 0, 5 ) === 'joint' ? true : false;

        if( isJoint ) return this.initJoint( type[0], o );
        else return this.initBody( type, o );

    },

    initBody: function( type, o ){

        var invScale = this.invScale;

        // body dynamic or static
        var move = o.move || false;
        var kinematic = o.kinematic || false;

        // POSITION

        // body position
        var p = o.pos || [0,0,0];
        p = p.map( function(x) { return x * invScale; } );

        // shape position
        var p2 = o.posShape || [0,0,0];
        p2 = p2.map( function(x) { return x * invScale; } );

        // ROTATION

        // body rotation in degree
        var r = o.rot || [0,0,0];
        r = r.map( function(x) { return x * _Math.degtorad; } );

        // shape rotation in degree
        var r2 = o.rotShape || [0,0,0];
        r2 = r.map( function(x) { return x * _Math.degtorad; } );

        // SIZE

        // shape size
        var s = o.size === undefined ? [1,1,1] : o.size;
        if( s.length === 1 ){ s[1] = s[0]; }
        if( s.length === 2 ){ s[2] = s[0]; }
        s = s.map( function(x) { return x * invScale; } );

        

        // body physics settings
        var sc = new ShapeConfig();
        // The density of the shape.
        if( o.density !== undefined ) sc.density = o.density;
        // The coefficient of friction of the shape.
        if( o.friction !== undefined ) sc.friction = o.friction;
        // The coefficient of restitution of the shape.
        if( o.restitution !== undefined ) sc.restitution = o.restitution;
        // The bits of the collision groups to which the shape belongs.
        if( o.belongsTo !== undefined ) sc.belongsTo = o.belongsTo;
        // The bits of the collision groups with which the shape collides.
        if( o.collidesWith !== undefined ) sc.collidesWith = o.collidesWith;

        if(o.config !== undefined ){
            if( o.config[0] !== undefined ) sc.density = o.config[0];
            if( o.config[1] !== undefined ) sc.friction = o.config[1];
            if( o.config[2] !== undefined ) sc.restitution = o.config[2];
            if( o.config[3] !== undefined ) sc.belongsTo = o.config[3];
            if( o.config[4] !== undefined ) sc.collidesWith = o.config[4];
        }


       /* if(o.massPos){
            o.massPos = o.massPos.map(function(x) { return x * invScale; });
            sc.relativePosition.set( o.massPos[0], o.massPos[1], o.massPos[2] );
        }
        if(o.massRot){
            o.massRot = o.massRot.map(function(x) { return x * _Math.degtorad; });
            var q = new Quat().setFromEuler( o.massRot[0], o.massRot[1], o.massRot[2] );
            sc.relativeRotation = new Mat33().setQuat( q );//_Math.EulerToMatrix( o.massRot[0], o.massRot[1], o.massRot[2] );
        }*/

        var position = new Vec3( p[0], p[1], p[2] );
        var rotation = new Quat().setFromEuler( r[0], r[1], r[2] );

        // rigidbody
        var body = new RigidBody( position, rotation );
        //var body = new RigidBody( p[0], p[1], p[2], r[0], r[1], r[2], r[3], this.scale, this.invScale );

        // SHAPES

        var shape, n;

        for( var i = 0; i < type.length; i++ ){

            n = i * 3;

            if( p2[n] !== undefined ) sc.relativePosition.set( p2[n], p2[n+1], p2[n+2] );
            if( r2[n] !== undefined ) sc.relativeRotation.setQuat( new Quat().setFromEuler( r2[n], r2[n+1], r2[n+2] ) );
            
            switch( type[i] ){
                case "sphere": shape = new Sphere( sc, s[n] ); break;
                case "cylinder": shape = new Cylinder( sc, s[n], s[n+1] ); break;
                case "box": shape = new Box( sc, s[n], s[n+1], s[n+2] ); break;
                case "plane": shape = new Plane( sc ); break
            }

            body.addShape( shape );
            
        }

        // body can sleep or not
        if( o.neverSleep || kinematic) body.allowSleep = false;
        else body.allowSleep = true;

        body.isKinematic = kinematic;

        // body static or dynamic
        if( move ){

            if(o.massPos || o.massRot) body.setupMass( BODY_DYNAMIC, false );
            else body.setupMass( BODY_DYNAMIC, true );

            // body can sleep or not
            //if( o.neverSleep ) body.allowSleep = false;
            //else body.allowSleep = true;

        } else {

            body.setupMass( BODY_STATIC );

        }

        if( o.name !== undefined ) body.name = o.name;
        //else if( move ) body.name = this.numRigidBodies;

        // finaly add to physics world
        this.addRigidBody( body );

        // force sleep on not
        if( move ){
            if( o.sleep ) body.sleep();
            else body.awake();
        }

        return body;


    },

    initJoint: function( type, o ){

        //var type = type;
        var invScale = this.invScale;

        var axe1 = o.axe1 || [1,0,0];
        var axe2 = o.axe2 || [1,0,0];
        var pos1 = o.pos1 || [0,0,0];
        var pos2 = o.pos2 || [0,0,0];

        pos1 = pos1.map(function(x){ return x * invScale; });
        pos2 = pos2.map(function(x){ return x * invScale; });

        var min, max;
        if( type === "jointDistance" ){
            min = o.min || 0;
            max = o.max || 10;
            min = min * invScale;
            max = max * invScale;
        }else{
            min = o.min || 57.29578;
            max = o.max || 0;
            min = min * _Math.degtorad;
            max = max * _Math.degtorad;
        }

        var limit = o.limit || null;
        var spring = o.spring || null;
        var motor = o.motor || null;

        // joint setting
        var jc = new JointConfig();
        jc.scale = this.scale;
        jc.invScale = this.invScale;
        jc.allowCollision = o.collision || false;
        jc.localAxis1.set( axe1[0], axe1[1], axe1[2] );
        jc.localAxis2.set( axe2[0], axe2[1], axe2[2] );
        jc.localAnchorPoint1.set( pos1[0], pos1[1], pos1[2] );
        jc.localAnchorPoint2.set( pos2[0], pos2[1], pos2[2] );

        var b1 = null;
        var b2 = null;

        if( o.body1 === undefined || o.body2 === undefined ) return printError('World', "Can't add joint if attach rigidbodys not define !" );

        if ( o.body1.constructor === String ) { b1 = this.getByName( o.body1 ); }
        else if ( o.body1.constructor === Number ) { b1 = this.getByName( o.body1 ); }
        else if ( o.body1.constructor === RigidBody ) { b1 = o.body1; }

        if ( o.body2.constructor === String ) { b2 = this.getByName( o.body2 ); }
        else if ( o.body2.constructor === Number ) { b2 = this.getByName( o.body2 ); }
        else if ( o.body2.constructor === RigidBody ) { b2 = o.body2; }

        if( b1 === null || b2 === null ) return printError('World', "Can't add joint attach rigidbodys not find !" );

        jc.body1 = b1;
        jc.body2 = b2;

        var joint;
        switch( type ){
            case "jointDistance": joint = new DistanceJoint(jc, min, max);
                if(spring !== null) joint.limitMotor.setSpring( spring[0], spring[1] );
                if(motor !== null) joint.limitMotor.setMotor( motor[0], motor[1] );
            break;
            case "jointHinge": case "joint": joint = new HingeJoint(jc, min, max);
                if(spring !== null) joint.limitMotor.setSpring( spring[0], spring[1] );// soften the joint ex: 100, 0.2
                if(motor !== null) joint.limitMotor.setMotor( motor[0], motor[1] );
            break;
            case "jointPrisme": joint = new PrismaticJoint(jc, min, max); break;
            case "jointSlide": joint = new SliderJoint(jc, min, max); break;
            case "jointBall": joint = new BallAndSocketJoint(jc); break;
            case "jointWheel": joint = new WheelJoint(jc);
                if(limit !== null) joint.rotationalLimitMotor1.setLimit( limit[0], limit[1] );
                if(spring !== null) joint.rotationalLimitMotor1.setSpring( spring[0], spring[1] );
                if(motor !== null) joint.rotationalLimitMotor1.setMotor( motor[0], motor[1] );
            break;
        }

        joint.name = o.name || '';
        // finaly add to physics world
        this.addJoint( joint );

        return joint;

    },


} );

// test version

//export { RigidBody } from './core/RigidBody_X.js';
//export { World } from './core/World_X.js';




/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = function( THREE ) {
	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author erich666 / http://erichaines.com
	 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe

	function OrbitControls( object, domElement ) {

		this.object = object;

		this.domElement = ( domElement !== undefined ) ? domElement : document;

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new THREE.Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.25;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

		// Set to false to disable use of the keys
		this.enableKeys = true;

		// The four arrow keys
		this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

		// Mouse buttons
		this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function() {

			var offset = new THREE.Vector3();

			// so camera.up is the orbit axis
			var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
			var quatInverse = quat.clone().inverse();

			var lastPosition = new THREE.Vector3();
			var lastQuaternion = new THREE.Quaternion();

			return function update () {

				var position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				spherical.theta += sphericalDelta.theta;
				spherical.phi += sphericalDelta.phi;

				// restrict theta to be between desired limits
				spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location
				scope.target.add( panOffset );

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

				}

				scale = 1;
				panOffset.set( 0, 0, 0 );

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function() {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
			scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

			scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
			scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
			scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			window.removeEventListener( 'keydown', onKeyDown, false );

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		var scope = this;

		var changeEvent = { type: 'change' };
		var startEvent = { type: 'start' };
		var endEvent = { type: 'end' };

		var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

		var state = STATE.NONE;

		var EPS = 0.000001;

		// current position in spherical coordinates
		var spherical = new THREE.Spherical();
		var sphericalDelta = new THREE.Spherical();

		var scale = 1;
		var panOffset = new THREE.Vector3();
		var zoomChanged = false;

		var rotateStart = new THREE.Vector2();
		var rotateEnd = new THREE.Vector2();
		var rotateDelta = new THREE.Vector2();

		var panStart = new THREE.Vector2();
		var panEnd = new THREE.Vector2();
		var panDelta = new THREE.Vector2();

		var dollyStart = new THREE.Vector2();
		var dollyEnd = new THREE.Vector2();
		var dollyDelta = new THREE.Vector2();

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		var panLeft = function() {

			var v = new THREE.Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		var panUp = function() {

			var v = new THREE.Vector3();

			return function panUp( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		var pan = function() {

			var offset = new THREE.Vector3();

			return function pan ( deltaX, deltaY ) {

				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

				if ( scope.object instanceof THREE.PerspectiveCamera ) {

					// perspective
					var position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					var targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we actually don't use screenWidth, since perspective camera is fixed to screen height
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object instanceof THREE.OrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyIn( dollyScale ) {

			if ( scope.object instanceof THREE.PerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyOut( dollyScale ) {

			if ( scope.object instanceof THREE.PerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			//console.log( 'handleMouseDownRotate' );

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			//console.log( 'handleMouseDownDolly' );

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			//console.log( 'handleMouseDownPan' );

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			//console.log( 'handleMouseMoveRotate' );

			rotateEnd.set( event.clientX, event.clientY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			//console.log( 'handleMouseMoveDolly' );

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyIn( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyOut( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			//console.log( 'handleMouseMovePan' );

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseUp( event ) {

			//console.log( 'handleMouseUp' );

		}

		function handleMouseWheel( event ) {

			//console.log( 'handleMouseWheel' );

			if ( event.deltaY < 0 ) {

				dollyOut( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyIn( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			//console.log( 'handleKeyDown' );

			switch ( event.keyCode ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					scope.update();
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					scope.update();
					break;

			}

		}

		function handleTouchStartRotate( event ) {

			//console.log( 'handleTouchStartRotate' );

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		}

		function handleTouchStartDolly( event ) {

			//console.log( 'handleTouchStartDolly' );

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartPan( event ) {

			//console.log( 'handleTouchStartPan' );

			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		}

		function handleTouchMoveRotate( event ) {

			//console.log( 'handleTouchMoveRotate' );

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleTouchMoveDolly( event ) {

			//console.log( 'handleTouchMoveDolly' );

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleTouchMovePan( event ) {

			//console.log( 'handleTouchMovePan' );

			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleTouchEnd( event ) {

			//console.log( 'handleTouchEnd' );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onMouseDown( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			if ( event.button === scope.mouseButtons.ORBIT ) {

				if ( scope.enableRotate === false ) return;

				handleMouseDownRotate( event );

				state = STATE.ROTATE;

			} else if ( event.button === scope.mouseButtons.ZOOM ) {

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

			} else if ( event.button === scope.mouseButtons.PAN ) {

				if ( scope.enablePan === false ) return;

				handleMouseDownPan( event );

				state = STATE.PAN;

			}

			if ( state !== STATE.NONE ) {

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mouseup', onMouseUp, false );

				scope.dispatchEvent( startEvent );

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			if ( state === STATE.ROTATE ) {

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

			} else if ( state === STATE.DOLLY ) {

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

			} else if ( state === STATE.PAN ) {

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

			}

		}

		function onMouseUp( event ) {

			if ( scope.enabled === false ) return;

			handleMouseUp( event );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

			event.preventDefault();
			event.stopPropagation();

			handleMouseWheel( event );

			scope.dispatchEvent( startEvent ); // not sure why these are here...
			scope.dispatchEvent( endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			if ( scope.enabled === false ) return;

			switch ( event.touches.length ) {

				case 1:	// one-fingered touch: rotate

					if ( scope.enableRotate === false ) return;

					handleTouchStartRotate( event );

					state = STATE.TOUCH_ROTATE;

					break;

				case 2:	// two-fingered touch: dolly

					if ( scope.enableZoom === false ) return;

					handleTouchStartDolly( event );

					state = STATE.TOUCH_DOLLY;

					break;

				case 3: // three-fingered touch: pan

					if ( scope.enablePan === false ) return;

					handleTouchStartPan( event );

					state = STATE.TOUCH_PAN;

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( startEvent );

			}

		}

		function onTouchMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			switch ( event.touches.length ) {

				case 1: // one-fingered touch: rotate

					if ( scope.enableRotate === false ) return;
					if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

					handleTouchMoveRotate( event );

					break;

				case 2: // two-fingered touch: dolly

					if ( scope.enableZoom === false ) return;
					if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

					handleTouchMoveDolly( event );

					break;

				case 3: // three-fingered touch: pan

					if ( scope.enablePan === false ) return;
					if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

					handleTouchMovePan( event );

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onTouchEnd( event ) {

			if ( scope.enabled === false ) return;

			handleTouchEnd( event );

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;

		}

		function onContextMenu( event ) {

			event.preventDefault();

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

		scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

		window.addEventListener( 'keydown', onKeyDown, false );

		// force an update at start

		this.update();

	};

	OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
	OrbitControls.prototype.constructor = OrbitControls;

	Object.defineProperties( OrbitControls.prototype, {

		center: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
				return this.target;

			}

		},

		// backward compatibility

		noZoom: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				return ! this.enableZoom;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				this.enableZoom = ! value;

			}

		},

		noRotate: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				return ! this.enableRotate;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				this.enableRotate = ! value;

			}

		},

		noPan: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				return ! this.enablePan;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				this.enablePan = ! value;

			}

		},

		noKeys: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				return ! this.enableKeys;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				this.enableKeys = ! value;

			}

		},

		staticMoving : {

			get: function () {

				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				return ! this.enableDamping;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				this.enableDamping = ! value;

			}

		},

		dynamicDampingFactor : {

			get: function () {

				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				return this.dampingFactor;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				this.dampingFactor = value;

			}

		}

	} );

	return OrbitControls;
};


/***/ }),
/* 56 */,
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 02.03.2017.
 */
class FormButton {
    constructor(options) {
        this.text = options.text;
        this.attrs = options.attrs || [];
        this.el = document.createElement(options.type);
        this._render();
    }

    _setAttrs(attrs) {
        Object.keys(attrs).forEach(name => {
            this.el.setAttribute(name, attrs[name]);
        })
    }

    getElem(){
        return this;
    }

    _render() {
        this.el.innerHTML = this.text;
        this._setAttrs(this.attrs);
    }

    toString() {
        return this.el.outerHTML;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FormButton;



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__ = __webpack_require__(22);
/**
 * Created by Denis on 02.03.2017.
 */


class Input {
    constructor(options) {
        this.text = options.text;
        this.attrs = options.attrs || [];
        this.help_attrs = options.help_attrs || [];
        this.el = document.createElement('input');
        this.help_el = document.createElement('p');
        this._render();
    }

    _setAttrs(attrs, elem) {
        Object.keys(attrs).forEach(name => {
            elem.setAttribute(name, attrs[name]);
        })
    }

    _render() {
        this._setAttrs(this.attrs, this.el);
        this._setAttrs(this.help_attrs, this.help_el);
    }

    getElem() {
        return this;
    }

    toString() {
        return this.el.outerHTML;
    }

    validate(prev) {
        let check = true;
        if (__WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].checkEmpty(this.el.value)) {
            __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].fieldSetErr(this.el);
            __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].helpSetText(this.help_el, 'empty field');
            return false;
        }
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].fieldRemoveErr(this.el);
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].helpSetText(this.help_el, '');

        const valid = this.el.getAttribute('valid');
        if (valid === 'login') {
            return __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].checkLogin({field: this.el, help: this.help_el});
        } else if (valid === 'password') {

        } else if (valid === 'repeatpassword') {
            return __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].checkPassword(
                {field: prev.el, help: prev.help_el},
                {field: this.el, help: this.help_el});
        }

        return check;
    }

    clear() {
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].helpSetText(this.help_el, '');
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].fieldSetText(this.el, '');
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].fieldRemoveOk(this.el);
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].fieldRemoveErr(this.el);
    }

    //noinspection JSDuplicatedDeclaration
    setError() {
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].fieldSetErr(this.el);
    }

    //noinspection JSDuplicatedDeclaration
    setError(value) {
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].fieldSetErr(this.el);
        __WEBPACK_IMPORTED_MODULE_0__js_menu_actions_CheckFields__["a" /* default */].helpSetText(this.help_el, value);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Input;



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 08.04.2017.
 */
class GameControls{
    constructor(node){
        this.node = node;
    }

    render(){
        let container = document.createElement('div');
        container.setAttribute('id', 'command-div');
        container.setAttribute('class', 'game-controls');

        let commandBox= document.createElement('textarea');
        commandBox.setAttribute('id', 'commands');
        commandBox.setAttribute('class', 'game-controls__textarea');
        commandBox.setAttribute('placeholder', 'Your commands');

        let btnStep = document.createElement('div');
        btnStep.setAttribute('id', 'btn-next-step');
        btnStep.setAttribute('class', 'game-controls__button');
        let text = document.createElement('p');
        text.innerText = 'Create step';
        btnStep.appendChild(text);

        container.appendChild(commandBox);
        container.appendChild(btnStep);
        this.node.appendChild(container);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameControls;


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GameScene__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__strategies_Singleplayer__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__strategies_Multiplayer__ = __webpack_require__(63);
/**
 * Created by Denis on 02.04.2017.
 */



class GameManager {
    constructor(storage, view, strategy) {
        this._subscribed = [];

        this.storage = storage;
        this.strategy = strategy === this.storage.gameStates.SINGLEPLAYER_STRATEGY ? new __WEBPACK_IMPORTED_MODULE_1__strategies_Singleplayer__["a" /* default */]() : new __WEBPACK_IMPORTED_MODULE_2__strategies_Multiplayer__["a" /* default */]();
        this.node = view.node;
        this.view = view;

        this.scene = new __WEBPACK_IMPORTED_MODULE_0__GameScene__["a" /* default */](view.node, this.storage);

        this._start();
    }

    /**
     * Начать игровой процесс
     * @private
     */
    _start(){
        //TODO start strategy
        this.scene.setState(this.storage.gameStates.STATEWAIT);
        setTimeout(()=>{
            this.opponent = this._getOpponent();
            this.scene.setPlayers(this.storage.user, this.opponent);
            this.scene.setState(this.storage.gameStates.STATEGAME);
        }, 1000);
    }

    /**
     * Получить противника
     * @return {*}
     * @private
     */
    _getOpponent() {
        if (this.strategy.constructor.name === __WEBPACK_IMPORTED_MODULE_1__strategies_Singleplayer__["a" /* default */].name) {
            return {login: 'dc.DRE'};
        } else {
            //TODO search for opponent in global
            return {login: 'MULTIPLAYER'};
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameManager;


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_three__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_oimo__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ObjPerson__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__elements_game_controls_GameControls__ = __webpack_require__(59);
/**
 * Created by Denis on 29.03.2017.
 */
// import * as THREE from "../../../../vendor/three";





const OrbitControls = __webpack_require__(55)(__WEBPACK_IMPORTED_MODULE_0_three__);
// import * as OrbitControls from 'three-orbit-controls';

class GameScene {
    constructor(node, storage) {
        this.HDim = 34;
        this.WDim = 50;

        this.node = node;
        this.storage = storage;

        this._setSize();
        this._renderContainer();
    }

    _setSize() {
        const height = window.innerHeight;
        this.fieldSize = (height / this.HDim) | 0;
        this.WIDTH = window.innerWidth;
        this.HEGHT = this.fieldSize / 3 * 2 * this.HDim;
    }

    _onWindowResize() {
        let height = window.innerHeight;

        this.fieldSize = (height / this.HDim) | 0;
        this.WIDTH = window.innerWidth;

        this.HEGHT = this.fieldSize / 3 * 2 * this.HDim;

        if (!this.camera || !this.renderer) return;

        this.camera.aspect = this.WIDTH / this.HEGHT;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(this.WIDTH, this.HEGHT);
    }

    _initListeners() {
        window.addEventListener('resize', this._onWindowResize.bind(this), false);
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    }

    _renderContainer() {
        /* init figures arr*/
        this.worldBodies = [];
        this.worldMeshes = [];

        this.scene = new __WEBPACK_IMPORTED_MODULE_0_three__["Scene"]();
        this.renderer = new __WEBPACK_IMPORTED_MODULE_0_three__["WebGLRenderer"]({
            antialias: true,
            alpha: true
        });
        this.scene.fog = new __WEBPACK_IMPORTED_MODULE_0_three__["FogExp2"](0xffffff, 0.002);
        this.renderer.setClearColor(this.scene.fog.color);

        this.renderer.setSize(this.WIDTH, this.HEGHT);
        this._addStylesToContainer();

        this.container = document.createElement('div');
        this.container.setAttribute('class', 'game-view__container');

        this.container.appendChild(this.renderer.domElement);
        this.node.appendChild(this.container);

        this.world = new __WEBPACK_IMPORTED_MODULE_1_oimo__["a" /* World */](1 / 60, 2, 8);

        this._addCamera();
        this._animate();
        this._initListeners();
    }

    _addStylesToContainer(){
        this.renderer.domElement.setAttribute('class', 'game-view__game-area');
        this.renderer.domElement.setAttribute('id', 'game-area');
    }

    /**
     * Установить текущее состояние
     * @param state - состояние
     */
    setState(state) {
        this.state = state;
        this._renderState();
    }

    /**
     * Отрисовка, относительно входного события
     * @private
     */
    _renderState() {
        switch (this.state) {
            case this.storage.gameStates.STATEWAIT: {
                this._renderWaitState();
                break;
            }
            case this.storage.gameStates.STATEGAME: {
                this._renderGameState();
                break;
            }
            case this.storage.gameStates.STATERESULT: {
                this._renderResultState();
                break;
            }
        }
    }

    /**
     * Отрисовка ждущего режима
     * @private
     */
    _renderWaitState() {
        this.clear();

        /* Lights */
        let spotLight = new __WEBPACK_IMPORTED_MODULE_0_three__["SpotLight"](0xffffff);
        spotLight.position.set(0, 20, 30);
        this.scene.add(spotLight);

        /* figure where field in*/
        let octahedronGeometry = new __WEBPACK_IMPORTED_MODULE_0_three__["OctahedronGeometry"](4, 0);
        let octahedronMaterial = new __WEBPACK_IMPORTED_MODULE_0_three__["MeshLambertMaterial"](
            {color: 0xff0000});
        let octahedron = new __WEBPACK_IMPORTED_MODULE_0_three__["Mesh"](octahedronGeometry, octahedronMaterial);
        octahedron.position.set(0, 0, 0);
        this.scene.add(octahedron);

        let render = () => {
            window.requestAnimationFrame(render);
            octahedron.rotation.y += 0.02;
            //this.refreshScene();
        };
        render();
    }

    /**
     * Отрисовка игрового режима
     * @private
     */
    _renderGameState() {
        this.clear();
        this._animCamera();
        this._renderControlArea();

        this._renderField();
        this._renderPlayers();
        this.refreshScene();

        this.mePerson.depnut();

         this._renderNames();
         this._renderHealthBars();
    }

    _renderField() {
        let axes = new __WEBPACK_IMPORTED_MODULE_0_three__["AxisHelper"](20);
        this.scene.add(axes);

        //dome
        let geometry = new __WEBPACK_IMPORTED_MODULE_0_three__["IcosahedronGeometry"](700, 1);
        let domeMaterial = new __WEBPACK_IMPORTED_MODULE_0_three__["MeshPhongMaterial"]({
            color: 0x35FBE0,
            shading: __WEBPACK_IMPORTED_MODULE_0_three__["FlatShading"],
            side: __WEBPACK_IMPORTED_MODULE_0_three__["BackSide"]
        });
        let dome = new __WEBPACK_IMPORTED_MODULE_0_three__["Mesh"](geometry, domeMaterial);
        this.scene.add(dome);

        //light
        let light = new __WEBPACK_IMPORTED_MODULE_0_three__["DirectionalLight"](0x4198B5);
        light.position.set(1, 1, 1);
        this.scene.add(light);
        light = new __WEBPACK_IMPORTED_MODULE_0_three__["DirectionalLight"](0x4198B5);
        light.position.set(1, -1, 0);
        this.scene.add(light);
        light = new __WEBPACK_IMPORTED_MODULE_0_three__["SpotLight"](0x4198B5);
        light.position.set(-1, 1, 0);
        this.scene.add(light);

        let planeGeometry = new __WEBPACK_IMPORTED_MODULE_0_three__["PlaneGeometry"](1000, 1000, 40, 40);
        let planeMaterial = new __WEBPACK_IMPORTED_MODULE_0_three__["MeshLambertMaterial"]({color: 0xffffff, wireframe: true});
        let plane = new __WEBPACK_IMPORTED_MODULE_0_three__["Mesh"](planeGeometry, planeMaterial);
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.set(0, -10, 0);
        this.scene.add(plane);

        this.world.add({
            size: [1000, 10, 1000],
            pos: [0, -10, 0],
            world: this.world,
            density: 1,
            collidesWith: 0xffffffff
        });

        this.world.gravity = new __WEBPACK_IMPORTED_MODULE_1_oimo__["b" /* Vec3 */](0, 0, 0);
    }

    _renderPlayers() {
        this.mePerson = new __WEBPACK_IMPORTED_MODULE_2__ObjPerson__["a" /* default */](this.scene, this);
        this.mePerson.render('right');

        this.opponentPerson = new __WEBPACK_IMPORTED_MODULE_2__ObjPerson__["a" /* default */](this.scene, this);
        this.opponentPerson.render('left');
    }

    _addCamera() {
        this.camera = new __WEBPACK_IMPORTED_MODULE_0_three__["PerspectiveCamera"](45
            , this.WIDTH / this.HEGHT, 0.1, 1000);

        this.camera.position.set(0,25,80);
        this.camera.lookAt(this.scene.position);
    }

    _animate() {
        let render = () => {
            window.requestAnimationFrame(render);
            this.refreshScene();
        };
        render();
    }

    refreshScene() {
        if (this.world) {
            this.world.step();
            for (let i = 0, len = this.worldBodies.length; i < len; i++) {
                let b = this.worldBodies[i];
                let m = this.worldMeshes[i];

                if (!b.sleeping) {
                    m.position.copy(b.getPosition());
                    m.quaternion.copy(b.getQuaternion());
                }
            }
        }

        this.renderer.render(this.scene, this.camera);
    }


    _animCamera(){
        this.camera.position.set(0,0,1000);
        let render = () => {
            if (this.camera.position.z > 60) {
                this.camera.position.z -= 10;
                this.camera.lookAt(this.scene.position);
                window.requestAnimationFrame(render);
            } else if(this.camera.position.y < 30){
                this.camera.position.y += 1;
                this.camera.lookAt(this.scene.position);
                window.requestAnimationFrame(render);
            }
        };
        render();
    }

    _renderControlArea() {
        this.gameControls = new __WEBPACK_IMPORTED_MODULE_3__elements_game_controls_GameControls__["a" /* default */](this.container);
        this.gameControls.render();
    }

    /**
     * Отрисовка послеигрового режима (результаты, итоги)
     * @private
     */
    _renderResultState() {
        this.clear();
    }

    _renderNames(){

    }

    _renderHealthBars(){

    }

    /**
     * Отчистка основного контейнера
     */
    clear() {
        this.scene.children.splice(0, this.scene.children.length);
        this.refreshScene();
    }

    /**
     * Установка данных игроков
     * @param me
     * @param opponent
     */
    setPlayers(me, opponent) {
        this.players = {me: me, opponent: opponent};
    }

    setUserResult(objResult, user) {
        this.objResult = objResult;
    }


}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameScene;


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_three__ = __webpack_require__(19);
/**
 * Created by Denis on 05.04.2017.
 */

class ObjPerson {
    constructor(scene, sceneContext) {
        this.scene = scene;
        this.sceneContext = sceneContext;
        this.material = new __WEBPACK_IMPORTED_MODULE_0_three__["MeshLambertMaterial"](
            {color: 0x7777ff /*shading: THREE.FlatShading,*/, skinning: true});

        this.personConst = {
            startPosition: {
                x: 10,
                y: 7,
                z: 0
            },
            startScale: {
                x: 2,
                y: 2,
                z: 2
            },
            startRotation: {
                x: Math.PI / 2,
                y: 0,
                z: Math.PI / 2
            }
        }
    }

    render(partOf) {
        this.partOf = partOf;
        this._renderBodyOnStart();
    }

    _renderBodyOnStart() {
        let loader = new __WEBPACK_IMPORTED_MODULE_0_three__["JSONLoader"]();
        loader.load('/src/three-models/player.json', (model => {
            const color = this.partOf === 'left' ? 0xFF0037 : 0x00FF51;
            let mat = new __WEBPACK_IMPORTED_MODULE_0_three__["MeshLambertMaterial"]({color: color, shading: __WEBPACK_IMPORTED_MODULE_0_three__["FlatShading"], skinning: true});
            this.person = new __WEBPACK_IMPORTED_MODULE_0_three__["SkinnedMesh"](model, mat);

            const pos = this.partOf === 'left' ? -1 : 1;
            this.person.position.set(
                this.personConst.startPosition.x * pos,
                this.personConst.startPosition.y,
                this.personConst.startPosition.z
            );
            this.person.scale.set(
                this.personConst.startScale.x,
                this.personConst.startScale.y,
                this.personConst.startScale.z
            );
            this.person.rotation.set(
                this.personConst.startRotation.x,
                this.personConst.startRotation.y,
                this.personConst.startRotation.z * pos
            );


            this.person.skeleton.bones[17].position.y += -2;
            this.person.skeleton.bones[17].position.z += -1;
            this.person.skeleton.bones[15].rotation.x += Math.PI / 6;
            this.person.skeleton.bones[16].rotation.x += -Math.PI / 4;
           /* this.person.skeleton.bones[16].position.y += -1;
            this.person.skeleton.bones[15].position.y += -1;

            this.person.skeleton.bones[14].position.y += 0;
            this.person.skeleton.bones[13].position.y += 1.5;
            this.person.skeleton.bones[12].position.y += 1;

            this.person.skeleton.bones[12].rotation.z += Math.PI / 2;*/

            /*this.person.skeleton.bones[5].rotation.y += Math.PI / 2;
            this.person.skeleton.bones[5].rotation.z += Math.PI / 2;
            this.person.skeleton.bones[6].rotation.y += 3 * Math.PI / 2;
            this.person.skeleton.bones[7].rotation.y += Math.PI ;*/

            // this.person.skeleton.bones[5].position.y += 3 ;

            this.scene.add(this.person);

            console.log(this.person);
        }));
    }

    depnut() {
        /*let step = 0;
         let render = () => {
         window.requestAnimationFrame(render);
         step = Math.PI / 96;
         if (this.armRT) {
         this.armRT.skeleton.bones[7].rotation.x += step;
         this.armRT.skeleton.bones[7].rotation.y += step;
         }
         };
         render();*/
    }

    /**
     * Добавить в мир физики
     * @param elem
     * Position params:
     * @param x
     * @param y
     * @param z
     * @private
     */
    _addInWorld(elem, x, y, z) {
        let body = this.sceneContext.world.add({
            type: 'box',
            pos: [x, y, z],
            move: true,
            world: this.sceneContext.world,
        });
        this.sceneContext.worldBodies.push(body);
        this.sceneContext.worldMeshes.push(elem);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ObjPerson;


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 02.04.2017.
 */
class MultiPlayerStrategy{
    constructor() {
        console.log('MultiPlayerStrategy.c');
    }

    gameLoop(){

    }

    startGameLoop() {
        this.inteval = setInterval(() => this.gameLoop(), 100);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MultiPlayerStrategy;


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 07.04.2017.
 */
class GameStates{
    constructor(){
        this.SINGLEPLAYER_STRATEGY='SINGLEPLAYERSTRATEGY';
        this.MULTIPLAYER_STRATEGY='MULTIPLAYERSTRATEGY';

        this.STATEWAIT = 'STATEWAIT';
        this.STATEGAME = 'STATEGAME';
        this.STATERESULT = 'STATERESULT';
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameStates;


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Created by Denis on 23.03.2017.
 */

class Diamond {
    constructor(color, strokeWidth) {
        this._render(color || 'white', strokeWidth || '2');
    }

    getElem() {
        return this;
    }

    _render(color, strokeWidth) {
        this.el = document.createElement('canvas');
        this.el.setAttribute('width', '50');
        this.el.setAttribute('height', '50');
        this.el.setAttribute('class', 'diamond');
        if(this.el.getContext){
            let context = this.el.getContext('2d');
            context.beginPath();
            context.lineWidth=`${strokeWidth}`;
            context.strokeStyle=`${color}`;
            context.moveTo(12,8);
            context.lineTo(38,8);
            context.lineTo(47,19);
            context.lineTo(25,45);
            context.lineTo(2,19);
            context.lineTo(12,8);
            context.lineTo(17,19);
            context.lineTo(25,8);
            context.lineTo(32,19);
            context.lineTo(38,8);
            context.moveTo(2,19);
            context.lineTo(47,19);
            context.moveTo(17,19);
            context.lineTo(25,45);
            context.lineTo(32,19);
            context.stroke();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Diamond;


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__ = __webpack_require__(9);
/**
 * Created by Denis on 17.03.2017.
 */


class Router {

    /**
     * Конструктор
     * @param node - область действия
     */
    constructor(node) {
        this.node = node;
        this.routes = {};
        this.currView = null;

        window.onpopstate = (event) => {
            this.go(document.location.pathname, false);
        };
    }

    /**
     * Инициализация всех вьюшек
     * @param config
     */
    init(config) {
        Object.keys(config).forEach(url => {
            const View = config[url].View;
            const el = config[url].el;
            if (el) {
                this.register(url, new View(el, __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */], this));
            }
        });
        this.go(document.location.pathname);
    }

    /**
     * Перейти по маршруту и поменять текущую вьюшку
     * @param {string} path
     * @param isToHistory
     */
    go(path, isToHistory) {
        path = this._checkUser(path);
        if (isToHistory) {
            window.history.pushState({}, '', path);
        }
        if (this.currView) {
            this.currView.destroyView();
        }
        this.currView = this.getViewByRoute(path);

        if (!this.currView) {
            return;
        }
        if ('render' in this.currView) {
            this.currView.render();
        }
    }

    /**
     * Регистрация маршрута
     * @param {string} route
     * @param {Object} view
     */
    register(route, view) {
        this.routes[route] = view;
    }

    /**
     * Получение маршрута
     * @param href
     * @return {*}
     */
    getViewByRoute(href) {
        return this.routes[href];
    }

    /**
     * Запустить процес маршрутизации
     */
    start() {
        this.node.addEventListener('click', event => this._onRouteChange(event));
    }

    /**
     * Остановить процес маршрутизации
     */
    cansel() {
        this.node.removeEventListener('click', event => this._onRouteChange(event))
    }

    /**
     * Проверка на смененный маршрут
     * @param event
     * @private
     */
    _onRouteChange(event) {
        if (event.target instanceof HTMLAnchorElement) {
            event.preventDefault();
            this.go(event.target.getAttribute('href'), true);
        } else if (event.target.parentElement instanceof HTMLAnchorElement) {
            event.preventDefault();
            this.go(event.target.parentElement.getAttribute('href'), true);
        }
    }

    /**
     * Проверка, залогинен ли юзер
     * @param path
     * @private
     */
    _checkUser(path) {
        if (path === __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].urls.LOGIN || path === __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].urls.SIGNUP) {
            if (__WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].user) {
                return __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].urls.PROFILE;
            } else {
                return path;
            }
        } else if (path === __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].urls.PROFILE) {
            if (__WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].user) {
                return path;
            } else {
                return __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].urls.LOGIN;
            }
        } else if (path === __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].urls.GAME) {
            //!!! for debug only !!!
            return __WEBPACK_IMPORTED_MODULE_0__game_object_Storage__["a" /* default */].urls.GAME;
            /*if (Storage.user) {
                return Storage.urls.GAME;
            } else {
                return Storage.urls.MAIN;
            }*/
        } else {
            return path;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Router;



/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(2);
/**
 * Created by Denis on 19.03.2017.
 */

class AboutView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */]{
    constructor(node){
        super(node);
        this.node = node;

    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AboutView;


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elements_loader_loader__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__elements_form_form__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__js_support_service_UserService__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__js_game_object_Storage__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__js_support_router_RouterUrls__ = __webpack_require__(23);
/**
 * Created by Denis on 19.03.2017.
 */







class LoginView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */] {
    constructor(node, storage, router) {
        super(node);
        this.node = node;
        this.storage = storage;
        this.router = router;
    }

    /**
     * Отрисовка вьюшки
     */
    render() {
        this._showViewProgressBar();
        this.loginForm = new __WEBPACK_IMPORTED_MODULE_2__elements_form_form__["a" /* default */]({
            data: {
                title: {
                    text: 'Log In',
                    type: 'h3',
                    attrs: {
                        class: 'form__title'
                    }
                },
                form: {
                    attrs: {
                        class: 'form',
                        action: '',
                        method: ''
                    }
                },
                fields: [
                    {
                        attrs: {
                            placeholder: 'Login',
                            id: 'l-login',
                            class: 'form__input',
                            type: 'text',
                            name: 'login'
                        },
                        help_attrs: {
                            id: 'l-login-help',
                            class: 'form__help-text'
                        }
                    },
                    {
                        attrs: {
                            placeholder: 'Password',
                            id: 'l-password',
                            class: 'form__input',
                            type: 'password',
                            name: 'password'
                        },
                        help_attrs: {
                            id: 'l-password-help',
                            class: 'form__help-text'
                        }
                    }
                ],
                controls: [
                    {
                        text: 'Enter',
                        attrs: {
                            type: 'submit',
                            class: 'form__button',
                            id: 'btn-login'
                        },
                        type: 'button'
                    },
                    {
                        text: 'Sign up',
                        attrs: {
                            class: 'form__link',
                            id: 'btn-to-signup',
                            href: this.storage.urls.SIGNUP
                        },
                        type: 'a'
                    }
                ]
            }
        }).getElem();

        setTimeout(() => {
            this._hideViewProgressBar();

            let title = document.createElement('a');
            title.setAttribute('href', this.storage.urls.MAIN);
            title.setAttribute('class', 'main-title');
            let h1 = document.createElement('h1');
            h1.innerText='Step Fight';
            title.appendChild(h1);

            this.node.appendChild(title);
            this.node.appendChild(this.loginForm.el);

            this.login = document.getElementById('l-login');
            this.password = document.getElementById('l-password');
            this.loginHelp = document.getElementById('l-login-help');
            this.btnLogin = document.getElementById('btn-login');
            this.btnToSignUp = document.getElementById('btn-to-signup');

            this._initListener();
        }, 500);
    }

    /**
     * Показать прогресс бар вьюшки
     * @private
     */
    _showViewProgressBar() {
        let progressBar = new __WEBPACK_IMPORTED_MODULE_1__elements_loader_loader__["a" /* default */]().getElem();
        this.node.appendChild(progressBar);
    }

    /**
     * Спрятать прогресс бар вьюшки
     * @private
     */
    _hideViewProgressBar() {
        this.node.removeChild(this.node.lastChild);
    }

    /**
     * Показать прогресс бар формы
     * @private
     */
    _showProgressBar() {
        this.btnLogin.hidden = true;
        let progressBar = new __WEBPACK_IMPORTED_MODULE_1__elements_loader_loader__["a" /* default */]().getElemParent();
        this.btnLogin.parentNode.insertBefore(progressBar, this.btnLogin.nextSibling);
    }

    /**
     * Спрятать прогресс бар формы
     * @private
     */
    _hideProgressBar() {
        setTimeout(() => {
            this.btnLogin.hidden = false;
            this.btnLogin.parentNode.removeChild(this.btnLogin.nextElementSibling);
        }, 500);
    }

    /**
     * Запуск слушателей на форму
     * @private
     */
    _initListener() {
        //Submit form
        this.loginForm.el.addEventListener('submit', event => {
            event.preventDefault();
            if (this._checkFields()) {
                let body = this.loginForm.getFormData();

                this._showProgressBar();

                new __WEBPACK_IMPORTED_MODULE_3__js_support_service_UserService__["a" /* default */]().login(body).then(user => {
                    this._clearFields();
                    this.storage.user = user;
                    this.router.go(this.storage.urls.PROFILE, true);

                    this._hideProgressBar();
                }).catch(e => {
                    this.loginForm.fields.forEach(elem => {
                        elem.setError();
                        elem.setError('wrong data');
                    });
                    this._hideProgressBar();
                    console.error(e);
                });
            }
        });
        this.btnToSignUp.addEventListener('click', event=>{
            this._clearFields();
        })
    }

    /**
     * Отчистка полей формы
     * @private
     */
    _clearFields() {
        this.loginForm.fields.forEach(elem => {
            elem.clear();
        });
    }

    /**
     * Проверка полей формы
     * @return {boolean}
     * @private
     */
    _checkFields() {
        let check = true;

        this.loginForm.fields.forEach(elem => {
            let result = elem.validate();
            if (check === true) {
                check = result;
            }
        });

        return check;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LoginView;


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elements_form_form__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__elements_loader_loader__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__js_menu_actions_CheckFields__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_izitoast__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_izitoast___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_izitoast__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__js_support_service_UserService__ = __webpack_require__(1);
/**
 * Created by Denis on 19.03.2017.
 */







class SignUpView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */]{
    constructor(node, storage, router){
        super(node);
        this.node = node;
        this.storage = storage;
        this.router = router;
    }

    /**
     * Отрисовка вьюшки
     * @private
     */
    render() {
        this._showViewProgressBar();
        this.signupForm = new __WEBPACK_IMPORTED_MODULE_1__elements_form_form__["a" /* default */]({
            data: {
                title: {
                    text: 'Sign up',
                    type: 'h3',
                    attrs: {
                        class: 'form__title',
                    }
                },
                form: {
                    attrs: {
                        class: 'form',
                        action: '',
                        method: ''
                    }
                },
                fields: [
                    {
                        attrs: {
                            placeholder: 'Login',
                            id: 'r-login',
                            class: 'form__input',
                            type: 'text',
                            name: 'login',
                            valid: 'login'
                        },
                        help_attrs: {
                            id: 'r-login-help',
                            class: 'form__help-text'
                        }
                    },
                    {
                        attrs: {
                            placeholder: 'Password',
                            id: 'r-password',
                            class: 'form__input',
                            type: 'password',
                            name: 'password',
                            valid: 'password'
                        },
                        help_attrs: {
                            id: 'r-password-help',
                            class: 'form__help-text'
                        }
                    },
                    {
                        attrs: {
                            placeholder: 'Repeat password',
                            id: 'r-repeatpassword',
                            class: 'form__input',
                            type: 'password',
                            name: 'repeatpassword',
                            valid: 'repeatpassword'
                        },
                        help_attrs: {
                            id: 'r-repeatpassword-help',
                            class: 'form__help-text'
                        }
                    }
                ],
                controls: [
                    {
                        text: 'Registrate',
                        attrs: {
                            type: 'submit',
                            class: 'form__button',
                            id: 'btn-signup'
                        },
                        type: 'button'
                    },
                    {
                        text: 'Log In',
                        attrs: {
                            class: 'form__link',
                            id: 'btn-to-login',
                            href: this.storage.urls.LOGIN
                        },
                        type: 'a'
                    }
                ]
            }
        }).getElem();
        setTimeout(()=>{
            this._hideViewProgressBar();

            let title = document.createElement('a');
            title.setAttribute('href', this.storage.urls.MAIN);
            title.setAttribute('class', 'main-title');
            let h1 = document.createElement('h1');
            h1.innerText='Step Fight';
            title.appendChild(h1);

            this.node.appendChild(title);
            this.node.appendChild(this.signupForm.el);

            this.login = document.getElementById('r-login');
            this.password = document.getElementById('r-password');
            this.repeatPassword = document.getElementById('r-repeatpassword');

            this.loginHelp = document.getElementById('r-login-help');
            this.passwordHelp = document.getElementById('r-password-help');
            this.repeatPasswordHelp = document.getElementById('r-repeatpassword-help');

            this.btnSignUp = document.getElementById('btn-signup');

            this.btnToLogin = document.getElementById('btn-to-login');
            this._initListener();
        }, 500);
    }

    /**
     * Показать прогресс бар вьюшки
     * @private
     */
    _showViewProgressBar() {
        let progressBar = new __WEBPACK_IMPORTED_MODULE_2__elements_loader_loader__["a" /* default */]().getElem();
        this.node.appendChild(progressBar);
    }

    /**
     * Спрятать прогресс бар вьюшки
     * @private
     */
    _hideViewProgressBar() {
        this.node.removeChild(this.node.lastChild);
    }

    /**
     * Показать прогресс бар формы
     * @private
     */
    _showProgressBar() {
        this.btnSignUp.hidden = true;
        let progressBar = new __WEBPACK_IMPORTED_MODULE_2__elements_loader_loader__["a" /* default */]().getElemParent();
        this.btnSignUp.parentNode.insertBefore(progressBar, this.btnSignUp.nextSibling);
    }

    /**
     * Спрятать прогресс бар формы
     * @private
     */
    _hideProgressBar() {
        setTimeout(() => {
            this.btnSignUp.hidden = false;
            this.btnSignUp.parentNode.removeChild(this.btnSignUp.nextElementSibling);
        }, 500);
    }

    /**
     * Запуск слушателей
     * @private
     */
    _initListener() {
        //Submit form
        this.signupForm.el.addEventListener('submit', event => {
            event.preventDefault();

            if (this._checkFields()) {
                let body = this.signupForm.getFormData();
                this._showProgressBar();

                new __WEBPACK_IMPORTED_MODULE_5__js_support_service_UserService__["a" /* default */]().signup(body).then(response => {
                    this._clearFields();
                    this._hideProgressBar();
                    __WEBPACK_IMPORTED_MODULE_4_izitoast___default.a.success({
                        title: 'Successfully registered',
                        position: 'topRight'
                    });
                    this.router.go(this.storage.urls.LOGIN);
                }).catch(err => {
                    __WEBPACK_IMPORTED_MODULE_3__js_menu_actions_CheckFields__["a" /* default */].fieldRemoveOk(this.login);
                    __WEBPACK_IMPORTED_MODULE_3__js_menu_actions_CheckFields__["a" /* default */].fieldSetErr(this.login);
                    if(err.result === 'no-conn'){
                        __WEBPACK_IMPORTED_MODULE_3__js_menu_actions_CheckFields__["a" /* default */].helpSetText(this.loginHelp, 'check connection');
                    } else {
                        __WEBPACK_IMPORTED_MODULE_3__js_menu_actions_CheckFields__["a" /* default */].helpSetText(this.loginHelp, 'login used');
                    }
                    this._hideProgressBar();
                    console.error(err);
                });
            }
        });
        this.btnToLogin.addEventListener('click', event=>{
            this._clearFields();
        })
    }

    /**
     * Проверка полей формы
     * @return {boolean}
     * @private
     */
    _checkFields() {
        let check = true;
        let prev = null;

        this.signupForm.fields.forEach(elem => {
            let result = elem.validate(prev);
            prev = elem;
            if (check === true) {
                check = result;
            }
        });

        return check;
    }

    /**
     * Отчистка полей формы
     * @private
     */
    _clearFields() {
        this.signupForm.fields.forEach(elem => {
            elem.clear();
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = SignUpView;


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__js_game_modules_GameManager__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__js_game_modules_strategies_Singleplayer__ = __webpack_require__(21);
/**
 * Created by Denis on 17.03.2017.
 */




class GameView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */]{
    constructor(node, storage, router){
        super(node);
        this.node = node;
        this.storage = storage;
        this.router = router;

    }

    render(){
        new __WEBPACK_IMPORTED_MODULE_1__js_game_modules_GameManager__["a" /* default */](this.storage, this, this.storage.gameStates.SINGLEPLAYER_STRATEGY);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GameView;


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elements_loader_loader__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__js_support_service_UserService__ = __webpack_require__(1);
/**
 * Created by Denis on 19.03.2017.
 */



class LeaderBoardView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */] {
    constructor(node, storage, router) {
        super(node);
        this.node = node;
        this.storage = storage;
        this.router = router;
    }

    _refreshLeaderBoard(data) {
        let leaderBoardSource = `
                        {{#with logo}}
                            <a href="/" class="{{class}}"><h1>{{text}}</h1></a>
                        {{/with}}
                        {{#with title}}
                            <h2 class="{{class}}">{{text}}</h2>
                        {{/with}}
                        <p class="{{control.class}}" id="{{control.id}}">{{control.text}}</p>
                        {{#if leaderboard}}
                        <ul class="leaderboard-view__list">
                            {{#each leaderboard}}
                            <li class="leaderboard-view__list__item">{{login}}<span class="badge">{{rating}}</span>
                            <span class="position">{{position}}</span></li>
                            {{/each}}
                        </ul>
                        {{/if}}`;
        let leaderBoardTemplate = Handlebars.compile(leaderBoardSource);
        return leaderBoardTemplate(data);
    }

    render() {
        this._setProgressBar(this.node);

        new __WEBPACK_IMPORTED_MODULE_2__js_support_service_UserService__["a" /* default */]().getLeaders().then(response => {
            let arr = response.leaders;
            let iter = 1;
            arr.forEach(elem => {
                elem.position = `${iter}.`;
                iter++;
            });
            setTimeout(() => {
                this.node.innerHTML = this._refreshLeaderBoard({
                    logo: {
                        text: 'Step fight',
                        class: 'main-title'
                    },
                    title: {
                        text: 'Top players:',
                        class: 'leaderboard-view__title'
                    },
                    leaderboard: arr,
                    control: {
                        text: 'Refresh',
                        class: 'leaderboard-view__link',
                        id: 'refresh-lb'
                    }
                });
                this._initRefreshListener();
            }, 500);
        }).catch(err => {
            console.error(err);
            this.node.innerHTML = this._refreshLeaderBoard({
                titles: {
                    title: 'No connection',
                },
                err: {},
                control: {
                    text: 'Refresh',
                    class: 'leaderboard-view__link',
                    id: 'refresh-lb'
                }
            });
            this._initRefreshListener();
        });
    }

    _initRefreshListener() {
        let refresh = document.getElementById('refresh-lb');
        if (refresh) {
            refresh.addEventListener('click', () => {
                this.render();
            });
        }
    }

    _clearContainer(container) {
        while (container.children.length > 1) {
            container.removeChild(container.lastChild);
        }
    }

    _setProgressBar(container) {
        this._clearContainer(container);
        container.appendChild(new __WEBPACK_IMPORTED_MODULE_1__elements_loader_loader__["a" /* default */]().getElem());
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LeaderBoardView;


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(2);
/**
 * Created by Denis on 19.03.2017.
 */

class MenuView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */] {
    constructor(node, storage, router) {
        super(node);
        this.node = node;
        this.storage = storage;
        this.router = router;
    }

    /**
     * Отрисовка меню
     */
    render() {
        const instr = {
            title: {
                type: 'a',
                attrs: {
                    href: this.storage.urls.MAIN,
                    class: 'main-title'
                },
                element: {
                    type: 'h1',
                    text: 'Step Fight'
                }
            },
            elements: [
                {
                    type: 'a',
                    attrs: {
                        href: this.storage.urls.LEADERBOARD,
                        class: 'menu-view__controls-block__button'
                    },
                    element: {
                        type: 'h1',
                        text: 'LEADER BOARD'
                    }
                },
                {
                    type: 'a',
                    attrs: {
                        href: this.storage.urls.LOGIN,
                        class: 'menu-view__controls-block__button_main'
                    },
                    element: {
                        type: 'h1',
                        text: 'PLAY'
                    }
                },
                {
                    type: 'a',
                    attrs: {
                        href: this.storage.urls.ABOUT,
                        class: 'menu-view__controls-block__button'
                    },
                    element: {
                        type: 'h1',
                        text: 'ABOUT'
                    }
                }
            ]
        };
        let title = this._getTitle(instr.title);
        this.node.appendChild(title);
        let elemArray = this._getElems(instr.elements);

        let controlsBlock = document.createElement('div');
        controlsBlock.setAttribute('class', 'menu-view__controls-block');
        this._elemsAppendTo(elemArray, controlsBlock);
        this.node.appendChild(controlsBlock);
    }

    /**
     * Установка массив атрибкутов
     * @param attrs
     * @param elem
     * @private
     */
    _setAttrs(attrs, elem) {
        Object.keys(attrs).forEach(name => {
            elem.setAttribute(name, attrs[name]);
        });
    }

    /**
     * Добавить массив элементов
     * @param array
     * @param elem
     * @private
     */
    _elemsAppendTo(array, elem) {
        array.forEach(item => {
            elem.appendChild(item);
        })
    }

    /**
     * Получить массив элементов
     * @param elements - инструкции по созданию
     * @private
     */
    _getElems(elements) {
        return elements.map(data => {
            let elem = document.createElement(data.type);
            this._setAttrs(data.attrs, elem);
            let textElem = document.createElement(data.element.type);
            textElem.textContent = data.element.text;
            elem.appendChild(textElem);
            return elem;
        });
    }

    /**
     *  Получить заголовок
     * @param data
     * @return {Element}
     * @private
     */
    _getTitle(data) {
        let elem = document.createElement(data.type);
        this._setAttrs(data.attrs, elem);
        let textElem = document.createElement(data.element.type);
        textElem.textContent = data.element.text;
        elem.appendChild(textElem);
        return elem;
    }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = MenuView;


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseView__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__js_support_service_UserService__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__elements_loader_loader__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__js_menu_elements_Diamond__ = __webpack_require__(65);
/**
 * Created by Denis on 19.03.2017.
 */





class ProfileView extends __WEBPACK_IMPORTED_MODULE_0__BaseView__["a" /* default */] {
    constructor(node, storage, router) {
        super(node);
        this.node = node;
        this.storage = storage;
        this.router = router;
    }

    /**
     * Получить юзера
     * @return {Promise}
     * @private
     */
    _getUser() {
        return new Promise(function (resolve, reject) {
            new __WEBPACK_IMPORTED_MODULE_1__js_support_service_UserService__["a" /* default */]().getUser().then(user => {
                window.USER = user;
                resolve(user);
            }).catch(err => {
                reject({});
            });
        });
    }

    /**
     * Отрисовка профайла
     */
    render() {
        this._showViewProgressBar();
        this._getUser().then(user => {
            setTimeout(() => {
                this._hideViewProgressBar();
                this._renderProfile(user);

                this.login = document.getElementById('l-login');
                this.password = document.getElementById('l-password');
                this.loginHelp = document.getElementById('l-login-help');
                this.btnLogin = document.getElementById('btn-login');

                this._initListener();
            }, 500);
        }).catch(err => {
            this._hideViewProgressBar();
        });
    }

    /**
     * Запуск слушателей
     * @private
     */
    _initListener() {
        document.getElementById('btn-logout').addEventListener('click', event => {
            new __WEBPACK_IMPORTED_MODULE_1__js_support_service_UserService__["a" /* default */]().logOutUser().then(response => {
                this.storage.user = null;
                this.router.go(this.storage.urls.LOGIN, true);
            }).catch(err => {

            });
        });
    }

    /**
     * Показать прогресс бар вьюшки
     * @private
     */
    _showViewProgressBar() {
        let progressBar = new __WEBPACK_IMPORTED_MODULE_2__elements_loader_loader__["a" /* default */]().getElem();
        this.node.appendChild(progressBar);
    }

    /**
     * Спрятать прогресс бар вьюшки
     * @private
     */
    _hideViewProgressBar() {
        this.node.removeChild(this.node.lastChild);
    }

    /**
     * Отчистка контейнера
     * @private
     */
    _clearContainer() {
        while (this.node.children.length > 0) {
            this.node.removeChild(this.node.lastChild);
        }
    }

    /**
     * Обновить вьюшку
     */
    refresh() {
        this._clearContainer();
        this._showViewProgressBar();
        this._render();
    }

    /**
     * Создание элементов профайла
     * @param user
     * @return {Element}
     * @private
     */
    _renderProfile(user) {
        /* create main title */
        let title = document.createElement('a');
        title.setAttribute('href', this.storage.urls.MAIN);
        title.setAttribute('class', 'main-title');
        let textElem = document.createElement('h1');
        textElem.textContent = 'Step fight';
        title.appendChild(textElem);
        this.node.appendChild(title);


        /* create controllers div*/
        let controllersDiv = document.createElement('div');
        controllersDiv.setAttribute('class', 'profile-view__controllers');

        let hrefPlayM = document.createElement('a');
        hrefPlayM.setAttribute('href', this.storage.urls.GAME);
        hrefPlayM.setAttribute('class', 'profile-view__controllers__button');
        let h1 = document.createElement('h1');
        h1.innerHTML = 'Multiplayer';
        hrefPlayM.appendChild(h1);

        let hrefPlayS = document.createElement('a');
        hrefPlayS.setAttribute('href', this.storage.urls.GAME);
        hrefPlayS.setAttribute('class', 'profile-view__controllers__button');
        h1 = document.createElement('h1');
        h1.innerHTML = 'Single play';
        hrefPlayS.appendChild(h1);

        controllersDiv.appendChild(hrefPlayM);
        controllersDiv.appendChild(hrefPlayS);

        /*create user div*/
        let userDiv = document.createElement('div');
        userDiv.setAttribute('class', 'profile-view__user-info');

        let elem = document.createElement('h2');
        elem.setAttribute('class', 'profile-view__user-info__login');
        elem.innerText = `${user.login}`;
        userDiv.appendChild(elem);

        let arrValue = [
            {
                name: 'Rating:',
                value: user.rating
            },
            {
                name: 'Winnings:',
                value: user.game_count_win
            }, {
                name: 'Total matches: ',
                value: user.game_count
            }
        ];

        arrValue.forEach(el => {
            elem = document.createElement('h3');
            elem.setAttribute('class', 'profile-view__user-info__item');
            elem.innerText = `${el.name} ${el.value}`;
            userDiv.appendChild(elem);
        });

        /*create resources div*/
        let resourcesDiv = document.createElement('div');
        resourcesDiv.setAttribute('class', 'profile-view__resources');

        let arrCrystals = [
            {value: user.crystal_green, color: 'rgb(29, 140, 114)'},
            {value: user.crystal_blue, color: 'rgb(57, 108, 219)'},
            {value: user.crystal_red, color: 'rgb(138, 34, 76)'},
            {value: user.crystal_purple, color: 'rgb(80, 35, 153)'}];
        arrCrystals.forEach(params => {
            let div = document.createElement('div');
            div.setAttribute('class', 'profile-view__resources__diamond');

            let d = new __WEBPACK_IMPORTED_MODULE_3__js_menu_elements_Diamond__["a" /* default */](`${params.color}`).getElem().el;
            div.appendChild(d);

            elem = document.createElement('h3');
            elem.setAttribute('class', 'profile-view__resources__diamond__text');
            elem.innerText = `${params.value}`;
            div.appendChild(elem);
            resourcesDiv.appendChild(div);
        });

        this.node.appendChild(userDiv);
        this.node.appendChild(resourcesDiv);
        this.node.appendChild(controllersDiv);

        let hrefLogout = document.createElement('a');
        hrefLogout.setAttribute('class', 'profile-view__controllers__button_logout');
        hrefLogout.setAttribute('id', 'btn-logout');
        hrefLogout.innerText = 'Log out';
        this.node.appendChild(hrefLogout);

        return this.node;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ProfileView;


/***/ }),
/* 74 */,
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(4);
module.exports = __webpack_require__(24);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZGUzNTU4MjAzMzZkNTAyNDIyNTgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N1cHBvcnQvc2VydmljZS9Vc2VyU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvQmFzZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vfi93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2xvYWRlci9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZS9vYmplY3QvU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3VwcG9ydC9odHRwL0h0dHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aHJlZS9idWlsZC90aHJlZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2Zvcm0vZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZS9tb2R1bGVzL3N0cmF0ZWdpZXMvU2luZ2xlcGxheWVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tZW51L2FjdGlvbnMvQ2hlY2tGaWVsZHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N1cHBvcnQvcm91dGVyL1JvdXRlclVybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0FwcGxpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vaXppdG9hc3QvZGlzdC9qcy9pemlUb2FzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L29pbW8vYnVpbGQvb2ltby5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aHJlZS1vcmJpdC1jb250cm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvZm9ybS9fX2J1dHRvbi9mb3JtLWJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvZm9ybS9fX2lucHV0L2Zvcm0taW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2dhbWUtY29udHJvbHMvR2FtZUNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lL21vZHVsZXMvR2FtZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWUvbW9kdWxlcy9HYW1lU2NlbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWUvbW9kdWxlcy9PYmpQZXJzb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWUvbW9kdWxlcy9zdHJhdGVnaWVzL011bHRpcGxheWVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lL29iamVjdC9HYW1lU3RhdGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tZW51L2VsZW1lbnRzL0RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N1cHBvcnQvcm91dGVyL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYWJvdXQtdmlldy9BYm91dFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2VudGVyLXZpZXdzL0xvZ2luVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvZW50ZXItdmlld3MvU2lnblVwVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvZ2FtZS12aWV3L0dhbWVWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9sZWFkZXJib2FyZC12aWV3L0xlYWRlckJvYXJkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWVudS12aWV3L01lbnVWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9wcm9maWxlLXZpZXcvUHJvZmlsZVZpZXcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ2hFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQSwyQkFBMkIsU0FBUztBQUNwQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxhQUFhO0FBQ2I7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLGlCQUFpQjtBQUNqQiw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7QUNkQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMEJBQTBCLGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUM1Y0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLHlCQUF5QjtBQUN6QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUEwQjs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxZQUFZOztBQUUzQjs7QUFFQTs7QUFFQSxlQUFlLFlBQVk7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxzQkFBc0I7O0FBRTNEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQzs7QUFFdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSx1QkFBdUIsa0JBQWtCOztBQUV6QyxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLHVCQUF1QixrQkFBa0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsZUFBZSxlQUFlO0FBQzlDLGdCQUFnQixlQUFlLGVBQWU7QUFDOUMsZ0JBQWdCLGVBQWUsZ0JBQWdCO0FBQy9DLGdCQUFnQixlQUFlLGdCQUFnQjs7QUFFL0M7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7O0FBRWhDOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGtCQUFrQixrQkFBa0I7QUFDdkQsbUJBQW1CLGtCQUFrQixrQkFBa0I7QUFDdkQsb0JBQW9CLG1CQUFtQixvQkFBb0I7QUFDM0QscUJBQXFCLG9CQUFvQixvQkFBb0I7O0FBRTdEOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsZUFBZSxjQUFjLGNBQWM7QUFDM0MsZUFBZSxjQUFjLGNBQWM7QUFDM0MsZUFBZSxjQUFjLGVBQWU7QUFDNUMsZUFBZSxjQUFjLGVBQWU7O0FBRTVDOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLG1CQUFtQjs7QUFFbkMsZ0JBQWdCLG9CQUFvQjtBQUNwQyxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGlCQUFpQixxQkFBcUI7O0FBRXRDOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYzs7QUFFN0I7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxhQUFhLGFBQWE7QUFDeEMsY0FBYyxhQUFhLGFBQWE7QUFDeEMsY0FBYyxhQUFhLGNBQWM7QUFDekMsY0FBYyxhQUFhLGdCQUFnQjs7QUFFM0M7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWEsYUFBYTtBQUM1QyxjQUFjLGlCQUFpQixhQUFhO0FBQzVDLGNBQWMsYUFBYSxvQkFBb0I7QUFDL0MsY0FBYyxhQUFhLGNBQWM7O0FBRXpDOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxpQkFBaUIsUUFBUTs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhCQUE4QixlQUFlOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsOEJBQThCO0FBQzVELDhCQUE4Qiw4QkFBOEI7O0FBRTVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0IsK0JBQStCO0FBQzlELCtCQUErQiwrQkFBK0I7QUFDOUQsK0JBQStCLCtCQUErQjs7QUFFOUQ7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDOztBQUVsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEMsaUNBQWlDO0FBQ2pDLGlDQUFpQzs7QUFFakMsOENBQThDO0FBQzlDLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0IsK0JBQStCO0FBQzlELCtCQUErQiwrQkFBK0I7O0FBRTlEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLFNBQVM7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLFNBQVM7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7O0FBRWxDLGtDQUFrQztBQUNsQyxrQ0FBa0M7O0FBRWxDLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLFNBQVM7O0FBRTFDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLE9BQU87O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEsaUNBQWlDLFNBQVM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsU0FBUzs7QUFFMUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLHFCQUFxQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0ZBQStGOztBQUUvRixnRkFBZ0Y7O0FBRWhGLHdGQUF3Rjs7QUFFeEYsK0hBQStILHVEQUF1RCw2SEFBNkgseUhBQXlIOztBQUU1YSx1RUFBdUUsaUNBQWlDOztBQUV4RywwREFBMEQ7O0FBRTFELCtEQUErRDs7QUFFL0QsMEpBQTBKLGlDQUFpQyxrSUFBa0kseUdBQXlHLHlEQUF5RCw4RkFBOEYsZUFBZSxpQkFBaUIsR0FBRywyREFBMkQsd0NBQXdDLEdBQUcsdUVBQXVFLG1FQUFtRSw2REFBNkQsR0FBRyx5RkFBeUYsNkJBQTZCLGlFQUFpRSxpRUFBaUUsNkJBQTZCLEdBQUcsbUdBQW1HLDZCQUE2QixpRUFBaUUsaUVBQWlFLHlDQUF5QyxHQUFHLDZEQUE2RCw2QkFBNkIscURBQXFELDhDQUE4QyxHQUFHLDZKQUE2SixvQ0FBb0MsMkVBQTJFLDhFQUE4RSx1RUFBdUUsOERBQThELHNFQUFzRSwrQ0FBK0MsMkRBQTJELG9DQUFvQyx5QkFBeUIsR0FBRyx5RkFBeUYsaUNBQWlDLHNEQUFzRCx5Q0FBeUMsNkJBQTZCLDhCQUE4QiwrQkFBK0Isc0NBQXNDLGdHQUFnRyxtQ0FBbUMsY0FBYyxHQUFHLHdEQUF3RCxtQkFBbUIsb0NBQW9DLG9DQUFvQyxvQ0FBb0Msb0NBQW9DLFVBQVUsd0JBQXdCLEtBQUssMEJBQTBCLFlBQVksNENBQTRDLDRDQUE0QyxLQUFLLDBCQUEwQixZQUFZLDRDQUE0Qyw0Q0FBNEMsS0FBSywwQkFBMEIsWUFBWSw0Q0FBNEMsNENBQTRDLEtBQUssMEJBQTBCLFlBQVksNENBQTRDLDRDQUE0QyxLQUFLLDBCQUEwQixZQUFZLEtBQUssMEJBQTBCLFlBQVksNENBQTRDLDRDQUE0QyxLQUFLLDBCQUEwQixZQUFZLDRDQUE0Qyw0Q0FBNEMsS0FBSywwQkFBMEIsWUFBWSw0Q0FBNEMsNENBQTRDLG1CQUFtQixLQUFLLDBCQUEwQixZQUFZLDRDQUE0Qyw0Q0FBNEMsS0FBSywyQkFBMkIsWUFBWSxLQUFLLDJCQUEyQixZQUFZLGtCQUFrQiw0Q0FBNEMsNENBQTRDLEtBQUssMkJBQTJCLFlBQVksNENBQTRDLDRDQUE0QyxLQUFLLDJCQUEyQixZQUFZLGtCQUFrQixrQkFBa0IsNENBQTRDLDRDQUE0QyxLQUFLLDJCQUEyQixZQUFZLDRDQUE0Qyw0Q0FBNEMsS0FBSywyQkFBMkIsWUFBWSxLQUFLLG1DQUFtQyxtQ0FBbUMsR0FBRywwREFBMEQsbUNBQW1DLG1DQUFtQyx1RkFBdUYsZUFBZSxHQUFHLHVIQUF1SCxpREFBaUQsaURBQWlELGlEQUFpRCxpREFBaUQsR0FBRywySEFBMkgsNkJBQTZCLDhCQUE4QiwrQkFBK0IsZ0JBQWdCLHdDQUF3QywwQkFBMEIsbUVBQW1FLHdCQUF3Qiw0REFBNEQsNERBQTRELDREQUE0RCw0REFBNEQsVUFBVSxzQ0FBc0MsOENBQThDLGlEQUFpRCxpREFBaUQsaURBQWlELGlEQUFpRCxpREFBaUQsb0JBQW9CLDBFQUEwRSwwRUFBMEUsMEVBQTBFLDJGQUEyRiwyRkFBMkYsMEJBQTBCLHNDQUFzQyxnQkFBZ0IsR0FBRyw0UUFBNFEsdUJBQXVCLDRFQUE0RSxzREFBc0QsZ0NBQWdDLGtEQUFrRCxnQ0FBZ0Msb0RBQW9ELDBIQUEwSCxrR0FBa0cseUNBQXlDLCtCQUErQixHQUFHLGlMQUFpTCx1QkFBdUIsNEVBQTRFLGtDQUFrQywrRkFBK0YsOEJBQThCLEdBQUcsbUlBQW1JLHVFQUF1RSwwREFBMEQsb0RBQW9ELGlDQUFpQyxzRUFBc0UsZ0RBQWdELHVDQUF1QyxHQUFHLGtDQUFrQyxnQkFBZ0IsR0FBRyx3RUFBd0UsK0VBQStFLEdBQUcsb0tBQW9LLDJFQUEyRSw4REFBOEQsc0VBQXNFLCtDQUErQyx1Q0FBdUMsK0NBQStDLHlCQUF5QixHQUFHLG9FQUFvRSx5REFBeUQsR0FBRyxxRUFBcUUsaURBQWlELEdBQUc7O0FBRXJuVCw2RUFBNkUsNEJBQTRCLHNCQUFzQiwrQkFBK0IsK0JBQStCLDBEQUEwRCx3RUFBd0Usd0VBQXdFLDhCQUE4QixLQUFLLHdFQUF3RSxzQ0FBc0Msc0NBQXNDLDBCQUEwQixxQ0FBcUMscUNBQXFDLHNDQUFzQyxrRUFBa0UsMERBQTBELEtBQUs7O0FBRXowQiwrRUFBK0UsMkJBQTJCLFNBQVMsdUNBQXVDLCtEQUErRCxLQUFLLG1GQUFtRiwwQ0FBMEMseUJBQXlCLFNBQVMseUNBQXlDLDJFQUEyRSxPQUFPLDZCQUE2Qjs7QUFFcmhCLG9KQUFvSixpRUFBaUU7O0FBRXJOLDRJQUE0STs7QUFFNUksNklBQTZJOztBQUU3SSxxRUFBcUU7O0FBRXJFLG1FQUFtRTs7QUFFbkUsaUVBQWlFOztBQUVqRSwrREFBK0Q7O0FBRS9ELHVWQUF1VixZQUFZLEVBQUUsa0NBQWtDLGNBQWMsRUFBRSxrQ0FBa0MsZ0JBQWdCLGNBQWMsRUFBRSx3Q0FBd0MscUNBQXFDLEVBQUUsd0NBQXdDLDhEQUE4RCxtRUFBbUUsOEJBQThCLEdBQUcsd0JBQXdCLGVBQWUsbUJBQW1CLGlCQUFpQixJQUFJLHlCQUF5Qix1QkFBdUIsd0JBQXdCLHlCQUF5QiwwQkFBMEIsSUFBSSwyQkFBMkIsa0JBQWtCLGdCQUFnQixpQkFBaUIsSUFBSSwwREFBMEQsMERBQTBELEdBQUcsaUVBQWlFLDBEQUEwRCxHQUFHLGtGQUFrRiw4REFBOEQsNENBQTRDLEdBQUcsaUZBQWlGLDREQUE0RCxHQUFHLG9IQUFvSCxnSUFBZ0ksR0FBRyxxQ0FBcUMsYUFBYSwwQ0FBMEMsMENBQTBDLDBDQUEwQyxlQUFlLEdBQUc7O0FBRS9nRSw4SUFBOEksdUNBQXVDLGtCQUFrQiwyQ0FBMkMsbUZBQW1GLG1EQUFtRCxLQUFLLFVBQVUsbUZBQW1GLG1EQUFtRCxLQUFLLGdCQUFnQixHQUFHLDZMQUE2TCx5REFBeUQsd0NBQXdDLHdDQUF3QyxnREFBZ0QsZ0RBQWdELGtEQUFrRCx5Q0FBeUMsbUNBQW1DLGtEQUFrRCxHQUFHLGlNQUFpTSx1RUFBdUUsMkNBQTJDLGdFQUFnRSxxREFBcUQsbURBQW1ELCtEQUErRCx5RUFBeUUsZ0NBQWdDLDZDQUE2QyxXQUFXLGdCQUFnQiwrQ0FBK0MsdUNBQXVDLG9CQUFvQix1REFBdUQsc0RBQXNELDJEQUEyRCxLQUFLLHlCQUF5QixzREFBc0QseURBQXlELDJEQUEyRCxLQUFLLHlCQUF5QixzREFBc0QsNkRBQTZELDJEQUEyRCxLQUFLLHlCQUF5QixzREFBc0QscURBQXFELDZEQUE2RCxLQUFLLHlCQUF5Qix1REFBdUQsd0RBQXdELDZEQUE2RCxLQUFLLFVBQVUsdURBQXVELDREQUE0RCw2REFBNkQsS0FBSyxxQkFBcUIsb0RBQW9ELHVEQUF1RCw2Q0FBNkMsb0RBQW9ELEdBQUcsZ0lBQWdJLG9EQUFvRCxtQ0FBbUMsd0JBQXdCLGtDQUFrQyxtRUFBbUUsd0JBQXdCLDZCQUE2QixnQ0FBZ0MseUNBQXlDLDJDQUEyQywyREFBMkQsaUVBQWlFLDJEQUEyRCxpRUFBaUUsMkNBQTJDLGlDQUFpQyxHQUFHOztBQUUzbUksOEVBQThFLCtEQUErRDs7QUFFN0ksbUdBQW1HLG9DQUFvQyxtQ0FBbUM7O0FBRTFLLGtLQUFrSzs7QUFFbEsseUdBQXlHLHNFQUFzRSwrQ0FBK0M7O0FBRTlOLHlGQUF5Rjs7QUFFekYsK0VBQStFOztBQUUvRSx1RUFBdUUsaUJBQWlCLEdBQUcsNkRBQTZELGtFQUFrRSxHQUFHLDZEQUE2RCx3RUFBd0UsR0FBRyxzQ0FBc0Msc0xBQXNMLEdBQUcsc0NBQXNDLHVLQUF1SyxHQUFHLHNDQUFzQyxvRUFBb0UsR0FBRyxzQ0FBc0MsaUVBQWlFLHNFQUFzRSxzRUFBc0UsR0FBRyx5REFBeUQsdURBQXVELEdBQUcseURBQXlELDJEQUEyRCx3REFBd0QsNkNBQTZDLG1EQUFtRCxHQUFHLHlEQUF5RCx1RUFBdUUsR0FBRyx5REFBeUQsMkRBQTJELGlEQUFpRCxrREFBa0QsK0RBQStELEdBQUcsdUdBQXVHLHlDQUF5QywwQ0FBMEMsdURBQXVELGlCQUFpQiw0Q0FBNEMsK0NBQStDLDBCQUEwQiw0REFBNEQsbUJBQW1CLEdBQUcsbUhBQW1ILHdDQUF3Qyx5Q0FBeUMsbUJBQW1CLDJDQUEyQyx3Q0FBd0Msd0NBQXdDLGdEQUFnRCx1Q0FBdUMsR0FBRzs7QUFFMXdGLCtMQUErTCx5RUFBeUUsb0dBQW9HLDZGQUE2RixzREFBc0QsZ0pBQWdKLDREQUE0RCxxRUFBcUUsdUdBQXVHLG9EQUFvRCwrSkFBK0osc0VBQXNFLDJDQUEyQyx5REFBeUQsNklBQTZJLGtJQUFrSSw4R0FBOEc7O0FBRWpuRCwyR0FBMkcsa0NBQWtDLHdLQUF3SyxzRUFBc0Usd0NBQXdDLHVDQUF1Qyx5SUFBeUkscUNBQXFDOztBQUV4bkIsMkpBQTJKLHFDQUFxQyxvQ0FBb0M7O0FBRXBPLDZKQUE2SixxRkFBcUYsb0ZBQW9GLDZGQUE2RixzRkFBc0Y7O0FBRXpmLDZEQUE2RDs7QUFFN0QsZ0VBQWdFOztBQUVoRSwrSkFBK0oseUVBQXlFLDhFQUE4RTs7QUFFdFQsaUVBQWlFLDJCQUEyQixrREFBa0QscUNBQXFDLDJCQUEyQjs7QUFFOU0sOEVBQThFLG9FQUFvRSxrREFBa0Qsa0RBQWtELCtFQUErRSx3RUFBd0UsaUJBQWlCOztBQUU5WiwySUFBMkk7O0FBRTNJLGdGQUFnRixvQ0FBb0M7O0FBRXBILHdEQUF3RCw0QkFBNEIscUNBQXFDLG1EQUFtRCxrREFBa0QsZ0NBQWdDLDRDQUE0Qyx5Q0FBeUMsMENBQTBDLDRCQUE0QixrREFBa0Qsb0NBQW9DLGNBQWMsZ0NBQWdDLDhDQUE4QyxzQkFBc0IsU0FBUywrRUFBK0UsNERBQTRELHdEQUF3RCxrRUFBa0UsNkZBQTZGLGlCQUFpQixxREFBcUQscUJBQXFCLFNBQVMsNkVBQTZFLDREQUE0RCx3REFBd0Qsa0VBQWtFLDZGQUE2RixpQkFBaUIsb0RBQW9ELG9CQUFvQixTQUFTLDJGQUEyRiw0REFBNEQsd0RBQXdELGtFQUFrRSw2RkFBNkYsaUJBQWlCLHFEQUFxRCxxQkFBcUIsU0FBUyxxRkFBcUYsbUhBQW1ILGlCQUFpQjs7QUFFN3BFLGtEQUFrRCxxRUFBcUUsd0NBQXdDLDREQUE0RCxnQ0FBZ0MsR0FBRyxxREFBcUQscUJBQXFCLGlCQUFpQixpQkFBaUIsdUJBQXVCLHlCQUF5Qix5QkFBeUIsTUFBTSxpRUFBaUUsK0pBQStKLGlEQUFpRCx5REFBeUQsaUNBQWlDLEtBQUsseURBQXlELG9CQUFvQixpQkFBaUIscUJBQXFCLGtCQUFrQixpQkFBaUIsdUJBQXVCLHlCQUF5Qix5QkFBeUIsTUFBTSx1REFBdUQsNklBQTZJLDZEQUE2RCxtREFBbUQsOENBQThDLDJDQUEyQyw0SEFBNEgsaUVBQWlFLEtBQUssdURBQXVELG9CQUFvQixxQkFBcUIsaUJBQWlCLHFCQUFxQixrQkFBa0Isb0JBQW9CLHdCQUF3QixpQkFBaUIsdUJBQXVCLHlCQUF5Qix5QkFBeUIsTUFBTSxvREFBb0QsMklBQTJJLDREQUE0RCxtREFBbUQsOENBQThDLHlFQUF5RSwyQ0FBMkMsNEZBQTRGLDRDQUE0Qyx5SUFBeUksbUNBQW1DLE9BQU8sT0FBTyx3Q0FBd0Msb0NBQW9DLE9BQU8sS0FBSyxnRUFBZ0UsaUJBQWlCLG9CQUFvQixxQkFBcUIsc0JBQXNCLE1BQU0sNkJBQTZCLDJCQUEyQixpRUFBaUUsNkRBQTZELHFCQUFxQixvQkFBb0IsdUJBQXVCLE1BQU0sZ0VBQWdFLGlIQUFpSCxnRUFBZ0Usa0RBQWtELDRGQUE0RixnRUFBZ0Usb0NBQW9DLEtBQUssb0tBQW9LLGtGQUFrRix3R0FBd0csdUhBQXVILGdHQUFnRywrRUFBK0UscUhBQXFILDBEQUEwRCxrREFBa0QsZ0VBQWdFLEtBQUssa0dBQWtHLHFEQUFxRCwrR0FBK0csOERBQThELEtBQUssK0lBQStJLDJHQUEyRyxvR0FBb0csbUZBQW1GLDBGQUEwRiw2R0FBNkcsMEhBQTBILG1HQUFtRywrRUFBK0UsMEhBQTBILCtHQUErRyxnRUFBZ0UsMERBQTBELCtFQUErRSxpSEFBaUgsMEZBQTBGLCtFQUErRSxvSkFBb0osbUlBQW1JLDRHQUE0RywrRUFBK0UsMkRBQTJELEtBQUs7O0FBRTE5Tix5REFBeUQsMkNBQTJDLG9DQUFvQyx5Q0FBeUMsK0NBQStDOztBQUVoTyw2REFBNkQsOENBQThDLHFDQUFxQyx1QkFBdUIsd0JBQXdCLDZCQUE2Qiw0QkFBNEIsSUFBSSw2TkFBNk4sZ0RBQWdELGlEQUFpRCw4Q0FBOEMsa0ZBQWtGLDZNQUE2TSwrSkFBK0osOEVBQThFLDhFQUE4RSxLQUFLLDBMQUEwTCwySEFBMkgsdUZBQXVGLGtEQUFrRCxzRUFBc0UseUdBQXlHLG9MQUFvTCxHQUFHLGlMQUFpTCxpR0FBaUcsR0FBRzs7QUFFaHdFLDBEQUEwRCx1RUFBdUUsbUVBQW1FLDZIQUE2SCwwSUFBMEksK0NBQStDLHVFQUF1RTs7QUFFamtCLDhEQUE4RCx1QkFBdUIsNkJBQTZCLHdCQUF3QiwwQ0FBMEMsK0JBQStCLGNBQWMsb0tBQW9LLDZJQUE2SSxHQUFHLHlOQUF5TixnREFBZ0QsaURBQWlELDhDQUE4QyxtREFBbUQsNk1BQTZNLCtKQUErSix3RUFBd0Usd0VBQXdFLEtBQUssc0xBQXNMLDRFQUE0RSxnREFBZ0QsNERBQTRELHVJQUF1SSx3Q0FBd0Msb0xBQW9MLHdIQUF3SCwyTUFBMk0sYUFBYSw2S0FBNkssaUdBQWlHLEdBQUcsNk1BQTZNLDZGQUE2RiwwQkFBMEIseUdBQXlHLHdDQUF3QyxtTEFBbUwsbU5BQW1OLGFBQWEsa2tCQUFra0Isa0hBQWtILEdBQUc7O0FBRWx3SSxtREFBbUQsc0NBQXNDLDJCQUEyQixnREFBZ0QsNEJBQTRCLGdGQUFnRixvQkFBb0Isc0JBQXNCLFNBQVMsb0NBQW9DLHlFQUF5RSw0UEFBNFAsK0VBQStFLEtBQUsscUZBQXFGLG9CQUFvQixxQkFBcUIsU0FBUyxrQ0FBa0MsdUVBQXVFLGlQQUFpUCwrRUFBK0UsS0FBSyxrR0FBa0csb0JBQW9CLG9CQUFvQixTQUFTLGdEQUFnRCxxRkFBcUYsMlJBQTJSLCtFQUErRSxLQUFLLDJHQUEyRyxvQkFBb0IsMEJBQTBCLFNBQVMsMENBQTBDLDhFQUE4RSxLQUFLLGdIQUFnSCwyR0FBMkcsd0VBQXdFLG1EQUFtRCwrREFBK0QscUJBQXFCLFNBQVMsc0ZBQXNGLE9BQU8sbUtBQW1LLG1GQUFtRixtTEFBbUwsdUpBQXVKLG9EQUFvRCxxR0FBcUc7O0FBRXA4RyxxSkFBcUo7O0FBRXJKLHVGQUF1Riw2REFBNkQ7O0FBRXBKLGtIQUFrSCwwQ0FBMEM7O0FBRTVKLDhIQUE4SCxxRUFBcUUscUVBQXFFOztBQUV4USw4RUFBOEUsZ0RBQWdELCtCQUErQjs7QUFFN0osaUVBQWlFOztBQUVqRSxvS0FBb0ssaURBQWlEOztBQUVyTiw4RUFBOEUsMEJBQTBCOztBQUV4RywrREFBK0Qsa0ZBQWtGLHdDQUF3Qzs7QUFFekwsNEZBQTRGOztBQUU1Riw0SEFBNEgsMkVBQTJFLDJFQUEyRSwyRUFBMkU7O0FBRTdWLCtIQUErSCxzREFBc0Q7O0FBRXJMLDZIQUE2SCw0RUFBNEUsNEVBQTRFLDRFQUE0RSx3R0FBd0csNEVBQTRFLDRFQUE0RSw0RUFBNEU7O0FBRTdxQixxR0FBcUcsa0NBQWtDOztBQUV2SSwwSUFBMEksaUdBQWlHLGlEQUFpRCwyREFBMkQsdUZBQXVGLG1HQUFtRzs7QUFFamhCLG1GQUFtRiw2QkFBNkIsNERBQTRELG9DQUFvQyxvQ0FBb0MsZ0NBQWdDLGdDQUFnQyxvREFBb0QscURBQXFELHNDQUFzQyw4REFBOEQsc0NBQXNDLGlDQUFpQyxxQ0FBcUMsS0FBSzs7QUFFbG5CLDZEQUE2RCwyQ0FBMkMsR0FBRywrQ0FBK0MsK0JBQStCLEdBQUcsd0NBQXdDLDBDQUEwQywwRUFBMEUsdUVBQXVFLHNDQUFzQyw0Q0FBNEMsaURBQWlELGlDQUFpQyx5QkFBeUIsR0FBRyw4Q0FBOEMsbUNBQW1DLEdBQUcsbUdBQW1HLDZDQUE2QyxHQUFHLHlHQUF5RywrQ0FBK0MsR0FBRyxrR0FBa0csaUVBQWlFLEdBQUcscUdBQXFHLGdFQUFnRSxHQUFHOztBQUUveUMscUdBQXFHOztBQUVyRyx5RkFBeUYsd0VBQXdFLHNEQUFzRDs7QUFFdk4sK0RBQStELGtGQUFrRix3Q0FBd0M7O0FBRXpMLDRGQUE0Rjs7QUFFNUYsNElBQTRJLDZEQUE2RCw4RkFBOEYsdURBQXVELGlHQUFpRyx5REFBeUQsa0ZBQWtGLDJFQUEyRSxLQUFLLHNGQUFzRiwyQ0FBMkMsMENBQTBDLHdEQUF3RCx5RkFBeUYseUZBQXlGLHlGQUF5Rix5RkFBeUYsd0NBQXdDLG1DQUFtQyxtQ0FBbUMsaUNBQWlDLGVBQWUsS0FBSyx3SEFBd0gsdUNBQXVDLGtDQUFrQyw0SEFBNEgsMkNBQTJDLHNFQUFzRSwrQ0FBK0MsMEJBQTBCLDRGQUE0RixpREFBaUQsaURBQWlELGlEQUFpRCxpREFBaUQsdzBCQUF3MEIsbUdBQW1HLGlEQUFpRCxpREFBaUQsaURBQWlELGlEQUFpRCwwK0JBQTArQix1RkFBdUYsbUJBQW1CLGlCQUFpQixLQUFLLCtDQUErQywyQkFBMkIscUVBQXFFLDBCQUEwQixvREFBb0QseUJBQXlCLDRDQUE0QywyQ0FBMkMsa0NBQWtDLHVEQUF1RCxPQUFPLGtDQUFrQyxrQ0FBa0MsNkNBQTZDLE9BQU8sa0NBQWtDLGtDQUFrQywyQ0FBMkMscUNBQXFDLE9BQU8sZ0VBQWdFLEtBQUssNkhBQTZILDBFQUEwRSw2Q0FBNkMsK0NBQStDLHFFQUFxRSwrSUFBK0ksNHpCQUE0ekIsMkZBQTJGLGlCQUFpQjs7QUFFeGhOLHdJQUF3SSw2REFBNkQsNEZBQTRGLHVEQUF1RCwrRkFBK0YseURBQXlEOztBQUVoZiwwRkFBMEYsb0JBQW9CLFNBQVMsa0ZBQWtGLEtBQUsseURBQXlELHFCQUFxQixTQUFTLG9FQUFvRSxLQUFLLDBEQUEwRCxzQkFBc0IsU0FBUyxzRUFBc0UsS0FBSzs7QUFFbGhCLHVEQUF1RCx1QkFBdUIsd0ZBQXdGLG9CQUFvQixvQkFBb0IsU0FBUyxnREFBZ0QseU5BQXlOLEtBQUssNkRBQTZELG9CQUFvQixxQkFBcUIsU0FBUyxrQ0FBa0MsK0tBQStLLEtBQUssZ0VBQWdFLG9CQUFvQixzQkFBc0IsU0FBUyxvQ0FBb0MsMExBQTBMLEtBQUssc0NBQXNDLEdBQUc7O0FBRXpxQywyRkFBMkYsaURBQWlELGlEQUFpRCxpREFBaUQ7O0FBRTlPLDJFQUEyRSxtQ0FBbUMsMkRBQTJELG1DQUFtQyxvQ0FBb0MsOENBQThDLDBCQUEwQixzREFBc0QseURBQXlELG1EQUFtRCxvREFBb0QsNkJBQTZCLHdFQUF3RSx3RUFBd0Usd0VBQXdFLHdFQUF3RSwyQ0FBMkMsb0JBQW9CLE9BQU8sc0RBQXNELDhDQUE4QywyQ0FBMkMsb0JBQW9CLE9BQU87O0FBRTNqQyxzR0FBc0csK0JBQStCLG9EQUFvRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCwyQ0FBMkM7O0FBRWhZLDhFQUE4RSwwQ0FBMEMsMENBQTBDLDBDQUEwQywwQ0FBMEMsOERBQThELHNFQUFzRTs7QUFFMVgsbURBQW1ELCtFQUErRSx1Q0FBdUMsa0NBQWtDOztBQUUzTSx5RkFBeUY7O0FBRXpGLDhHQUE4Rzs7QUFFOUcsNkdBQTZHLHNDQUFzQyx3Q0FBd0MsdUNBQXVDLEdBQUcsMENBQTBDLGlDQUFpQyx1REFBdUQsR0FBRyw4TUFBOE0saUNBQWlDLHFHQUFxRyxHQUFHLGlEQUFpRCxpQ0FBaUMsOENBQThDLDRHQUE0RyxHQUFHOztBQUVoN0IsOFFBQThROztBQUU5USw0UUFBNFEsOEJBQThCOztBQUUxUyxtU0FBbVM7O0FBRW5TLGtHQUFrRzs7QUFFbEcsaUdBQWlHLHNCQUFzQjs7QUFFdkgsb0ZBQW9GOztBQUVwRixzTkFBc04sMkVBQTJFOztBQUVqUywyQ0FBMkMsc0JBQXNCLHdCQUF3Qiw4QkFBOEIsa0NBQWtDLDZGQUE2Riw4QkFBOEIsR0FBRzs7QUFFdlIsNkNBQTZDLGtDQUFrQyxpRUFBaUUsMkRBQTJEOztBQUUzTSxxRUFBcUUsNE9BQTRPLDJFQUEyRSw0REFBNEQsbU9BQW1PLHNGQUFzRixhQUFhOztBQUU5dkIsc1FBQXNRLDJSQUEyUjs7QUFFamlCLCtDQUErQyw4QkFBOEIsaUdBQWlHLGtJQUFrSSxHQUFHOztBQUVuVCxxREFBcUQsK0lBQStJLDJQQUEyUCxHQUFHOztBQUVsYyxpREFBaUQsc0JBQXNCLDhCQUE4QixrQ0FBa0MsaURBQWlELGtCQUFrQiw4REFBOEQseUVBQXlFLG9EQUFvRCxHQUFHOztBQUV4WSxpREFBaUQsa0NBQWtDLGlFQUFpRSwyREFBMkQ7O0FBRS9NLDRDQUE0Qyx3QkFBd0IseUJBQXlCLDBCQUEwQiw4QkFBOEIsZ0xBQWdMLDhGQUE4RixjQUFjLEtBQUsscUNBQXFDLGlEQUFpRCxxR0FBcUcseURBQXlELDZJQUE2STs7QUFFdnpCLDJDQUEyQywrQkFBK0IsOEJBQThCLHdLQUF3SyxvRUFBb0UsOERBQThELGdEQUFnRCxrR0FBa0c7O0FBRXBpQiwyQ0FBMkMsd0JBQXdCLDhDQUE4Qyw4YkFBOGIsd0ZBQXdGLHdTQUF3UyxtSEFBbUgsNkRBQTZELDhGQUE4Rix3REFBd0QsaUhBQWlILDZJQUE2STs7QUFFbi9DLHVWQUF1VixpaUJBQWlpQjs7QUFFeDNCLDZDQUE2Qyx3QkFBd0Isd0JBQXdCLDJCQUEyQixpREFBaUQsMm1CQUEybUIsd0ZBQXdGLHlHQUF5RywwQ0FBMEMsc1RBQXNULCtHQUErRywwR0FBMEcsMERBQTBELHlHQUF5Ryw0SUFBNEksaUhBQWlILDZJQUE2STs7QUFFM2pFLGtFQUFrRSxpREFBaUQsdVpBQXVaLHFrQkFBcWtCOztBQUUva0MsMERBQTBELHdCQUF3Qix3QkFBd0IsMEJBQTBCLHdCQUF3QixpdEJBQWl0Qix3RkFBd0YseUdBQXlHLDBDQUEwQywwaUJBQTBpQix1RkFBdUYsNklBQTZJOztBQUV0MkQsZ0VBQWdFLDhDQUE4QyxxWkFBcVosaVRBQWlULCtRQUErUSxxSEFBcUg7O0FBRXhyQyxnRUFBZ0Usd0JBQXdCLDBCQUEwQiwwQkFBMEIsd0JBQXdCLDhDQUE4QyxxQ0FBcUMscUNBQXFDLDhDQUE4Qyxzd0JBQXN3Qix3RkFBd0YseUdBQXlHLDBDQUEwQyxxbkJBQXFuQix5REFBeUQsNklBQTZJOztBQUV0bkUsc0VBQXNFLDhDQUE4Qyw0WkFBNFosaVRBQWlULCtRQUErUSx5RkFBeUY7O0FBRXpxQyx5REFBeUQsaUhBQWlILHNEQUFzRCxvTEFBb0wseUpBQXlKLEdBQUc7O0FBRWhqQixrSkFBa0osc0RBQXNELG1NQUFtTSw2UEFBNlAsNFRBQTRULFdBQVc7O0FBRS84Qix3Q0FBd0Msd0JBQXdCLCtRQUErUSw0RUFBNEUsaURBQWlELDBLQUEwSyx5REFBeUQsNklBQTZJOztBQUU1ekIsc0NBQXNDLHNCQUFzQiwwTUFBME0sd0tBQXdLLG1DQUFtQyx5S0FBeUs7O0FBRTFuQix5Q0FBeUMseUtBQXlLLDhFQUE4RSxHQUFHOztBQUVuUyxrRUFBa0Usd0hBQXdIOztBQUUxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsd0RBQXdEO0FBQ3hELHdDQUF3QztBQUN4Qyx3Q0FBd0M7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsYUFBYSxZQUFZOztBQUV6Qjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLGFBQWE7O0FBRXpCLFFBQVEsY0FBYztBQUN0QixpQkFBaUIsbUNBQW1DOztBQUVwRCxnQkFBZ0IsY0FBYztBQUM5QixhQUFhLGNBQWM7O0FBRTNCLFdBQVcsY0FBYztBQUN6QixlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLGFBQWE7QUFDOUIsb0JBQW9COztBQUVwQixFQUFFOztBQUVGOztBQUVBLFVBQVUsY0FBYztBQUN4QixtQkFBbUI7O0FBRW5CLEVBQUU7O0FBRUY7O0FBRUEsYUFBYSxjQUFjO0FBQzNCLHNCQUFzQjs7QUFFdEIsRUFBRTs7QUFFRjs7QUFFQSxnQkFBZ0I7O0FBRWhCLEVBQUU7O0FBRUY7O0FBRUEsWUFBWSxjQUFjO0FBQzFCLGNBQWM7O0FBRWQsRUFBRTs7QUFFRjs7QUFFQSxjQUFjLGNBQWM7QUFDNUIsZ0JBQWdCOztBQUVoQixFQUFFOztBQUVGOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDLHNCQUFzQixXQUFXO0FBQ2pDLHFCQUFxQjs7QUFFckIsRUFBRTs7QUFFRjs7QUFFQSxpQkFBaUI7O0FBRWpCLEVBQUU7O0FBRUY7O0FBRUEsaUJBQWlCOztBQUVqQixFQUFFOztBQUVGOztBQUVBLGdCQUFnQjs7QUFFaEIsRUFBRTs7QUFFRjs7QUFFQSxlQUFlLGlCQUFpQjtBQUNoQyxZQUFZLFdBQVc7QUFDdkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7O0FBRWIsRUFBRTs7QUFFRjs7QUFFQSxzQkFBc0IsWUFBWTs7QUFFbEMsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQixZQUFZOztBQUVaLGFBQWE7QUFDYixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRyxFQUFFOztBQUVMLHlCQUF5QixZQUFZO0FBQ3JDLDRCQUE0QixZQUFZOztBQUV4QyxlQUFlO0FBQ2YsWUFBWTtBQUNaLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsWUFBWTs7QUFFWixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUcsRUFBRTs7QUFFTCxrQkFBa0IsWUFBWTtBQUM5QixxQkFBcUIsWUFBWTs7QUFFakMsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixlQUFlO0FBQ2YsWUFBWTtBQUNaLGVBQWU7O0FBRWYsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkI7QUFDQSxHQUFHLEVBQUU7O0FBRUwsbUJBQW1CLFlBQVk7QUFDL0Isc0JBQXNCLFlBQVk7O0FBRWxDLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0EsbUJBQW1CO0FBQ25CLFlBQVk7QUFDWixlQUFlO0FBQ2YsWUFBWTtBQUNaO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGOztBQUVBLFlBQVksK0JBQStCO0FBQzNDLFlBQVksYUFBYTtBQUN6QixTQUFTLGFBQWE7QUFDdEIsVUFBVSxhQUFhO0FBQ3ZCLFFBQVEsY0FBYztBQUN0QixpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDLGVBQWUsK0JBQStCO0FBQzlDLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixXQUFXO0FBQzNCLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLFdBQVc7QUFDWCxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLGNBQWM7QUFDZCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUM7O0FBRWpDLGlDQUFpQztBQUNqQyx3QkFBd0I7QUFDeEIsNEJBQTRCOztBQUU1QixvQ0FBb0M7O0FBRXBDLDZCQUE2QjtBQUM3Qix1QkFBdUI7O0FBRXZCLHNCQUFzQjtBQUN0QiwrQkFBK0I7O0FBRS9CLGtCQUFrQjs7QUFFbEIsZUFBZTs7QUFFZiwwQkFBMEI7O0FBRTFCLDhCQUE4Qjs7QUFFOUIscUVBQXFFO0FBQ3JFLGlFQUFpRTtBQUNqRSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ2pFLGlFQUFpRTtBQUNqRSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ2pFLGlFQUFpRTtBQUNqRSxpRUFBaUU7O0FBRWpFLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQzs7QUFFL0MsMkVBQTJFO0FBQzNFLDJFQUEyRTs7QUFFM0UsT0FBTzs7QUFFUCwwRkFBMEY7O0FBRTFGLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsaUNBQWlDOztBQUVqQywyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLHdCQUF3Qjs7QUFFeEIsc0JBQXNCO0FBQ3RCLCtCQUErQjs7QUFFL0Isa0JBQWtCOztBQUVsQjs7QUFFQSw4QkFBOEI7O0FBRTlCLGlEQUFpRDs7QUFFakQ7O0FBRUEsT0FBTyw4QkFBOEI7O0FBRXJDLDRDQUE0Qzs7QUFFNUM7O0FBRUEsT0FBTyxPQUFPOztBQUVkLDRDQUE0QztBQUM1QywwQ0FBMEM7QUFDMUMsOEJBQThCO0FBQzlCLGlDQUFpQzs7QUFFakMsT0FBTzs7QUFFUCxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0QsUUFBUTs7QUFFMUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRDs7QUFFcEQsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQix5QkFBeUI7O0FBRXpCLDRCQUE0QjtBQUM1QixzQkFBc0I7O0FBRXRCLHFCQUFxQjs7QUFFckIsaUJBQWlCOztBQUVqQixtQ0FBbUM7O0FBRW5DLDZDQUE2Qzs7QUFFN0MsMEJBQTBCO0FBQzFCLG1HQUFtRztBQUNuRyxtR0FBbUc7O0FBRW5HLHdCQUF3Qjs7QUFFeEIsa0VBQWtFO0FBQ2xFLHlDQUF5QztBQUN6QyxzREFBc0Q7O0FBRXRELGlDQUFpQzs7QUFFakMsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxvREFBb0Q7O0FBRXBELHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLDRCQUE0Qjs7QUFFNUIscUJBQXFCOztBQUVyQixpQkFBaUI7O0FBRWpCLDBDQUEwQzs7QUFFMUMsMENBQTBDOztBQUUxQyxxRUFBcUU7O0FBRXJFLHlCQUF5Qjs7QUFFekIsb0RBQW9EO0FBQ3BELDRCQUE0Qjs7QUFFNUIsMkJBQTJCOztBQUUzQix3REFBd0Q7O0FBRXhELE9BQU8sT0FBTzs7QUFFZCxtQ0FBbUM7QUFDbkMsNEVBQTRFO0FBQzVFLHNEQUFzRDs7QUFFdEQsT0FBTzs7QUFFUCxzRkFBc0Y7O0FBRXRGLE1BQU07O0FBRU4sS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyx1QkFBdUI7O0FBRTVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSx1QkFBdUIsaUJBQWlCOztBQUV4QyxFQUFFOztBQUVGOztBQUVBLHVCQUF1QixrQkFBa0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEMsZUFBZSxnQkFBZ0IsYUFBYSxpQkFBaUIsWUFBWSxFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUMsNkVBQTZFLEdBQUc7QUFDbkgscUNBQXFDLDhDQUE4QyxHQUFHOztBQUV0Rjs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsdUJBQXVCOztBQUV2Qix1QkFBdUI7QUFDdkIsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLGdGQUFnRjtBQUNoRixnRkFBZ0Y7QUFDaEYsZ0ZBQWdGO0FBQ2hGLGdGQUFnRjtBQUNoRixnRkFBZ0Y7QUFDaEYsZ0ZBQWdGO0FBQ2hGLGdGQUFnRjs7QUFFaEY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTs7QUFFL0I7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYzs7QUFFN0I7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7O0FBRWhDOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxpQkFBaUIsT0FBTzs7QUFFeEI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlDQUFpQzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsUUFBUTs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCOztBQUVoQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7Ozs7QUFJRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyx1QkFBdUI7O0FBRTVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsZ0JBQWdCOztBQUUxQzs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLGtCQUFrQjs7QUFFNUM7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsNENBQTRDLE9BQU87O0FBRW5EO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGLHdCQUF3Qjs7QUFFeEI7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiwwQkFBMEI7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLDRCQUE0Qjs7QUFFL0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixxQkFBcUI7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRCxRQUFROztBQUU1RDs7QUFFQTs7QUFFQSxtREFBbUQsUUFBUTs7QUFFM0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGtCQUFrQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsd0JBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQix3QkFBd0I7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isa0JBQWtCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQix3QkFBd0I7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQix3QkFBd0I7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdCQUFnQjs7QUFFNUM7O0FBRUEscUNBQXFDLDJCQUEyQjs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsUUFBUTs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQSxtREFBbUQsUUFBUTs7QUFFM0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHNCQUFzQjs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUJBQW1COztBQUV2Qzs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxRQUFROztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLG9CQUFvQixvQkFBb0I7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsbUJBQW1CLDBCQUEwQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDLFFBQVE7O0FBRXZEOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsUUFBUTs7QUFFckQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDLFFBQVE7O0FBRWhEO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxRQUFROztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBa0QsUUFBUTs7QUFFMUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLFFBQVE7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDs7QUFFQTs7QUFFQSwrQ0FBK0MsUUFBUTs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsWUFBWTs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZOztBQUU5Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLDBCQUEwQjs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCOztBQUV6Qzs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLFFBQVE7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxRQUFROztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsUUFBUTs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUEsZ0RBQWdELFFBQVE7O0FBRXhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQSxpQ0FBaUMsUUFBUTs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLFFBQVE7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0RBQXdELFFBQVE7O0FBRWhFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVEQUF1RCxRQUFROztBQUUvRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkRBQTZELFFBQVE7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJEQUEyRCxRQUFROztBQUVuRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLHVCQUF1QixrQkFBa0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQywyQkFBMkI7O0FBRWhFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSCxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxRQUFROztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLDRCQUE0Qjs7QUFFM0U7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQSxvQkFBb0IsY0FBYzs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxlQUFlOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnREFBZ0Q7O0FBRWhELDBDQUEwQyxPQUFPOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsT0FBTzs7QUFFeEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsdUJBQXVCLGtCQUFrQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkVBQTZFLGtDQUFrQzs7QUFFL0c7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxPQUFPOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxRQUFROztBQUV4RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtHQUFrRztBQUNsRyxrR0FBa0c7QUFDbEcsa0dBQWtHO0FBQ2xHLGtHQUFrRztBQUNsRyxrR0FBa0c7QUFDbEcsa0dBQWtHOztBQUVsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxhQUFhOztBQUU1Qjs7QUFFQSxnQkFBZ0IsYUFBYTs7QUFFN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFlBQVk7O0FBRTNCLGdCQUFnQixZQUFZOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsYUFBYTs7QUFFM0I7O0FBRUEsZUFBZSxhQUFhOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsWUFBWTs7QUFFMUIsZUFBZSxZQUFZOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLGtCQUFrQjs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtEQUFrRCwrREFBK0QsRUFBRTs7QUFFbkg7O0FBRUE7O0FBRUE7QUFDQSxrREFBa0QsMERBQTBELEVBQUU7O0FBRTlHOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtEQUFrRCxvREFBb0QsRUFBRTs7QUFFeEc7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQixPQUFPOztBQUV4QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsWUFBWSxhQUFhLGVBQWUsR0FBRzs7QUFFbEY7O0FBRUE7O0FBRUEsa0NBQWtDLHFCQUFxQjs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7OztBQUdBLGlEQUFpRDtBQUNqRCwrQ0FBK0M7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLGdDQUFnQzs7QUFFaEMsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQixzQkFBc0I7O0FBRXRCOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7O0FBRUEsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDOztBQUVqQzs7QUFFQSxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7O0FBRWxDOztBQUVBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCLCtCQUErQjs7QUFFL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlEO0FBQ2pELCtDQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUIsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLDJCQUEyQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLGlEQUFpRCxPQUFPOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsd0NBQXdDLFFBQVE7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxZQUFZLFFBQVE7O0FBRXBCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVc7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnREFBZ0QsU0FBUzs7QUFFekQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixvQkFBb0I7O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsOEJBQThCOztBQUVoRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1Qjs7QUFFQSxtQkFBbUIsZUFBZTs7QUFFbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxZQUFZOztBQUVaOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscURBQXFELE9BQU87O0FBRTVEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0RBQWdELE9BQU87O0FBRXZEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0VBQXNFLFFBQVE7O0FBRTlFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQSxHQUFHOztBQUVIOztBQUVBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQWtEO0FBQy9FOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiwyQkFBMkI7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiwyQkFBMkI7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrRUFBa0U7O0FBRWxFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTzs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTs7QUFFdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUJBQW1COztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IscUNBQXFDOztBQUU3RDs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxPQUFPOztBQUVsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2RkFBNkY7QUFDN0Y7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1EQUFtRCxRQUFROztBQUUzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1EQUFtRCxRQUFROztBQUUzRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsbUJBQW1CLHNDQUFzQzs7QUFFekQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCwyQkFBMkI7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2RUFBNkUsa0NBQWtDOztBQUUvRzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsT0FBTzs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBLEtBQUs7O0FBRUwsbURBQW1ELE9BQU87O0FBRTFEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0RBQWdEOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7O0FBRXhDOztBQUVBOztBQUVBLCtDQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwRUFBMEUsa0NBQWtDOztBQUU1Rzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCwrQ0FBK0MsT0FBTzs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsT0FBTzs7QUFFdkM7O0FBRUEsZUFBZSxPQUFPOztBQUV0QjtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTs7QUFFQSxxQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxELGlCQUFpQixPQUFPOztBQUV4QjtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQzs7QUFFQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRCxnQkFBZ0IsT0FBTzs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLGFBQWE7O0FBRTFCOztBQUVBLGNBQWMsYUFBYTs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLFlBQVk7O0FBRXpCLGNBQWMsWUFBWTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixvQkFBb0I7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLFdBQVc7O0FBRXpCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxXQUFXOztBQUUxQjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsVUFBVTs7QUFFeEIsZUFBZSwwQkFBMEI7O0FBRXpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IseUJBQXlCOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQix5QkFBeUI7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLHFCQUFxQjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qix5QkFBeUI7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxxQkFBcUI7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLHFCQUFxQjs7QUFFbkM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxzQkFBc0I7O0FBRXBDLGVBQWUscUJBQXFCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsc0JBQXNCOztBQUVwQyxlQUFlLHFCQUFxQjs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxzQkFBc0I7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMscUJBQXFCOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsc0JBQXNCOztBQUVuQyxjQUFjLHFCQUFxQjs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGFBQWEscUJBQXFCOztBQUVsQyxjQUFjLHNCQUFzQjs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSxxQkFBcUI7O0FBRWxDLGNBQWMsc0JBQXNCOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLE9BQU87O0FBRXBDOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjs7QUFFaEIsZUFBZSxPQUFPOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsT0FBTzs7QUFFdkIsSUFBSTs7QUFFSixnQkFBZ0IsT0FBTzs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCOztBQUV0QixvQkFBb0IsUUFBUTs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHlCQUF5QjtBQUNuQyxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLHVCQUF1Qjs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsNEJBQTRCLFFBQVE7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDZDQUE2Qzs7QUFFN0MsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzRkFBc0Y7QUFDdEY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQixNQUFNOztBQUVOLDBCQUEwQjtBQUMxQiwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUIsTUFBTTs7QUFFTiwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQjs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUIsTUFBTTs7QUFFTiwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7O0FBRTFCLE1BQU07O0FBRU4sMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCOztBQUV4Qyx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCOztBQUUvQztBQUNBLG9CQUFvQix1QkFBdUI7O0FBRTNDLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTs7QUFFOUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix1QkFBdUI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrQkFBa0I7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEMsa0NBQWtDOztBQUVsQztBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUEsZ0JBQWdCOztBQUVoQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxRQUFROztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsUUFBUTs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxRUFBcUU7QUFDckU7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7O0FBRTdDOztBQUVBLGVBQWUsT0FBTzs7QUFFdEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLFFBQVE7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0ZBQXdGO0FBQ3hGLDBGQUEwRjtBQUMxRjs7QUFFQSxxRkFBcUY7O0FBRXJGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQyxRQUFROztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCOzs7QUFHQTs7QUFFQTs7QUFFQSx3QkFBd0I7O0FBRXhCLGdDQUFnQyxRQUFROztBQUV4Qzs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsNkRBQTZELFFBQVE7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsUUFBUTs7QUFFeEM7O0FBRUE7O0FBRUEsd0RBQXdELFFBQVE7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxhQUFhLG1CQUFtQjs7QUFFaEMsNEJBQTRCLE9BQU87O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDLFFBQVE7O0FBRXpDO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsVUFBVTs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxZQUFZOztBQUV6QixjQUFjLFVBQVU7O0FBRXhCOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsZUFBZSxvQkFBb0I7QUFDbkMsNkJBQTZCLFFBQVE7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsUUFBUTs7QUFFekM7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBLGVBQWUsVUFBVTs7QUFFekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsVUFBVTs7QUFFekI7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLGVBQWUsVUFBVTs7QUFFekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLFVBQVU7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxRQUFROztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxRQUFROztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxzQkFBc0I7O0FBRXBDOztBQUVBOztBQUVBLGVBQWUscUJBQXFCOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLHFCQUFxQjs7QUFFbkMsZUFBZSxvQkFBb0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLGtCQUFrQjs7QUFFL0IsY0FBYyxvQkFBb0I7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLGlCQUFpQjs7QUFFOUI7O0FBRUEsY0FBYyxtQkFBbUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLGVBQWU7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyw0QkFBNEI7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLGNBQWM7O0FBRTNCLGNBQWMsMkJBQTJCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixtQkFBbUI7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGLGtCQUFrQixtQkFBbUI7O0FBRXJDOztBQUVBLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7O0FBRUEsZ0NBQWdDLE9BQU87O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQSxrQkFBa0IsT0FBTzs7QUFFekI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQjs7QUFFcEIsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWMscUJBQXFCOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLHFCQUFxQjs7QUFFcEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsb0JBQW9COztBQUVsQyxlQUFlLG9CQUFvQjs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxxQkFBcUI7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMscUJBQXFCOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsb0JBQW9COztBQUVsQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGVBQWU7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLGVBQWU7O0FBRTVCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGtCQUFrQiwyQkFBMkI7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0IsaUJBQWlCOztBQUV2Qzs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsaUJBQWlCOztBQUU1RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQyxRQUFROztBQUU1Qzs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixXQUFXOztBQUVoQyxxQkFBcUI7O0FBRXJCLHNCQUFzQiwwQkFBMEI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLGtCQUFrQixpQkFBaUI7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esa0RBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7O0FBRTVCOztBQUVBLDZDQUE2Qzs7QUFFN0MsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyx1QkFBdUI7O0FBRXhEOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBLG9DQUFvQzs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDOztBQUVBOztBQUVBLElBQUk7O0FBRUosR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsRUFBRTs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYztBQUNkOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxFQUFFOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsY0FBYzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUwsZ0NBQWdDOztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLFNBQVM7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsU0FBUzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFROztBQUVSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLGFBQWE7O0FBRS9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFNBQVM7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsZUFBZTs7QUFFakM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWM7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWM7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVGQUF1RixjQUFjOztBQUVyRzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxnQkFBZ0I7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLGtCQUFrQix3QkFBd0I7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsa0JBQWtCLHdCQUF3Qjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7O0FBRXhDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQiw0QkFBNEI7O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCOztBQUU5Qzs7QUFFQSxzQkFBc0IsMENBQTBDOztBQUVoRTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLDRDQUE0Qzs7QUFFakU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsa0JBQWtCLHNCQUFzQjs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixxQkFBcUI7O0FBRXJDOztBQUVBOztBQUVBLGdCQUFnQixlQUFlOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLGVBQWU7O0FBRWpDOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLGVBQWU7O0FBRWpDOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCxPQUFPOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQsT0FBTzs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBa0QsT0FBTzs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7O0FBRXREO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsdUJBQXVCOztBQUUxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVc7O0FBRVgsR0FBRzs7QUFFSDs7QUFFQSxXQUFXOztBQUVYOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPOztBQUUzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsT0FBTzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGtCQUFrQixpQkFBaUI7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsT0FBTzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0MsT0FBTzs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG1CQUFtQjs7QUFFdkM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLGdCQUFnQjs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsZ0JBQWdCOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxnQkFBZ0I7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsS0FBSyx3QkFBd0I7O0FBRTVDLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLGVBQWU7O0FBRTdCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLGNBQWMsZUFBZTs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUZBQXVGOztBQUV2Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsZUFBZTs7QUFFOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLG1CQUFtQjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0JBQWdCOztBQUVuQzs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxnQ0FBZ0M7O0FBRWhDLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLE9BQU87O0FBRWhEOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQsa0JBQWtCOztBQUVsQixNQUFNOztBQUVOO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixvQ0FBb0MsZ0NBQWdDOztBQUVwRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxhQUFhOztBQUU1RDs7QUFFQTs7QUFFQSwrQ0FBK0MsYUFBYTs7QUFFNUQ7O0FBRUEsdUJBQXVCLG1CQUFtQjs7QUFFMUM7QUFDQTs7QUFFQSx5QkFBeUIsMEJBQTBCOztBQUVuRDs7QUFFQSw2Q0FBNkMsc0NBQXNDO0FBQ25GOztBQUVBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsa0JBQWtCOztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixpQkFBaUI7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsaUJBQWlCOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLE9BQU87O0FBRW5EOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7OztBQUdGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7O0FBR0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGtCQUFrQixpQkFBaUI7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTRDLFNBQVM7O0FBRXJEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnREFBZ0QsU0FBUzs7QUFFekQ7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGtCQUFrQixjQUFjOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQix5QkFBeUI7O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQ7QUFDQTs7QUFFQSxHQUFHLGdFQUFnRTs7QUFFbkU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsNENBQTRDOztBQUVoRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxTQUFTOztBQUU5Qzs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLHFDQUFxQyxTQUFTOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLHFDQUFxQyxTQUFTOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7O0FBRWpDOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUzs7QUFFakM7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLDJCQUEyQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHFCQUFxQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQix1Q0FBdUMsU0FBUzs7QUFFaEQ7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCLHdCQUF3QixnQkFBZ0I7QUFDeEMscUJBQXFCO0FBQ3JCLGtDQUFrQzs7QUFFbEM7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsOEJBQThCLEVBQUU7QUFDaEQsZ0JBQWdCLDJDQUEyQztBQUMzRCxHQUFHOztBQUVILDJCQUEyQiwrQkFBK0I7O0FBRTFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUMsU0FBUzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxTQUFTOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUwsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7O0FBRWhDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsZUFBZTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QixxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQixpQ0FBaUM7O0FBRWpDLCtCQUErQjtBQUMvQiw2QkFBNkI7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkIseUJBQXlCOztBQUV6Qjs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QyxTQUFTOztBQUVyRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxHQUFHLE9BQU87O0FBRVY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsOEJBQThCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7O0FBRWxDOztBQUVBOztBQUVBLGtCQUFrQixpQkFBaUI7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLGdCQUFnQjs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0MsU0FBUzs7QUFFeEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixlQUFlOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDLFNBQVM7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdDQUF3QyxTQUFTOztBQUVqRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCO0FBQ3RCOztBQUVBLG1DQUFtQzs7O0FBR25DLGlDQUFpQztBQUNqQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQiw4QkFBOEIsRUFBRTtBQUNqRCxpQkFBaUIsOEJBQThCO0FBQy9DLElBQUk7QUFDSjtBQUNBLGlCQUFpQiwrQkFBK0IsRUFBRTtBQUNsRCxpQkFBaUIsK0JBQStCO0FBQ2hELElBQUk7QUFDSjtBQUNBLGlCQUFpQiwwQ0FBMEMsRUFBRTtBQUM3RCxpQkFBaUIsMENBQTBDO0FBQzNEOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLHVDQUF1QyxTQUFTOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7OztBQUdGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLE9BQU87O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVixTQUFTO0FBQ1QsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSCw4SEFBOEg7QUFDOUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUgsNkNBQTZDO0FBQzdDLHVFQUF1RTs7QUFFdkU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVEQUF1RDtBQUN2RCxrREFBa0Q7QUFDbEQsc0NBQXNDOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0RBQW9ELFFBQVE7O0FBRTVEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtELFFBQVE7O0FBRTFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNERBQTRELGlDQUFpQzs7QUFFN0Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBLG9EQUFvRCxRQUFROztBQUU1RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxPQUFPOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxhQUFhOztBQUVyRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxxRkFBcUY7O0FBRTdIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLDRCQUE0Qjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qix1QkFBdUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsZ0ZBQWdGOztBQUV0STtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekMscUJBQXFCLG9CQUFvQjtBQUN6QyxxQkFBcUIsb0JBQW9COztBQUV6Qzs7QUFFQSxxQkFBcUIsb0JBQW9CO0FBQ3pDLHFCQUFxQixvQkFBb0I7QUFDekMscUJBQXFCLG9CQUFvQjs7QUFFekM7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3Qyw4Q0FBOEM7O0FBRXRGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsT0FBTzs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3QyxnQkFBZ0I7O0FBRXhEO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLDZCQUE2Qjs7QUFFckU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxjQUFjOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLGNBQWM7O0FBRTNCOztBQUVBOztBQUVBLGNBQWMsZUFBZTs7QUFFN0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLDZCQUE2Qjs7QUFFckU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDREQUE0RCxpQ0FBaUM7O0FBRTdGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLE9BQU87O0FBRTNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxhQUFhOztBQUVyRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDLDRDQUE0Qzs7QUFFcEY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTRELGVBQWU7O0FBRTNFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQyxzQkFBc0IscUJBQXFCO0FBQzNDLHNCQUFzQixxQkFBcUI7QUFDM0Msc0JBQXNCLHFCQUFxQjtBQUMzQyxzQkFBc0IscUJBQXFCO0FBQzNDLHNCQUFzQixxQkFBcUI7QUFDM0Msc0JBQXNCLHFCQUFxQjtBQUMzQyxzQkFBc0IscUJBQXFCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBOztBQUVBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLDZCQUE2Qjs7QUFFckU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBLG9CQUFvQjs7QUFFcEI7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0ZBQXdGLDRDQUE0Qzs7QUFFcEk7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw0RkFBNEYsNENBQTRDOztBQUV4STs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRVE7Ozs7Ozs7OztBQ2w2ekNSO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLEM7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMENBQTBDLHFCQUFxQixHQUFHLGNBQWM7QUFDaEY7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDJDQUEyQyxzQkFBc0IsR0FBRyxjQUFjO0FBQ2xGO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOzs7Ozs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQyxZQUFZLFNBQVM7QUFDckIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFFQUFxRTtBQUMzRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esc0NBQXNDLG1FQUFtRTtBQUN6RztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxzREFBc0Q7QUFDdEQsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsdUJBQXVCO0FBQ3BGLEtBQUs7QUFDTDtBQUNBLDhEQUE4RCxzQkFBc0I7QUFDcEY7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUM7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLHVCQUF1QjtBQUNsRixJQUFJO0FBQ0o7QUFDQSw0REFBNEQsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0eEJEO0FBQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUEwQjs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDOztBQUVBLHFDOztBQUVBLEtBQUs7O0FBRUwscUM7O0FBRUEsd0U7O0FBRUEsS0FBSzs7QUFFTCxrQzs7QUFFQSxxRDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsUUFBUTs7QUFFcEM7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUwsd0I7O0FBRUEsOEI7O0FBRUEsS0FBSzs7QUFFTCwyQjs7QUFFQSxxQzs7QUFFQSxLQUFLOztBQUVMLHlDOztBQUVBLHlEOztBQUVBLEtBQUs7O0FBRUwsbUNBQW1DLDhDQUE4QyxFQUFFOzs7O0FBSW5GOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QixzQkFBc0IsZUFBZSxFQUFFO0FBQ3BHLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakMsNEJBQTRCO0FBQzVCO0FBQ0EsMEJBQTBCLE1BQU0sTUFBTTtBQUN0QztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDJCQUEyQixNQUFNLE1BQU0sTUFBTTtBQUM3Qyx5QkFBeUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQ3ZELDRCQUE0QixNQUFNLE1BQU07QUFDeEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7Ozs7O0FBTUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7OztBQUdMLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxvQkFBb0IsYUFBYTtBQUNqQyxvQkFBb0IsYUFBYTtBQUNqQzs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckMsc0JBQXNCLGVBQWU7QUFDckMsc0JBQXNCLGVBQWU7QUFDckM7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0MsMkJBQTJCO0FBQzdEOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLHdCQUF3QixpQkFBaUI7QUFDekMsd0JBQXdCLGlCQUFpQjtBQUN6Qzs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckMsc0JBQXNCLGVBQWU7QUFDckMsc0JBQXNCLGVBQWU7QUFDckM7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0MsMkJBQTJCO0FBQzdEOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLHdCQUF3QixpQkFBaUI7QUFDekMsd0JBQXdCLGlCQUFpQjtBQUN6Qzs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QywwQkFBMEIsbUJBQW1CO0FBQzdDLDBCQUEwQixtQkFBbUI7QUFDN0M7O0FBRUEsS0FBSzs7QUFFTCwrQkFBK0I7O0FBRS9CO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IsbUJBQW1CLFlBQVk7QUFDL0IsbUJBQW1CLFlBQVk7QUFDL0I7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCLHFCQUFxQixTQUFTO0FBQzlCLHFCQUFxQixTQUFTOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOzs7O0FBSUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQyw2QkFBNkIsa0JBQWtCO0FBQy9DLDZCQUE2QixrQkFBa0I7QUFDL0MsU0FBUztBQUNULDZCQUE2QixrQkFBa0I7QUFDL0MsNkJBQTZCLGtCQUFrQjtBQUMvQyw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDLHNCQUFzQixlQUFlO0FBQ3JDLHNCQUFzQixlQUFlO0FBQ3JDOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixjQUFjO0FBQ25DLHFCQUFxQixjQUFjO0FBQ25DLHFCQUFxQixjQUFjOztBQUVuQzs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7O0FBR0w7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsdUJBQXVCLE9BQU87O0FBRTlCOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLHNCQUFzQixtQkFBbUI7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOzs7QUFHRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EseUJBQXlCLGdCQUFnQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQjs7QUFFQSxvQjs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOzs7QUFHTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOzs7QUFHTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYzs7QUFFbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSw2QkFBNkI7O0FBRTdCO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEscUNBQXFDLGdCQUFnQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsa01BQWtNOztBQUVsTSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsYUFBYTs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLGdJQUFnSTtBQUNoSTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGtIQUFrSDtBQUNsSDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SCxjQUFjO0FBQ3ZJO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EseUJBQXlCLGtCQUFrQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQSw4QkFBOEIsTUFBTTtBQUNwQyw4QkFBOEIsTUFBTTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQixFQUFFO0FBQzdDLHVCQUF1QixvQkFBb0IsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsWUFBWSxpQkFBaUI7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZLGlCQUFpQjtBQUNuRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsaUNBQWlDO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0U7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLHVCQUF1QixRQUFRO0FBQy9CLGFBQWE7QUFDYiwyQkFBMkIsWUFBWTtBQUN2Qyx3QkFBd0IsU0FBUztBQUNqQztBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHFCQUFxQixVQUFVO0FBQy9CLG9CQUFvQixTQUFTO0FBQzdCLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkMsdUJBQXVCLFFBQVE7QUFDL0IsYUFBYTtBQUNiLDJCQUEyQixZQUFZO0FBQ3ZDLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCLFVBQVU7QUFDL0Isb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCLFVBQVU7QUFDL0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwyQkFBMkIsWUFBWTtBQUN2Qyx1QkFBdUIsUUFBUTtBQUMvQixhQUFhO0FBQ2IsMkJBQTJCLFlBQVk7QUFDdkMsd0JBQXdCLFNBQVM7QUFDakM7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixxQkFBcUIsVUFBVTtBQUMvQixvQkFBb0IsU0FBUztBQUM3QixxQkFBcUIsVUFBVTtBQUMvQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkMsdUJBQXVCLFFBQVE7QUFDL0IsYUFBYTtBQUNiLDJCQUEyQixZQUFZO0FBQ3ZDLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCLFVBQVU7QUFDL0Isb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCLFVBQVU7QUFDL0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLHVCQUF1QixRQUFRO0FBQy9CLGFBQWE7QUFDYiwyQkFBMkIsWUFBWTtBQUN2Qyx3QkFBd0IsU0FBUztBQUNqQztBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHFCQUFxQixVQUFVO0FBQy9CLG9CQUFvQixTQUFTO0FBQzdCLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2Qyx1QkFBdUIsUUFBUTtBQUMvQixhQUFhO0FBQ2IsMkJBQTJCLFlBQVk7QUFDdkMsd0JBQXdCLFNBQVM7QUFDakM7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixxQkFBcUIsVUFBVTtBQUMvQixvQkFBb0IsU0FBUztBQUM3QixxQkFBcUIsVUFBVTtBQUMvQjtBQUNBLDZCQUE2QjtBQUM3QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QixtQkFBbUIsU0FBUztBQUM1QixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQiwwQkFBMEIsV0FBVyxXQUFXO0FBQ2hELDBCQUEwQixXQUFXLFdBQVc7QUFDaEQsMEJBQTBCLFlBQVksWUFBWTtBQUNsRCwwQkFBMEIsV0FBVyxXQUFXO0FBQ2hEO0FBQ0Esb0NBQW9DO0FBQ3BDLDJCQUEyQixZQUFZLFlBQVk7QUFDbkQsMkJBQTJCLFlBQVksWUFBWTtBQUNuRCwyQkFBMkIsWUFBWSxZQUFZO0FBQ25ELDJCQUEyQixZQUFZLFlBQVk7QUFDbkQ7QUFDQSxvQ0FBb0M7QUFDcEMsMkJBQTJCLFlBQVksWUFBWTtBQUNuRCwwQkFBMEIsV0FBVyxXQUFXO0FBQ2hELDBCQUEwQixXQUFXLFdBQVc7QUFDaEQsMkJBQTJCLFlBQVksWUFBWTtBQUNuRDtBQUNBLG9DQUFvQztBQUNwQywyQkFBMkIsWUFBWSxZQUFZO0FBQ25ELDBCQUEwQixZQUFZLFlBQVk7QUFDbEQsMEJBQTBCLFdBQVcsV0FBVztBQUNoRCwyQkFBMkIsWUFBWSxZQUFZO0FBQ25EO0FBQ0Esb0NBQW9DO0FBQ3BDLDJCQUEyQixZQUFZLFlBQVk7QUFDbkQsMkJBQTJCLFlBQVksWUFBWTtBQUNuRCwwQkFBMEIsV0FBVyxXQUFXO0FBQ2hELDBCQUEwQixXQUFXLFdBQVc7QUFDaEQ7QUFDQSxvQ0FBb0M7QUFDcEMsMEJBQTBCLFdBQVcsV0FBVztBQUNoRCwyQkFBMkIsV0FBVyxXQUFXO0FBQ2pELDBCQUEwQixZQUFZLFlBQVk7QUFDbEQsMkJBQTJCLFlBQVksWUFBWTtBQUNuRCwyQkFBMkIsWUFBWSxZQUFZO0FBQ25EOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCO0FBQy9CLDBCQUEwQixXQUFXLFdBQVc7QUFDaEQsMEJBQTBCLFdBQVcsV0FBVztBQUNoRCwwQkFBMEIsWUFBWSxZQUFZO0FBQ2xELDBCQUEwQixXQUFXLFdBQVc7QUFDaEQ7QUFDQSxvQ0FBb0M7QUFDcEMsMkJBQTJCLFlBQVksWUFBWTtBQUNuRCwyQkFBMkIsWUFBWSxZQUFZO0FBQ25ELDJCQUEyQixZQUFZLFlBQVk7QUFDbkQsMkJBQTJCLFlBQVksWUFBWTtBQUNuRDtBQUNBLG9DQUFvQztBQUNwQywyQkFBMkIsWUFBWSxZQUFZO0FBQ25ELDBCQUEwQixXQUFXLFdBQVc7QUFDaEQsMEJBQTBCLFdBQVcsV0FBVztBQUNoRCwyQkFBMkIsWUFBWSxZQUFZO0FBQ25EO0FBQ0Esb0NBQW9DO0FBQ3BDLDJCQUEyQixZQUFZLFlBQVk7QUFDbkQsMEJBQTBCLFlBQVksWUFBWTtBQUNsRCwwQkFBMEIsV0FBVyxXQUFXO0FBQ2hELDJCQUEyQixZQUFZLFlBQVk7QUFDbkQ7QUFDQSxvQ0FBb0M7QUFDcEMsMkJBQTJCLFlBQVksWUFBWTtBQUNuRCwyQkFBMkIsWUFBWSxZQUFZO0FBQ25ELDBCQUEwQixXQUFXLFdBQVc7QUFDaEQsMEJBQTBCLFdBQVcsV0FBVztBQUNoRDtBQUNBLG9DQUFvQztBQUNwQywwQkFBMEIsV0FBVyxXQUFXO0FBQ2hELDBCQUEwQixZQUFZLFlBQVk7QUFDbEQsMkJBQTJCLFlBQVksWUFBWTtBQUNuRCwyQkFBMkIsWUFBWSxZQUFZO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0EsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkI7OztBQUczQjs7QUFFQSx3Q0FBd0M7OztBQUd4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVELFVBQVUsYUFBYTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELCtEQUErRDtBQUMvRCx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDLGNBQWMsRUFBRTtBQUM3RDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQscUNBQXFDO0FBQ2xHO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsa0NBQWtDO0FBQ3ZHO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsZUFBZTs7QUFFeEQsZ0ZBQWdGOztBQUVoRixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7O0FBRUEsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRCxzREFBc0Q7QUFDdEQsaURBQWlEO0FBQ2pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUIsRUFBRTs7QUFFdkQ7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUIsRUFBRTs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkIsRUFBRTs7QUFFN0Q7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkIsRUFBRTs7QUFFOUQ7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDLDZCQUE2QixhQUFhO0FBQzFDLGdDQUFnQyxxQkFBcUIsRUFBRTs7OztBQUl2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsbURBQW1ELHFCQUFxQixFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwyQkFBMkIsRUFBRTtBQUNoRjtBQUNBLDJEQUEyRDtBQUMzRCxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixpQkFBaUI7O0FBRXhDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQsMEVBQTBFO0FBQzFFLHdFQUF3RTtBQUN4RSxzREFBc0Q7QUFDdEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxxQkFBcUIsRUFBRTtBQUMzRCxvQ0FBb0MscUJBQXFCLEVBQUU7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0MsZ0NBQWdDO0FBQy9FLG9EQUFvRCxnQ0FBZ0M7QUFDcEYsdURBQXVELGNBQWM7O0FBRXJFLCtDQUErQyxnQ0FBZ0M7QUFDL0Usb0RBQW9ELGdDQUFnQztBQUNwRix1REFBdUQsY0FBYzs7QUFFckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFLHFFQUFxRTtBQUNyRSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOzs7QUFHTCxDQUFDOztBQUVEOztBQUVBLFVBQVUsWUFBWTtBQUN0QixVQUFVLFFBQVE7O0FBRVY7Ozs7Ozs7QUNuK1hSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsa0JBQWtCLEdBQUc7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGtCQUFrQjs7QUFFbEIsZUFBZTs7QUFFZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOzs7Ozs7Ozs7QUMzL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzdCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZHQUEyQyxtQ0FBbUM7QUFDOUUsU0FBUzs7QUFFVCxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BELGlCQUFpQixtQ0FBbUM7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7QUM3QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUMvQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEZBQTJELGlDQUFpQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLEM7Ozs7Ozs7OztBQ25UQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQWdFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXFELDBGQUF5RDtBQUM5Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7OztBQ3pDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN4SUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7O0FDcE5BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEM7Ozs7Ozs7Ozs7O0FDaFBBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsaURBQWlELE9BQU8sUUFBUSxNQUFNO0FBQ3RFLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIseUNBQXlDLE9BQU8sSUFBSSxNQUFNO0FBQzFELDBCQUEwQjtBQUMxQixvQ0FBb0MsZUFBZSxRQUFRLFlBQVksSUFBSSxjQUFjO0FBQ3pGLDBCQUEwQjtBQUMxQjtBQUNBLDhCQUE4QjtBQUM5Qix1RUFBdUUsT0FBTyxzQkFBc0IsUUFBUTtBQUM1RyxxREFBcUQsVUFBVTtBQUMvRCw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7QUNwR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDOzs7Ozs7Ozs7Ozs7QUNqSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsR0FBRyxTQUFTO0FBQ3BEO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNEQUFzRDtBQUNuRSxhQUFhLHFEQUFxRDtBQUNsRSxhQUFhLG1EQUFtRDtBQUNoRSxhQUFhLHNEQUFzRDtBQUNuRTtBQUNBO0FBQ0E7O0FBRUEsc0dBQW1DLGFBQWE7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDIiwiZmlsZSI6ImFwcC5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA3NSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZGUzNTU4MjAzMzZkNTAyNDIyNTgiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwNS4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IEh0dHAgZnJvbSAnLi4vaHR0cC9IdHRwJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlclNlcnZpY2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5odHRwID0gbmV3IEh0dHAoKTtcclxuICAgICAgICB0aGlzLnVybCA9IHRoaXMuaHR0cC5CYXNlVXJsO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFVzZXIoKSB7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGAke3RoaXMudXJsfS91c2VyL2dldGA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUmVxdWVzdChhZGRyZXNzLCBudWxsLCAnR0VUJywgbnVsbCkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnVzZXIpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9naW4oYm9keSkge1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBgJHt0aGlzLnVybH0vdXNlci9sb2dpbmA7XHJcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ307XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUmVxdWVzdChhZGRyZXNzLCBoZWFkZXJzLCAnUE9TVCcsIGJvZHkpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS51c2VyKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNpZ251cChib2R5KSB7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGAke3RoaXMudXJsfS91c2VyL3NpZ251cGA7XHJcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ307XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUmVxdWVzdChhZGRyZXNzLCBoZWFkZXJzLCAnUE9TVCcsIGJvZHkpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7cmVzdWx0OiAnc3VjY2Vzcyd9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZighZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtyZXN1bHQ6ICduby1jb25uJ30pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe3Jlc3VsdDogJ2Vycm9yJ30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRMZWFkZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBgJHt0aGlzLnVybH0vdXNlci9sZWFkZXJzYDtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXF1ZXN0KGFkZHJlc3MsIG51bGwsICdHRVQnLCBudWxsKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9nT3V0VXNlcigpIHtcclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYCR7dGhpcy51cmx9L3VzZXIvbG9nb3V0YDtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXF1ZXN0KGFkZHJlc3MsIG51bGwsICdHRVQnLCBudWxsKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NyZWF0ZVJlcXVlc3QoYWRkcmVzcywgaGVhZGVycyA9IHt9LCB0eXBlID0gJ0dFVCcsIGJvZHkgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IGh0dHAgPSB0aGlzLmh0dHA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaHR0cC5yZXF1ZXN0KGFkZHJlc3MsIGhlYWRlcnMsIHR5cGUsIGJvZHkpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gJzIwMCBPSycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHt9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvc3VwcG9ydC9zZXJ2aWNlL1VzZXJTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTcuMDMuMjAxNy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VWaWV3IHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBkZXN0cm95Vmlldygpe1xyXG4gICAgICAgIHdoaWxlICh0aGlzLm5vZGUuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZpZXdzL0Jhc2VWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIihmdW5jdGlvbihzZWxmKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdXG5cbiAgICB2YXIgaXNEYXRhVmlldyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gICAgfVxuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge31cblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgfSwgdGhpcylcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gICAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlKycsJyt2YWx1ZSA6IHZhbHVlXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKG5hbWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsgaXRlbXMucHVzaCh2YWx1ZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCdcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSlcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHsgYm9keTogdGhpcy5fYm9keUluaXQgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgIGJvZHkudHJpbSgpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgICByYXdIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9ICdzdGF0dXMnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IDIwMFxuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSydcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDcuMDMuMjAxNy5cclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0JhciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RWxlbSgpIHtcclxuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbG9hZGVyJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RWxlbVBhcmVudCgpIHtcclxuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbG9hZGVyX3BhcmVudCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xyXG4gICAgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZWxlbWVudHMvbG9hZGVyL2xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwNi4wMy4yMDE3LlxyXG4gKi9cclxuXHJcbmltcG9ydCBSb3V0ZXJVcmxzIGZyb20gXCIuLi8uLi9zdXBwb3J0L3JvdXRlci9Sb3V0ZXJVcmxzXCI7XHJcbmltcG9ydCBHYW1lU3RhdGVzIGZyb20gXCIuL0dhbWVTdGF0ZXNcIjtcclxuXHJcbmNsYXNzIFN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnVybHNPYmogPSBuZXcgUm91dGVyVXJscygpO1xyXG4gICAgICAgIHRoaXMuZ2FtZVN0YXRlc09iaiA9IG5ldyBHYW1lU3RhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5vYmpVc2VyID0gbnVsbDtcclxuICAgICAgICBTdG9yYWdlLl9faW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB1c2VyKHVzZXIpe1xyXG4gICAgICAgIHRoaXMub2JqVXNlciA9IHVzZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHVzZXIoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYmpVc2VyO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB1cmxzKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsc09iajtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZ2FtZVN0YXRlcygpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdhbWVTdGF0ZXNPYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xyXG5leHBvcnQgZGVmYXVsdCBzdG9yYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9nYW1lL29iamVjdC9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDA1LjAzLjIwMTcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSHR0cCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBpZiAoSHR0cC5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSHR0cC5pbnN0YW5jZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2Jhc2VVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaSc7XHJcbiAgICAgICAgLy90aGlzLl9iYXNlVXJsID0gJ2h0dHBzOi8vdHAtc2VydmVyLWphdmEuaGVyb2t1YXBwLmNvbS9hcGknO1xyXG5cclxuICAgICAgICBIdHRwLmluc3RhbmNlID0gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgQmFzZVVybCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZVVybDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgQmFzZVVybCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Jhc2VVcmwgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXF1ZXN0KGFkZHJlc3MgPSAnJywgaGVhZGVycyA9IHt9LCB0eXBlID0gJ0dFVCcsIGJvZHkgPSB7fSkge1xyXG4gICAgICAgIGxldCBmZXRjaE9iaiA9IHtcclxuICAgICAgICAgICAgbWV0aG9kOiB0eXBlLFxyXG4gICAgICAgICAgICBtb2RlOiAnY29ycycsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXHJcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChib2R5KSB7XHJcbiAgICAgICAgICAgIGZldGNoT2JqLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZldGNoKGFkZHJlc3MsIGZldGNoT2JqKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIH0pLnRoZW4oanNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGpzb24pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHt9KTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyIHx8IGVyci5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvc3VwcG9ydC9odHRwL0h0dHAuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gUG9seWZpbGxzXG5cbmlmICggTnVtYmVyLkVQU0lMT04gPT09IHVuZGVmaW5lZCApIHtcblxuXHROdW1iZXIuRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDUyICk7XG5cbn1cblxuLy9cblxuaWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cblxuXHRNYXRoLnNpZ24gPSBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRyZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6ICsgeDtcblxuXHR9O1xuXG59XG5cbmlmICggRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHQvLyBNaXNzaW5nIGluIElFOS0xMS5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50b1N0cmluZygpLm1hdGNoKCAvXlxccypmdW5jdGlvblxccyooW15cXChcXHNdKikvIClbIDEgXTtcblxuXHRcdH1cblxuXHR9ICk7XG5cbn1cblxuaWYgKCBPYmplY3QuYXNzaWduID09PSB1bmRlZmluZWQgKSB7XG5cblx0Ly8gTWlzc2luZyBpbiBJRS5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuXG5cdCggZnVuY3Rpb24gKCkge1xuXG5cdFx0T2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0XHQndXNlIHN0cmljdCc7XG5cblx0XHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG91dHB1dCA9IE9iamVjdCggdGFyZ2V0ICk7XG5cblx0XHRcdGZvciAoIHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggKysgKSB7XG5cblx0XHRcdFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1sgaW5kZXggXTtcblxuXHRcdFx0XHRpZiAoIHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBuZXh0S2V5IGluIHNvdXJjZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHNvdXJjZSwgbmV4dEtleSApICkge1xuXG5cdFx0XHRcdFx0XHRcdG91dHB1dFsgbmV4dEtleSBdID0gc291cmNlWyBuZXh0S2V5IF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cbiAqL1xuXG5mdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7fVxuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlID0ge1xuXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRyZXR1cm4gbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDE7XG5cblx0fSxcblxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XG5cblx0XHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0XHRsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XG5cblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcblxuXHRcdFx0dmFyIGFycmF5ID0gW10sIGkgPSAwO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxufTtcblxudmFyIFJFVklTSU9OID0gJzg0JztcbnZhciBNT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xudmFyIEN1bGxGYWNlTm9uZSA9IDA7XG52YXIgQ3VsbEZhY2VCYWNrID0gMTtcbnZhciBDdWxsRmFjZUZyb250ID0gMjtcbnZhciBDdWxsRmFjZUZyb250QmFjayA9IDM7XG52YXIgRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSAwO1xudmFyIEZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG52YXIgQmFzaWNTaGFkb3dNYXAgPSAwO1xudmFyIFBDRlNoYWRvd01hcCA9IDE7XG52YXIgUENGU29mdFNoYWRvd01hcCA9IDI7XG52YXIgRnJvbnRTaWRlID0gMDtcbnZhciBCYWNrU2lkZSA9IDE7XG52YXIgRG91YmxlU2lkZSA9IDI7XG52YXIgRmxhdFNoYWRpbmcgPSAxO1xudmFyIFNtb290aFNoYWRpbmcgPSAyO1xudmFyIE5vQ29sb3JzID0gMDtcbnZhciBGYWNlQ29sb3JzID0gMTtcbnZhciBWZXJ0ZXhDb2xvcnMgPSAyO1xudmFyIE5vQmxlbmRpbmcgPSAwO1xudmFyIE5vcm1hbEJsZW5kaW5nID0gMTtcbnZhciBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcbnZhciBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbnZhciBNdWx0aXBseUJsZW5kaW5nID0gNDtcbnZhciBDdXN0b21CbGVuZGluZyA9IDU7XG52YXIgQWRkRXF1YXRpb24gPSAxMDA7XG52YXIgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcbnZhciBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbnZhciBNaW5FcXVhdGlvbiA9IDEwMztcbnZhciBNYXhFcXVhdGlvbiA9IDEwNDtcbnZhciBaZXJvRmFjdG9yID0gMjAwO1xudmFyIE9uZUZhY3RvciA9IDIwMTtcbnZhciBTcmNDb2xvckZhY3RvciA9IDIwMjtcbnZhciBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xudmFyIFNyY0FscGhhRmFjdG9yID0gMjA0O1xudmFyIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG52YXIgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG52YXIgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbnZhciBEc3RDb2xvckZhY3RvciA9IDIwODtcbnZhciBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xudmFyIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG52YXIgTmV2ZXJEZXB0aCA9IDA7XG52YXIgQWx3YXlzRGVwdGggPSAxO1xudmFyIExlc3NEZXB0aCA9IDI7XG52YXIgTGVzc0VxdWFsRGVwdGggPSAzO1xudmFyIEVxdWFsRGVwdGggPSA0O1xudmFyIEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbnZhciBHcmVhdGVyRGVwdGggPSA2O1xudmFyIE5vdEVxdWFsRGVwdGggPSA3O1xudmFyIE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbnZhciBNaXhPcGVyYXRpb24gPSAxO1xudmFyIEFkZE9wZXJhdGlvbiA9IDI7XG52YXIgTm9Ub25lTWFwcGluZyA9IDA7XG52YXIgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xudmFyIFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xudmFyIFVuY2hhcnRlZDJUb25lTWFwcGluZyA9IDM7XG52YXIgQ2luZW9uVG9uZU1hcHBpbmcgPSA0O1xudmFyIFVWTWFwcGluZyA9IDMwMDtcbnZhciBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG52YXIgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xudmFyIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xudmFyIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xudmFyIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xudmFyIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xudmFyIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gMzA3O1xudmFyIFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbnZhciBDbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcbnZhciBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcbnZhciBOZWFyZXN0RmlsdGVyID0gMTAwMztcbnZhciBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG52YXIgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG52YXIgTGluZWFyRmlsdGVyID0gMTAwNjtcbnZhciBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcbnZhciBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xudmFyIFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xudmFyIEJ5dGVUeXBlID0gMTAxMDtcbnZhciBTaG9ydFR5cGUgPSAxMDExO1xudmFyIFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcbnZhciBJbnRUeXBlID0gMTAxMztcbnZhciBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xudmFyIEZsb2F0VHlwZSA9IDEwMTU7XG52YXIgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XG52YXIgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbnZhciBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xudmFyIFVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxOTtcbnZhciBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xudmFyIEFscGhhRm9ybWF0ID0gMTAyMTtcbnZhciBSR0JGb3JtYXQgPSAxMDIyO1xudmFyIFJHQkFGb3JtYXQgPSAxMDIzO1xudmFyIEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XG52YXIgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xudmFyIFJHQkVGb3JtYXQgPSBSR0JBRm9ybWF0O1xudmFyIERlcHRoRm9ybWF0ID0gMTAyNjtcbnZhciBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xudmFyIFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMTtcbnZhciBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xudmFyIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XG52YXIgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMjAwNDtcbnZhciBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XG52YXIgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xudmFyIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XG52YXIgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcbnZhciBSR0JfRVRDMV9Gb3JtYXQgPSAyMTUxO1xudmFyIExvb3BPbmNlID0gMjIwMDtcbnZhciBMb29wUmVwZWF0ID0gMjIwMTtcbnZhciBMb29wUGluZ1BvbmcgPSAyMjAyO1xudmFyIEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xudmFyIEludGVycG9sYXRlTGluZWFyID0gMjMwMTtcbnZhciBJbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XG52YXIgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG52YXIgWmVyb1Nsb3BlRW5kaW5nID0gMjQwMTtcbnZhciBXcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcbnZhciBUcmlhbmdsZXNEcmF3TW9kZSA9IDA7XG52YXIgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcbnZhciBUcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcbnZhciBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG52YXIgc1JHQkVuY29kaW5nID0gMzAwMTtcbnZhciBHYW1tYUVuY29kaW5nID0gMzAwNztcbnZhciBSR0JFRW5jb2RpbmcgPSAzMDAyO1xudmFyIExvZ0x1dkVuY29kaW5nID0gMzAwMztcbnZhciBSR0JNN0VuY29kaW5nID0gMzAwNDtcbnZhciBSR0JNMTZFbmNvZGluZyA9IDMwMDU7XG52YXIgUkdCREVuY29kaW5nID0gMzAwNjtcbnZhciBCYXNpY0RlcHRoUGFja2luZyA9IDMyMDA7XG52YXIgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIF9NYXRoID0ge1xuXG5cdERFRzJSQUQ6IE1hdGguUEkgLyAxODAsXG5cdFJBRDJERUc6IDE4MCAvIE1hdGguUEksXG5cblx0Z2VuZXJhdGVVVUlEOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmJyb29mYS5jb20vVG9vbHMvTWF0aC51dWlkLmh0bVxuXG5cdFx0dmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcblx0XHR2YXIgdXVpZCA9IG5ldyBBcnJheSggMzYgKTtcblx0XHR2YXIgcm5kID0gMCwgcjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaSA9PT0gOCB8fCBpID09PSAxMyB8fCBpID09PSAxOCB8fCBpID09PSAyMyApIHtcblxuXHRcdFx0XHRcdHV1aWRbIGkgXSA9ICctJztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpID09PSAxNCApIHtcblxuXHRcdFx0XHRcdHV1aWRbIGkgXSA9ICc0JztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCBybmQgPD0gMHgwMiApIHJuZCA9IDB4MjAwMDAwMCArICggTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCApIHwgMDtcblx0XHRcdFx0XHRyID0gcm5kICYgMHhmO1xuXHRcdFx0XHRcdHJuZCA9IHJuZCA+PiA0O1xuXHRcdFx0XHRcdHV1aWRbIGkgXSA9IGNoYXJzWyAoIGkgPT09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHV1aWQuam9pbiggJycgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRcdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cblx0fSxcblxuXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG5cdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xuXG5cdFx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxuXHR9LFxuXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXG5cblx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xuXG5cdFx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG5cdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cblx0fSxcblxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuXHR9LFxuXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG5cblx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuXHR9LFxuXG5cdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XG5cblx0XHRyZXR1cm4gZGVncmVlcyAqIF9NYXRoLkRFRzJSQUQ7XG5cblx0fSxcblxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG5cdFx0cmV0dXJuIHJhZGlhbnMgKiBfTWF0aC5SQUQyREVHO1xuXG5cdH0sXG5cblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cblx0fSxcblxuXHRuZWFyZXN0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5yb3VuZCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cblx0fSxcblxuXHRuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHZhbHVlIC0tO1xuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDE7XG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gMjtcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA0O1xuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDg7XG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gMTY7XG5cdFx0dmFsdWUgKys7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5mdW5jdGlvbiBWZWN0b3IyKCB4LCB5ICkge1xuXG5cdHRoaXMueCA9IHggfHwgMDtcblx0dGhpcy55ID0geSB8fCAwO1xuXG59XG5cblZlY3RvcjIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBWZWN0b3IyLFxuXG5cdGlzVmVjdG9yMjogdHJ1ZSxcblxuXHRnZXQgd2lkdGgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54O1xuXG5cdH0sXG5cblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMueCA9IHZhbHVlO1xuXG5cdH0sXG5cblx0Z2V0IGhlaWdodCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnk7XG5cblx0fSxcblxuXHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMueSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0Ly9cblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy54IC09IHM7XG5cdFx0dGhpcy55IC09IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggKj0gdi54O1xuXHRcdHRoaXMueSAqPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xuXG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtaW4sIG1heDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWluID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdFx0bWF4ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgLyBsZW5ndGggKTtcblxuXHR9LFxuXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xuXG5cdH0sXG5cblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG5cdH0sXG5cblx0YW5nbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXG5cblx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKCB0aGlzLnksIHRoaXMueCApO1xuXG5cdFx0aWYgKCBhbmdsZSA8IDAgKSBhbmdsZSArPSAyICogTWF0aC5QSTtcblxuXHRcdHJldHVybiBhbmdsZTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb01hbmhhdHRhbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm90YXRlQXJvdW5kOiBmdW5jdGlvbiAoIGNlbnRlciwgYW5nbGUgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuXHRcdHZhciB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG5cdFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cbnZhciB0ZXh0dXJlSWQgPSAwO1xuXG5mdW5jdGlvbiBUZXh0dXJlKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IHRleHR1cmVJZCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cblx0dGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRleHR1cmUuREVGQVVMVF9JTUFHRTtcblx0dGhpcy5taXBtYXBzID0gW107XG5cblx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xuXG5cdHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHR0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG5cdHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IGFuaXNvdHJvcHkgOiAxO1xuXG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBSR0JBRm9ybWF0O1xuXHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVW5zaWduZWRCeXRlVHlwZTtcblxuXHR0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XG5cdHRoaXMucmVwZWF0ID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG5cdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuXHR0aGlzLmZsaXBZID0gdHJ1ZTtcblx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0O1x0Ly8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXG5cblxuXHQvLyBWYWx1ZXMgb2YgZW5jb2RpbmcgIT09IFRIUkVFLkxpbmVhckVuY29kaW5nIG9ubHkgc3VwcG9ydGVkIG9uIG1hcCwgZW52TWFwIGFuZCBlbWlzc2l2ZU1hcC5cblx0Ly9cblx0Ly8gQWxzbyBjaGFuZ2luZyB0aGUgZW5jb2RpbmcgYWZ0ZXIgYWxyZWFkeSB1c2VkIGJ5IGEgTWF0ZXJpYWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBtYWtlIHRoZSBNYXRlcmlhbFxuXHQvLyB1cGRhdGUuICBZb3UgbmVlZCB0byBleHBsaWNpdGx5IGNhbGwgTWF0ZXJpYWwubmVlZHNVcGRhdGUgdG8gdHJpZ2dlciBpdCB0byByZWNvbXBpbGUuXG5cdHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gZW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcblxuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcblxufVxuXG5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFVWTWFwcGluZztcblxuVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRleHR1cmUsXG5cblx0aXNUZXh0dXJlOiB0cnVlLFxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0dGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcblx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xuXG5cdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XG5cblx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuXHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cblx0XHR0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG5cdFx0dGhpcy50eXBlID0gc291cmNlLnR5cGU7XG5cblx0XHR0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XG5cdFx0dGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xuXHRcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG5cdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSBzb3VyY2UudW5wYWNrQWxpZ25tZW50O1xuXHRcdHRoaXMuZW5jb2RpbmcgPSBzb3VyY2UuZW5jb2Rpbmc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0aWYgKCBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGNhbnZhcztcblxuXHRcdFx0aWYgKCBpbWFnZS50b0RhdGFVUkwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjYW52YXMgPSBpbWFnZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdFx0Y2FudmFzLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xuXG5cdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgb3V0cHV0ID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC40LFxuXHRcdFx0XHR0eXBlOiAnVGV4dHVyZScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ1RleHR1cmUudG9KU09OJ1xuXHRcdFx0fSxcblxuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXG5cdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cblx0XHRcdHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXG5cdFx0XHRvZmZzZXQ6IFsgdGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSBdLFxuXHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXG5cblx0XHRcdG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXG5cdFx0XHRtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxuXHRcdFx0YW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5LFxuXG5cdFx0XHRmbGlwWTogdGhpcy5mbGlwWVxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gVE9ETzogTW92ZSB0byBUSFJFRS5JbWFnZVxuXG5cdFx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG5cdFx0XHRpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpbWFnZS51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSB7XG5cdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcblx0XHRcdFx0XHR1cmw6IGdldERhdGFVUkwoIGltYWdlIClcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fSxcblxuXHR0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcblxuXHRcdGlmICggdGhpcy5tYXBwaW5nICE9PSBVVk1hcHBpbmcgKSByZXR1cm47XG5cblx0XHR1di5tdWx0aXBseSggdGhpcy5yZXBlYXQgKTtcblx0XHR1di5hZGQoIHRoaXMub2Zmc2V0ICk7XG5cblx0XHRpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xuXG5cdFx0XHRcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XG5cblx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XG5cblx0XHRcdFx0XHR1di54ID0gdXYueCA8IDAgPyAwIDogMTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di54ICkgJSAyICkgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdHV2LnggPSBNYXRoLmNlaWwoIHV2LnggKSAtIHV2Lng7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcblxuXHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5mbGlwWSApIHtcblxuXHRcdFx0dXYueSA9IDEgLSB1di55O1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuT2JqZWN0LmFzc2lnbiggVGV4dHVyZS5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuZnVuY3Rpb24gVmVjdG9yNCggeCwgeSwgeiwgdyApIHtcblxuXHR0aGlzLnggPSB4IHx8IDA7XG5cdHRoaXMueSA9IHkgfHwgMDtcblx0dGhpcy56ID0geiB8fCAwO1xuXHR0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn1cblxuVmVjdG9yNC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFZlY3RvcjQsXG5cblx0aXNWZWN0b3I0OiB0cnVlLFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cdFx0dGhpcy53ID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXHRcdHRoaXMudyA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xuXG5cdFx0dGhpcy53ID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRjYXNlIDM6IHJldHVybiB0aGlzLnc7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cdFx0dGhpcy53ICs9IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblx0XHR0aGlzLncgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXHRcdHRoaXMudyArPSB2LncgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cdFx0dGhpcy53IC09IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblx0XHR0aGlzLncgLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0dGhpcy53ID0gYS53IC0gYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcblxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy53ICo9IHNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblx0XHRcdHRoaXMudyA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSAqIHc7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xuXHRcdHRoaXMudyA9IGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICogdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fSxcblxuXHRzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxuXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xuXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcblxuXHRcdGlmICggcyA8IDAuMDAwMSApIHtcblxuXHRcdFx0IHRoaXMueCA9IDE7XG5cdFx0XHQgdGhpcy55ID0gMDtcblx0XHRcdCB0aGlzLnogPSAwO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0IHRoaXMueCA9IHEueCAvIHM7XG5cdFx0XHQgdGhpcy55ID0gcS55IC8gcztcblx0XHRcdCB0aGlzLnogPSBxLnogLyBzO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcblx0XHRcdGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xuXHRcdFx0ZXBzaWxvbjIgPSAwLjEsXHRcdC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cblx0XHRcdHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcblx0XHQgICAgICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApICYmXG5cdFx0ICAgICAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcblxuXHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcblx0XHRcdC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcblx0XHRcdC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcblxuXHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yICkgJiZcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApICYmXG5cdFx0XHQgICAgICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKSAmJlxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xuXG5cdFx0XHRcdC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxuXG5cdFx0XHRcdHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcblxuXHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xuXG5cdFx0XHR2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XG5cdFx0XHR2YXIgeXkgPSAoIG0yMiArIDEgKSAvIDI7XG5cdFx0XHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XG5cdFx0XHR2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcblx0XHRcdHZhciB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xuXHRcdFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XG5cblx0XHRcdGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7XG5cblx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuXHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHggPSBNYXRoLnNxcnQoIHh4ICk7XG5cdFx0XHRcdFx0eSA9IHh5IC8geDtcblx0XHRcdFx0XHR6ID0geHogLyB4O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHtcblxuXHRcdFx0XHQvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICggeXkgPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcblx0XHRcdFx0XHR4ID0geHkgLyB5O1xuXHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblxuXHRcdFx0XHRpZiAoIHp6IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eiA9IDA7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XG5cdFx0XHRcdFx0eCA9IHh6IC8gejtcblx0XHRcdFx0XHR5ID0geXogLyB6O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cblx0XHR9XG5cblx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XG5cblx0XHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xuXHRcdCAgICAgICAgICAgICAgICAgICAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKSArXG5cdFx0ICAgICAgICAgICAgICAgICAgICggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXG5cblx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xuXG5cdFx0Ly8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxuXHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxuXG5cdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0dGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG5cdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblx0XHR0aGlzLncgPSBNYXRoLm1pbiggdGhpcy53LCB2LncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cdFx0dGhpcy53ID0gTWF0aC5tYXgoIG1pbi53LCBNYXRoLm1pbiggbWF4LncsIHRoaXMudyApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWluLCBtYXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1pbiA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0XHRcdG1heCA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXHRcdHRoaXMueiA9IC0gdGhpcy56O1xuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cblx0fSxcblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcblxuXHR9LFxuXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XG5cblx0fSxcblxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cdFx0dGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cdFx0dGhpcy53ID0gYXR0cmlidXRlLmdldFcoIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgTWFyaXVzIEtpbnRlbCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9raW50ZWxcbiAqL1xuXG4vKlxuIEluIG9wdGlvbnMsIHdlIGNhbiBzcGVjaWZ5OlxuICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxuICogZGVwdGhCdWZmZXIvc3RlbmNpbEJ1ZmZlcjogQm9vbGVhbnMgdG8gaW5kaWNhdGUgaWYgd2Ugc2hvdWxkIGdlbmVyYXRlIHRoZXNlIGJ1ZmZlcnNcbiovXG5mdW5jdGlvbiBXZWJHTFJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdHRoaXMuc2Npc3NvciA9IG5ldyBWZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcblxuXHR0aGlzLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHR0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZSggdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5LCBvcHRpb25zLmVuY29kaW5nICk7XG5cblx0dGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xuXHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XG5cdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhUZXh0dXJlIDogbnVsbDtcblxufVxuXG5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFdlYkdMUmVuZGVyVGFyZ2V0LFxuXG5cdGlzV2ViR0xSZW5kZXJUYXJnZXQ6IHRydWUsXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xuXG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXHRcdHRoaXMuc2Npc3Nvci5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXG5cdFx0dGhpcy52aWV3cG9ydC5jb3B5KCBzb3VyY2Uudmlld3BvcnQgKTtcblxuXHRcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XG5cblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuXHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xuXHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gc291cmNlLmRlcHRoVGV4dHVyZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59O1xuXG5PYmplY3QuYXNzaWduKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXG4gKi9cblxuZnVuY3Rpb24gV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG5cdFdlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHR0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDsgLy8gUFggMCwgTlggMSwgUFkgMiwgTlkgMywgUFogNCwgTlogNVxuXHR0aGlzLmFjdGl2ZU1pcE1hcExldmVsID0gMDtcblxufVxuXG5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XG5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xuXG5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gdHJ1ZTtcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICovXG5cbmZ1bmN0aW9uIFF1YXRlcm5pb24oIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufVxuXG5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbixcblxuXHRnZXQgeCAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9LFxuXG5cdHNldCB4ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeSAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9LFxuXG5cdHNldCB5ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9LFxuXG5cdHNldCB6ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgdyAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHR9LFxuXG5cdHNldCB3ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl93ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XG5cblx0XHRpZiAoIChldWxlciAmJiBldWxlci5pc0V1bGVyKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcblx0XHR2YXIgYzIgPSBNYXRoLmNvcyggZXVsZXIuX3kgLyAyICk7XG5cdFx0dmFyIGMzID0gTWF0aC5jb3MoIGV1bGVyLl96IC8gMiApO1xuXHRcdHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcblx0XHR2YXIgczIgPSBNYXRoLnNpbiggZXVsZXIuX3kgLyAyICk7XG5cdFx0dmFyIHMzID0gTWF0aC5zaW4oIGV1bGVyLl96IC8gMiApO1xuXG5cdFx0dmFyIG9yZGVyID0gZXVsZXIub3JkZXI7XG5cblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxuXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcblx0XHRcdHM7XG5cblx0XHRpZiAoIHRyYWNlID4gMCApIHtcblxuXHRcdFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcblxuXHRcdFx0dGhpcy5fdyA9IDAuMjUgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcblxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcblxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcblxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gMC4yNSAqIHM7XG5cblx0XHR9XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBodHRwOi8vbG9sZW5naW5lLm5ldC9ibG9nLzIwMTQvMDIvMjQvcXVhdGVybmlvbi1mcm9tLXR3by12ZWN0b3JzLWZpbmFsXG5cblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuXHRcdHZhciB2MSwgcjtcblxuXHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tVW5pdFZlY3RvcnMoIHZGcm9tLCB2VG8gKSB7XG5cblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0ciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xuXG5cdFx0XHRpZiAoIHIgPCBFUFMgKSB7XG5cblx0XHRcdFx0ciA9IDA7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcblxuXHRcdFx0XHRcdHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ggPSB2MS54O1xuXHRcdFx0dGhpcy5feSA9IHYxLnk7XG5cdFx0XHR0aGlzLl96ID0gdjEuejtcblx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG5cdH0sXG5cblx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuXHR9LFxuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuXHRcdH1cblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xuXG5cdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcblxuXHR9LFxuXG5cdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCB0aGlzICk7XG5cblx0fSxcblxuXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblxuXHRcdHZhciBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xuXG5cdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcblx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuXHRcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG5cdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG5cdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcblxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IC0gcWIuX3c7XG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xuXHRcdFx0dGhpcy5feiA9IC0gcWIuX3o7XG5cblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuXG5cdFx0XHR0aGlzLl93ID0gdztcblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcblxuXHRcdGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XG5cdFx0XHR0aGlzLl94ID0gMC41ICogKCB4ICsgdGhpcy5feCApO1xuXHRcdFx0dGhpcy5feSA9IDAuNSAqICggeSArIHRoaXMuX3kgKTtcblx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG5cdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcblx0XHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcblx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXHRcdHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cblxufTtcblxuT2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbiwge1xuXG5cdHNsZXJwOiBmdW5jdGlvbiggcWEsIHFiLCBxbSwgdCApIHtcblxuXHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdH0sXG5cblx0c2xlcnBGbGF0OiBmdW5jdGlvbihcblx0XHRcdGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xuXG5cdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG5cdFx0dmFyIHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcblx0XHRcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXSxcblxuXHRcdFx0eDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuXHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cblx0XHRcdHZhciBzID0gMSAtIHQsXG5cblx0XHRcdFx0Y29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcblxuXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xuXG5cdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHR2YXIgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xuXG5cdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdHZhciBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xuXG5cdFx0XHRcdHgwICo9IGY7XG5cdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdHcwICo9IGY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cbmZ1bmN0aW9uIFZlY3RvcjMoIHgsIHksIHogKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblxufVxuXG5WZWN0b3IzLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVmVjdG9yMyxcblxuXHRpc1ZlY3RvcjM6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0dGhpcy56ICs9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0dGhpcy56IC09IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcblxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHR0aGlzLnogPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUV1bGVyKCBldWxlciApIHtcblxuXHRcdFx0aWYgKCAoZXVsZXIgJiYgZXVsZXIuaXNFdWxlcikgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdO1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHogKyBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdO1xuXHRcdHZhciB3ID0gIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB3ICk7XG5cblx0fSxcblxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdHZhciBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cblx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuXHRcdHZhciBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0dmFyIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcblx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWF0cml4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWF0cml4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVucHJvamVjdCggY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkgKTtcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblx0XHR0aGlzLnogLz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtaW4gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRtYXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgLyBsZW5ndGggKTtcblxuXHR9LFxuXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXHRcdHRoaXMueiA9IC0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG5cblx0fSxcblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9LFxuXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fSxcblxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuXHRcdHRoaXMueCA9IHkgKiB2LnogLSB6ICogdi55O1xuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xuXHRcdHRoaXMueiA9IHggKiB2LnkgLSB5ICogdi54O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXHRcdHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHR2YXIgc2NhbGFyID0gdmVjdG9yLmRvdCggdGhpcyApIC8gdmVjdG9yLmxlbmd0aFNxKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ZWN0b3IgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XG5cblx0fSxcblxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyZWZsZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHR2YXIgdjE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKSApO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9NYW5oYXR0YW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fSxcblxuXHRzZXRGcm9tU3BoZXJpY2FsOiBmdW5jdGlvbiggcyApIHtcblxuXHRcdHZhciBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcy5waGkgKSAqIHMucmFkaXVzO1xuXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHMudGhldGEgKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcy5waGkgKSAqIHMucmFkaXVzO1xuXHRcdHRoaXMueiA9IHNpblBoaVJhZGl1cyAqIE1hdGguY29zKCBzLnRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21DeWxpbmRyaWNhbDogZnVuY3Rpb24oIGMgKSB7XG5cblx0XHR0aGlzLnggPSBjLnJhZGl1cyAqIE1hdGguc2luKCBjLnRoZXRhICk7XG5cdFx0dGhpcy55ID0gYy55O1xuXHRcdHRoaXMueiA9IGMucmFkaXVzICogTWF0aC5jb3MoIGMudGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAzICk7XG5cblx0fSxcblxuXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBzeCA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuXHRcdHZhciBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdHZhciBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggbSwgaW5kZXggKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBtID09PSAnbnVtYmVyJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogc2V0RnJvbU1hdHJpeENvbHVtbiBub3cgZXhwZWN0cyAoIG1hdHJpeCwgaW5kZXggKS4nICk7XG5cdFx0XHR2YXIgdGVtcCA9IG07XG5cdFx0XHRtID0gaW5kZXg7XG5cdFx0XHRpbmRleCA9IHRlbXA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxuICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5mdW5jdGlvbiBNYXRyaXg0KCkge1xuXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cblx0XHQxLCAwLCAwLCAwLFxuXHRcdDAsIDEsIDAsIDAsXG5cdFx0MCwgMCwgMSwgMCxcblx0XHQwLCAwLCAwLCAxXG5cblx0XSApO1xuXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0fVxuXG59XG5cbk1hdHJpeDQucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBNYXRyaXg0LFxuXG5cdGlzTWF0cml4NDogdHJ1ZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIG0uZWxlbWVudHMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZUJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdDAsICAgICAgIDAsICAgICAgIDAsICAgICAgIDFcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBleHRyYWN0Um90YXRpb24oIG0gKSB7XG5cblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHZhciBzY2FsZVggPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuXHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc2NhbGVaID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG5cdFx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcblx0XHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXG5cdFx0XHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcblx0XHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuXHRcdFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cblx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuXHRcdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG5cdFx0XHR0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdGlmICggKGV1bGVyICYmIGV1bGVyLmlzRXVsZXIpID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHR9XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0dmFyIGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xuXHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xuXHRcdFx0dGVbIDggXSA9IGEgKiBkO1xuXG5cdFx0XHR0ZVsgMSBdID0gYSAqIGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XG5cdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XG5cblx0XHRcdHRlWyAxIF0gPSBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGQgKiBlO1xuXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xuXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdH1cblxuXHRcdC8vIGxhc3QgY29sdW1uXG5cdFx0dGVbIDMgXSA9IDA7XG5cdFx0dGVbIDcgXSA9IDA7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0Ly8gYm90dG9tIHJvd1xuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcblx0XHR2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcblx0XHR2YXIgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6Mjtcblx0XHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6Mjtcblx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuXHRcdHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XG5cdFx0dGVbIDQgXSA9IHh5IC0gd3o7XG5cdFx0dGVbIDggXSA9IHh6ICsgd3k7XG5cblx0XHR0ZVsgMSBdID0geHkgKyB3ejtcblx0XHR0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xuXHRcdHRlWyA5IF0gPSB5eiAtIHd4O1xuXG5cdFx0dGVbIDIgXSA9IHh6IC0gd3k7XG5cdFx0dGVbIDYgXSA9IHl6ICsgd3g7XG5cdFx0dGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XG5cblx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdHRlWyAzIF0gPSAwO1xuXHRcdHRlWyA3IF0gPSAwO1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdC8vIGJvdHRvbSByb3dcblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHgsIHksIHo7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XG5cblx0XHRcdGlmICggeCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR5ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0eiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRpZiAoIHoubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0XHR6LnogPSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRpZiAoIHgubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0XHR6LnogKz0gMC4wMDAxO1xuXHRcdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR5LmNyb3NzVmVjdG9ycyggeiwgeCApO1xuXG5cblx0XHRcdHRlWyAwIF0gPSB4Lng7IHRlWyA0IF0gPSB5Lng7IHRlWyA4IF0gPSB6Lng7XG5cdFx0XHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xuXHRcdFx0dGVbIDIgXSA9IHguejsgdGVbIDYgXSA9IHkuejsgdGVbIDEwIF0gPSB6Lno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcblxuXHRcdGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cblx0fSxcblxuXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGFlID0gYS5lbGVtZW50cztcblx0XHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG5cdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICk7XG5cblx0XHRyWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xuXHRcdHJbIDQgXSA9IHRlWyA0IF07IHJbIDUgXSA9IHRlWyA1IF07IHJbIDYgXSA9IHRlWyA2IF07IHJbIDcgXSA9IHRlWyA3IF07XG5cdFx0clsgOCBdICA9IHRlWyA4IF07IHJbIDkgXSAgPSB0ZVsgOSBdOyByWyAxMCBdID0gdGVbIDEwIF07IHJbIDExIF0gPSB0ZVsgMTEgXTtcblx0XHRyWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseVRvQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHRcdHYxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xuXHRcdFx0XHR2MS56ID0gYXR0cmlidXRlLmdldFooIGkgKTtcblxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuc2V0WFlaKCBpLCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xuXHRcdHZhciBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcblx0XHR2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuXHRcdHZhciBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XG5cblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdG40MSAqIChcblx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxuXHRcdFx0KSArXG5cdFx0XHRuNDIgKiAoXG5cdFx0XHRcdCsgbjExICogbjIzICogbjM0XG5cdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcblx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQzICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40NCAqIChcblx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXG5cdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxuXHRcdFx0KVxuXG5cdFx0KTtcblxuXHR9LFxuXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgdG1wO1xuXG5cdFx0dG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDIgXTsgdGVbIDIgXSA9IHRlWyA4IF07IHRlWyA4IF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XG5cblx0XHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA3IF07IHRlWyA3IF0gPSB0ZVsgMTMgXTsgdGVbIDEzIF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAxMiBdID0gdi54O1xuXHRcdHRlWyAxMyBdID0gdi55O1xuXHRcdHRlWyAxNCBdID0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG0sIHRocm93T25EZWdlbmVyYXRlICkge1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdG1lID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bjExID0gbWVbIDAgXSwgbjIxID0gbWVbIDEgXSwgbjMxID0gbWVbIDIgXSwgbjQxID0gbWVbIDMgXSxcblx0XHRcdG4xMiA9IG1lWyA0IF0sIG4yMiA9IG1lWyA1IF0sIG4zMiA9IG1lWyA2IF0sIG40MiA9IG1lWyA3IF0sXG5cdFx0XHRuMTMgPSBtZVsgOCBdLCBuMjMgPSBtZVsgOSBdLCBuMzMgPSBtZVsgMTAgXSwgbjQzID0gbWVbIDExIF0sXG5cdFx0XHRuMTQgPSBtZVsgMTIgXSwgbjI0ID0gbWVbIDEzIF0sIG4zNCA9IG1lWyAxNCBdLCBuNDQgPSBtZVsgMTUgXSxcblxuXHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxuXHRcdFx0dDEyID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0LFxuXHRcdFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxuXHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXG5cdFx0dmFyIGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcblxuXHRcdGlmICggZGV0ID09PSAwICkge1xuXG5cdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG5cdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDQgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA4IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDkgXSA9ICggbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMSBdID0gKCBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xuXHRcdHRlWyAxMyBdID0gKCBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xuXG5cdH0sXG5cblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHQwLCAwLCAxLCB6LFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAgMCwgMCxcblx0XHRcdDAsIGMsIC0gcywgMCxcblx0XHRcdDAsIHMsICBjLCAwLFxuXHRcdFx0MCwgMCwgIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0IGMsIDAsIHMsIDAsXG5cdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdHMsICBjLCAwLCAwLFxuXHRcdFx0MCwgIDAsIDEsIDAsXG5cdFx0XHQwLCAgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdHZhciB0ID0gMSAtIGM7XG5cdFx0dmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XG5cdFx0dmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdCByZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0MCwgMCwgeiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VTaGVhcjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHksIHosIDAsXG5cdFx0XHR4LCAxLCB6LCAwLFxuXHRcdFx0eCwgeSwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0dGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXHRcdHRoaXMuc2NhbGUoIHNjYWxlICk7XG5cdFx0dGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVjdG9yLCBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRcdGlmICggZGV0IDwgMCApIHtcblxuXHRcdFx0XHRzeCA9IC0gc3g7XG5cblx0XHRcdH1cblxuXHRcdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuXHRcdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG5cdFx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXG5cdFx0XHRtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcblxuXHRcdFx0dmFyIGludlNYID0gMSAvIHN4O1xuXHRcdFx0dmFyIGludlNZID0gMSAvIHN5O1xuXHRcdFx0dmFyIGludlNaID0gMSAvIHN6O1xuXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRzY2FsZS54ID0gc3g7XG5cdFx0XHRzY2FsZS55ID0gc3k7XG5cdFx0XHRzY2FsZS56ID0gc3o7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0aWYgKCBmYXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm1ha2VQZXJzcGVjdGl2ZSgpIGhhcyBiZWVuIHJlZGVmaW5lZCBhbmQgaGFzIGEgbmV3IHNpZ25hdHVyZS4gUGxlYXNlIGNoZWNrIHRoZSBkb2NzLicgKTtcblxuXHRcdH1cblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHR2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cdFx0dmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgdyA9IDEuMCAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0dmFyIGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xuXHRcdHZhciBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgKiB3O1xuXHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAqIGg7XG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAqIHA7XG5cblx0XHR0ZVsgMCBdID0gMiAqIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAqIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IC0gMiAqIHA7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDkgXSAgPSB0ZVsgOSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQ3ViZVRleHR1cmUoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcblxuXHRpbWFnZXMgPSBpbWFnZXMgIT09IHVuZGVmaW5lZCA/IGltYWdlcyA6IFtdO1xuXHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcblxuXHRUZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xuXG5cdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxufVxuXG5DdWJlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZVRleHR1cmU7XG5cbkN1YmVUZXh0dXJlLnByb3RvdHlwZS5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KCBDdWJlVGV4dHVyZS5wcm90b3R5cGUsICdpbWFnZXMnLCB7XG5cblx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbWFnZTtcblxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuaW1hZ2UgPSB2YWx1ZTtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIHRzY2h3XG4gKlxuICogVW5pZm9ybXMgb2YgYSBwcm9ncmFtLlxuICogVGhvc2UgZm9ybSBhIHRyZWUgc3RydWN0dXJlIHdpdGggYSBzcGVjaWFsIHRvcC1sZXZlbCBjb250YWluZXIgZm9yIHRoZSByb290LFxuICogd2hpY2ggeW91IGdldCBieSBjYWxsaW5nICduZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICknLlxuICpcbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcbiAqXG4gKiAuc2VxIC0gYXJyYXkgb2YgbmVzdGVkIHVuaWZvcm1zXG4gKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcbiAqXG4gKlxuICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIHZhbHVlLCBbcmVuZGVyZXJdIClcbiAqXG4gKiBcdFx0dXBsb2FkcyBhIHVuaWZvcm0gdmFsdWUocylcbiAqICBcdHRoZSAncmVuZGVyZXInIHBhcmFtZXRlciBpcyBuZWVkZWQgZm9yIHNhbXBsZXIgdW5pZm9ybXNcbiAqXG4gKlxuICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHJlbmRlcmVyIGZhY3Rvcml6YXRpb25zKTpcbiAqXG4gKiAudXBsb2FkKCBnbCwgc2VxLCB2YWx1ZXMsIHJlbmRlcmVyIClcbiAqXG4gKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcbiAqXG4gKiAuc2VxV2l0aFZhbHVlKCBzZXEsIHZhbHVlcyApIDogZmlsdGVyZWRTZXFcbiAqXG4gKiBcdFx0ZmlsdGVycyAnc2VxJyBlbnRyaWVzIHdpdGggY29ycmVzcG9uZGluZyBlbnRyeSBpbiB2YWx1ZXNcbiAqXG4gKlxuICogTWV0aG9kcyBvZiB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciAocmVuZGVyZXIgZmFjdG9yaXphdGlvbnMpOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlIClcbiAqXG4gKiBcdFx0c2V0cyB1bmlmb3JtIHdpdGggIG5hbWUgJ25hbWUnIHRvICd2YWx1ZSdcbiAqXG4gKiAuc2V0KCBnbCwgb2JqLCBwcm9wIClcbiAqXG4gKiBcdFx0c2V0cyB1bmlmb3JtIGZyb20gb2JqZWN0IGFuZCBwcm9wZXJ0eSB3aXRoIHNhbWUgbmFtZSB0aGFuIHVuaWZvcm1cbiAqXG4gKiAuc2V0T3B0aW9uYWwoIGdsLCBvYmosIHByb3AgKVxuICpcbiAqIFx0XHRsaWtlIC5zZXQgZm9yIGFuIG9wdGlvbmFsIHByb3BlcnR5IG9mIHRoZSBvYmplY3RcbiAqXG4gKi9cblxudmFyIGVtcHR5VGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG52YXIgZW1wdHlDdWJlVGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpO1xuXG4vLyAtLS0gQmFzZSBmb3IgaW5uZXIgbm9kZXMgKGluY2x1ZGluZyB0aGUgcm9vdCkgLS0tXG5cbmZ1bmN0aW9uIFVuaWZvcm1Db250YWluZXIoKSB7XG5cblx0dGhpcy5zZXEgPSBbXTtcblx0dGhpcy5tYXAgPSB7fTtcblxufVxuXG4vLyAtLS0gVXRpbGl0aWVzIC0tLVxuXG4vLyBBcnJheSBDYWNoZXMgKHByb3ZpZGUgdHlwZWQgYXJyYXlzIGZvciB0ZW1wb3JhcnkgYnkgc2l6ZSlcblxudmFyIGFycmF5Q2FjaGVGMzIgPSBbXTtcbnZhciBhcnJheUNhY2hlSTMyID0gW107XG5cbi8vIEZsYXR0ZW5pbmcgZm9yIGFycmF5cyBvZiB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuXG5mdW5jdGlvbiBmbGF0dGVuKCBhcnJheSwgbkJsb2NrcywgYmxvY2tTaXplICkge1xuXG5cdHZhciBmaXJzdEVsZW0gPSBhcnJheVsgMCBdO1xuXG5cdGlmICggZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCApIHJldHVybiBhcnJheTtcblx0Ly8gdW5vcHRpbWl6ZWQ6ICEgaXNOYU4oIGZpcnN0RWxlbSApXG5cdC8vIHNlZSBodHRwOi8vamFja3NvbmR1bnN0YW4uY29tL2FydGljbGVzLzk4M1xuXG5cdHZhciBuID0gbkJsb2NrcyAqIGJsb2NrU2l6ZSxcblx0XHRyID0gYXJyYXlDYWNoZUYzMlsgbiBdO1xuXG5cdGlmICggciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0ciA9IG5ldyBGbG9hdDMyQXJyYXkoIG4gKTtcblx0XHRhcnJheUNhY2hlRjMyWyBuIF0gPSByO1xuXG5cdH1cblxuXHRpZiAoIG5CbG9ja3MgIT09IDAgKSB7XG5cblx0XHRmaXJzdEVsZW0udG9BcnJheSggciwgMCApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAxLCBvZmZzZXQgPSAwOyBpICE9PSBuQmxvY2tzOyArKyBpICkge1xuXG5cdFx0XHRvZmZzZXQgKz0gYmxvY2tTaXplO1xuXHRcdFx0YXJyYXlbIGkgXS50b0FycmF5KCByLCBvZmZzZXQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHI7XG5cbn1cblxuLy8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cblxuZnVuY3Rpb24gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKSB7XG5cblx0dmFyIHIgPSBhcnJheUNhY2hlSTMyWyBuIF07XG5cblx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRyID0gbmV3IEludDMyQXJyYXkoIG4gKTtcblx0XHRhcnJheUNhY2hlSTMyWyBuIF0gPSByO1xuXG5cdH1cblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxuXHRcdHJbIGkgXSA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcblxuXHRyZXR1cm4gcjtcblxufVxuXG4vLyAtLS0gU2V0dGVycyAtLS1cblxuLy8gTm90ZTogRGVmaW5pbmcgdGhlc2UgbWV0aG9kcyBleHRlcm5hbGx5LCBiZWNhdXNlIHRoZXkgY29tZSBpbiBhIGJ1bmNoXG4vLyBhbmQgdGhpcyB3YXkgdGhlaXIgbmFtZXMgbWluaWZ5LlxuXG4vLyBTaW5nbGUgc2NhbGFyXG5cbmZ1bmN0aW9uIHNldFZhbHVlMWYoIGdsLCB2ICkgeyBnbC51bmlmb3JtMWYoIHRoaXMuYWRkciwgdiApOyB9XG5mdW5jdGlvbiBzZXRWYWx1ZTFpKCBnbCwgdiApIHsgZ2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHYgKTsgfVxuXG4vLyBTaW5nbGUgZmxvYXQgdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuVmVjdG9yTilcblxuZnVuY3Rpb24gc2V0VmFsdWUyZnYoIGdsLCB2ICkge1xuXG5cdGlmICggdi54ID09PSB1bmRlZmluZWQgKSBnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIHYgKTtcblx0ZWxzZSBnbC51bmlmb3JtMmYoIHRoaXMuYWRkciwgdi54LCB2LnkgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZTNmdiggZ2wsIHYgKSB7XG5cblx0aWYgKCB2LnggIT09IHVuZGVmaW5lZCApXG5cdFx0Z2wudW5pZm9ybTNmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnogKTtcblx0ZWxzZSBpZiAoIHYuciAhPT0gdW5kZWZpbmVkIClcblx0XHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi5yLCB2LmcsIHYuYiApO1xuXHRlbHNlXG5cdFx0Z2wudW5pZm9ybTNmdiggdGhpcy5hZGRyLCB2ICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWU0ZnYoIGdsLCB2ICkge1xuXG5cdGlmICggdi54ID09PSB1bmRlZmluZWQgKSBnbC51bmlmb3JtNGZ2KCB0aGlzLmFkZHIsIHYgKTtcblx0ZWxzZSBnbC51bmlmb3JtNGYoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53ICk7XG5cbn1cblxuLy8gU2luZ2xlIG1hdHJpeCAoZnJvbSBmbGF0IGFycmF5IG9yIE1hdHJpeE4pXG5cbmZ1bmN0aW9uIHNldFZhbHVlMmZtKCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCB2LmVsZW1lbnRzIHx8IHYgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZTNmbSggZ2wsIHYgKSB7XG5cblx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgdi5lbGVtZW50cyB8fCB2ICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWU0Zm0oIGdsLCB2ICkge1xuXG5cdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYuZWxlbWVudHMgfHwgdiApO1xuXG59XG5cbi8vIFNpbmdsZSB0ZXh0dXJlICgyRCAvIEN1YmUpXG5cbmZ1bmN0aW9uIHNldFZhbHVlVDEoIGdsLCB2LCByZW5kZXJlciApIHtcblxuXHR2YXIgdW5pdCA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcblx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcblx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB2IHx8IGVtcHR5VGV4dHVyZSwgdW5pdCApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVDYoIGdsLCB2LCByZW5kZXJlciApIHtcblxuXHR2YXIgdW5pdCA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcblx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcblx0cmVuZGVyZXIuc2V0VGV4dHVyZUN1YmUoIHYgfHwgZW1wdHlDdWJlVGV4dHVyZSwgdW5pdCApO1xuXG59XG5cbi8vIEludGVnZXIgLyBCb29sZWFuIHZlY3RvcnMgb3IgYXJyYXlzIHRoZXJlb2YgKGFsd2F5cyBmbGF0IGFycmF5cylcblxuZnVuY3Rpb24gc2V0VmFsdWUyaXYoIGdsLCB2ICkgeyBnbC51bmlmb3JtMml2KCB0aGlzLmFkZHIsIHYgKTsgfVxuZnVuY3Rpb24gc2V0VmFsdWUzaXYoIGdsLCB2ICkgeyBnbC51bmlmb3JtM2l2KCB0aGlzLmFkZHIsIHYgKTsgfVxuZnVuY3Rpb24gc2V0VmFsdWU0aXYoIGdsLCB2ICkgeyBnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTsgfVxuXG4vLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciB0aGUgc2luZ3VsYXIgY2FzZVxuXG5mdW5jdGlvbiBnZXRTaW5ndWxhclNldHRlciggdHlwZSApIHtcblxuXHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0Y2FzZSAweDE0MDY6IHJldHVybiBzZXRWYWx1ZTFmOyAvLyBGTE9BVFxuXHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWUyZnY7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTE6IHJldHVybiBzZXRWYWx1ZTNmdjsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlNGZ2OyAvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZTJmbTsgLy8gX01BVDJcblx0XHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlM2ZtOyAvLyBfTUFUM1xuXHRcdGNhc2UgMHg4YjVjOiByZXR1cm4gc2V0VmFsdWU0Zm07IC8vIF9NQVQ0XG5cblx0XHRjYXNlIDB4OGI1ZTogcmV0dXJuIHNldFZhbHVlVDE7IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2MDogcmV0dXJuIHNldFZhbHVlVDY7IC8vIFNBTVBMRVJfQ1VCRVxuXG5cdFx0Y2FzZSAweDE0MDQ6IGNhc2UgMHg4YjU2OiByZXR1cm4gc2V0VmFsdWUxaTsgLy8gSU5ULCBCT09MXG5cdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWUzaXY7IC8vIF9WRUMzXG5cdFx0Y2FzZSAweDhiNTU6IGNhc2UgMHg4YjU5OiByZXR1cm4gc2V0VmFsdWU0aXY7IC8vIF9WRUM0XG5cblx0fVxuXG59XG5cbi8vIEFycmF5IG9mIHNjYWxhcnNcblxuZnVuY3Rpb24gc2V0VmFsdWUxZnYoIGdsLCB2ICkgeyBnbC51bmlmb3JtMWZ2KCB0aGlzLmFkZHIsIHYgKTsgfVxuZnVuY3Rpb24gc2V0VmFsdWUxaXYoIGdsLCB2ICkgeyBnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHYgKTsgfVxuXG4vLyBBcnJheSBvZiB2ZWN0b3JzIChmbGF0IG9yIGZyb20gVEhSRUUgY2xhc3NlcylcblxuZnVuY3Rpb24gc2V0VmFsdWVWMmEoIGdsLCB2ICkge1xuXG5cdGdsLnVuaWZvcm0yZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAyICkgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzYSggZ2wsIHYgKSB7XG5cblx0Z2wudW5pZm9ybTNmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDMgKSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVjRhKCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtNGZ2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgNCApICk7XG5cbn1cblxuLy8gQXJyYXkgb2YgbWF0cmljZXMgKGZsYXQgb3IgZnJvbSBUSFJFRSBjbGFzZXMpXG5cbmZ1bmN0aW9uIHNldFZhbHVlTTJhKCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTNhKCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDkgKSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTRhKCBnbCwgdiApIHtcblxuXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDE2ICkgKTtcblxufVxuXG4vLyBBcnJheSBvZiB0ZXh0dXJlcyAoMkQgLyBDdWJlKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQxYSggZ2wsIHYsIHJlbmRlcmVyICkge1xuXG5cdHZhciBuID0gdi5sZW5ndGgsXG5cdFx0dW5pdHMgPSBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApO1xuXG5cdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHZbIGkgXSB8fCBlbXB0eVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVUNmEoIGdsLCB2LCByZW5kZXJlciApIHtcblxuXHR2YXIgbiA9IHYubGVuZ3RoLFxuXHRcdHVuaXRzID0gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKTtcblxuXHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0cmVuZGVyZXIuc2V0VGV4dHVyZUN1YmUoIHZbIGkgXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1sgaSBdICk7XG5cblx0fVxuXG59XG5cbi8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIGEgcHVyZSAoYm90dG9tLWxldmVsKSBhcnJheVxuXG5mdW5jdGlvbiBnZXRQdXJlQXJyYXlTZXR0ZXIoIHR5cGUgKSB7XG5cblx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdGNhc2UgMHgxNDA2OiByZXR1cm4gc2V0VmFsdWUxZnY7IC8vIEZMT0FUXG5cdFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZVYyYTsgLy8gX1ZFQzJcblx0XHRjYXNlIDB4OGI1MTogcmV0dXJuIHNldFZhbHVlVjNhOyAvLyBfVkVDM1xuXHRcdGNhc2UgMHg4YjUyOiByZXR1cm4gc2V0VmFsdWVWNGE7IC8vIF9WRUM0XG5cblx0XHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlTTJhOyAvLyBfTUFUMlxuXHRcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWVNM2E7IC8vIF9NQVQzXG5cdFx0Y2FzZSAweDhiNWM6IHJldHVybiBzZXRWYWx1ZU00YTsgLy8gX01BVDRcblxuXHRcdGNhc2UgMHg4YjVlOiByZXR1cm4gc2V0VmFsdWVUMWE7IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2MDogcmV0dXJuIHNldFZhbHVlVDZhOyAvLyBTQU1QTEVSX0NVQkVcblxuXHRcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlMWl2OyAvLyBJTlQsIEJPT0xcblx0XHRjYXNlIDB4OGI1MzogY2FzZSAweDhiNTc6IHJldHVybiBzZXRWYWx1ZTJpdjsgLy8gX1ZFQzJcblx0XHRjYXNlIDB4OGI1NDogY2FzZSAweDhiNTg6IHJldHVybiBzZXRWYWx1ZTNpdjsgLy8gX1ZFQzNcblx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZTRpdjsgLy8gX1ZFQzRcblxuXHR9XG5cbn1cblxuLy8gLS0tIFVuaWZvcm0gQ2xhc3NlcyAtLS1cblxuZnVuY3Rpb24gU2luZ2xlVW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XG5cblx0dGhpcy5pZCA9IGlkO1xuXHR0aGlzLmFkZHIgPSBhZGRyO1xuXHR0aGlzLnNldFZhbHVlID0gZ2V0U2luZ3VsYXJTZXR0ZXIoIGFjdGl2ZUluZm8udHlwZSApO1xuXG5cdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblxufVxuXG5mdW5jdGlvbiBQdXJlQXJyYXlVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIHtcblxuXHR0aGlzLmlkID0gaWQ7XG5cdHRoaXMuYWRkciA9IGFkZHI7XG5cdHRoaXMuc2l6ZSA9IGFjdGl2ZUluZm8uc2l6ZTtcblx0dGhpcy5zZXRWYWx1ZSA9IGdldFB1cmVBcnJheVNldHRlciggYWN0aXZlSW5mby50eXBlICk7XG5cblx0Ly8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xuXG59XG5cbmZ1bmN0aW9uIFN0cnVjdHVyZWRVbmlmb3JtKCBpZCApIHtcblxuXHR0aGlzLmlkID0gaWQ7XG5cblx0VW5pZm9ybUNvbnRhaW5lci5jYWxsKCB0aGlzICk7IC8vIG1peC1pblxuXG59XG5cblN0cnVjdHVyZWRVbmlmb3JtLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKCBnbCwgdmFsdWUgKSB7XG5cblx0Ly8gTm90ZTogRG9uJ3QgbmVlZCBhbiBleHRyYSAncmVuZGVyZXInIHBhcmFtZXRlciwgc2luY2Ugc2FtcGxlcnNcblx0Ly8gYXJlIG5vdCBhbGxvd2VkIGluIHN0cnVjdHVyZWQgdW5pZm9ybXMuXG5cblx0dmFyIHNlcSA9IHRoaXMuc2VxO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHR2YXIgdSA9IHNlcVsgaSBdO1xuXHRcdHUuc2V0VmFsdWUoIGdsLCB2YWx1ZVsgdS5pZCBdICk7XG5cblx0fVxuXG59O1xuXG4vLyAtLS0gVG9wLWxldmVsIC0tLVxuXG4vLyBQYXJzZXIgLSBidWlsZHMgdXAgdGhlIHByb3BlcnR5IHRyZWUgZnJvbSB0aGUgcGF0aCBzdHJpbmdzXG5cbnZhciBSZVBhdGhQYXJ0ID0gLyhbXFx3XFxkX10rKShcXF0pPyhcXFt8XFwuKT8vZztcblxuLy8gZXh0cmFjdHNcbi8vIFx0LSB0aGUgaWRlbnRpZmllciAobWVtYmVyIG5hbWUgb3IgYXJyYXkgaW5kZXgpXG4vLyAgLSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCByaWdodCBicmFja2V0IChmb3VuZCB3aGVuIGFycmF5IGluZGV4KVxuLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXG4vL1xuLy8gTm90ZTogVGhlc2UgcG9ydGlvbnMgY2FuIGJlIHJlYWQgaW4gYSBub24tb3ZlcmxhcHBpbmcgZmFzaGlvbiBhbmRcbi8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXG4vLyBpbiB0aGUgdW5pZm9ybSBuYW1lcy5cblxuZnVuY3Rpb24gYWRkVW5pZm9ybSggY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0ICkge1xuXG5cdGNvbnRhaW5lci5zZXEucHVzaCggdW5pZm9ybU9iamVjdCApO1xuXHRjb250YWluZXIubWFwWyB1bmlmb3JtT2JqZWN0LmlkIF0gPSB1bmlmb3JtT2JqZWN0O1xuXG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5pZm9ybSggYWN0aXZlSW5mbywgYWRkciwgY29udGFpbmVyICkge1xuXG5cdHZhciBwYXRoID0gYWN0aXZlSW5mby5uYW1lLFxuXHRcdHBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuXHQvLyByZXNldCBSZWdFeHAgb2JqZWN0LCBiZWNhdXNlIG9mIHRoZSBlYXJseSBleGl0IG9mIGEgcHJldmlvdXMgcnVuXG5cdFJlUGF0aFBhcnQubGFzdEluZGV4ID0gMDtcblxuXHRmb3IgKDsgOykge1xuXG5cdFx0dmFyIG1hdGNoID0gUmVQYXRoUGFydC5leGVjKCBwYXRoICksXG5cdFx0XHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4LFxuXG5cdFx0XHRpZCA9IG1hdGNoWyAxIF0sXG5cdFx0XHRpZElzSW5kZXggPSBtYXRjaFsgMiBdID09PSAnXScsXG5cdFx0XHRzdWJzY3JpcHQgPSBtYXRjaFsgMyBdO1xuXG5cdFx0aWYgKCBpZElzSW5kZXggKSBpZCA9IGlkIHwgMDsgLy8gY29udmVydCB0byBpbnRlZ2VyXG5cblx0XHRpZiAoIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdHN1YnNjcmlwdCA9PT0gJ1snICYmIG1hdGNoRW5kICsgMiA9PT0gcGF0aExlbmd0aCApIHtcblx0XHRcdC8vIGJhcmUgbmFtZSBvciBcInB1cmVcIiBib3R0b20tbGV2ZWwgYXJyYXkgXCJbMF1cIiBzdWZmaXhcblxuXHRcdFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0bmV3IFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgOlxuXHRcdFx0XHRcdG5ldyBQdXJlQXJyYXlVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApICk7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHN0ZXAgaW50byBpbm5lciBub2RlIC8gY3JlYXRlIGl0IGluIGNhc2UgaXQgZG9lc24ndCBleGlzdFxuXG5cdFx0XHR2YXIgbWFwID0gY29udGFpbmVyLm1hcCxcblx0XHRcdFx0bmV4dCA9IG1hcFsgaWQgXTtcblxuXHRcdFx0aWYgKCBuZXh0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bmV4dCA9IG5ldyBTdHJ1Y3R1cmVkVW5pZm9ybSggaWQgKTtcblx0XHRcdFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBuZXh0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29udGFpbmVyID0gbmV4dDtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gUm9vdCBDb250YWluZXJcblxuZnVuY3Rpb24gV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICkge1xuXG5cdFVuaWZvcm1Db250YWluZXIuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuXHR2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyApO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IG47ICsrIGkgKSB7XG5cblx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKSxcblx0XHRcdHBhdGggPSBpbmZvLm5hbWUsXG5cdFx0XHRhZGRyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBwYXRoICk7XG5cblx0XHRwYXJzZVVuaWZvcm0oIGluZm8sIGFkZHIsIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuV2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiggZ2wsIG5hbWUsIHZhbHVlICkge1xuXG5cdHZhciB1ID0gdGhpcy5tYXBbIG5hbWUgXTtcblxuXHRpZiAoIHUgIT09IHVuZGVmaW5lZCApIHUuc2V0VmFsdWUoIGdsLCB2YWx1ZSwgdGhpcy5yZW5kZXJlciApO1xuXG59O1xuXG5XZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiggZ2wsIG9iamVjdCwgbmFtZSApIHtcblxuXHR2YXIgdSA9IHRoaXMubWFwWyBuYW1lIF07XG5cblx0aWYgKCB1ICE9PSB1bmRlZmluZWQgKSB1LnNldFZhbHVlKCBnbCwgb2JqZWN0WyBuYW1lIF0sIHRoaXMucmVuZGVyZXIgKTtcblxufTtcblxuV2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0T3B0aW9uYWwgPSBmdW5jdGlvbiggZ2wsIG9iamVjdCwgbmFtZSApIHtcblxuXHR2YXIgdiA9IG9iamVjdFsgbmFtZSBdO1xuXG5cdGlmICggdiAhPT0gdW5kZWZpbmVkICkgdGhpcy5zZXRWYWx1ZSggZ2wsIG5hbWUsIHYgKTtcblxufTtcblxuXG4vLyBTdGF0aWMgaW50ZXJmYWNlXG5cbldlYkdMVW5pZm9ybXMudXBsb2FkID0gZnVuY3Rpb24oIGdsLCBzZXEsIHZhbHVlcywgcmVuZGVyZXIgKSB7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHZhciB1ID0gc2VxWyBpIF0sXG5cdFx0XHR2ID0gdmFsdWVzWyB1LmlkIF07XG5cblx0XHRpZiAoIHYubmVlZHNVcGRhdGUgIT09IGZhbHNlICkge1xuXHRcdFx0Ly8gbm90ZTogYWx3YXlzIHVwZGF0aW5nIHdoZW4gLm5lZWRzVXBkYXRlIGlzIHVuZGVmaW5lZFxuXG5cdFx0XHR1LnNldFZhbHVlKCBnbCwgdi52YWx1ZSwgcmVuZGVyZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbldlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlID0gZnVuY3Rpb24oIHNlcSwgdmFsdWVzICkge1xuXG5cdHZhciByID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdHZhciB1ID0gc2VxWyBpIF07XG5cdFx0aWYgKCB1LmlkIGluIHZhbHVlcyApIHIucHVzaCggdSApO1xuXG5cdH1cblxuXHRyZXR1cm4gcjtcblxufTtcblxuLyoqXG4gKiBVbmlmb3JtIFV0aWxpdGllc1xuICovXG5cbnZhciBVbmlmb3Jtc1V0aWxzID0ge1xuXG5cdG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xuXG5cdFx0dmFyIG1lcmdlZCA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xuXG5cdFx0XHR2YXIgdG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XG5cblx0XHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lcmdlZDtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcblxuXHRcdHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcblxuXHRcdGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcblxuXHRcdFx0dW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XG5cblx0XHRcdFx0dmFyIHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyX3NyYyAmJiAoIHBhcmFtZXRlcl9zcmMuaXNDb2xvciB8fFxuXHRcdFx0XHRcdHBhcmFtZXRlcl9zcmMuaXNNYXRyaXgzIHx8IHBhcmFtZXRlcl9zcmMuaXNNYXRyaXg0IHx8XG5cdFx0XHRcdFx0cGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjIgfHwgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjMgfHwgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjQgfHxcblx0XHRcdFx0XHRwYXJhbWV0ZXJfc3JjLmlzVGV4dHVyZSApICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmlmb3Jtc19kc3Q7XG5cblx0fVxuXG59O1xuXG52YXIgYWxwaGFtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgYWxwaGFtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgYWxwaGF0ZXN0X2ZyYWdtZW50ID0gXCIjaWZkZWYgQUxQSEFURVNUXFxuXFx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBhb21hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gYW1iaWVudE9jY2x1c2lvbjtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgYW9tYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG5cbnZhciBiZWdpbl92ZXJ0ZXggPSBcIlxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcblwiO1xuXG52YXIgYmVnaW5ub3JtYWxfdmVydGV4ID0gXCJcXG52ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApO1xcblwiO1xuXG52YXIgYnNkZnMgPSBcImZsb2F0IHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcdFxcdGlmKCBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcbiNpZiBkZWZpbmVkICggUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUUyApXFxuXFx0XFx0XFx0ZmxvYXQgZGlzdGFuY2VGYWxsb2ZmID0gMS4wIC8gbWF4KCBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSwgMC4wMSApO1xcblxcdFxcdFxcdGZsb2F0IG1heERpc3RhbmNlQ3V0b2ZmRmFjdG9yID0gcG93Miggc2F0dXJhdGUoIDEuMCAtIHBvdzQoIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSApICkgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZGlzdGFuY2VGYWxsb2ZmICogbWF4RGlzdGFuY2VDdXRvZmZGYWN0b3I7XFxuI2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuI2VuZGlmXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAxLjA7XFxufVxcbnZlYzMgQlJERl9EaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yO1xcbn1cXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBkb3RMSCApIHtcXG5cXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQ3MyAqIGRvdExIIC0gNi45ODMxNiApICogZG90TEggKTtcXG5cXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXG59XFxuZmxvYXQgR19HR1hfU21pdGgoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGdsID0gZG90TkwgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXG5cXHRmbG9hdCBndiA9IGRvdE5WICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxuXFx0cmV0dXJuIDEuMCAvICggZ2wgKiBndiApO1xcbn1cXG5mbG9hdCBHX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXG5cXHRmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxuXFx0cmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1xcbn1cXG5mbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBkZW5vbSA9IHBvdzIoIGRvdE5IICkgKiAoIGEyIC0gMS4wICkgKyAxLjA7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAvIHBvdzIoIGRlbm9tICk7XFxufVxcbnZlYzMgQlJERl9TcGVjdWxhcl9HR1goIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFx0ZmxvYXQgRyA9IEdfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xcblxcdGZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7XFxuXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufVxcbnZlYzIgbHRjVGV4dHVyZUNvb3JkcyggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGNvbnN0IGZsb2F0IExVVF9TSVpFICA9IDY0LjA7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKExVVF9TSVpFIC0gMS4wKS9MVVRfU0laRTtcXG5cXHRjb25zdCBmbG9hdCBMVVRfQklBUyAgPSAwLjUvTFVUX1NJWkU7XFxuXFx0dmVjMyBOID0gZ2VvbWV0cnkubm9ybWFsO1xcblxcdHZlYzMgViA9IGdlb21ldHJ5LnZpZXdEaXI7XFxuXFx0dmVjMyBQID0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0ZmxvYXQgdGhldGEgPSBhY29zKCBkb3QoIE4sIFYgKSApO1xcblxcdHZlYzIgdXYgPSB2ZWMyKFxcblxcdFxcdHNxcnQoIHNhdHVyYXRlKCByb3VnaG5lc3MgKSApLFxcblxcdFxcdHNhdHVyYXRlKCB0aGV0YSAvICggMC41ICogUEkgKSApICk7XFxuXFx0dXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTO1xcblxcdHJldHVybiB1djtcXG59XFxudm9pZCBjbGlwUXVhZFRvSG9yaXpvbiggaW5vdXQgdmVjMyBMWzVdLCBvdXQgaW50IG4gKSB7XFxuXFx0aW50IGNvbmZpZyA9IDA7XFxuXFx0aWYgKCBMWzBdLnogPiAwLjAgKSBjb25maWcgKz0gMTtcXG5cXHRpZiAoIExbMV0ueiA+IDAuMCApIGNvbmZpZyArPSAyO1xcblxcdGlmICggTFsyXS56ID4gMC4wICkgY29uZmlnICs9IDQ7XFxuXFx0aWYgKCBMWzNdLnogPiAwLjAgKSBjb25maWcgKz0gODtcXG5cXHRuID0gMDtcXG5cXHRpZiAoIGNvbmZpZyA9PSAwICkge1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSAxICkge1xcblxcdFxcdG4gPSAzO1xcblxcdFxcdExbMV0gPSAtTFsxXS56ICogTFswXSArIExbMF0ueiAqIExbMV07XFxuXFx0XFx0TFsyXSA9IC1MWzNdLnogKiBMWzBdICsgTFswXS56ICogTFszXTtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gMiApIHtcXG5cXHRcXHRuID0gMztcXG5cXHRcXHRMWzBdID0gLUxbMF0ueiAqIExbMV0gKyBMWzFdLnogKiBMWzBdO1xcblxcdFxcdExbMl0gPSAtTFsyXS56ICogTFsxXSArIExbMV0ueiAqIExbMl07XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDMgKSB7XFxuXFx0XFx0biA9IDQ7XFxuXFx0XFx0TFsyXSA9IC1MWzJdLnogKiBMWzFdICsgTFsxXS56ICogTFsyXTtcXG5cXHRcXHRMWzNdID0gLUxbM10ueiAqIExbMF0gKyBMWzBdLnogKiBMWzNdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSA0ICkge1xcblxcdFxcdG4gPSAzO1xcblxcdFxcdExbMF0gPSAtTFszXS56ICogTFsyXSArIExbMl0ueiAqIExbM107XFxuXFx0XFx0TFsxXSA9IC1MWzFdLnogKiBMWzJdICsgTFsyXS56ICogTFsxXTtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gNSApIHtcXG5cXHRcXHRuID0gMDtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gNiApIHtcXG5cXHRcXHRuID0gNDtcXG5cXHRcXHRMWzBdID0gLUxbMF0ueiAqIExbMV0gKyBMWzFdLnogKiBMWzBdO1xcblxcdFxcdExbM10gPSAtTFszXS56ICogTFsyXSArIExbMl0ueiAqIExbM107XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDcgKSB7XFxuXFx0XFx0biA9IDU7XFxuXFx0XFx0TFs0XSA9IC1MWzNdLnogKiBMWzBdICsgTFswXS56ICogTFszXTtcXG5cXHRcXHRMWzNdID0gLUxbM10ueiAqIExbMl0gKyBMWzJdLnogKiBMWzNdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSA4ICkge1xcblxcdFxcdG4gPSAzO1xcblxcdFxcdExbMF0gPSAtTFswXS56ICogTFszXSArIExbM10ueiAqIExbMF07XFxuXFx0XFx0TFsxXSA9IC1MWzJdLnogKiBMWzNdICsgTFszXS56ICogTFsyXTtcXG5cXHRcXHRMWzJdID0gIExbM107XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDkgKSB7XFxuXFx0XFx0biA9IDQ7XFxuXFx0XFx0TFsxXSA9IC1MWzFdLnogKiBMWzBdICsgTFswXS56ICogTFsxXTtcXG5cXHRcXHRMWzJdID0gLUxbMl0ueiAqIExbM10gKyBMWzNdLnogKiBMWzJdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSAxMCApIHtcXG5cXHRcXHRuID0gMDtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gMTEgKSB7XFxuXFx0XFx0biA9IDU7XFxuXFx0XFx0TFs0XSA9IExbM107XFxuXFx0XFx0TFszXSA9IC1MWzJdLnogKiBMWzNdICsgTFszXS56ICogTFsyXTtcXG5cXHRcXHRMWzJdID0gLUxbMl0ueiAqIExbMV0gKyBMWzFdLnogKiBMWzJdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSAxMiApIHtcXG5cXHRcXHRuID0gNDtcXG5cXHRcXHRMWzFdID0gLUxbMV0ueiAqIExbMl0gKyBMWzJdLnogKiBMWzFdO1xcblxcdFxcdExbMF0gPSAtTFswXS56ICogTFszXSArIExbM10ueiAqIExbMF07XFxuXFx0fSBlbHNlIGlmICggY29uZmlnID09IDEzICkge1xcblxcdFxcdG4gPSA1O1xcblxcdFxcdExbNF0gPSBMWzNdO1xcblxcdFxcdExbM10gPSBMWzJdO1xcblxcdFxcdExbMl0gPSAtTFsxXS56ICogTFsyXSArIExbMl0ueiAqIExbMV07XFxuXFx0XFx0TFsxXSA9IC1MWzFdLnogKiBMWzBdICsgTFswXS56ICogTFsxXTtcXG5cXHR9IGVsc2UgaWYgKCBjb25maWcgPT0gMTQgKSB7XFxuXFx0XFx0biA9IDU7XFxuXFx0XFx0TFs0XSA9IC1MWzBdLnogKiBMWzNdICsgTFszXS56ICogTFswXTtcXG5cXHRcXHRMWzBdID0gLUxbMF0ueiAqIExbMV0gKyBMWzFdLnogKiBMWzBdO1xcblxcdH0gZWxzZSBpZiAoIGNvbmZpZyA9PSAxNSApIHtcXG5cXHRcXHRuID0gNDtcXG5cXHR9XFxuXFx0aWYgKCBuID09IDMgKVxcblxcdFxcdExbM10gPSBMWzBdO1xcblxcdGlmICggbiA9PSA0IClcXG5cXHRcXHRMWzRdID0gTFswXTtcXG59XFxuZmxvYXQgaW50ZWdyYXRlTHRjQnJkZk92ZXJSZWN0RWRnZSggdmVjMyB2MSwgdmVjMyB2MiApIHtcXG5cXHRmbG9hdCBjb3NUaGV0YSA9IGRvdCggdjEsIHYyICk7XFxuXFx0ZmxvYXQgdGhldGEgPSBhY29zKCBjb3NUaGV0YSApO1xcblxcdGZsb2F0IHJlcyA9IGNyb3NzKCB2MSwgdjIgKS56ICogKCAoIHRoZXRhID4gMC4wMDEgKSA/IHRoZXRhIC8gc2luKCB0aGV0YSApIDogMS4wICk7XFxuXFx0cmV0dXJuIHJlcztcXG59XFxudm9pZCBpbml0UmVjdFBvaW50cyggY29uc3QgaW4gdmVjMyBwb3MsIGNvbnN0IGluIHZlYzMgaGFsZldpZHRoLCBjb25zdCBpbiB2ZWMzIGhhbGZIZWlnaHQsIG91dCB2ZWMzIHJlY3RQb2ludHNbNF0gKSB7XFxuXFx0cmVjdFBvaW50c1swXSA9IHBvcyAtIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFxuXFx0cmVjdFBvaW50c1sxXSA9IHBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFxuXFx0cmVjdFBvaW50c1syXSA9IHBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0cmVjdFBvaW50c1szXSA9IHBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxufVxcbnZlYzMgaW50ZWdyYXRlTHRjQnJkZk92ZXJSZWN0KCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBtYXQzIGJyZGZNYXQsIGNvbnN0IGluIHZlYzMgcmVjdFBvaW50c1s0XSApIHtcXG5cXHR2ZWMzIE4gPSBnZW9tZXRyeS5ub3JtYWw7XFxuXFx0dmVjMyBWID0gZ2VvbWV0cnkudmlld0RpcjtcXG5cXHR2ZWMzIFAgPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHR2ZWMzIFQxLCBUMjtcXG5cXHRUMSA9IG5vcm1hbGl6ZShWIC0gTiAqIGRvdCggViwgTiApKTtcXG5cXHRUMiA9IC0gY3Jvc3MoIE4sIFQxICk7XFxuXFx0bWF0MyBicmRmV3J0U3VyZmFjZSA9IGJyZGZNYXQgKiB0cmFuc3Bvc2UoIG1hdDMoIFQxLCBUMiwgTiApICk7XFxuXFx0dmVjMyBjbGlwcGVkUmVjdFs1XTtcXG5cXHRjbGlwcGVkUmVjdFswXSA9IGJyZGZXcnRTdXJmYWNlICogKCByZWN0UG9pbnRzWzBdIC0gUCApO1xcblxcdGNsaXBwZWRSZWN0WzFdID0gYnJkZldydFN1cmZhY2UgKiAoIHJlY3RQb2ludHNbMV0gLSBQICk7XFxuXFx0Y2xpcHBlZFJlY3RbMl0gPSBicmRmV3J0U3VyZmFjZSAqICggcmVjdFBvaW50c1syXSAtIFAgKTtcXG5cXHRjbGlwcGVkUmVjdFszXSA9IGJyZGZXcnRTdXJmYWNlICogKCByZWN0UG9pbnRzWzNdIC0gUCApO1xcblxcdGludCBuO1xcblxcdGNsaXBRdWFkVG9Ib3Jpem9uKGNsaXBwZWRSZWN0LCBuKTtcXG5cXHRpZiAoIG4gPT0gMCApXFxuXFx0XFx0cmV0dXJuIHZlYzMoIDAsIDAsIDAgKTtcXG5cXHRjbGlwcGVkUmVjdFswXSA9IG5vcm1hbGl6ZSggY2xpcHBlZFJlY3RbMF0gKTtcXG5cXHRjbGlwcGVkUmVjdFsxXSA9IG5vcm1hbGl6ZSggY2xpcHBlZFJlY3RbMV0gKTtcXG5cXHRjbGlwcGVkUmVjdFsyXSA9IG5vcm1hbGl6ZSggY2xpcHBlZFJlY3RbMl0gKTtcXG5cXHRjbGlwcGVkUmVjdFszXSA9IG5vcm1hbGl6ZSggY2xpcHBlZFJlY3RbM10gKTtcXG5cXHRjbGlwcGVkUmVjdFs0XSA9IG5vcm1hbGl6ZSggY2xpcHBlZFJlY3RbNF0gKTtcXG5cXHRmbG9hdCBzdW0gPSAwLjA7XFxuXFx0c3VtICs9IGludGVncmF0ZUx0Y0JyZGZPdmVyUmVjdEVkZ2UoIGNsaXBwZWRSZWN0WzBdLCBjbGlwcGVkUmVjdFsxXSApO1xcblxcdHN1bSArPSBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3RFZGdlKCBjbGlwcGVkUmVjdFsxXSwgY2xpcHBlZFJlY3RbMl0gKTtcXG5cXHRzdW0gKz0gaW50ZWdyYXRlTHRjQnJkZk92ZXJSZWN0RWRnZSggY2xpcHBlZFJlY3RbMl0sIGNsaXBwZWRSZWN0WzNdICk7XFxuXFx0aWYgKG4gPj0gNClcXG5cXHRcXHRzdW0gKz0gaW50ZWdyYXRlTHRjQnJkZk92ZXJSZWN0RWRnZSggY2xpcHBlZFJlY3RbM10sIGNsaXBwZWRSZWN0WzRdICk7XFxuXFx0aWYgKG4gPT0gNSlcXG5cXHRcXHRzdW0gKz0gaW50ZWdyYXRlTHRjQnJkZk92ZXJSZWN0RWRnZSggY2xpcHBlZFJlY3RbNF0sIGNsaXBwZWRSZWN0WzBdICk7XFxuXFx0c3VtID0gbWF4KCAwLjAsIHN1bSApO1xcblxcdHZlYzMgTG9faSA9IHZlYzMoIHN1bSwgc3VtLCBzdW0gKTtcXG5cXHRyZXR1cm4gTG9faTtcXG59XFxudmVjMyBSZWN0X0FyZWFfTGlnaHRfU3BlY3VsYXJfUmVmbGVjdGFuY2UoXFxuXFx0XFx0Y29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSxcXG5cXHRcXHRjb25zdCBpbiB2ZWMzIGxpZ2h0UG9zLCBjb25zdCBpbiB2ZWMzIGxpZ2h0SGFsZldpZHRoLCBjb25zdCBpbiB2ZWMzIGxpZ2h0SGFsZkhlaWdodCxcXG5cXHRcXHRjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsXFxuXFx0XFx0Y29uc3QgaW4gc2FtcGxlcjJEIGx0Y01hdCwgY29uc3QgaW4gc2FtcGxlcjJEIGx0Y01hZyApIHtcXG5cXHR2ZWMzIHJlY3RQb2ludHNbNF07XFxuXFx0aW5pdFJlY3RQb2ludHMoIGxpZ2h0UG9zLCBsaWdodEhhbGZXaWR0aCwgbGlnaHRIYWxmSGVpZ2h0LCByZWN0UG9pbnRzICk7XFxuXFx0dmVjMiB1diA9IGx0Y1RleHR1cmVDb29yZHMoIGdlb21ldHJ5LCByb3VnaG5lc3MgKTtcXG5cXHR2ZWM0IGJyZGZMdGNBcHByb3hQYXJhbXMsIHQ7XFxuXFx0YnJkZkx0Y0FwcHJveFBhcmFtcyA9IHRleHR1cmUyRCggbHRjTWF0LCB1diApO1xcblxcdHQgPSB0ZXh0dXJlMkQoIGx0Y01hdCwgdXYgKTtcXG5cXHRmbG9hdCBicmRmTHRjU2NhbGFyID0gdGV4dHVyZTJEKCBsdGNNYWcsIHV2ICkuYTtcXG5cXHRtYXQzIGJyZGZMdGNBcHByb3hNYXQgPSBtYXQzKFxcblxcdFxcdHZlYzMoICAgMSwgICAwLCB0LnkgKSxcXG5cXHRcXHR2ZWMzKCAgIDAsIHQueiwgICAwICksXFxuXFx0XFx0dmVjMyggdC53LCAgIDAsIHQueCApXFxuXFx0KTtcXG5cXHR2ZWMzIHNwZWN1bGFyUmVmbGVjdGFuY2UgPSBpbnRlZ3JhdGVMdGNCcmRmT3ZlclJlY3QoIGdlb21ldHJ5LCBicmRmTHRjQXBwcm94TWF0LCByZWN0UG9pbnRzICk7XFxuXFx0c3BlY3VsYXJSZWZsZWN0YW5jZSAqPSBicmRmTHRjU2NhbGFyO1xcblxcdHJldHVybiBzcGVjdWxhclJlZmxlY3RhbmNlO1xcbn1cXG52ZWMzIFJlY3RfQXJlYV9MaWdodF9EaWZmdXNlX1JlZmxlY3RhbmNlKFxcblxcdFxcdGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksXFxuXFx0XFx0Y29uc3QgaW4gdmVjMyBsaWdodFBvcywgY29uc3QgaW4gdmVjMyBsaWdodEhhbGZXaWR0aCwgY29uc3QgaW4gdmVjMyBsaWdodEhhbGZIZWlnaHQgKSB7XFxuXFx0dmVjMyByZWN0UG9pbnRzWzRdO1xcblxcdGluaXRSZWN0UG9pbnRzKCBsaWdodFBvcywgbGlnaHRIYWxmV2lkdGgsIGxpZ2h0SGFsZkhlaWdodCwgcmVjdFBvaW50cyApO1xcblxcdG1hdDMgZGlmZnVzZUJyZGZNYXQgPSBtYXQzKDEpO1xcblxcdHZlYzMgZGlmZnVzZVJlZmxlY3RhbmNlID0gaW50ZWdyYXRlTHRjQnJkZk92ZXJSZWN0KCBnZW9tZXRyeSwgZGlmZnVzZUJyZGZNYXQsIHJlY3RQb2ludHMgKTtcXG5cXHRyZXR1cm4gZGlmZnVzZVJlZmxlY3RhbmNlO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0Y29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XFxuXFx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXFx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG5cXHRmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTtcXG5cXHR2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcblxcdHJldHVybiBzcGVjdWxhckNvbG9yICogQUIueCArIEFCLnk7XFxufVxcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKSB7XFxuXFx0cmV0dXJuIDAuMjU7XFxufVxcbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7XFxuXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdEaXIgKTtcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxuXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG5mbG9hdCBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIGNvbnN0IGluIGZsb2F0IGdneFJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gKCAyLjAgLyBwb3cyKCBnZ3hSb3VnaG5lc3MgKyAwLjAwMDEgKSAtIDIuMCApO1xcbn1cXG5mbG9hdCBCbGlubkV4cG9uZW50VG9HR1hSb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IGJsaW5uRXhwb25lbnQgKSB7XFxuXFx0cmV0dXJuIHNxcnQoIDIuMCAvICggYmxpbm5FeHBvbmVudCArIDIuMCApICk7XFxufVxcblwiO1xuXG52YXIgYnVtcG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcdHZlYzIgZEhkeHlfZndkKCkge1xcblxcdFxcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cXHRcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFx0XFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcblxcdFxcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblxcdFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcdFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcdH1cXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1xcblxcdFxcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuXFx0XFx0dmVjMyB2U2lnbWFZID0gZEZkeSggc3VyZl9wb3MgKTtcXG5cXHRcXHR2ZWMzIHZOID0gc3VyZl9ub3JtO1xcblxcdFxcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG5cXHRcXHR2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFx0XFx0ZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXG5cXHRcXHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG52YXIgY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBVTklPTl9DTElQUElOR19QTEFORVM7ICsrIGkgKSB7XFxuXFx0XFx0dmVjNCBwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0aWYgKCBkb3QoIHZWaWV3UG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApIGRpc2NhcmQ7XFxuXFx0fVxcblxcdFxcdFxcblxcdCNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTXFxuXFx0XFx0Ym9vbCBjbGlwcGVkID0gdHJ1ZTtcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSA8IE5VTV9DTElQUElOR19QTEFORVM7ICsrIGkgKSB7XFxuXFx0XFx0XFx0dmVjNCBwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0XFx0Y2xpcHBlZCA9ICggZG90KCB2Vmlld1Bvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIGNsaXBwZWQgKSBkaXNjYXJkO1xcblxcdFxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdCNpZiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSB2ZWM0IGNsaXBwaW5nUGxhbmVzWyBOVU1fQ0xJUFBJTkdfUExBTkVTIF07XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXggPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMCAmJiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBjbGlwcGluZ19wbGFuZXNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAgJiYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcblwiO1xuXG52YXIgY29sb3JfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG4jZW5kaWZcIjtcblxudmFyIGNvbG9yX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgY29sb3JfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG52YXIgY29sb3JfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFx0dkNvbG9yLnh5eiA9IGNvbG9yLnh5ejtcXG4jZW5kaWZcIjtcblxudmFyIGNvbW1vbiA9IFwiI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XFxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxOFxcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDlcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuZmxvYXQgcG93MiggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeDsgfVxcbmZsb2F0IHBvdzMoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4KngqeDsgfVxcbmZsb2F0IHBvdzQoIGNvbnN0IGluIGZsb2F0IHggKSB7IGZsb2F0IHgyID0geCp4OyByZXR1cm4geDIqeDI7IH1cXG5mbG9hdCBhdmVyYWdlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkgeyByZXR1cm4gZG90KCBjb2xvciwgdmVjMyggMC4zMzMzICkgKTsgfVxcbmhpZ2hwIGZsb2F0IHJhbmQoIGNvbnN0IGluIHZlYzIgdXYgKSB7XFxuXFx0Y29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xcblxcdGhpZ2hwIGZsb2F0IGR0ID0gZG90KCB1di54eSwgdmVjMiggYSxiICkgKSwgc24gPSBtb2QoIGR0LCBQSSApO1xcblxcdHJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxufVxcbnN0cnVjdCBJbmNpZGVudExpZ2h0IHtcXG5cXHR2ZWMzIGNvbG9yO1xcblxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdGJvb2wgdmlzaWJsZTtcXG59O1xcbnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7XFxuXFx0dmVjMyBkaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgZGlyZWN0U3BlY3VsYXI7XFxuXFx0dmVjMyBpbmRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xcbn07XFxuc3RydWN0IEdlb21ldHJpY0NvbnRleHQge1xcblxcdHZlYzMgcG9zaXRpb247XFxuXFx0dmVjMyBub3JtYWw7XFxuXFx0dmVjMyB2aWV3RGlyO1xcbn07XFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIGRpciwgMC4wICkgKS54eXogKTtcXG59XFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxufVxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcblxcdHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXG59XFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcdHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxufVxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXG59XFxubWF0MyB0cmFuc3Bvc2UoIGNvbnN0IGluIG1hdDMgdiApIHtcXG5cXHRtYXQzIHRtcDtcXG5cXHR0bXBbMF0gPSB2ZWMzKHZbMF0ueCwgdlsxXS54LCB2WzJdLngpO1xcblxcdHRtcFsxXSA9IHZlYzModlswXS55LCB2WzFdLnksIHZbMl0ueSk7XFxuXFx0dG1wWzJdID0gdmVjMyh2WzBdLnosIHZbMV0ueiwgdlsyXS56KTtcXG5cXHRyZXR1cm4gdG1wO1xcbn1cXG5cIjtcblxudmFyIGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCA9IFwiI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG4jZGVmaW5lIGN1YmVVVl90ZXh0dXJlU2l6ZSAoMTAyNC4wKVxcbmludCBnZXRGYWNlRnJvbURpcmVjdGlvbih2ZWMzIGRpcmVjdGlvbikge1xcblxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKGRpcmVjdGlvbik7XFxuXFx0aW50IGZhY2UgPSAtMTtcXG5cXHRpZiggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueiApIHtcXG5cXHRcXHRpZihhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi55IClcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnggPiAwLjAgPyAwIDogMztcXG5cXHRcXHRlbHNlXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMSA6IDQ7XFxuXFx0fVxcblxcdGVsc2Uge1xcblxcdFxcdGlmKGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIgOiA1O1xcblxcdFxcdGVsc2VcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxIDogNDtcXG5cXHR9XFxuXFx0cmV0dXJuIGZhY2U7XFxufVxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMxICAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAxLjApXFxuI2RlZmluZSBjdWJlVVZfcmFuZ2VDbGFtcCAoZXhwMigoNi4wIC0gMS4wKSAqIDIuMCkpXFxudmVjMiBNaXBMZXZlbEluZm8oIHZlYzMgdmVjLCBmbG9hdCByb3VnaG5lc3NMZXZlbCwgZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IHNjYWxlID0gZXhwMihjdWJlVVZfbWF4TG9kczEgLSByb3VnaG5lc3NMZXZlbCk7XFxuXFx0ZmxvYXQgZHhSb3VnaG5lc3MgPSBkRmR4KHJvdWdobmVzcyk7XFxuXFx0ZmxvYXQgZHlSb3VnaG5lc3MgPSBkRmR5KHJvdWdobmVzcyk7XFxuXFx0dmVjMyBkeCA9IGRGZHgoIHZlYyAqIHNjYWxlICogZHhSb3VnaG5lc3MgKTtcXG5cXHR2ZWMzIGR5ID0gZEZkeSggdmVjICogc2NhbGUgKiBkeVJvdWdobmVzcyApO1xcblxcdGZsb2F0IGQgPSBtYXgoIGRvdCggZHgsIGR4ICksIGRvdCggZHksIGR5ICkgKTtcXG5cXHRkID0gY2xhbXAoZCwgMS4wLCBjdWJlVVZfcmFuZ2VDbGFtcCk7XFxuXFx0ZmxvYXQgbWlwTGV2ZWwgPSAwLjUgKiBsb2cyKGQpO1xcblxcdHJldHVybiB2ZWMyKGZsb29yKG1pcExldmVsKSwgZnJhY3QobWlwTGV2ZWwpKTtcXG59XFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczIgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMi4wKVxcbiNkZWZpbmUgY3ViZVVWX3JjcFRleHR1cmVTaXplICgxLjAgLyBjdWJlVVZfdGV4dHVyZVNpemUpXFxudmVjMiBnZXRDdWJlVVYodmVjMyBkaXJlY3Rpb24sIGZsb2F0IHJvdWdobmVzc0xldmVsLCBmbG9hdCBtaXBMZXZlbCkge1xcblxcdG1pcExldmVsID0gcm91Z2huZXNzTGV2ZWwgPiBjdWJlVVZfbWF4TG9kczIgLSAzLjAgPyAwLjAgOiBtaXBMZXZlbDtcXG5cXHRmbG9hdCBhID0gMTYuMCAqIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZTtcXG5cXHR2ZWMyIGV4cDJfcGFja2VkID0gZXhwMiggdmVjMiggcm91Z2huZXNzTGV2ZWwsIG1pcExldmVsICkgKTtcXG5cXHR2ZWMyIHJjcF9leHAyX3BhY2tlZCA9IHZlYzIoIDEuMCApIC8gZXhwMl9wYWNrZWQ7XFxuXFx0ZmxvYXQgcG93U2NhbGUgPSBleHAyX3BhY2tlZC54ICogZXhwMl9wYWNrZWQueTtcXG5cXHRmbG9hdCBzY2FsZSA9IHJjcF9leHAyX3BhY2tlZC54ICogcmNwX2V4cDJfcGFja2VkLnkgKiAwLjI1O1xcblxcdGZsb2F0IG1pcE9mZnNldCA9IDAuNzUqKDEuMCAtIHJjcF9leHAyX3BhY2tlZC55KSAqIHJjcF9leHAyX3BhY2tlZC54O1xcblxcdGJvb2wgYlJlcyA9IG1pcExldmVsID09IDAuMDtcXG5cXHRzY2FsZSA9ICBiUmVzICYmIChzY2FsZSA8IGEpID8gYSA6IHNjYWxlO1xcblxcdHZlYzMgcjtcXG5cXHR2ZWMyIG9mZnNldDtcXG5cXHRpbnQgZmFjZSA9IGdldEZhY2VGcm9tRGlyZWN0aW9uKGRpcmVjdGlvbik7XFxuXFx0ZmxvYXQgcmNwUG93U2NhbGUgPSAxLjAgLyBwb3dTY2FsZTtcXG5cXHRpZiggZmFjZSA9PSAwKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLngsIC1kaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkpO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoMC4wK21pcE9mZnNldCwwLjc1ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyBhIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2UgaWYoIGZhY2UgPT0gMSkge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi55LCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnopO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoc2NhbGUrbWlwT2Zmc2V0LCAwLjc1ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyBhIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2UgaWYoIGZhY2UgPT0gMikge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkpO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoMi4wKnNjYWxlK21pcE9mZnNldCwgMC43NSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gYSA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIGlmKCBmYWNlID09IDMpIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDAuMCttaXBPZmZzZXQsMC41ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAwLjAgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSBpZiggZmFjZSA9PSA0KSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54LCAtZGlyZWN0aW9uLnopO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoc2NhbGUrbWlwT2Zmc2V0LCAwLjUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IDAuMCA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueiwgLWRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSk7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigyLjAqc2NhbGUrbWlwT2Zmc2V0LCAwLjUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IDAuMCA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRyID0gbm9ybWFsaXplKHIpO1xcblxcdGZsb2F0IHRleGVsT2Zmc2V0ID0gMC41ICogY3ViZVVWX3JjcFRleHR1cmVTaXplO1xcblxcdHZlYzIgcyA9ICggci55eiAvIGFicyggci54ICkgKyB2ZWMyKCAxLjAgKSApICogMC41O1xcblxcdHZlYzIgYmFzZSA9IG9mZnNldCArIHZlYzIoIHRleGVsT2Zmc2V0ICk7XFxuXFx0cmV0dXJuIGJhc2UgKyBzICogKCBzY2FsZSAtIDIuMCAqIHRleGVsT2Zmc2V0ICk7XFxufVxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMzIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDMuMClcXG52ZWM0IHRleHR1cmVDdWJlVVYodmVjMyByZWZsZWN0ZWREaXJlY3Rpb24sIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCByb3VnaG5lc3NWYWwgPSByb3VnaG5lc3MqIGN1YmVVVl9tYXhMb2RzMztcXG5cXHRmbG9hdCByMSA9IGZsb29yKHJvdWdobmVzc1ZhbCk7XFxuXFx0ZmxvYXQgcjIgPSByMSArIDEuMDtcXG5cXHRmbG9hdCB0ID0gZnJhY3Qocm91Z2huZXNzVmFsKTtcXG5cXHR2ZWMyIG1pcEluZm8gPSBNaXBMZXZlbEluZm8ocmVmbGVjdGVkRGlyZWN0aW9uLCByMSwgcm91Z2huZXNzKTtcXG5cXHRmbG9hdCBzID0gbWlwSW5mby55O1xcblxcdGZsb2F0IGxldmVsMCA9IG1pcEluZm8ueDtcXG5cXHRmbG9hdCBsZXZlbDEgPSBsZXZlbDAgKyAxLjA7XFxuXFx0bGV2ZWwxID0gbGV2ZWwxID4gNS4wID8gNS4wIDogbGV2ZWwxO1xcblxcdGxldmVsMCArPSBtaW4oIGZsb29yKCBzICsgMC41ICksIDUuMCApO1xcblxcdHZlYzIgdXZfMTAgPSBnZXRDdWJlVVYocmVmbGVjdGVkRGlyZWN0aW9uLCByMSwgbGV2ZWwwKTtcXG5cXHR2ZWM0IGNvbG9yMTAgPSBlbnZNYXBUZXhlbFRvTGluZWFyKHRleHR1cmUyRChlbnZNYXAsIHV2XzEwKSk7XFxuXFx0dmVjMiB1dl8yMCA9IGdldEN1YmVVVihyZWZsZWN0ZWREaXJlY3Rpb24sIHIyLCBsZXZlbDApO1xcblxcdHZlYzQgY29sb3IyMCA9IGVudk1hcFRleGVsVG9MaW5lYXIodGV4dHVyZTJEKGVudk1hcCwgdXZfMjApKTtcXG5cXHR2ZWM0IHJlc3VsdCA9IG1peChjb2xvcjEwLCBjb2xvcjIwLCB0KTtcXG5cXHRyZXR1cm4gdmVjNChyZXN1bHQucmdiLCAxLjApO1xcbn1cXG4jZW5kaWZcXG5cIjtcblxudmFyIGRlZmF1bHRub3JtYWxfdmVydGV4ID0gXCIjaWZkZWYgRkxJUF9TSURFRFxcblxcdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuI2VuZGlmXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG5cIjtcblxudmFyIGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBkaXNwbGFjZW1lbnRtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHRyYW5zZm9ybWVkICs9IG5vcm1hbCAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgZW1pc3NpdmVtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGVtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhciggZW1pc3NpdmVDb2xvciApLnJnYjtcXG5cXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBlbmNvZGluZ3NfZnJhZ21lbnQgPSBcIiAgZ2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7XFxuXCI7XG5cbnZhciBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCA9IFwiXFxudmVjNCBMaW5lYXJUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmFsdWU7XFxufVxcbnZlYzQgR2FtbWFUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcXG59XFxudmVjNCBMaW5lYXJUb0dhbW1hKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBnYW1tYUZhY3RvciApIHtcXG5cXHRyZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIDEuMCAvIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1xcbn1cXG52ZWM0IHNSR0JUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCB2YWx1ZS5yZ2IgKiAwLjA3NzM5OTM4MDgsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wNDA0NSApICkgKSApLCB2YWx1ZS53ICk7XFxufVxcbnZlYzQgTGluZWFyVG9zUkdCKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLncgKTtcXG59XFxudmVjNCBSR0JFVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqIGV4cDIoIHZhbHVlLmEgKiAyNTUuMCAtIDEyOC4wICksIDEuMCApO1xcbn1cXG52ZWM0IExpbmVhclRvUkdCRSggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgoIG1heCggdmFsdWUuciwgdmFsdWUuZyApLCB2YWx1ZS5iICk7XFxuXFx0ZmxvYXQgZkV4cCA9IGNsYW1wKCBjZWlsKCBsb2cyKCBtYXhDb21wb25lbnQgKSApLCAtMTI4LjAsIDEyNy4wICk7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAvIGV4cDIoIGZFeHAgKSwgKCBmRXhwICsgMTI4LjAgKSAvIDI1NS4wICk7XFxufVxcbnZlYzQgUkdCTVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUueHl6ICogdmFsdWUudyAqIG1heFJhbmdlLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQk0oIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcblxcdGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUueCwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXG5cXHRmbG9hdCBNICAgICAgPSBjbGFtcCggbWF4UkdCIC8gbWF4UmFuZ2UsIDAuMCwgMS4wICk7XFxuXFx0TSAgICAgICAgICAgID0gY2VpbCggTSAqIDI1NS4wICkgLyAyNTUuMDtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gKCBNICogbWF4UmFuZ2UgKSwgTSApO1xcbn1cXG52ZWM0IFJHQkRUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggKCBtYXhSYW5nZSAvIDI1NS4wICkgLyB2YWx1ZS5hICksIDEuMCApO1xcbn1cXG52ZWM0IExpbmVhclRvUkdCRCggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0ZmxvYXQgbWF4UkdCID0gbWF4KCB2YWx1ZS54LCBtYXgoIHZhbHVlLmcsIHZhbHVlLmIgKSApO1xcblxcdGZsb2F0IEQgICAgICA9IG1heCggbWF4UmFuZ2UgLyBtYXhSR0IsIDEuMCApO1xcblxcdEQgICAgICAgICAgICA9IG1pbiggZmxvb3IoIEQgKSAvIDI1NS4wLCAxLjAgKTtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogKCBEICogKCAyNTUuMCAvIG1heFJhbmdlICkgKSwgRCApO1xcbn1cXG5jb25zdCBtYXQzIGNMb2dMdXZNID0gbWF0MyggMC4yMjA5LCAwLjMzOTAsIDAuNDE4NCwgMC4xMTM4LCAwLjY3ODAsIDAuNzMxOSwgMC4wMTAyLCAwLjExMzAsIDAuMjk2OSApO1xcbnZlYzQgTGluZWFyVG9Mb2dMdXYoIGluIHZlYzQgdmFsdWUgKSAge1xcblxcdHZlYzMgWHBfWV9YWVpwID0gdmFsdWUucmdiICogY0xvZ0x1dk07XFxuXFx0WHBfWV9YWVpwID0gbWF4KFhwX1lfWFlacCwgdmVjMygxZS02LCAxZS02LCAxZS02KSk7XFxuXFx0dmVjNCB2UmVzdWx0O1xcblxcdHZSZXN1bHQueHkgPSBYcF9ZX1hZWnAueHkgLyBYcF9ZX1hZWnAuejtcXG5cXHRmbG9hdCBMZSA9IDIuMCAqIGxvZzIoWHBfWV9YWVpwLnkpICsgMTI3LjA7XFxuXFx0dlJlc3VsdC53ID0gZnJhY3QoTGUpO1xcblxcdHZSZXN1bHQueiA9IChMZSAtIChmbG9vcih2UmVzdWx0LncqMjU1LjApKS8yNTUuMCkvMjU1LjA7XFxuXFx0cmV0dXJuIHZSZXN1bHQ7XFxufVxcbmNvbnN0IG1hdDMgY0xvZ0x1dkludmVyc2VNID0gbWF0MyggNi4wMDE0LCAtMi43MDA4LCAtMS43OTk2LCAtMS4zMzIwLCAzLjEwMjksIC01Ljc3MjEsIDAuMzAwOCwgLTEuMDg4MiwgNS42MjY4ICk7XFxudmVjNCBMb2dMdXZUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRmbG9hdCBMZSA9IHZhbHVlLnogKiAyNTUuMCArIHZhbHVlLnc7XFxuXFx0dmVjMyBYcF9ZX1hZWnA7XFxuXFx0WHBfWV9YWVpwLnkgPSBleHAyKChMZSAtIDEyNy4wKSAvIDIuMCk7XFxuXFx0WHBfWV9YWVpwLnogPSBYcF9ZX1hZWnAueSAvIHZhbHVlLnk7XFxuXFx0WHBfWV9YWVpwLnggPSB2YWx1ZS54ICogWHBfWV9YWVpwLno7XFxuXFx0dmVjMyB2UkdCID0gWHBfWV9YWVpwLnJnYiAqIGNMb2dMdXZJbnZlcnNlTTtcXG5cXHRyZXR1cm4gdmVjNCggbWF4KHZSR0IsIDAuMCksIDEuMCApO1xcbn1cXG5cIjtcblxudmFyIGVudm1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXFx0XFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRcXHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApICkueHl6ICsgdmVjMyggMC4wLCAwLjAsIDEuMCApICk7XFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHZlYzQoIDAuMCApO1xcblxcdCNlbmRpZlxcblxcdGVudkNvbG9yID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52Q29sb3IgKTtcXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxudmFyIGVudm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgKCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIClcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggUEhZU0lDQUwgKVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgZW52bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgZW52bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgZm9nX3ZlcnRleCA9IFwiXFxuI2lmZGVmIFVTRV9GT0dcXG5mb2dEZXB0aCA9IC1tdlBvc2l0aW9uLno7XFxuI2VuZGlmXCI7XG5cbnZhciBmb2dfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRk9HXFxuICB2YXJ5aW5nIGZsb2F0IGZvZ0RlcHRoO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgZm9nX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdGZsb2F0IGZvZ0ZhY3RvciA9IHdoaXRlQ29tcGxpbWVudCggZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGZvZ0RlcHRoICogZm9nRGVwdGggKiBMT0cyICkgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZm9nRGVwdGggKTtcXG5cXHQjZW5kaWZcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBmb2dDb2xvciwgZm9nRmFjdG9yICk7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBmb2dfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFx0dmFyeWluZyBmbG9hdCBmb2dEZXB0aDtcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbnZhciBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVE9PTlxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGdyYWRpZW50TWFwO1xcblxcdHZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHtcXG5cXHRcXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBsaWdodERpcmVjdGlvbiApO1xcblxcdFxcdHZlYzIgY29vcmQgPSB2ZWMyKCBkb3ROTCAqIDAuNSArIDAuNSwgMC4wICk7XFxuXFx0XFx0I2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnJnYjtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiAoIGNvb3JkLnggPCAwLjcgKSA/IHZlYzMoIDAuNyApIDogdmVjMyggMS4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG52YXIgbGlnaHRtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gUEkgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBsaWdodG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcblxudmFyIGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCA9IFwidmVjMyBkaWZmdXNlID0gdmVjMyggMS4wICk7XFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5nZW9tZXRyeS52aWV3RGlyID0gbm9ybWFsaXplKCAtbXZQb3NpdGlvbi54eXogKTtcXG5HZW9tZXRyaWNDb250ZXh0IGJhY2tHZW9tZXRyeTtcXG5iYWNrR2VvbWV0cnkucG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5iYWNrR2VvbWV0cnkubm9ybWFsID0gLWdlb21ldHJ5Lm5vcm1hbDtcXG5iYWNrR2VvbWV0cnkudmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxudkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcbiNlbmRpZlxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuZmxvYXQgZG90Tkw7XFxudmVjMyBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggcG9pbnRMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggZGlyZWN0aW9uYWxMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZMaWdodEZyb250ICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGJhY2tHZW9tZXRyeSApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcXG5cIjtcblxudmFyIGxpZ2h0c19wYXJzID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0I2VuZGlmXFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxufVxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRpbnQgc2hhZG93O1xcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcXG5cXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFBvaW50TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRpbnQgc2hhZG93O1xcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gUG9pbnRMaWdodCBwb2ludExpZ2h0c1sgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIFBvaW50TGlnaHQgcG9pbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgKSB7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggbGlnaHREaXN0YW5jZSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xcblxcdFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSAoIGRpcmVjdExpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFNwb3RMaWdodCB7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdGZsb2F0IGRpc3RhbmNlO1xcblxcdFxcdGZsb2F0IGRlY2F5O1xcblxcdFxcdGZsb2F0IGNvbmVDb3M7XFxuXFx0XFx0ZmxvYXQgcGVudW1icmFDb3M7XFxuXFx0XFx0aW50IHNoYWRvdztcXG5cXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFNwb3RMaWdodCBzcG90TGlnaHRzWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgYW5nbGVDb3MgPSBkb3QoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgc3BvdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGlmICggYW5nbGVDb3MgPiBzcG90TGlnaHQuY29uZUNvcyApIHtcXG5cXHRcXHRcXHRmbG9hdCBzcG90RWZmZWN0ID0gc21vb3Roc3RlcCggc3BvdExpZ2h0LmNvbmVDb3MsIHNwb3RMaWdodC5wZW51bWJyYUNvcywgYW5nbGVDb3MgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvcjtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBzcG90RWZmZWN0ICogcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHN0cnVjdCBSZWN0QXJlYUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBoYWxmV2lkdGg7XFxuXFx0XFx0dmVjMyBoYWxmSGVpZ2h0O1xcblxcdH07XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjTWF0O1xcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y01hZztcXG5cXHR1bmlmb3JtIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodHNbIE5VTV9SRUNUX0FSRUFfTElHSFRTIF07XFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIHNreUNvbG9yO1xcblxcdFxcdHZlYzMgZ3JvdW5kQ29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTtcXG5cXHR2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxuXFx0XFx0dmVjMyBpcnJhZGlhbmNlID0gbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXHRcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdHJldHVybiBpcnJhZGlhbmNlO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggZ2VvbWV0cnkubm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHdvcmxkTm9ybWFsLngsIHdvcmxkTm9ybWFsLnl6ICk7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHdvcmxkTm9ybWFsLngsIHdvcmxkTm9ybWFsLnl6ICk7XFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIHF1ZXJ5VmVjLCAxLjAgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB2ZWM0KCAwLjAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0fVxcblxcdGZsb2F0IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHRmbG9hdCBtYXhNSVBMZXZlbFNjYWxhciA9IGZsb2F0KCBtYXhNSVBMZXZlbCApO1xcblxcdFxcdGZsb2F0IGRlc2lyZWRNSVBMZXZlbCA9IG1heE1JUExldmVsU2NhbGFyIC0gMC43OTI0OCAtIDAuNSAqIGxvZzIoIHBvdzIoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQgKSArIDEuMCApO1xcblxcdFxcdHJldHVybiBjbGFtcCggZGVzaXJlZE1JUExldmVsLCAwLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxuXFx0fVxcblxcdHZlYzMgZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJNSVBMZXZlbCA9IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIG1heE1JUExldmVsICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5UmVmbGVjdFZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlTG9kRVhUKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdFxcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKHF1ZXJ5UmVmbGVjdFZlYywgQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKGJsaW5uU2hpbmluZXNzRXhwb25lbnQpKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG5cXHRcXHRcXHR2ZWMyIHNhbXBsZVVWO1xcblxcdFxcdFxcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggcmVmbGVjdFZlYy55ICogMC41ICsgMC41ICk7XFxuXFx0XFx0XFx0c2FtcGxlVVYueCA9IGF0YW4oIHJlZmxlY3RWZWMueiwgcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IG5vcm1hbGl6ZSggKCB2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkgKS54eXogKyB2ZWMzKCAwLjAsMC4wLDEuMCApICk7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZXR1cm4gZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdH1cXG4jZW5kaWZcXG5cIjtcblxudmFyIGxpZ2h0c19waG9uZ19mcmFnbWVudCA9IFwiQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xcbm1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzID0gc2hpbmluZXNzO1xcbm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO1xcblwiO1xuXG52YXIgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG5zdHJ1Y3QgQmxpbm5QaG9uZ01hdGVyaWFsIHtcXG5cXHR2ZWMzXFx0ZGlmZnVzZUNvbG9yO1xcblxcdHZlYzNcXHRzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJTaGluaW5lc3M7XFxuXFx0ZmxvYXRcXHRzcGVjdWxhclN0cmVuZ3RoO1xcbn07XFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHZvaWQgUkVfRGlyZWN0X1JlY3RBcmVhX0JsaW5uUGhvbmcoIGNvbnN0IGluIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRcXHR2ZWMzIG1hdERpZmZDb2xvciA9IG1hdGVyaWFsLmRpZmZ1c2VDb2xvcjtcXG5cXHRcXHR2ZWMzIG1hdFNwZWNDb2xvciA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3I7XFxuXFx0XFx0dmVjMyBsaWdodENvbG9yICAgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IEJsaW5uRXhwb25lbnRUb0dHWFJvdWdobmVzcyggbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKTtcXG5cXHRcXHR2ZWMzIHNwZWMgPSBSZWN0X0FyZWFfTGlnaHRfU3BlY3VsYXJfUmVmbGVjdGFuY2UoXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnksXFxuXFx0XFx0XFx0XFx0cmVjdEFyZWFMaWdodC5wb3NpdGlvbiwgcmVjdEFyZWFMaWdodC5oYWxmV2lkdGgsIHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodCxcXG5cXHRcXHRcXHRcXHRyb3VnaG5lc3MsXFxuXFx0XFx0XFx0XFx0bHRjTWF0LCBsdGNNYWcgKTtcXG5cXHRcXHR2ZWMzIGRpZmYgPSBSZWN0X0FyZWFfTGlnaHRfRGlmZnVzZV9SZWZsZWN0YW5jZShcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeSxcXG5cXHRcXHRcXHRcXHRyZWN0QXJlYUxpZ2h0LnBvc2l0aW9uLCByZWN0QXJlYUxpZ2h0LmhhbGZXaWR0aCwgcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0ICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIG1hdFNwZWNDb2xvciAqIHNwZWMgLyBQSTI7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSAgKz0gbGlnaHRDb2xvciAqIG1hdERpZmZDb2xvciAqIGRpZmYgLyBQSTI7XFxuXFx0fVxcbiNlbmRpZlxcbnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0I2lmZGVmIFRPT05cXG5cXHRcXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2VuZGlmXFxuXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApICogbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aDtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9CbGlublBob25nXFxuI2RlZmluZSBSRV9EaXJlY3RfUmVjdEFyZWFcXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWFfQmxpbm5QaG9uZ1xcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdcXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcXHQoMClcXG5cIjtcblxudmFyIGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCA9IFwiUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLjAgLSBtZXRhbG5lc3NGYWN0b3IgKTtcXG5tYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyA9IGNsYW1wKCByb3VnaG5lc3NGYWN0b3IsIDAuMDQsIDEuMCApO1xcbiNpZmRlZiBTVEFOREFSRFxcblxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XFxuI2Vsc2VcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCBNQVhJTVVNX1NQRUNVTEFSX0NPRUZGSUNJRU5UICogcG93MiggcmVmbGVjdGl2aXR5ICkgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XFxuXFx0bWF0ZXJpYWwuY2xlYXJDb2F0ID0gc2F0dXJhdGUoIGNsZWFyQ29hdCApO1xcdG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyA9IGNsYW1wKCBjbGVhckNvYXRSb3VnaG5lc3MsIDAuMDQsIDEuMCApO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQgPSBcInN0cnVjdCBQaHlzaWNhbE1hdGVyaWFsIHtcXG5cXHR2ZWMzXFx0ZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJSb3VnaG5lc3M7XFxuXFx0dmVjM1xcdHNwZWN1bGFyQ29sb3I7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdDtcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3M7XFxuXFx0I2VuZGlmXFxufTtcXG4jZGVmaW5lIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgMC4xNlxcbiNkZWZpbmUgREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjA0XFxuZmxvYXQgY2xlYXJDb2F0REhSQXBwcm94KCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5MICkge1xcblxcdHJldHVybiBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICsgKCAxLjAgLSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICkgKiAoIHBvdyggMS4wIC0gZG90TkwsIDUuMCApICogcG93KCAxLjAgLSByb3VnaG5lc3MsIDIuMCApICk7XFxufVxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRcXHR2ZWMzIG1hdERpZmZDb2xvciA9IG1hdGVyaWFsLmRpZmZ1c2VDb2xvcjtcXG5cXHRcXHR2ZWMzIG1hdFNwZWNDb2xvciA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3I7XFxuXFx0XFx0dmVjMyBsaWdodENvbG9yICAgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzO1xcblxcdFxcdHZlYzMgc3BlYyA9IFJlY3RfQXJlYV9MaWdodF9TcGVjdWxhcl9SZWZsZWN0YW5jZShcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeSxcXG5cXHRcXHRcXHRcXHRyZWN0QXJlYUxpZ2h0LnBvc2l0aW9uLCByZWN0QXJlYUxpZ2h0LmhhbGZXaWR0aCwgcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0LFxcblxcdFxcdFxcdFxcdHJvdWdobmVzcyxcXG5cXHRcXHRcXHRcXHRsdGNNYXQsIGx0Y01hZyApO1xcblxcdFxcdHZlYzMgZGlmZiA9IFJlY3RfQXJlYV9MaWdodF9EaWZmdXNlX1JlZmxlY3RhbmNlKFxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LFxcblxcdFxcdFxcdFxcdHJlY3RBcmVhTGlnaHQucG9zaXRpb24sIHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoLCByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogbWF0U3BlY0NvbG9yICogc3BlYztcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICArPSBsaWdodENvbG9yICogbWF0RGlmZkNvbG9yICogZGlmZjtcXG5cXHR9XFxuI2VuZGlmXFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90TlY7XFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogcmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gY2xlYXJDb2F0UmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X1BoeXNpY2FsXFxuI2RlZmluZSBSRV9EaXJlY3RfUmVjdEFyZWFcXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3RTcGVjdWxhclxcdFxcdFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWxcXG4jZGVmaW5lIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICkgICBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzIClcXG4jZGVmaW5lIE1hdGVyaWFsX0NsZWFyQ29hdF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKVxcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xcbn1cXG5cIjtcblxudmFyIGxpZ2h0c190ZW1wbGF0ZSA9IFwiXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjtcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIHBvaW50TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBzcG90TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggc3BvdExpZ2h0LnNoYWRvdywgZGlyZWN0TGlnaHQudmlzaWJsZSApICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKVxcblxcdFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcXG5cXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWEoIHJlY3RBcmVhTGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcXG5cXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0XFx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0XFx0bGlnaHRNYXBJcnJhZGlhbmNlICo9IFBJO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdGlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcblxcdCNlbmRpZlxcblxcdCNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKVxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRcXHRpcnJhZGlhbmNlICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApICYmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0SXJyYWRpYW5jZSggZ2VvbWV0cnksIDggKTtcXG5cXHQjZW5kaWZcXG5cXHRSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHZlYzMgcmFkaWFuY2UgPSBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggZ2VvbWV0cnksIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0dmVjMyBjbGVhckNvYXRSYWRpYW5jZSA9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeSwgTWF0ZXJpYWxfQ2xlYXJDb2F0X0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgY2xlYXJDb2F0UmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG5cIjtcblxudmFyIGxvZ2RlcHRoYnVmX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUYpICYmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGX0VYVClcXG5cXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcblxudmFyIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbnZhciBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG4jZW5kaWZcIjtcblxudmFyIGxvZ2RlcHRoYnVmX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdGdsX1Bvc2l0aW9uLnogPSBsb2cyKG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApKSAqIGxvZ0RlcHRoQnVmRkM7XFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXHQjZWxzZVxcblxcdFxcdGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXG5cXHR0ZXhlbENvbG9yID0gbWFwVGV4ZWxUb0xpbmVhciggdGV4ZWxDb2xvciApO1xcblxcdGRpZmZ1c2VDb2xvciAqPSB0ZXhlbENvbG9yO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgbWFwX3BhcnRpY2xlX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHZlYzQgbWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIG1hcCwgdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKSAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eSApO1xcblxcdGRpZmZ1c2VDb2xvciAqPSBtYXBUZXhlbFRvTGluZWFyKCBtYXBUZXhlbCApO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBtZXRhbG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzcztcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICk7XFxuXFx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLnI7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBtb3JwaG5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDEgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG4jZW5kaWZcXG5cIjtcblxudmFyIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFx0I2Vsc2VcXG5cXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgbm9ybWFsX2ZsaXAgPSBcIiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRmbG9hdCBmbGlwTm9ybWFsID0gKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcbiNlbHNlXFxuXFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG4jZW5kaWZcXG5cIjtcblxudmFyIG5vcm1hbF9mcmFnbWVudCA9IFwiI2lmZGVmIEZMQVRfU0hBREVEXFxuXFx0dmVjMyBmZHggPSB2ZWMzKCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeCggdlZpZXdQb3NpdGlvbi55ICksIGRGZHgoIHZWaWV3UG9zaXRpb24ueiApICk7XFxuXFx0dmVjMyBmZHkgPSB2ZWMzKCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeSggdlZpZXdQb3NpdGlvbi55ICksIGRGZHkoIHZWaWV3UG9zaXRpb24ueiApICk7XFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBmZHgsIGZkeSApICk7XFxuI2Vsc2VcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApICogZmxpcE5vcm1hbDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBub3JtYWxtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcblxcdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxuXFx0XFx0dmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcdFxcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cXHRcXHR2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1xcblxcdFxcdHZlYzMgTiA9IG5vcm1hbGl6ZSggc3VyZl9ub3JtICk7XFxuXFx0XFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRcXHRtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1xcblxcdFxcdG1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBwYWNraW5nID0gXCJ2ZWMzIHBhY2tOb3JtYWxUb1JHQiggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7XFxufVxcbnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkge1xcblxcdHJldHVybiAxLjAgLSAyLjAgKiByZ2IueHl6O1xcbn1cXG5jb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO1xcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAgMjU2LiApO1xcbmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9ycyA9IFVucGFja0Rvd25zY2FsZSAvIHZlYzQoIFBhY2tGYWN0b3JzLCAxLiApO1xcbmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuO1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBKCBjb25zdCBpbiBmbG9hdCB2ICkge1xcblxcdHZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApO1xcblxcdHIueXp3IC09IHIueHl6ICogU2hpZnRSaWdodDg7XFx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcXG59XFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XFxufVxcbmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCB2aWV3WiArIG5lYXIgKSAvICggbmVhciAtIGZhciApO1xcbn1cXG5mbG9hdCBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGxpbmVhckNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuIGxpbmVhckNsaXBaICogKCBuZWFyIC0gZmFyICkgLSBuZWFyO1xcbn1cXG5mbG9hdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICgoIGZhciAtIG5lYXIgKSAqIHZpZXdaICk7XFxufVxcbmZsb2F0IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBpbnZDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoIG5lYXIgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiBpbnZDbGlwWiAtIGZhciApO1xcbn1cXG5cIjtcblxudmFyIHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQgPSBcIiNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTtcXG4jZW5kaWZcXG5cIjtcblxudmFyIHByb2plY3RfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG4jZWxzZVxcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jZW5kaWZcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblwiO1xuXG52YXIgcm91Z2huZXNzbWFwX2ZyYWdtZW50ID0gXCJmbG9hdCByb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3M7XFxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR2ZWM0IHRleGVsUm91Z2huZXNzID0gdGV4dHVyZTJEKCByb3VnaG5lc3NNYXAsIHZVdiApO1xcblxcdHJvdWdobmVzc0ZhY3RvciAqPSB0ZXhlbFJvdWdobmVzcy5yO1xcbiNlbmRpZlxcblwiO1xuXG52YXIgcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwO1xcbiNlbmRpZlwiO1xuXG52YXIgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdGZsb2F0IHRleHR1cmUyRENvbXBhcmUoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxuXFx0XFx0cmV0dXJuIHN0ZXAoIGNvbXBhcmUsIHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIGRlcHRocywgdXYgKSApICk7XFxuXFx0fVxcblxcdGZsb2F0IHRleHR1cmUyRFNoYWRvd0xlcnAoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgc2l6ZSwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cXHRcXHRjb25zdCB2ZWMyIG9mZnNldCA9IHZlYzIoIDAuMCwgMS4wICk7XFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNpemU7XFxuXFx0XFx0dmVjMiBjZW50cm9pZFVWID0gZmxvb3IoIHV2ICogc2l6ZSArIDAuNSApIC8gc2l6ZTtcXG5cXHRcXHRmbG9hdCBsYiA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC54eCwgY29tcGFyZSApO1xcblxcdFxcdGZsb2F0IGx0ID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnh5LCBjb21wYXJlICk7XFxuXFx0XFx0ZmxvYXQgcmIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXgsIGNvbXBhcmUgKTtcXG5cXHRcXHRmbG9hdCBydCA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC55eSwgY29tcGFyZSApO1xcblxcdFxcdHZlYzIgZiA9IGZyYWN0KCB1diAqIHNpemUgKyAwLjUgKTtcXG5cXHRcXHRmbG9hdCBhID0gbWl4KCBsYiwgbHQsIGYueSApO1xcblxcdFxcdGZsb2F0IGIgPSBtaXgoIHJiLCBydCwgZi55ICk7XFxuXFx0XFx0ZmxvYXQgYyA9IG1peCggYSwgYiwgZi54ICk7XFxuXFx0XFx0cmV0dXJuIGM7XFxuXFx0fVxcblxcdGZsb2F0IGdldFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7XFxuXFx0XFx0c2hhZG93Q29vcmQueHl6IC89IHNoYWRvd0Nvb3JkLnc7XFxuXFx0XFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcblxcdFxcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXG5cXHRcXHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFx0XFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFx0XFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXHRcXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHJldHVybiAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAxLjA7XFxuXFx0fVxcblxcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cXHRcXHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXHRcXHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXG5cXHRcXHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblxcdFxcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXG5cXHRcXHR2ZWMyIHBsYW5hciA9IHYueHk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxuXFx0XFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGlmICggdi56ID4gMC4wIClcXG5cXHRcXHRcXHRcXHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblxcdFxcdFxcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7XFxuXFx0XFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxuXFx0XFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cXHRcXHRmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0JpYXMgKSAvIDEwMDAuMDtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG52YXIgc2hhZG93bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IHNwb3RTaGFkb3dNYXRyaXhbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxudmFyIHNoYWRvd21hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dlNwb3RTaGFkb3dDb29yZFsgaSBdID0gc3BvdFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50ID0gXCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcblxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IGJvb2woIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggc3BvdExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSBib29sKCBwb2ludExpZ2h0LnNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXHRyZXR1cm4gc2hhZG93O1xcbn1cXG5cIjtcblxudmFyIHNraW5iYXNlX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcbiNlbmRpZlwiO1xuXG52YXIgc2tpbm5pbmdfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblxcdFxcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlV2lkdGg7XFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XFxuXFx0XFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdFxcdGZsb2F0IGogPSBpICogNC4wO1xcblxcdFxcdFxcdGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXHRcXHRcXHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApO1xcblxcdFxcdFxcdGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlSGVpZ2h0ICk7XFxuXFx0XFx0XFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFx0XFx0XFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IGJvbmVNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFx0XFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IGJvbmVNYXRyaWNlc1sgaW50KGkpIF07XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgc2tpbm5pbmdfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cXHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG4jZW5kaWZcXG5cIjtcblxudmFyIHNraW5ub3JtYWxfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cXHRza2luTWF0cml4ICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XFxuXFx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxuI2VuZGlmXFxuXCI7XG5cbnZhciBzcGVjdWxhcm1hcF9mcmFnbWVudCA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG4jZWxzZVxcblxcdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuI2VuZGlmXCI7XG5cbnZhciBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciB0b25lbWFwcGluZ19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFRPTkVfTUFQUElORyApXFxuICBnbF9GcmFnQ29sb3IucmdiID0gdG9uZU1hcHBpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXG4jZW5kaWZcXG5cIjtcblxudmFyIHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQgPSBcIiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxudW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ1doaXRlUG9pbnQ7XFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRyZXR1cm4gdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yO1xcbn1cXG52ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXG59XFxuI2RlZmluZSBVbmNoYXJ0ZWQySGVscGVyKCB4ICkgbWF4KCAoICggeCAqICggMC4xNSAqIHggKyAwLjEwICogMC41MCApICsgMC4yMCAqIDAuMDIgKSAvICggeCAqICggMC4xNSAqIHggKyAwLjUwICkgKyAwLjIwICogMC4zMCApICkgLSAwLjAyIC8gMC4zMCwgdmVjMyggMC4wICkgKVxcbnZlYzMgVW5jaGFydGVkMlRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBVbmNoYXJ0ZWQySGVscGVyKCBjb2xvciApIC8gVW5jaGFydGVkMkhlbHBlciggdmVjMyggdG9uZU1hcHBpbmdXaGl0ZVBvaW50ICkgKSApO1xcbn1cXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0Y29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7XFxuXFx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXG59XFxuXCI7XG5cbnZhciB1dl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlwiO1xuXG52YXIgdXZfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG4jZW5kaWZcXG5cIjtcblxudmFyIHV2X3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxuXFx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuI2VuZGlmXCI7XG5cbnZhciB1djJfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XG5cbnZhciB1djJfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG4jZW5kaWZcIjtcblxudmFyIHV2Ml92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdHZVdjIgPSB1djI7XFxuI2VuZGlmXCI7XG5cbnZhciB3b3JsZHBvc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBQSFlTSUNBTCApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXFx0I2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdFxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG52YXIgY3ViZV9mcmFnID0gXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1xcbnVuaWZvcm0gZmxvYXQgdEZsaXA7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1xcblxcdGdsX0ZyYWdDb2xvci5hICo9IG9wYWNpdHk7XFxufVxcblwiO1xuXG52YXIgY3ViZV92ZXJ0ID0gXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4Plxcbn1cXG5cIjtcblxudmFyIGRlcHRoX2ZyYWcgPSBcIiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXG5cXHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxuXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdFxcdGRpZmZ1c2VDb2xvci5hID0gb3BhY2l0eTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggZ2xfRnJhZ0Nvb3JkLnogKSwgb3BhY2l0eSApO1xcblxcdCNlbGlmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZ2xfRnJhZ0Nvb3JkLnogKTtcXG5cXHQjZW5kaWZcXG59XFxuXCI7XG5cbnZhciBkZXB0aF92ZXJ0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG59XFxuXCI7XG5cbnZhciBkaXN0YW5jZVJHQkFfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zO1xcbnZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4gKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uLnh5eiAtIGxpZ2h0UG9zLnh5eiApIC8gMTAwMC4wICk7XFxufVxcblwiO1xuXG52YXIgZGlzdGFuY2VSR0JBX3ZlcnQgPSBcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XFxufVxcblwiO1xuXG52YXIgZXF1aXJlY3RfZnJhZyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xcbnVuaWZvcm0gZmxvYXQgdEZsaXA7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xcblxcdHZlYzIgc2FtcGxlVVY7XFxuXFx0c2FtcGxlVVYueSA9IHNhdHVyYXRlKCB0RmxpcCAqIGRpcmVjdGlvbi55ICogLTAuNSArIDAuNSApO1xcblxcdHNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcbn1cXG5cIjtcblxudmFyIGVxdWlyZWN0X3ZlcnQgPSBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxufVxcblwiO1xuXG52YXIgbGluZWRhc2hlZF9mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcXG51bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cXG5cIjtcblxudmFyIGxpbmVkYXNoZWRfdmVydCA9IFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcblxudmFyIG1lc2hiYXNpY19mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdmVjMyggMS4wICk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG52YXIgbWVzaGJhc2ljX3ZlcnQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVxcblwiO1xuXG52YXIgbWVzaGxhbWJlcnRfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdCNpbmNsdWRlIDxsaWdodG1hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSB2TGlnaHRGcm9udDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICkgKiBnZXRTaGFkb3dNYXNrKCk7XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mbGlwPlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cXG5cIjtcblxudmFyIG1lc2hsYW1iZXJ0X3ZlcnQgPSBcIiNkZWZpbmUgTEFNQkVSVFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVxcblwiO1xuXG52YXIgbWVzaHBob25nX2ZyYWcgPSBcIiNkZWZpbmUgUEhPTkdcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1xcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3Bob25nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdGVtcGxhdGU+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG52YXIgbWVzaHBob25nX3ZlcnQgPSBcIiNkZWZpbmUgUEhPTkdcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG4jZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcblxudmFyIG1lc2hwaHlzaWNhbF9mcmFnID0gXCIjZGVmaW5lIFBIWVNJQ0FMXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcbnVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZuZGVmIFNUQU5EQVJEXFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXQ7XFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3M7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3RlbXBsYXRlPlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCI7XG5cbnZhciBtZXNocGh5c2ljYWxfdmVydCA9IFwiI2RlZmluZSBQSFlTSUNBTFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG4jZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcblxudmFyIG5vcm1hbF9mcmFnID0gXCIjZGVmaW5lIE5PUk1BTFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIG9wYWNpdHkgKTtcXG59XFxuXCI7XG5cbnZhciBub3JtYWxfdmVydCA9IFwiI2RlZmluZSBOT1JNQUxcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxufVxcblwiO1xuXG52YXIgcG9pbnRzX2ZyYWcgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG52YXIgcG9pbnRzX3ZlcnQgPSBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTtcXG5cXHQjZWxzZVxcblxcdFxcdGdsX1BvaW50U2l6ZSA9IHNpemU7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcblxudmFyIHNoYWRvd19mcmFnID0gXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcbn1cXG5cIjtcblxudmFyIHNoYWRvd192ZXJ0ID0gXCIjaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4Plxcbn1cXG5cIjtcblxudmFyIFNoYWRlckNodW5rID0ge1xuXHRhbHBoYW1hcF9mcmFnbWVudDogYWxwaGFtYXBfZnJhZ21lbnQsXG5cdGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGFscGhhdGVzdF9mcmFnbWVudDogYWxwaGF0ZXN0X2ZyYWdtZW50LFxuXHRhb21hcF9mcmFnbWVudDogYW9tYXBfZnJhZ21lbnQsXG5cdGFvbWFwX3BhcnNfZnJhZ21lbnQ6IGFvbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGJlZ2luX3ZlcnRleDogYmVnaW5fdmVydGV4LFxuXHRiZWdpbm5vcm1hbF92ZXJ0ZXg6IGJlZ2lubm9ybWFsX3ZlcnRleCxcblx0YnNkZnM6IGJzZGZzLFxuXHRidW1wbWFwX3BhcnNfZnJhZ21lbnQ6IGJ1bXBtYXBfcGFyc19mcmFnbWVudCxcblx0Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQsXG5cdGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCxcblx0Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXgsXG5cdGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXgsXG5cdGNvbG9yX2ZyYWdtZW50OiBjb2xvcl9mcmFnbWVudCxcblx0Y29sb3JfcGFyc19mcmFnbWVudDogY29sb3JfcGFyc19mcmFnbWVudCxcblx0Y29sb3JfcGFyc192ZXJ0ZXg6IGNvbG9yX3BhcnNfdmVydGV4LFxuXHRjb2xvcl92ZXJ0ZXg6IGNvbG9yX3ZlcnRleCxcblx0Y29tbW9uOiBjb21tb24sXG5cdGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDogY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50LFxuXHRkZWZhdWx0bm9ybWFsX3ZlcnRleDogZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXG5cdGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4LFxuXHRkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfdmVydGV4LFxuXHRlbWlzc2l2ZW1hcF9mcmFnbWVudDogZW1pc3NpdmVtYXBfZnJhZ21lbnQsXG5cdGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGVuY29kaW5nc19mcmFnbWVudDogZW5jb2RpbmdzX2ZyYWdtZW50LFxuXHRlbmNvZGluZ3NfcGFyc19mcmFnbWVudDogZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQsXG5cdGVudm1hcF9mcmFnbWVudDogZW52bWFwX2ZyYWdtZW50LFxuXHRlbnZtYXBfcGFyc19mcmFnbWVudDogZW52bWFwX3BhcnNfZnJhZ21lbnQsXG5cdGVudm1hcF9wYXJzX3ZlcnRleDogZW52bWFwX3BhcnNfdmVydGV4LFxuXHRlbnZtYXBfdmVydGV4OiBlbnZtYXBfdmVydGV4LFxuXHRmb2dfdmVydGV4OiBmb2dfdmVydGV4LFxuXHRmb2dfcGFyc192ZXJ0ZXg6IGZvZ19wYXJzX3ZlcnRleCxcblx0Zm9nX2ZyYWdtZW50OiBmb2dfZnJhZ21lbnQsXG5cdGZvZ19wYXJzX2ZyYWdtZW50OiBmb2dfcGFyc19mcmFnbWVudCxcblx0Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudDogZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCxcblx0bGlnaHRtYXBfZnJhZ21lbnQ6IGxpZ2h0bWFwX2ZyYWdtZW50LFxuXHRsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBsaWdodG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxcblx0bGlnaHRzX3BhcnM6IGxpZ2h0c19wYXJzLFxuXHRsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19mcmFnbWVudCxcblx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCxcblx0bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfdGVtcGxhdGU6IGxpZ2h0c190ZW1wbGF0ZSxcblx0bG9nZGVwdGhidWZfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX2ZyYWdtZW50LFxuXHRsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50OiBsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50LFxuXHRsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXG5cdGxvZ2RlcHRoYnVmX3ZlcnRleDogbG9nZGVwdGhidWZfdmVydGV4LFxuXHRtYXBfZnJhZ21lbnQ6IG1hcF9mcmFnbWVudCxcblx0bWFwX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRtYXBfcGFydGljbGVfZnJhZ21lbnQ6IG1hcF9wYXJ0aWNsZV9mcmFnbWVudCxcblx0bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50LFxuXHRtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9mcmFnbWVudCxcblx0bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50LFxuXHRtb3JwaG5vcm1hbF92ZXJ0ZXg6IG1vcnBobm9ybWFsX3ZlcnRleCxcblx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxuXHRtb3JwaHRhcmdldF92ZXJ0ZXg6IG1vcnBodGFyZ2V0X3ZlcnRleCxcblx0bm9ybWFsX2ZsaXA6IG5vcm1hbF9mbGlwLFxuXHRub3JtYWxfZnJhZ21lbnQ6IG5vcm1hbF9mcmFnbWVudCxcblx0bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6IG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRwYWNraW5nOiBwYWNraW5nLFxuXHRwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OiBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50LFxuXHRwcm9qZWN0X3ZlcnRleDogcHJvamVjdF92ZXJ0ZXgsXG5cdHJvdWdobmVzc21hcF9mcmFnbWVudDogcm91Z2huZXNzbWFwX2ZyYWdtZW50LFxuXHRyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudDogcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCxcblx0c2hhZG93bWFwX3BhcnNfdmVydGV4OiBzaGFkb3dtYXBfcGFyc192ZXJ0ZXgsXG5cdHNoYWRvd21hcF92ZXJ0ZXg6IHNoYWRvd21hcF92ZXJ0ZXgsXG5cdHNoYWRvd21hc2tfcGFyc19mcmFnbWVudDogc2hhZG93bWFza19wYXJzX2ZyYWdtZW50LFxuXHRza2luYmFzZV92ZXJ0ZXg6IHNraW5iYXNlX3ZlcnRleCxcblx0c2tpbm5pbmdfcGFyc192ZXJ0ZXg6IHNraW5uaW5nX3BhcnNfdmVydGV4LFxuXHRza2lubmluZ192ZXJ0ZXg6IHNraW5uaW5nX3ZlcnRleCxcblx0c2tpbm5vcm1hbF92ZXJ0ZXg6IHNraW5ub3JtYWxfdmVydGV4LFxuXHRzcGVjdWxhcm1hcF9mcmFnbWVudDogc3BlY3VsYXJtYXBfZnJhZ21lbnQsXG5cdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQsXG5cdHRvbmVtYXBwaW5nX2ZyYWdtZW50OiB0b25lbWFwcGluZ19mcmFnbWVudCxcblx0dG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDogdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCxcblx0dXZfcGFyc19mcmFnbWVudDogdXZfcGFyc19mcmFnbWVudCxcblx0dXZfcGFyc192ZXJ0ZXg6IHV2X3BhcnNfdmVydGV4LFxuXHR1dl92ZXJ0ZXg6IHV2X3ZlcnRleCxcblx0dXYyX3BhcnNfZnJhZ21lbnQ6IHV2Ml9wYXJzX2ZyYWdtZW50LFxuXHR1djJfcGFyc192ZXJ0ZXg6IHV2Ml9wYXJzX3ZlcnRleCxcblx0dXYyX3ZlcnRleDogdXYyX3ZlcnRleCxcblx0d29ybGRwb3NfdmVydGV4OiB3b3JsZHBvc192ZXJ0ZXgsXG5cblx0Y3ViZV9mcmFnOiBjdWJlX2ZyYWcsXG5cdGN1YmVfdmVydDogY3ViZV92ZXJ0LFxuXHRkZXB0aF9mcmFnOiBkZXB0aF9mcmFnLFxuXHRkZXB0aF92ZXJ0OiBkZXB0aF92ZXJ0LFxuXHRkaXN0YW5jZVJHQkFfZnJhZzogZGlzdGFuY2VSR0JBX2ZyYWcsXG5cdGRpc3RhbmNlUkdCQV92ZXJ0OiBkaXN0YW5jZVJHQkFfdmVydCxcblx0ZXF1aXJlY3RfZnJhZzogZXF1aXJlY3RfZnJhZyxcblx0ZXF1aXJlY3RfdmVydDogZXF1aXJlY3RfdmVydCxcblx0bGluZWRhc2hlZF9mcmFnOiBsaW5lZGFzaGVkX2ZyYWcsXG5cdGxpbmVkYXNoZWRfdmVydDogbGluZWRhc2hlZF92ZXJ0LFxuXHRtZXNoYmFzaWNfZnJhZzogbWVzaGJhc2ljX2ZyYWcsXG5cdG1lc2hiYXNpY192ZXJ0OiBtZXNoYmFzaWNfdmVydCxcblx0bWVzaGxhbWJlcnRfZnJhZzogbWVzaGxhbWJlcnRfZnJhZyxcblx0bWVzaGxhbWJlcnRfdmVydDogbWVzaGxhbWJlcnRfdmVydCxcblx0bWVzaHBob25nX2ZyYWc6IG1lc2hwaG9uZ19mcmFnLFxuXHRtZXNocGhvbmdfdmVydDogbWVzaHBob25nX3ZlcnQsXG5cdG1lc2hwaHlzaWNhbF9mcmFnOiBtZXNocGh5c2ljYWxfZnJhZyxcblx0bWVzaHBoeXNpY2FsX3ZlcnQ6IG1lc2hwaHlzaWNhbF92ZXJ0LFxuXHRub3JtYWxfZnJhZzogbm9ybWFsX2ZyYWcsXG5cdG5vcm1hbF92ZXJ0OiBub3JtYWxfdmVydCxcblx0cG9pbnRzX2ZyYWc6IHBvaW50c19mcmFnLFxuXHRwb2ludHNfdmVydDogcG9pbnRzX3ZlcnQsXG5cdHNoYWRvd19mcmFnOiBzaGFkb3dfZnJhZyxcblx0c2hhZG93X3ZlcnQ6IHNoYWRvd192ZXJ0XG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQ29sb3IoIHIsIGcsIGIgKSB7XG5cblx0aWYgKCBnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Ly8gciBpcyBUSFJFRS5Db2xvciwgaGV4IG9yIHN0cmluZ1xuXHRcdHJldHVybiB0aGlzLnNldCggciApO1xuXG5cdH1cblxuXHRyZXR1cm4gdGhpcy5zZXRSR0IoIHIsIGcsIGIgKTtcblxufVxuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IENvbG9yLFxuXG5cdGlzQ29sb3I6IHRydWUsXG5cblx0cjogMSwgZzogMSwgYjogMSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlICYmIHZhbHVlLmlzQ29sb3IgKSB7XG5cblx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMuciA9IHNjYWxhcjtcblx0XHR0aGlzLmcgPSBzY2FsYXI7XG5cdFx0dGhpcy5iID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRIZXg6IGZ1bmN0aW9uICggaGV4ICkge1xuXG5cdFx0aGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XG5cblx0XHR0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xuXHRcdHRoaXMuZyA9ICggaGV4ID4+IDggJiAyNTUgKSAvIDI1NTtcblx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcblxuXHRcdHRoaXMuciA9IHI7XG5cdFx0dGhpcy5nID0gZztcblx0XHR0aGlzLmIgPSBiO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIHQgKSB7XG5cblx0XHRcdGlmICggdCA8IDAgKSB0ICs9IDE7XG5cdFx0XHRpZiAoIHQgPiAxICkgdCAtPSAxO1xuXHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xuXHRcdFx0aWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcblx0XHRcdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcblx0XHRcdHJldHVybiBwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEhTTCggaCwgcywgbCApIHtcblxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcblx0XHRcdGggPSBfTWF0aC5ldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcblx0XHRcdHMgPSBfTWF0aC5jbGFtcCggcywgMCwgMSApO1xuXHRcdFx0bCA9IF9NYXRoLmNsYW1wKCBsLCAwLCAxICk7XG5cblx0XHRcdGlmICggcyA9PT0gMCApIHtcblxuXHRcdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBwID0gbCA8PSAwLjUgPyBsICogKCAxICsgcyApIDogbCArIHMgLSAoIGwgKiBzICk7XG5cdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcblxuXHRcdFx0XHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcblx0XHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xuXHRcdFx0XHR0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoIHN0eWxlICkge1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQWxwaGEoIHN0cmluZyApIHtcblxuXHRcdFx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0aWYgKCBwYXJzZUZsb2F0KCBzdHJpbmcgKSA8IDEgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0dmFyIG07XG5cblx0XHRpZiAoIG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKFxccyooW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XG5cblx0XHRcdC8vIHJnYiAvIGhzbFxuXG5cdFx0XHR2YXIgY29sb3I7XG5cdFx0XHR2YXIgbmFtZSA9IG1bIDEgXTtcblx0XHRcdHZhciBjb21wb25lbnRzID0gbVsgMiBdO1xuXG5cdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3JnYic6XG5cdFx0XHRcdGNhc2UgJ3JnYmEnOlxuXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xuXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcblx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xuXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMDtcblx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaHNsJzpcblx0XHRcdFx0Y2FzZSAnaHNsYSc6XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuXHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XG5cdFx0XHRcdFx0XHR2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xuXHRcdFx0XHRcdFx0dmFyIGwgPSBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSAvIDEwMDtcblxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggbSA9IC9eXFwjKFtBLUZhLWYwLTldKykkLy5leGVjKCBzdHlsZSApICkge1xuXG5cdFx0XHQvLyBoZXggY29sb3JcblxuXHRcdFx0dmFyIGhleCA9IG1bIDEgXTtcblx0XHRcdHZhciBzaXplID0gaGV4Lmxlbmd0aDtcblxuXHRcdFx0aWYgKCBzaXplID09PSAzICkge1xuXG5cdFx0XHRcdC8vICNmZjBcblx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcblx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcblx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDIgKSwgMTYgKSAvIDI1NTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcblxuXHRcdFx0XHQvLyAjZmYwMDAwXG5cdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XG5cdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCA0ICkgKyBoZXguY2hhckF0KCA1ICksIDE2ICkgLyAyNTU7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggc3R5bGUgJiYgc3R5bGUubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRcdHZhciBoZXggPSBDb2xvcktleXdvcmRzWyBzdHlsZSBdO1xuXG5cdFx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIHJlZFxuXHRcdFx0XHR0aGlzLnNldEhleCggaGV4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gdW5rbm93biBjb2xvclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gY29sb3Iucjtcblx0XHR0aGlzLmcgPSBjb2xvci5nO1xuXHRcdHRoaXMuYiA9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG5cdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIGdhbW1hRmFjdG9yICk7XG5cdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XG5cdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIGdhbW1hRmFjdG9yICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG5cdFx0dmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcblxuXHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xuXHRcdHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBzYWZlSW52ZXJzZSApO1xuXHRcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cblx0XHR0aGlzLnIgPSByICogcjtcblx0XHR0aGlzLmcgPSBnICogZztcblx0XHR0aGlzLmIgPSBiICogYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XG5cdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcblx0XHR0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRIZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xuXG5cdH0sXG5cblx0Z2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XG5cblx0fSxcblxuXHRnZXRIU0w6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xuXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcblx0XHR2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdHZhciBodWUsIHNhdHVyYXRpb247XG5cdFx0dmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XG5cblx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXG5cdFx0XHRodWUgPSAwO1xuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcblxuXHRcdFx0c3dpdGNoICggbWF4ICkge1xuXG5cdFx0XHRcdGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGh1ZSAvPSA2O1xuXG5cdFx0fVxuXG5cdFx0aHNsLmggPSBodWU7XG5cdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xuXHRcdGhzbC5sID0gbGlnaHRuZXNzO1xuXG5cdFx0cmV0dXJuIGhzbDtcblxuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xuXG5cdH0sXG5cblx0b2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cblx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcblxuXHRcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XG5cblx0XHR0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgKz0gY29sb3Iucjtcblx0XHR0aGlzLmcgKz0gY29sb3IuZztcblx0XHR0aGlzLmIgKz0gY29sb3IuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcblx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy5yICs9IHM7XG5cdFx0dGhpcy5nICs9IHM7XG5cdFx0dGhpcy5iICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YjogZnVuY3Rpb24oIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gTWF0aC5tYXgoIDAsIHRoaXMuciAtIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xuXHRcdHRoaXMuYiA9IE1hdGgubWF4KCAwLCB0aGlzLmIgLSBjb2xvci5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnIgKj0gcztcblx0XHR0aGlzLmcgKj0gcztcblx0XHR0aGlzLmIgKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcblx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGMgKSB7XG5cblx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy5yID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5nO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEhleCgpO1xuXG5cdH1cblxufTtcblxudmFyIENvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcbidiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcbidicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcbidjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuJ2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG4nZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxuJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcbidkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuJ2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXG4nZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXG4naW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuJ2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcbidsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuJ2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcbidsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcbidtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcbidtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuJ25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcbidwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuJ3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4Rixcbidyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxuJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXG4nc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuJ3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbmZ1bmN0aW9uIERhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xuXG5cdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xuXG5cdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG5cblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgID0gZmFsc2U7XG5cdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuXG59XG5cbkRhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XG5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhVGV4dHVyZTtcblxuRGF0YVRleHR1cmUucHJvdG90eXBlLmlzRGF0YVRleHR1cmUgPSB0cnVlO1xuXG4vKipcbiAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXG4gKi9cblxudmFyIFVuaWZvcm1zTGliID0ge1xuXG5cdGNvbW1vbjoge1xuXG5cdFx0ZGlmZnVzZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXG5cblx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRvZmZzZXRSZXBlYXQ6IHsgdmFsdWU6IG5ldyBWZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcblxuXHRcdHNwZWN1bGFyTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcblxuXHRcdGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGZsaXBFbnZNYXA6IHsgdmFsdWU6IC0gMSB9LFxuXHRcdHJlZmxlY3Rpdml0eTogeyB2YWx1ZTogMS4wIH0sXG5cdFx0cmVmcmFjdGlvblJhdGlvOiB7IHZhbHVlOiAwLjk4IH1cblxuXHR9LFxuXG5cdGFvbWFwOiB7XG5cblx0XHRhb01hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGFvTWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH1cblxuXHR9LFxuXG5cdGxpZ2h0bWFwOiB7XG5cblx0XHRsaWdodE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdGxpZ2h0TWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH1cblxuXHR9LFxuXG5cdGVtaXNzaXZlbWFwOiB7XG5cblx0XHRlbWlzc2l2ZU1hcDogeyB2YWx1ZTogbnVsbCB9XG5cblx0fSxcblxuXHRidW1wbWFwOiB7XG5cblx0XHRidW1wTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0YnVtcFNjYWxlOiB7IHZhbHVlOiAxIH1cblxuXHR9LFxuXG5cdG5vcm1hbG1hcDoge1xuXG5cdFx0bm9ybWFsTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0bm9ybWFsU2NhbGU6IHsgdmFsdWU6IG5ldyBWZWN0b3IyKCAxLCAxICkgfVxuXG5cdH0sXG5cblx0ZGlzcGxhY2VtZW50bWFwOiB7XG5cblx0XHRkaXNwbGFjZW1lbnRNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRkaXNwbGFjZW1lbnRTY2FsZTogeyB2YWx1ZTogMSB9LFxuXHRcdGRpc3BsYWNlbWVudEJpYXM6IHsgdmFsdWU6IDAgfVxuXG5cdH0sXG5cblx0cm91Z2huZXNzbWFwOiB7XG5cblx0XHRyb3VnaG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxuXG5cdH0sXG5cblx0bWV0YWxuZXNzbWFwOiB7XG5cblx0XHRtZXRhbG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxuXG5cdH0sXG5cblx0Z3JhZGllbnRtYXA6IHtcblxuXHRcdGdyYWRpZW50TWFwOiB7IHZhbHVlOiBudWxsIH1cblxuXHR9LFxuXG5cdGZvZzoge1xuXG5cdFx0Zm9nRGVuc2l0eTogeyB2YWx1ZTogMC4wMDAyNSB9LFxuXHRcdGZvZ05lYXI6IHsgdmFsdWU6IDEgfSxcblx0XHRmb2dGYXI6IHsgdmFsdWU6IDIwMDAgfSxcblx0XHRmb2dDb2xvcjogeyB2YWx1ZTogbmV3IENvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdGxpZ2h0czoge1xuXG5cdFx0YW1iaWVudExpZ2h0Q29sb3I6IHsgdmFsdWU6IFtdIH0sXG5cblx0XHRkaXJlY3Rpb25hbExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdGRpcmVjdGlvbjoge30sXG5cdFx0XHRjb2xvcjoge30sXG5cblx0XHRcdHNoYWRvdzoge30sXG5cdFx0XHRzaGFkb3dCaWFzOiB7fSxcblx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuXHRcdH0gfSxcblxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0c3BvdExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdGNvbG9yOiB7fSxcblx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdGRpcmVjdGlvbjoge30sXG5cdFx0XHRkaXN0YW5jZToge30sXG5cdFx0XHRjb25lQ29zOiB7fSxcblx0XHRcdHBlbnVtYnJhQ29zOiB7fSxcblx0XHRcdGRlY2F5OiB7fSxcblxuXHRcdFx0c2hhZG93OiB7fSxcblx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcblx0XHRcdHNoYWRvd01hcFNpemU6IHt9XG5cdFx0fSB9LFxuXG5cdFx0c3BvdFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcblx0XHRzcG90U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0cG9pbnRMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRjb2xvcjoge30sXG5cdFx0XHRwb3NpdGlvbjoge30sXG5cdFx0XHRkZWNheToge30sXG5cdFx0XHRkaXN0YW5jZToge30sXG5cblx0XHRcdHNoYWRvdzoge30sXG5cdFx0XHRzaGFkb3dCaWFzOiB7fSxcblx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuXHRcdH0gfSxcblxuXHRcdHBvaW50U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxuXHRcdHBvaW50U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0aGVtaXNwaGVyZUxpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdGRpcmVjdGlvbjoge30sXG5cdFx0XHRza3lDb2xvcjoge30sXG5cdFx0XHRncm91bmRDb2xvcjoge31cblx0XHR9IH0sXG5cblx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCBCUkRGIGRhdGEgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBleGFtcGxlIHRvIG1haW4gc3JjXG5cdFx0cmVjdEFyZWFMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRjb2xvcjoge30sXG5cdFx0XHRwb3NpdGlvbjoge30sXG5cdFx0XHR3aWR0aDoge30sXG5cdFx0XHRoZWlnaHQ6IHt9XG5cdFx0fSB9XG5cblx0fSxcblxuXHRwb2ludHM6IHtcblxuXHRcdGRpZmZ1c2U6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhlZWVlZWUgKSB9LFxuXHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdHNpemU6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdHNjYWxlOiB7IHZhbHVlOiAxLjAgfSxcblx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRvZmZzZXRSZXBlYXQ6IHsgdmFsdWU6IG5ldyBWZWN0b3I0KCAwLCAwLCAxLCAxICkgfVxuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxudmFyIFNoYWRlckxpYiA9IHtcblxuXHRiYXNpYzoge1xuXG5cdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2dcblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY192ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfZnJhZ1xuXG5cdH0sXG5cblx0bGFtYmVydDoge1xuXG5cdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdHtcblx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXG5cblx0fSxcblxuXHRwaG9uZzoge1xuXG5cdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ncmFkaWVudG1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdHtcblx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxuXHRcdFx0XHRzcGVjdWxhcjogeyB2YWx1ZTogbmV3IENvbG9yKCAweDExMTExMSApIH0sXG5cdFx0XHRcdHNoaW5pbmVzczogeyB2YWx1ZTogMzAgfVxuXHRcdFx0fVxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXG5cblx0fSxcblxuXHRzdGFuZGFyZDoge1xuXG5cdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5yb3VnaG5lc3NtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5tZXRhbG5lc3NtYXAsXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2csXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXG5cdFx0XHR7XG5cdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0cm91Z2huZXNzOiB7IHZhbHVlOiAwLjUgfSxcblx0XHRcdFx0bWV0YWxuZXNzOiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRcdGVudk1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9IC8vIHRlbXBvcmFyeVxuXHRcdFx0fVxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXG5cblx0fSxcblxuXHRwb2ludHM6IHtcblxuXHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cdFx0XHRVbmlmb3Jtc0xpYi5wb2ludHMsXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2dcblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c192ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfZnJhZ1xuXG5cdH0sXG5cblx0ZGFzaGVkOiB7XG5cblx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXHRcdFx0e1xuXHRcdFx0XHRzY2FsZTogeyB2YWx1ZTogMSB9LFxuXHRcdFx0XHRkYXNoU2l6ZTogeyB2YWx1ZTogMSB9LFxuXHRcdFx0XHR0b3RhbFNpemU6IHsgdmFsdWU6IDIgfVxuXHRcdFx0fVxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX2ZyYWdcblxuXHR9LFxuXG5cdGRlcHRoOiB7XG5cblx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwXG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF9mcmFnXG5cblx0fSxcblxuXHRub3JtYWw6IHtcblxuXHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG5cdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxuXHRcdFx0e1xuXHRcdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxuXHRcdFx0fVxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubm9ybWFsX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm5vcm1hbF9mcmFnXG5cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcblx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRjdWJlOiB7XG5cblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0dEN1YmU6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdHRGbGlwOiB7IHZhbHVlOiAtIDEgfSxcblx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX2ZyYWdcblxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGVxdWlyZWN0OiB7XG5cblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0dEVxdWlyZWN0OiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHR0RmxpcDogeyB2YWx1ZTogLSAxIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF9mcmFnXG5cblx0fSxcblxuXHRkaXN0YW5jZVJHQkE6IHtcblxuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRsaWdodFBvczogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV9mcmFnXG5cblx0fVxuXG59O1xuXG5TaGFkZXJMaWIucGh5c2ljYWwgPSB7XG5cblx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsXG5cdFx0e1xuXHRcdFx0Y2xlYXJDb2F0OiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRjbGVhckNvYXRSb3VnaG5lc3M6IHsgdmFsdWU6IDAgfVxuXHRcdH1cblx0XSApLFxuXG5cdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG5cdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5mdW5jdGlvbiBCb3gyKCBtaW4sIG1heCApIHtcblxuXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBWZWN0b3IyKCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxufVxuXG5Cb3gyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogQm94MixcblxuXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xuXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCApIDogcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cblx0fSxcblxuXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdFx0cG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XG5cblx0fSxcblxuXHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcblx0XHRcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55O1xuXG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcblx0XHQpO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblx0XHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XG5cblx0fSxcblxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBMZW5zRmxhcmVQbHVnaW4oIHJlbmRlcmVyLCBmbGFyZXMgKSB7XG5cblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblx0dmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cblx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcblx0dmFyIHNoYWRlciwgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cblx0dmFyIHRlbXBUZXh0dXJlLCBvY2NsdXNpb25UZXh0dXJlO1xuXG5cdGZ1bmN0aW9uIGluaXQoKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0XHQtIDEsIC0gMSwgIDAsIDAsXG5cdFx0XHQgMSwgLSAxLCAgMSwgMCxcblx0XHRcdCAxLCAgMSwgIDEsIDEsXG5cdFx0XHQtIDEsICAxLCAgMCwgMVxuXHRcdF0gKTtcblxuXHRcdHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuXHRcdFx0MCwgMSwgMixcblx0XHRcdDAsIDIsIDNcblx0XHRdICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHR2ZXJ0ZXhCdWZmZXIgICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0ZWxlbWVudEJ1ZmZlciAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cblx0XHQvLyB0ZXh0dXJlc1xuXG5cdFx0dGVtcFRleHR1cmUgICAgICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRvY2NsdXNpb25UZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCAxNiwgMTYsIDAsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG5cdFx0c2hhZGVyID0ge1xuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcblxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XCJ2VVYgPSB1djtcIixcblxuXHRcdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcblxuXHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcblx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApO1wiLFxuXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XCIsXG5cdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcblx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApO1wiLFxuXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XCIsXG5cdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcblx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApO1wiLFxuXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XCIsXG5cblx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxuXHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XCIsXG5cdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9ICAgICAgIHZpc2liaWxpdHkuYiAvIDkuMDtcIixcblx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxuXG5cdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cdFx0XHRcdFx0XHRcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cblx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cblx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXG5cblx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxuXG5cdFx0XHRcdFx0Ly8gcmVzdG9yZVxuXG5cdFx0XHRcdFx0XCJ9IGVsc2UgaWYgKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG5cdFx0XHRcdFx0Ly8gZmxhcmVcblxuXHRcdFx0XHRcdFwifSBlbHNlIHtcIixcblxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cdFx0XHRcdFx0XHRcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdlZpc2liaWxpdHk7XCIsXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXG5cblx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdFx0fTtcblxuXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcblxuXHRcdGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHR2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHR1djogICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJ1dlwiIClcblx0XHR9O1xuXG5cdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRyZW5kZXJUeXBlOiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJlbmRlclR5cGVcIiApLFxuXHRcdFx0bWFwOiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxuXHRcdFx0b2NjbHVzaW9uTWFwOiAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvY2NsdXNpb25NYXBcIiApLFxuXHRcdFx0b3BhY2l0eTogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvcGFjaXR5XCIgKSxcblx0XHRcdGNvbG9yOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxuXHRcdFx0c2NhbGU6ICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY2FsZVwiICksXG5cdFx0XHRyb3RhdGlvbjogICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJvdGF0aW9uXCIgKSxcblx0XHRcdHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXG5cdFx0fTtcblxuXHR9XG5cblx0Lypcblx0ICogUmVuZGVyIGxlbnMgZmxhcmVzXG5cdCAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXG5cdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXG5cdCAqL1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydCApIHtcblxuXHRcdGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0LncgLyB2aWV3cG9ydC56LFxuXHRcdFx0aGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydC56ICogMC41LFxuXHRcdFx0aGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnQudyAqIDAuNTtcblxuXHRcdHZhciBzaXplID0gMTYgLyB2aWV3cG9ydC53LFxuXHRcdFx0c2NhbGUgPSBuZXcgVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG5cdFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFZlY3RvcjMoIDEsIDEsIDAgKSxcblx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHZhciB2YWxpZEFyZWEgPSBuZXcgQm94MigpO1xuXG5cdFx0dmFsaWRBcmVhLm1pbi5zZXQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnkgKTtcblx0XHR2YWxpZEFyZWEubWF4LnNldCggdmlld3BvcnQueCArICggdmlld3BvcnQueiAtIDE2ICksIHZpZXdwb3J0LnkgKyAoIHZpZXdwb3J0LncgLSAxNiApICk7XG5cblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aW5pdCgpO1xuXG5cdFx0fVxuXG5cdFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XG5cdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXG5cdFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcblxuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XG5cdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG5cdFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggZmFsc2UgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydC53O1xuXHRcdFx0c2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cblx0XHRcdC8vIGNhbGMgb2JqZWN0IHNjcmVlbiBwb3NpdGlvblxuXG5cdFx0XHR2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcblxuXHRcdFx0dGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEyIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMyBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTQgXSApO1xuXG5cdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHQvLyBzZXR1cCBhcnJheXMgZm9yIGdsIHByb2dyYW1zXG5cblx0XHRcdHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xuXG5cdFx0XHQvLyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBsb3dlciBsZWZ0IGNvcm5lciBvZiB0aGUgcGl4ZWxzIHRvIGNvcHlcblxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHZpZXdwb3J0LnggKyAoIHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCApICsgaGFsZlZpZXdwb3J0V2lkdGggLSA4O1xuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA9IHZpZXdwb3J0LnkgKyAoIHNjcmVlblBvc2l0aW9uLnkgKiBoYWxmVmlld3BvcnRIZWlnaHQgKSArIGhhbGZWaWV3cG9ydEhlaWdodCAtIDg7XG5cblx0XHRcdC8vIHNjcmVlbiBjdWxsXG5cblx0XHRcdGlmICggdmFsaWRBcmVhLmNvbnRhaW5zUG9pbnQoIHNjcmVlblBvc2l0aW9uUGl4ZWxzICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcblxuXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcblx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSwgMTYsIDE2LCAwICk7XG5cblxuXHRcdFx0XHQvLyByZW5kZXIgcGluayBxdWFkXG5cblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuXG5cdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XG5cdFx0XHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cblx0XHRcdFx0Ly8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXG5cblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcblx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLngsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnksIDE2LCAxNiwgMCApO1xuXG5cblx0XHRcdFx0Ly8gcmVzdG9yZSBncmFwaGljc1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xuXHRcdFx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdCBwb3NpdGlvbnNcblxuXHRcdFx0XHRmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApO1xuXG5cdFx0XHRcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0XHRmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZW5kZXIgZmxhcmVzXG5cblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XG5cdFx0XHRcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XG5cblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcblxuXHRcdFx0XHRcdFx0c2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnQudztcblxuXHRcdFx0XHRcdFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XG5cdFx0XHRcdFx0XHRzY2FsZS55ID0gc2l6ZTtcblxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgc3ByaXRlLnJvdGF0aW9uICk7XG5cblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgc3ByaXRlLm9wYWNpdHkgKTtcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcblxuXHRcdFx0XHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIHNwcml0ZS5ibGVuZGluZywgc3ByaXRlLmJsZW5kRXF1YXRpb24sIHNwcml0ZS5ibGVuZFNyYywgc3ByaXRlLmJsZW5kRHN0ICk7XG5cdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHNwcml0ZS50ZXh0dXJlLCAxICk7XG5cblx0XHRcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gcmVzdG9yZSBnbFxuXG5cdFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblx0XHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XG5cblx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oIHNoYWRlciApIHtcblxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cblx0XHR2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1xcblwiO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XG5cdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBTcHJpdGVQbHVnaW4oIHJlbmRlcmVyLCBzcHJpdGVzICkge1xuXG5cdHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cdHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXG5cdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG5cdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcblxuXHR2YXIgdGV4dHVyZTtcblxuXHQvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcblxuXHR2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXHR2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG5cdGZ1bmN0aW9uIGluaXQoKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0XHQtIDAuNSwgLSAwLjUsICAwLCAwLFxuXHRcdFx0ICAwLjUsIC0gMC41LCAgMSwgMCxcblx0XHRcdCAgMC41LCAgIDAuNSwgIDEsIDEsXG5cdFx0XHQtIDAuNSwgICAwLjUsICAwLCAxXG5cdFx0XSApO1xuXG5cdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG5cdFx0XHQwLCAxLCAyLFxuXHRcdFx0MCwgMiwgM1xuXHRcdF0gKTtcblxuXHRcdHZlcnRleEJ1ZmZlciAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCk7XG5cblx0XHRhdHRyaWJ1dGVzID0ge1xuXHRcdFx0cG9zaXRpb246XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAncG9zaXRpb24nICksXG5cdFx0XHR1djpcdFx0XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAndXYnIClcblx0XHR9O1xuXG5cdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHR1dk9mZnNldDpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dk9mZnNldCcgKSxcblx0XHRcdHV2U2NhbGU6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZTY2FsZScgKSxcblxuXHRcdFx0cm90YXRpb246XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXG5cdFx0XHRzY2FsZTpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxuXG5cdFx0XHRjb2xvcjpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxuXHRcdFx0bWFwOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxuXHRcdFx0b3BhY2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxuXG5cdFx0XHRtb2RlbFZpZXdNYXRyaXg6IFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbW9kZWxWaWV3TWF0cml4JyApLFxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeDpcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXG5cblx0XHRcdGZvZ1R5cGU6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nVHlwZScgKSxcblx0XHRcdGZvZ0RlbnNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcblx0XHRcdGZvZ05lYXI6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcblx0XHRcdGZvZ0ZhcjpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcblx0XHRcdGZvZ0NvbG9yOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0NvbG9yJyApLFxuXG5cdFx0XHRhbHBoYVRlc3Q6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnYWxwaGFUZXN0JyApXG5cdFx0fTtcblxuXHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcblx0XHRjYW52YXMud2lkdGggPSA4O1xuXHRcdGNhbnZhcy5oZWlnaHQgPSA4O1xuXG5cdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcblx0XHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XG5cblx0XHR0ZXh0dXJlID0gbmV3IFRleHR1cmUoIGNhbnZhcyApO1xuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cblx0XHQvLyBzZXR1cCBnbFxuXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGluaXQoKTtcblxuXHRcdH1cblxuXHRcdGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG5cdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcblxuXHRcdHZhciBvbGRGb2dUeXBlID0gMDtcblx0XHR2YXIgc2NlbmVGb2dUeXBlID0gMDtcblx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG5cdFx0aWYgKCBmb2cgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuZm9nQ29sb3IsIGZvZy5jb2xvci5yLCBmb2cuY29sb3IuZywgZm9nLmNvbG9yLmIgKTtcblxuXHRcdFx0aWYgKCBmb2cuaXNGb2cgKSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dOZWFyLCBmb2cubmVhciApO1xuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0ZhciwgZm9nLmZhciApO1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xuXHRcdFx0XHRvbGRGb2dUeXBlID0gMTtcblx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMTtcblxuXHRcdFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0RlbnNpdHksIGZvZy5kZW5zaXR5ICk7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAyO1xuXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAyO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcblx0XHRcdG9sZEZvZ1R5cGUgPSAwO1xuXHRcdFx0c2NlbmVGb2dUeXBlID0gMDtcblxuXHRcdH1cblxuXG5cdFx0Ly8gdXBkYXRlIHBvc2l0aW9ucyBhbmQgc29ydFxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuXG5cdFx0XHRzcHJpdGUubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0c3ByaXRlLnogPSAtIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XG5cblx0XHR9XG5cblx0XHRzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XG5cblx0XHQvLyByZW5kZXIgYWxsIHNwcml0ZXNcblxuXHRcdHZhciBzY2FsZSA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuXHRcdFx0dmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XG5cblx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKTtcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdFx0c3ByaXRlLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggc3ByaXRlUG9zaXRpb24sIHNwcml0ZVJvdGF0aW9uLCBzcHJpdGVTY2FsZSApO1xuXG5cdFx0XHRzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcblx0XHRcdHNjYWxlWyAxIF0gPSBzcHJpdGVTY2FsZS55O1xuXG5cdFx0XHR2YXIgZm9nVHlwZSA9IDA7XG5cblx0XHRcdGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuXHRcdFx0XHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcblx0XHRcdFx0b2xkRm9nVHlwZSA9IGZvZ1R5cGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIDAsIDAgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XG5cdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XG5cblx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG5cdFx0XHRnbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcblxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcblx0XHRcdHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnNldFRleHR1cmUyRCggbWF0ZXJpYWwubWFwLCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIGdsXG5cblx0XHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKCkge1xuXG5cdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcblxuXHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXG5cblx0XHRcdCdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBmbG9hdCByb3RhdGlvbjsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dlNjYWxlOycsXG5cblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cblx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cblx0XHRcdCd2b2lkIG1haW4oKSB7JyxcblxuXHRcdFx0XHQndlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcblxuXHRcdFx0XHQndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXG5cblx0XHRcdFx0J3ZlYzIgcm90YXRlZFBvc2l0aW9uOycsXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7Jyxcblx0XHRcdFx0J3JvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuXG5cdFx0XHRcdCd2ZWM0IGZpbmFsUG9zaXRpb247JyxcblxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBmaW5hbFBvc2l0aW9uOycsXG5cblx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxuXG5cdFx0XHQnfSdcblxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xuXG5cdFx0XHQncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuXHRcdFx0J3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxuXHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxuXG5cdFx0XHQndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7JyxcblxuXHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcblxuXHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxuXG5cdFx0XHRcdCd2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcblxuXHRcdFx0XHQnaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXG5cblx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxuXG5cdFx0XHRcdCdpZiAoIGZvZ1R5cGUgPiAwICkgeycsXG5cblx0XHRcdFx0XHQnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXG5cdFx0XHRcdFx0J2Zsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxuXG5cdFx0XHRcdFx0J2lmICggZm9nVHlwZSA9PSAxICkgeycsXG5cblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7JyxcblxuXHRcdFx0XHRcdCd9IGVsc2UgeycsXG5cblx0XHRcdFx0XHRcdCdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7Jyxcblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKTsnLFxuXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcblxuXHRcdFx0XHRcdCd9JyxcblxuXHRcdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApOycsXG5cblx0XHRcdFx0J30nLFxuXG5cdFx0XHQnfSdcblxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuXHRcdGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcblxuXHRcdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xuXG5cdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdHJldHVybiBiLnogLSBhLno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYi5pZCAtIGEuaWQ7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxudmFyIG1hdGVyaWFsSWQgPSAwO1xuXG5mdW5jdGlvbiBNYXRlcmlhbCgpIHtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IG1hdGVyaWFsSWQgKysgfSApO1xuXG5cdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdHRoaXMuZm9nID0gdHJ1ZTtcblx0dGhpcy5saWdodHMgPSB0cnVlO1xuXG5cdHRoaXMuYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcblx0dGhpcy5zaWRlID0gRnJvbnRTaWRlO1xuXHR0aGlzLnNoYWRpbmcgPSBTbW9vdGhTaGFkaW5nOyAvLyBUSFJFRS5GbGF0U2hhZGluZywgVEhSRUUuU21vb3RoU2hhZGluZ1xuXHR0aGlzLnZlcnRleENvbG9ycyA9IE5vQ29sb3JzOyAvLyBUSFJFRS5Ob0NvbG9ycywgVEhSRUUuVmVydGV4Q29sb3JzLCBUSFJFRS5GYWNlQ29sb3JzXG5cblx0dGhpcy5vcGFjaXR5ID0gMTtcblx0dGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG5cdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3Rvcjtcblx0dGhpcy5ibGVuZERzdCA9IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuXHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cblx0dGhpcy5kZXB0aEZ1bmMgPSBMZXNzRXF1YWxEZXB0aDtcblx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuXHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG5cdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBudWxsO1xuXHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBmYWxzZTtcblx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xuXG5cdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cblx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG5cdHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xuXHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cblx0dGhpcy5hbHBoYVRlc3QgPSAwO1xuXHR0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IGZhbHNlO1xuXG5cdHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn1cblxuTWF0ZXJpYWwucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBNYXRlcmlhbCxcblxuXHRpc01hdGVyaWFsOiB0cnVlLFxuXG5cdGdldCBuZWVkc1VwZGF0ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuXHR9LFxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcblxuXHRcdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0dmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcblxuXHRcdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5cIiArIHRoaXMudHlwZSArIFwiOiAnXCIgKyBrZXkgKyBcIicgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC5cIiApO1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNDb2xvciApIHtcblxuXHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAoIGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNWZWN0b3IzICkgJiYgKCBuZXdWYWx1ZSAmJiBuZXdWYWx1ZS5pc1ZlY3RvcjMgKSApIHtcblxuXHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xuXG5cdFx0XHRcdC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0aWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcblx0XHRcdFx0dGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0XHR2YXIgaXNSb290ID0gbWV0YSA9PT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCBpc1Jvb3QgKSB7XG5cblx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcblx0XHRcdFx0aW1hZ2VzOiB7fVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHZhciBkYXRhID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC40LFxuXHRcdFx0XHR0eXBlOiAnTWF0ZXJpYWwnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yICYmIHRoaXMuY29sb3IuaXNDb2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG5cdFx0aWYgKCB0aGlzLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5yb3VnaG5lc3MgPSB0aGlzLnJvdWdobmVzcztcblx0XHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xuXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlICYmIHRoaXMuZW1pc3NpdmUuaXNDb2xvciApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhciAmJiB0aGlzLnNwZWN1bGFyLmlzQ29sb3IgKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcblx0XHRpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXHRcdGlmICggdGhpcy5jbGVhckNvYXQgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJDb2F0ID0gdGhpcy5jbGVhckNvYXQ7XG5cdFx0aWYgKCB0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5jbGVhckNvYXRSb3VnaG5lc3MgPSB0aGlzLmNsZWFyQ29hdFJvdWdobmVzcztcblxuXHRcdGlmICggdGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5hbHBoYU1hcCAmJiB0aGlzLmFscGhhTWFwLmlzVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLmxpZ2h0TWFwICYmIHRoaXMubGlnaHRNYXAuaXNUZXh0dXJlICkgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMuYnVtcE1hcCAmJiB0aGlzLmJ1bXBNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG5cblx0XHR9XG5cdFx0aWYgKCB0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlLnRvQXJyYXkoKTtcblxuXHRcdH1cblx0XHRpZiAoIHRoaXMuZGlzcGxhY2VtZW50TWFwICYmIHRoaXMuZGlzcGxhY2VtZW50TWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLnJvdWdobmVzc01hcCA9IHRoaXMucm91Z2huZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLm1ldGFsbmVzc01hcCA9IHRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRpZiAoIHRoaXMuZW1pc3NpdmVNYXAgJiYgdGhpcy5lbWlzc2l2ZU1hcC5pc1RleHR1cmUgKSBkYXRhLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRpZiAoIHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5lbnZNYXAgPSB0aGlzLmVudk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0ZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmdyYWRpZW50TWFwICYmIHRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZSA9IHRoaXMuc2l6ZTtcblx0XHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSBOb3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdGlmICggdGhpcy5zaGFkaW5nICE9PSBTbW9vdGhTaGFkaW5nICkgZGF0YS5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXHRcdGlmICggdGhpcy5zaWRlICE9PSBGcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG5cdFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xuXG5cdFx0ZGF0YS5kZXB0aEZ1bmMgPSB0aGlzLmRlcHRoRnVuYztcblx0XHRkYXRhLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xuXHRcdGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblxuXHRcdGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcblx0XHRpZiAoIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkgZGF0YS5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcblx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSApIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVjYXAgIT09ICdyb3VuZCcgKSBkYXRhLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVqb2luICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHRkYXRhLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcblx0XHRkYXRhLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xuXG5cdFx0Ly8gVE9ETzogQ29waWVkIGZyb20gT2JqZWN0M0QudG9KU09OXG5cblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xuXG5cdFx0XHRcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpc1Jvb3QgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcblx0XHRcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBkYXRhLnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgZGF0YS5pbWFnZXMgPSBpbWFnZXM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblxuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XG5cdFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XG5cdFx0dGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcblxuXHRcdHRoaXMuYmxlbmRTcmMgPSBzb3VyY2UuYmxlbmRTcmM7XG5cdFx0dGhpcy5ibGVuZERzdCA9IHNvdXJjZS5ibGVuZERzdDtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBzb3VyY2UuYmxlbmRTcmNBbHBoYTtcblx0XHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBzb3VyY2UuYmxlbmREc3RBbHBoYTtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cblx0XHR0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XG5cdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xuXHRcdHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuXG5cdFx0dGhpcy5jb2xvcldyaXRlID0gc291cmNlLmNvbG9yV3JpdGU7XG5cblx0XHR0aGlzLnByZWNpc2lvbiA9IHNvdXJjZS5wcmVjaXNpb247XG5cblx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cblx0XHR0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XG5cblx0XHR0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBsaWVkQWxwaGE7XG5cblx0XHR0aGlzLm92ZXJkcmF3ID0gc291cmNlLm92ZXJkcmF3O1xuXG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IHNvdXJjZS5jbGlwU2hhZG93cztcblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcblxuXHRcdHZhciBzcmNQbGFuZXMgPSBzb3VyY2UuY2xpcHBpbmdQbGFuZXMsXG5cdFx0XHRkc3RQbGFuZXMgPSBudWxsO1xuXG5cdFx0aWYgKCBzcmNQbGFuZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdHZhciBuID0gc3JjUGxhbmVzLmxlbmd0aDtcblx0XHRcdGRzdFBsYW5lcyA9IG5ldyBBcnJheSggbiApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxuXHRcdFx0XHRkc3RQbGFuZXNbIGkgXSA9IHNyY1BsYW5lc1sgaSBdLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gZHN0UGxhbmVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cbk9iamVjdC5hc3NpZ24oIE1hdGVyaWFsLnByb3RvdHlwZSwgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApO1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBkZWZpbmVzOiB7IFwibGFiZWxcIiA6IFwidmFsdWVcIiB9LFxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdmFsdWUyOiAyIH0gfSxcbiAqXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgbGlnaHRzOiA8Ym9vbD4sXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBTaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcblxuXHR0aGlzLmRlZmluZXMgPSB7fTtcblx0dGhpcy51bmlmb3JtcyA9IHt9O1xuXG5cdHRoaXMudmVydGV4U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufSc7XG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xuXG5cdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblx0dGhpcy5jbGlwcGluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXNcblxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xuXG5cdHRoaXMuZXh0ZW5zaW9ucyA9IHtcblx0XHRkZXJpdmF0aXZlczogZmFsc2UsIC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcblx0XHRmcmFnRGVwdGg6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGZyYWdtZW50IGRlcHRoIHZhbHVlc1xuXHRcdGRyYXdCdWZmZXJzOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBkcmF3IGJ1ZmZlcnNcblx0XHRzaGFkZXJUZXh0dXJlTE9EOiBmYWxzZSAvLyBzZXQgdG8gdXNlIHNoYWRlciB0ZXh0dXJlIExPRFxuXHR9O1xuXG5cdC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxuXHQvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXG5cdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcblx0XHQnY29sb3InOiBbIDEsIDEsIDEgXSxcblx0XHQndXYnOiBbIDAsIDAgXSxcblx0XHQndXYyJzogWyAwLCAwIF1cblx0fTtcblxuXHR0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XG5cblx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBkZWZpbmVkIGluIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cbn1cblxuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkZXJNYXRlcmlhbDtcblxuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzU2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBzb3VyY2UuZnJhZ21lbnRTaGFkZXI7XG5cdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcblxuXHR0aGlzLnVuaWZvcm1zID0gVW5pZm9ybXNVdGlscy5jbG9uZSggc291cmNlLnVuaWZvcm1zICk7XG5cblx0dGhpcy5kZWZpbmVzID0gc291cmNlLmRlZmluZXM7XG5cblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cblx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xuXHR0aGlzLmNsaXBwaW5nID0gc291cmNlLmNsaXBwaW5nO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cblx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cblx0dGhpcy5leHRlbnNpb25zID0gc291cmNlLmV4dGVuc2lvbnM7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0dmFyIGRhdGEgPSBNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuXHRkYXRhLnVuaWZvcm1zID0gdGhpcy51bmlmb3Jtcztcblx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcblx0ZGF0YS5mcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXI7XG5cblx0cmV0dXJuIGRhdGE7XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cHM6Ly9jbGFyYS5pb1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuICogfVxuICovXG5cbmZ1bmN0aW9uIE1lc2hEZXB0aE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXG5cdHRoaXMuZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XG5cblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHR0aGlzLmZvZyA9IGZhbHNlO1xuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn1cblxuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoRGVwdGhNYXRlcmlhbDtcblxuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xuXG5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcblxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5mdW5jdGlvbiBCb3gzKCBtaW4sIG1heCApIHtcblxuXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxufVxuXG5Cb3gzLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogQm94MyxcblxuXHRpc0JveDM6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdHZhciBtaW5YID0gKyBJbmZpbml0eTtcblx0XHR2YXIgbWluWSA9ICsgSW5maW5pdHk7XG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xuXG5cdFx0dmFyIG1heFggPSAtIEluZmluaXR5O1xuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcblx0XHR2YXIgbWF4WiA9IC0gSW5maW5pdHk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdHZhciB4ID0gYXJyYXlbIGkgXTtcblx0XHRcdHZhciB5ID0gYXJyYXlbIGkgKyAxIF07XG5cdFx0XHR2YXIgeiA9IGFycmF5WyBpICsgMiBdO1xuXG5cdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XG5cdFx0XHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XG5cdFx0XHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XG5cblx0XHRcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcblx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcblx0XHRcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcblxuXHRcdH1cblxuXHRcdHRoaXMubWluLnNldCggbWluWCwgbWluWSwgbWluWiApO1xuXHRcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSApIHtcblxuXHRcdHZhciBtaW5YID0gKyBJbmZpbml0eTtcblx0XHR2YXIgbWluWSA9ICsgSW5maW5pdHk7XG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xuXG5cdFx0dmFyIG1heFggPSAtIEluZmluaXR5O1xuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcblx0XHR2YXIgbWF4WiA9IC0gSW5maW5pdHk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgeCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHR2YXIgeSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XG5cdFx0XHR2YXIgeiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XG5cblx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcblx0XHRcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcblx0XHRcdGlmICggeiA8IG1pblogKSBtaW5aID0gejtcblxuXHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xuXHRcdFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xuXHRcdFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5taW4uc2V0KCBtaW5YLCBtaW5ZLCBtaW5aICk7XG5cdFx0dGhpcy5tYXguc2V0KCBtYXhYLCBtYXhZLCBtYXhaICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcblxuXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdHJldHVybiB0aGlzLmV4cGFuZEJ5T2JqZWN0KCBvYmplY3QgKTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gKyBJbmZpbml0eTtcblx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xuXG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCwgMCApIDogcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cblx0fSxcblxuXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXhwYW5kQnlPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG5cdFx0Ly8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXG5cblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4cGFuZEJ5T2JqZWN0KCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgaSwgbDtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2MS5jb3B5KCB2ZXJ0aWNlc1sgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0XHRcdHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaSApLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XG5cblx0fSxcblxuXHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcblx0XHRcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICYmXG5cdFx0XHR0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcblxuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXG5cdFx0KTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuXHRcdFx0Ym94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XG5cdFx0XHRib3gubWF4LnogPCB0aGlzLm1pbi56IHx8IGJveC5taW4ueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RzU3BoZXJlOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBjbG9zZXN0UG9pbnQ7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0XHRpZiAoIGNsb3Nlc3RQb2ludCA9PT0gdW5kZWZpbmVkICkgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgY2xvc2VzdFBvaW50ICk7XG5cblx0XHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggc3BoZXJlLmNlbnRlciApIDw9ICggc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH07XG5cblx0fSApKCksXG5cblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IHBsYW5lLmNvbnN0YW50ICk7XG5cblx0fSxcblxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRCb3VuZGluZ1NwaGVyZSggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgU3BoZXJlKCk7XG5cblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCByZXN1bHQuY2VudGVyICk7XG5cblx0XHRcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLmdldFNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHQvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXG5cdFx0aWYoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRuZXcgVmVjdG9yMygpLFxuXHRcdFx0bmV3IFZlY3RvcjMoKSxcblx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRuZXcgVmVjdG9yMygpLFxuXHRcdFx0bmV3IFZlY3RvcjMoKSxcblx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRuZXcgVmVjdG9yMygpXG5cdFx0XTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdFx0Ly8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXG5cdFx0XHRpZiggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcblxuXHRcdFx0Ly8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcblx0XHRcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG5cdFx0XHRwb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcblx0XHRcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG5cdFx0XHRwb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcblx0XHRcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcdC8vIDExMVxuXG5cdFx0XHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gU3BoZXJlKCBjZW50ZXIsIHJhZGl1cyApIHtcblxuXHR0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBWZWN0b3IzKCk7XG5cdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMDtcblxufVxuXG5TcGhlcmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBTcGhlcmUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBib3g7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVBvaW50cyggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcblxuXHRcdFx0aWYgKCBib3ggPT09IHVuZGVmaW5lZCApIGJveCA9IG5ldyBCb3gzKCk7IC8vIHNlZSAjMTA1NDdcblxuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG5cdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuXHRcdHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcblxuXHR9LFxuXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdC8vIFdlIHVzZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHRvIGNvbXB1dGUgdGhlIHNpZ25lZCBkaXN0YW5jZSBmcm9tXG5cdFx0Ly8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlIHRvIHRoZSBwbGFuZS5cblx0XHQvL1xuXHRcdC8vIGRpc3RhbmNlID0gcSAqIG4gLSBkXG5cdFx0Ly9cblx0XHQvLyBJZiB0aGlzIGRpc3RhbmNlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUsXG5cdFx0Ly8gdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMuY2VudGVyLmRvdCggcGxhbmUubm9ybWFsICkgLSBwbGFuZS5jb25zdGFudCApIDw9IHRoaXMucmFkaXVzO1xuXG5cdH0sXG5cblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcblxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG5cdFx0XHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fSxcblxuXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgQm94MygpO1xuXG5cdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG5cdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG5cdFx0cmV0dXJuIGJveDtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuZnVuY3Rpb24gTWF0cml4MygpIHtcblxuXHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG5cdFx0MSwgMCwgMCxcblx0XHQwLCAxLCAwLFxuXHRcdDAsIDAsIDFcblxuXHRdICk7XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuXHR9XG5cbn1cblxuTWF0cml4My5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IE1hdHJpeDMsXG5cblx0aXNNYXRyaXgzOiB0cnVlLFxuXG5cdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyAxIF0gPSBuMjE7IHRlWyAyIF0gPSBuMzE7XG5cdFx0dGVbIDMgXSA9IG4xMjsgdGVbIDQgXSA9IG4yMjsgdGVbIDUgXSA9IG4zMjtcblx0XHR0ZVsgNiBdID0gbjEzOyB0ZVsgNyBdID0gbjIzOyB0ZVsgOCBdID0gbjMzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgMyBdLCBtZVsgNiBdLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSxcblx0XHRcdG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF1cblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXg0OiBmdW5jdGlvbiggbSApIHtcblxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDQgXSwgbWVbICA4IF0sXG5cdFx0XHRtZVsgMSBdLCBtZVsgNSBdLCBtZVsgIDkgXSxcblx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseVRvQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHRcdHYxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xuXHRcdFx0XHR2MS56ID0gYXR0cmlidXRlLmdldFooIGkgKTtcblxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuc2V0WFlaKCBpLCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXG5cdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxuXHRcdFx0ZyA9IHRlWyA2IF0sIGggPSB0ZVsgNyBdLCBpID0gdGVbIDggXTtcblxuXHRcdHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XG5cblx0fSxcblxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XG5cblx0XHRpZiAoIG1hdHJpeCAmJiBtYXRyaXguaXNNYXRyaXg0ICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk1hdHJpeDMuZ2V0SW52ZXJzZSBubyBsb25nZXIgdGFrZXMgYSBNYXRyaXg0IGFyZ3VtZW50LlwiICk7XG5cblx0XHR9XG5cblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHMsXG5cdFx0XHR0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXG5cdFx0XHRuMTIgPSBtZVsgMyBdLCBuMjIgPSBtZVsgNCBdLCBuMzIgPSBtZVsgNSBdLFxuXHRcdFx0bjEzID0gbWVbIDYgXSwgbjIzID0gbWVbIDcgXSwgbjMzID0gbWVbIDggXSxcblxuXHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuXHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuXHRcdFx0dDEzID0gbjIzICogbjEyIC0gbjIyICogbjEzLFxuXG5cdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHtcblxuXHRcdFx0dmFyIG1zZyA9IFwiVEhSRUUuTWF0cml4My5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcblxuXHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcblx0XHR9XG5cblx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMyBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xuXG5cdFx0dGVbIDYgXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcblx0XHR0ZVsgOCBdID0gKCBuMjIgKiBuMTEgLSBuMjEgKiBuMTIgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyWyAwIF0gPSBtWyAwIF07XG5cdFx0clsgMSBdID0gbVsgMyBdO1xuXHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRyWyAzIF0gPSBtWyAxIF07XG5cdFx0clsgNCBdID0gbVsgNCBdO1xuXHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRyWyA2IF0gPSBtWyAyIF07XG5cdFx0clsgNyBdID0gbVsgNSBdO1xuXHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5mdW5jdGlvbiBQbGFuZSggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XG5cdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxufVxuXG5QbGFuZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFBsYW5lLFxuXG5cdHNldDogZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5zZXQoIHgsIHksIHogKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcdC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCBhLCBiLCBjICkge1xuXG5cdFx0XHR2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cblxuXHRcdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXG5cblx0XHR2YXIgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xuXHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XG5cdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuY29uc3RhbnQgKj0gLSAxO1xuXHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWwuZG90KCBwb2ludCApICsgdGhpcy5jb25zdGFudDtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgLSBzcGhlcmUucmFkaXVzO1xuXG5cdH0sXG5cblx0cHJvamVjdFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLm9ydGhvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApLnN1YiggcG9pbnQgKS5uZWdhdGUoKTtcblxuXHR9LFxuXG5cdG9ydGhvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKTtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggcGVycGVuZGljdWxhck1hZ25pdHVkZSApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG5cdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG5cdFx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdFx0aWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cblx0XHRcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3RzTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0Ly8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXG5cblx0XHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcblx0XHR2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xuXG5cdFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseU1hdHJpeDQoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cblx0XHRcdHZhciByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjEgKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHQvLyB0cmFuc2Zvcm0gbm9ybWFsIGJhc2VkIG9uIHRoZW9yeSBoZXJlOlxuXHRcdFx0Ly8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblx0XHRcdHZhciBub3JtYWwgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHQvLyByZWNhbGN1bGF0ZSBjb25zdGFudCAobGlrZSBpbiBzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludClcblx0XHRcdHRoaXMuY29uc3RhbnQgPSAtIHJlZmVyZW5jZVBvaW50LmRvdCggbm9ybWFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuXHRcdHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5mdW5jdGlvbiBGcnVzdHVtKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdHRoaXMucGxhbmVzID0gW1xuXG5cdFx0KCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBQbGFuZSgpLFxuXHRcdCggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgUGxhbmUoKSxcblx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFBsYW5lKCksXG5cdFx0KCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBQbGFuZSgpLFxuXHRcdCggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgUGxhbmUoKSxcblx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFBsYW5lKClcblxuXHRdO1xuXG59XG5cbkZydXN0dW0ucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBGcnVzdHVtLFxuXG5cdHNldDogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0cGxhbmVzWyAwIF0uY29weSggcDAgKTtcblx0XHRwbGFuZXNbIDEgXS5jb3B5KCBwMSApO1xuXHRcdHBsYW5lc1sgMiBdLmNvcHkoIHAyICk7XG5cdFx0cGxhbmVzWyAzIF0uY29weSggcDMgKTtcblx0XHRwbGFuZXNbIDQgXS5jb3B5KCBwNCApO1xuXHRcdHBsYW5lc1sgNSBdLmNvcHkoIHA1ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XG5cblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xuXHRcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xuXHRcdHZhciBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcblx0XHR2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xuXG5cdFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXG5cdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKVxuXHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3RzU3ByaXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNTcHJpdGUoIHNwcml0ZSApIHtcblxuXHRcdFx0c3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdHNwaGVyZS5yYWRpdXMgPSAwLjcwNzEwNjc4MTE4NjU0NzY7XG5cdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcblx0XHR2YXIgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcblxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHAxID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHAyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XG5cblx0XHRcdFx0cDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcblx0XHRcdFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcblx0XHRcdFx0cDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcblx0XHRcdFx0cDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcblx0XHRcdFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcblx0XHRcdFx0cDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcblxuXHRcdFx0XHR2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XG5cdFx0XHRcdHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcblxuXHRcdFx0XHQvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxuXG5cdFx0XHRcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gV2ViR0xTaGFkb3dNYXAoIF9yZW5kZXJlciwgX2xpZ2h0cywgX29iamVjdHMsIGNhcGFiaWxpdGllcyApIHtcblxuXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXG5cdF9zdGF0ZSA9IF9yZW5kZXJlci5zdGF0ZSxcblx0X2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpLFxuXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCksXG5cblx0X2xpZ2h0U2hhZG93cyA9IF9saWdodHMuc2hhZG93cyxcblxuXHRfc2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCksXG5cdF9tYXhTaGFkb3dNYXBTaXplID0gbmV3IFZlY3RvcjIoIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICksXG5cblx0X2xvb2tUYXJnZXQgPSBuZXcgVmVjdG9yMygpLFxuXHRfbGlnaHRQb3NpdGlvbldvcmxkID0gbmV3IFZlY3RvcjMoKSxcblxuXHRfcmVuZGVyTGlzdCA9IFtdLFxuXG5cdF9Nb3JwaGluZ0ZsYWcgPSAxLFxuXHRfU2tpbm5pbmdGbGFnID0gMixcblxuXHRfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzID0gKCBfTW9ycGhpbmdGbGFnIHwgX1NraW5uaW5nRmxhZyApICsgMSxcblxuXHRfZGVwdGhNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcblx0X2Rpc3RhbmNlTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXG5cblx0X21hdGVyaWFsQ2FjaGUgPSB7fTtcblxuXHR2YXIgY3ViZURpcmVjdGlvbnMgPSBbXG5cdFx0bmV3IFZlY3RvcjMoIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIC0gMSwgMCwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFxuXHRcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApXG5cdF07XG5cblx0dmFyIGN1YmVVcHMgPSBbXG5cdFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSxcblx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApXG5cdF07XG5cblx0dmFyIGN1YmUyRFZpZXdQb3J0cyA9IFtcblx0XHRuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLFxuXHRcdG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KClcblx0XTtcblxuXHQvLyBpbml0XG5cblx0dmFyIGRlcHRoTWF0ZXJpYWxUZW1wbGF0ZSA9IG5ldyBNZXNoRGVwdGhNYXRlcmlhbCgpO1xuXHRkZXB0aE1hdGVyaWFsVGVtcGxhdGUuZGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZztcblx0ZGVwdGhNYXRlcmlhbFRlbXBsYXRlLmNsaXBwaW5nID0gdHJ1ZTtcblxuXHR2YXIgZGlzdGFuY2VTaGFkZXIgPSBTaGFkZXJMaWJbIFwiZGlzdGFuY2VSR0JBXCIgXTtcblx0dmFyIGRpc3RhbmNlVW5pZm9ybXMgPSBVbmlmb3Jtc1V0aWxzLmNsb25lKCBkaXN0YW5jZVNoYWRlci51bmlmb3JtcyApO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSAhPT0gX051bWJlck9mTWF0ZXJpYWxWYXJpYW50czsgKysgaSApIHtcblxuXHRcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcblx0XHR2YXIgdXNlU2tpbm5pbmcgPSAoIGkgJiBfU2tpbm5pbmdGbGFnICkgIT09IDA7XG5cblx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGRlcHRoTWF0ZXJpYWxUZW1wbGF0ZS5jbG9uZSgpO1xuXHRcdGRlcHRoTWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdXNlTW9ycGhpbmc7XG5cdFx0ZGVwdGhNYXRlcmlhbC5za2lubmluZyA9IHVzZVNraW5uaW5nO1xuXG5cdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xuXG5cdFx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHRcdGRlZmluZXM6IHtcblx0XHRcdFx0J1VTRV9TSEFET1dNQVAnOiAnJ1xuXHRcdFx0fSxcblx0XHRcdHVuaWZvcm1zOiBkaXN0YW5jZVVuaWZvcm1zLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBkaXN0YW5jZVNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZGlzdGFuY2VTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRtb3JwaFRhcmdldHM6IHVzZU1vcnBoaW5nLFxuXHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nLFxuXHRcdFx0Y2xpcHBpbmc6IHRydWVcblx0XHR9ICk7XG5cblx0XHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XG5cblx0fVxuXG5cdC8vXG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy50eXBlID0gUENGU2hhZG93TWFwO1xuXG5cdHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID0gdHJ1ZTtcblx0dGhpcy5yZW5kZXJTaW5nbGVTaWRlZCA9IHRydWU7XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdGlmICggc2NvcGUuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2NvcGUubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aWYgKCBfbGlnaHRTaGFkb3dzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdC8vIFNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwLlxuXHRcdF9zdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAxLCAxLCAxLCAxICk7XG5cdFx0X3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXHRcdF9zdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XG5cblx0XHQvLyByZW5kZXIgZGVwdGggbWFwXG5cblx0XHR2YXIgZmFjZUNvdW50LCBpc1BvaW50TGlnaHQ7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gX2xpZ2h0U2hhZG93cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGxpZ2h0ID0gX2xpZ2h0U2hhZG93c1sgaSBdO1xuXHRcdFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcblxuXHRcdFx0aWYgKCBzaGFkb3cgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRvd01hcDonLCBsaWdodCwgJ2hhcyBubyBzaGFkb3cuJyApO1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2hhZG93Q2FtZXJhID0gc2hhZG93LmNhbWVyYTtcblxuXHRcdFx0X3NoYWRvd01hcFNpemUuY29weSggc2hhZG93Lm1hcFNpemUgKTtcblx0XHRcdF9zaGFkb3dNYXBTaXplLm1pbiggX21heFNoYWRvd01hcFNpemUgKTtcblxuXHRcdFx0aWYgKCBsaWdodCAmJiBsaWdodC5pc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0ZmFjZUNvdW50ID0gNjtcblx0XHRcdFx0aXNQb2ludExpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgdnBXaWR0aCA9IF9zaGFkb3dNYXBTaXplLng7XG5cdFx0XHRcdHZhciB2cEhlaWdodCA9IF9zaGFkb3dNYXBTaXplLnk7XG5cblx0XHRcdFx0Ly8gVGhlc2Ugdmlld3BvcnRzIG1hcCBhIGN1YmUtbWFwIG9udG8gYSAyRCB0ZXh0dXJlIHdpdGggdGhlXG5cdFx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gIHh6WFpcblx0XHRcdFx0Ly8gICB5IFlcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXG5cdFx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0XHQvLyBZIC0gUG9zaXRpdmUgeSBkaXJlY3Rpb25cblx0XHRcdFx0Ly8geSAtIE5lZ2F0aXZlIHkgZGlyZWN0aW9uXG5cdFx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuXHRcdFx0XHQvLyB6IC0gTmVnYXRpdmUgeiBkaXJlY3Rpb25cblxuXHRcdFx0XHQvLyBwb3NpdGl2ZSBYXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMCBdLnNldCggdnBXaWR0aCAqIDIsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXHRcdFx0XHQvLyBuZWdhdGl2ZSBYXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMSBdLnNldCggMCwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG5cdFx0XHRcdC8vIHBvc2l0aXZlIFpcblx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAyIF0uc2V0KCB2cFdpZHRoICogMywgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG5cdFx0XHRcdC8vIG5lZ2F0aXZlIFpcblx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAzIF0uc2V0KCB2cFdpZHRoLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblx0XHRcdFx0Ly8gcG9zaXRpdmUgWVxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDQgXS5zZXQoIHZwV2lkdGggKiAzLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXHRcdFx0XHQvLyBuZWdhdGl2ZSBZXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgNSBdLnNldCggdnBXaWR0aCwgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblxuXHRcdFx0XHRfc2hhZG93TWFwU2l6ZS54ICo9IDQuMDtcblx0XHRcdFx0X3NoYWRvd01hcFNpemUueSAqPSAyLjA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZmFjZUNvdW50ID0gMTtcblx0XHRcdFx0aXNQb2ludExpZ2h0ID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzaGFkb3cubWFwID09PSBudWxsICkge1xuXG5cdFx0XHRcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlciwgZm9ybWF0OiBSR0JBRm9ybWF0IH07XG5cblx0XHRcdFx0c2hhZG93Lm1hcCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSwgcGFycyApO1xuXG5cdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzaGFkb3cuaXNTcG90TGlnaHRTaGFkb3cgKSB7XG5cblx0XHRcdFx0c2hhZG93LnVwZGF0ZSggbGlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uIC8gc2FtLWctc3RlZWwpOiBpcyB0aGlzIG5lZWRlZD9cblx0XHRcdGlmIChzaGFkb3cgJiYgc2hhZG93LmlzUmVjdEFyZWFMaWdodFNoYWRvdyApIHtcblxuXHRcdFx0XHRzaGFkb3cudXBkYXRlKCBsaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzaGFkb3dNYXAgPSBzaGFkb3cubWFwO1xuXHRcdFx0dmFyIHNoYWRvd01hdHJpeCA9IHNoYWRvdy5tYXRyaXg7XG5cblx0XHRcdF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcblxuXHRcdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XG5cdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcblxuXHRcdFx0Ly8gcmVuZGVyIHNoYWRvdyBtYXAgZm9yIGVhY2ggY3ViZSBmYWNlIChpZiBvbW5pLWRpcmVjdGlvbmFsKSBvclxuXHRcdFx0Ly8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XG5cblx0XHRcdGZvciAoIHZhciBmYWNlID0gMDsgZmFjZSA8IGZhY2VDb3VudDsgZmFjZSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRcdF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xuXHRcdFx0XHRcdF9sb29rVGFyZ2V0LmFkZCggY3ViZURpcmVjdGlvbnNbIGZhY2UgXSApO1xuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS51cC5jb3B5KCBjdWJlVXBzWyBmYWNlIF0gKTtcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xuXG5cdFx0XHRcdFx0dmFyIHZwRGltZW5zaW9ucyA9IGN1YmUyRFZpZXdQb3J0c1sgZmFjZSBdO1xuXHRcdFx0XHRcdF9zdGF0ZS52aWV3cG9ydCggdnBEaW1lbnNpb25zICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX2xvb2tUYXJnZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0XHRcdHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XG5cblx0XHRcdFx0c2hhZG93TWF0cml4LnNldChcblx0XHRcdFx0XHQwLjUsIDAuMCwgMC4wLCAwLjUsXG5cdFx0XHRcdFx0MC4wLCAwLjUsIDAuMCwgMC41LFxuXHRcdFx0XHRcdDAuMCwgMC4wLCAwLjUsIDAuNSxcblx0XHRcdFx0XHQwLjAsIDAuMCwgMC4wLCAxLjBcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuXHRcdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcblxuXHRcdFx0XHRfcmVuZGVyTGlzdC5sZW5ndGggPSAwO1xuXG5cdFx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSApO1xuXG5cdFx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwXG5cdFx0XHRcdC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gX3JlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gX3JlbmRlckxpc3RbIGogXTtcblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgJiYgbWF0ZXJpYWwuaXNNdWx0aU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGsgXTtcblx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBncm91cE1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcblx0XHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXHRcdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBudWxsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBSZXN0b3JlIEdMIHN0YXRlLlxuXHRcdHZhciBjbGVhckNvbG9yID0gX3JlbmRlcmVyLmdldENsZWFyQ29sb3IoKSxcblx0XHRjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcblx0XHRfcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xuXG5cdFx0c2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgbGlnaHRQb3NpdGlvbldvcmxkICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cblx0XHR2YXIgbWF0ZXJpYWxWYXJpYW50cyA9IF9kZXB0aE1hdGVyaWFscztcblx0XHR2YXIgY3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuXHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xuXG5cdFx0XHRtYXRlcmlhbFZhcmlhbnRzID0gX2Rpc3RhbmNlTWF0ZXJpYWxzO1xuXHRcdFx0Y3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdGlmICggISBjdXN0b21NYXRlcmlhbCApIHtcblxuXHRcdFx0dmFyIHVzZU1vcnBoaW5nID0gZmFsc2U7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoID4gMDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0dXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB1c2VTa2lubmluZyA9IG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xuXG5cdFx0XHR2YXIgdmFyaWFudEluZGV4ID0gMDtcblxuXHRcdFx0aWYgKCB1c2VNb3JwaGluZyApIHZhcmlhbnRJbmRleCB8PSBfTW9ycGhpbmdGbGFnO1xuXHRcdFx0aWYgKCB1c2VTa2lubmluZyApIHZhcmlhbnRJbmRleCB8PSBfU2tpbm5pbmdGbGFnO1xuXG5cdFx0XHRyZXN1bHQgPSBtYXRlcmlhbFZhcmlhbnRzWyB2YXJpYW50SW5kZXggXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlc3VsdCA9IGN1c3RvbU1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBfcmVuZGVyZXIubG9jYWxDbGlwcGluZ0VuYWJsZWQgJiZcblx0XHRcdCBtYXRlcmlhbC5jbGlwU2hhZG93cyA9PT0gdHJ1ZSAmJlxuXHRcdFx0XHRtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcy5sZW5ndGggIT09IDAgKSB7XG5cblx0XHRcdC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIGEgdW5pcXVlIG1hdGVyaWFsIGluc3RhbmNlIHJlZmxlY3RpbmcgdGhlXG5cdFx0XHQvLyBhcHByb3ByaWF0ZSBzdGF0ZVxuXG5cdFx0XHR2YXIga2V5QSA9IHJlc3VsdC51dWlkLCBrZXlCID0gbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0dmFyIG1hdGVyaWFsc0ZvclZhcmlhbnQgPSBfbWF0ZXJpYWxDYWNoZVsga2V5QSBdO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsc0ZvclZhcmlhbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XG5cdFx0XHRcdF9tYXRlcmlhbENhY2hlWyBrZXlBIF0gPSBtYXRlcmlhbHNGb3JWYXJpYW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXTtcblxuXHRcdFx0aWYgKCBjYWNoZWRNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gcmVzdWx0LmNsb25lKCk7XG5cdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXSA9IGNhY2hlZE1hdGVyaWFsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdCA9IGNhY2hlZE1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0cmVzdWx0LnZpc2libGUgPSBtYXRlcmlhbC52aXNpYmxlO1xuXHRcdHJlc3VsdC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XG5cblx0XHR2YXIgc2lkZSA9IG1hdGVyaWFsLnNpZGU7XG5cblx0XHRpZiAoIHNjb3BlLnJlbmRlclNpbmdsZVNpZGVkICYmIHNpZGUgPT0gRG91YmxlU2lkZSApIHtcblxuXHRcdFx0c2lkZSA9IEZyb250U2lkZTtcblxuXHRcdH1cblxuXHRcdGlmICggc2NvcGUucmVuZGVyUmV2ZXJzZVNpZGVkICkge1xuXG5cdFx0XHRpZiAoIHNpZGUgPT09IEZyb250U2lkZSApIHNpZGUgPSBCYWNrU2lkZTtcblx0XHRcdGVsc2UgaWYgKCBzaWRlID09PSBCYWNrU2lkZSApIHNpZGUgPSBGcm9udFNpZGU7XG5cblx0XHR9XG5cblx0XHRyZXN1bHQuc2lkZSA9IHNpZGU7XG5cblx0XHRyZXN1bHQuY2xpcFNoYWRvd3MgPSBtYXRlcmlhbC5jbGlwU2hhZG93cztcblx0XHRyZXN1bHQuY2xpcHBpbmdQbGFuZXMgPSBtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcztcblxuXHRcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0cmVzdWx0LmxpbmV3aWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblxuXHRcdGlmICggaXNQb2ludExpZ2h0ICYmIHJlc3VsdC51bmlmb3Jtcy5saWdodFBvcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXN1bHQudW5pZm9ybXMubGlnaHRQb3MudmFsdWUuY29weSggbGlnaHRQb3NpdGlvbldvcmxkICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR2YXIgdmlzaWJsZSA9ICggb2JqZWN0LmxheWVycy5tYXNrICYgY2FtZXJhLmxheWVycy5tYXNrICkgIT09IDA7XG5cblx0XHRpZiAoIHZpc2libGUgJiYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSApIHtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRfcmVuZGVyTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgc2hhZG93Q2FtZXJhICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICovXG5cbmZ1bmN0aW9uIFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVmVjdG9yMygpO1xuXHR0aGlzLmRpcmVjdGlvbiA9ICggZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgKSA/IGRpcmVjdGlvbiA6IG5ldyBWZWN0b3IzKCk7XG5cbn1cblxuUmF5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogUmF5LFxuXG5cdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCByYXkgKSB7XG5cblx0XHR0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdH0sXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCB2ICkuc3ViKCB0aGlzLm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVjYXN0KCB0ICkge1xuXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG5cdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRcdC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XG5cblx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuXHRcdFx0cmV0dXJuIHYxLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0ZGlzdGFuY2VTcVRvU2VnbWVudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHNlZ0NlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHNlZ0RpciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIGRpZmYgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlU3FUb1NlZ21lbnQoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlRGlzdFJheVNlZ21lbnQuaFxuXHRcdFx0Ly8gSXQgcmV0dXJucyB0aGUgbWluIGRpc3RhbmNlIGJldHdlZW4gdGhlIHJheSBhbmQgdGhlIHNlZ21lbnRcblx0XHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG5cdFx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxuXHRcdFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcmF5XG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cblx0XHRcdHNlZ0NlbnRlci5jb3B5KCB2MCApLmFkZCggdjEgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cdFx0XHRzZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XG5cdFx0XHRkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcblxuXHRcdFx0dmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XG5cdFx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xuXHRcdFx0dmFyIGIwID0gZGlmZi5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cdFx0XHR2YXIgYjEgPSAtIGRpZmYuZG90KCBzZWdEaXIgKTtcblx0XHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xuXHRcdFx0dmFyIGRldCA9IE1hdGguYWJzKCAxIC0gYTAxICogYTAxICk7XG5cdFx0XHR2YXIgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XG5cblx0XHRcdGlmICggZGV0ID4gMCApIHtcblxuXHRcdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXG5cblx0XHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xuXHRcdFx0XHRzMSA9IGEwMSAqIGIwIC0gYjE7XG5cdFx0XHRcdGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcblxuXHRcdFx0XHRpZiAoIHMwID49IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHMxID49IC0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHMxIDw9IGV4dERldCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuXHRcdFx0XHRcdFx0XHQvLyBNaW5pbXVtIGF0IGludGVyaW9yIHBvaW50cyBvZiByYXkgYW5kIHNlZ21lbnQuXG5cblx0XHRcdFx0XHRcdFx0dmFyIGludkRldCA9IDEgLyBkZXQ7XG5cdFx0XHRcdFx0XHRcdHMwICo9IGludkRldDtcblx0XHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAxXG5cblx0XHRcdFx0XHRcdFx0czEgPSBzZWdFeHRlbnQ7XG5cdFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDVcblxuXHRcdFx0XHRcdFx0czEgPSAtIHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA0XG5cblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAzXG5cblx0XHRcdFx0XHRcdHMwID0gMDtcblx0XHRcdFx0XHRcdHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMlxuXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXG5cblx0XHRcdFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xuXHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG5cdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XG5cblx0XHRcdFx0b3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHMwICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuXHRcdFx0XHRvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoIHNlZ0RpciApLm11bHRpcGx5U2NhbGFyKCBzMSApLmFkZCggc2VnQ2VudGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNxckRpc3Q7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3RTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0U3BoZXJlKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuXHRcdFx0dmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblx0XHRcdHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcblx0XHRcdHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRcdGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG5cdFx0XHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuXHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xuXG5cdFx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG5cdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XG5cblx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuXHRcdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuXHRcdFx0aWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHRcdC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXG5cdFx0XHRyZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXM7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cblx0XHQvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxuXG5cdFx0cmV0dXJuIHQgPj0gMCA/IHQgOiAgbnVsbDtcblxuXHR9LFxuXG5cdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XG5cblx0XHRpZiAoIHQgPT09IG51bGwgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fSxcblxuXG5cblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG5cdFx0dmFyIGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uICggYm94LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblxuXHRcdHZhciBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXG5cdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG5cdFx0XHRpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XG5cblx0XHR2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cblx0XHRpZiAoIGludmRpcnggPj0gMCApIHtcblxuXHRcdFx0dG1pbiA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cdFx0XHR0bWF4ID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cblx0XHR9XG5cblx0XHRpZiAoIGludmRpcnkgPj0gMCApIHtcblxuXHRcdFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cblx0XHQvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXG5cblx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xuXG5cdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcblxuXHRcdGlmICggaW52ZGlyeiA+PSAwICkge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG5cdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuXHRcdGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XG5cblx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cblx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RzQm94OiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XG5cblx0XHR9O1xuXG5cdH0gKSgpLFxuXG5cdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cblx0XHR2YXIgZGlmZiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIGVkZ2UxID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgZWRnZTIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlSW50clJheTNUcmlhbmdsZTMuaFxuXG5cdFx0XHRlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0XHRub3JtYWwuY3Jvc3NWZWN0b3JzKCBlZGdlMSwgZWRnZTIgKTtcblxuXHRcdFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXG5cdFx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcblx0XHRcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxuXHRcdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcblx0XHRcdHZhciBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIG5vcm1hbCApO1xuXHRcdFx0dmFyIHNpZ247XG5cblx0XHRcdGlmICggRGROID4gMCApIHtcblxuXHRcdFx0XHRpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xuXHRcdFx0XHRzaWduID0gMTtcblxuXHRcdFx0fSBlbHNlIGlmICggRGROIDwgMCApIHtcblxuXHRcdFx0XHRzaWduID0gLSAxO1xuXHRcdFx0XHREZE4gPSAtIERkTjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG5cdFx0XHR2YXIgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTIuY3Jvc3NWZWN0b3JzKCBkaWZmLCBlZGdlMiApICk7XG5cblx0XHRcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRpZiAoIERkUXhFMiA8IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcblxuXHRcdFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggRGRFMXhRIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cblx0XHRcdHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XG5cblx0XHRcdC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggUWROIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cblx0XHRcdHJldHVybiB0aGlzLmF0KCBRZE4gLyBEZE4sIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcblxuXHRcdHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcblx0XHR0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5zdWIoIHRoaXMub3JpZ2luICk7XG5cdFx0dGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XG5cblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5mdW5jdGlvbiBFdWxlciggeCwgeSwgeiwgb3JkZXIgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCBFdWxlci5EZWZhdWx0T3JkZXI7XG5cbn1cblxuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cbkV1bGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogRXVsZXIsXG5cblx0aXNFdWxlcjogdHJ1ZSxcblxuXHRnZXQgeCAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9LFxuXG5cdHNldCB4ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeSAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9LFxuXG5cdHNldCB5ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9LFxuXG5cdHNldCB6ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgb3JkZXIgKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xuXG5cdH0sXG5cblx0c2V0IG9yZGVyICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcblx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0dmFyIGNsYW1wID0gX01hdGguY2xhbXA7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dmFyIHRlID0gbS5lbGVtZW50cztcblx0XHR2YXIgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcblx0XHR2YXIgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcblx0XHR2YXIgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cblx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG5cdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3kgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xuXG5cdH0sXG5cblx0cmVvcmRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0dmFyIHEgPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlb3JkZXIoIG5ld09yZGVyICkge1xuXG5cdFx0XHRxLnNldEZyb21FdWxlciggdGhpcyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdHRvVmVjdG9yMzogZnVuY3Rpb24gKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cblx0XHRcdHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBuZXcgVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIExheWVycygpIHtcblxuXHR0aGlzLm1hc2sgPSAxO1xuXG59XG5cbkxheWVycy5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IExheWVycyxcblxuXHRzZXQ6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbDtcblxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbDtcblxuXHR9LFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbDtcblxuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsICk7XG5cblx0fSxcblxuXHR0ZXN0OiBmdW5jdGlvbiAoIGxheWVycyApIHtcblxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxuICovXG5cbnZhciBvYmplY3QzRElkID0gMDtcblxuZnVuY3Rpb24gT2JqZWN0M0QoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBvYmplY3QzRElkICsrIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLm5hbWUgPSAnJztcblx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuXHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuXHR0aGlzLnVwID0gT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XG5cblx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcblxuXHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xuXG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cblx0XHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xuXG5cdH1cblxuXHRyb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xuXHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0fSxcblx0XHRyb3RhdGlvbjoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdH0sXG5cdFx0cXVhdGVybmlvbjoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXG5cdFx0fSxcblx0XHRzY2FsZToge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdH0sXG5cdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdH0sXG5cdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XG5cdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuXHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHR0aGlzLnVzZXJEYXRhID0ge307XG5cblx0dGhpcy5vbkJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXHR0aGlzLm9uQWZ0ZXJSZW5kZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxufVxuXG5PYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5PYmplY3QzRC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IE9iamVjdDNELFxuXG5cdGlzT2JqZWN0M0Q6IHRydWUsXG5cblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0dGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuXHR9LFxuXG5cdHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHR9LFxuXG5cdHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcblxuXHR9LFxuXG5cdHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcblxuXHR9LFxuXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXG5cblx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggcSApO1xuXG5cdH0sXG5cblx0cm90YXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25BeGlzKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSB7XG5cblx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWiggZGlzdGFuY2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHR9LFxuXG5cdHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIG0xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcblxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRcdG0xLmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2FkZGVkJyB9ICk7XG5cblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcblxuXHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XG5cblx0fSxcblxuXHRnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcblx0XHRcdHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fSxcblxuXHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0sXG5cblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRRdWF0ZXJuaW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRSb3RhdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgRXVsZXIoKTtcblxuXHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkU2NhbGUoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHJlc3VsdCApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZERpcmVjdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cmF5Y2FzdDogZnVuY3Rpb24gKCkge30sXG5cblx0dHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y2FsbGJhY2soIHBhcmVudCApO1xuXG5cdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9LFxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdGZvcmNlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdC8vIG1ldGEgaXMgJycgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxuXHRcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhID09PSAnJyApO1xuXG5cdFx0dmFyIG91dHB1dCA9IHt9O1xuXG5cdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cblx0XHQvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcblx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdGdlb21ldHJpZXM6IHt9LFxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdGltYWdlczoge31cblx0XHRcdH07XG5cblx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcblx0XHRcdFx0dmVyc2lvbjogNC40LFxuXHRcdFx0XHR0eXBlOiAnT2JqZWN0Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuXHRcdHZhciBvYmplY3QgPSB7fTtcblxuXHRcdG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xuXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCBtZXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdG9iamVjdC5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRvYmplY3QuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJpZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmdlb21ldHJpZXMgKTtcblx0XHRcdHZhciBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xuXHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0dmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXG5cdFx0fVxuXG5cdFx0b3V0cHV0Lm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuXHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cblx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggcmVjdXJzaXZlICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXG5cdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbk9iamVjdC5hc3NpZ24oIE9iamVjdDNELnByb3RvdHlwZSwgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApO1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5mdW5jdGlvbiBMaW5lMyggc3RhcnQsIGVuZCApIHtcblxuXHR0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBWZWN0b3IzKCk7XG5cdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFZlY3RvcjMoKTtcblxufVxuXG5MaW5lMy5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IExpbmUzLFxuXG5cdHNldDogZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xuXHRcdHRoaXMuZW5kLmNvcHkoIGVuZCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9LFxuXG5cdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcblxuXHR9LFxuXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHR9LFxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBzdGFydFAgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBzdGFydEVuZCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICkge1xuXG5cdFx0XHRzdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcblx0XHRcdHN0YXJ0RW5kLnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cblx0XHRcdHZhciBzdGFydEVuZDIgPSBzdGFydEVuZC5kb3QoIHN0YXJ0RW5kICk7XG5cdFx0XHR2YXIgc3RhcnRFbmRfc3RhcnRQID0gc3RhcnRFbmQuZG90KCBzdGFydFAgKTtcblxuXHRcdFx0dmFyIHQgPSBzdGFydEVuZF9zdGFydFAgLyBzdGFydEVuZDI7XG5cblx0XHRcdGlmICggY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRcdFx0dCA9IF9NYXRoLmNsYW1wKCB0LCAwLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHQ7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG5cdH0sXG5cblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblx0XHR0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggbGluZSApIHtcblxuXHRcdHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcblxuXHR9XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBUcmlhbmdsZSggYSwgYiwgYyApIHtcblxuXHR0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBWZWN0b3IzKCk7XG5cdHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFZlY3RvcjMoKTtcblx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVmVjdG9yMygpO1xuXG59XG5cblRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiBub3JtYWwoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHRyZXN1bHQuY3Jvc3MoIHYwICk7XG5cblx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcblx0XHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4vLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0djAuc3ViVmVjdG9ycyggYywgYSApO1xuXHRcdHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHR2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xuXG5cdFx0dmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xuXHRcdHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcblx0XHR2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XG5cdFx0dmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xuXHRcdHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuXHRcdHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cdFx0aWYgKCBkZW5vbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XG5cdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xuXHRcdHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG5cdFx0dmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcblxuXHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG5cdH07XG5cbn0oKTtcblxuVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiBjb250YWluc1BvaW50KCBwb2ludCwgYSwgYiwgYyApIHtcblxuXHRcdHZhciByZXN1bHQgPSBUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xuXG5cdFx0cmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xuXG5cdH07XG5cbn0oKTtcblxuVHJpYW5nbGUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUcmlhbmdsZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcblx0XHR0aGlzLmMuY29weSggYyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cblx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG5cdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXJlYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFyZWEoKSB7XG5cblx0XHRcdHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XG5cdFx0XHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xuXG5cdFx0XHRyZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG5cdH0sXG5cblx0bm9ybWFsOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9LFxuXG5cdHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBQbGFuZSgpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9LFxuXG5cdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9LFxuXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9LFxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwbGFuZSwgZWRnZUxpc3QsIHByb2plY3RlZFBvaW50LCBjbG9zZXN0UG9pbnQ7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRpZiAoIHBsYW5lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGxhbmUgPSBuZXcgUGxhbmUoKTtcblx0XHRcdFx0ZWRnZUxpc3QgPSBbIG5ldyBMaW5lMygpLCBuZXcgTGluZTMoKSwgbmV3IExpbmUzKCkgXTtcblx0XHRcdFx0cHJvamVjdGVkUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG5cblx0XHRcdC8vIHByb2plY3QgdGhlIHBvaW50IG9udG8gdGhlIHBsYW5lIG9mIHRoZSB0cmlhbmdsZVxuXG5cdFx0XHRwbGFuZS5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblx0XHRcdHBsYW5lLnByb2plY3RQb2ludCggcG9pbnQsIHByb2plY3RlZFBvaW50ICk7XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZSBwcm9qZWN0aW9uIGxpZXMgd2l0aGluIHRoZSB0cmlhbmdsZVxuXG5cdFx0XHRpZiggdGhpcy5jb250YWluc1BvaW50KCBwcm9qZWN0ZWRQb2ludCApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIGlmIHNvLCB0aGlzIGlzIHRoZSBjbG9zZXN0IHBvaW50XG5cblx0XHRcdFx0cmVzdWx0LmNvcHkoIHByb2plY3RlZFBvaW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gaWYgbm90LCB0aGUgcG9pbnQgZmFsbHMgb3V0c2lkZSB0aGUgdHJpYW5nbGUuIHRoZSByZXN1bHQgaXMgdGhlIGNsb3Nlc3QgcG9pbnQgdG8gdGhlIHRyaWFuZ2xlJ3MgZWRnZXMgb3IgdmVydGljZXNcblxuXHRcdFx0XHRlZGdlTGlzdFsgMCBdLnNldCggdGhpcy5hLCB0aGlzLmIgKTtcblx0XHRcdFx0ZWRnZUxpc3RbIDEgXS5zZXQoIHRoaXMuYiwgdGhpcy5jICk7XG5cdFx0XHRcdGVkZ2VMaXN0WyAyIF0uc2V0KCB0aGlzLmMsIHRoaXMuYSApO1xuXG5cdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZUxpc3QubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZWRnZUxpc3RbIGkgXS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwcm9qZWN0ZWRQb2ludCwgdHJ1ZSwgY2xvc2VzdFBvaW50ICk7XG5cblx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBwcm9qZWN0ZWRQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggY2xvc2VzdFBvaW50ICk7XG5cblx0XHRcdFx0XHRpZiggZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuXHRcdFx0XHRcdFx0cmVzdWx0LmNvcHkoIGNsb3Nlc3RQb2ludCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHR0aGlzLmEgPSBhO1xuXHR0aGlzLmIgPSBiO1xuXHR0aGlzLmMgPSBjO1xuXG5cdHRoaXMubm9ybWFsID0gKG5vcm1hbCAmJiBub3JtYWwuaXNWZWN0b3IzKSA/IG5vcm1hbCA6IG5ldyBWZWN0b3IzKCk7XG5cdHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XG5cblx0dGhpcy5jb2xvciA9IChjb2xvciAmJiBjb2xvci5pc0NvbG9yKSA/IGNvbG9yIDogbmV3IENvbG9yKCk7XG5cdHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XG5cblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cbn1cblxuRmFjZTMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBGYWNlMyxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmEgPSBzb3VyY2UuYTtcblx0XHR0aGlzLmIgPSBzb3VyY2UuYjtcblx0XHR0aGlzLmMgPSBzb3VyY2UuYztcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHNvdXJjZS5ub3JtYWwgKTtcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdID0gc291cmNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudmVydGV4Q29sb3JzWyBpIF0gPSBzb3VyY2UudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPlxuICogfVxuICovXG5cbmZ1bmN0aW9uIE1lc2hCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXG5cblx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdHRoaXMuYW9NYXAgPSBudWxsO1xuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdHRoaXMuZW52TWFwID0gbnVsbDtcblx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufVxuXG5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcbk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hCYXNpY01hdGVyaWFsO1xuXG5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoQmFzaWNNYXRlcmlhbCA9IHRydWU7XG5cbk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cblx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xuXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xuXG5cdH1cblxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZSA6IDA7XG5cdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XG5cblx0dGhpcy5keW5hbWljID0gZmFsc2U7XG5cdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXG5cdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cbn1cblxuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogQnVmZmVyQXR0cmlidXRlLFxuXG5cdGlzQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH0sXG5cblx0c2V0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZSA6IDA7XG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXG5cdH0sXG5cblx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cblx0XHR0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcblxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNvbG9yID0gY29sb3JzWyBpIF07XG5cblx0XHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0Y29sb3IgPSBuZXcgQ29sb3IoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuZztcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcblxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmI7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5VmVjdG9yMnNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5VmVjdG9yM3NBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG5cdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3Iuejtcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xuXG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xuXG5cdH0sXG5cblx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG9uVXBsb2FkOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUgKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59O1xuXG4vL1xuXG5mdW5jdGlvbiBJbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn1cblxuSW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5JbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XG5cblxuZnVuY3Rpb24gVWludDhCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn1cblxuVWludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuVWludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDhCdWZmZXJBdHRyaWJ1dGU7XG5cblxuZnVuY3Rpb24gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufVxuXG5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZTtcblxuXG5mdW5jdGlvbiBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufVxuXG5JbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5JbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcblxuXG5mdW5jdGlvbiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59XG5cblVpbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5VaW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDE2QnVmZmVyQXR0cmlidXRlO1xuXG5cbmZ1bmN0aW9uIEludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59XG5cbkludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcbkludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDMyQnVmZmVyQXR0cmlidXRlO1xuXG5cbmZ1bmN0aW9uIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn1cblxuVWludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcblVpbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50MzJCdWZmZXJBdHRyaWJ1dGU7XG5cblxuZnVuY3Rpb24gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59XG5cbkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9hdDMyQnVmZmVyQXR0cmlidXRlO1xuXG5cbmZ1bmN0aW9uIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufVxuXG5GbG9hdDY0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcbkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIERpcmVjdEdlb21ldHJ5KCkge1xuXG5cdHRoaXMuaW5kaWNlcyA9IFtdO1xuXHR0aGlzLnZlcnRpY2VzID0gW107XG5cdHRoaXMubm9ybWFscyA9IFtdO1xuXHR0aGlzLmNvbG9ycyA9IFtdO1xuXHR0aGlzLnV2cyA9IFtdO1xuXHR0aGlzLnV2czIgPSBbXTtcblxuXHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdHRoaXMubW9ycGhUYXJnZXRzID0ge307XG5cblx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xuXHR0aGlzLnNraW5JbmRpY2VzID0gW107XG5cblx0Ly8gdGhpcy5saW5lRGlzdGFuY2VzID0gW107XG5cblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdC8vIHVwZGF0ZSBmbGFnc1xuXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBEaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUsIHtcblxuXHRjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0dmFyIGdyb3VwO1xuXHRcdHZhciBncm91cHMgPSBbXTtcblx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IHVuZGVmaW5lZDtcblxuXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdC8vIG1hdGVyaWFsc1xuXG5cdFx0XHRpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdyb3VwID0ge1xuXHRcdFx0XHRcdHN0YXJ0OiBpICogMyxcblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcblx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ncm91cHMgPSBncm91cHM7XG5cblx0fSxcblxuXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XG5cblx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xuXHRcdHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xuXG5cdFx0Ly8gbW9ycGhzXG5cblx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXHRcdHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xuXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG5cdFx0aWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xuXG5cdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvbiA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLnBvc2l0aW9uID0gbW9ycGhUYXJnZXRzUG9zaXRpb247XG5cblx0XHR9XG5cblx0XHR2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xuXHRcdHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xuXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c05vcm1hbDtcblxuXHRcdGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcblxuXHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcblxuXHRcdH1cblxuXHRcdC8vIHNraW5zXG5cblx0XHR2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcblx0XHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcblxuXHRcdHZhciBoYXNTa2luSW5kaWNlcyA9IHNraW5JbmRpY2VzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuXHRcdHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0Ly9cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cblx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcblxuXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xuXG5cdFx0XHRcdFx0dGhpcy51dnMucHVzaCggbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xuXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XG5cblx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBtb3JwaHNcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0ucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XG5cblx0XHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsWyBqIF0ucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNraW5zXG5cblx0XHRcdGlmICggaGFzU2tpbkluZGljZXMgKSB7XG5cblx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTa2luV2VpZ2h0cyApIHtcblxuXHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xuXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XG5cdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY2OTE5MC9qYXZhc2NyaXB0LW1pbi1tYXgtYXJyYXktdmFsdWVzLzEzNDQwODQyIzEzNDQwODQyXG5cbmZ1bmN0aW9uIGFycmF5TWF4KCBhcnJheSApIHtcblxuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBtYXggPSAtIEluZmluaXR5O1xuXG5cdHdoaWxlICggbGVuZ3RoIC0tICkge1xuXG5cdFx0aWYgKCBhcnJheVsgbGVuZ3RoIF0gPiBtYXggKSB7XG5cblx0XHRcdG1heCA9IGFycmF5WyBsZW5ndGggXTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIG1heDtcblxufVxuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG52YXIgY291bnQgPSAwO1xuZnVuY3Rpb24gR2VvbWV0cnlJZENvdW50KCkgeyByZXR1cm4gY291bnQrKzsgfVxuXG5mdW5jdGlvbiBHZW9tZXRyeSgpIHtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IEdlb21ldHJ5SWRDb3VudCgpIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLm5hbWUgPSAnJztcblx0dGhpcy50eXBlID0gJ0dlb21ldHJ5JztcblxuXHR0aGlzLnZlcnRpY2VzID0gW107XG5cdHRoaXMuY29sb3JzID0gW107XG5cdHRoaXMuZmFjZXMgPSBbXTtcblx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcblxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xuXHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xuXG5cdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcblx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG5cdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHQvLyB1cGRhdGUgZmxhZ3NcblxuXHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxufVxuXG5HZW9tZXRyeS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IEdlb21ldHJ5LFxuXG5cdGlzR2VvbWV0cnk6IHRydWUsXG5cblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0dmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuXHRcdHZhciBtMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cblx0XHR2YXIgbTE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG5cdFx0dmFyIG0xO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdHZhciBtMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cblx0XHR2YXIgbTE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb2JqO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG5cdFx0XHRpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xuXG5cdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIHV2czIgPSBhdHRyaWJ1dGVzLnV2MiAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51djIuYXJyYXkgOiB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gW107XG5cblx0XHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcblx0XHR2YXIgdGVtcFVWcyA9IFtdO1xuXHRcdHZhciB0ZW1wVVZzMiA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMywgaiArPSAyICkge1xuXG5cdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICkgKTtcblxuXHRcdFx0aWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGVtcE5vcm1hbHMucHVzaCggbmV3IFZlY3RvcjMoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5jb2xvcnMucHVzaCggbmV3IENvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGVtcFVWcy5wdXNoKCBuZXcgVmVjdG9yMiggdXZzWyBqIF0sIHV2c1sgaiArIDEgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGVtcFVWczIucHVzaCggbmV3IFZlY3RvcjIoIHV2czJbIGogXSwgdXZzMlsgaiArIDEgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEZhY2UoIGEsIGIsIGMsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcblx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cblx0XHRcdHZhciBmYWNlID0gbmV3IEZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMsIG1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGogXSwgaW5kaWNlc1sgaiArIDEgXSwgaW5kaWNlc1sgaiArIDIgXSwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0YWRkRmFjZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdLCBpbmRpY2VzWyBpICsgMiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xuXG5cdFx0XHRcdGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XG5cblx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG5cdFx0cmV0dXJuIG9mZnNldDtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblx0XHR2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG5cblx0XHR2YXIgcyA9IHJhZGl1cyA9PT0gMCA/IDEgOiAxLjAgLyByYWRpdXM7XG5cblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRtYXRyaXguc2V0KFxuXHRcdFx0cywgMCwgMCwgLSBzICogY2VudGVyLngsXG5cdFx0XHQwLCBzLCAwLCAtIHMgKiBjZW50ZXIueSxcblx0XHRcdDAsIDAsIHMsIC0gcyAqIGNlbnRlci56LFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4KCBtYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0dmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRjYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoIGFyZWFXZWlnaHRlZCApIHtcblxuXHRcdGlmICggYXJlYVdlaWdodGVkID09PSB1bmRlZmluZWQgKSBhcmVhV2VpZ2h0ZWQgPSB0cnVlO1xuXG5cdFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XG5cblx0XHR2ZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcblxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHZlcnRpY2VzWyB2IF0gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cblx0XHRcdC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXG5cdFx0XHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXG5cblx0XHRcdHZhciB2QSwgdkIsIHZDO1xuXHRcdFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0dkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0dkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcblx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG5cdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGNiICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggdmVydGljZXNbIGZhY2UuYiBdICk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdID0gdmVydGljZXNbIGZhY2UuYiBdLmNsb25lKCk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZmFjZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlRmxhdFZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmLCBmbCwgZmFjZTtcblxuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggZmFjZS5ub3JtYWwgKTtcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5mYWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XG5cblx0XHQvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcblx0XHQvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3Ncblx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcblxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xuXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXG5cblx0XHR2YXIgdG1wR2VvID0gbmV3IEdlb21ldHJ5KCk7XG5cdFx0dG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXG5cblx0XHRcdGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcblxuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFZlY3RvcjMoKSwgYjogbmV3IFZlY3RvcjMoKSwgYzogbmV3IFZlY3RvcjMoKSB9O1xuXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xuXHRcdFx0XHRcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcblxuXHRcdFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxuXG5cdFx0XHR0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG5cdFx0XHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcblxuXHRcdFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXHRcdFx0dG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcblxuXHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHRmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xuXG5cdFx0XHRcdGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcblx0XHRcdFx0dmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcblxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGQgPSAwO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaSA+IDAgKSB7XG5cblx0XHRcdFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cblx0fSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdGlmICggKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgbm9ybWFsTWF0cml4LFxuXHRcdHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuXHRcdHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXG5cdFx0dmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXG5cdFx0ZmFjZXMxID0gdGhpcy5mYWNlcyxcblx0XHRmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcblx0XHR1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXG5cdFx0dXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXSxcblx0XHRjb2xvcnMxID0gdGhpcy5jb2xvcnMsXG5cdFx0Y29sb3JzMiA9IGdlb21ldHJ5LmNvbG9ycztcblxuXHRcdGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XG5cblx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHQvLyB2ZXJ0aWNlc1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xuXG5cdFx0XHR2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xuXG5cdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHR2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29sb3JzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29sb3JzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29sb3JzMS5wdXNoKCBjb2xvcnMyWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZmFjZXNcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXG5cdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcblx0XHRcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuXHRcdFx0ZmFjZUNvcHkgPSBuZXcgRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcblx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XG5cblx0XHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZhY2VDb3B5LmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0Y29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZUNvcHkubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleCArIG1hdGVyaWFsSW5kZXhPZmZzZXQ7XG5cblx0XHRcdGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXZzXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xuXG5cdFx0XHRpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1dnMxLnB1c2goIHV2Q29weSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0bWVyZ2VNZXNoOiBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cblx0XHRpZiAoICggbWVzaCAmJiBtZXNoLmlzTWVzaCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdG1lc2gubWF0cml4QXV0b1VwZGF0ZSAmJiBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcblxuXHR9LFxuXG5cdC8qXG5cdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cblx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuXHQgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxuXHQgKi9cblxuXHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcblx0XHR2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcblxuXHRcdHZhciB2LCBrZXk7XG5cdFx0dmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuXHRcdHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xuXHRcdHZhciBpLCBpbCwgZmFjZTtcblx0XHR2YXIgaW5kaWNlcywgaiwgamw7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xuXG5cdFx0XHRpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XG5cdFx0XHRcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0Ly8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxuXHRcdC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXG5cdFx0dmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cblx0XHRcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xuXHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XG5cdFx0XHRmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0aW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xuXG5cdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXG5cdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxuXHRcdFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcblxuXHRcdFx0XHRpZiAoIGluZGljZXNbIG4gXSA9PT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xuXG5cdFx0XHRcdFx0ZmFjZUluZGljZXNUb1JlbW92ZS5wdXNoKCBpICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XG5cblx0XHRcdHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XG5cblx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXG5cblx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcblx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xuXHRcdHJldHVybiBkaWZmO1xuXG5cdH0sXG5cblx0c29ydEZhY2VzQnlNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuXHRcdHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XG5cblx0XHQvLyB0YWcgZmFjZXNcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZXNbIGkgXS5faWQgPSBpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc29ydCBmYWNlc1xuXG5cdFx0ZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBhLm1hdGVyaWFsSW5kZXggLSBiLm1hdGVyaWFsSW5kZXg7XG5cblx0XHR9XG5cblx0XHRmYWNlcy5zb3J0KCBtYXRlcmlhbEluZGV4U29ydCApO1xuXG5cdFx0Ly8gc29ydCB1dnNcblxuXHRcdHZhciB1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XG5cdFx0dmFyIHV2czIgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXTtcblxuXHRcdHZhciBuZXdVdnMxLCBuZXdVdnMyO1xuXG5cdFx0aWYgKCB1dnMxICYmIHV2czEubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMxID0gW107XG5cdFx0aWYgKCB1dnMyICYmIHV2czIubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMyID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBpZCA9IGZhY2VzWyBpIF0uX2lkO1xuXG5cdFx0XHRpZiAoIG5ld1V2czEgKSBuZXdVdnMxLnB1c2goIHV2czFbIGlkIF0gKTtcblx0XHRcdGlmICggbmV3VXZzMiApIG5ld1V2czIucHVzaCggdXZzMlsgaWQgXSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdVdnMxICkgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0gPSBuZXdVdnMxO1xuXHRcdGlmICggbmV3VXZzMiApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gbmV3VXZzMjtcblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0dlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZhY2VzID0gW107XG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHR2YXIgbm9ybWFsc0hhc2ggPSB7fTtcblx0XHR2YXIgY29sb3JzID0gW107XG5cdFx0dmFyIGNvbG9yc0hhc2ggPSB7fTtcblx0XHR2YXIgdXZzID0gW107XG5cdFx0dmFyIHV2c0hhc2ggPSB7fTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuXHRcdFx0dmFyIGhhc01hdGVyaWFsID0gdHJ1ZTtcblx0XHRcdHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF0gIT09IHVuZGVmaW5lZDtcblx0XHRcdHZhciBoYXNGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwubGVuZ3RoKCkgPiAwO1xuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcblx0XHRcdHZhciBoYXNGYWNlQ29sb3IgPSBmYWNlLmNvbG9yLnIgIT09IDEgfHwgZmFjZS5jb2xvci5nICE9PSAxIHx8IGZhY2UuY29sb3IuYiAhPT0gMTtcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4Q29sb3IgPSBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwO1xuXG5cdFx0XHR2YXIgZmFjZVR5cGUgPSAwO1xuXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTsgLy8gaXNRdWFkXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcblxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcblx0XHRcdGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcblx0XHRcdGZhY2VzLnB1c2goIGZhY2UubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuXHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cblx0XHRcdFx0ZmFjZXMucHVzaChcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAxIF0gKSxcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRmYWNlcy5wdXNoKFxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcblx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXG5cdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDIgXSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cblx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XG5cblx0XHRcdHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+ICggMSA8PCBwb3NpdGlvbiApICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcblx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoIGNvbG9yICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XG5cdFx0XHRjb2xvcnMucHVzaCggY29sb3IuZ2V0SGV4KCkgKTtcblxuXHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFV2SW5kZXgoIHV2ICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdGRhdGEuZGF0YSA9IHt9O1xuXG5cdFx0ZGF0YS5kYXRhLnZlcnRpY2VzID0gdmVydGljZXM7XG5cdFx0ZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xuXHRcdGlmICggY29sb3JzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEuY29sb3JzID0gY29sb3JzO1xuXHRcdGlmICggdXZzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEudXZzID0gWyB1dnMgXTsgLy8gdGVtcG9yYWwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRcdGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Lypcblx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xuXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0dmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcblx0XHRcdHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblx0XHQqL1xuXG5cdFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0dmFyIGksIGlsLCBqLCBqbCwgaywga2w7XG5cblx0XHQvLyByZXNldFxuXG5cdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHRcdHRoaXMuY29sb3JzID0gW107XG5cdFx0dGhpcy5mYWNlcyA9IFtdO1xuXHRcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFtbXV07XG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xuXHRcdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcblx0XHR0aGlzLnNraW5JbmRpY2VzID0gW107XG5cdFx0dGhpcy5saW5lRGlzdGFuY2VzID0gW107XG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHQvLyBuYW1lXG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdC8vIHZlcnRpY2VzXG5cblx0XHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNvbG9yc1xuXG5cdFx0dmFyIGNvbG9ycyA9IHNvdXJjZS5jb2xvcnM7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGZhY2VzXG5cblx0XHR2YXIgZmFjZXMgPSBzb3VyY2UuZmFjZXM7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGZhY2UgdmVydGV4IHV2c1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcblxuXHRcdFx0aWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XG5cblx0XHRcdFx0Zm9yICggayA9IDAsIGtsID0gdXZzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHV2ID0gdXZzWyBrIF07XG5cblx0XHRcdFx0XHR1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBtb3JwaCB0YXJnZXRzXG5cblx0XHR2YXIgbW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0ge307XG5cdFx0XHRtb3JwaFRhcmdldC5uYW1lID0gbW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcblxuXHRcdFx0Ly8gdmVydGljZXNcblxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1vcnBoVGFyZ2V0LnZlcnRpY2VzID0gW107XG5cblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRtb3JwaFRhcmdldC52ZXJ0aWNlcy5wdXNoKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlc1sgaiBdLmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbm9ybWFsc1xuXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtb3JwaFRhcmdldC5ub3JtYWxzID0gW107XG5cblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0Lm5vcm1hbHMucHVzaCggbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFsc1sgaiBdLmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldHMucHVzaCggbW9ycGhUYXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIG5vcm1hbHNcblxuXHRcdHZhciBtb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gbW9ycGhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSB7fTtcblxuXHRcdFx0Ly8gdmVydGV4IG5vcm1hbHNcblxuXHRcdFx0aWYgKCBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bW9ycGhOb3JtYWwudmVydGV4Tm9ybWFscyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3JjVmVydGV4Tm9ybWFsID0gbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFsc1sgaiBdO1xuXHRcdFx0XHRcdHZhciBkZXN0VmVydGV4Tm9ybWFsID0ge307XG5cblx0XHRcdFx0XHRkZXN0VmVydGV4Tm9ybWFsLmEgPSBzcmNWZXJ0ZXhOb3JtYWwuYS5jbG9uZSgpO1xuXHRcdFx0XHRcdGRlc3RWZXJ0ZXhOb3JtYWwuYiA9IHNyY1ZlcnRleE5vcm1hbC5iLmNsb25lKCk7XG5cdFx0XHRcdFx0ZGVzdFZlcnRleE5vcm1hbC5jID0gc3JjVmVydGV4Tm9ybWFsLmMuY2xvbmUoKTtcblxuXHRcdFx0XHRcdG1vcnBoTm9ybWFsLnZlcnRleE5vcm1hbHMucHVzaCggZGVzdFZlcnRleE5vcm1hbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmYWNlIG5vcm1hbHNcblxuXHRcdFx0aWYgKCBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1vcnBoTm9ybWFsLmZhY2VOb3JtYWxzID0gW107XG5cblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRtb3JwaE5vcm1hbC5mYWNlTm9ybWFscy5wdXNoKCBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFsc1sgaiBdLmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb3JwaE5vcm1hbHMucHVzaCggbW9ycGhOb3JtYWwgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNraW4gd2VpZ2h0c1xuXG5cdFx0dmFyIHNraW5XZWlnaHRzID0gc291cmNlLnNraW5XZWlnaHRzO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGkgXS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHQvLyBza2luIGluZGljZXNcblxuXHRcdHZhciBza2luSW5kaWNlcyA9IHNvdXJjZS5za2luSW5kaWNlcztcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbGluZSBkaXN0YW5jZXNcblxuXHRcdHZhciBsaW5lRGlzdGFuY2VzID0gc291cmNlLmxpbmVEaXN0YW5jZXM7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBsaW5lRGlzdGFuY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmxpbmVEaXN0YW5jZXMucHVzaCggbGluZURpc3RhbmNlc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHQvLyBib3VuZGluZyBib3hcblxuXHRcdHZhciBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBmbGFnc1xuXG5cdFx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBzb3VyY2UuZWxlbWVudHNOZWVkVXBkYXRlO1xuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gc291cmNlLnZlcnRpY2VzTmVlZFVwZGF0ZTtcblx0XHR0aGlzLnV2c05lZWRVcGRhdGUgPSBzb3VyY2UudXZzTmVlZFVwZGF0ZTtcblx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gc291cmNlLm5vcm1hbHNOZWVkVXBkYXRlO1xuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IHNvdXJjZS5jb2xvcnNOZWVkVXBkYXRlO1xuXHRcdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBzb3VyY2UubGluZURpc3RhbmNlc05lZWRVcGRhdGU7XG5cdFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gc291cmNlLmdyb3Vwc05lZWRVcGRhdGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdH1cblxufTtcblxuT2JqZWN0LmFzc2lnbiggR2VvbWV0cnkucHJvdG90eXBlLCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnkoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBHZW9tZXRyeUlkQ291bnQoKSB9ICk7XG5cblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5pbmRleCA9IG51bGw7XG5cdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG5cdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cblx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcblxufVxuXG5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IEJ1ZmZlckdlb21ldHJ5LFxuXG5cdGlzQnVmZmVyR2VvbWV0cnk6IHRydWUsXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmluZGV4O1xuXG5cdH0sXG5cblx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGluZGV4ICkgKSB7XG5cblx0XHRcdHRoaXMuaW5kZXggPSBuZXcgKCBhcnJheU1heCggaW5kZXggKSA+IDY1NTM1ID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGV4LCAxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XG5cblx0XHR9XG5cblx0fSxcblxuXHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCAoIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUgKSA9PT0gZmFsc2UgJiYgKCBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XG5cblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKSApO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIG5hbWUgPT09ICdpbmRleCcgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xuXHRcdFx0dGhpcy5zZXRJbmRleCggYXR0cmlidXRlICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHR9LFxuXG5cdHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXG5cblx0XHR9ICk7XG5cblx0fSxcblxuXHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR9LFxuXG5cdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRub3JtYWxNYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggbm9ybWFsICk7XG5cdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xuXG5cdFx0dmFyIG0xO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuXHRcdHZhciBtMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcblxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHR2YXIgbTE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxuXG5cdFx0dmFyIG0xO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcblxuXHRcdHZhciBtMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcblxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvYmo7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRcdGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XG5cblx0XHRcdG9iai51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XG5cblx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG5cdFx0cmV0dXJuIG9mZnNldDtcblxuXHR9LFxuXG5cdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdGlmICggb2JqZWN0LmlzUG9pbnRzIHx8IG9iamVjdC5pc0xpbmUgKSB7XG5cblx0XHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xuXHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMywgMyApO1xuXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGgsIDEgKTtcblxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIGxpbmVEaXN0YW5jZXMuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc01lc2ggKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcblxuXHRcdFx0dmFyIGRpcmVjdCA9IGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGRpcmVjdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0Z2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcblx0XHRcdGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuXHRcdFx0ZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuXHRcdFx0ZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuXHRcdFx0ZGlyZWN0Lmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdGdlb21ldHJ5ID0gZGlyZWN0O1xuXG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZTtcblxuXHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XG5cblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XG5cdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMudXY7XG5cblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRnZW9tZXRyeS5jb21wdXRlR3JvdXBzKCBvYmplY3QuZ2VvbWV0cnkgKTtcblx0XHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tRGlyZWN0R2VvbWV0cnkoIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgKTtcblxuXHR9LFxuXG5cdGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG5cblx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMyApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS51dnMyLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2czIsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzMiApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIFR5cGVBcnJheSA9IGFycmF5TWF4KCBnZW9tZXRyeS5pbmRpY2VzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG5cdFx0XHR2YXIgaW5kaWNlcyA9IG5ldyBUeXBlQXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xuXHRcdFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApLmNvcHlJbmRpY2VzQXJyYXkoIGdlb21ldHJ5LmluZGljZXMgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdC8vIG1vcnBoc1xuXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XG5cblx0XHRcdFx0YXJyYXkucHVzaCggYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBtb3JwaFRhcmdldCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2tpbm5pbmdcblxuXHRcdGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIHNraW5JbmRpY2VzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAqIDQsIDQgKTtcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbkluZGV4Jywgc2tpbkluZGljZXMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5JbmRpY2VzICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIHNraW5XZWlnaHRzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAqIDQsIDQgKTtcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYm94ID0gbmV3IEJveDMoKTtcblx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XG5cblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0aWYgKCBwb3NpdGlvbiApIHtcblxuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG5cblx0XHRcdFx0Ym94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XG5cdFx0XHRcdGJveC5nZXRDZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0XHRcdC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXHRcdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmVjdG9yLnggPSBwb3NpdGlvbi5nZXRYKCBpICk7XG5cdFx0XHRcdFx0dmVjdG9yLnkgPSBwb3NpdGlvbi5nZXRZKCBpICk7XG5cdFx0XHRcdFx0dmVjdG9yLnogPSBwb3NpdGlvbi5nZXRaKCBpICk7XG5cdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cblx0XHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0fSxcblxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cblx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5WyBpIF0gPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG5cdFx0XHR2YXIgdkEsIHZCLCB2Qztcblx0XHRcdHZhciBwQSA9IG5ldyBWZWN0b3IzKCksIHBCID0gbmV3IFZlY3RvcjMoKSwgcEMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmFkZEdyb3VwKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xuXG5cdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBqIF07XG5cblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XG5cdFx0XHRcdFx0XHR2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xuXHRcdFx0XHRcdFx0dkMgPSBpbmRpY2VzWyBpICsgMiBdICogMztcblxuXHRcdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZBICk7XG5cdFx0XHRcdFx0XHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcblx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xuXG5cdFx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xuXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiBdICs9IGNiLng7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgXSArPSBjYi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMiBdICs9IGNiLno7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuXHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG5cdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XG5cdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDIgXSA9IGNiLno7XG5cblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMyBdID0gY2IueDtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNCBdID0gY2IueTtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA2IF0gPSBjYi54O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuXHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcblxuXHRcdGlmICggKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xuXHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gYXR0cmlidXRlU2l6ZSAqIG9mZnNldDsgaSA8IGF0dHJpYnV0ZUFycmF5Mi5sZW5ndGg7IGkgKyssIGogKysgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlQXJyYXkxWyBqIF0gPSBhdHRyaWJ1dGVBcnJheTJbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cblx0XHR2YXIgeCwgeSwgeiwgbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHggPSBub3JtYWxzWyBpIF07XG5cdFx0XHR5ID0gbm9ybWFsc1sgaSArIDEgXTtcblx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xuXG5cdFx0XHRuID0gMS4wIC8gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuXHRcdFx0bm9ybWFsc1sgaSBdICo9IG47XG5cdFx0XHRub3JtYWxzWyBpICsgMSBdICo9IG47XG5cdFx0XHRub3JtYWxzWyBpICsgMiBdICo9IG47XG5cblx0XHR9XG5cblx0fSxcblxuXHR0b05vbkluZGV4ZWQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR2YXIgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR2YXIgaW5kaWNlcyA9IHRoaXMuaW5kZXguYXJyYXk7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHR2YXIgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdHZhciBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcblxuXHRcdFx0dmFyIGluZGV4ID0gMCwgaW5kZXgyID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaXRlbVNpemU7IGogKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheTJbIGluZGV4MiArKyBdID0gYXJyYXlbIGluZGV4ICsrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Mi5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5MjtcblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XG5cblx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IGFycmF5XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xuXG5cdFx0XHRkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XG5cdFx0XHRcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXG5cdFx0XHRcdHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRhcnJheTogYXJyYXksXG5cdFx0XHRcdG5vcm1hbGl6ZWQ6IGF0dHJpYnV0ZS5ub3JtYWxpemVkXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8qXG5cdFx0Ly8gSGFuZGxlIHByaW1pdGl2ZXNcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cdFx0Ki9cblxuXHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHZhciBuYW1lLCBpLCBsO1xuXG5cdFx0Ly8gcmVzZXRcblxuXHRcdHRoaXMuaW5kZXggPSBudWxsO1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHRcdC8vIG5hbWVcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0Ly8gaW5kZXhcblxuXHRcdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGF0dHJpYnV0ZXNcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBzb3VyY2UubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0dmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXkucHVzaCggbW9ycGhBdHRyaWJ1dGVbIGkgXS5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuXHRcdGZvciAoIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cblx0XHR9XG5cblx0XHQvLyBib3VuZGluZyBib3hcblxuXHRcdHZhciBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdC8vIGRyYXcgcmFuZ2VcblxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcblx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IHNvdXJjZS5kcmF3UmFuZ2UuY291bnQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdH1cblxufTtcblxuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA2NTUzNTtcblxuT2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xuICovXG5cbmZ1bmN0aW9uIE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2gnO1xuXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuXHR0aGlzLmRyYXdNb2RlID0gVHJpYW5nbGVzRHJhd01vZGU7XG5cblx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxufVxuXG5NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IE1lc2gsXG5cblx0aXNNZXNoOiB0cnVlLFxuXG5cdHNldERyYXdNb2RlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5kcmF3TW9kZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZHJhd01vZGUgPSBzb3VyY2UuZHJhd01vZGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0czogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXG5cdFx0aWYgKCBtb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBtb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcblx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0dmFyIHZBID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdkIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciB2QyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR2YXIgdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciB0ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHRlbXBDID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciB1dkEgPSBuZXcgVmVjdG9yMigpO1xuXHRcdHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xuXHRcdHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0dmFyIGJhcnljb29yZCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIHV2SW50ZXJzZWN0aW9uKCBwb2ludCwgcDEsIHAyLCBwMywgdXYxLCB1djIsIHV2MyApIHtcblxuXHRcdFx0VHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XG5cblx0XHRcdHV2MS5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnggKTtcblx0XHRcdHV2Mi5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnkgKTtcblx0XHRcdHV2My5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnogKTtcblxuXHRcdFx0dXYxLmFkZCggdXYyICkuYWRkKCB1djMgKTtcblxuXHRcdFx0cmV0dXJuIHV2MS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBBLCBwQiwgcEMsIHBvaW50ICkge1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0O1xuXHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xuXG5cdFx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBBLCBwQiwgcEMsIG1hdGVyaWFsLnNpZGUgIT09IERvdWJsZVNpZGUsIHBvaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0aW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBwb2ludCApO1xuXHRcdFx0aW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cblx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRwb2ludDogaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdFxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApIHtcblxuXHRcdFx0dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGEgKTtcblx0XHRcdHZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBiICk7XG5cdFx0XHR2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYyApO1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHZBLCB2QiwgdkMsIGludGVyc2VjdGlvblBvaW50ICk7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdGlmICggdXYgKSB7XG5cblx0XHRcdFx0XHR1dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGEgKTtcblx0XHRcdFx0XHR1dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGIgKTtcblx0XHRcdFx0XHR1dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGMgKTtcblxuXHRcdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIFRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICk7XG5cdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XG5cdFx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0XHQvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcmF5LmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbnRlcnNlY3Rpb247XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgYSwgYiwgYztcblx0XHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdHZhciB1diA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudXY7XG5cdFx0XHRcdHZhciBpLCBsO1xuXG5cdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBpbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBpbmRleC5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0YSA9IGluZGV4LmdldFgoIGkgKTtcblx0XHRcdFx0XHRcdGIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdFx0YyA9IGluZGV4LmdldFgoIGkgKyAyICk7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRpY2VzIGJ1ZmZlciBzZW1hbnRpY3Ncblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gcG9zaXRpb24uY291bnQ7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGEgPSBpO1xuXHRcdFx0XHRcdFx0YiA9IGkgKyAxO1xuXHRcdFx0XHRcdFx0YyA9IGkgKyAyO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XG5cblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5pbmRleCA9IGE7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBwb3NpdGlvbnMgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xuXG5cdFx0XHRcdHZhciBmdkEsIGZ2QiwgZnZDO1xuXHRcdFx0XHR2YXIgaXNGYWNlTWF0ZXJpYWwgPSAoIG1hdGVyaWFsICYmIG1hdGVyaWFsLmlzTXVsdGlNYXRlcmlhbCApO1xuXHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xuXG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXHRcdFx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblx0XHRcdFx0dmFyIHV2cztcblxuXHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblx0XHRcdFx0aWYgKCBmYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB1dnMgPSBmYWNlVmVydGV4VXZzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBmID0gMCwgZmwgPSBmYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGYgXTtcblx0XHRcdFx0XHR2YXIgZmFjZU1hdGVyaWFsID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdFx0XHRmdkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHRcdFx0ZnZCID0gdmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdGZ2QyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblx0XHRcdFx0XHRcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRcdFx0XHRcdFx0dkEuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdFx0XHR2Qi5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdFx0XHRcdHZDLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XG5cblx0XHRcdFx0XHRcdFx0dkEuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQS5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmEgXSwgZnZBICksIGluZmx1ZW5jZSApO1xuXHRcdFx0XHRcdFx0XHR2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBmdkIgKSwgaW5mbHVlbmNlICk7XG5cdFx0XHRcdFx0XHRcdHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2QS5hZGQoIGZ2QSApO1xuXHRcdFx0XHRcdFx0dkIuYWRkKCBmdkIgKTtcblx0XHRcdFx0XHRcdHZDLmFkZCggZnZDICk7XG5cblx0XHRcdFx0XHRcdGZ2QSA9IHZBO1xuXHRcdFx0XHRcdFx0ZnZCID0gdkI7XG5cdFx0XHRcdFx0XHRmdkMgPSB2QztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgZnZBLCBmdkIsIGZ2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHV2cyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdXZzX2YgPSB1dnNbIGYgXTtcblx0XHRcdFx0XHRcdFx0dXZBLmNvcHkoIHV2c19mWyAwIF0gKTtcblx0XHRcdFx0XHRcdFx0dXZCLmNvcHkoIHV2c19mWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0dXZDLmNvcHkoIHV2c19mWyAyIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGZ2QSwgZnZCLCBmdkMsIHV2QSwgdXZCLCB1dkMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gZjtcblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKSApLFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXG4gKi9cblxuZnVuY3Rpb24gQm94R2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0d2lkdGg6IHdpZHRoLFxuXHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdGRlcHRoOiBkZXB0aCxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdH07XG5cblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBCb3hCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkgKTtcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbn1cblxuQm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICovXG5cbmZ1bmN0aW9uIEJveEJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdCb3hCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRkZXB0aDogZGVwdGgsXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuXHR9O1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0Ly8gc2VnbWVudHNcblxuXHR3aWR0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XG5cdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuXHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggZGVwdGhTZWdtZW50cyApIHx8IDE7XG5cblx0Ly8gYnVmZmVyc1xuXG5cdHZhciBpbmRpY2VzID0gW107XG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9ybWFscyA9IFtdO1xuXHR2YXIgdXZzID0gW107XG5cblx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdHZhciBudW1iZXJPZlZlcnRpY2VzID0gMDtcblx0dmFyIGdyb3VwU3RhcnQgPSAwO1xuXG5cdC8vIGJ1aWxkIGVhY2ggc2lkZSBvZiB0aGUgYm94IGdlb21ldHJ5XG5cblx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsICAgd2lkdGgsICBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCApOyAvLyBweFxuXHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAgIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aCwgIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAxICk7IC8vIG54XG5cdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsICAgIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgIDIgKTsgLy8gcHlcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgICAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgIC0gaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAgMyApOyAvLyBueVxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAgIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgICBkZXB0aCwgIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0ICk7IC8vIHB6XG5cdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoLCAgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDUgKTsgLy8gbnpcblxuXHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdywgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGdyaWRYLCBncmlkWSwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdHZhciBzZWdtZW50V2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuXHRcdHZhciBzZWdtZW50SGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0XHR2YXIgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xuXHRcdHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblx0XHR2YXIgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xuXG5cdFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdFx0dmFyIHZlcnRleENvdW50ZXIgPSAwO1xuXHRcdHZhciBncm91cENvdW50ID0gMDtcblxuXHRcdHZhciBpeCwgaXk7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG5cdFx0XHR2YXIgeSA9IGl5ICogc2VnbWVudEhlaWdodCAtIGhlaWdodEhhbGY7XG5cblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7XG5cblx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcblxuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9IHggKiB1ZGlyO1xuXHRcdFx0XHR2ZWN0b3JbIHYgXSA9IHkgKiB2ZGlyO1xuXHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoSGFsZjtcblxuXHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIHZlcnRleCBidWZmZXJcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcblxuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9IDA7XG5cdFx0XHRcdHZlY3RvclsgdiBdID0gMDtcblx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xuXG5cdFx0XHRcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gbm9ybWFsIGJ1ZmZlclxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHRcdC8vIHV2c1xuXG5cdFx0XHRcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XG5cdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdFx0XHQvLyBjb3VudGVyc1xuXG5cdFx0XHRcdHZlcnRleENvdW50ZXIgKz0gMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2Vcblx0XHQvLyAyLiBhIHNpbmdsZSBzZWdtZW50IGNvbnNpc3RzIG9mIHR3byBmYWNlc1xuXHRcdC8vIDMuIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgc2l4ICgyKjMpIGluZGljZXMgcGVyIHNlZ21lbnRcblxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cblx0XHRcdFx0dmFyIGEgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdFx0dmFyIGIgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgYyA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdFx0dmFyIGQgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdC8vIGluY3JlYXNlIGNvdW50ZXJcblxuXHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgbWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0XHQvLyB1cGRhdGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzXG5cblx0XHRudW1iZXJPZlZlcnRpY2VzICs9IHZlcnRleENvdW50ZXI7XG5cblx0fVxuXG59XG5cbkJveEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuQm94QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94QnVmZmVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cbmZ1bmN0aW9uIFBsYW5lR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG5cdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuXHR9O1xuXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xuXG59XG5cblBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKlxuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gKi9cblxuZnVuY3Rpb24gUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQbGFuZUJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0d2lkdGg6IHdpZHRoLFxuXHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdH07XG5cblx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cblx0dmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XG5cdHZhciBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcblxuXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0dmFyIGl4LCBpeTtcblxuXHQvLyBidWZmZXJzXG5cblx0dmFyIGluZGljZXMgPSBbXTtcblx0dmFyIHZlcnRpY2VzID0gW107XG5cdHZhciBub3JtYWxzID0gW107XG5cdHZhciB1dnMgPSBbXTtcblxuXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cblx0XHR2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuXHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIC0geSwgMCApO1xuXG5cdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblxuXHRcdFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcblx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gaW5kaWNlc1xuXG5cdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cblx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG59XG5cblBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lQnVmZmVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cbmZ1bmN0aW9uIENhbWVyYSgpIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0NhbWVyYSc7XG5cblx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG59XG5cbkNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW1lcmE7XG5cbkNhbWVyYS5wcm90b3R5cGUuaXNDYW1lcmEgPSB0cnVlO1xuXG5DYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdH07XG5cbn0oKTtcblxuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgY2FtZXJhcyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cblx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuXHR9O1xuXG59KCk7XG5cbkNhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG59O1xuXG5DYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuXHRDYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cblx0dGhpcy5mb3YgPSBmb3YgIT09IHVuZGVmaW5lZCA/IGZvdiA6IDUwO1xuXHR0aGlzLnpvb20gPSAxO1xuXG5cdHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG5cdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xuXHR0aGlzLmZvY3VzID0gMTA7XG5cblx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XG5cdHRoaXMudmlldyA9IG51bGw7XG5cblx0dGhpcy5maWxtR2F1Z2UgPSAzNTtcdC8vIHdpZHRoIG9mIHRoZSBmaWxtIChkZWZhdWx0IGluIG1pbGxpbWV0ZXJzKVxuXHR0aGlzLmZpbG1PZmZzZXQgPSAwO1x0Ly8gaG9yaXpvbnRhbCBmaWxtIG9mZnNldCAoc2FtZSB1bml0IGFzIGdhdWdlKVxuXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59XG5cblBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENhbWVyYS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBQZXJzcGVjdGl2ZUNhbWVyYSxcblxuXHRpc1BlcnNwZWN0aXZlQ2FtZXJhOiB0cnVlLFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0Q2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xuXHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXG5cdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG5cdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cblx0XHR0aGlzLmFzcGVjdCA9IHNvdXJjZS5hc3BlY3Q7XG5cdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XG5cblx0XHR0aGlzLmZpbG1HYXVnZSA9IHNvdXJjZS5maWxtR2F1Z2U7XG5cdFx0dGhpcy5maWxtT2Zmc2V0ID0gc291cmNlLmZpbG1PZmZzZXQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBGT1YgYnkgZm9jYWwgbGVuZ3RoIGluIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgLmZpbG1HYXVnZS5cblx0ICpcblx0ICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXG5cdCAqIGEgMzVtbSAoZnVsbCBmcmFtZSkgY2FtZXJhLlxuXHQgKlxuXHQgKiBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cblx0ICovXG5cdHNldEZvY2FsTGVuZ3RoOiBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoICkge1xuXG5cdFx0Ly8gc2VlIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXG5cdFx0dmFyIHZFeHRlbnRTbG9wZSA9IDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gZm9jYWxMZW5ndGg7XG5cblx0XHR0aGlzLmZvdiA9IF9NYXRoLlJBRDJERUcgKiAyICogTWF0aC5hdGFuKCB2RXh0ZW50U2xvcGUgKTtcblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBmb2NhbCBsZW5ndGggZnJvbSB0aGUgY3VycmVudCAuZm92IGFuZCAuZmlsbUdhdWdlLlxuXHQgKi9cblx0Z2V0Rm9jYWxMZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2RXh0ZW50U2xvcGUgPSBNYXRoLnRhbiggX01hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICk7XG5cblx0XHRyZXR1cm4gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyB2RXh0ZW50U2xvcGU7XG5cblx0fSxcblxuXHRnZXRFZmZlY3RpdmVGT1Y6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfTWF0aC5SQUQyREVHICogMiAqIE1hdGguYXRhbihcblx0XHRcdFx0TWF0aC50YW4oIF9NYXRoLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApIC8gdGhpcy56b29tICk7XG5cblx0fSxcblxuXHRnZXRGaWxtV2lkdGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBwb3J0cmFpdCBmb3JtYXQgKGFzcGVjdCA8IDEpXG5cdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlICogTWF0aC5taW4oIHRoaXMuYXNwZWN0LCAxICk7XG5cblx0fSxcblxuXHRnZXRGaWxtSGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gbGFuZHNjYXBlIGZvcm1hdCAoYXNwZWN0ID4gMSlcblx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCggdGhpcy5hc3BlY3QsIDEgKTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG5cdCAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG5cdCAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcblx0ICpcblx0ICogICArLS0tKy0tLSstLS0rXG5cdCAqICAgfCBBIHwgQiB8IEMgfFxuXHQgKiAgICstLS0rLS0tKy0tLStcblx0ICogICB8IEQgfCBFIHwgRiB8XG5cdCAqICAgKy0tLSstLS0rLS0tK1xuXHQgKlxuXHQgKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG5cdCAqXG5cdCAqICAgdmFyIHcgPSAxOTIwO1xuXHQgKiAgIHZhciBoID0gMTA4MDtcblx0ICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XG5cdCAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcblx0ICpcblx0ICogICAtLUEtLVxuXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XG5cdCAqICAgLS1CLS1cblx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuXHQgKiAgIC0tQy0tXG5cdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcblx0ICogICAtLUQtLVxuXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XG5cdCAqICAgLS1FLS1cblx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuXHQgKiAgIC0tRi0tXG5cdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcblx0ICpcblx0ICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuXHQgKi9cblx0c2V0Vmlld09mZnNldDogZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHR0aGlzLmFzcGVjdCA9IGZ1bGxXaWR0aCAvIGZ1bGxIZWlnaHQ7XG5cblx0XHR0aGlzLnZpZXcgPSB7XG5cdFx0XHRmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcblx0XHRcdGZ1bGxIZWlnaHQ6IGZ1bGxIZWlnaHQsXG5cdFx0XHRvZmZzZXRYOiB4LFxuXHRcdFx0b2Zmc2V0WTogeSxcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0fTtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH0sXG5cblx0Y2xlYXJWaWV3T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMudmlldyA9IG51bGw7XG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0fSxcblxuXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbmVhciA9IHRoaXMubmVhcixcblx0XHRcdHRvcCA9IG5lYXIgKiBNYXRoLnRhbihcblx0XHRcdFx0XHRfTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSxcblx0XHRcdGhlaWdodCA9IDIgKiB0b3AsXG5cdFx0XHR3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0LFxuXHRcdFx0bGVmdCA9IC0gMC41ICogd2lkdGgsXG5cdFx0XHR2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0aWYgKCB2aWV3ICE9PSBudWxsICkge1xuXG5cdFx0XHR2YXIgZnVsbFdpZHRoID0gdmlldy5mdWxsV2lkdGgsXG5cdFx0XHRcdGZ1bGxIZWlnaHQgPSB2aWV3LmZ1bGxIZWlnaHQ7XG5cblx0XHRcdGxlZnQgKz0gdmlldy5vZmZzZXRYICogd2lkdGggLyBmdWxsV2lkdGg7XG5cdFx0XHR0b3AgLT0gdmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcblx0XHRcdHdpZHRoICo9IHZpZXcud2lkdGggLyBmdWxsV2lkdGg7XG5cdFx0XHRoZWlnaHQgKj0gdmlldy5oZWlnaHQgLyBmdWxsSGVpZ2h0O1xuXG5cdFx0fVxuXG5cdFx0dmFyIHNrZXcgPSB0aGlzLmZpbG1PZmZzZXQ7XG5cdFx0aWYgKCBza2V3ICE9PSAwICkgbGVmdCArPSBuZWFyICogc2tldyAvIHRoaXMuZ2V0RmlsbVdpZHRoKCk7XG5cblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCBsZWZ0ICsgd2lkdGgsIHRvcCwgdG9wIC0gaGVpZ2h0LCBuZWFyLCB0aGlzLmZhciApO1xuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblxuXHRcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cdFx0ZGF0YS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xuXG5cdFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG5cblx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy52aWV3ICk7XG5cblx0XHRkYXRhLm9iamVjdC5maWxtR2F1Z2UgPSB0aGlzLmZpbG1HYXVnZTtcblx0XHRkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgYXJvc2UgLyBodHRwOi8vZ2l0aHViLmNvbS9hcm9zZVxuICovXG5cbmZ1bmN0aW9uIE9ydGhvZ3JhcGhpY0NhbWVyYSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0Q2FtZXJhLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnT3J0aG9ncmFwaGljQ2FtZXJhJztcblxuXHR0aGlzLnpvb20gPSAxO1xuXHR0aGlzLnZpZXcgPSBudWxsO1xuXG5cdHRoaXMubGVmdCA9IGxlZnQ7XG5cdHRoaXMucmlnaHQgPSByaWdodDtcblx0dGhpcy50b3AgPSB0b3A7XG5cdHRoaXMuYm90dG9tID0gYm90dG9tO1xuXG5cdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDIwMDA7XG5cblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn1cblxuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENhbWVyYS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBPcnRob2dyYXBoaWNDYW1lcmEsXG5cblx0aXNPcnRob2dyYXBoaWNDYW1lcmE6IHRydWUsXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRDYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcblx0XHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xuXHRcdHRoaXMudG9wID0gc291cmNlLnRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG5cdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG5cdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXG5cdFx0dGhpcy56b29tID0gc291cmNlLnpvb207XG5cdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHR0aGlzLnZpZXcgPSB7XG5cdFx0XHRmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcblx0XHRcdGZ1bGxIZWlnaHQ6IGZ1bGxIZWlnaHQsXG5cdFx0XHRvZmZzZXRYOiB4LFxuXHRcdFx0b2Zmc2V0WTogeSxcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0fTtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH0sXG5cblx0Y2xlYXJWaWV3T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMudmlldyA9IG51bGw7XG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0fSxcblxuXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xuXHRcdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG5cdFx0dmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xuXHRcdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcblxuXHRcdHZhciBsZWZ0ID0gY3ggLSBkeDtcblx0XHR2YXIgcmlnaHQgPSBjeCArIGR4O1xuXHRcdHZhciB0b3AgPSBjeSArIGR5O1xuXHRcdHZhciBib3R0b20gPSBjeSAtIGR5O1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSB7XG5cblx0XHRcdHZhciB6b29tVyA9IHRoaXMuem9vbSAvICggdGhpcy52aWV3LndpZHRoIC8gdGhpcy52aWV3LmZ1bGxXaWR0aCApO1xuXHRcdFx0dmFyIHpvb21IID0gdGhpcy56b29tIC8gKCB0aGlzLnZpZXcuaGVpZ2h0IC8gdGhpcy52aWV3LmZ1bGxIZWlnaHQgKTtcblx0XHRcdHZhciBzY2FsZVcgPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvIHRoaXMudmlldy53aWR0aDtcblx0XHRcdHZhciBzY2FsZUggPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvIHRoaXMudmlldy5oZWlnaHQ7XG5cblx0XHRcdGxlZnQgKz0gc2NhbGVXICogKCB0aGlzLnZpZXcub2Zmc2V0WCAvIHpvb21XICk7XG5cdFx0XHRyaWdodCA9IGxlZnQgKyBzY2FsZVcgKiAoIHRoaXMudmlldy53aWR0aCAvIHpvb21XICk7XG5cdFx0XHR0b3AgLT0gc2NhbGVIICogKCB0aGlzLnZpZXcub2Zmc2V0WSAvIHpvb21IICk7XG5cdFx0XHRib3R0b20gPSB0b3AgLSBzY2FsZUggKiAoIHRoaXMudmlldy5oZWlnaHQgLyB6b29tSCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblx0XHRkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xuXHRcdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcblx0XHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcblx0XHRkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcblx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggZ2wsIGV4dGVuc2lvbnMsIGluZm9SZW5kZXIgKSB7XG5cblx0dmFyIG1vZGU7XG5cblx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cblx0XHRtb2RlID0gdmFsdWU7XG5cblx0fVxuXG5cdHZhciB0eXBlLCBzaXplO1xuXG5cdGZ1bmN0aW9uIHNldEluZGV4KCBpbmRleCApIHtcblxuXHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XG5cdFx0XHRzaXplID0gNDtcblxuXHRcdH0gZWxzZSBpZiAoIGluZGV4LmFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcblx0XHRcdHNpemUgPSAyO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHRzaXplID0gMTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRnbC5kcmF3RWxlbWVudHMoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIHNpemUgKTtcblxuXHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XG5cdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcblxuXHRcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuXHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XG5cdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xuXG5cdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0c2V0TW9kZTogc2V0TW9kZSxcblx0XHRzZXRJbmRleDogc2V0SW5kZXgsXG5cdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0cmVuZGVySW5zdGFuY2VzOiByZW5kZXJJbnN0YW5jZXNcblxuXHR9O1xuXG59XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBXZWJHTEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcblxuXHR2YXIgbW9kZTtcblxuXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuXHRcdG1vZGUgPSB2YWx1ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRnbC5kcmF3QXJyYXlzKCBtb2RlLCBzdGFydCwgY291bnQgKTtcblxuXHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XG5cdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcblxuXHRcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGlmICggcG9zaXRpb24uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y291bnQgPSBwb3NpdGlvbi5kYXRhLmNvdW50O1xuXG5cdFx0XHRleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBjb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvdW50ID0gcG9zaXRpb24uY291bnQ7XG5cblx0XHRcdGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG5cdFx0fVxuXG5cdFx0aW5mb1JlbmRlci5jYWxscyArKztcblx0XHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50ICogZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQ7XG5cblx0XHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudCAvIDM7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c2V0TW9kZTogc2V0TW9kZSxcblx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRyZW5kZXJJbnN0YW5jZXM6IHJlbmRlckluc3RhbmNlc1xuXHR9O1xuXG59XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBXZWJHTExpZ2h0cygpIHtcblxuXHR2YXIgbGlnaHRzID0ge307XG5cblx0cmV0dXJuIHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRcdFx0aWYgKCBsaWdodHNbIGxpZ2h0LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB1bmlmb3JtcztcblxuXHRcdFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcblxuXHRcdFx0XHRcdFx0c2hhZG93OiBmYWxzZSxcblx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG5cdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogMCxcblx0XHRcdFx0XHRcdGNvbmVDb3M6IDAsXG5cdFx0XHRcdFx0XHRwZW51bWJyYUNvczogMCxcblx0XHRcdFx0XHRcdGRlY2F5OiAwLFxuXG5cdFx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogMCxcblx0XHRcdFx0XHRcdGRlY2F5OiAwLFxuXG5cdFx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRza3lDb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRncm91bmRDb2xvcjogbmV3IENvbG9yKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg6IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRoYWxmSGVpZ2h0OiBuZXcgVmVjdG9yMygpXG5cdFx0XHRcdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogc2V0IFJlY3RBcmVhTGlnaHQgc2hhZG93IHVuaWZvcm1zXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0cmV0dXJuIHVuaWZvcm1zO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSB7XG5cblx0dmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuXHR9XG5cblx0cmV0dXJuIGxpbmVzLmpvaW4oICdcXG4nICk7XG5cbn1cblxuZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cblx0dmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xuXG5cdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcblx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cblx0aWYgKCBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXCd0IGNvbXBpbGUuJyApO1xuXG5cdH1cblxuXHRpZiAoIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApICE9PSAnJyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cblx0fVxuXG5cdC8vIC0tZW5hYmxlLXByaXZpbGVnZWQtd2ViZ2wtZXh0ZW5zaW9uXG5cdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cblx0cmV0dXJuIHNoYWRlcjtcblxufVxuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIHByb2dyYW1JZENvdW50ID0gMDtcblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBlbmNvZGluZyApIHtcblxuXHRzd2l0Y2ggKCBlbmNvZGluZyApIHtcblxuXHRcdGNhc2UgTGluZWFyRW5jb2Rpbmc6XG5cdFx0XHRyZXR1cm4gWyAnTGluZWFyJywnKCB2YWx1ZSApJyBdO1xuXHRcdGNhc2Ugc1JHQkVuY29kaW5nOlxuXHRcdFx0cmV0dXJuIFsgJ3NSR0InLCcoIHZhbHVlICknIF07XG5cdFx0Y2FzZSBSR0JFRW5jb2Rpbmc6XG5cdFx0XHRyZXR1cm4gWyAnUkdCRScsJyggdmFsdWUgKScgXTtcblx0XHRjYXNlIFJHQk03RW5jb2Rpbmc6XG5cdFx0XHRyZXR1cm4gWyAnUkdCTScsJyggdmFsdWUsIDcuMCApJyBdO1xuXHRcdGNhc2UgUkdCTTE2RW5jb2Rpbmc6XG5cdFx0XHRyZXR1cm4gWyAnUkdCTScsJyggdmFsdWUsIDE2LjAgKScgXTtcblx0XHRjYXNlIFJHQkRFbmNvZGluZzpcblx0XHRcdHJldHVybiBbICdSR0JEJywnKCB2YWx1ZSwgMjU2LjAgKScgXTtcblx0XHRjYXNlIEdhbW1hRW5jb2Rpbmc6XG5cdFx0XHRyZXR1cm4gWyAnR2FtbWEnLCcoIHZhbHVlLCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKScgXTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAndW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgZW5jb2RpbmcgKSB7XG5cblx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XG5cdHJldHVybiBcInZlYzQgXCIgKyBmdW5jdGlvbk5hbWUgKyBcIiggdmVjNCB2YWx1ZSApIHsgcmV0dXJuIFwiICsgY29tcG9uZW50c1sgMCBdICsgXCJUb0xpbmVhclwiICsgY29tcG9uZW50c1sgMSBdICsgXCI7IH1cIjtcblxufVxuXG5mdW5jdGlvbiBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgZW5jb2RpbmcgKSB7XG5cblx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XG5cdHJldHVybiBcInZlYzQgXCIgKyBmdW5jdGlvbk5hbWUgKyBcIiggdmVjNCB2YWx1ZSApIHsgcmV0dXJuIExpbmVhclRvXCIgKyBjb21wb25lbnRzWyAwIF0gKyBjb21wb25lbnRzWyAxIF0gKyBcIjsgfVwiO1xuXG59XG5cbmZ1bmN0aW9uIGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgdG9uZU1hcHBpbmcgKSB7XG5cblx0dmFyIHRvbmVNYXBwaW5nTmFtZTtcblxuXHRzd2l0Y2ggKCB0b25lTWFwcGluZyApIHtcblxuXHRcdGNhc2UgTGluZWFyVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSBcIkxpbmVhclwiO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFJlaW5oYXJkVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSBcIlJlaW5oYXJkXCI7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgVW5jaGFydGVkMlRvbmVNYXBwaW5nOlxuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gXCJVbmNoYXJ0ZWQyXCI7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQ2luZW9uVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSBcIk9wdGltaXplZENpbmVvblwiO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAndW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6ICcgKyB0b25lTWFwcGluZyApO1xuXG5cdH1cblxuXHRyZXR1cm4gXCJ2ZWMzIFwiICsgZnVuY3Rpb25OYW1lICsgXCIoIHZlYzMgY29sb3IgKSB7IHJldHVybiBcIiArIHRvbmVNYXBwaW5nTmFtZSArIFwiVG9uZU1hcHBpbmcoIGNvbG9yICk7IH1cIjtcblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUV4dGVuc2lvbnMoIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMsIHJlbmRlcmVyRXh0ZW5zaW9ucyApIHtcblxuXHRleHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuXHR2YXIgY2h1bmtzID0gW1xuXHRcdCggZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyB8fCBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVViB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyApID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxuXHRcdCggZXh0ZW5zaW9ucy5mcmFnRGVwdGggfHwgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsXG5cdFx0KCBleHRlbnNpb25zLmRyYXdCdWZmZXJzICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ1dFQkdMX2RyYXdfYnVmZmVycycgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlJyA6ICcnLFxuXHRcdCggZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9EIHx8IHBhcmFtZXRlcnMuZW52TWFwICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlJyA6ICcnXG5cdF07XG5cblx0cmV0dXJuIGNodW5rcy5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICkge1xuXG5cdHZhciBjaHVua3MgPSBbXTtcblxuXHRmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xuXG5cdFx0dmFyIHZhbHVlID0gZGVmaW5lc1sgbmFtZSBdO1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XG5cblx0fVxuXG5cdHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcblxufVxuXG5mdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG5cdHZhciBhdHRyaWJ1dGVzID0ge307XG5cblx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XG5cblx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYiggcHJvZ3JhbSwgaSApO1xuXHRcdHZhciBuYW1lID0gaW5mby5uYW1lO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOlwiLCBuYW1lLCBpICk7XG5cblx0XHRhdHRyaWJ1dGVzWyBuYW1lIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xuXG5cdH1cblxuXHRyZXR1cm4gYXR0cmlidXRlcztcblxufVxuXG5mdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcblxuXHRyZXR1cm4gc3RyaW5nICE9PSAnJztcblxufVxuXG5mdW5jdGlvbiByZXBsYWNlTGlnaHROdW1zKCBzdHJpbmcsIHBhcmFtZXRlcnMgKSB7XG5cblx0cmV0dXJuIHN0cmluZ1xuXHRcdC5yZXBsYWNlKCAvTlVNX0RJUl9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1EaXJMaWdodHMgKVxuXHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fUkVDVF9BUkVBX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVJlY3RBcmVhTGlnaHRzIClcblx0XHQucmVwbGFjZSggL05VTV9QT0lOVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0cyApXG5cdFx0LnJlcGxhY2UoIC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XG5cbn1cblxuZnVuY3Rpb24gcGFyc2VJbmNsdWRlcyggc3RyaW5nICkge1xuXG5cdHZhciBwYXR0ZXJuID0gLyNpbmNsdWRlICs8KFtcXHdcXGQuXSspPi9nO1xuXG5cdGZ1bmN0aW9uIHJlcGxhY2UoIG1hdGNoLCBpbmNsdWRlICkge1xuXG5cdFx0dmFyIHJlcGxhY2UgPSBTaGFkZXJDaHVua1sgaW5jbHVkZSBdO1xuXG5cdFx0aWYgKCByZXBsYWNlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8JyArIGluY2x1ZGUgKyAnPicgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZUluY2x1ZGVzKCByZXBsYWNlICk7XG5cblx0fVxuXG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xuXG59XG5cbmZ1bmN0aW9uIHVucm9sbExvb3BzKCBzdHJpbmcgKSB7XG5cblx0dmFyIHBhdHRlcm4gPSAvZm9yIFxcKCBpbnQgaSBcXD0gKFxcZCspXFw7IGkgPCAoXFxkKylcXDsgaSBcXCtcXCsgXFwpIFxceyhbXFxzXFxTXSs/KSg/PVxcfSlcXH0vZztcblxuXHRmdW5jdGlvbiByZXBsYWNlKCBtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCApIHtcblxuXHRcdHZhciB1bnJvbGwgPSAnJztcblxuXHRcdGZvciAoIHZhciBpID0gcGFyc2VJbnQoIHN0YXJ0ICk7IGkgPCBwYXJzZUludCggZW5kICk7IGkgKysgKSB7XG5cblx0XHRcdHVucm9sbCArPSBzbmlwcGV0LnJlcGxhY2UoIC9cXFsgaSBcXF0vZywgJ1sgJyArIGkgKyAnIF0nICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5yb2xsO1xuXG5cdH1cblxuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKTtcblxufVxuXG5mdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXG5cdHZhciBleHRlbnNpb25zID0gbWF0ZXJpYWwuZXh0ZW5zaW9ucztcblx0dmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xuXG5cdHZhciB2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnZlcnRleFNoYWRlcjtcblx0dmFyIGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuXHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cblx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNoYWRvd01hcCApIHtcblxuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcblxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cblx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcblxuXHR9XG5cblx0dmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuXHR2YXIgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblxuXHRpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xuXG5cdFx0c3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XG5cblx0XHRcdGNhc2UgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0Y2FzZSBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZzpcblx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFX1VWJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzpcblx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG5cdFx0XHRjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcblx0XHRcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcblxuXHRcdFx0Y2FzZSBNdWx0aXBseU9wZXJhdGlvbjpcblx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgTWl4T3BlcmF0aW9uOlxuXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQWRkT3BlcmF0aW9uOlxuXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblxuXHQvLyBjb25zb2xlLmxvZyggJ2J1aWxkaW5nIG5ldyBwcm9ncmFtICcgKTtcblxuXHQvL1xuXG5cdHZhciBjdXN0b21FeHRlbnNpb25zID0gZ2VuZXJhdGVFeHRlbnNpb25zKCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzLCByZW5kZXJlci5leHRlbnNpb25zICk7XG5cblx0dmFyIGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKTtcblxuXHQvL1xuXG5cdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdHZhciBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xuXG5cdGlmICggbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHtcblxuXHRcdHByZWZpeFZlcnRleCA9IFtcblxuXHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuXHRcdFx0J1xcbidcblxuXHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG5cdFx0cHJlZml4RnJhZ21lbnQgPSBbXG5cblx0XHRcdGN1c3RvbUV4dGVuc2lvbnMsXG5cdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHQnXFxuJ1xuXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHByZWZpeFZlcnRleCA9IFtcblxuICAgICAgICBcblx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuXHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5uYW1lLFxuXG5cdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBWRVJURVhfVEVYVFVSRVMnIDogJycsXG5cblx0XHRcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cblx0XHRcdCcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcblx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXG5cdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcblxuXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cblx0XHRcdCcjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgJyArIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMsXG5cblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7Jyxcblx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG5cdFx0XHQnYXR0cmlidXRlIHZlYzMgcG9zaXRpb247Jyxcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7Jyxcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG5cdFx0XHQnI2lmZGVmIFVTRV9DT0xPUicsXG5cblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLFxuXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7Jyxcblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JyxcblxuXHRcdFx0J1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxuXG5cdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLFxuXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7Jyxcblx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXG5cdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLFxuXG5cdFx0XHQnXHQjZWxzZScsXG5cblx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXG5cdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxuXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7Jyxcblx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXG5cblx0XHRcdCdcdCNlbmRpZicsXG5cblx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHQnI2lmZGVmIFVTRV9TS0lOTklORycsXG5cblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLFxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxuXG5cdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0J1xcbidcblxuXHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG5cdFx0cHJlZml4RnJhZ21lbnQgPSBbXG5cblx0XHRcdGN1c3RvbUV4dGVuc2lvbnMsXG5cblx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuXHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5uYW1lLFxuXG5cdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmFscGhhVGVzdCA/ICcjZGVmaW5lIEFMUEhBVEVTVCAnICsgcGFyYW1ldGVycy5hbHBoYVRlc3QgOiAnJyxcblxuXHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuXHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcblx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmdyYWRpZW50TWFwID8gJyNkZWZpbmUgVVNFX0dSQURJRU5UTUFQJyA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cblx0XHRcdCcjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgJyArIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMsXG5cdFx0XHQnI2RlZmluZSBVTklPTl9DTElQUElOR19QTEFORVMgJyArIChwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzIC0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uKSxcblxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhID8gXCIjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEFcIiA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID8gXCIjZGVmaW5lIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcIiA6ICcnLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcmVuZGVyZXIuZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXG5cblx0XHRcdHBhcmFtZXRlcnMuZW52TWFwICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSA/ICcjZGVmaW5lIFRFWFRVUkVfTE9EX0VYVCcgOiAnJyxcblxuXHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cblx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gXCIjZGVmaW5lIFRPTkVfTUFQUElOR1wiIDogJycsXG5cdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IFNoYWRlckNodW5rWyAndG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCcgXSA6ICcnLCAgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB0b25lTWFwcGluZygpIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbiggXCJ0b25lTWFwcGluZ1wiLCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICkgOiAnJyxcblxuXHRcdFx0KCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nIHx8IHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgfHwgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgKSA/IFNoYWRlckNodW5rWyAnZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQnIF0gOiAnJywgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblx0XHRcdHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdtYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5tYXBFbmNvZGluZyApIDogJycsXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnZW52TWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgKSA6ICcnLFxuXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nICkgOiAnJyxcblx0XHRcdHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgPyBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oIFwibGluZWFyVG9PdXRwdXRUZXhlbFwiLCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nICkgOiAnJyxcblxuXHRcdFx0cGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgPyBcIiNkZWZpbmUgREVQVEhfUEFDS0lORyBcIiArIG1hdGVyaWFsLmRlcHRoUGFja2luZyA6ICcnLFxuXG5cdFx0XHQnXFxuJ1xuXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0fVxuXG5cdHZlcnRleFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyApO1xuXHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCB2ZXJ0ZXhTaGFkZXIsIHBhcmFtZXRlcnMgKTtcblxuXHRmcmFnbWVudFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIGZyYWdtZW50U2hhZGVyLCBwYXJhbWV0ZXJzICk7XG5cdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcblxuXHRpZiAoICEgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCApIHtcblxuXHRcdHZlcnRleFNoYWRlciA9IHVucm9sbExvb3BzKCB2ZXJ0ZXhTaGFkZXIgKTtcblx0XHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKCBmcmFnbWVudFNoYWRlciApO1xuXG5cdH1cblxuXHR2YXIgdmVydGV4R2xzbCA9IHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcblx0dmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XG5cblx0Ly8gY29uc29sZS5sb2coICcqVkVSVEVYKicsIHZlcnRleEdsc2wgKTtcblx0Ly8gY29uc29sZS5sb2coICcqRlJBR01FTlQqJywgZnJhZ21lbnRHbHNsICk7XG5cblx0dmFyIGdsVmVydGV4U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XG5cdHZhciBnbEZyYWdtZW50U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xuXG5cdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcblx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XG5cblx0Ly8gRm9yY2UgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSB0byBpbmRleCAwLlxuXG5cdGlmICggbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cblx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cblx0XHQvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcblx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcblxuXHR9XG5cblx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHR2YXIgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XG5cdHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xuXHR2YXIgZnJhZ21lbnRMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbEZyYWdtZW50U2hhZGVyICk7XG5cblx0dmFyIHJ1bm5hYmxlID0gdHJ1ZTtcblx0dmFyIGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XG5cblx0Ly8gY29uc29sZS5sb2coICcqKlZFUlRFWCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbFZlcnRleFNoYWRlciApICk7XG5cdC8vIGNvbnNvbGUubG9nKCAnKipGUkFHTUVOVCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbEZyYWdtZW50U2hhZGVyICkgKTtcblxuXHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG5cdFx0cnVubmFibGUgPSBmYWxzZTtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XG5cblx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XG5cblx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XG5cblx0XHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcblxuXHR9XG5cblx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XG5cblx0XHR0aGlzLmRpYWdub3N0aWNzID0ge1xuXG5cdFx0XHRydW5uYWJsZTogcnVubmFibGUsXG5cdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG5cblx0XHRcdHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXG5cblx0XHRcdHZlcnRleFNoYWRlcjoge1xuXG5cdFx0XHRcdGxvZzogdmVydGV4TG9nLFxuXHRcdFx0XHRwcmVmaXg6IHByZWZpeFZlcnRleFxuXG5cdFx0XHR9LFxuXG5cdFx0XHRmcmFnbWVudFNoYWRlcjoge1xuXG5cdFx0XHRcdGxvZzogZnJhZ21lbnRMb2csXG5cdFx0XHRcdHByZWZpeDogcHJlZml4RnJhZ21lbnRcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cblx0Ly8gY2xlYW4gdXBcblxuXHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XG5cdGdsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cdC8vIHNldCB1cCBjYWNoaW5nIGZvciB1bmlmb3JtIGxvY2F0aW9uc1xuXG5cdHZhciBjYWNoZWRVbmlmb3JtcztcblxuXHR0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNhY2hlZFVuaWZvcm1zID1cblx0XHRcdFx0bmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtLCByZW5kZXJlciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xuXG5cdH07XG5cblx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcblxuXHR2YXIgY2FjaGVkQXR0cmlidXRlcztcblxuXHR0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmICggY2FjaGVkQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcblxuXHR9O1xuXG5cdC8vIGZyZWUgcmVzb3VyY2VcblxuXHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuXHRcdGdsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcblx0XHR0aGlzLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cblx0fTtcblxuXHQvLyBERVBSRUNBVEVEXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblxuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFVuaWZvcm1zKCk7XG5cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YXR0cmlidXRlczoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gKTtcblxuXG5cdC8vXG5cblx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xuXHR0aGlzLmNvZGUgPSBjb2RlO1xuXHR0aGlzLnVzZWRUaW1lcyA9IDE7XG5cdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXG5cdHJldHVybiB0aGlzO1xuXG59XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBXZWJHTFByb2dyYW1zKCByZW5kZXJlciwgY2FwYWJpbGl0aWVzICkge1xuXG5cdHZhciBwcm9ncmFtcyA9IFtdO1xuXG5cdHZhciBzaGFkZXJJRHMgPSB7XG5cdFx0TWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXG5cdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcblx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG5cdFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG5cdFx0TWVzaFRvb25NYXRlcmlhbDogJ3Bob25nJyxcblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcblx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcblx0XHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcblx0XHRMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuXHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJ1xuXHR9O1xuXG5cdHZhciBwYXJhbWV0ZXJOYW1lcyA9IFtcblx0XHRcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJtYXBFbmNvZGluZ1wiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIiwgXCJlbnZNYXBFbmNvZGluZ1wiLFxuXHRcdFwibGlnaHRNYXBcIiwgXCJhb01hcFwiLCBcImVtaXNzaXZlTWFwXCIsIFwiZW1pc3NpdmVNYXBFbmNvZGluZ1wiLCBcImJ1bXBNYXBcIiwgXCJub3JtYWxNYXBcIiwgXCJkaXNwbGFjZW1lbnRNYXBcIiwgXCJzcGVjdWxhck1hcFwiLFxuXHRcdFwicm91Z2huZXNzTWFwXCIsIFwibWV0YWxuZXNzTWFwXCIsIFwiZ3JhZGllbnRNYXBcIixcblx0XHRcImFscGhhTWFwXCIsIFwiY29tYmluZVwiLCBcInZlcnRleENvbG9yc1wiLCBcImZvZ1wiLCBcInVzZUZvZ1wiLCBcImZvZ0V4cFwiLFxuXHRcdFwiZmxhdFNoYWRpbmdcIiwgXCJzaXplQXR0ZW51YXRpb25cIiwgXCJsb2dhcml0aG1pY0RlcHRoQnVmZmVyXCIsIFwic2tpbm5pbmdcIixcblx0XHRcIm1heEJvbmVzXCIsIFwidXNlVmVydGV4VGV4dHVyZVwiLCBcIm1vcnBoVGFyZ2V0c1wiLCBcIm1vcnBoTm9ybWFsc1wiLFxuXHRcdFwibWF4TW9ycGhUYXJnZXRzXCIsIFwibWF4TW9ycGhOb3JtYWxzXCIsIFwicHJlbXVsdGlwbGllZEFscGhhXCIsXG5cdFx0XCJudW1EaXJMaWdodHNcIiwgXCJudW1Qb2ludExpZ2h0c1wiLCBcIm51bVNwb3RMaWdodHNcIiwgXCJudW1IZW1pTGlnaHRzXCIsIFwibnVtUmVjdEFyZWFMaWdodHNcIixcblx0XHRcInNoYWRvd01hcEVuYWJsZWRcIiwgXCJzaGFkb3dNYXBUeXBlXCIsIFwidG9uZU1hcHBpbmdcIiwgJ3BoeXNpY2FsbHlDb3JyZWN0TGlnaHRzJyxcblx0XHRcImFscGhhVGVzdFwiLCBcImRvdWJsZVNpZGVkXCIsIFwiZmxpcFNpZGVkXCIsIFwibnVtQ2xpcHBpbmdQbGFuZXNcIiwgXCJudW1DbGlwSW50ZXJzZWN0aW9uXCIsIFwiZGVwdGhQYWNraW5nXCJcblx0XTtcblxuXG5cdGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMoIG9iamVjdCApIHtcblxuXHRcdGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0cmV0dXJuIDEwMjQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcblx0XHRcdC8vXG5cdFx0XHQvLyAgLSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xuXHRcdFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXG5cdFx0XHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXG5cblx0XHRcdHZhciBuVmVydGV4VW5pZm9ybXMgPSBjYXBhYmlsaXRpZXMubWF4VmVydGV4VW5pZm9ybXM7XG5cdFx0XHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xuXG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XG5cblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgKG9iamVjdCAmJiBvYmplY3QuaXNTa2lubmVkTWVzaCkgKSB7XG5cblx0XHRcdFx0bWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcblxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRvbyBtYW55IGJvbmVzIC0gJyArIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0ICcgKyBtYXhCb25lcyArICcgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSknICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXhCb25lcztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWFwLCBnYW1tYU92ZXJyaWRlTGluZWFyICkge1xuXG5cdFx0dmFyIGVuY29kaW5nO1xuXG5cdFx0aWYgKCAhIG1hcCApIHtcblxuXHRcdFx0ZW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcblxuXHRcdH0gZWxzZSBpZiAoIG1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGVuY29kaW5nID0gbWFwLmVuY29kaW5nO1xuXG5cdFx0fSBlbHNlIGlmICggbWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFByb2dyYW1zLmdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXA6IGRvbid0IHVzZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXCIgKTtcblx0XHRcdGVuY29kaW5nID0gbWFwLnRleHR1cmUuZW5jb2Rpbmc7XG5cblx0XHR9XG5cblx0XHQvLyBhZGQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIFdlYkdMUmVuZGVyZXIuZ2FtbWFJbnB1dC9nYW1tYU91dHB1dCBwYXJhbWV0ZXIsIHNob3VsZCBwcm9iYWJseSBiZSByZW1vdmVkIGF0IHNvbWUgcG9pbnQuXG5cdFx0aWYgKCBlbmNvZGluZyA9PT0gTGluZWFyRW5jb2RpbmcgJiYgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcblxuXHRcdFx0ZW5jb2RpbmcgPSBHYW1tYUVuY29kaW5nO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVuY29kaW5nO1xuXG5cdH1cblxuXHR0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgbkNsaXBQbGFuZXMsIG5DbGlwSW50ZXJzZWN0aW9uLCBvYmplY3QgKSB7XG5cblx0XHR2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcblxuXHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG5cdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuXHRcdHZhciBtYXhCb25lcyA9IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApO1xuXHRcdHZhciBwcmVjaXNpb24gPSByZW5kZXJlci5nZXRQcmVjaXNpb24oKTtcblxuXHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcblxuXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0ge1xuXG5cdFx0XHRzaGFkZXJJRDogc2hhZGVySUQsXG5cblx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxuXHRcdFx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLFxuXHRcdFx0b3V0cHV0RW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoICggISBjdXJyZW50UmVuZGVyVGFyZ2V0ICkgPyBudWxsIDogY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlLCByZW5kZXJlci5nYW1tYU91dHB1dCApLFxuXHRcdFx0bWFwOiAhISBtYXRlcmlhbC5tYXAsXG5cdFx0XHRtYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwubWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXG5cdFx0XHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcblx0XHRcdGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcblx0XHRcdGVudk1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXRlcmlhbC5lbnZNYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcblx0XHRcdGVudk1hcEN1YmVVVjogKCAhISBtYXRlcmlhbC5lbnZNYXAgKSAmJiAoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgfHwgKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgKSApLFxuXHRcdFx0bGlnaHRNYXA6ICEhIG1hdGVyaWFsLmxpZ2h0TWFwLFxuXHRcdFx0YW9NYXA6ICEhIG1hdGVyaWFsLmFvTWFwLFxuXHRcdFx0ZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxuXHRcdFx0ZW1pc3NpdmVNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW1pc3NpdmVNYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcblx0XHRcdGJ1bXBNYXA6ICEhIG1hdGVyaWFsLmJ1bXBNYXAsXG5cdFx0XHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcblx0XHRcdGRpc3BsYWNlbWVudE1hcDogISEgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuXHRcdFx0cm91Z2huZXNzTWFwOiAhISBtYXRlcmlhbC5yb3VnaG5lc3NNYXAsXG5cdFx0XHRtZXRhbG5lc3NNYXA6ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcCxcblx0XHRcdHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcblx0XHRcdGFscGhhTWFwOiAhISBtYXRlcmlhbC5hbHBoYU1hcCxcblxuXHRcdFx0Z3JhZGllbnRNYXA6ICEhIG1hdGVyaWFsLmdyYWRpZW50TWFwLFxuXG5cdFx0XHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxuXG5cdFx0XHR2ZXJ0ZXhDb2xvcnM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyxcblxuXHRcdFx0Zm9nOiAhISBmb2csXG5cdFx0XHR1c2VGb2c6IG1hdGVyaWFsLmZvZyxcblx0XHRcdGZvZ0V4cDogKGZvZyAmJiBmb2cuaXNGb2dFeHAyKSxcblxuXHRcdFx0ZmxhdFNoYWRpbmc6IG1hdGVyaWFsLnNoYWRpbmcgPT09IEZsYXRTaGFkaW5nLFxuXG5cdFx0XHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcblx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG5cdFx0XHRza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcsXG5cdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXG5cdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlLFxuXG5cdFx0XHRtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcblx0XHRcdG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxuXHRcdFx0bWF4TW9ycGhUYXJnZXRzOiByZW5kZXJlci5tYXhNb3JwaFRhcmdldHMsXG5cdFx0XHRtYXhNb3JwaE5vcm1hbHM6IHJlbmRlcmVyLm1heE1vcnBoTm9ybWFscyxcblxuXHRcdFx0bnVtRGlyTGlnaHRzOiBsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoLFxuXHRcdFx0bnVtUG9pbnRMaWdodHM6IGxpZ2h0cy5wb2ludC5sZW5ndGgsXG5cdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXG5cdFx0XHRudW1SZWN0QXJlYUxpZ2h0czogbGlnaHRzLnJlY3RBcmVhLmxlbmd0aCxcblx0XHRcdG51bUhlbWlMaWdodHM6IGxpZ2h0cy5oZW1pLmxlbmd0aCxcblxuXHRcdFx0bnVtQ2xpcHBpbmdQbGFuZXM6IG5DbGlwUGxhbmVzLFxuXHRcdFx0bnVtQ2xpcEludGVyc2VjdGlvbjogbkNsaXBJbnRlcnNlY3Rpb24sXG5cblx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIGxpZ2h0cy5zaGFkb3dzLmxlbmd0aCA+IDAsXG5cdFx0XHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcblxuXHRcdFx0dG9uZU1hcHBpbmc6IHJlbmRlcmVyLnRvbmVNYXBwaW5nLFxuXHRcdFx0cGh5c2ljYWxseUNvcnJlY3RMaWdodHM6IHJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzLFxuXG5cdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcblxuXHRcdFx0YWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXG5cdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSxcblx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUsXG5cblx0XHRcdGRlcHRoUGFja2luZzogKCBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwuZGVwdGhQYWNraW5nIDogZmFsc2VcblxuXHRcdH07XG5cblx0XHRyZXR1cm4gcGFyYW1ldGVycztcblxuXHR9O1xuXG5cdHRoaXMuZ2V0UHJvZ3JhbUNvZGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cblx0XHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc2hhZGVySUQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyICk7XG5cdFx0XHRhcnJheS5wdXNoKCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5kZWZpbmVzICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG5hbWUgKTtcblx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWwuZGVmaW5lc1sgbmFtZSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBhcmFtZXRlck5hbWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0YXJyYXkucHVzaCggcGFyYW1ldGVyc1sgcGFyYW1ldGVyTmFtZXNbIGkgXSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyYXkuam9pbigpO1xuXG5cdH07XG5cblx0dGhpcy5hY3F1aXJlUHJvZ3JhbSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHBhcmFtZXRlcnMsIGNvZGUgKSB7XG5cblx0XHR2YXIgcHJvZ3JhbTtcblxuXHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuXHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcblxuXHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcblxuXHRcdFx0aWYgKCBwcm9ncmFtSW5mby5jb2RlID09PSBjb2RlICkge1xuXG5cdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtSW5mbztcblx0XHRcdFx0KysgcHJvZ3JhbS51c2VkVGltZXM7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwcm9ncmFtID0gbmV3IFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XG5cdFx0XHRwcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHR9O1xuXG5cdHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiggcHJvZ3JhbSApIHtcblxuXHRcdGlmICggLS0gcHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBmcm9tIHVub3JkZXJlZCBzZXRcblx0XHRcdHZhciBpID0gcHJvZ3JhbXMuaW5kZXhPZiggcHJvZ3JhbSApO1xuXHRcdFx0cHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XG5cdFx0XHRwcm9ncmFtcy5wb3AoKTtcblxuXHRcdFx0Ly8gRnJlZSBXZWJHTCByZXNvdXJjZXNcblx0XHRcdHByb2dyYW0uZGVzdHJveSgpO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRXhwb3NlZCBmb3IgcmVzb3VyY2UgbW9uaXRvcmluZyAmIGVycm9yIGZlZWRiYWNrIHZpYSByZW5kZXJlci5pbmZvOlxuXHR0aGlzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFdlYkdMR2VvbWV0cmllcyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XG5cblx0dmFyIGdlb21ldHJpZXMgPSB7fTtcblxuXHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XG5cdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdGlmICggYnVmZmVyZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGRlbGV0ZUF0dHJpYnV0ZSggYnVmZmVyZ2VvbWV0cnkuaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdGRlbGV0ZUF0dHJpYnV0ZXMoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKTtcblxuXHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0Ly8gVE9ET1xuXG5cdFx0dmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XG5cblx0XHRpZiAoIHByb3BlcnR5LndpcmVmcmFtZSApIHtcblxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBwcm9wZXJ0eS53aXJlZnJhbWUgKTtcblxuXHRcdH1cblxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBnZW9tZXRyeSApO1xuXG5cdFx0dmFyIGJ1ZmZlcnByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGJ1ZmZlcmdlb21ldHJ5ICk7XG5cblx0XHRpZiAoIGJ1ZmZlcnByb3BlcnR5LndpcmVmcmFtZSApIHtcblxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJwcm9wZXJ0eS53aXJlZnJhbWUgKTtcblxuXHRcdH1cblxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBidWZmZXJnZW9tZXRyeSApO1xuXG5cdFx0Ly9cblxuXHRcdGluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0dmFyIGJ1ZmZlciA9IGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICk7XG5cblx0XHRpZiAoIGJ1ZmZlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRnbC5kZWxldGVCdWZmZXIoIGJ1ZmZlciApO1xuXHRcdFx0cmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0cHJvcGVydGllcy5kZWxldGUoIGF0dHJpYnV0ZS5kYXRhICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblxuXHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gPSBidWZmZXJnZW9tZXRyeTtcblxuXHRcdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcblxuXHRcdFx0cmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFdlYkdMT2JqZWN0cyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XG5cblx0dmFyIGdlb21ldHJpZXMgPSBuZXcgV2ViR0xHZW9tZXRyaWVzKCBnbCwgcHJvcGVydGllcywgaW5mbyApO1xuXG5cdC8vXG5cblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XG5cblx0XHQvLyBUT0RPOiBBdm9pZCB1cGRhdGluZyB0d2ljZSAod2hlbiB1c2luZyBzaGFkb3dNYXApLiBNYXliZSBhZGQgZnJhbWUgY291bnRlci5cblxuXHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QgKTtcblxuXHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdGdlb21ldHJ5LnVwZGF0ZUZyb21PYmplY3QoIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dXBkYXRlQXR0cmlidXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIHRhcmdldHNcblxuXHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHR2YXIgZGF0YSA9ICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggZGF0YSApO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cblx0XHR9IGVsc2UgaWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gIT09IGRhdGEudmVyc2lvbiApIHtcblxuXHRcdFx0dXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApIHtcblxuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xuXG5cdFx0dmFyIHVzYWdlID0gZGF0YS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XG5cblx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLmFycmF5LCB1c2FnZSApO1xuXG5cdFx0dmFyIHR5cGUgPSBnbC5GTE9BVDtcblx0XHR2YXIgYXJyYXkgPSBkYXRhLmFycmF5O1xuXG5cdFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcblxuXHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggXCJVbnN1cHBvcnRlZCBkYXRhIGJ1ZmZlciBmb3JtYXQ6IEZsb2F0NjRBcnJheVwiICk7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfU0hPUlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5TSE9SVDtcblxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5JTlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSApIHtcblxuXHRcdFx0dHlwZSA9IGdsLkJZVEU7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXG5cdFx0fVxuXG5cdFx0YXR0cmlidXRlUHJvcGVydGllcy5ieXRlc1BlckVsZW1lbnQgPSBhcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRhdHRyaWJ1dGVQcm9wZXJ0aWVzLnR5cGUgPSB0eXBlO1xuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcblxuXHRcdGRhdGEub25VcGxvYWRDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcblxuXHRcdGlmICggZGF0YS5keW5hbWljID09PSBmYWxzZSApIHtcblxuXHRcdFx0Z2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgZGF0YS5hcnJheSwgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcblxuXHRcdFx0Ly8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcblxuXHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgZGF0YS5hcnJheSApO1xuXG5cdFx0fSBlbHNlIGlmICggZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMT2JqZWN0cy51cGRhdGVCdWZmZXI6IGR5bmFtaWMgVEhSRUUuQnVmZmVyQXR0cmlidXRlIG1hcmtlZCBhcyBuZWVkc1VwZGF0ZSBidXQgdXBkYXRlUmFuZ2UuY291bnQgaXMgMCwgZW5zdXJlIHlvdSBhcmUgdXNpbmcgc2V0IG1ldGhvZHMgb3IgdXBkYXRpbmcgbWFudWFsbHkuJyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuXHRcdFx0XHRcdFx0XHQgIGRhdGEuYXJyYXkuc3ViYXJyYXkoIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0LCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCArIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID0gMDsgLy8gcmVzZXQgcmFuZ2VcblxuXHRcdH1cblxuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlUHJvcGVydGllcyggYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcblxuXHRcdHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG5cdFx0aWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIHByb3BlcnR5LndpcmVmcmFtZTtcblxuXHRcdH1cblxuXHRcdHZhciBpbmRpY2VzID0gW107XG5cblx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBjb25zb2xlLnRpbWUoICd3aXJlZnJhbWUnICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdHZhciBhID0gYXJyYXlbIGkgKyAwIF07XG5cdFx0XHRcdHZhciBiID0gYXJyYXlbIGkgKyAxIF07XG5cdFx0XHRcdHZhciBjID0gYXJyYXlbIGkgKyAyIF07XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2YXIgYSA9IGkgKyAwO1xuXHRcdFx0XHR2YXIgYiA9IGkgKyAxO1xuXHRcdFx0XHR2YXIgYyA9IGkgKyAyO1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjb25zb2xlLnRpbWVFbmQoICd3aXJlZnJhbWUnICk7XG5cblx0XHR2YXIgYXR0cmlidXRlID0gbmV3ICggYXJyYXlNYXgoIGluZGljZXMgKSA+IDY1NTM1ID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGljZXMsIDEgKTtcblxuXHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xuXG5cdFx0cHJvcGVydHkud2lyZWZyYW1lID0gYXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGdldEF0dHJpYnV0ZUJ1ZmZlcjogZ2V0QXR0cmlidXRlQnVmZmVyLFxuXHRcdGdldEF0dHJpYnV0ZVByb3BlcnRpZXM6IGdldEF0dHJpYnV0ZVByb3BlcnRpZXMsXG5cdFx0Z2V0V2lyZWZyYW1lQXR0cmlidXRlOiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUsXG5cblx0XHR1cGRhdGU6IHVwZGF0ZVxuXG5cdH07XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFdlYkdMVGV4dHVyZXMoIF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgcGFyYW1UaHJlZVRvR0wsIGluZm8gKSB7XG5cblx0dmFyIF9pbmZvTWVtb3J5ID0gaW5mby5tZW1vcnk7XG5cdHZhciBfaXNXZWJHTDIgPSAoIHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBfZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICk7XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSggaW1hZ2UsIG1heFNpemUgKSB7XG5cblx0XHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG5cdFx0XHQvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxuXHRcdFx0Ly8gcHJlbXVsdGlwbGllZCBhbHBoYS5cblxuXHRcdFx0dmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBzY2FsZSApO1xuXG5cdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuXHRcdFx0cmV0dXJuIGNhbnZhcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNQb3dlck9mVHdvKCBpbWFnZSApIHtcblxuXHRcdHJldHVybiBfTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgX01hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZVBvd2VyT2ZUd28oIGltYWdlICkge1xuXG5cdFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHtcblxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gX01hdGgubmVhcmVzdFBvd2VyT2ZUd28oIGltYWdlLndpZHRoICk7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gX01hdGgubmVhcmVzdFBvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyBub3QgcG93ZXIgb2YgdHdvICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuXHRcdFx0cmV0dXJuIGNhbnZhcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcblxuXHRcdHJldHVybiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHx8XG5cdFx0XHQoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKTtcblxuXHR9XG5cblx0Ly8gRmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcblxuXHRmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayggZiApIHtcblxuXHRcdGlmICggZiA9PT0gTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcblxuXG5cdH1cblxuXHRmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG5cdFx0ZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuXHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXG5cblx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAyRCB0ZXh0dXJlXG5cblx0XHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0XHR9XG5cblx0XHQvLyByZW1vdmUgYWxsIHdlYmdsIHByb3BlcnRpZXNcblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggdGV4dHVyZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblxuXHRcdGlmICggISByZW5kZXJUYXJnZXQgKSByZXR1cm47XG5cblx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICkgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICkgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQgKTtcblxuXHR9XG5cblx0Ly9cblxuXG5cblx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuXHRcdFx0dmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuXHRcdFx0aWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnLCB0ZXh0dXJlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdFx0aWYgKCAhIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdFx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cblx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9ICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKTtcblx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSAoIHRleHR1cmUuaW1hZ2VbIDAgXSAmJiB0ZXh0dXJlLmltYWdlWyAwIF0uaXNEYXRhVGV4dHVyZSApO1xuXG5cdFx0XHRcdHZhciBjdWJlSW1hZ2UgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIGlzQ29tcHJlc3NlZCAmJiAhIGlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdGN1YmVJbWFnZVsgaSBdID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2VbIGkgXSwgY2FwYWJpbGl0aWVzLm1heEN1YmVtYXBTaXplICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlWyBpIF0uaW1hZ2UgOiB0ZXh0dXJlLmltYWdlWyBpIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpbWFnZSA9IGN1YmVJbWFnZVsgMCBdLFxuXHRcdFx0XHRpc1Bvd2VyT2ZUd29JbWFnZSA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcblx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcblx0XHRcdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIGlzQ29tcHJlc3NlZCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgY3ViZUltYWdlWyBpIF0ud2lkdGgsIGN1YmVJbWFnZVsgaSBdLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0uZGF0YSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGogXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0VGV4dHVyZUN1YmUoKVwiICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xuXG5cdFx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkge1xuXG5cdFx0dmFyIGV4dGVuc2lvbjtcblxuXHRcdGlmICggaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicsIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cblx0XHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJywgdGV4dHVyZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApID09PSBudWxsICkgcmV0dXJuO1xuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcblxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyZiggdGV4dHVyZVR5cGUsIGV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oIHRleHR1cmUuYW5pc290cm9weSwgY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XG5cdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xuXG5cdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cblx0XHR2YXIgaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XG5cblx0XHRpZiAoIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSAmJiBpc1Bvd2VyT2ZUd28oIGltYWdlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpbWFnZSA9IG1ha2VQb3dlck9mVHdvKCBpbWFnZSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGlzUG93ZXJPZlR3b0ltYWdlID0gaXNQb3dlck9mVHdvKCBpbWFnZSApLFxuXHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG5cdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xuXG5cdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuXHRcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0Ly8gcG9wdWxhdGUgZGVwdGggdGV4dHVyZSB3aXRoIGR1bW15IGRhdGFcblxuXHRcdFx0dmFyIGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSApIHtcblxuXHRcdFx0XHRpZiAoICFfaXNXZWJHTDIgKSB0aHJvdyBuZXcgRXJyb3IoJ0Zsb2F0IERlcHRoIFRleHR1cmUgb25seSBzdXBwb3J0ZWQgaW4gV2ViR0wyLjAnKTtcblx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBfaXNXZWJHTDIgKSB7XG5cblx0XHRcdFx0Ly8gV2ViR0wgMi4wIHJlcXVpcmVzIHNpZ25lZCBpbnRlcm5hbGZvcm1hdCBmb3IgZ2xUZXhJbWFnZTJEXG5cdFx0XHRcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDE2O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgPT09IERlcHRoRm9ybWF0ICYmIGludGVybmFsRm9ybWF0ID09PSBfZ2wuREVQVEhfQ09NUE9ORU5UICkge1xuXG5cdFx0XHRcdC8vIFRoZSBlcnJvciBJTlZBTElEX09QRVJBVElPTiBpcyBnZW5lcmF0ZWQgYnkgdGV4SW1hZ2UyRCBpZiBmb3JtYXQgYW5kIGludGVybmFsZm9ybWF0IGFyZVxuXHRcdFx0XHQvLyBERVBUSF9DT01QT05FTlQgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX1NIT1JUIG9yIFVOU0lHTkVEX0lOVFxuXHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkU2hvcnRUeXBlICYmIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRJbnRUeXBlICkge1xuXG5cdFx0XHRcdCAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkU2hvcnRUeXBlIG9yIFVuc2lnbmVkSW50VHlwZSBmb3IgRGVwdGhGb3JtYXQgRGVwdGhUZXh0dXJlLicgKTtcblxuXHRcdFx0XHRcdHRleHR1cmUudHlwZSA9IFVuc2lnbmVkU2hvcnRUeXBlO1xuXHRcdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVwdGggc3RlbmNpbCB0ZXh0dXJlcyBuZWVkIHRoZSBERVBUSF9TVEVOQ0lMIGludGVybmFsIGZvcm1hdFxuXHRcdFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXG5cdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XG5cblx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfU1RFTkNJTDtcblxuXHRcdFx0XHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcblx0XHRcdFx0Ly8gREVQVEhfU1RFTkNJTCBhbmQgdHlwZSBpcyBub3QgVU5TSUdORURfSU5UXzI0XzhfV0VCR0wuXG5cdFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxuXHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xuXG5cdFx0XHRcdCAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkSW50MjQ4VHlwZSBmb3IgRGVwdGhTdGVuY2lsRm9ybWF0IERlcHRoVGV4dHVyZS4nICk7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG5cdFx0XHRcdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcblx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuXHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cblx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cblx0fVxuXG5cdC8vIFJlbmRlciB0YXJnZXRzXG5cblx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgdGFyZ2V0IHRleHR1cmUgYW5kIGJpbmQgaXQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCApIHtcblxuXHRcdHZhciBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgKTtcblx0XHR2YXIgZ2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgKTtcblx0XHRzdGF0ZS50ZXhJbWFnZTJEKCB0ZXh0dXJlVGFyZ2V0LCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgMCApO1xuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdH1cblxuXHQvLyBTZXR1cCBzdG9yYWdlIGZvciBpbnRlcm5hbCBkZXB0aC9zdGVuY2lsIGJ1ZmZlcnMgYW5kIGJpbmQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuXHRmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRklYTUU6IFdlIGRvbid0IHN1cHBvcnQgIWRlcHRoICFzdGVuY2lsXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdH1cblxuXHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG5cblx0fVxuXG5cdC8vIFNldHVwIHJlc291cmNlcyBmb3IgYSBEZXB0aCBUZXh0dXJlIGZvciBhIEZCTyAobmVlZHMgYW4gZXh0ZW5zaW9uKVxuXHRmdW5jdGlvbiBzZXR1cERlcHRoVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcblx0XHRpZiAoIGlzQ3ViZSApIHRocm93IG5ldyBFcnJvcignRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZCEnKTtcblxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuXHRcdGlmICggISggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvcigncmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFRIUkVFLkRlcHRoVGV4dHVyZScpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBsb2FkIGFuIGVtcHR5IGRlcHRoIHRleHR1cmUgd2l0aCBmcmFtZWJ1ZmZlciBzaXplXG5cdFx0aWYgKCAhcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSB8fFxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHxcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgIT09IHJlbmRlclRhcmdldC5oZWlnaHQgKSB7XG5cdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0c2V0VGV4dHVyZTJEKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLCAwICk7XG5cblx0XHR2YXIgd2ViZ2xEZXB0aFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgKSB7XG5cblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwICk7XG5cblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xuXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdCcpXG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFNldHVwIEdMIHJlc291cmNlcyBmb3IgYSBub24tdGV4dHVyZSBkZXB0aCBidWZmZXJcblx0ZnVuY3Rpb24gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPT09IHRydWUgKTtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldC5kZXB0aFRleHR1cmUgbm90IHN1cHBvcnRlZCBpbiBDdWJlIHJlbmRlciB0YXJnZXRzJyk7XG5cblx0XHRcdHNldHVwRGVwdGhUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHR9XG5cblx0Ly8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9PT0gdHJ1ZSApO1xuXHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xuXG5cdFx0Ly8gU2V0dXAgZnJhbWVidWZmZXJcblxuXHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdH1cblxuXHRcdC8vIFNldHVwIGNvbG9yIGJ1ZmZlclxuXG5cdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xuXHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XG5cblx0XHR9XG5cblx0XHQvLyBTZXR1cCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzXG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0c2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKSAmJlxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJlxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gKHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUpID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcblx0XHRcdHZhciB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xuXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB3ZWJnbFRleHR1cmUgKTtcblx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICk7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCBudWxsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuc2V0VGV4dHVyZTJEID0gc2V0VGV4dHVyZTJEO1xuXHR0aGlzLnNldFRleHR1cmVDdWJlID0gc2V0VGV4dHVyZUN1YmU7XG5cdHRoaXMuc2V0VGV4dHVyZUN1YmVEeW5hbWljID0gc2V0VGV4dHVyZUN1YmVEeW5hbWljO1xuXHR0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gc2V0dXBSZW5kZXJUYXJnZXQ7XG5cdHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xuXG59XG5cbi8qKlxuICogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cbiAqL1xuXG5mdW5jdGlvbiBXZWJHTFByb3BlcnRpZXMoKSB7XG5cblx0dmFyIHByb3BlcnRpZXMgPSB7fTtcblxuXHRyZXR1cm4ge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcblx0XHRcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XG5cblx0XHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWFwID0ge307XG5cdFx0XHRcdHByb3BlcnRpZXNbIHV1aWQgXSA9IG1hcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFwO1xuXG5cdFx0fSxcblxuXHRcdGRlbGV0ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdGRlbGV0ZSBwcm9wZXJ0aWVzWyBvYmplY3QudXVpZCBdO1xuXG5cdFx0fSxcblxuXHRcdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHByb3BlcnRpZXMgPSB7fTtcblxuXHRcdH1cblxuXHR9O1xuXG59XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBXZWJHTFN0YXRlKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKSB7XG5cblx0ZnVuY3Rpb24gQ29sb3JCdWZmZXIoKSB7XG5cblx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XG5cblx0XHR2YXIgY29sb3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdHZhciBjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHR2YXIgY3VycmVudENvbG9yQ2xlYXIgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKCBjb2xvck1hc2sgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgJiYgISBsb2NrZWQgKSB7XG5cblx0XHRcdFx0XHRnbC5jb2xvck1hc2soIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzayApO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBjb2xvck1hc2s7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcblxuXHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCByLCBnLCBiLCBhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cblx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRyICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvci5zZXQoIHIsIGcsIGIsIGEgKTtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRDb2xvckNsZWFyLmVxdWFscyggY29sb3IgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG5cdFx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuY29weSggY29sb3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cblx0XHRcdFx0Y3VycmVudENvbG9yTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBEZXB0aEJ1ZmZlcigpIHtcblxuXHRcdHZhciBsb2NrZWQgPSBmYWxzZTtcblxuXHRcdHZhciBjdXJyZW50RGVwdGhNYXNrID0gbnVsbDtcblx0XHR2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHRcdFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggZGVwdGhNYXNrICkge1xuXG5cdFx0XHRcdGlmICggY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICYmICEgbG9ja2VkICkge1xuXG5cdFx0XHRcdFx0Z2wuZGVwdGhNYXNrKCBkZXB0aE1hc2sgKTtcblx0XHRcdFx0XHRjdXJyZW50RGVwdGhNYXNrID0gZGVwdGhNYXNrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGRlcHRoRnVuYyApIHtcblxuXHRcdFx0XHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgTmV2ZXJEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIEFsd2F5c0RlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIExlc3NEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgTGVzc0VxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgRXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgTm90RXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcblxuXHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCBkZXB0aCApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnREZXB0aENsZWFyICE9PSBkZXB0aCApIHtcblxuXHRcdFx0XHRcdGdsLmNsZWFyRGVwdGgoIGRlcHRoICk7XG5cdFx0XHRcdFx0Y3VycmVudERlcHRoQ2xlYXIgPSBkZXB0aDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cblx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFN0ZW5jaWxCdWZmZXIoKSB7XG5cblx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XG5cblx0XHR2YXIgY3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcblx0XHR2YXIgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcblx0XHR2YXIgY3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcblx0XHR2YXIgY3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcblx0XHR2YXIgY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uICggc3RlbmNpbFRlc3QgKSB7XG5cblx0XHRcdFx0aWYgKCBzdGVuY2lsVGVzdCApIHtcblxuXHRcdFx0XHRcdGVuYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGRpc2FibGUoIGdsLlNURU5DSUxfVEVTVCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKCBzdGVuY2lsTWFzayApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsTWFzayAhPT0gc3RlbmNpbE1hc2sgJiYgISBsb2NrZWQgKSB7XG5cblx0XHRcdFx0XHRnbC5zdGVuY2lsTWFzayggc3RlbmNpbE1hc2sgKTtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbE1hc2sgPSBzdGVuY2lsTWFzaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldEZ1bmM6IGZ1bmN0aW9uICggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxGdW5jICE9PSBzdGVuY2lsRnVuYyB8fFxuXHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsUmVmIFx0IT09IHN0ZW5jaWxSZWYgXHR8fFxuXHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgIT09IHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0XHRcdFx0Z2wuc3RlbmNpbEZ1bmMoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApO1xuXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gc3RlbmNpbEZ1bmM7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBzdGVuY2lsTWFzaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldE9wOiBmdW5jdGlvbiAoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsRmFpbFx0ICE9PSBzdGVuY2lsRmFpbCBcdHx8XG5cdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxaRmFpbCAhPT0gc3RlbmNpbFpGYWlsIHx8XG5cdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xuXG5cdFx0XHRcdFx0Z2wuc3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKTtcblxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IHN0ZW5jaWxGYWlsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaUGFzcyA9IHN0ZW5jaWxaUGFzcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xuXG5cdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIHN0ZW5jaWwgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbENsZWFyICE9PSBzdGVuY2lsICkge1xuXG5cdFx0XHRcdFx0Z2wuY2xlYXJTdGVuY2lsKCBzdGVuY2lsICk7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IHN0ZW5jaWw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdC8vXG5cblx0dmFyIGNvbG9yQnVmZmVyID0gbmV3IENvbG9yQnVmZmVyKCk7XG5cdHZhciBkZXB0aEJ1ZmZlciA9IG5ldyBEZXB0aEJ1ZmZlcigpO1xuXHR2YXIgc3RlbmNpbEJ1ZmZlciA9IG5ldyBTdGVuY2lsQnVmZmVyKCk7XG5cblx0dmFyIG1heFZlcnRleEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xuXHR2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XG5cdHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XG5cdHZhciBhdHRyaWJ1dGVEaXZpc29ycyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XG5cblx0dmFyIGNhcGFiaWxpdGllcyA9IHt9O1xuXG5cdHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG5cdHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuXHR2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0dmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblx0dmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0dmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblx0dmFyIGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuXG5cdHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0dmFyIGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG5cblx0dmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xuXG5cdHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG5cdHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcblxuXHR2YXIgY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbDtcblxuXHR2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cblx0dmFyIHZlcnNpb24gPSBwYXJzZUZsb2F0KCAvXldlYkdMXFwgKFswLTldKS8uZXhlYyggZ2wuZ2V0UGFyYW1ldGVyKCBnbC5WRVJTSU9OICkgKVsgMSBdICk7XG5cdHZhciBsaW5lV2lkdGhBdmFpbGFibGUgPSBwYXJzZUZsb2F0KCB2ZXJzaW9uICkgPj0gMS4wO1xuXG5cdHZhciBjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xuXHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuXHR2YXIgY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xuXHR2YXIgY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKCB0eXBlLCB0YXJnZXQsIGNvdW50ICkge1xuXG5cdFx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggNCApOyAvLyA0IGlzIHJlcXVpcmVkIHRvIG1hdGNoIGRlZmF1bHQgdW5wYWNrIGFsaWdubWVudCBvZiA0LlxuXHRcdHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoIHR5cGUsIHRleHR1cmUgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHRnbC50ZXhJbWFnZTJEKCB0YXJnZXQgKyBpLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cblx0dmFyIGVtcHR5VGV4dHVyZXMgPSB7fTtcblx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV8yRCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV8yRCwgMSApO1xuXHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFX0NVQkVfTUFQIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDYgKTtcblxuXHQvL1xuXG5cdGZ1bmN0aW9uIGluaXQoKSB7XG5cblx0XHRjb2xvckJ1ZmZlci5zZXRDbGVhciggMCwgMCwgMCwgMSApO1xuXHRcdGRlcHRoQnVmZmVyLnNldENsZWFyKCAxICk7XG5cdFx0c3RlbmNpbEJ1ZmZlci5zZXRDbGVhciggMCApO1xuXG5cdFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cdFx0c2V0RGVwdGhGdW5jKCBMZXNzRXF1YWxEZXB0aCApO1xuXG5cdFx0c2V0RmxpcFNpZGVkKCBmYWxzZSApO1xuXHRcdHNldEN1bGxGYWNlKCBDdWxsRmFjZUJhY2sgKTtcblx0XHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0ZW5hYmxlKCBnbC5CTEVORCApO1xuXHRcdHNldEJsZW5kaW5nKCBOb3JtYWxCbGVuZGluZyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpbml0QXR0cmlidXRlcygpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cblx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuXHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdH1cblxuXHRcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSAwICkge1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0XHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIDAgKTtcblx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICkge1xuXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XG5cblx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cblx0XHR9XG5cblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlICk7XG5cdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gPSBtZXNoUGVyQXR0cmlidXRlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSAhPT0gbDsgKysgaSApIHtcblxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XG5cblx0XHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZSggaWQgKSB7XG5cblx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xuXHRcdFx0Y2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzYWJsZSggaWQgKSB7XG5cblx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdGdsLmRpc2FibGUoIGlkICk7XG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkge1xuXG5cdFx0aWYgKCBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XG5cdFx0XHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHxcblx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKSApIHtcblxuXHRcdFx0XHR2YXIgZm9ybWF0cyA9IGdsLmdldFBhcmFtZXRlciggZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmb3JtYXRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEJsZW5kaW5nKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdGlmICggYmxlbmRpbmcgIT09IE5vQmxlbmRpbmcgKSB7XG5cblx0XHRcdGVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRpc2FibGUoIGdsLkJMRU5EICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgKSB7XG5cblx0XHRcdGlmICggYmxlbmRpbmcgPT09IEFkZGl0aXZlQmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cblx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuXHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gU3VidHJhY3RpdmVCbGVuZGluZyApIHtcblxuXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG5cdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBNdWx0aXBseUJsZW5kaW5nICkge1xuXG5cdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG5cdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5TUkNfQUxQSEEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG5cdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG5cdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXHRcdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBibGVuZGluZyA9PT0gQ3VzdG9tQmxlbmRpbmcgKSB7XG5cblx0XHRcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuXHRcdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG5cdFx0XHRibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcblxuXHRcdFx0aWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cblx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcblxuXHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XG5cdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XG5cblx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjQWxwaGEgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0QWxwaGEgKSApO1xuXG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuXHRcdFx0XHRjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcblx0XHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuXHRcdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcblx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFRPRE8gRGVwcmVjYXRlXG5cblx0ZnVuY3Rpb24gc2V0Q29sb3JXcml0ZSggY29sb3JXcml0ZSApIHtcblxuXHRcdGNvbG9yQnVmZmVyLnNldE1hc2soIGNvbG9yV3JpdGUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RGVwdGhUZXN0KCBkZXB0aFRlc3QgKSB7XG5cblx0XHRkZXB0aEJ1ZmZlci5zZXRUZXN0KCBkZXB0aFRlc3QgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RGVwdGhXcml0ZSggZGVwdGhXcml0ZSApIHtcblxuXHRcdGRlcHRoQnVmZmVyLnNldE1hc2soIGRlcHRoV3JpdGUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RGVwdGhGdW5jKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRkZXB0aEJ1ZmZlci5zZXRGdW5jKCBkZXB0aEZ1bmMgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U3RlbmNpbFRlc3QoIHN0ZW5jaWxUZXN0ICkge1xuXG5cdFx0c3RlbmNpbEJ1ZmZlci5zZXRUZXN0KCBzdGVuY2lsVGVzdCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTdGVuY2lsV3JpdGUoIHN0ZW5jaWxXcml0ZSApIHtcblxuXHRcdHN0ZW5jaWxCdWZmZXIuc2V0TWFzayggc3RlbmNpbFdyaXRlICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XG5cblx0XHRzdGVuY2lsQnVmZmVyLnNldEZ1bmMoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTdGVuY2lsT3AoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApIHtcblxuXHRcdHN0ZW5jaWxCdWZmZXIuc2V0T3AoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHNldEZsaXBTaWRlZCggZmxpcFNpZGVkICkge1xuXG5cdFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XG5cblx0XHRcdGlmICggZmxpcFNpZGVkICkge1xuXG5cdFx0XHRcdGdsLmZyb250RmFjZSggZ2wuQ1cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEN1bGxGYWNlKCBjdWxsRmFjZSApIHtcblxuXHRcdGlmICggY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSApIHtcblxuXHRcdFx0ZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0aWYgKCBjdWxsRmFjZSAhPT0gY3VycmVudEN1bGxGYWNlICkge1xuXG5cdFx0XHRcdGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjayApIHtcblxuXHRcdFx0XHRcdGdsLmN1bGxGYWNlKCBnbC5CQUNLICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlRnJvbnQgKSB7XG5cblx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuRlJPTlQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UX0FORF9CQUNLICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRkaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdH1cblxuXHRcdGN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMaW5lV2lkdGgoIHdpZHRoICkge1xuXG5cdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcblxuXHRcdFx0aWYgKCBsaW5lV2lkdGhBdmFpbGFibGUgKSBnbC5saW5lV2lkdGgoIHdpZHRoICk7XG5cblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0UG9seWdvbk9mZnNldCggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcblxuXHRcdGlmICggcG9seWdvbk9mZnNldCApIHtcblxuXHRcdFx0ZW5hYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cblx0XHRcdGlmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApIHtcblxuXHRcdFx0XHRnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XG5cblx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG5cdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTY2lzc29yVGVzdCgpIHtcblxuXHRcdHJldHVybiBjdXJyZW50U2Npc3NvclRlc3Q7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNjaXNzb3JUZXN0KCBzY2lzc29yVGVzdCApIHtcblxuXHRcdGN1cnJlbnRTY2lzc29yVGVzdCA9IHNjaXNzb3JUZXN0O1xuXG5cdFx0aWYgKCBzY2lzc29yVGVzdCApIHtcblxuXHRcdFx0ZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyB0ZXh0dXJlXG5cblx0ZnVuY3Rpb24gYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICkge1xuXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xuXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcblxuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG5cdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApIHtcblxuXHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ID09PSBudWxsICkge1xuXG5cdFx0XHRhY3RpdmVUZXh0dXJlKCk7XG5cblx0XHR9XG5cblx0XHR2YXIgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdO1xuXG5cdFx0aWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdID0gYm91bmRUZXh0dXJlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSB8fCBlbXB0eVRleHR1cmVzWyB3ZWJnbFR5cGUgXSApO1xuXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcblx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4SW1hZ2UyRCgpIHtcblxuXHRcdHRyeSB7XG5cblx0XHRcdGdsLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRleEltYWdlMkQoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC50ZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gc2Npc3Nvciggc2Npc3NvciApIHtcblxuXHRcdGlmICggY3VycmVudFNjaXNzb3IuZXF1YWxzKCBzY2lzc29yICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRnbC5zY2lzc29yKCBzY2lzc29yLngsIHNjaXNzb3IueSwgc2Npc3Nvci56LCBzY2lzc29yLncgKTtcblx0XHRcdGN1cnJlbnRTY2lzc29yLmNvcHkoIHNjaXNzb3IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdmlld3BvcnQoIHZpZXdwb3J0ICkge1xuXG5cdFx0aWYgKCBjdXJyZW50Vmlld3BvcnQuZXF1YWxzKCB2aWV3cG9ydCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Z2wudmlld3BvcnQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncgKTtcblx0XHRcdGN1cnJlbnRWaWV3cG9ydC5jb3B5KCB2aWV3cG9ydCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHJlc2V0KCkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XG5cblx0XHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjYXBhYmlsaXRpZXMgPSB7fTtcblxuXHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cblx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xuXHRcdGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cblx0XHRjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXG5cdFx0Y3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cdFx0Y3VycmVudEN1bGxGYWNlID0gbnVsbDtcblxuXHRcdGNvbG9yQnVmZmVyLnJlc2V0KCk7XG5cdFx0ZGVwdGhCdWZmZXIucmVzZXQoKTtcblx0XHRzdGVuY2lsQnVmZmVyLnJlc2V0KCk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRidWZmZXJzOiB7XG5cdFx0XHRjb2xvcjogY29sb3JCdWZmZXIsXG5cdFx0XHRkZXB0aDogZGVwdGhCdWZmZXIsXG5cdFx0XHRzdGVuY2lsOiBzdGVuY2lsQnVmZmVyXG5cdFx0fSxcblxuXHRcdGluaXQ6IGluaXQsXG5cdFx0aW5pdEF0dHJpYnV0ZXM6IGluaXRBdHRyaWJ1dGVzLFxuXHRcdGVuYWJsZUF0dHJpYnV0ZTogZW5hYmxlQXR0cmlidXRlLFxuXHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3I6IGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IsXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXM6IGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzLFxuXHRcdGVuYWJsZTogZW5hYmxlLFxuXHRcdGRpc2FibGU6IGRpc2FibGUsXG5cdFx0Z2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzOiBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsXG5cblx0XHRzZXRCbGVuZGluZzogc2V0QmxlbmRpbmcsXG5cblx0XHRzZXRDb2xvcldyaXRlOiBzZXRDb2xvcldyaXRlLFxuXHRcdHNldERlcHRoVGVzdDogc2V0RGVwdGhUZXN0LFxuXHRcdHNldERlcHRoV3JpdGU6IHNldERlcHRoV3JpdGUsXG5cdFx0c2V0RGVwdGhGdW5jOiBzZXREZXB0aEZ1bmMsXG5cdFx0c2V0U3RlbmNpbFRlc3Q6IHNldFN0ZW5jaWxUZXN0LFxuXHRcdHNldFN0ZW5jaWxXcml0ZTogc2V0U3RlbmNpbFdyaXRlLFxuXHRcdHNldFN0ZW5jaWxGdW5jOiBzZXRTdGVuY2lsRnVuYyxcblx0XHRzZXRTdGVuY2lsT3A6IHNldFN0ZW5jaWxPcCxcblxuXHRcdHNldEZsaXBTaWRlZDogc2V0RmxpcFNpZGVkLFxuXHRcdHNldEN1bGxGYWNlOiBzZXRDdWxsRmFjZSxcblxuXHRcdHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxuXHRcdHNldFBvbHlnb25PZmZzZXQ6IHNldFBvbHlnb25PZmZzZXQsXG5cblx0XHRnZXRTY2lzc29yVGVzdDogZ2V0U2Npc3NvclRlc3QsXG5cdFx0c2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxuXG5cdFx0YWN0aXZlVGV4dHVyZTogYWN0aXZlVGV4dHVyZSxcblx0XHRiaW5kVGV4dHVyZTogYmluZFRleHR1cmUsXG5cdFx0Y29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxuXHRcdHRleEltYWdlMkQ6IHRleEltYWdlMkQsXG5cblx0XHRzY2lzc29yOiBzY2lzc29yLFxuXHRcdHZpZXdwb3J0OiB2aWV3cG9ydCxcblxuXHRcdHJlc2V0OiByZXNldFxuXG5cdH07XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFdlYkdMQ2FwYWJpbGl0aWVzKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApIHtcblxuXHR2YXIgbWF4QW5pc290cm9weTtcblxuXHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXG5cdFx0aWYgKCBtYXhBbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gbWF4QW5pc290cm9weTtcblxuXHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRtYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXhBbmlzb3Ryb3B5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcblxuXHRcdGlmICggcHJlY2lzaW9uID09PSAnaGlnaHAnICkge1xuXG5cdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcblx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG5cdFx0XHRcdHJldHVybiAnaGlnaHAnO1xuXG5cdFx0XHR9XG5cblx0XHRcdHByZWNpc2lvbiA9ICdtZWRpdW1wJztcblxuXHRcdH1cblxuXHRcdGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XG5cblx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG5cdFx0XHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG5cdFx0XHRcdHJldHVybiAnbWVkaXVtcCc7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiAnbG93cCc7XG5cblx0fVxuXG5cdHZhciBwcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnO1xuXHR2YXIgbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKTtcblxuXHRpZiAoIG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCBwcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIG1heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXHRcdHByZWNpc2lvbiA9IG1heFByZWNpc2lvbjtcblxuXHR9XG5cblx0dmFyIGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPT09IHRydWUgJiYgISEgZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKTtcblxuXHR2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdHZhciBtYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdHZhciBtYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xuXHR2YXIgbWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcblxuXHR2YXIgbWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG5cdHZhciBtYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcblx0dmFyIG1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XG5cdHZhciBtYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XG5cblx0dmFyIHZlcnRleFRleHR1cmVzID0gbWF4VmVydGV4VGV4dHVyZXMgPiAwO1xuXHR2YXIgZmxvYXRGcmFnbWVudFRleHR1cmVzID0gISEgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcblx0dmFyIGZsb2F0VmVydGV4VGV4dHVyZXMgPSB2ZXJ0ZXhUZXh0dXJlcyAmJiBmbG9hdEZyYWdtZW50VGV4dHVyZXM7XG5cblx0cmV0dXJuIHtcblxuXHRcdGdldE1heEFuaXNvdHJvcHk6IGdldE1heEFuaXNvdHJvcHksXG5cdFx0Z2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXG5cblx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG5cdFx0bWF4VGV4dHVyZXM6IG1heFRleHR1cmVzLFxuXHRcdG1heFZlcnRleFRleHR1cmVzOiBtYXhWZXJ0ZXhUZXh0dXJlcyxcblx0XHRtYXhUZXh0dXJlU2l6ZTogbWF4VGV4dHVyZVNpemUsXG5cdFx0bWF4Q3ViZW1hcFNpemU6IG1heEN1YmVtYXBTaXplLFxuXG5cdFx0bWF4QXR0cmlidXRlczogbWF4QXR0cmlidXRlcyxcblx0XHRtYXhWZXJ0ZXhVbmlmb3JtczogbWF4VmVydGV4VW5pZm9ybXMsXG5cdFx0bWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxuXHRcdG1heEZyYWdtZW50VW5pZm9ybXM6IG1heEZyYWdtZW50VW5pZm9ybXMsXG5cblx0XHR2ZXJ0ZXhUZXh0dXJlczogdmVydGV4VGV4dHVyZXMsXG5cdFx0ZmxvYXRGcmFnbWVudFRleHR1cmVzOiBmbG9hdEZyYWdtZW50VGV4dHVyZXMsXG5cdFx0ZmxvYXRWZXJ0ZXhUZXh0dXJlczogZmxvYXRWZXJ0ZXhUZXh0dXJlc1xuXG5cdH07XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFdlYkdMRXh0ZW5zaW9ucyggZ2wgKSB7XG5cblx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuXHRyZXR1cm4ge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2RlcHRoX3RleHR1cmUnOlxuXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XG5cdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnOlxuXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRleHRlbnNpb25zWyBuYW1lIF0gPSBleHRlbnNpb247XG5cblx0XHRcdHJldHVybiBleHRlbnNpb247XG5cblx0XHR9XG5cblx0fTtcblxufVxuXG4vKipcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBXZWJHTENsaXBwaW5nKCkge1xuXG5cdHZhciBzY29wZSA9IHRoaXMsXG5cblx0XHRnbG9iYWxTdGF0ZSA9IG51bGwsXG5cdFx0bnVtR2xvYmFsUGxhbmVzID0gMCxcblx0XHRsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlLFxuXHRcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZSxcblxuXHRcdHBsYW5lID0gbmV3IFBsYW5lKCksXG5cdFx0dmlld05vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCksXG5cblx0XHR1bmlmb3JtID0geyB2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6IGZhbHNlIH07XG5cblx0dGhpcy51bmlmb3JtID0gdW5pZm9ybTtcblx0dGhpcy5udW1QbGFuZXMgPSAwO1xuXHR0aGlzLm51bUludGVyc2VjdGlvbiA9IDA7XG5cblx0dGhpcy5pbml0ID0gZnVuY3Rpb24oIHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZywgY2FtZXJhICkge1xuXG5cdFx0dmFyIGVuYWJsZWQgPVxuXHRcdFx0cGxhbmVzLmxlbmd0aCAhPT0gMCB8fFxuXHRcdFx0ZW5hYmxlTG9jYWxDbGlwcGluZyB8fFxuXHRcdFx0Ly8gZW5hYmxlIHN0YXRlIG9mIHByZXZpb3VzIGZyYW1lIC0gdGhlIGNsaXBwaW5nIGNvZGUgaGFzIHRvXG5cdFx0XHQvLyBydW4gYW5vdGhlciBmcmFtZSBpbiBvcmRlciB0byByZXNldCB0aGUgc3RhdGU6XG5cdFx0XHRudW1HbG9iYWxQbGFuZXMgIT09IDAgfHxcblx0XHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkO1xuXG5cdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBlbmFibGVMb2NhbENsaXBwaW5nO1xuXG5cdFx0Z2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgMCApO1xuXHRcdG51bUdsb2JhbFBsYW5lcyA9IHBsYW5lcy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gZW5hYmxlZDtcblxuXHR9O1xuXG5cdHRoaXMuYmVnaW5TaGFkb3dzID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZW5kZXJpbmdTaGFkb3dzID0gdHJ1ZTtcblx0XHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XG5cblx0fTtcblxuXHR0aGlzLmVuZFNoYWRvd3MgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZTtcblx0XHRyZXNldEdsb2JhbFN0YXRlKCk7XG5cblx0fTtcblxuXHR0aGlzLnNldFN0YXRlID0gZnVuY3Rpb24oIHBsYW5lcywgY2xpcEludGVyc2VjdGlvbiwgY2xpcFNoYWRvd3MsIGNhbWVyYSwgY2FjaGUsIGZyb21DYWNoZSApIHtcblxuXHRcdGlmICggISBsb2NhbENsaXBwaW5nRW5hYmxlZCB8fFxuXHRcdFx0XHRwbGFuZXMgPT09IG51bGwgfHwgcGxhbmVzLmxlbmd0aCA9PT0gMCB8fFxuXHRcdFx0XHRyZW5kZXJpbmdTaGFkb3dzICYmICEgY2xpcFNoYWRvd3MgKSB7XG5cdFx0XHQvLyB0aGVyZSdzIG5vIGxvY2FsIGNsaXBwaW5nXG5cblx0XHRcdGlmICggcmVuZGVyaW5nU2hhZG93cyApIHtcblx0XHRcdFx0Ly8gdGhlcmUncyBubyBnbG9iYWwgY2xpcHBpbmdcblxuXHRcdFx0XHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIG5HbG9iYWwgPSByZW5kZXJpbmdTaGFkb3dzID8gMCA6IG51bUdsb2JhbFBsYW5lcyxcblx0XHRcdFx0bEdsb2JhbCA9IG5HbG9iYWwgKiA0LFxuXG5cdFx0XHRcdGRzdEFycmF5ID0gY2FjaGUuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xuXG5cdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7IC8vIGVuc3VyZSB1bmlxdWUgc3RhdGVcblxuXHRcdFx0ZHN0QXJyYXkgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgbEdsb2JhbCwgZnJvbUNhY2hlICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbEdsb2JhbDsgKysgaSApIHtcblxuXHRcdFx0XHRkc3RBcnJheVsgaSBdID0gZ2xvYmFsU3RhdGVbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjYWNoZS5jbGlwcGluZ1N0YXRlID0gZHN0QXJyYXk7XG5cdFx0XHR0aGlzLm51bUludGVyc2VjdGlvbiA9IGNsaXBJbnRlcnNlY3Rpb24gPyB0aGlzLm51bVBsYW5lcyA6IDA7XG5cdFx0XHR0aGlzLm51bVBsYW5lcyArPSBuR2xvYmFsO1xuXG5cdFx0fVxuXG5cblx0fTtcblxuXHRmdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xuXG5cdFx0aWYgKCB1bmlmb3JtLnZhbHVlICE9PSBnbG9iYWxTdGF0ZSApIHtcblxuXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGdsb2JhbFN0YXRlO1xuXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IG51bUdsb2JhbFBsYW5lcyA+IDA7XG5cblx0XHR9XG5cblx0XHRzY29wZS5udW1QbGFuZXMgPSBudW1HbG9iYWxQbGFuZXM7XG5cdFx0c2NvcGUubnVtSW50ZXJzZWN0aW9uID0gMDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGRzdE9mZnNldCwgc2tpcFRyYW5zZm9ybSApIHtcblxuXHRcdHZhciBuUGxhbmVzID0gcGxhbmVzICE9PSBudWxsID8gcGxhbmVzLmxlbmd0aCA6IDAsXG5cdFx0XHRkc3RBcnJheSA9IG51bGw7XG5cblx0XHRpZiAoIG5QbGFuZXMgIT09IDAgKSB7XG5cblx0XHRcdGRzdEFycmF5ID0gdW5pZm9ybS52YWx1ZTtcblxuXHRcdFx0aWYgKCBza2lwVHJhbnNmb3JtICE9PSB0cnVlIHx8IGRzdEFycmF5ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHZhciBmbGF0U2l6ZSA9IGRzdE9mZnNldCArIG5QbGFuZXMgKiA0LFxuXHRcdFx0XHRcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXG5cdFx0XHRcdHZpZXdOb3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0aWYgKCBkc3RBcnJheSA9PT0gbnVsbCB8fCBkc3RBcnJheS5sZW5ndGggPCBmbGF0U2l6ZSApIHtcblxuXHRcdFx0XHRcdGRzdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggZmxhdFNpemUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpNCA9IGRzdE9mZnNldDtcblx0XHRcdFx0XHRcdFx0XHRcdGkgIT09IG5QbGFuZXM7ICsrIGksIGk0ICs9IDQgKSB7XG5cblx0XHRcdFx0XHRwbGFuZS5jb3B5KCBwbGFuZXNbIGkgXSApLlxuXHRcdFx0XHRcdFx0XHRhcHBseU1hdHJpeDQoIHZpZXdNYXRyaXgsIHZpZXdOb3JtYWxNYXRyaXggKTtcblxuXHRcdFx0XHRcdHBsYW5lLm5vcm1hbC50b0FycmF5KCBkc3RBcnJheSwgaTQgKTtcblx0XHRcdFx0XHRkc3RBcnJheVsgaTQgKyAzIF0gPSBwbGFuZS5jb25zdGFudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5O1xuXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xuXHRcdFxuXHRcdHJldHVybiBkc3RBcnJheTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuZnVuY3Rpb24gV2ViR0xSZW5kZXJlciggcGFyYW1ldGVycyApIHtcblxuXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBSRVZJU0lPTiApO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICksXG5cdFx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cblx0XHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXG5cdFx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG5cdFx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG5cdFx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuXHRcdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuXHRcdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZTtcblxuXHR2YXIgbGlnaHRzID0gW107XG5cblx0dmFyIG9wYXF1ZU9iamVjdHMgPSBbXTtcblx0dmFyIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XG5cdHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcblx0dmFyIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcblxuXHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xuXG5cdHZhciBzcHJpdGVzID0gW107XG5cdHZhciBsZW5zRmxhcmVzID0gW107XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXHR0aGlzLmNvbnRleHQgPSBudWxsO1xuXG5cdC8vIGNsZWFyaW5nXG5cblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcblx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0Ly8gc2NlbmUgZ3JhcGhcblxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuXHQvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcblxuXHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gW107XG5cdHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuXHR0aGlzLmdhbW1hRmFjdG9yID0gMi4wO1x0Ly8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xuXHR0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cblx0Ly8gcGh5c2ljYWwgbGlnaHRzXG5cblx0dGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IGZhbHNlO1xuXG5cdC8vIHRvbmUgbWFwcGluZ1xuXG5cdHRoaXMudG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZztcblx0dGhpcy50b25lTWFwcGluZ0V4cG9zdXJlID0gMS4wO1xuXHR0aGlzLnRvbmVNYXBwaW5nV2hpdGVQb2ludCA9IDEuMDtcblxuXHQvLyBtb3JwaHNcblxuXHR0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XG5cdHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcblxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG5cblx0dmFyIF90aGlzID0gdGhpcyxcblxuXHRcdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cblx0XHRfY3VycmVudFByb2dyYW0gPSBudWxsLFxuXHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbCxcblx0XHRfY3VycmVudEZyYW1lYnVmZmVyID0gbnVsbCxcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDEsXG5cdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJyxcblx0XHRfY3VycmVudENhbWVyYSA9IG51bGwsXG5cblx0XHRfY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpLFxuXHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBudWxsLFxuXG5cdFx0X2N1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCksXG5cblx0XHQvL1xuXG5cdFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxuXG5cdFx0Ly9cblxuXHRcdF9jbGVhckNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApLFxuXHRcdF9jbGVhckFscGhhID0gMCxcblxuXHRcdF93aWR0aCA9IF9jYW52YXMud2lkdGgsXG5cdFx0X2hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXG5cdFx0X3BpeGVsUmF0aW8gPSAxLFxuXG5cdFx0X3NjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICksXG5cdFx0X3NjaXNzb3JUZXN0ID0gZmFsc2UsXG5cblx0XHRfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICksXG5cblx0XHQvLyBmcnVzdHVtXG5cblx0XHRfZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCksXG5cblx0XHQvLyBjbGlwcGluZ1xuXG5cdFx0X2NsaXBwaW5nID0gbmV3IFdlYkdMQ2xpcHBpbmcoKSxcblx0XHRfY2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG5cdFx0X2xvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG5cblx0XHRfc3BoZXJlID0gbmV3IFNwaGVyZSgpLFxuXG5cdFx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cblx0XHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCksXG5cblx0XHRfdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCksXG5cdFx0X21hdHJpeDQgPSBuZXcgTWF0cml4NCgpLFxuXHRcdF9tYXRyaXg0MiA9IG5ldyBNYXRyaXg0KCksXG5cblx0XHQvLyBsaWdodCBhcnJheXMgY2FjaGVcblxuXHRcdF9saWdodHMgPSB7XG5cblx0XHRcdGhhc2g6ICcnLFxuXG5cdFx0YW1iaWVudDogWyAwLCAwLCAwIF0sXG5cdFx0ZGlyZWN0aW9uYWw6IFtdLFxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiBbXSxcblx0XHRkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDogW10sXG5cdFx0c3BvdDogW10sXG5cdFx0c3BvdFNoYWRvd01hcDogW10sXG5cdFx0c3BvdFNoYWRvd01hdHJpeDogW10sXG5cdFx0cmVjdEFyZWE6IFtdLFxuXHRcdHBvaW50OiBbXSxcblx0XHRwb2ludFNoYWRvd01hcDogW10sXG5cdFx0cG9pbnRTaGFkb3dNYXRyaXg6IFtdLFxuXHRcdGhlbWk6IFtdLFxuXG5cdFx0XHRzaGFkb3dzOiBbXVxuXG5cdFx0fSxcblxuXHRcdC8vIGluZm9cblxuXHRcdF9pbmZvUmVuZGVyID0ge1xuXG5cdFx0XHRjYWxsczogMCxcblx0XHRcdHZlcnRpY2VzOiAwLFxuXHRcdFx0ZmFjZXM6IDAsXG5cdFx0XHRwb2ludHM6IDBcblxuXHRcdH07XG5cblx0dGhpcy5pbmZvID0ge1xuXG5cdFx0cmVuZGVyOiBfaW5mb1JlbmRlcixcblx0XHRtZW1vcnk6IHtcblxuXHRcdFx0Z2VvbWV0cmllczogMCxcblx0XHRcdHRleHR1cmVzOiAwXG5cblx0XHR9LFxuXHRcdHByb2dyYW1zOiBudWxsXG5cblx0fTtcblxuXG5cdC8vIGluaXRpYWxpemVcblxuXHR2YXIgX2dsO1xuXG5cdHRyeSB7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHtcblx0XHRcdGFscGhhOiBfYWxwaGEsXG5cdFx0XHRkZXB0aDogX2RlcHRoLFxuXHRcdFx0c3RlbmNpbDogX3N0ZW5jaWwsXG5cdFx0XHRhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXG5cdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsXG5cdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcblx0XHR9O1xuXG5cdFx0X2dsID0gX2NvbnRleHQgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnLCBhdHRyaWJ1dGVzICkgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyApO1xuXG5cdFx0aWYgKCBfZ2wgPT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBTb21lIGV4cGVyaW1lbnRhbC13ZWJnbCBpbXBsZW1lbnRhdGlvbnMgZG8gbm90IGhhdmUgZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0XG5cblx0XHRpZiAoIF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0X2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4geyAncmFuZ2VNaW4nOiAxLCAncmFuZ2VNYXgnOiAxLCAncHJlY2lzaW9uJzogMSB9O1xuXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cblx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvciApO1xuXG5cdH1cblxuXHR2YXIgZXh0ZW5zaW9ucyA9IG5ldyBXZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xuXG5cdGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICk7XG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuXHRcdEJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNDI5NDk2NzI5NjtcblxuXHR9XG5cblx0dmFyIGNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyggX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICk7XG5cblx0dmFyIHN0YXRlID0gbmV3IFdlYkdMU3RhdGUoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKTtcblx0dmFyIHByb3BlcnRpZXMgPSBuZXcgV2ViR0xQcm9wZXJ0aWVzKCk7XG5cdHZhciB0ZXh0dXJlcyA9IG5ldyBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHBhcmFtVGhyZWVUb0dMLCB0aGlzLmluZm8gKTtcblx0dmFyIG9iamVjdHMgPSBuZXcgV2ViR0xPYmplY3RzKCBfZ2wsIHByb3BlcnRpZXMsIHRoaXMuaW5mbyApO1xuXHR2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFdlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xuXHR2YXIgbGlnaHRDYWNoZSA9IG5ldyBXZWJHTExpZ2h0cygpO1xuXG5cdHRoaXMuaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcblxuXHR2YXIgYnVmZmVyUmVuZGVyZXIgPSBuZXcgV2ViR0xCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuXHR2YXIgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XG5cblx0Ly9cblxuXHR2YXIgYmFja2dyb3VuZFBsYW5lQ2FtZXJhLCBiYWNrZ3JvdW5kUGxhbmVNZXNoO1xuXHR2YXIgYmFja2dyb3VuZEJveENhbWVyYSwgYmFja2dyb3VuZEJveE1lc2g7XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xuXG5cdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZhdWx0R0xTdGF0ZSgpIHtcblxuXHRcdHN0YXRlLmluaXQoKTtcblxuXHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XG5cdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcblxuXHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhLCBfcHJlbXVsdGlwbGllZEFscGhhICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0R0xTdGF0ZSgpIHtcblxuXHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cblx0XHRzdGF0ZS5yZXNldCgpO1xuXG5cdH1cblxuXHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG5cdHRoaXMuY29udGV4dCA9IF9nbDtcblx0dGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XG5cdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cdHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cdHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuXHQvLyBzaGFkb3cgbWFwXG5cblx0dmFyIHNoYWRvd01hcCA9IG5ldyBXZWJHTFNoYWRvd01hcCggdGhpcywgX2xpZ2h0cywgb2JqZWN0cywgY2FwYWJpbGl0aWVzICk7XG5cblx0dGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XG5cblxuXHQvLyBQbHVnaW5zXG5cblx0dmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBTcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcblx0dmFyIGxlbnNGbGFyZVBsdWdpbiA9IG5ldyBMZW5zRmxhcmVQbHVnaW4oIHRoaXMsIGxlbnNGbGFyZXMgKTtcblxuXHQvLyBBUElcblxuXHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gX2dsO1xuXG5cdH07XG5cblx0dGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcblxuXHR9O1xuXG5cdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbG9zZV9jb250ZXh0JyApLmxvc2VDb250ZXh0KCk7XG5cblx0fTtcblxuXHR0aGlzLmdldE1heEFuaXNvdHJvcHkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKTtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGNhcGFiaWxpdGllcy5wcmVjaXNpb247XG5cblx0fTtcblxuXHR0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gX3BpeGVsUmF0aW87XG5cblx0fTtcblxuXHR0aGlzLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcblxuXHRcdHRoaXMuc2V0U2l6ZSggX3ZpZXdwb3J0LnosIF92aWV3cG9ydC53LCBmYWxzZSApO1xuXG5cdH07XG5cblx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBfd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IF9oZWlnaHRcblx0XHR9O1xuXG5cdH07XG5cblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcblxuXHRcdF93aWR0aCA9IHdpZHRoO1xuXHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRfY2FudmFzLndpZHRoID0gd2lkdGggKiBfcGl4ZWxSYXRpbztcblx0XHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIF9waXhlbFJhdGlvO1xuXG5cdFx0aWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0fTtcblxuXHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0c3RhdGUudmlld3BvcnQoIF92aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSApO1xuXG5cdH07XG5cblx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0c3RhdGUuc2Npc3NvciggX3NjaXNzb3Iuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkgKTtcblxuXHR9O1xuXG5cdHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XG5cblx0XHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX3NjaXNzb3JUZXN0ID0gYm9vbGVhbiApO1xuXG5cdH07XG5cblx0Ly8gQ2xlYXJpbmdcblxuXHR0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gX2NsZWFyQ29sb3I7XG5cblx0fTtcblxuXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcblxuXHRcdF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcblxuXHRcdF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcblxuXHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhLCBfcHJlbXVsdGlwbGllZEFscGhhICk7XG5cblx0fTtcblxuXHR0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gX2NsZWFyQWxwaGE7XG5cblx0fTtcblxuXHR0aGlzLnNldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoIGFscGhhICkge1xuXG5cdFx0X2NsZWFyQWxwaGEgPSBhbHBoYTtcblxuXHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhLCBfcHJlbXVsdGlwbGllZEFscGhhICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cblx0XHR2YXIgYml0cyA9IDA7XG5cblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuXHRcdGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cdFx0aWYgKCBzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCApIGJpdHMgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcblxuXHRcdF9nbC5jbGVhciggYml0cyApO1xuXG5cdH07XG5cblx0dGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jbGVhciggdHJ1ZSwgZmFsc2UsIGZhbHNlICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNsZWFyKCBmYWxzZSwgdHJ1ZSwgZmFsc2UgKTtcblxuXHR9O1xuXG5cdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jbGVhciggZmFsc2UsIGZhbHNlLCB0cnVlICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcblxuXHR9O1xuXG5cdC8vIFJlc2V0XG5cblx0dGhpcy5yZXNldEdMU3RhdGUgPSByZXNldEdMU3RhdGU7XG5cblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcblx0XHR0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtMTtcblx0XHRvcGFxdWVPYmplY3RzID0gW107XG5cdFx0b3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuXG5cdFx0X2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cblx0fTtcblxuXHQvLyBFdmVudHNcblxuXHRmdW5jdGlvbiBvbkNvbnRleHRMb3N0KCBldmVudCApIHtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRyZXNldEdMU3RhdGUoKTtcblx0XHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG5cdFx0cHJvcGVydGllcy5jbGVhcigpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XG5cblx0XHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cblx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG5cdFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcblxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xuXG5cdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbTtcblxuXHRcdG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbUluZm8gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdHZhciBidWZmZXJzID0gcHJvcGVydGllcy5nZXQoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgYnVmZmVycy5wb3NpdGlvbiApIGJ1ZmZlcnMucG9zaXRpb24gPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIGJ1ZmZlcnMubm9ybWFsICkgYnVmZmVycy5ub3JtYWwgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgYnVmZmVycy5jb2xvciApIGJ1ZmZlcnMuY29sb3IgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbiApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLm5vcm1hbCApO1xuXG5cdFx0XHRpZiAoICEgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCAmJlxuXHRcdFx0XHQhIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgJiZcblx0XHRcdFx0ISBtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCAmJlxuXHRcdFx0XHRtYXRlcmlhbC5zaGFkaW5nID09PSBGbGF0U2hhZGluZyApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY291bnQgKiAzOyBpIDwgbDsgaSArPSA5ICkge1xuXG5cdFx0XHRcdFx0dmFyIGFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xuXG5cdFx0XHRcdFx0dmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XG5cdFx0XHRcdFx0dmFyIG55ID0gKCBhcnJheVsgaSArIDEgXSArIGFycmF5WyBpICsgNCBdICsgYXJyYXlbIGkgKyA3IF0gKSAvIDM7XG5cdFx0XHRcdFx0dmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XG5cblx0XHRcdFx0XHRhcnJheVsgaSArIDAgXSA9IG54O1xuXHRcdFx0XHRcdGFycmF5WyBpICsgMSBdID0gbnk7XG5cdFx0XHRcdFx0YXJyYXlbIGkgKyAyIF0gPSBuejtcblxuXHRcdFx0XHRcdGFycmF5WyBpICsgMyBdID0gbng7XG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA0IF0gPSBueTtcblx0XHRcdFx0XHRhcnJheVsgaSArIDUgXSA9IG56O1xuXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA2IF0gPSBueDtcblx0XHRcdFx0XHRhcnJheVsgaSArIDcgXSA9IG55O1xuXHRcdFx0XHRcdGFycmF5WyBpICsgOCBdID0gbno7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnV2ICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBOb0NvbG9ycyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcblxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0XHRfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XG5cblx0XHRvYmplY3QuY291bnQgPSAwO1xuXG5cdH07XG5cblx0dGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKSB7XG5cblx0XHRzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuXHRcdHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2U7XG5cdFx0dmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArIG1hdGVyaWFsLndpcmVmcmFtZTtcblxuXHRcdGlmICggZ2VvbWV0cnlQcm9ncmFtICE9PSBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSApIHtcblxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeVByb2dyYW07XG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIHRhcmdldHNcblxuXHRcdHZhciBtb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGFjdGl2ZUluZmx1ZW5jZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLnB1c2goIFsgaW5mbHVlbmNlLCBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhY3RpdmVJbmZsdWVuY2VzLnNvcnQoIGFic051bWVyaWNhbFNvcnQgKTtcblxuXHRcdFx0aWYgKCBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA+IDggKSB7XG5cblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPSA4O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gYWN0aXZlSW5mbHVlbmNlc1sgaSBdO1xuXHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IGluZmx1ZW5jZVsgMCBdO1xuXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlWyAwIF0gIT09IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSBpbmZsdWVuY2VbIDEgXTtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGksIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvblsgaW5kZXggXSApO1xuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5ub3JtYWwgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsWyBpbmRleCBdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoLCBpbCA9IG1vcnBoSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IDAuMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoXG5cdFx0XHRcdF9nbCwgJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsIG1vcnBoSW5mbHVlbmNlcyApO1xuXG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdHZhciByYW5nZUZhY3RvciA9IDE7XG5cblx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0aW5kZXggPSBvYmplY3RzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKTtcblx0XHRcdHJhbmdlRmFjdG9yID0gMjtcblxuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlcjtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXHRcdFx0cmVuZGVyZXIuc2V0SW5kZXgoIGluZGV4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG5cdFx0XHRzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBpbmRleCApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgZGF0YUNvdW50ID0gMDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGFDb3VudCA9IGluZGV4LmNvdW50O1xuXG5cdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZGF0YUNvdW50ID0gcG9zaXRpb24uY291bnQ7XG5cblx0XHR9XG5cblx0XHR2YXIgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydCAqIHJhbmdlRmFjdG9yO1xuXHRcdHZhciByYW5nZUNvdW50ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50ICogcmFuZ2VGYWN0b3I7XG5cblx0XHR2YXIgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciA6IDA7XG5cdFx0dmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50ICogcmFuZ2VGYWN0b3IgOiBJbmZpbml0eTtcblxuXHRcdHZhciBkcmF3U3RhcnQgPSBNYXRoLm1heCggcmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApO1xuXHRcdHZhciBkcmF3RW5kID0gTWF0aC5taW4oIGRhdGFDb3VudCwgcmFuZ2VTdGFydCArIHJhbmdlQ291bnQsIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICkgLSAxO1xuXG5cdFx0dmFyIGRyYXdDb3VudCA9IE1hdGgubWF4KCAwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSApO1xuXG5cdFx0aWYgKCBkcmF3Q291bnQgPT09IDAgKSByZXR1cm47XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBvYmplY3QuaXNNZXNoICkge1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBvYmplY3QuZHJhd01vZGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIFRyaWFuZ2xlc0RyYXdNb2RlOlxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZTpcblx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRV9TVFJJUCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRyaWFuZ2xlRmFuRHJhd01vZGU6XG5cdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVfRkFOICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZSApIHtcblxuXHRcdFx0dmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblxuXHRcdFx0aWYgKCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCApIGxpbmVXaWR0aCA9IDE7IC8vIE5vdCB1c2luZyBMaW5lKk1hdGVyaWFsXG5cblx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XG5cblx0XHRcdGlmICggb2JqZWN0LmlzTGluZVNlZ21lbnRzICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1BvaW50cyApIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcblxuXHRcdHZhciBleHRlbnNpb247XG5cblx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGFydEluZGV4ID09PSB1bmRlZmluZWQgKSBzdGFydEluZGV4ID0gMDtcblxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cblx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuXHRcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0dmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgbm9ybWFsaXplZCA9IGdlb21ldHJ5QXR0cmlidXRlLm5vcm1hbGl6ZWQ7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVQcm9wZXJ0aWVzID0gb2JqZWN0cy5nZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlcjtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IGF0dHJpYnV0ZVByb3BlcnRpZXMudHlwZTtcblx0XHRcdFx0XHR2YXIgYnl0ZXNQZXJFbGVtZW50ID0gYXR0cmlidXRlUHJvcGVydGllcy5ieXRlc1BlckVsZW1lbnQ7XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcblx0XHRcdFx0XHRcdHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcblx0XHRcdFx0XHRcdHZhciBvZmZzZXQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5vZmZzZXQ7XG5cblx0XHRcdFx0XHRcdGlmICggZGF0YSAmJiBkYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUgKiBieXRlc1BlckVsZW1lbnQsICggc3RhcnRJbmRleCAqIHN0cmlkZSArIG9mZnNldCApICogYnl0ZXNQZXJFbGVtZW50ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiBieXRlc1BlckVsZW1lbnQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG5cdH1cblxuXHQvLyBTb3J0aW5nXG5cblx0ZnVuY3Rpb24gYWJzTnVtZXJpY2FsU29ydCggYSwgYiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggYlsgMCBdICkgLSBNYXRoLmFicyggYVsgMCBdICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XG5cblx0XHRcdHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xuXG5cdFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5wcm9ncmFtICYmIGIubWF0ZXJpYWwucHJvZ3JhbSAmJiBhLm1hdGVyaWFsLnByb2dyYW0gIT09IGIubWF0ZXJpYWwucHJvZ3JhbSApIHtcblxuXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWwucHJvZ3JhbS5pZCAtIGIubWF0ZXJpYWwucHJvZ3JhbS5pZDtcblxuXHRcdH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XG5cblx0XHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblxuXHRcdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG5cdFx0XHRyZXR1cm4gYS56IC0gYi56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cblx0XHRpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcblxuXHRcdFx0cmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cblx0XHR9IGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdHJldHVybiBiLnogLSBhLno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XG5cblx0XHRpZiAoIGNhbWVyYSAhPT0gdW5kZWZpbmVkICYmIGNhbWVyYS5pc0NhbWVyYSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXG5cblx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcblx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XG5cblx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cblx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRsaWdodHMubGVuZ3RoID0gMDtcblxuXHRcdG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XG5cdFx0dHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xuXG5cdFx0c3ByaXRlcy5sZW5ndGggPSAwO1xuXHRcdGxlbnNGbGFyZXMubGVuZ3RoID0gMDtcblxuXHRcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cdFx0X2NsaXBwaW5nRW5hYmxlZCA9IF9jbGlwcGluZy5pbml0KCB0aGlzLmNsaXBwaW5nUGxhbmVzLCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQsIGNhbWVyYSApO1xuXG5cdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0b3BhcXVlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVPYmplY3RzTGFzdEluZGV4ICsgMTtcblx0XHR0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID0gdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ICsgMTtcblxuXHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRcdHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuYmVnaW5TaGFkb3dzKCk7XG5cblx0XHRzZXR1cFNoYWRvd3MoIGxpZ2h0cyApO1xuXG5cdFx0c2hhZG93TWFwLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0c2V0dXBMaWdodHMoIGxpZ2h0cywgY2FtZXJhICk7XG5cblx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuZW5kU2hhZG93cygpO1xuXG5cdFx0Ly9cblxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzID0gMDtcblx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyA9IDA7XG5cdFx0X2luZm9SZW5kZXIuZmFjZXMgPSAwO1xuXHRcdF9pbmZvUmVuZGVyLnBvaW50cyA9IDA7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBiYWNrZ3JvdW5kID0gc2NlbmUuYmFja2dyb3VuZDtcblxuXHRcdGlmICggYmFja2dyb3VuZCA9PT0gbnVsbCApIHtcblxuXHRcdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEsIF9wcmVtdWx0aXBsaWVkQWxwaGEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCBiYWNrZ3JvdW5kLnIsIGJhY2tncm91bmQuZywgYmFja2dyb3VuZC5iLCAxLCBfcHJlbXVsdGlwbGllZEFscGhhICk7XG5cdFx0XHRmb3JjZUNsZWFyID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0dGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlICkge1xuXG5cdFx0XHRpZiAoIGJhY2tncm91bmRCb3hDYW1lcmEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRiYWNrZ3JvdW5kQm94Q2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cblx0XHRcdFx0YmFja2dyb3VuZEJveE1lc2ggPSBuZXcgTWVzaChcblx0XHRcdFx0XHRuZXcgQm94QnVmZmVyR2VvbWV0cnkoIDUsIDUsIDUgKSxcblx0XHRcdFx0XHRuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBTaGFkZXJMaWIuY3ViZS51bmlmb3Jtcyxcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyTGliLmN1YmUudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckxpYi5jdWJlLmZyYWdtZW50U2hhZGVyLFxuXHRcdFx0XHRcdFx0c2lkZTogQmFja1NpZGUsXG5cdFx0XHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRmb2c6IGZhbHNlXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0YmFja2dyb3VuZEJveENhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdGJhY2tncm91bmRCb3hDYW1lcmEubWF0cml4V29ybGQuZXh0cmFjdFJvdGF0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdGJhY2tncm91bmRCb3hDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGJhY2tncm91bmRCb3hDYW1lcmEubWF0cml4V29ybGQgKTtcblxuXG5cdFx0XHRiYWNrZ3JvdW5kQm94TWVzaC5tYXRlcmlhbC51bmlmb3Jtc1sgXCJ0Q3ViZVwiIF0udmFsdWUgPSBiYWNrZ3JvdW5kO1xuXHRcdFx0YmFja2dyb3VuZEJveE1lc2gubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGJhY2tncm91bmRCb3hDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBiYWNrZ3JvdW5kQm94TWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRvYmplY3RzLnVwZGF0ZSggYmFja2dyb3VuZEJveE1lc2ggKTtcblxuXHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBiYWNrZ3JvdW5kQm94Q2FtZXJhLCBudWxsLCBiYWNrZ3JvdW5kQm94TWVzaC5nZW9tZXRyeSwgYmFja2dyb3VuZEJveE1lc2gubWF0ZXJpYWwsIGJhY2tncm91bmRCb3hNZXNoLCBudWxsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRpZiAoIGJhY2tncm91bmRQbGFuZUNhbWVyYSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJhY2tncm91bmRQbGFuZUNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gMSwgMSwgMSwgLSAxLCAwLCAxICk7XG5cblx0XHRcdFx0YmFja2dyb3VuZFBsYW5lTWVzaCA9IG5ldyBNZXNoKFxuXHRcdFx0XHRcdG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KCAyLCAyICksXG5cdFx0XHRcdFx0bmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCBmb2c6IGZhbHNlIH0gKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJhY2tncm91bmRQbGFuZU1lc2gubWF0ZXJpYWwubWFwID0gYmFja2dyb3VuZDtcblxuXHRcdFx0b2JqZWN0cy51cGRhdGUoIGJhY2tncm91bmRQbGFuZU1lc2ggKTtcblxuXHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBiYWNrZ3JvdW5kUGxhbmVDYW1lcmEsIG51bGwsIGJhY2tncm91bmRQbGFuZU1lc2guZ2VvbWV0cnksIGJhY2tncm91bmRQbGFuZU1lc2gubWF0ZXJpYWwsIGJhY2tncm91bmRQbGFuZU1lc2gsIG51bGwgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHZhciBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXHRcdFx0cmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBzY2VuZSwgY2FtZXJhLCBvdmVycmlkZU1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcblx0XHRcdHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHR9XG5cblx0XHQvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHBvc3QgcGFzcylcblxuXHRcdHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcblx0XHRsZW5zRmxhcmVQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFZpZXdwb3J0ICk7XG5cblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG5cdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xuXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIHRydWUgKTtcblxuXHRcdC8vIF9nbC5maW5pc2goKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgeiwgZ3JvdXAgKSB7XG5cblx0XHR2YXIgYXJyYXksIGluZGV4O1xuXG5cdFx0Ly8gYWxsb2NhdGUgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGFwcHJvcHJpYXRlIGFycmF5XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xuXG5cdFx0XHRhcnJheSA9IHRyYW5zcGFyZW50T2JqZWN0cztcblx0XHRcdGluZGV4ID0gKysgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YXJyYXkgPSBvcGFxdWVPYmplY3RzO1xuXHRcdFx0aW5kZXggPSArKyBvcGFxdWVPYmplY3RzTGFzdEluZGV4O1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVjeWNsZSBleGlzdGluZyByZW5kZXIgaXRlbSBvciBncm93IHRoZSBhcnJheVxuXG5cdFx0dmFyIHJlbmRlckl0ZW0gPSBhcnJheVsgaW5kZXggXTtcblxuXHRcdGlmICggcmVuZGVySXRlbSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XG5cdFx0XHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHRyZW5kZXJJdGVtLnogPSBfdmVjdG9yMy56O1xuXHRcdFx0cmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVySXRlbSA9IHtcblx0XHRcdFx0aWQ6IG9iamVjdC5pZCxcblx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeSxcblx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxuXHRcdFx0XHR6OiBfdmVjdG9yMy56LFxuXHRcdFx0XHRncm91cDogZ3JvdXBcblx0XHRcdH07XG5cblx0XHRcdC8vIGFzc2VydCggaW5kZXggPT09IGFycmF5Lmxlbmd0aCApO1xuXHRcdFx0YXJyYXkucHVzaCggcmVuZGVySXRlbSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBUT0RPIER1cGxpY2F0ZWQgY29kZSAoRnJ1c3R1bSlcblxuXHRmdW5jdGlvbiBpc09iamVjdFZpZXdhYmxlKCBvYmplY3QgKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsIClcblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0X3NwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApLlxuXHRcdGFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRyZXR1cm4gaXNTcGhlcmVWaWV3YWJsZSggX3NwaGVyZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpc1Nwcml0ZVZpZXdhYmxlKCBzcHJpdGUgKSB7XG5cblx0XHRfc3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHRfc3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3Njtcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggc3ByaXRlLm1hdHJpeFdvcmxkICk7XG5cblx0XHRyZXR1cm4gaXNTcGhlcmVWaWV3YWJsZSggX3NwaGVyZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpc1NwaGVyZVZpZXdhYmxlKCBzcGhlcmUgKSB7XG5cblx0XHRpZiAoICEgX2ZydXN0dW0uaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHR2YXIgbnVtUGxhbmVzID0gX2NsaXBwaW5nLm51bVBsYW5lcztcblxuXHRcdGlmICggbnVtUGxhbmVzID09PSAwICkgcmV0dXJuIHRydWU7XG5cblx0XHR2YXIgcGxhbmVzID0gX3RoaXMuY2xpcHBpbmdQbGFuZXMsXG5cblx0XHRcdGNlbnRlciA9IHNwaGVyZS5jZW50ZXIsXG5cdFx0XHRuZWdSYWQgPSAtIHNwaGVyZS5yYWRpdXMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gb3V0IHdoZW4gZGVlcGVyIHRoYW4gcmFkaXVzIGluIHRoZSBuZWdhdGl2ZSBoYWxmc3BhY2Vcblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKSA8IG5lZ1JhZCApIHJldHVybiBmYWxzZTtcblxuXHRcdH0gd2hpbGUgKCArKyBpICE9PSBudW1QbGFuZXMgKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcblxuXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0dmFyIHZpc2libGUgPSAoIG9iamVjdC5sYXllcnMubWFzayAmIGNhbWVyYS5sYXllcnMubWFzayApICE9PSAwO1xuXG5cdFx0aWYgKCB2aXNpYmxlICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5pc0xpZ2h0ICkge1xuXG5cdFx0XHRcdGxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU3ByaXRlICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IGlzU3ByaXRlVmlld2FibGUoIG9iamVjdCApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0c3ByaXRlcy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xlbnNGbGFyZSApIHtcblxuXHRcdFx0XHRsZW5zRmxhcmVzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlNYXRyaXg0KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBudWxsLCBvYmplY3QubWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBpc09iamVjdFZpZXdhYmxlKCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTXVsdGlNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBzY2VuZSwgY2FtZXJhLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcmVuZGVySXRlbSA9IHJlbmRlckxpc3RbIGkgXTtcblxuXHRcdFx0dmFyIG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xuXHRcdFx0dmFyIGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcblx0XHRcdHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuXHRcdFx0dmFyIGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcblxuXHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcblx0XHRcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XG5cblx0XHRcdG9iamVjdC5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcblxuXHRcdFx0aWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdFx0c2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0dmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIHNjZW5lLmZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0XHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG5cblx0XHRcdFx0b2JqZWN0LnJlbmRlciggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIHNjZW5lLmZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0Lm9uQWZ0ZXJSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XG5cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgZm9nLCBvYmplY3QgKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKFxuXHRcdFx0bWF0ZXJpYWwsIF9saWdodHMsIGZvZywgX2NsaXBwaW5nLm51bVBsYW5lcywgX2NsaXBwaW5nLm51bUludGVyc2VjdGlvbiwgb2JqZWN0ICk7XG5cblx0XHR2YXIgY29kZSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ29kZSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblxuXHRcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW07XG5cdFx0dmFyIHByb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIG5ldyBtYXRlcmlhbFxuXHRcdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG5cdFx0fSBlbHNlIGlmICggcHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xuXG5cdFx0XHQvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xuXHRcdFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gc2FtZSBnbHNsIGFuZCB1bmlmb3JtIGxpc3Rcblx0XHRcdHJldHVybjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIG9ubHkgcmVidWlsZCB1bmlmb3JtIGxpc3Rcblx0XHRcdHByb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggcHJvZ3JhbUNoYW5nZSApIHtcblxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xuXG5cdFx0XHRcdHZhciBzaGFkZXIgPSBTaGFkZXJMaWJbIHBhcmFtZXRlcnMuc2hhZGVySUQgXTtcblxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcblx0XHRcdFx0XHRuYW1lOiBtYXRlcmlhbC50eXBlLFxuXHRcdFx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKSxcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xuXHRcdFx0XHRcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXG5cdFx0XHRcdFx0dW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxuXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBtYXRlcmlhbC5mcmFnbWVudFNoYWRlclxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlcjtcblxuXHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1DYWNoZS5hY3F1aXJlUHJvZ3JhbSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMsIGNvZGUgKTtcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPSBwcm9ncmFtO1xuXHRcdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHByb2dyYW07XG5cblx0XHR9XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBpIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcztcblxuXHRcdGlmICggISBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmXG5cdFx0XHQhIG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgfHxcblx0XHRcdG1hdGVyaWFsLmNsaXBwaW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiA9IF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb247XG5cdFx0XHR1bmlmb3Jtcy5jbGlwcGluZ1BsYW5lcyA9IF9jbGlwcGluZy51bmlmb3JtO1xuXG5cdFx0fVxuXG5cdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyA9IGZvZztcblxuXHRcdC8vIHN0b3JlIHRoZSBsaWdodCBzZXR1cCBpdCB3YXMgY3JlYXRlZCBmb3JcblxuXHRcdG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoID0gX2xpZ2h0cy5oYXNoO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5saWdodHMgKSB7XG5cblx0XHRcdC8vIHdpcmUgdXAgdGhlIG1hdGVyaWFsIHRvIHRoaXMgcmVuZGVyZXIncyBsaWdodGluZyBzdGF0ZVxuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IF9saWdodHMuYW1iaWVudDtcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5kaXJlY3Rpb25hbDtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMudmFsdWUgPSBfbGlnaHRzLnNwb3Q7XG5cdFx0XHR1bmlmb3Jtcy5yZWN0QXJlYUxpZ2h0cy52YWx1ZSA9IF9saWdodHMucmVjdEFyZWE7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy52YWx1ZSA9IF9saWdodHMucG9pbnQ7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5oZW1pO1xuXG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZSA9IF9saWdodHMuZGlyZWN0aW9uYWxTaGFkb3dNYXA7XG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC52YWx1ZSA9IF9saWdodHMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg7XG5cdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5zcG90U2hhZG93TWFwO1xuXHRcdFx0dW5pZm9ybXMuc3BvdFNoYWRvd01hdHJpeC52YWx1ZSA9IF9saWdodHMuc3BvdFNoYWRvd01hdHJpeDtcblx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5wb2ludFNoYWRvd01hcDtcblx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeDtcblx0XHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBhZGQgYXJlYSBsaWdodHMgc2hhZG93IGluZm8gdG8gdW5pZm9ybXNcblxuXHRcdH1cblxuXHRcdHZhciBwcm9nVW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuXHRcdFx0dW5pZm9ybXNMaXN0ID1cblx0XHRcdFx0V2ViR0xVbmlmb3Jtcy5zZXFXaXRoVmFsdWUoIHByb2dVbmlmb3Jtcy5zZXEsIHVuaWZvcm1zICk7XG5cblx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gdW5pZm9ybXNMaXN0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cblx0XHRtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlXG5cdFx0XHQ/IHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKVxuXHRcdFx0OiBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdHN0YXRlLnNldEZsaXBTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKTtcblxuXHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlXG5cdFx0XHQ/IHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApXG5cdFx0XHQ6IHN0YXRlLnNldEJsZW5kaW5nKCBOb0JsZW5kaW5nICk7XG5cblx0XHRzdGF0ZS5zZXREZXB0aEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xuXHRcdHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcblx0XHRzdGF0ZS5zZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XG5cblx0XHRfdXNlZFRleHR1cmVVbml0cyA9IDA7XG5cblx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cblx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSB7XG5cblx0XHRcdGlmICggX2xvY2FsQ2xpcHBpbmdFbmFibGVkIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XG5cblx0XHRcdFx0dmFyIHVzZUNhY2hlID1cblx0XHRcdFx0XHRjYW1lcmEgPT09IF9jdXJyZW50Q2FtZXJhICYmXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaWQgPT09IF9jdXJyZW50TWF0ZXJpYWxJZDtcblxuXHRcdFx0XHQvLyB3ZSBtaWdodCB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHNvbWUgQ2xpcHBpbmdHcm91cFxuXHRcdFx0XHQvLyBvYmplY3QgaW5zdGVhZCBvZiB0aGUgbWF0ZXJpYWwsIG9uY2UgaXQgYmVjb21lcyBmZWFzaWJsZVxuXHRcdFx0XHQvLyAoIzg0NjUsICM4Mzc5KVxuXHRcdFx0XHRfY2xpcHBpbmcuc2V0U3RhdGUoXG5cdFx0XHRcdFx0bWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMsIG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb24sIG1hdGVyaWFsLmNsaXBTaGFkb3dzLFxuXHRcdFx0XHRcdGNhbWVyYSwgbWF0ZXJpYWxQcm9wZXJ0aWVzLCB1c2VDYWNoZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZm9nICYmIG1hdGVyaWFsUHJvcGVydGllcy5mb2cgIT09IGZvZyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmxpZ2h0cyAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gX2xpZ2h0cy5oYXNoICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0KCBtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IF9jbGlwcGluZy5udW1QbGFuZXMgfHxcblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiAgIT09IF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb24gKSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZvZywgb2JqZWN0ICk7XG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG5cdFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuXHRcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLFxuXHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcblx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcztcblxuXHRcdGlmICggcHJvZ3JhbS5pZCAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xuXG5cdFx0XHRfZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICk7XG5cdFx0XHRfY3VycmVudFByb2dyYW0gPSBwcm9ncmFtLmlkO1xuXG5cdFx0XHRyZWZyZXNoUHJvZ3JhbSA9IHRydWU7XG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XG5cblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xuXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZWZyZXNoUHJvZ3JhbSB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xuXG5cdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBjYW1lcmEsICdwcm9qZWN0aW9uTWF0cml4JyApO1xuXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLFxuXHRcdFx0XHRcdDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGlmICggY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuXHRcdFx0XHRfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0XHQvLyBsaWdodGluZyB1bmlmb3JtcyBkZXBlbmQgb24gdGhlIGNhbWVyYSBzbyBlbmZvcmNlIGFuIHVwZGF0ZVxuXHRcdFx0XHQvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxuXHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XG5cblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcdFx0Ly8gc2V0IHRvIHRydWUgb24gbWF0ZXJpYWwgY2hhbmdlXG5cdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1x0XHQvLyByZW1haW5zIHNldCB1bnRpbCB1cGRhdGUgZG9uZVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcblx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcblx0XHRcdFx0bWF0ZXJpYWwuZW52TWFwICkge1xuXG5cdFx0XHRcdHZhciB1Q2FtUG9zID0gcF91bmlmb3Jtcy5tYXAuY2FtZXJhUG9zaXRpb247XG5cblx0XHRcdFx0aWYgKCB1Q2FtUG9zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR1Q2FtUG9zLnNldFZhbHVlKCBfZ2wsXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XG5cdFx0XHRcdG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHxcblx0XHRcdFx0bWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndmlld01hdHJpeCcsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBfdGhpcywgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnICk7XG5cdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBfdGhpcywgJ3RvbmVNYXBwaW5nV2hpdGVQb2ludCcgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxuXHRcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xuXHRcdC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXG5cblx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG5cdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXgnICk7XG5cdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXhJbnZlcnNlJyApO1xuXG5cdFx0XHR2YXIgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XG5cblx0XHRcdGlmICggc2tlbGV0b24gKSB7XG5cblx0XHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBza2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgc2tlbGV0b24sICdib25lVGV4dHVyZScgKTtcblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBza2VsZXRvbiwgJ2JvbmVUZXh0dXJlV2lkdGgnICk7XG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgc2tlbGV0b24sICdib25lVGV4dHVyZUhlaWdodCcgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBza2VsZXRvbiwgJ2JvbmVNYXRyaWNlcycgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0cyApIHtcblxuXHRcdFx0XHQvLyB0aGUgY3VycmVudCBtYXRlcmlhbCByZXF1aXJlcyBsaWdodGluZyBpbmZvXG5cblx0XHRcdFx0Ly8gbm90ZTogYWxsIGxpZ2h0aW5nIHVuaWZvcm1zIGFyZSBhbHdheXMgc2V0IGNvcnJlY3RseVxuXHRcdFx0XHQvLyB0aGV5IHNpbXBseSByZWZlcmVuY2UgdGhlIHJlbmRlcmVyJ3Mgc3RhdGUgZm9yIHRoZWlyXG5cdFx0XHRcdC8vIHZhbHVlc1xuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyB1c2UgdGhlIGN1cnJlbnQgbWF0ZXJpYWwncyAubmVlZHNVcGRhdGUgZmxhZ3MgdG8gc2V0XG5cdFx0XHRcdC8vIHRoZSBHTCBzdGF0ZSB3aGVuIHJlcXVpcmVkXG5cblx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHJlZnJlc2hMaWdodHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG5cdFx0XHRpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgfHxcblx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8XG5cdFx0XHRcdG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNQb2ludHNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQb2ludHMoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zVG9vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0XHRcdG1fdW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0XHRcdG1fdW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0XHRtX3VuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTm9ybWFsKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlY3RBcmVhTGlnaHQgVGV4dHVyZVxuXHRcdFx0Ly8gVE9ETyAobXJkb29iKTogRmluZCBhIG5pY2VyIGltcGxlbWVudGF0aW9uXG5cblx0XHRcdGlmICggbV91bmlmb3Jtcy5sdGNNYXQgIT09IHVuZGVmaW5lZCApIG1fdW5pZm9ybXMubHRjTWF0LnZhbHVlID0gVEhSRUUuVW5pZm9ybXNMaWIuTFRDX01BVF9URVhUVVJFO1xuXHRcdFx0aWYgKCBtX3VuaWZvcm1zLmx0Y01hZyAhPT0gdW5kZWZpbmVkICkgbV91bmlmb3Jtcy5sdGNNYWcudmFsdWUgPSBUSFJFRS5Vbmlmb3Jtc0xpYi5MVENfTUFHX1RFWFRVUkU7XG5cblx0XHRcdFdlYkdMVW5pZm9ybXMudXBsb2FkKFxuXHRcdFx0XHRfZ2wsIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG1fdW5pZm9ybXMsIF90aGlzICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIGNvbW1vbiBtYXRyaWNlc1xuXG5cdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgb2JqZWN0LCAnbW9kZWxWaWV3TWF0cml4JyApO1xuXHRcdHBfdW5pZm9ybXMuc2V0KCBfZ2wsIG9iamVjdCwgJ25vcm1hbE1hdHJpeCcgKTtcblx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdtb2RlbE1hdHJpeCcsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0cmV0dXJuIHByb2dyYW07XG5cblx0fVxuXG5cdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmUgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ICk7XG5cblx0XHR9XG5cblx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuXHRcdFx0dW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcblxuXHRcdH1cblxuXHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuXHRcdC8vIDEuIGNvbG9yIG1hcFxuXHRcdC8vIDIuIHNwZWN1bGFyIG1hcFxuXHRcdC8vIDMuIG5vcm1hbCBtYXBcblx0XHQvLyA0LiBidW1wIG1hcFxuXHRcdC8vIDUuIGFscGhhIG1hcFxuXHRcdC8vIDYuIGVtaXNzaXZlIG1hcFxuXG5cdFx0dmFyIHV2U2NhbGVNYXA7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRpZiAoIHV2U2NhbGVNYXAuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHR1dlNjYWxlTWFwID0gdXZTY2FsZU1hcC50ZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcblx0XHRcdHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcblxuXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuXHRcdH1cblxuXHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcblxuXHRcdC8vIGRvbid0IGZsaXAgQ3ViZVRleHR1cmUgZW52TWFwcywgZmxpcCBldmVyeXRoaW5nIGVsc2U6XG5cdFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSB3aWxsIGJlIGZsaXBwZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS50ZXh0dXJlIHdpbGwgYmUgZmxpcHBlZCBiZWNhdXNlIGl0J3MgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxuXHRcdC8vIHRoaXMgY2hlY2sgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5LCBvciByZW1vdmVkIGVudGlyZWx5LCBpZiBXZWJHTFJlbmRlclRhcmdldEN1YmUgdXNlcyBhIEN1YmVUZXh0dXJlIGluIHRoZSBmdXR1cmVcblx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCAhICggbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5pc0N1YmVUZXh0dXJlICkgKSA/IDEgOiAtIDE7XG5cblx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG5cdFx0dW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2goIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XG5cdFx0dW5pZm9ybXMudG90YWxTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemUgKyBtYXRlcmlhbC5nYXBTaXplO1xuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXHRcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplICogX3BpeGVsUmF0aW87XG5cdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfaGVpZ2h0ICogMC41O1xuXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xuXHRcdFx0dmFyIHJlcGVhdCA9IG1hdGVyaWFsLm1hcC5yZXBlYXQ7XG5cblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyggdW5pZm9ybXMsIGZvZyApIHtcblxuXHRcdHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xuXG5cdFx0aWYgKCBmb2cuaXNGb2cgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcblx0XHRcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XG5cblx0XHR9IGVsc2UgaWYgKCBmb2cuaXNGb2dFeHAyICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xuXHRcdHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IE1hdGgubWF4KCBtYXRlcmlhbC5zaGluaW5lc3MsIDFlLTQgKTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcblxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNUb29uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsLmdyYWRpZW50TWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5ncmFkaWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmdyYWRpZW50TWFwO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMucm91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzO1xuXHRcdHVuaWZvcm1zLm1ldGFsbmVzcy52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzcztcblxuXHRcdGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubWV0YWxuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmVudk1hcCApIHtcblxuXHRcdFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXG5cdFx0XHR1bmlmb3Jtcy5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5jbGVhckNvYXQudmFsdWUgPSBtYXRlcmlhbC5jbGVhckNvYXQ7XG5cdFx0dW5pZm9ybXMuY2xlYXJDb2F0Um91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzO1xuXG5cdFx0cmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNOb3JtYWwoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cblxuXHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggdW5pZm9ybXMsIHZhbHVlICkge1xuXG5cdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0fVxuXG5cdC8vIExpZ2h0aW5nXG5cblx0ZnVuY3Rpb24gc2V0dXBTaGFkb3dzKCBsaWdodHMgKSB7XG5cblx0XHR2YXIgbGlnaHRTaGFkb3dzTGVuZ3RoID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcblxuXHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRcdF9saWdodHMuc2hhZG93c1sgbGlnaHRTaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0X2xpZ2h0cy5zaGFkb3dzLmxlbmd0aCA9IGxpZ2h0U2hhZG93c0xlbmd0aDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBMaWdodHMoIGxpZ2h0cywgY2FtZXJhICkge1xuXG5cdFx0dmFyIGwsIGxsLCBsaWdodCxcblx0XHRcdHIgPSAwLCBnID0gMCwgYiA9IDAsXG5cdFx0XHRjb2xvcixcblx0XHRcdGludGVuc2l0eSxcblx0XHRcdGRpc3RhbmNlLFxuXHRcdFx0c2hhZG93TWFwLFxuXG5cdFx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSxcblxuXHRcdGRpcmVjdGlvbmFsTGVuZ3RoID0gMCxcblx0XHRwb2ludExlbmd0aCA9IDAsXG5cdFx0c3BvdExlbmd0aCA9IDAsXG5cdFx0cmVjdEFyZWFMZW5ndGggPSAwLFxuXHRcdGhlbWlMZW5ndGggPSAwO1xuXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xuXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0aW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuXHRcdFx0ZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdFx0c2hhZG93TWFwID0gKCBsaWdodC5zaGFkb3cgJiYgbGlnaHQuc2hhZG93Lm1hcCApID8gbGlnaHQuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbDtcblxuXHRcdFx0aWYgKCBsaWdodC5pc0FtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdGcgKz0gY29sb3IuZyAqIGludGVuc2l0eTtcblx0XHRcdFx0YiArPSBjb2xvci5iICogaW50ZW5zaXR5O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQgKSB7XG5cblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xuXG5cdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBsaWdodC5zaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBsaWdodC5zaGFkb3cubWFwU2l6ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2xpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHNoYWRvd01hcDtcblx0XHRcdFx0X2xpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XG5cdFx0XHRcdF9saWdodHMuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoICsrIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNTcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuY29uZUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5wZW51bWJyYUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSAqICggMSAtIGxpZ2h0LnBlbnVtYnJhICkgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xuXG5cdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBsaWdodC5zaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBsaWdodC5zaGFkb3cubWFwU2l6ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2xpZ2h0cy5zcG90U2hhZG93TWFwWyBzcG90TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdF9saWdodHMuc3BvdFNoYWRvd01hdHJpeFsgc3BvdExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0X2xpZ2h0cy5zcG90WyBzcG90TGVuZ3RoICsrIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNSZWN0QXJlYUxpZ2h0ICkge1xuXG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdC8vIChhKSBpbnRlbnNpdHkgY29udHJvbHMgaXJyYWRpYW5jZSBvZiBlbnRpcmUgbGlnaHRcblx0XHRcdFx0dW5pZm9ybXMuY29sb3Jcblx0XHRcdFx0XHQuY29weSggY29sb3IgKVxuXHRcdFx0XHRcdC5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5IC8gKCBsaWdodC53aWR0aCAqIGxpZ2h0LmhlaWdodCApICk7XG5cblx0XHRcdFx0Ly8gKGIpIGludGVuc2l0eSBjb250cm9scyB0aGUgcmFkaWFuY2UgcGVyIGxpZ2h0IGFyZWFcblx0XHRcdFx0Ly8gdW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHQvLyBleHRyYWN0IGxvY2FsIHJvdGF0aW9uIG9mIGxpZ2h0IHRvIGRlcml2ZSB3aWR0aC9oZWlnaHQgaGFsZiB2ZWN0b3JzXG5cdFx0XHRcdF9tYXRyaXg0Mi5pZGVudGl0eSgpO1xuXHRcdFx0XHRfbWF0cml4NC5jb3B5KCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRfbWF0cml4NC5wcmVtdWx0aXBseSggdmlld01hdHJpeCApO1xuXHRcdFx0XHRfbWF0cml4NDIuZXh0cmFjdFJvdGF0aW9uKCBfbWF0cml4NCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmhhbGZXaWR0aC5zZXQoIGxpZ2h0LndpZHRoICogMC41LCAgICAgICAgICAgICAgICAwLjAsIDAuMCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCggICAgICAgICAgICAgIDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjAgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KCBfbWF0cml4NDIgKTtcblx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5hcHBseU1hdHJpeDQoIF9tYXRyaXg0MiApO1xuXG5cdFx0XHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IGRpc3RhbmNlP1xuXHRcdFx0XHQvLyB1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG5cdFx0XHRcdF9saWdodHMucmVjdEFyZWFbIHJlY3RBcmVhTGVuZ3RoICsrIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNQb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcblxuXHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gbGlnaHQuc2hhZG93LmJpYXM7XG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93UmFkaXVzID0gbGlnaHQuc2hhZG93LnJhZGl1cztcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9saWdodHMucG9pbnRTaGFkb3dNYXBbIHBvaW50TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XG5cblx0XHRcdFx0aWYgKCBfbGlnaHRzLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRfbGlnaHRzLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxuXHRcdFx0XHQvLyBlcXVhbCB0byBpbnZlcnNlIG9mIHRoZSBsaWdodCdzIHBvc2l0aW9uXG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKTtcblx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXS5pZGVudGl0eSgpLnNldFBvc2l0aW9uKCBfdmVjdG9yMyApO1xuXG5cdFx0XHRcdF9saWdodHMucG9pbnRbIHBvaW50TGVuZ3RoICsrIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNIZW1pc3BoZXJlTGlnaHQgKSB7XG5cblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0dW5pZm9ybXMuc2t5Q29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XG5cdFx0XHRcdHVuaWZvcm1zLmdyb3VuZENvbG9yLmNvcHkoIGxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdF9saWdodHMuaGVtaVsgaGVtaUxlbmd0aCArKyBdID0gdW5pZm9ybXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF9saWdodHMuYW1iaWVudFsgMCBdID0gcjtcblx0XHRfbGlnaHRzLmFtYmllbnRbIDEgXSA9IGc7XG5cdFx0X2xpZ2h0cy5hbWJpZW50WyAyIF0gPSBiO1xuXG5cdFx0X2xpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJlY3Rpb25hbExlbmd0aDtcblx0XHRfbGlnaHRzLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcblx0XHRfbGlnaHRzLnJlY3RBcmVhLmxlbmd0aCA9IHJlY3RBcmVhTGVuZ3RoO1xuXHRcdF9saWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0X2xpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cblx0XHQvLyBUT0RPIChzYW0tZy1zdGVlbCkgd2h5IGFyZW4ndCB3ZSB1c2luZyBqb2luXG5cdFx0X2xpZ2h0cy5oYXNoID0gZGlyZWN0aW9uYWxMZW5ndGggKyAnLCcgKyBwb2ludExlbmd0aCArICcsJyArIHNwb3RMZW5ndGggKyAnLCcgKyByZWN0QXJlYUxlbmd0aCArICcsJyArIGhlbWlMZW5ndGggKyAnLCcgKyBfbGlnaHRzLnNoYWRvd3MubGVuZ3RoO1xuXG5cdH1cblxuXHQvLyBHTCBzdGF0ZSBzZXR0aW5nXG5cblx0dGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcblxuXHRcdHN0YXRlLnNldEN1bGxGYWNlKCBjdWxsRmFjZSApO1xuXHRcdHN0YXRlLnNldEZsaXBTaWRlZCggZnJvbnRGYWNlRGlyZWN0aW9uID09PSBGcm9udEZhY2VEaXJlY3Rpb25DVyApO1xuXG5cdH07XG5cblx0Ly8gVGV4dHVyZXNcblxuXHRmdW5jdGlvbiBhbGxvY1RleHR1cmVVbml0KCkge1xuXG5cdFx0dmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XG5cblx0XHRpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICk7XG5cblx0XHR9XG5cblx0XHRfdXNlZFRleHR1cmVVbml0cyArPSAxO1xuXG5cdFx0cmV0dXJuIHRleHR1cmVVbml0O1xuXG5cdH1cblxuXHR0aGlzLmFsbG9jVGV4dHVyZVVuaXQgPSBhbGxvY1RleHR1cmVVbml0O1xuXG5cdC8vIHRoaXMuc2V0VGV4dHVyZTJEID0gc2V0VGV4dHVyZTJEO1xuXHR0aGlzLnNldFRleHR1cmUyRCA9ICggZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgd2FybmVkID0gZmFsc2U7XG5cblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogcGVlbCB0ZXh0dXJlLnRleHR1cmVcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdGlmICggISB3YXJuZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlci5zZXRUZXh0dXJlMkQ6IGRvbid0IHVzZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXCIgKTtcblx0XHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZS50ZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApO1xuXG5cdFx0fTtcblxuXHR9KCkgKTtcblxuXHR0aGlzLnNldFRleHR1cmUgPSAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmUoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRcdGlmICggISB3YXJuZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlIGlzIGRlcHJlY2F0ZWQsIHVzZSBzZXRUZXh0dXJlMkQgaW5zdGVhZC5cIiApO1xuXHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApO1xuXG5cdFx0fTtcblxuXHR9KCkgKTtcblxuXHR0aGlzLnNldFRleHR1cmVDdWJlID0gKCBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB3YXJuZWQgPSBmYWxzZTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHBlZWwgdGV4dHVyZS50ZXh0dXJlXG5cdFx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuXHRcdFx0XHRpZiAoICEgd2FybmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZUN1YmU6IGRvbid0IHVzZSBjdWJlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiApO1xuXHRcdFx0XHRcdHdhcm5lZCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY3VycmVudGx5IHJlbHlpbmcgb24gdGhlIGZhY3QgdGhhdCBXZWJHTFJlbmRlclRhcmdldEN1YmUudGV4dHVyZSBpcyBhIFRleHR1cmUgYW5kIE5PVCBhIEN1YmVUZXh0dXJlXG5cdFx0XHQvLyBUT0RPOiB1bmlmeSB0aGVzZSBjb2RlIHBhdGhzXG5cdFx0XHRpZiAoICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB8fFxuXHRcdFx0XHQoIEFycmF5LmlzQXJyYXkoIHRleHR1cmUuaW1hZ2UgKSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkge1xuXG5cdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXG5cblx0XHRcdFx0Ly8gdGhpcyBmdW5jdGlvbiBhbG9uZSBzaG91bGQgdGFrZSBjYXJlIG9mIGN1YmUgdGV4dHVyZXNcblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBhc3N1bWVkOiB0ZXh0dXJlIHByb3BlcnR5IG9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZVxuXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlRHluYW1pYyggdGV4dHVyZSwgc2xvdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKSApO1xuXG5cdHRoaXMuZ2V0Q3VycmVudFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0O1xuXG5cdH07XG5cblx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XG5cdFx0dmFyIGZyYW1lYnVmZmVyO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCByZW5kZXJUYXJnZXQuc2Npc3NvciApO1xuXHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IHJlbmRlclRhcmdldC5zY2lzc29yVGVzdDtcblxuXHRcdFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KCByZW5kZXJUYXJnZXQudmlld3BvcnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZyYW1lYnVmZmVyID0gbnVsbDtcblxuXHRcdFx0X2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICk7XG5cdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gX3NjaXNzb3JUZXN0O1xuXG5cdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBfY3VycmVudEZyYW1lYnVmZmVyICE9PSBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXHRcdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yICk7XG5cdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9jdXJyZW50U2Npc3NvclRlc3QgKTtcblxuXHRcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0ICk7XG5cblx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgcmVuZGVyVGFyZ2V0LmFjdGl2ZU1pcE1hcExldmVsICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyICkge1xuXG5cdFx0aWYgKCAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG5cdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0dmFyIHJlc3RvcmUgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0cmVzdG9yZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHR2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHR2YXIgdGV4dHVyZUZvcm1hdCA9IHRleHR1cmUuZm9ybWF0O1xuXHRcdFx0XHR2YXIgdGV4dHVyZVR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlRm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlRm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LicgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGV4dHVyZVR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUgJiYgcGFyYW1UaHJlZVRvR0woIHRleHR1cmVUeXBlICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUgKSAmJiAvLyBJRTExLCBFZGdlIGFuZCBDaHJvbWUgTWFjIDwgNTIgKCM5NTEzKVxuXHRcdFx0XHRcdCEgKCB0ZXh0dXJlVHlwZSA9PT0gRmxvYXRUeXBlICYmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKSB8fCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApICkgJiYgLy8gQ2hyb21lIE1hYyA+PSA1MiBhbmQgRmlyZWZveFxuXHRcdFx0XHRcdCEgKCB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4nICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIF9nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCBfZ2wuRlJBTUVCVUZGRVIgKSA9PT0gX2dsLkZSQU1FQlVGRkVSX0NPTVBMRVRFICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnQgZW5zdXJlcyB2YWxpZCByZWFkIHJlcXVlc3RzIChubyBvdXQtb2YtYm91bmRzIHBpeGVscywgc2VlICM4NjA0KVxuXG5cdFx0XHRcdFx0aWYgKCAoIHggPj0gMCAmJiB4IDw9ICggcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggKSApICYmICggeSA+PSAwICYmIHkgPD0gKCByZW5kZXJUYXJnZXQuaGVpZ2h0IC0gaGVpZ2h0ICkgKSApIHtcblxuXHRcdFx0XHRcdFx0X2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlRm9ybWF0ICksIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlVHlwZSApLCBidWZmZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGZpbmFsbHkge1xuXG5cdFx0XHRcdGlmICggcmVzdG9yZSApIHtcblxuXHRcdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2N1cnJlbnRGcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcblxuXHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCggcCApIHtcblxuXHRcdHZhciBleHRlbnNpb247XG5cblx0XHRpZiAoIHAgPT09IFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5SRVBFQVQ7XG5cdFx0aWYgKCBwID09PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xuXHRcdGlmICggcCA9PT0gTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUO1xuXG5cdFx0aWYgKCBwID09PSBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUO1xuXHRcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG5cdFx0aWYgKCBwID09PSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cblx0XHRpZiAoIHAgPT09IExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSO1xuXHRcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xuXHRcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ1NjVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcblxuXHRcdGlmICggcCA9PT0gQnl0ZVR5cGUgKSByZXR1cm4gX2dsLkJZVEU7XG5cdFx0aWYgKCBwID09PSBTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlNIT1JUO1xuXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdGlmICggcCA9PT0gSW50VHlwZSApIHJldHVybiBfZ2wuSU5UO1xuXHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7XG5cdFx0aWYgKCBwID09PSBGbG9hdFR5cGUgKSByZXR1cm4gX2dsLkZMT0FUO1xuXG5cdFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcblxuXHRcdH1cblxuXHRcdGlmICggcCA9PT0gQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xuXHRcdGlmICggcCA9PT0gUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XG5cdFx0aWYgKCBwID09PSBSR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xuXHRcdGlmICggcCA9PT0gTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XG5cdFx0aWYgKCBwID09PSBMdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXHRcdGlmICggcCA9PT0gRGVwdGhGb3JtYXQgKSByZXR1cm4gX2dsLkRFUFRIX0NPTVBPTkVOVDtcblx0XHRpZiAoIHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHJldHVybiBfZ2wuREVQVEhfU1RFTkNJTDtcblxuXHRcdGlmICggcCA9PT0gQWRkRXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfQUREO1xuXHRcdGlmICggcCA9PT0gU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcblx0XHRpZiAoIHAgPT09IFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XG5cblx0XHRpZiAoIHAgPT09IFplcm9GYWN0b3IgKSByZXR1cm4gX2dsLlpFUk87XG5cdFx0aWYgKCBwID09PSBPbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcblx0XHRpZiAoIHAgPT09IFNyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQ09MT1I7XG5cdFx0aWYgKCBwID09PSBPbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xuXHRcdGlmICggcCA9PT0gU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcblx0XHRpZiAoIHAgPT09IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQUxQSEE7XG5cdFx0aWYgKCBwID09PSBEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuRFNUX0FMUEhBO1xuXHRcdGlmICggcCA9PT0gT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcblxuXHRcdGlmICggcCA9PT0gRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9DT0xPUjtcblx0XHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQ09MT1I7XG5cdFx0aWYgKCBwID09PSBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEFfU0FUVVJBVEU7XG5cblx0XHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCB8fFxuXHRcdFx0cCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fFxuXHRcdFx0cCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHAgPT09IFJHQl9FVEMxX0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0w7XG5cblx0XHR9XG5cblx0XHRpZiAoIHAgPT09IE1pbkVxdWF0aW9uIHx8IHAgPT09IE1heEVxdWF0aW9uICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gTWF4RXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1BWF9FWFQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTDtcblxuXHRcdH1cblxuXHRcdHJldHVybiAwO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbmZ1bmN0aW9uIEZvZ0V4cDIgKCBjb2xvciwgZGVuc2l0eSApIHtcblxuXHR0aGlzLm5hbWUgPSAnJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuXHR0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XG5cbn1cblxuRm9nRXhwMi5wcm90b3R5cGUuaXNGb2dFeHAyID0gdHJ1ZTtcblxuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyBGb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcblxufTtcblxuRm9nRXhwMi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdHJldHVybiB7XG5cdFx0dHlwZTogJ0ZvZ0V4cDInLFxuXHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuXHRcdGRlbnNpdHk6IHRoaXMuZGVuc2l0eVxuXHR9O1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbmZ1bmN0aW9uIEZvZyAoIGNvbG9yLCBuZWFyLCBmYXIgKSB7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcblxuXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxufVxuXG5Gb2cucHJvdG90eXBlLmlzRm9nID0gdHJ1ZTtcblxuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gbmV3IEZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG5Gb2cucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRyZXR1cm4ge1xuXHRcdHR5cGU6ICdGb2cnLFxuXHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuXHRcdG5lYXI6IHRoaXMubmVhcixcblx0XHRmYXI6IHRoaXMuZmFyXG5cdH07XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBTY2VuZSAoKSB7XG5cblx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTY2VuZSc7XG5cblx0dGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcblx0dGhpcy5mb2cgPSBudWxsO1xuXHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xuXG5cdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXG5cbn1cblxuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjZW5lO1xuXG5TY2VuZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRpZiAoIHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsICkgdGhpcy5iYWNrZ3JvdW5kID0gc291cmNlLmJhY2tncm91bmQuY2xvbmUoKTtcblx0aWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XG5cdGlmICggc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xuXG5cdHRoaXMuYXV0b1VwZGF0ZSA9IHNvdXJjZS5hdXRvVXBkYXRlO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuU2NlbmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdGlmICggdGhpcy5iYWNrZ3JvdW5kICE9PSBudWxsICkgZGF0YS5vYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oIG1ldGEgKTtcblx0aWYgKCB0aGlzLmZvZyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LmZvZyA9IHRoaXMuZm9nLnRvSlNPTigpO1xuXG5cdHJldHVybiBkYXRhO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbmZ1bmN0aW9uIExlbnNGbGFyZSggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5sZW5zRmxhcmVzID0gW107XG5cblx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBWZWN0b3IzKCk7XG5cdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cblx0aWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHR0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xuXG5cdH1cblxufVxuXG5MZW5zRmxhcmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogTGVuc0ZsYXJlLFxuXG5cdGlzTGVuc0ZsYXJlOiB0cnVlLFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xuXHRcdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBzb3VyY2UuY3VzdG9tVXBkYXRlQ2FsbGJhY2s7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuc0ZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuXHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcblx0XHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cdFx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblx0XHRpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXG5cdFx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cblx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xuXHRcdFx0dGV4dHVyZTogdGV4dHVyZSxcdC8vIFRIUkVFLlRleHR1cmVcblx0XHRcdHNpemU6IHNpemUsIFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSwgXHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG5cdFx0XHR4OiAwLCB5OiAwLCB6OiAwLFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXG5cdFx0XHRzY2FsZTogMSwgXHRcdC8vIHNjYWxlXG5cdFx0XHRyb3RhdGlvbjogMCwgXHRcdC8vIHJvdGF0aW9uXG5cdFx0XHRvcGFjaXR5OiBvcGFjaXR5LFx0Ly8gb3BhY2l0eVxuXHRcdFx0Y29sb3I6IGNvbG9yLFx0XHQvLyBjb2xvclxuXHRcdFx0YmxlbmRpbmc6IGJsZW5kaW5nXHQvLyBibGVuZGluZ1xuXHRcdH0gKTtcblxuXHR9LFxuXG5cdC8qXG5cdCAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxuXHQgKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxuXHQgKi9cblxuXHR1cGRhdGVMZW5zRmxhcmVzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xuXHRcdHZhciBmbGFyZTtcblx0XHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcblx0XHR2YXIgdmVjWSA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcblxuXHRcdGZvciAoIGYgPSAwOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XG5cblx0XHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XG5cdFx0XHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xuXG5cdFx0XHRmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcblx0XHRcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcblxuXHRcdH1cblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAqXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gU3ByaXRlTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdHRoaXMucm90YXRpb24gPSAwO1xuXG5cdHRoaXMuZm9nID0gZmFsc2U7XG5cdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufVxuXG5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcblNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcml0ZU1hdGVyaWFsO1xuXG5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbmZ1bmN0aW9uIFNwcml0ZSggbWF0ZXJpYWwgKSB7XG5cblx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXG5cdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFNwcml0ZU1hdGVyaWFsKCk7XG5cbn1cblxuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFNwcml0ZSxcblxuXHRpc1Nwcml0ZTogdHJ1ZSxcblxuXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dmFyIGRpc3RhbmNlU3EgPSByYXljYXN0ZXIucmF5LmRpc3RhbmNlU3FUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xuXHRcdFx0dmFyIGd1ZXNzU2l6ZVNxID0gdGhpcy5zY2FsZS54ICogdGhpcy5zY2FsZS55IC8gNDtcblxuXHRcdFx0aWYgKCBkaXN0YW5jZVNxID4gZ3Vlc3NTaXplU3EgKSB7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdGRpc3RhbmNlOiBNYXRoLnNxcnQoIGRpc3RhbmNlU3EgKSxcblx0XHRcdFx0cG9pbnQ6IHRoaXMucG9zaXRpb24sXG5cdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9O1xuXG5cdH0oKSApLFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIExPRCgpIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0xPRCc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRsZXZlbHM6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogW11cblx0XHR9XG5cdH0gKTtcblxufVxuXG5cbkxPRC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBMT0QsXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIGZhbHNlICk7XG5cblx0XHR2YXIgbGV2ZWxzID0gc291cmNlLmxldmVscztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0dGhpcy5hZGRMZXZlbCggbGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZExldmVsOiBmdW5jdGlvbiAoIG9iamVjdCwgZGlzdGFuY2UgKSB7XG5cblx0XHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cblx0XHRkaXN0YW5jZSA9IE1hdGguYWJzKCBkaXN0YW5jZSApO1xuXG5cdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgbCBdLmRpc3RhbmNlICkge1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRsZXZlbHMuc3BsaWNlKCBsLCAwLCB7IGRpc3RhbmNlOiBkaXN0YW5jZSwgb2JqZWN0OiBvYmplY3QgfSApO1xuXG5cdFx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG5cdH0sXG5cblx0Z2V0T2JqZWN0Rm9yRGlzdGFuY2U6IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cblx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcblxuXHR9LFxuXG5cdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xuXG5cdFx0XHR0aGlzLmdldE9iamVjdEZvckRpc3RhbmNlKCBkaXN0YW5jZSApLnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fTtcblxuXHR9KCkgKSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcblxuXHRcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XG5cblx0XHRcdFx0bGV2ZWxzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA+PSBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0bGV2ZWxzWyBpIC0gMSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcblxuXHRcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0ZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcblx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcblx0XHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5mdW5jdGlvbiBTa2VsZXRvbiggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHR0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcblxuXHR0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHQvLyBjb3B5IHRoZSBib25lIGFycmF5XG5cblx0Ym9uZXMgPSBib25lcyB8fCBbXTtcblxuXHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblxuXHQvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXG5cblx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG5cdFx0Ly8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuXHRcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXG5cdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXG5cdFx0Ly8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG5cdFx0Ly8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cblxuXHRcdHZhciBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLmJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxuXHRcdHNpemUgPSBfTWF0aC5uZXh0UG93ZXJPZlR3byggTWF0aC5jZWlsKCBzaXplICkgKTtcblx0XHRzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcblxuXHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XG5cdFx0dGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG5cdFx0dGhpcy5ib25lVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB0aGlzLmJvbmVzLmxlbmd0aCApO1xuXG5cdH1cblxuXHQvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xuXG5cdGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XG5cblx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzLnNsaWNlKCAwICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbiBib25JbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLicgKTtcblxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IE1hdHJpeDQoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbk9iamVjdC5hc3NpZ24oIFNrZWxldG9uLnByb3RvdHlwZSwge1xuXG5cdGNhbGN1bGF0ZUludmVyc2VzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRcdHZhciBpbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0aWYgKCB0aGlzLmJvbmVzWyBiIF0gKSB7XG5cblx0XHRcdFx0aW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYm9uZTtcblxuXHRcdC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cblx0XHRcdGlmICggYm9uZSApIHtcblxuXHRcdFx0XHRib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcblxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0XHRib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG5cdFx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XG5cblx0XHRcdFx0XHRib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0dXBkYXRlOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvZmZzZXRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0Ly8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XG5cblx0XHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0XHRcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXG5cblx0XHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMuYm9uZXNbIGIgXSA/IHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCA6IHRoaXMuaWRlbnRpdHlNYXRyaXg7XG5cblx0XHRcdFx0b2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuXHRcdFx0XHRvZmZzZXRNYXRyaXgudG9BcnJheSggdGhpcy5ib25lTWF0cmljZXMsIGIgKiAxNiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0XHRcdHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0gKSgpLFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFNrZWxldG9uKCB0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcywgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICk7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5mdW5jdGlvbiBCb25lKCkge1xuXG5cdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQm9uZSc7XG5cbn1cblxuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBCb25lLFxuXG5cdGlzQm9uZTogdHJ1ZVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5mdW5jdGlvbiBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdE1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcblxuXHR0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xuXHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHQvLyBpbml0IGJvbmVzXG5cblx0Ly8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXG5cdC8vIGNvbnZlbmllbmNlKSBmb3IgVEhSRUUuU2tpbm5lZE1lc2ggdG8gZG8gdGhpcy5cblxuXHR2YXIgYm9uZXMgPSBbXTtcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dmFyIGJvbmUsIGdib25lO1xuXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XG5cblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG5cdFx0XHRib25lID0gbmV3IEJvbmUoKTtcblx0XHRcdGJvbmVzLnB1c2goIGJvbmUgKTtcblxuXHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcblx0XHRcdGJvbmUucG9zaXRpb24uZnJvbUFycmF5KCBnYm9uZS5wb3MgKTtcblx0XHRcdGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcblx0XHRcdGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcblxuXHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XG5cblx0XHRcdGlmICggZ2JvbmUucGFyZW50ICE9PSAtIDEgJiYgZ2JvbmUucGFyZW50ICE9PSBudWxsICYmXG5cdFx0XHRcdFx0Ym9uZXNbIGdib25lLnBhcmVudCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ym9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGIgXSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuYWRkKCBib25lc1sgYiBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG5cdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblx0dGhpcy5iaW5kKCBuZXcgU2tlbGV0b24oIGJvbmVzLCB1bmRlZmluZWQsIHVzZVZlcnRleFRleHR1cmUgKSwgdGhpcy5tYXRyaXhXb3JsZCApO1xuXG59XG5cblxuU2tpbm5lZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBTa2lubmVkTWVzaCxcblxuXHRpc1NraW5uZWRNZXNoOiB0cnVlLFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCBza2VsZXRvbiwgYmluZE1hdHJpeCApIHtcblxuXHRcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuXHRcdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuXHRcdFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xuXG5cdH0sXG5cblx0cG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cblx0fSxcblxuXHRub3JtYWxpemVTa2luV2VpZ2h0czogZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xuXG5cdFx0XHRcdHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xuXG5cdFx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRcdFx0c3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN3LnNldCggMSwgMCwgMCwgMCApOyAvLyBkbyBzb21ldGhpbmcgcmVhc29uYWJsZVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdHZhciB2ZWMgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0XHR2YXIgc2tpbldlaWdodCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBza2luV2VpZ2h0LmNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdHZlYy54ID0gc2tpbldlaWdodC5nZXRYKCBpICk7XG5cdFx0XHRcdHZlYy55ID0gc2tpbldlaWdodC5nZXRZKCBpICk7XG5cdFx0XHRcdHZlYy56ID0gc2tpbldlaWdodC5nZXRaKCBpICk7XG5cdFx0XHRcdHZlYy53ID0gc2tpbldlaWdodC5nZXRXKCBpICk7XG5cblx0XHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gdmVjLmxlbmd0aE1hbmhhdHRhbigpO1xuXG5cdFx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRcdFx0dmVjLm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2ZWMuc2V0KCAxLCAwLCAwLCAwICk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjLngsIHZlYy55LCB2ZWMueiwgdmVjLncgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uKCBmb3JjZSApIHtcblxuXHRcdE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcblxuXHRcdGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJhdHRhY2hlZFwiICkge1xuXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcblxuXHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJpbmRNYXRyaXggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCwgdGhpcy5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkuY29weSggdGhpcyApO1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXG4gKiAgbGluZWpvaW46IFwicm91bmRcIlxuICogfVxuICovXG5cbmZ1bmN0aW9uIExpbmVCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTGluZUJhc2ljTWF0ZXJpYWwnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0dGhpcy5saW5ld2lkdGggPSAxO1xuXHR0aGlzLmxpbmVjYXAgPSAncm91bmQnO1xuXHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcblxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn1cblxuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQmFzaWNNYXRlcmlhbDtcblxuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0dGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuXHR0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcblx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcblxuXHRpZiAoIG1vZGUgPT09IDEgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lOiBwYXJhbWV0ZXIgVEhSRUUuTGluZVBpZWNlcyBubyBsb25nZXIgc3VwcG9ydGVkLiBDcmVhdGVkIFRIUkVFLkxpbmVTZWdtZW50cyBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTGluZSc7XG5cblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG59XG5cbkxpbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogTGluZSxcblxuXHRpc0xpbmU6IHRydWUsXG5cblx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcblx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xuXHRcdFx0dmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XG5cdFx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0XHR2YXIgdlN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciB2RW5kID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBpbnRlclNlZ21lbnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIGludGVyUmF5ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBzdGVwID0gKHRoaXMgJiYgdGhpcy5pc0xpbmVTZWdtZW50cykgPyAyIDogMTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYSA9IGluZGljZXNbIGkgXTtcblx0XHRcdFx0XHRcdHZhciBiID0gaW5kaWNlc1sgaSArIDEgXTtcblxuXHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXHRcdFx0XHRcdFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG5cdFx0XHRcdFx0XHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XG5cdFx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSArIDMgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cdFx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpICs9IHN0ZXAgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG5cdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuXHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcblx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSgpICksXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy50eXBlID0gJ0xpbmVTZWdtZW50cyc7XG5cbn1cblxuTGluZVNlZ21lbnRzLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpbmUucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogTGluZVNlZ21lbnRzLFxuXG5cdGlzTGluZVNlZ21lbnRzOiB0cnVlXG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc2l6ZTogPGZsb2F0PixcbiAqICBzaXplQXR0ZW51YXRpb246IDxib29sPlxuICogfVxuICovXG5cbmZ1bmN0aW9uIFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdHRoaXMuc2l6ZSA9IDE7XG5cdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn1cblxuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludHNNYXRlcmlhbDtcblxuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmlzUG9pbnRzTWF0ZXJpYWwgPSB0cnVlO1xuXG5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1BvaW50cyc7XG5cblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG59XG5cblBvaW50cy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBQb2ludHMsXG5cblx0aXNQb2ludHM6IHRydWUsXG5cblx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcblx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdFx0dmFyIG9iamVjdCA9IHRoaXM7XG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRcdHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG5cblx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0Ly9cblxuXHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xuXHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuXHRcdFx0dmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xuXHRcdFx0dmFyIGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0ZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcblx0XHRcdFx0XHRpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xuXG5cdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxuXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXG5cdFx0XHRcdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdFx0b2JqZWN0OiBvYmplY3RcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblxuXHRcdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBpICogMyApO1xuXG5cdFx0XHRcdFx0XHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR0ZXN0UG9pbnQoIHZlcnRpY2VzWyBpIF0sIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSgpICksXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIEdyb3VwKCkge1xuXG5cdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xuXG59XG5cbkdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IEdyb3VwXG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFZpZGVvVGV4dHVyZSggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRUZXh0dXJlLmNhbGwoIHRoaXMsIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0ZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcblxuXHRcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSApIHtcblxuXHRcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGUoKTtcblxufVxuXG5WaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcblZpZGVvVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWaWRlb1RleHR1cmU7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBDb21wcmVzc2VkVGV4dHVyZSggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcblxuXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcblxuXHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cdHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG5cblx0Ly8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcblx0Ly8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuXHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0Ly8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuXHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXG5cblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxufVxuXG5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcHJlc3NlZFRleHR1cmU7XG5cbkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIENhbnZhc1RleHR1cmUoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxufVxuXG5DYW52YXNUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XG5DYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1RleHR1cmU7XG5cbi8qKlxuICogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIC8gQG1hdHRkZXNsXG4gKiBAYXV0aG9yIGF0aXggLyBhcnRodXJzaWxiZXIuZGVcbiAqL1xuXG5mdW5jdGlvbiBEZXB0aFRleHR1cmUoIHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCApIHtcblxuXHRmb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IERlcHRoRm9ybWF0O1xuXG5cdGlmICggZm9ybWF0ICE9PSBEZXB0aEZvcm1hdCAmJiBmb3JtYXQgIT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcblxuXHRcdHRocm93IG5ldyBFcnJvciggJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0JyApXG5cblx0fVxuXG5cdGlmICggdHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgKSB0eXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XG5cdGlmICggdHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkgdHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcblxuXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG5cblx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHR0aGlzLmdlbmVyYXRlTWlwbWFwc1x0PSBmYWxzZTtcblxufVxuXG5EZXB0aFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcbkRlcHRoVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZXB0aFRleHR1cmU7XG5EZXB0aFRleHR1cmUucHJvdG90eXBlLmlzRGVwdGhUZXh0dXJlID0gdHJ1ZTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBXaXJlZnJhbWVHZW9tZXRyeSggZ2VvbWV0cnkgKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdXaXJlZnJhbWVHZW9tZXRyeSc7XG5cblx0Ly8gYnVmZmVyXG5cblx0dmFyIHZlcnRpY2VzID0gW107XG5cblx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdHZhciBpLCBqLCBsLCBvLCBvbDtcblx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgZWRnZXMgPSB7fSwgZTtcblx0dmFyIGtleSwga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXHR2YXIgdmVydGV4O1xuXG5cdC8vIGRpZmZlcmVudCBsb2dpYyBmb3IgR2VvbWV0cnkgYW5kIEJ1ZmZlckdlb21ldHJ5XG5cblx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xuXG5cdFx0Ly8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWRnZXMgd2l0aG91dCBkdXBsaWNhdGVzXG5cblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblxuXHRcdGZvciAoIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0ZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG5cdFx0XHRcdGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xuXHRcdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApOyAvLyBzb3J0aW5nIHByZXZlbnRzIGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0aWYgKCBlZGdlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGVkZ2VzWyBrZXkgXSA9IHsgaW5kZXgxOiBlZGdlWyAwIF0sIGluZGV4MjogZWRnZVsgMSBdIH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlc1xuXG5cdFx0Zm9yICgga2V5IGluIGVkZ2VzICkge1xuXG5cdFx0XHRlID0gZWRnZXNbIGtleSBdO1xuXG5cdFx0XHR2ZXJ0ZXggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZS5pbmRleDEgXTtcblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0dmVydGV4ID0gZ2VvbWV0cnkudmVydGljZXNbIGUuaW5kZXgyIF07XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdHZhciBwb3NpdGlvbiwgaW5kaWNlcywgZ3JvdXBzO1xuXHRcdHZhciBncm91cCwgc3RhcnQsIGNvdW50O1xuXHRcdHZhciBpbmRleDEsIGluZGV4MjtcblxuXHRcdHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGluZGljZXMgPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCAwLCBpbmRpY2VzLmNvdW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcblxuXHRcdFx0Zm9yICggbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG5cdFx0XHRcdGdyb3VwID0gZ3JvdXBzWyBvIF07XG5cblx0XHRcdFx0c3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0Y291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRmb3IgKCBpID0gc3RhcnQsIGwgPSAoIHN0YXJ0ICsgY291bnQgKTsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0ZWRnZVsgMCBdID0gaW5kaWNlcy5nZXRYKCBpICsgaiApO1xuXHRcdFx0XHRcdFx0ZWRnZVsgMSBdID0gaW5kaWNlcy5nZXRYKCBpICsgKCBqICsgMSApICUgMyApO1xuXHRcdFx0XHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTsgLy8gc29ydGluZyBwcmV2ZW50cyBkdXBsaWNhdGVzXG5cblx0XHRcdFx0XHRcdGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBlZGdlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRlZGdlc1sga2V5IF0gPSB7IGluZGV4MTogZWRnZVsgMCBdLCBpbmRleDI6IGVkZ2VbIDEgXSB9O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXG5cblx0XHRcdGZvciAoIGtleSBpbiBlZGdlcyApIHtcblxuXHRcdFx0XHRlID0gZWRnZXNbIGtleSBdO1xuXG5cdFx0XHRcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgZS5pbmRleDEgKTtcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgZS5pbmRleDIgKTtcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gKCBwb3NpdGlvbi5jb3VudCAvIDMgKTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhyZWUgZWRnZXMgcGVyIHRyaWFuZ2xlLCBhbiBlZGdlIGlzIHJlcHJlc2VudGVkIGFzIChpbmRleDEsIGluZGV4Milcblx0XHRcdFx0XHQvLyBlLmcuIHRoZSBmaXJzdCB0cmlhbmdsZSBoYXMgdGhlIGZvbGxvd2luZyBlZGdlczogKDAsMSksKDEsMiksKDIsMClcblxuXHRcdFx0XHRcdGluZGV4MSA9IDMgKiBpICsgajtcblx0XHRcdFx0XHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MSApO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHRcdGluZGV4MiA9IDMgKiBpICsgKCAoIGogKyAxICkgJSAzICk7XG5cdFx0XHRcdFx0dmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDIgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cblx0Ly8gY3VzdG9tIGFycmF5IHNvcnQgZnVuY3Rpb25cblxuXHRmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHRyZXR1cm4gYSAtIGI7XG5cblx0fVxuXG59XG5cbldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2lyZWZyYW1lR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqXG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XG4gKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxuICovXG5cbmZ1bmN0aW9uIFBhcmFtZXRyaWNHZW9tZXRyeSggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XG5cblx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRmdW5jOiBmdW5jLFxuXHRcdHNsaWNlczogc2xpY2VzLFxuXHRcdHN0YWNrczogc3RhY2tzXG5cdH07XG5cblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkgKTtcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbn1cblxuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICpcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XG4gKi9cblxuZnVuY3Rpb24gUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5KCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcblxuXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1BhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdGZ1bmM6IGZ1bmMsXG5cdFx0c2xpY2VzOiBzbGljZXMsXG5cdFx0c3RhY2tzOiBzdGFja3Ncblx0fTtcblxuXHQvLyBidWZmZXJzXG5cblx0dmFyIGluZGljZXMgPSBbXTtcblx0dmFyIHZlcnRpY2VzID0gW107XG5cdHZhciB1dnMgPSBbXTtcblxuXHR2YXIgaSwgajtcblxuXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcyBhbmQgdXZzXG5cblx0dmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xuXG5cdGZvciAoIGkgPSAwOyBpIDw9IHN0YWNrczsgaSArKyApIHtcblxuXHRcdHZhciB2ID0gaSAvIHN0YWNrcztcblxuXHRcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcblxuXHRcdFx0dmFyIHUgPSBqIC8gc2xpY2VzO1xuXG5cdFx0XHR2YXIgcCA9IGZ1bmMoIHUsIHYgKTtcblx0XHRcdHZlcnRpY2VzLnB1c2goIHAueCwgcC55LCBwLnogKTtcblxuXHRcdFx0dXZzLnB1c2goIHUsIHYgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpICsrICkge1xuXG5cdFx0Zm9yICggaiA9IDA7IGogPCBzbGljZXM7IGogKysgKSB7XG5cblx0XHRcdHZhciBhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuXHRcdFx0dmFyIGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xuXHRcdFx0dmFyIGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XG5cdFx0XHR2YXIgZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xuXG5cdFx0XHQvLyBmYWNlcyBvbmUgYW5kIHR3b1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHQvLyBnZW5lcmF0ZSBub3JtYWxzXG5cblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59XG5cblBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuZnVuY3Rpb24gUG9seWhlZHJvbkdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSApO1xuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufVxuXG5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWhlZHJvbkdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKi9cblxuZnVuY3Rpb24gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuXHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXG5cblx0dmFyIHZlcnRleEJ1ZmZlciA9IFtdO1xuXHR2YXIgdXZCdWZmZXIgPSBbXTtcblxuXHQvLyB0aGUgc3ViZGl2aXNpb24gY3JlYXRlcyB0aGUgdmVydGV4IGJ1ZmZlciBkYXRhXG5cblx0c3ViZGl2aWRlKCBkZXRhaWwgKTtcblxuXHQvLyBhbGwgdmVydGljZXMgc2hvdWxkIGxpZSBvbiBhIGNvbmNlcHR1YWwgc3BoZXJlIHdpdGggYSBnaXZlbiByYWRpdXNcblxuXHRhcHBwbHlSYWRpdXMoIHJhZGl1cyApO1xuXG5cdC8vIGZpbmFsbHksIGNyZWF0ZSB0aGUgdXYgZGF0YVxuXG5cdGdlbmVyYXRlVVZzKCk7XG5cblx0Ly8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRleEJ1ZmZlciwgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRleEJ1ZmZlci5zbGljZSgpLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkJ1ZmZlciwgMiApICk7XG5cdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG5cdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXHRmdW5jdGlvbiBzdWJkaXZpZGUoIGRldGFpbCApIHtcblxuXHRcdHZhciBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIGMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc29uIHdpdGggdGhlIGdpdmVuIGRldGFpbCB2YWx1ZVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0Ly8gZ2V0IHRoZSB2ZXJ0aWNlcyBvZiB0aGUgZmFjZVxuXG5cdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMCBdLCBhICk7XG5cdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMSBdLCBiICk7XG5cdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMiBdLCBjICk7XG5cblx0XHRcdC8vIHBlcmZvcm0gc3ViZGl2aXNpb25cblxuXHRcdFx0c3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApIHtcblxuXHRcdHZhciBjb2xzID0gTWF0aC5wb3coIDIsIGRldGFpbCApO1xuXG5cdFx0Ly8gd2UgdXNlIHRoaXMgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBhcyBhIGRhdGEgc3RydWN0dXJlIGZvciBjcmVhdGluZyB0aGUgc3ViZGl2aXNpb25cblxuXHRcdHZhciB2ID0gW107XG5cblx0XHR2YXIgaSwgajtcblxuXHRcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSBjb2xzOyBpICsrICkge1xuXG5cdFx0XHR2WyBpIF0gPSBbXTtcblxuXHRcdFx0dmFyIGFqID0gYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICk7XG5cdFx0XHR2YXIgYmogPSBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcblxuXHRcdFx0dmFyIHJvd3MgPSBjb2xzIC0gaTtcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcblxuXHRcdFx0XHRpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcblxuXHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDwgMiAqICggY29scyAtIGkgKSAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdGlmICggaiAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcblx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcHBseVJhZGl1cyggcmFkaXVzICkge1xuXG5cdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBidWZmZXIgYW5kIGFwcGx5IHRoZSByYWRpdXMgdG8gZWFjaCB2ZXJ0ZXhcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF07XG5cdFx0XHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlclsgaSArIDEgXTtcblx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHR2ZXJ0ZXgubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xuXG5cdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0gPSB2ZXJ0ZXgueDtcblx0XHRcdHZlcnRleEJ1ZmZlclsgaSArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0dmVydGV4QnVmZmVyWyBpICsgMiBdID0gdmVydGV4Lno7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xuXG5cdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyWyBpICsgMCBdO1xuXHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlclsgaSArIDIgXTtcblxuXHRcdFx0dmFyIHUgPSBhemltdXRoKCB2ZXJ0ZXggKSAvIDIgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVydGV4ICkgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdH1cblxuXHRcdGNvcnJlY3RVVnMoKTtcblxuXHRcdGNvcnJlY3RTZWFtKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvcnJlY3RTZWFtKCkge1xuXG5cdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB1dkJ1ZmZlci5sZW5ndGg7IGkgKz0gNiApIHtcblxuXHRcdFx0Ly8gdXYgZGF0YSBvZiBhIHNpbmdsZSBmYWNlXG5cblx0XHRcdHZhciB4MCA9IHV2QnVmZmVyWyBpICsgMCBdO1xuXHRcdFx0dmFyIHgxID0gdXZCdWZmZXJbIGkgKyAyIF07XG5cdFx0XHR2YXIgeDIgPSB1dkJ1ZmZlclsgaSArIDQgXTtcblxuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KCB4MCwgeDEsIHgyICk7XG5cdFx0XHR2YXIgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcblxuXHRcdFx0Ly8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxuXG5cdFx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XG5cblx0XHRcdFx0aWYgKCB4MCA8IDAuMiApIHV2QnVmZmVyWyBpICsgMCBdICs9IDE7XG5cdFx0XHRcdGlmICggeDEgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDIgXSArPSAxO1xuXHRcdFx0XHRpZiAoIHgyIDwgMC4yICkgdXZCdWZmZXJbIGkgKyA0IF0gKz0gMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoVmVydGV4KCB2ZXJ0ZXggKSB7XG5cblx0XHR2ZXJ0ZXhCdWZmZXIucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRWZXJ0ZXhCeUluZGV4KCBpbmRleCwgdmVydGV4ICkge1xuXG5cdFx0dmFyIHN0cmlkZSA9IGluZGV4ICogMztcblxuXHRcdHZlcnRleC54ID0gdmVydGljZXNbIHN0cmlkZSArIDAgXTtcblx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBzdHJpZGUgKyAxIF07XG5cdFx0dmVydGV4LnogPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMiBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjb3JyZWN0VVZzKCkge1xuXG5cdFx0dmFyIGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBiID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgYyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR2YXIgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0dmFyIHV2QiA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0dmFyIHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSA5LCBqICs9IDYgKSB7XG5cblx0XHRcdGEuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0sIHZlcnRleEJ1ZmZlclsgaSArIDEgXSwgdmVydGV4QnVmZmVyWyBpICsgMiBdICk7XG5cdFx0XHRiLnNldCggdmVydGV4QnVmZmVyWyBpICsgMyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA0IF0sIHZlcnRleEJ1ZmZlclsgaSArIDUgXSApO1xuXHRcdFx0Yy5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDYgXSwgdmVydGV4QnVmZmVyWyBpICsgNyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA4IF0gKTtcblxuXHRcdFx0dXZBLnNldCggdXZCdWZmZXJbIGogKyAwIF0sIHV2QnVmZmVyWyBqICsgMSBdICk7XG5cdFx0XHR1dkIuc2V0KCB1dkJ1ZmZlclsgaiArIDIgXSwgdXZCdWZmZXJbIGogKyAzIF0gKTtcblx0XHRcdHV2Qy5zZXQoIHV2QnVmZmVyWyBqICsgNCBdLCB1dkJ1ZmZlclsgaiArIDUgXSApO1xuXG5cdFx0XHRjZW50cm9pZC5jb3B5KCBhICkuYWRkKCBiICkuYWRkKCBjICkuZGl2aWRlU2NhbGFyKCAzICk7XG5cblx0XHRcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xuXG5cdFx0XHRjb3JyZWN0VVYoIHV2QSwgaiArIDAsIGEsIGF6aSApO1xuXHRcdFx0Y29ycmVjdFVWKCB1dkIsIGogKyAyLCBiLCBhemkgKTtcblx0XHRcdGNvcnJlY3RVViggdXZDLCBqICsgNCwgYywgYXppICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHN0cmlkZSwgdmVjdG9yLCBhemltdXRoICkge1xuXG5cdFx0aWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB7XG5cblx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IHV2LnggLSAxO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkge1xuXG5cdFx0XHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuXHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcblxuXHR9XG5cblxuXHQvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXG5cblx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuXHRcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG5cdH1cblxufVxuXG5Qb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5Qb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5mdW5jdGlvbiBUZXRyYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1RldHJhaGVkcm9uR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSApO1xuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufVxuXG5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXRyYWhlZHJvbkdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKi9cblxuZnVuY3Rpb24gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0dmFyIHZlcnRpY2VzID0gW1xuXHRcdDEsICAxLCAgMSwgICAtIDEsIC0gMSwgIDEsICAgLSAxLCAgMSwgLSAxLCAgICAxLCAtIDEsIC0gMVxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdDIsICAxLCAgMCwgICAgMCwgIDMsICAyLCAgICAxLCAgMywgIDAsICAgIDIsICAzLCAgMVxuXHRdO1xuXG5cdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdGRldGFpbDogZGV0YWlsXG5cdH07XG5cbn1cblxuVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5UZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICovXG5cbmZ1bmN0aW9uIE9jdGFoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG59XG5cbk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPY3RhaGVkcm9uR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHQxLCAwLCAwLCAgIC0gMSwgMCwgMCwgICAgMCwgMSwgMCwgICAgMCwgLSAxLCAwLCAgICAwLCAwLCAxLCAgICAwLCAwLCAtIDFcblx0XTtcblxuXHR2YXIgaW5kaWNlcyA9IFtcblx0XHQwLCAyLCA0LCAgICAwLCA0LCAzLCAgICAwLCAzLCA1LCAgICAwLCA1LCAyLCAgICAxLCAyLCA1LCAgICAxLCA1LCAzLCAgICAxLCAzLCA0LCAgICAxLCA0LCAyXG5cdF07XG5cblx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG59XG5cbk9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5PY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5mdW5jdGlvbiBJY29zYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcblxuIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbn1cblxuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICovXG5cbmZ1bmN0aW9uIEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cblx0dmFyIHZlcnRpY2VzID0gW1xuXHRcdC0gMSwgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxuXHRcdCAwLCAtIDEsICB0LCAgICAwLCAgMSwgIHQsICAgIDAsIC0gMSwgLSB0LCAgICAwLCAgMSwgLSB0LFxuXHRcdCB0LCAgMCwgLSAxLCAgICB0LCAgMCwgIDEsICAgLSB0LCAgMCwgLSAxLCAgIC0gdCwgIDAsICAxXG5cdF07XG5cblx0dmFyIGluZGljZXMgPSBbXG5cdFx0IDAsIDExLCAgNSwgICAgMCwgIDUsICAxLCAgICAwLCAgMSwgIDcsICAgIDAsICA3LCAxMCwgICAgMCwgMTAsIDExLFxuXHRcdCAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcblx0XHQgMywgIDksICA0LCAgICAzLCAgNCwgIDIsICAgIDMsICAyLCAgNiwgICAgMywgIDYsICA4LCAgICAzLCAgOCwgIDksXG5cdFx0IDQsICA5LCAgNSwgICAgMiwgIDQsIDExLCAgICA2LCAgMiwgMTAsICAgIDgsICA2LCAgNywgICAgOSwgIDgsICAxXG5cdF07XG5cblx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxufVxuXG5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbkljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxuICovXG5cbmZ1bmN0aW9uIERvZGVjYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG59XG5cbkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblx0dmFyIHIgPSAxIC8gdDtcblxuXHR2YXIgdmVydGljZXMgPSBbXG5cblx0XHQvLyAowrExLCDCsTEsIMKxMSlcblx0XHQtIDEsIC0gMSwgLSAxLCAgICAtIDEsIC0gMSwgIDEsXG5cdFx0LSAxLCAgMSwgLSAxLCAgICAtIDEsICAxLCAgMSxcblx0XHQgIDEsIC0gMSwgLSAxLCAgICAgMSwgLSAxLCAgMSxcblx0XHQgIDEsICAxLCAtIDEsICAgICAxLCAgMSwgIDEsXG5cblx0XHQvLyAoMCwgwrExL8+GLCDCsc+GKVxuXHRcdCAwLCAtIHIsIC0gdCwgICAgIDAsIC0gciwgIHQsXG5cdFx0IDAsICByLCAtIHQsICAgICAwLCAgciwgIHQsXG5cblx0XHQvLyAowrExL8+GLCDCsc+GLCAwKVxuXHRcdC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXG5cdFx0IHIsIC0gdCwgIDAsICAgICByLCAgdCwgIDAsXG5cblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdC0gdCwgIDAsIC0gciwgICAgIHQsICAwLCAtIHIsXG5cdFx0LSB0LCAgMCwgIHIsICAgICB0LCAgMCwgIHJcblx0XTtcblxuXHR2YXIgaW5kaWNlcyA9IFtcblx0XHQgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXG5cdFx0IDcsIDE5LCAxNywgICAgICA3LCAxNywgIDYsICAgICAgNywgIDYsIDE1LFxuXHRcdDE3LCAgNCwgIDgsICAgICAxNywgIDgsIDEwLCAgICAgMTcsIDEwLCAgNixcblx0XHQgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXG5cdFx0IDAsIDEyLCAgMSwgICAgICAwLCAgMSwgMTgsICAgICAgMCwgMTgsIDE2LFxuXHRcdCA2LCAxMCwgIDIsICAgICAgNiwgIDIsIDEzLCAgICAgIDYsIDEzLCAxNSxcblx0XHQgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXG5cdFx0MTgsICAxLCAgOSwgICAgIDE4LCAgOSwgMTEsICAgICAxOCwgMTEsICAzLFxuXHRcdCA0LCAxNCwgMTIsICAgICAgNCwgMTIsICAwLCAgICAgIDQsICAwLCAgOCxcblx0XHQxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXG5cdFx0MTksICA1LCAxNCwgICAgIDE5LCAxNCwgIDQsICAgICAxOSwgIDQsIDE3LFxuXHRcdCAxLCAxMiwgMTQsICAgICAgMSwgMTQsICA1LCAgICAgIDEsICA1LCAgOVxuXHRdO1xuXG5cdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG59XG5cbkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlIC8gaHR0cHM6Ly9naXRodWIuY29tL29vc21veGllY29kZVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjFcbiAqXG4gKiBDcmVhdGVzIGEgdHViZSB3aGljaCBleHRydWRlcyBhbG9uZyBhIDNkIHNwbGluZS5cbiAqL1xuXG5mdW5jdGlvbiBUdWJlR2VvbWV0cnkoIHBhdGgsIHR1YnVsYXJTZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkLCB0YXBlciApIHtcblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHBhdGg6IHBhdGgsXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGNsb3NlZDogY2xvc2VkXG5cdH07XG5cblx0aWYgKCB0YXBlciAhPT0gdW5kZWZpbmVkICkgY29uc29sZS53YXJuKCAnVEhSRUUuVHViZUdlb21ldHJ5OiB0YXBlciBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR2YXIgYnVmZmVyR2VvbWV0cnkgPSBuZXcgVHViZUJ1ZmZlckdlb21ldHJ5KCBwYXRoLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCApO1xuXG5cdC8vIGV4cG9zZSBpbnRlcm5hbHNcblxuXHR0aGlzLnRhbmdlbnRzID0gYnVmZmVyR2VvbWV0cnkudGFuZ2VudHM7XG5cdHRoaXMubm9ybWFscyA9IGJ1ZmZlckdlb21ldHJ5Lm5vcm1hbHM7XG5cdHRoaXMuYmlub3JtYWxzID0gYnVmZmVyR2VvbWV0cnkuYmlub3JtYWxzO1xuXG5cdC8vIGNyZWF0ZSBnZW9tZXRyeVxuXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBidWZmZXJHZW9tZXRyeSApO1xuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufVxuXG5UdWJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHViZUdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKi9cblxuZnVuY3Rpb24gVHViZUJ1ZmZlckdlb21ldHJ5KCBwYXRoLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1R1YmVCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHBhdGg6IHBhdGgsXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGNsb3NlZDogY2xvc2VkXG5cdH07XG5cblx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY0O1xuXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuXHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XG5cblx0dmFyIGZyYW1lcyA9IHBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggdHVidWxhclNlZ21lbnRzLCBjbG9zZWQgKTtcblxuXHQvLyBleHBvc2UgaW50ZXJuYWxzXG5cblx0dGhpcy50YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cztcblx0dGhpcy5ub3JtYWxzID0gZnJhbWVzLm5vcm1hbHM7XG5cdHRoaXMuYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcblxuXHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdHZhciBpLCBqO1xuXG5cdC8vIGJ1ZmZlclxuXG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9ybWFscyA9IFtdO1xuXHR2YXIgdXZzID0gW107XG5cdHZhciBpbmRpY2VzID0gW107XG5cblx0Ly8gY3JlYXRlIGJ1ZmZlciBkYXRhXG5cblx0Z2VuZXJhdGVCdWZmZXJEYXRhKCk7XG5cblx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdC8vIGZ1bmN0aW9uc1xuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyRGF0YSgpIHtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRnZW5lcmF0ZVNlZ21lbnQoIGkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBub3QgY2xvc2VkLCBnZW5lcmF0ZSB0aGUgbGFzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHNcblx0XHQvLyBhdCB0aGUgcmVndWxhciBwb3NpdGlvbiBvbiB0aGUgZ2l2ZW4gcGF0aFxuXHRcdC8vXG5cdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgZHVwbGljYXRlIHRoZSBmaXJzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHMgKHV2cyB3aWxsIGRpZmZlcilcblxuXHRcdGdlbmVyYXRlU2VnbWVudCggKCBjbG9zZWQgPT09IGZhbHNlICkgPyB0dWJ1bGFyU2VnbWVudHMgOiAwICk7XG5cblx0XHQvLyB1dnMgYXJlIGdlbmVyYXRlZCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxuXHRcdC8vIHRoaXMgbWFrZXMgaXQgZWFzeSBjb21wdXRlIGNvcnJlY3QgdmFsdWVzIGZvciBjbG9zZWQgZ2VvbWV0cmllc1xuXG5cdFx0Z2VuZXJhdGVVVnMoKTtcblxuXHRcdC8vIGZpbmFsbHkgY3JlYXRlIGZhY2VzXG5cblx0XHRnZW5lcmF0ZUluZGljZXMoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50KCBpICkge1xuXG5cdFx0Ly8gd2UgdXNlIGdldFBvaW50QXQgdG8gc2FtcGxlIGV2ZW5seSBkaXN0cmlidXRlZCBwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gcGF0aFxuXG5cdFx0dmFyIFAgPSBwYXRoLmdldFBvaW50QXQoIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblxuXHRcdC8vIHJldHJpZXZlIGNvcnJlc3BvbmRpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbFxuXG5cdFx0dmFyIE4gPSBmcmFtZXMubm9ybWFsc1sgaSBdO1xuXHRcdHZhciBCID0gZnJhbWVzLmJpbm9ybWFsc1sgaSBdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgbm9ybWFscyBhbmQgdmVydGljZXMgZm9yIHRoZSBjdXJyZW50IHNlZ21lbnRcblxuXHRcdGZvciAoIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHR2YXIgc2luID0gICBNYXRoLnNpbiggdiApO1xuXHRcdFx0dmFyIGNvcyA9IC0gTWF0aC5jb3MoIHYgKTtcblxuXHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdG5vcm1hbC54ID0gKCBjb3MgKiBOLnggKyBzaW4gKiBCLnggKTtcblx0XHRcdG5vcm1hbC55ID0gKCBjb3MgKiBOLnkgKyBzaW4gKiBCLnkgKTtcblx0XHRcdG5vcm1hbC56ID0gKCBjb3MgKiBOLnogKyBzaW4gKiBCLnogKTtcblx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcblxuXHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHR2ZXJ0ZXgueCA9IFAueCArIHJhZGl1cyAqIG5vcm1hbC54O1xuXHRcdFx0dmVydGV4LnkgPSBQLnkgKyByYWRpdXMgKiBub3JtYWwueTtcblx0XHRcdHZlcnRleC56ID0gUC56ICsgcmFkaXVzICogbm9ybWFsLno7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVJbmRpY2VzKCkge1xuXG5cdFx0Zm9yICggaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XG5cdFx0XHRcdHZhciBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XG5cdFx0XHRcdHZhciBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXHRcdFx0XHR2YXIgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0XHR1di54ID0gaSAvIHR1YnVsYXJTZWdtZW50cztcblx0XHRcdFx0dXYueSA9IGogLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59XG5cblR1YmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblR1YmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUdWJlQnVmZmVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqL1xuXG5mdW5jdGlvbiBUb3J1c0tub3RHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0dHViZTogdHViZSxcblx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0cDogcCxcblx0XHRxOiBxXG5cdH07XG5cblx0aWYgKCBoZWlnaHRTY2FsZSAhPT0gdW5kZWZpbmVkICkgY29uc29sZS53YXJuKCAnVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk6IGhlaWdodFNjYWxlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuc2NhbGUoIHgsIHksIHogKSBpbnN0ZWFkLicgKTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEgKSApO1xuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufVxuXG5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzS25vdEdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKiBzZWU6IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wcXRvcnVzL1xuICovXG5cbmZ1bmN0aW9uIFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEgKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHR1YmU6IHR1YmUsXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdHA6IHAsXG5cdFx0cTogcVxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG5cdHR1YmUgPSB0dWJlIHx8IDQwO1xuXHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKSB8fCA2NDtcblx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XG5cdHAgPSBwIHx8IDI7XG5cdHEgPSBxIHx8IDM7XG5cblx0Ly8gYnVmZmVyc1xuXG5cdHZhciBpbmRpY2VzID0gW107XG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9ybWFscyA9IFtdO1xuXHR2YXIgdXZzID0gW107XG5cblx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdHZhciBpLCBqO1xuXG5cdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHR2YXIgUDEgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgUDIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdHZhciBCID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIFQgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgTiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdGZvciAoIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgKysgaSApIHtcblxuXHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ2VtZW50XG5cblx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBwICogTWF0aC5QSSAqIDI7XG5cblx0XHQvLyBub3cgd2UgY2FsY3VsYXRlIHR3byBwb2ludHMuIFAxIGlzIG91ciBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSwgUDIgaXMgYSBsaXR0bGUgZmFydGhlciBhaGVhZC5cblx0XHQvLyB0aGVzZSBwb2ludHMgYXJlIHVzZWQgdG8gY3JlYXRlIGEgc3BlY2lhbCBcImNvb3JkaW5hdGUgc3BhY2VcIiwgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB2ZXJ0ZXggcG9zaXRpb25zXG5cblx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgUDEgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUgKyAwLjAxLCBwLCBxLCByYWRpdXMsIFAyICk7XG5cblx0XHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcblxuXHRcdFQuc3ViVmVjdG9ycyggUDIsIFAxICk7XG5cdFx0Ti5hZGRWZWN0b3JzKCBQMiwgUDEgKTtcblx0XHRCLmNyb3NzVmVjdG9ycyggVCwgTiApO1xuXHRcdE4uY3Jvc3NWZWN0b3JzKCBCLCBUICk7XG5cblx0XHQvLyBub3JtYWxpemUgQiwgTi4gVCBjYW4gYmUgaWdub3JlZCwgd2UgZG9uJ3QgdXNlIGl0XG5cblx0XHRCLm5vcm1hbGl6ZSgpO1xuXHRcdE4ubm9ybWFsaXplKCk7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgdmVydGljZXMuIHRoZXkgYXJlIG5vdGhpbmcgbW9yZSB0aGFuIGFuIGV4dHJ1c2lvbiBvZiB0aGUgdG9ydXMgY3VydmUuXG5cdFx0XHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cblxuXHRcdFx0dmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblx0XHRcdHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7XG5cdFx0XHR2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgZmluYWwgdmVydGV4IHBvc2l0aW9uLlxuXHRcdFx0Ly8gZmlyc3Qgd2Ugb3JpZW50IHRoZSBleHRydXNpb24gd2l0aCBvdXIgYmFzaXMgdmVjdG9zLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuXHRcdFx0dmVydGV4LnggPSBQMS54ICsgKCBjeCAqIE4ueCArIGN5ICogQi54ICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IFAxLnkgKyAoIGN4ICogTi55ICsgY3kgKiBCLnkgKTtcblx0XHRcdHZlcnRleC56ID0gUDEueiArICggY3ggKiBOLnogKyBjeSAqIEIueiApO1xuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcblxuXHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgUDEgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdC8vIHV2XG5cblx0XHRcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHR1dnMucHVzaCggaiAvIHJhZGlhbFNlZ21lbnRzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRmb3IgKCBqID0gMTsgaiA8PSB0dWJ1bGFyU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHR2YXIgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XG5cdFx0XHR2YXIgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xuXHRcdFx0dmFyIGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XG5cdFx0XHR2YXIgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuXG5cdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0Ly8gdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZVxuXG5cdGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBwb3NpdGlvbiApIHtcblxuXHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG5cdFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcblx0XHR2YXIgcXVPdmVyUCA9IHEgLyBwICogdTtcblx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0cG9zaXRpb24ueCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcblx0XHRwb3NpdGlvbi55ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xuXHRcdHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG5cdH1cblxufVxuXG5Ub3J1c0tub3RCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxuICovXG5cbmZ1bmN0aW9uIFRvcnVzR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG5cdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHR1YmU6IHR1YmUsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdGFyYzogYXJjXG5cdH07XG5cblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUb3J1c0J1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApICk7XG5cbn1cblxuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICovXG5cbmZ1bmN0aW9uIFRvcnVzQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG5cdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVG9ydXNCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHR1YmU6IHR1YmUsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdGFyYzogYXJjXG5cdH07XG5cblx0cmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcblx0dHViZSA9IHR1YmUgfHwgNDA7XG5cdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xuXHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKSB8fCA2O1xuXHRhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cblx0Ly8gYnVmZmVyc1xuXG5cdHZhciBpbmRpY2VzID0gW107XG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9ybWFscyA9IFtdO1xuXHR2YXIgdXZzID0gW107XG5cblx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdHZhciBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0dmFyIGosIGk7XG5cblx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdGZvciAoIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG5cdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0Y2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgY2VudGVyICkubm9ybWFsaXplKCk7XG5cblx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHQvLyB1dlxuXG5cdFx0XHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0Zm9yICggaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0dmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcblx0XHRcdHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcblx0XHRcdHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuXHRcdFx0dmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG5cdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbn1cblxuVG9ydXNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRvcnVzQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxudmFyIFNoYXBlVXRpbHMgPSB7XG5cblx0Ly8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxuXG5cdGFyZWE6IGZ1bmN0aW9uICggY29udG91ciApIHtcblxuXHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cdFx0dmFyIGEgPSAwLjA7XG5cblx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG5cdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGEgKiAwLjU7XG5cblx0fSxcblxuXHR0cmlhbmd1bGF0ZTogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xuXHRcdCAqIGZsaXBjb2RlLmNvbSBieSBKb2huIFcuIFJhdGNsaWZmICAvLyBKdWx5IDIyLCAyMDAwXG5cdFx0ICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcblx0XHQgKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXG5cdFx0ICpcblx0XHQgKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxuXHRcdCAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxuXHRcdCAqXG5cdFx0ICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xuXHRcdCAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0XHQgKlxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gc25pcCggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XG5cblx0XHRcdHZhciBwO1xuXHRcdFx0dmFyIGF4LCBheSwgYngsIGJ5O1xuXHRcdFx0dmFyIGN4LCBjeSwgcHgsIHB5O1xuXG5cdFx0XHRheCA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS54O1xuXHRcdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuXHRcdFx0YnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcblx0XHRcdGJ5ID0gY29udG91clsgdmVydHNbIHYgXSBdLnk7XG5cblx0XHRcdGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG5cdFx0XHRjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xuXG5cdFx0XHRpZiAoICggYnggLSBheCApICogKCBjeSAtIGF5ICkgLSAoIGJ5IC0gYXkgKSAqICggY3ggLSBheCApIDw9IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xuXHRcdFx0dmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XG5cdFx0XHR2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcblxuXHRcdFx0YVggPSBjeCAtIGJ4OyAgYVkgPSBjeSAtIGJ5O1xuXHRcdFx0YlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xuXHRcdFx0Y1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xuXG5cdFx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHAgKysgKSB7XG5cblx0XHRcdFx0cHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueDtcblx0XHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcblxuXHRcdFx0XHRpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcblx0XHRcdFx0XHQgKCAoIHB4ID09PSBieCApICYmICggcHkgPT09IGJ5ICkgKSB8fFxuXHRcdFx0XHRcdCAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApIClcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuXHRcdFx0XHRicHggPSBweCAtIGJ4OyAgYnB5ID0gcHkgLSBieTtcblx0XHRcdFx0Y3B4ID0gcHggLSBjeDsgIGNweSA9IHB5IC0gY3k7XG5cblx0XHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG5cdFx0XHRcdGFDUk9TU2JwID0gYVggKiBicHkgLSBhWSAqIGJweDtcblx0XHRcdFx0Y0NST1NTYXAgPSBjWCAqIGFweSAtIGNZICogYXB4O1xuXHRcdFx0XHRiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cblx0XHRcdFx0aWYgKCAoIGFDUk9TU2JwID49IC0gTnVtYmVyLkVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC0gTnVtYmVyLkVQU0lMT04gKSAmJiAoIGNDUk9TU2FwID49IC0gTnVtYmVyLkVQU0lMT04gKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcblxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmlhbmd1bGF0ZSggY29udG91ciwgaW5kaWNlcyApIHtcblxuXHRcdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBuIDwgMyApIHJldHVybiBudWxsO1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdHZlcnRzID0gW10sXG5cdFx0XHRcdHZlcnRJbmRpY2VzID0gW107XG5cblx0XHRcdC8qIHdlIHdhbnQgYSBjb3VudGVyLWNsb2Nrd2lzZSBwb2x5Z29uIGluIHZlcnRzICovXG5cblx0XHRcdHZhciB1LCB2LCB3O1xuXG5cdFx0XHRpZiAoIFNoYXBlVXRpbHMuYXJlYSggY29udG91ciApID4gMC4wICkge1xuXG5cdFx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSB2O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSAoIG4gLSAxICkgLSB2O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBudiA9IG47XG5cblx0XHRcdC8qICByZW1vdmUgbnYgLSAyIHZlcnRpY2VzLCBjcmVhdGluZyAxIHRyaWFuZ2xlIGV2ZXJ5IHRpbWUgKi9cblxuXHRcdFx0dmFyIGNvdW50ID0gMiAqIG52OyAgIC8qIGVycm9yIGRldGVjdGlvbiAqL1xuXG5cdFx0XHRmb3IgKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xuXG5cdFx0XHRcdC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXG5cblx0XHRcdFx0aWYgKCAoIGNvdW50IC0tICkgPD0gMCApIHtcblxuXHRcdFx0XHRcdC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXG5cblx0XHRcdFx0XHQvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xuXHRcdFx0XHRcdC8vcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0Ly8gU29tZXRpbWVzIHdhcm5pbmcgaXMgZmluZSwgZXNwZWNpYWxseSBwb2x5Z29ucyBhcmUgdHJpYW5ndWxhdGVkIGluIHJldmVyc2UuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGVVdGlsczogVW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hIGluIHRyaWFuZ3VsYXRlKCknICk7XG5cblx0XHRcdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXG5cblx0XHRcdFx0dSA9IHY7IFx0IFx0aWYgKCBudiA8PSB1ICkgdSA9IDA7ICAgICAvKiBwcmV2aW91cyAqL1xuXHRcdFx0XHR2ID0gdSArIDE7ICBpZiAoIG52IDw9IHYgKSB2ID0gMDsgICAgIC8qIG5ldyB2ICAgICovXG5cdFx0XHRcdHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cblxuXHRcdFx0XHRpZiAoIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG52LCB2ZXJ0cyApICkge1xuXG5cdFx0XHRcdFx0dmFyIGEsIGIsIGMsIHMsIHQ7XG5cblx0XHRcdFx0XHQvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG5cdFx0XHRcdFx0YSA9IHZlcnRzWyB1IF07XG5cdFx0XHRcdFx0YiA9IHZlcnRzWyB2IF07XG5cdFx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XG5cblx0XHRcdFx0XHQvKiBvdXRwdXQgVHJpYW5nbGUgKi9cblxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBbIGNvbnRvdXJbIGEgXSxcblx0XHRcdFx0XHRcdGNvbnRvdXJbIGIgXSxcblx0XHRcdFx0XHRcdGNvbnRvdXJbIGMgXSBdICk7XG5cblxuXHRcdFx0XHRcdHZlcnRJbmRpY2VzLnB1c2goIFsgdmVydHNbIHUgXSwgdmVydHNbIHYgXSwgdmVydHNbIHcgXSBdICk7XG5cblx0XHRcdFx0XHQvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG5cdFx0XHRcdFx0Zm9yICggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzICsrLCB0ICsrICkge1xuXG5cdFx0XHRcdFx0XHR2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG52IC0tO1xuXG5cdFx0XHRcdFx0LyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cblxuXHRcdFx0XHRcdGNvdW50ID0gMiAqIG52O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdH0gKSgpLFxuXG5cdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHRmdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMocG9pbnRzKSB7XG5cblx0XHRcdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBsID4gMiAmJiBwb2ludHNbIGwgLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0XHRcdHBvaW50cy5wb3AoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmVtb3ZlRHVwRW5kUHRzKCBjb250b3VyICk7XG5cdFx0aG9sZXMuZm9yRWFjaCggcmVtb3ZlRHVwRW5kUHRzICk7XG5cblx0XHRmdW5jdGlvbiBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZ1B0MSwgaW5TZWdQdDIsIGluT3RoZXJQdCApIHtcblxuXHRcdFx0Ly8gaW5PdGhlclB0IG5lZWRzIHRvIGJlIGNvbGxpbmVhciB0byB0aGUgaW5TZWdtZW50XG5cdFx0XHRpZiAoIGluU2VnUHQxLnggIT09IGluU2VnUHQyLnggKSB7XG5cblx0XHRcdFx0aWYgKCBpblNlZ1B0MS54IDwgaW5TZWdQdDIueCApIHtcblxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQyLnggKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0Mi54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0MS54ICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBpblNlZ1B0MS55IDwgaW5TZWdQdDIueSApIHtcblxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQyLnkgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0Mi55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0MS55ICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSB7XG5cblx0XHRcdHZhciBzZWcxZHggPSBpblNlZzFQdDIueCAtIGluU2VnMVB0MS54LCAgIHNlZzFkeSA9IGluU2VnMVB0Mi55IC0gaW5TZWcxUHQxLnk7XG5cdFx0XHR2YXIgc2VnMmR4ID0gaW5TZWcyUHQyLnggLSBpblNlZzJQdDEueCwgICBzZWcyZHkgPSBpblNlZzJQdDIueSAtIGluU2VnMlB0MS55O1xuXG5cdFx0XHR2YXIgc2VnMXNlZzJkeCA9IGluU2VnMVB0MS54IC0gaW5TZWcyUHQxLng7XG5cdFx0XHR2YXIgc2VnMXNlZzJkeSA9IGluU2VnMVB0MS55IC0gaW5TZWcyUHQxLnk7XG5cblx0XHRcdHZhciBsaW1pdFx0XHQ9IHNlZzFkeSAqIHNlZzJkeCAtIHNlZzFkeCAqIHNlZzJkeTtcblx0XHRcdHZhciBwZXJwU2VnMVx0PSBzZWcxZHkgKiBzZWcxc2VnMmR4IC0gc2VnMWR4ICogc2VnMXNlZzJkeTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbGltaXQgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxuXG5cdFx0XHRcdHZhciBwZXJwU2VnMjtcblx0XHRcdFx0aWYgKCBsaW1pdCA+IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxID4gMCApIHx8ICggcGVycFNlZzEgPCBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMiA+IDAgKSB8fCAoIHBlcnBTZWcyIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xuXHRcdFx0XHQvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMxP1xuXHRcdFx0XHRpZiAoIHBlcnBTZWcyID09PSAwICkge1xuXG5cdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG5cdFx0XHRcdFx0XHQgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MSBdO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gbGltaXQgKSB7XG5cblx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcblx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQyIF07XG5cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMyP1xuXHRcdFx0XHRpZiAoIHBlcnBTZWcxID09PSAwIClcdFx0cmV0dXJuIFsgaW5TZWcyUHQxIF07XG5cdFx0XHRcdGlmICggcGVycFNlZzEgPT09IGxpbWl0IClcdHJldHVybiBbIGluU2VnMlB0MiBdO1xuXG5cdFx0XHRcdC8vIHJldHVybiByZWFsIGludGVyc2VjdGlvbiBwb2ludFxuXHRcdFx0XHR2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XG5cdFx0XHRcdHJldHVyblx0WyB7IHg6IGluU2VnMVB0MS54ICsgZmFjdG9yU2VnMSAqIHNlZzFkeCxcblx0XHRcdFx0XHRcdFx0eTogaW5TZWcxUHQxLnkgKyBmYWN0b3JTZWcxICogc2VnMWR5IH0gXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcblx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxICE9PSAwICkgfHxcblx0XHRcdFx0XHQgKCBzZWcyZHkgKiBzZWcxc2VnMmR4ICE9PSBzZWcyZHggKiBzZWcxc2VnMmR5ICkgKSBcdFx0XHRyZXR1cm4gW107XG5cblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIG9yIGRlZ2VuZXJhdGVcblx0XHRcdFx0dmFyIHNlZzFQdCA9ICggKCBzZWcxZHggPT09IDAgKSAmJiAoIHNlZzFkeSA9PT0gMCApICk7XHQvLyBzZWdtZW50MSBpcyBqdXN0IGEgcG9pbnQ/XG5cdFx0XHRcdHZhciBzZWcyUHQgPSAoICggc2VnMmR4ID09PSAwICkgJiYgKCBzZWcyZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDIgaXMganVzdCBhIHBvaW50P1xuXHRcdFx0XHQvLyBib3RoIHNlZ21lbnRzIGFyZSBwb2ludHNcblx0XHRcdFx0aWYgKCBzZWcxUHQgJiYgc2VnMlB0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCAoIGluU2VnMVB0MS54ICE9PSBpblNlZzJQdDEueCApIHx8XG5cdFx0XHRcdFx0XHQgKCBpblNlZzFQdDEueSAhPT0gaW5TZWcyUHQxLnkgKSApXHRcdHJldHVybiBbXTtcdC8vIHRoZXkgYXJlIGRpc3RpbmN0ICBwb2ludHNcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTsgICAgICAgICAgICAgICAgIFx0XHRcdFx0XHRcdC8vIHRoZXkgYXJlIHRoZSBzYW1lIHBvaW50XG5cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XG5cdFx0XHRcdGlmICggc2VnMVB0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNlZ21lbnQjMiAgaXMgYSBzaW5nbGUgcG9pbnRcblx0XHRcdFx0aWYgKCBzZWcyUHQgKSB7XG5cblx0XHRcdFx0XHRpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMVxuXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMlB0MSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgc2VnbWVudHMsIHdoaWNoIG1pZ2h0IG92ZXJsYXBcblx0XHRcdFx0dmFyIHNlZzFtaW4sIHNlZzFtYXgsIHNlZzFtaW5WYWwsIHNlZzFtYXhWYWw7XG5cdFx0XHRcdHZhciBzZWcybWluLCBzZWcybWF4LCBzZWcybWluVmFsLCBzZWcybWF4VmFsO1xuXHRcdFx0XHRpZiAoIHNlZzFkeCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcblxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0MTsgc2VnMW1pblZhbCA9IGluU2VnMVB0MS54O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0Mjsgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi54O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS54O1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggaW5TZWcyUHQxLnggPCBpblNlZzJQdDIueCApIHtcblxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS54O1xuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi54O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0Mjsgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi54O1xuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS54O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcblxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0MTsgc2VnMW1pblZhbCA9IGluU2VnMVB0MS55O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0Mjsgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi55O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggaW5TZWcyUHQxLnkgPCBpblNlZzJQdDIueSApIHtcblxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS55O1xuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi55O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0Mjsgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi55O1xuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPCAgc2VnMm1pblZhbCApXHRyZXR1cm4gW107XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsID09PSBzZWcybWluVmFsIClcdHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBzZWcybWluIF07XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMm1pbiwgc2VnMW1heCBdO1xuXHRcdFx0XHRcdHJldHVyblx0WyBzZWcybWluLCBzZWcybWF4IF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsIClcdHJldHVybiBbXTtcblx0XHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPT09IHNlZzJtYXhWYWwgKVx0e1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApXHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHRcdHJldHVybiBbIHNlZzFtaW4gXTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApXHRyZXR1cm4gWyBzZWcxbWluLCBzZWcxbWF4IF07XG5cdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzFtaW4sIHNlZzJtYXggXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVBbmdsZSggaW5WZXJ0ZXgsIGluTGVnRnJvbVB0LCBpbkxlZ1RvUHQsIGluT3RoZXJQdCApIHtcblxuXHRcdFx0Ly8gVGhlIG9yZGVyIG9mIGxlZ3MgaXMgaW1wb3J0YW50XG5cblx0XHRcdC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXG5cdFx0XHR2YXIgbGVnRnJvbVB0WFx0PSBpbkxlZ0Zyb21QdC54IC0gaW5WZXJ0ZXgueCwgIGxlZ0Zyb21QdFlcdD0gaW5MZWdGcm9tUHQueSAtIGluVmVydGV4Lnk7XG5cdFx0XHR2YXIgbGVnVG9QdFhcdD0gaW5MZWdUb1B0LnhcdC0gaW5WZXJ0ZXgueCwgIGxlZ1RvUHRZXHRcdD0gaW5MZWdUb1B0LnlcdC0gaW5WZXJ0ZXgueTtcblx0XHRcdHZhciBvdGhlclB0WFx0PSBpbk90aGVyUHQueFx0LSBpblZlcnRleC54LCAgb3RoZXJQdFlcdFx0PSBpbk90aGVyUHQueVx0LSBpblZlcnRleC55O1xuXG5cdFx0XHQvLyBtYWluIGFuZ2xlID4wOiA8IDE4MCBkZWcuOyAwOiAxODAgZGVnLjsgPDA6ID4gMTgwIGRlZy5cblx0XHRcdHZhciBmcm9tMnRvQW5nbGVcdD0gbGVnRnJvbVB0WCAqIGxlZ1RvUHRZIC0gbGVnRnJvbVB0WSAqIGxlZ1RvUHRYO1xuXHRcdFx0dmFyIGZyb20yb3RoZXJBbmdsZVx0PSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIGZyb20ydG9BbmdsZSApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Ly8gYW5nbGUgIT0gMTgwIGRlZy5cblxuXHRcdFx0XHR2YXIgb3RoZXIydG9BbmdsZVx0XHQ9IG90aGVyUHRYICogbGVnVG9QdFkgLSBvdGhlclB0WSAqIGxlZ1RvUHRYO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJmcm9tMnRvOiBcIiArIGZyb20ydG9BbmdsZSArIFwiLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSArIFwiLCBvdGhlcjJ0bzogXCIgKyBvdGhlcjJ0b0FuZ2xlICk7XG5cblx0XHRcdFx0aWYgKCBmcm9tMnRvQW5nbGUgPiAwICkge1xuXG5cdFx0XHRcdFx0Ly8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXG5cdFx0XHRcdFx0cmV0dXJuXHQoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSAmJiAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG1haW4gYW5nbGUgPiAxODAgZGVnLlxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBhbmdsZSA9PSAxODAgZGVnLlxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJmcm9tMnRvOiAxODAgZGVnLiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgICk7XG5cdFx0XHRcdHJldHVyblx0KCBmcm9tMm90aGVyQW5nbGUgPiAwICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xuXG5cdFx0XHR2YXIgc2hhcGUgPSBjb250b3VyLmNvbmNhdCgpOyAvLyB3b3JrIG9uIHRoaXMgc2hhcGVcblx0XHRcdHZhciBob2xlO1xuXG5cdFx0XHRmdW5jdGlvbiBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIGluU2hhcGVJZHgsIGluSG9sZUlkeCApIHtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiBob2xlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBzaGFwZSBwb2ludFxuXHRcdFx0XHR2YXIgbGFzdFNoYXBlSWR4ID0gc2hhcGUubGVuZ3RoIC0gMTtcblxuXHRcdFx0XHR2YXIgcHJldlNoYXBlSWR4ID0gaW5TaGFwZUlkeCAtIDE7XG5cdFx0XHRcdGlmICggcHJldlNoYXBlSWR4IDwgMCApXHRcdFx0cHJldlNoYXBlSWR4ID0gbGFzdFNoYXBlSWR4O1xuXG5cdFx0XHRcdHZhciBuZXh0U2hhcGVJZHggPSBpblNoYXBlSWR4ICsgMTtcblx0XHRcdFx0aWYgKCBuZXh0U2hhcGVJZHggPiBsYXN0U2hhcGVJZHggKVx0bmV4dFNoYXBlSWR4ID0gMDtcblxuXHRcdFx0XHR2YXIgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIHNoYXBlWyBpblNoYXBlSWR4IF0sIHNoYXBlWyBwcmV2U2hhcGVJZHggXSwgc2hhcGVbIG5leHRTaGFwZUlkeCBdLCBob2xlWyBpbkhvbGVJZHggXSApO1xuXHRcdFx0XHRpZiAoICEgaW5zaWRlQW5nbGUgKSB7XG5cblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKFNoYXBlKTogXCIgKyBpblNoYXBlSWR4ICsgXCIsIFBvaW50OiBcIiArIGhvbGVbaW5Ib2xlSWR4XS54ICsgXCIvXCIgKyBob2xlW2luSG9sZUlkeF0ueSApO1xuXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XG5cdFx0XHRcdHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcblxuXHRcdFx0XHR2YXIgcHJldkhvbGVJZHggPSBpbkhvbGVJZHggLSAxO1xuXHRcdFx0XHRpZiAoIHByZXZIb2xlSWR4IDwgMCApXHRcdFx0cHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcblxuXHRcdFx0XHR2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xuXHRcdFx0XHRpZiAoIG5leHRIb2xlSWR4ID4gbGFzdEhvbGVJZHggKVx0bmV4dEhvbGVJZHggPSAwO1xuXG5cdFx0XHRcdGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlWyBpbkhvbGVJZHggXSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbIGluU2hhcGVJZHggXSApO1xuXHRcdFx0XHRpZiAoICEgaW5zaWRlQW5nbGUgKSB7XG5cblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKEhvbGUpOiBcIiArIGluSG9sZUlkeCArIFwiLCBQb2ludDogXCIgKyBzaGFwZVtpblNoYXBlSWR4XS54ICsgXCIvXCIgKyBzaGFwZVtpblNoYXBlSWR4XS55ICk7XG5cdFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuXHR0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggc2hhcGUgZWRnZXNcblx0XHRcdFx0dmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcblx0XHRcdFx0Zm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHggKysgKSB7XG5cblx0XHRcdFx0XHRuZXh0SWR4ID0gc0lkeCArIDE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbIHNJZHggXSwgc2hhcGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGVwSG9sZXMgPSBbXTtcblxuXHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGhvbGUgZWRnZXNcblx0XHRcdFx0dmFyIGloSWR4LCBjaGtIb2xlLFxuXHRcdFx0XHRcdGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcblx0XHRcdFx0Zm9yICggaWhJZHggPSAwOyBpaElkeCA8IGluZGVwSG9sZXMubGVuZ3RoOyBpaElkeCArKyApIHtcblxuXHRcdFx0XHRcdGNoa0hvbGUgPSBob2xlc1sgaW5kZXBIb2xlc1sgaWhJZHggXV07XG5cdFx0XHRcdFx0Zm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcblxuXHRcdFx0XHRcdFx0bmV4dElkeCA9IGhJZHggKyAxOyBuZXh0SWR4ICU9IGNoa0hvbGUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBjaGtIb2xlWyBoSWR4IF0sIGNoa0hvbGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGhvbGVJbmRleCwgc2hhcGVJbmRleCxcblx0XHRcdFx0c2hhcGVQdCwgaG9sZVB0LFxuXHRcdFx0XHRob2xlSWR4LCBjdXRLZXksIGZhaWxlZEN1dHMgPSBbXSxcblx0XHRcdFx0dG1wU2hhcGUxLCB0bXBTaGFwZTIsXG5cdFx0XHRcdHRtcEhvbGUxLCB0bXBIb2xlMjtcblxuXHRcdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdGluZGVwSG9sZXMucHVzaCggaCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtaW5TaGFwZUluZGV4ID0gMDtcblx0XHRcdHZhciBjb3VudGVyID0gaW5kZXBIb2xlcy5sZW5ndGggKiAyO1xuXHRcdFx0d2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y291bnRlciAtLTtcblx0XHRcdFx0aWYgKCBjb3VudGVyIDwgMCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxuXHRcdFx0XHQvLyB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRmb3IgKCBzaGFwZUluZGV4ID0gbWluU2hhcGVJbmRleDsgc2hhcGVJbmRleCA8IHNoYXBlLmxlbmd0aDsgc2hhcGVJbmRleCArKyApIHtcblxuXHRcdFx0XHRcdHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xuXHRcdFx0XHRcdGhvbGVJbmRleFx0PSAtIDE7XG5cblx0XHRcdFx0XHQvLyBzZWFyY2ggZm9yIGhvbGUgd2hpY2ggY2FuIGJlIHJlYWNoZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0Zm9yICggdmFyIGggPSAwOyBoIDwgaW5kZXBIb2xlcy5sZW5ndGg7IGggKysgKSB7XG5cblx0XHRcdFx0XHRcdGhvbGVJZHggPSBpbmRlcEhvbGVzWyBoIF07XG5cblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgbXVsdGlwbGUgY2hlY2tzXG5cdFx0XHRcdFx0XHRjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcblx0XHRcdFx0XHRcdGlmICggZmFpbGVkQ3V0c1sgY3V0S2V5IF0gIT09IHVuZGVmaW5lZCApXHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRcdGhvbGUgPSBob2xlc1sgaG9sZUlkeCBdO1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aG9sZVB0ID0gaG9sZVsgaDIgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCAhIGlzQ3V0TGluZUluc2lkZUFuZ2xlcyggc2hhcGVJbmRleCwgaDIgKSApXHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNTaGFwZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c0hvbGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApXHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRcdGhvbGVJbmRleCA9IGgyO1xuXHRcdFx0XHRcdFx0XHRpbmRlcEhvbGVzLnNwbGljZSggaCwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4ICsgMSApO1xuXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCArIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRzaGFwZSA9IHRtcFNoYXBlMS5jb25jYXQoIHRtcEhvbGUxICkuY29uY2F0KCB0bXBIb2xlMiApLmNvbmNhdCggdG1wU2hhcGUyICk7XG5cblx0XHRcdFx0XHRcdFx0bWluU2hhcGVJbmRleCA9IHNoYXBlSW5kZXg7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRGVidWcgb25seSwgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgY3V0c1xuXHRcdFx0XHRcdFx0XHQvLyBnbG9iX0N1dExpbmVzLnB1c2goIFsgc2hhcGVQdCwgaG9sZVB0IF0gKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcblxuXHRcdFx0XHRcdFx0ZmFpbGVkQ3V0c1sgY3V0S2V5IF0gPSB0cnVlO1x0XHRcdC8vIHJlbWVtYmVyIGZhaWx1cmVcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGhvbGVJbmRleCA+PSAwIClcdGJyZWFrO1x0XHQvLyBob2xlLXZlcnRleCBmb3VuZFxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2hhcGU7IFx0XHRcdC8qIHNoYXBlIHdpdGggbm8gaG9sZXMgKi9cblxuXHRcdH1cblxuXG5cdFx0dmFyIGksIGlsLCBmLCBmYWNlLFxuXHRcdFx0a2V5LCBpbmRleCxcblx0XHRcdGFsbFBvaW50c01hcCA9IHt9O1xuXG5cdFx0Ly8gVG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9sZCBzaGFwZSwgb25lIG11c3QgbWF0Y2ggY29vcmRpbmF0ZXMsIG9yIG9mZnNldCB0aGUgaW5kaWNlcyBmcm9tIG9yaWdpbmFsIGFycmF5cy4gSXQncyBwcm9iYWJseSBlYXNpZXIgdG8gZG8gdGhlIGZpcnN0LlxuXG5cdFx0dmFyIGFsbHBvaW50cyA9IGNvbnRvdXIuY29uY2F0KCk7XG5cblx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBhbGxwb2ludHMsIGhvbGVzWyBoIF0gKTtcblxuXHRcdH1cblxuXHRcdC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XG5cblx0XHQvLyBwcmVwYXJlIGFsbCBwb2ludHMgbWFwXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBhbGxwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XG5cblx0XHRcdGlmICggYWxsUG9pbnRzTWFwWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5TaGFwZVV0aWxzOiBEdXBsaWNhdGUgcG9pbnRcIiwga2V5LCBpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YWxsUG9pbnRzTWFwWyBrZXkgXSA9IGk7XG5cblx0XHR9XG5cblx0XHQvLyByZW1vdmUgaG9sZXMgYnkgY3V0dGluZyBwYXRocyB0byBob2xlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIHNoYXBlXG5cdFx0dmFyIHNoYXBlV2l0aG91dEhvbGVzID0gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICk7XG5cblx0XHR2YXIgdHJpYW5nbGVzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZSggc2hhcGVXaXRob3V0SG9sZXMsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxuXHRcdC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XG5cblx0XHQvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xuXG5cdFx0XHRcdGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcblxuXHRcdFx0XHRpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XG5cblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0ZmFjZVsgZiBdID0gaW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCgpO1xuXG5cdH0sXG5cblx0aXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xuXG5cdFx0cmV0dXJuIFNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcbiAqXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZT4gLy8gY3VydmUgdG8gZXh0cnVkZSBzaGFwZSBhbG9uZ1xuICogIGZyYW1lczogPE9iamVjdD4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xuICpcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqKi9cblxuZnVuY3Rpb24gRXh0cnVkZUdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cblx0aWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xuXG5cdFx0c2hhcGVzID0gW107XG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XG5cblx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG5cdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXG5cdC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xuXHQvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXG5cblx0Ly90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0Ly9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XG5cbn1cblxuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dHJ1ZGVHZW9tZXRyeTtcblxuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuXHR2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xuXG5cdGZvciAoIHZhciBzID0gMDsgcyA8IHNsOyBzICsrICkge1xuXG5cdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcblxuXHR9XG5cbn07XG5cbkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG5cdHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XG5cblx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXG5cdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcblx0dmFyIGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cblx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXG5cblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG5cdHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXG5cdHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG5cdHZhciBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XG5cblx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBFeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcblxuXHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuXHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xuXG5cdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuXHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuXHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cblx0XHRzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogZXh0cnVkZVBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggc3RlcHMsIGZhbHNlICk7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuXHRcdGJpbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0fVxuXG5cdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxuXG5cdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRiZXZlbFNlZ21lbnRzID0gMDtcblx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XG5cdFx0YmV2ZWxTaXplID0gMDtcblxuXHR9XG5cblx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXG5cblx0dmFyIGFob2xlLCBoLCBobDsgLy8gbG9vcGluZyBvZiBob2xlc1xuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdHZhciByZXZlcnNlID0gISBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG5cdGlmICggcmV2ZXJzZSApIHtcblxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG5cdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcblxuXHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXG5cblx0fVxuXG5cblx0dmFyIGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuXHQvKiBWZXJ0aWNlcyAqL1xuXG5cdHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cblx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcblxuXHR9XG5cblxuXHRmdW5jdGlvbiBzY2FsZVB0MiggcHQsIHZlYywgc2l6ZSApIHtcblxuXHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcblxuXHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcblxuXHR9XG5cblx0dmFyIGIsIGJzLCB0LCB6LFxuXHRcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG5cdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuXHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcblx0XHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG5cdFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXG5cdFx0Ly9cblx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuXHRcdC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXG5cblx0XHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7XHRcdC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcblx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxuXG5cdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cblx0XHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xuXG5cdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuXHRcdHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0aWYgKCBNYXRoLmFicyggY29sbGluZWFyMCApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcblxuXHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cblx0XHRcdHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG5cdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cblx0XHRcdHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xuXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XG5cblx0XHRcdHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xuXHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XG5cblx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cblx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xuXHRcdFx0XHRcdCAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0XHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG5cdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG5cdFx0XHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XG5cblx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG5cdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHR2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XG5cdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcblxuXHRcdFx0XHRyZXR1cm5cdG5ldyBWZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcblxuXHRcdFx0dmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlO1x0XHQvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuXHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XG5cblx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG5cdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG5cdFx0XHRcdHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuXHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcblx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm5cdG5ldyBWZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG5cdH1cblxuXG5cdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cblx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG5cdH1cblxuXHR2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSwgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG5cdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0fVxuXG5cdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuXHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0fVxuXG5cblx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXG5cdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xuXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cblx0XHR9XG5cblx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRicyA9IGJldmVsU2l6ZTtcblxuXHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cblx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cblx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuXHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuXHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXG5cblx0dmFyIHM7XG5cblx0Zm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cblx0XHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cblx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuXHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG5cdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuXHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXG5cblx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHRmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcblxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyAoIHQgKiBNYXRoLlBJIC8gMiApO1xuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xuXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuXHRcdH1cblxuXHRcdC8vIGV4cGFuZCBob2xlc1xuXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qIEZhY2VzICovXG5cblx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuXHRidWlsZExpZEZhY2VzKCk7XG5cblx0Ly8gU2lkZXMgZmFjZXNcblxuXHRidWlsZFNpZGVGYWNlcygpO1xuXG5cblx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG5cdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cblx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcblx0XHRcdG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUb3AgZmFjZXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cblx0XHR2YXIgbGF5ZXJvZmZzZXQgPSAwO1xuXHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcblx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xuXG5cdFx0XHQvLywgdHJ1ZVxuXHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG5cdFx0dmFyIGosIGs7XG5cdFx0aSA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XG5cblx0XHRcdGogPSBpO1xuXHRcdFx0ayA9IGkgLSAxO1xuXHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG5cdFx0XHR2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cblx0XHRcdGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cblx0XHRcdFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XG5cdFx0XHRcdHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XG5cblx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcblx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuXHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuXHRcdFx0XHRmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXG5cdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XG5cblx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggeCwgeSwgeiApICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xuXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XG5cblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIDAgKSApO1xuXG5cdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCBhLCBiLCBjICk7XG5cblx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZzICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkLCB3YWxsQ29udG91ciwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApIHtcblxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGQgKz0gc2hhcGVzT2Zmc2V0O1xuXG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IEZhY2UzKCBhLCBiLCBkLCBudWxsLCBudWxsLCAxICkgKTtcblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGIsIGMsIGQsIG51bGwsIG51bGwsIDEgKSApO1xuXG5cdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcblxuXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMCBdLCB1dnNbIDEgXSwgdXZzWyAzIF0gXSApO1xuXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMSBdLCB1dnNbIDIgXSwgdXZzWyAzIF0gXSApO1xuXG5cdH1cblxufTtcblxuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgPSB7XG5cblx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0dmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XG5cdFx0dmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XG5cdFx0dmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0bmV3IFZlY3RvcjIoIGEueCwgYS55ICksXG5cdFx0XHRuZXcgVmVjdG9yMiggYi54LCBiLnkgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBjLngsIGMueSApXG5cdFx0XTtcblxuXHR9LFxuXG5cdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHR2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcblx0XHR2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcblx0XHR2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcblx0XHR2YXIgZCA9IHZlcnRpY2VzWyBpbmRleEQgXTtcblxuXHRcdGlmICggTWF0aC5hYnMoIGEueSAtIGIueSApIDwgMC4wMSApIHtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYi54LCAxIC0gYi56ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjLngsIDEgLSBjLnogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGQueCwgMSAtIGQueiApXG5cdFx0XHRdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGEueSwgMSAtIGEueiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYi55LCAxIC0gYi56ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjLnksIDEgLSBjLnogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGQueSwgMSAtIGQueiApXG5cdFx0XHRdO1xuXG5cdFx0fVxuXG5cdH1cbn07XG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBUZXh0ID0gM0QgVGV4dFxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgZm9udDogPFRIUkVFLkZvbnQ+LCAvLyBmb250XG4gKlxuICogIHNpemU6IDxmbG9hdD4sIC8vIHNpemUgb2YgdGhlIHRleHRcbiAqICBoZWlnaHQ6IDxmbG9hdD4sIC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+IC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBUZXh0R2VvbWV0cnkoIHRleHQsIHBhcmFtZXRlcnMgKSB7XG5cblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0dmFyIGZvbnQgPSBwYXJhbWV0ZXJzLmZvbnQ7XG5cblx0aWYgKCAoIGZvbnQgJiYgZm9udC5pc0ZvbnQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVGV4dEdlb21ldHJ5OiBmb250IHBhcmFtZXRlciBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRm9udC4nICk7XG5cdFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpO1xuXG5cdH1cblxuXHR2YXIgc2hhcGVzID0gZm9udC5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgcGFyYW1ldGVycy5zaXplLCBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgKTtcblxuXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXG5cblx0cGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcblxuXHQvLyBkZWZhdWx0c1xuXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxTaXplID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XG5cdGlmICggcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID0gZmFsc2U7XG5cblx0RXh0cnVkZUdlb21ldHJ5LmNhbGwoIHRoaXMsIHNoYXBlcywgcGFyYW1ldGVycyApO1xuXG5cdHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xuXG59XG5cblRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XG5UZXh0R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gU3BoZXJlR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cbn1cblxuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmVHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKi9cblxuZnVuY3Rpb24gU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHRyYWRpdXMgPSByYWRpdXMgfHwgNTA7XG5cblx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xuXHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcblxuXHRwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XG5cdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XG5cblx0dmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xuXG5cdHZhciBpeCwgaXk7XG5cblx0dmFyIGluZGV4ID0gMDtcblx0dmFyIGdyaWQgPSBbXTtcblxuXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Ly8gYnVmZmVyc1xuXG5cdHZhciBpbmRpY2VzID0gW107XG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9ybWFscyA9IFtdO1xuXHR2YXIgdXZzID0gW107XG5cblx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdGZvciAoIGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xuXG5cdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XG5cblx0XHR2YXIgdiA9IGl5IC8gaGVpZ2h0U2VnbWVudHM7XG5cblx0XHRmb3IgKCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IGl4IC8gd2lkdGhTZWdtZW50cztcblxuXHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdHZlcnRleC54ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRub3JtYWwuc2V0KCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICkubm9ybWFsaXplKCk7XG5cdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0Ly8gdXZcblxuXHRcdFx0dXZzLnB1c2goIHUsIDEgLSB2ICk7XG5cblx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHR9XG5cblx0XHRncmlkLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cblx0fVxuXG5cdC8vIGluZGljZXNcblxuXHRmb3IgKCBpeSA9IDA7IGl5IDwgaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xuXG5cdFx0Zm9yICggaXggPSAwOyBpeCA8IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xuXHRcdFx0dmFyIGIgPSBncmlkWyBpeSBdWyBpeCBdO1xuXHRcdFx0dmFyIGMgPSBncmlkWyBpeSArIDEgXVsgaXggXTtcblx0XHRcdHZhciBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xuXG5cdFx0XHRpZiAoIGl5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRpZiAoIGl5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJICkgaW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxufVxuXG5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgS2FsZWIgTXVycGh5XG4gKi9cblxuZnVuY3Rpb24gUmluZ0dlb21ldHJ5KCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcblx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFJpbmdCdWZmZXJHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xuXG59XG5cblJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSaW5nR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBSaW5nQnVmZmVyR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUmluZ0J1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcblx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuXHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG5cdGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgMjA7XG5cdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XG5cblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG5cdHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcblx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiAxO1xuXG5cdC8vIGJ1ZmZlcnNcblxuXHR2YXIgaW5kaWNlcyA9IFtdO1xuXHR2YXIgdmVydGljZXMgPSBbXTtcblx0dmFyIG5vcm1hbHMgPSBbXTtcblx0dmFyIHV2cyA9IFtdO1xuXG5cdC8vIHNvbWUgaGVscGVyIHZhcmlhYmxlc1xuXG5cdHZhciBzZWdtZW50O1xuXHR2YXIgcmFkaXVzID0gaW5uZXJSYWRpdXM7XG5cdHZhciByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XG5cdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgaiwgaTtcblxuXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0Zm9yICggaiA9IDA7IGogPD0gcGhpU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHQvLyB2YWx1ZXMgYXJlIGdlbmVyYXRlIGZyb20gdGhlIGluc2lkZSBvZiB0aGUgcmluZyB0byB0aGUgb3V0c2lkZVxuXG5cdFx0XHRzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHQvLyB1dlxuXG5cdFx0XHR1di54ID0gKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcblx0XHRcdHV2LnkgPSAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xuXG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcblxuXHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXG5cdH1cblxuXHQvLyBpbmRpY2VzXG5cblx0Zm9yICggaiA9IDA7IGogPCBwaGlTZWdtZW50czsgaiArKyApIHtcblxuXHRcdHZhciB0aGV0YVNlZ21lbnRMZXZlbCA9IGogKiAoIHRoZXRhU2VnbWVudHMgKyAxICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdHNlZ21lbnQgPSBpICsgdGhldGFTZWdtZW50TGV2ZWw7XG5cblx0XHRcdHZhciBhID0gc2VnbWVudDtcblx0XHRcdHZhciBiID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuXHRcdFx0dmFyIGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cdFx0XHR2YXIgZCA9IHNlZ21lbnQgKyAxO1xuXG5cdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbn1cblxuUmluZ0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuUmluZ0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdCdWZmZXJHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG4vLyBwb2ludHMgLSB0byBjcmVhdGUgYSBjbG9zZWQgdG9ydXMsIG9uZSBtdXN0IHVzZSBhIHNldCBvZiBwb2ludHNcbi8vICAgIGxpa2Ugc286IFsgYSwgYiwgYywgZCwgYSBdLCBzZWUgZmlyc3QgaXMgdGhlIHNhbWUgYXMgbGFzdC5cbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxuLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXG4vLyBwaGlMZW5ndGggLSB0aGUgcmFkaWFuICgwIHRvIDJQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXG4vLyAgICAyUEkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxuXG5mdW5jdGlvbiBMYXRoZUdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xuXG5cdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHBvaW50czogcG9pbnRzLFxuXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IExhdGhlQnVmZmVyR2VvbWV0cnkoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSApO1xuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufVxuXG5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXRoZUdlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKi9cblxuZnVuY3Rpb24gTGF0aGVCdWZmZXJHZW9tZXRyeSggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0xhdGhlQnVmZmVyR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdH07XG5cblx0c2VnbWVudHMgPSBNYXRoLmZsb29yKCBzZWdtZW50cyApIHx8IDEyO1xuXHRwaGlTdGFydCA9IHBoaVN0YXJ0IHx8IDA7XG5cdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCBNYXRoLlBJICogMjtcblxuXHQvLyBjbGFtcCBwaGlMZW5ndGggc28gaXQncyBpbiByYW5nZSBvZiBbIDAsIDJQSSBdXG5cblx0cGhpTGVuZ3RoID0gX01hdGguY2xhbXAoIHBoaUxlbmd0aCwgMCwgTWF0aC5QSSAqIDIgKTtcblxuXG5cdC8vIGJ1ZmZlcnNcblxuXHR2YXIgaW5kaWNlcyA9IFtdO1xuXHR2YXIgdmVydGljZXMgPSBbXTtcblx0dmFyIHV2cyA9IFtdO1xuXG5cdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHR2YXIgYmFzZTtcblx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIGksIGo7XG5cblx0Ly8gZ2VuZXJhdGUgdmVydGljZXMgYW5kIHV2c1xuXG5cdGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcblxuXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggcGhpICk7XG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKCBwaGkgKTtcblxuXHRcdGZvciAoIGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdHZlcnRleC54ID0gcG9pbnRzWyBqIF0ueCAqIHNpbjtcblx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcblx0XHRcdHZlcnRleC56ID0gcG9pbnRzWyBqIF0ueCAqIGNvcztcblxuXHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHQvLyB1dlxuXG5cdFx0XHR1di54ID0gaSAvIHNlZ21lbnRzO1xuXHRcdFx0dXYueSA9IGogLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XG5cblx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gaW5kaWNlc1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0YmFzZSA9IGogKyBpICogcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0dmFyIGEgPSBiYXNlO1xuXHRcdFx0dmFyIGIgPSBiYXNlICsgcG9pbnRzLmxlbmd0aDtcblx0XHRcdHZhciBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xuXHRcdFx0dmFyIGQgPSBiYXNlICsgMTtcblxuXHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0Ly8gZ2VuZXJhdGUgbm9ybWFsc1xuXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgY2xvc2VkLCB3ZSBuZWVkIHRvIGF2ZXJhZ2UgdGhlIG5vcm1hbHMgYWxvbmcgdGhlIHNlYW0uXG5cdC8vIGJlY2F1c2UgdGhlIGNvcnJlc3BvbmRpbmcgdmVydGljZXMgYXJlIGlkZW50aWNhbCAoYnV0IHN0aWxsIGhhdmUgZGlmZmVyZW50IFVWcykuXG5cblx0aWYgKCBwaGlMZW5ndGggPT09IE1hdGguUEkgKiAyICkge1xuXG5cdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXHRcdHZhciBuMSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIG4yID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyB0aGlzIGlzIHRoZSBidWZmZXIgb2Zmc2V0IGZvciB0aGUgbGFzdCBsaW5lIG9mIHZlcnRpY2VzXG5cblx0XHRiYXNlID0gc2VnbWVudHMgKiBwb2ludHMubGVuZ3RoICogMztcblxuXHRcdGZvciAoIGkgPSAwLCBqID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKyssIGogKz0gMyApIHtcblxuXHRcdFx0Ly8gc2VsZWN0IHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCBpbiB0aGUgZmlyc3QgbGluZVxuXG5cdFx0XHRuMS54ID0gbm9ybWFsc1sgaiArIDAgXTtcblx0XHRcdG4xLnkgPSBub3JtYWxzWyBqICsgMSBdO1xuXHRcdFx0bjEueiA9IG5vcm1hbHNbIGogKyAyIF07XG5cblx0XHRcdC8vIHNlbGVjdCB0aGUgbm9ybWFsIG9mIHRoZSB2ZXJ0ZXggaW4gdGhlIGxhc3QgbGluZVxuXG5cdFx0XHRuMi54ID0gbm9ybWFsc1sgYmFzZSArIGogKyAwIF07XG5cdFx0XHRuMi55ID0gbm9ybWFsc1sgYmFzZSArIGogKyAxIF07XG5cdFx0XHRuMi56ID0gbm9ybWFsc1sgYmFzZSArIGogKyAyIF07XG5cblx0XHRcdC8vIGF2ZXJhZ2Ugbm9ybWFsc1xuXG5cdFx0XHRuLmFkZFZlY3RvcnMoIG4xLCBuMiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHQvLyBhc3NpZ24gdGhlIG5ldyB2YWx1ZXMgdG8gYm90aCBub3JtYWxzXG5cblx0XHRcdG5vcm1hbHNbIGogKyAwIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDAgXSA9IG4ueDtcblx0XHRcdG5vcm1hbHNbIGogKyAxIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDEgXSA9IG4ueTtcblx0XHRcdG5vcm1hbHNbIGogKyAyIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDIgXSA9IG4uejtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuTGF0aGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbkxhdGhlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF0aGVCdWZmZXJHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cbiAqL1xuXG5mdW5jdGlvbiBTaGFwZUdlb21ldHJ5KCBzaGFwZXMsIGN1cnZlU2VnbWVudHMgKSB7XG5cblx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTaGFwZUdlb21ldHJ5JztcblxuXHRpZiAoIHR5cGVvZiBjdXJ2ZVNlZ21lbnRzID09PSAnb2JqZWN0JyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlR2VvbWV0cnk6IE9wdGlvbnMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0Y3VydmVTZWdtZW50cyA9IGN1cnZlU2VnbWVudHMuY3VydmVTZWdtZW50cztcblxuXHR9XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHNoYXBlczogc2hhcGVzLFxuXHRcdGN1cnZlU2VnbWVudHM6IGN1cnZlU2VnbWVudHNcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFNoYXBlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgY3VydmVTZWdtZW50cyApICk7XG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG59XG5cblNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYXBlR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBTaGFwZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIGN1cnZlU2VnbWVudHMgKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTaGFwZUJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xuXHR9O1xuXG5cdGN1cnZlU2VnbWVudHMgPSBjdXJ2ZVNlZ21lbnRzIHx8IDEyO1xuXG5cdC8vIGJ1ZmZlcnNcblxuXHR2YXIgaW5kaWNlcyA9IFtdO1xuXHR2YXIgdmVydGljZXMgPSBbXTtcblx0dmFyIG5vcm1hbHMgPSBbXTtcblx0dmFyIHV2cyA9IFtdO1xuXG5cdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHR2YXIgZ3JvdXBTdGFydCA9IDA7XG5cdHZhciBncm91cENvdW50ID0gMDtcblxuXHQvLyBhbGxvdyBzaW5nbGUgYW5kIGFycmF5IHZhbHVlcyBmb3IgXCJzaGFwZXNcIiBwYXJhbWV0ZXJcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHtcblxuXHRcdGFkZFNoYXBlKCBzaGFwZXMgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2hhcGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0YWRkU2hhcGUoIHNoYXBlc1sgaSBdICk7XG5cblx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIGkgKTsgLy8gZW5hYmxlcyBNdWx0aU1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXHRcdFx0Z3JvdXBDb3VudCA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXG5cdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XG5cblx0XHR2YXIgaSwgbCwgc2hhcGVIb2xlO1xuXG5cdFx0dmFyIGluZGV4T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMztcblx0XHR2YXIgcG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG5cdFx0dmFyIHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XG5cdFx0dmFyIHNoYXBlSG9sZXMgPSBwb2ludHMuaG9sZXM7XG5cblx0XHQvLyBjaGVjayBkaXJlY3Rpb24gb2YgdmVydGljZXNcblxuXHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVWZXJ0aWNlcyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMucmV2ZXJzZSgpO1xuXG5cdFx0XHQvLyBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlSG9sZSApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0c2hhcGVIb2xlc1sgaSBdID0gc2hhcGVIb2xlLnJldmVyc2UoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggc2hhcGVWZXJ0aWNlcywgc2hhcGVIb2xlcyApO1xuXG5cdFx0Ly8gam9pbiB2ZXJ0aWNlcyBvZiBpbm5lciBhbmQgb3V0ZXIgcGF0aHMgdG8gYSBzaW5nbGUgYXJyYXlcblxuXHRcdGZvciAoIGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRzaGFwZUhvbGUgPSBzaGFwZUhvbGVzWyBpIF07XG5cdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoIHNoYXBlSG9sZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdmVydGljZXMsIG5vcm1hbHMsIHV2c1xuXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBzaGFwZVZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBzaGFwZVZlcnRpY2VzWyBpIF07XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgMCApO1xuXHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cdFx0XHR1dnMucHVzaCggdmVydGV4LngsIHZlcnRleC55ICk7IC8vIHdvcmxkIHV2c1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5jaWRlc1xuXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdHZhciBhID0gZmFjZVsgMCBdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHR2YXIgYiA9IGZhY2VbIDEgXSArIGluZGV4T2Zmc2V0O1xuXHRcdFx0dmFyIGMgPSBmYWNlWyAyIF0gKyBpbmRleE9mZnNldDtcblxuXHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XG5cdFx0XHRncm91cENvdW50ICs9IDM7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cblNoYXBlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5TaGFwZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYXBlQnVmZmVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICovXG5cbmZ1bmN0aW9uIEVkZ2VzR2VvbWV0cnkoIGdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApIHtcblxuXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0VkZ2VzR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR0aHJlc2hvbGRBbmdsZTogdGhyZXNob2xkQW5nbGVcblx0fTtcblxuXHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xuXG5cdC8vIGJ1ZmZlclxuXG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG5cdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHR2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIF9NYXRoLkRFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSApO1xuXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBlZGdlcyA9IHt9O1xuXHR2YXIga2V5LCBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cblx0Ly8gcHJlcGFyZSBzb3VyY2UgZ2VvbWV0cnlcblxuXHR2YXIgZ2VvbWV0cnkyO1xuXG5cdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdGdlb21ldHJ5MiA9IG5ldyBHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XG5cblx0fVxuXG5cdGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XG5cdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR2YXIgc291cmNlVmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG5cdHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcblxuXHQvLyBub3cgY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgd2hlcmUgZWFjaCBlbnRyeSByZXByZXNlbnRzIGFuIGVkZ2Ugd2l0aCBpdHMgYWRqb2luaW5nIGZhY2VzXG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuXHRcdFx0ZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG5cdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG5cdFx0XHRrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdGlmICggZWRnZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZWRnZXNbIGtleSBdID0geyBpbmRleDE6IGVkZ2VbIDAgXSwgaW5kZXgyOiBlZGdlWyAxIF0sIGZhY2UxOiBpLCBmYWNlMjogdW5kZWZpbmVkIH07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZWRnZXNbIGtleSBdLmZhY2UyID0gaTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlc1xuXG5cdGZvciAoIGtleSBpbiBlZGdlcyApIHtcblxuXHRcdHZhciBlID0gZWRnZXNbIGtleSBdO1xuXG5cdFx0Ly8gYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSAoaW4gZGVncmVlcykgYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIHRoZSBhZGpvaW5pbmcgZmFjZXMgZXhjZWVkcyB0aGlzIHZhbHVlLiBkZWZhdWx0ID0gMSBkZWdyZWUuXG5cblx0XHRpZiAoIGUuZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgZS5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBlLmZhY2UyIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gc291cmNlVmVydGljZXNbIGUuaW5kZXgxIF07XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdHZlcnRleCA9IHNvdXJjZVZlcnRpY2VzWyBlLmluZGV4MiBdO1xuXHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXG5cdC8vIGN1c3RvbSBhcnJheSBzb3J0IGZ1bmN0aW9uXG5cblx0ZnVuY3Rpb24gc29ydEZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGEgLSBiO1xuXG5cdH1cblxufVxuXG5FZGdlc0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGdlc0dlb21ldHJ5O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQ3lsaW5kZXJHZW9tZXRyeSggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuXHRcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxuXHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG59XG5cbkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN5bGluZGVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDeWxpbmRlckJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0cmFkaXVzVG9wID0gcmFkaXVzVG9wICE9PSB1bmRlZmluZWQgPyByYWRpdXNUb3AgOiAyMDtcblx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcblx0aGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XG5cblx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XG5cdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuXG5cdG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMC4wO1xuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IDIuMCAqIE1hdGguUEk7XG5cblx0Ly8gYnVmZmVyc1xuXG5cdHZhciBpbmRpY2VzID0gW107XG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9ybWFscyA9IFtdO1xuXHR2YXIgdXZzID0gW107XG5cblx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciBpbmRleE9mZnNldCA9IDA7XG5cdHZhciBpbmRleEFycmF5ID0gW107XG5cdHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblx0dmFyIGdyb3VwU3RhcnQgPSAwO1xuXG5cdC8vIGdlbmVyYXRlIGdlb21ldHJ5XG5cblx0Z2VuZXJhdGVUb3JzbygpO1xuXG5cdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSApIHtcblxuXHRcdGlmICggcmFkaXVzVG9wID4gMCApIGdlbmVyYXRlQ2FwKCB0cnVlICk7XG5cdFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XG5cblx0fVxuXG5cdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xuXG5cdFx0dmFyIHgsIHk7XG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR2YXIgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHQvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuXHRcdHZhciBzbG9wZSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdFx0dmFyIGluZGV4Um93ID0gW107XG5cblx0XHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcblxuXHRcdFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xuXG5cdFx0XHRmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0XHR2YXIgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXG5cdFx0XHRcdHZhciBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xuXHRcdFx0XHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XG5cdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwuc2V0KCBzaW5UaGV0YSwgc2xvcGUsIGNvc1RoZXRhICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIHUsIDEgLSB2ICk7XG5cblx0XHRcdFx0Ly8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcblxuXHRcdFx0XHRpbmRleFJvdy5wdXNoKCBpbmRleCArKyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG5vdyBzYXZlIHZlcnRpY2VzIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XG5cblx0XHRcdGluZGV4QXJyYXkucHVzaCggaW5kZXhSb3cgKTtcblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cblx0XHRcdFx0Ly8gd2UgdXNlIHRoZSBpbmRleCBhcnJheSB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgaW5kaWNlc1xuXG5cdFx0XHRcdHZhciBhID0gaW5kZXhBcnJheVsgeSBdWyB4IF07XG5cdFx0XHRcdHZhciBiID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCBdO1xuXHRcdFx0XHR2YXIgYyA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggKyAxIF07XG5cdFx0XHRcdHZhciBkID0gaW5kZXhBcnJheVsgeSBdWyB4ICsgMSBdO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBncm91cCBjb3VudGVyXG5cblx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDAgKTtcblxuXHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUNhcCggdG9wICkge1xuXG5cdFx0dmFyIHgsIGNlbnRlckluZGV4U3RhcnQsIGNlbnRlckluZGV4RW5kO1xuXG5cdFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciBncm91cENvdW50ID0gMDtcblxuXHRcdHZhciByYWRpdXMgPSAoIHRvcCA9PT0gdHJ1ZSApID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xuXHRcdHZhciBzaWduID0gKCB0b3AgPT09IHRydWUgKSA/IDEgOiAtIDE7XG5cblx0XHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2VudGVyIHZlcnRleFxuXHRcdGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcblxuXHRcdC8vIGZpcnN0IHdlIGdlbmVyYXRlIHRoZSBjZW50ZXIgdmVydGV4IGRhdGEgb2YgdGhlIGNhcC5cblx0XHQvLyBiZWNhdXNlIHRoZSBnZW9tZXRyeSBuZWVkcyBvbmUgc2V0IG9mIHV2cyBwZXIgZmFjZSxcblx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cblx0XHRmb3IgKCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIGhhbGZIZWlnaHQgKiBzaWduLCAwICk7XG5cblx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcblxuXHRcdFx0Ly8gdXZcblxuXHRcdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XG5cblx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdGluZGV4ICsrO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2VudGVyIHZlcnRleFxuXG5cdFx0Y2VudGVySW5kZXhFbmQgPSBpbmRleDtcblxuXHRcdC8vIG5vdyB3ZSBnZW5lcmF0ZSB0aGUgc3Vycm91bmRpbmcgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXHRcdFx0dmFyIHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuXHRcdFx0dmFyIGNvc1RoZXRhID0gTWF0aC5jb3MoIHRoZXRhICk7XG5cdFx0XHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG5cdFx0XHR2ZXJ0ZXgueSA9IGhhbGZIZWlnaHQgKiBzaWduO1xuXHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xuXG5cdFx0XHQvLyB1dlxuXG5cdFx0XHR1di54ID0gKCBjb3NUaGV0YSAqIDAuNSApICsgMC41O1xuXHRcdFx0dXYueSA9ICggc2luVGhldGEgKiAwLjUgKiBzaWduICkgKyAwLjU7XG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuXG5cdFx0XHRpbmRleCArKztcblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdHZhciBjID0gY2VudGVySW5kZXhTdGFydCArIHg7XG5cdFx0XHR2YXIgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcblxuXHRcdFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gZmFjZSB0b3BcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCBjICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gZmFjZSBib3R0b21cblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGkgKyAxLCBpLCBjICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMiApO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0fVxuXG59XG5cbkN5bGluZGVyQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5DeWxpbmRlckJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN5bGluZGVyQnVmZmVyR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxuICovXG5cbmZ1bmN0aW9uIENvbmVHZW9tZXRyeSggcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRDeWxpbmRlckdlb21ldHJ5LmNhbGwoIHRoaXMsIDAsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKTtcblxuXHR0aGlzLnR5cGUgPSAnQ29uZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG59XG5cbkNvbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuQ29uZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yOiBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxuICovXG5cbmZ1bmN0aW9uIENvbmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIDAsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKTtcblxuXHR0aGlzLnR5cGUgPSAnQ29uZUJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG59XG5cbkNvbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuQ29uZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVCdWZmZXJHZW9tZXRyeTtcblxuLyoqXG4gKiBAYXV0aG9yIGh1Z2hlc1xuICovXG5cbmZ1bmN0aW9uIENpcmNsZUdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdH07XG5cblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBDaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xuXG59XG5cbkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlR2VvbWV0cnk7XG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICovXG5cbmZ1bmN0aW9uIENpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdH07XG5cblx0cmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuXHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XG5cblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG5cdC8vIGJ1ZmZlcnNcblxuXHR2YXIgaW5kaWNlcyA9IFtdO1xuXHR2YXIgdmVydGljZXMgPSBbXTtcblx0dmFyIG5vcm1hbHMgPSBbXTtcblx0dmFyIHV2cyA9IFtdO1xuXG5cdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHR2YXIgaSwgcztcblx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XG5cblx0Ly8gY2VudGVyIHBvaW50XG5cblx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblx0dXZzLnB1c2goIDAuNSwgMC41ICk7XG5cblx0Zm9yICggcyA9IDAsIGkgPSAzOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMgKSB7XG5cblx0XHR2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuXHRcdC8vIHZlcnRleFxuXG5cdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuXHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdC8vIG5vcm1hbFxuXG5cdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cblx0XHQvLyB1dnNcblxuXHRcdHV2LnggPSAoIHZlcnRpY2VzWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXHRcdHV2LnkgPSAoIHZlcnRpY2VzWyBpICsgMSBdIC8gcmFkaXVzICsgMSApIC8gMjtcblxuXHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0fVxuXG5cdC8vIGluZGljZXNcblxuXHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcblxuXHR9XG5cblx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG59XG5cbkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG5cblxuXG52YXIgR2VvbWV0cmllcyA9IE9iamVjdC5mcmVlemUoe1xuXHRXaXJlZnJhbWVHZW9tZXRyeTogV2lyZWZyYW1lR2VvbWV0cnksXG5cdFBhcmFtZXRyaWNHZW9tZXRyeTogUGFyYW1ldHJpY0dlb21ldHJ5LFxuXHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk6IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSxcblx0VGV0cmFoZWRyb25HZW9tZXRyeTogVGV0cmFoZWRyb25HZW9tZXRyeSxcblx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeTogVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSxcblx0T2N0YWhlZHJvbkdlb21ldHJ5OiBPY3RhaGVkcm9uR2VvbWV0cnksXG5cdE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeTogT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxuXHRJY29zYWhlZHJvbkdlb21ldHJ5OiBJY29zYWhlZHJvbkdlb21ldHJ5LFxuXHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxuXHREb2RlY2FoZWRyb25HZW9tZXRyeTogRG9kZWNhaGVkcm9uR2VvbWV0cnksXG5cdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSxcblx0UG9seWhlZHJvbkdlb21ldHJ5OiBQb2x5aGVkcm9uR2VvbWV0cnksXG5cdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeTogUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxuXHRUdWJlR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcblx0VHViZUJ1ZmZlckdlb21ldHJ5OiBUdWJlQnVmZmVyR2VvbWV0cnksXG5cdFRvcnVzS25vdEdlb21ldHJ5OiBUb3J1c0tub3RHZW9tZXRyeSxcblx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnk6IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LFxuXHRUb3J1c0dlb21ldHJ5OiBUb3J1c0dlb21ldHJ5LFxuXHRUb3J1c0J1ZmZlckdlb21ldHJ5OiBUb3J1c0J1ZmZlckdlb21ldHJ5LFxuXHRUZXh0R2VvbWV0cnk6IFRleHRHZW9tZXRyeSxcblx0U3BoZXJlR2VvbWV0cnk6IFNwaGVyZUdlb21ldHJ5LFxuXHRTcGhlcmVCdWZmZXJHZW9tZXRyeTogU3BoZXJlQnVmZmVyR2VvbWV0cnksXG5cdFJpbmdHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxuXHRSaW5nQnVmZmVyR2VvbWV0cnk6IFJpbmdCdWZmZXJHZW9tZXRyeSxcblx0UGxhbmVHZW9tZXRyeTogUGxhbmVHZW9tZXRyeSxcblx0UGxhbmVCdWZmZXJHZW9tZXRyeTogUGxhbmVCdWZmZXJHZW9tZXRyeSxcblx0TGF0aGVHZW9tZXRyeTogTGF0aGVHZW9tZXRyeSxcblx0TGF0aGVCdWZmZXJHZW9tZXRyeTogTGF0aGVCdWZmZXJHZW9tZXRyeSxcblx0U2hhcGVHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcblx0U2hhcGVCdWZmZXJHZW9tZXRyeTogU2hhcGVCdWZmZXJHZW9tZXRyeSxcblx0RXh0cnVkZUdlb21ldHJ5OiBFeHRydWRlR2VvbWV0cnksXG5cdEVkZ2VzR2VvbWV0cnk6IEVkZ2VzR2VvbWV0cnksXG5cdENvbmVHZW9tZXRyeTogQ29uZUdlb21ldHJ5LFxuXHRDb25lQnVmZmVyR2VvbWV0cnk6IENvbmVCdWZmZXJHZW9tZXRyeSxcblx0Q3lsaW5kZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcblx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeTogQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSxcblx0Q2lyY2xlR2VvbWV0cnk6IENpcmNsZUdlb21ldHJ5LFxuXHRDaXJjbGVCdWZmZXJHZW9tZXRyeTogQ2lyY2xlQnVmZmVyR2VvbWV0cnksXG5cdEJveEdlb21ldHJ5OiBCb3hHZW9tZXRyeSxcblx0Qm94QnVmZmVyR2VvbWV0cnk6IEJveEJ1ZmZlckdlb21ldHJ5XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFNoYWRvd01hdGVyaWFsKCkge1xuXG5cdFNoYWRlck1hdGVyaWFsLmNhbGwoIHRoaXMsIHtcblx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXHRcdFx0e1xuXHRcdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxuXHRcdFx0fVxuXHRcdF0gKSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rWyAnc2hhZG93X3ZlcnQnIF0sXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rWyAnc2hhZG93X2ZyYWcnIF1cblx0fSApO1xuXG5cdHRoaXMubGlnaHRzID0gdHJ1ZTtcblx0dGhpcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxufVxuXG5TaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcblNoYWRvd01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRvd01hdGVyaWFsO1xuXG5TaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBSYXdTaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRTaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxufVxuXG5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcblJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhd1NoYWRlck1hdGVyaWFsO1xuXG5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuaXNSYXdTaGFkZXJNYXRlcmlhbCA9IHRydWU7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBNdWx0aU1hdGVyaWFsKCBtYXRlcmlhbHMgKSB7XG5cblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy50eXBlID0gJ011bHRpTWF0ZXJpYWwnO1xuXG5cdHRoaXMubWF0ZXJpYWxzID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxzICkgPyBtYXRlcmlhbHMgOiBbXTtcblxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG59XG5cbk11bHRpTWF0ZXJpYWwucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBNdWx0aU1hdGVyaWFsLFxuXG5cdGlzTXVsdGlNYXRlcmlhbDogdHJ1ZSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjIsXG5cdFx0XHRcdHR5cGU6ICdtYXRlcmlhbCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsRXhwb3J0ZXInXG5cdFx0XHR9LFxuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0bWF0ZXJpYWxzOiBbXVxuXHRcdH07XG5cblx0XHR2YXIgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBpIF0udG9KU09OKCBtZXRhICk7XG5cdFx0XHRkZWxldGUgbWF0ZXJpYWwubWV0YWRhdGE7XG5cblx0XHRcdG91dHB1dC5tYXRlcmlhbHMucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRtYXRlcmlhbC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICByb3VnaG5lc3M6IDxmbG9hdD4sXG4gKiAgbWV0YWxuZXNzOiA8ZmxvYXQ+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuICpcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcbiAqXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG4gKlxuICogIHJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbWV0YWxuZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGVudk1hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuICogfVxuICovXG5cbmZ1bmN0aW9uIE1lc2hTdGFuZGFyZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XG5cblx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cdHRoaXMucm91Z2huZXNzID0gMC41O1xuXHR0aGlzLm1ldGFsbmVzcyA9IDAuNTtcblxuXHR0aGlzLm1hcCA9IG51bGw7XG5cblx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0dGhpcy5hb01hcCA9IG51bGw7XG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHR0aGlzLnJvdWdobmVzc01hcCA9IG51bGw7XG5cblx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xuXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdHRoaXMuZW52TWFwID0gbnVsbDtcblx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn1cblxuTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcblxuTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSB0cnVlO1xuXG5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcblxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XG5cdHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcblxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHR0aGlzLnJvdWdobmVzc01hcCA9IHNvdXJjZS5yb3VnaG5lc3NNYXA7XG5cblx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xuXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XG5cblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PlxuICogfVxuICovXG5cbmZ1bmN0aW9uIE1lc2hQaHlzaWNhbE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1lc2hTdGFuZGFyZE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmRlZmluZXMgPSB7ICdQSFlTSUNBTCc6ICcnIH07XG5cblx0dGhpcy50eXBlID0gJ01lc2hQaHlzaWNhbE1hdGVyaWFsJztcblxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDAuNTsgLy8gbWFwcyB0byBGMCA9IDAuMDRcblxuXHR0aGlzLmNsZWFyQ29hdCA9IDAuMDtcblx0dGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSAwLjA7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufVxuXG5NZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgKTtcbk1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuXG5NZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XG5cbk1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5kZWZpbmVzID0geyAnUEhZU0lDQUwnOiAnJyB9O1xuXG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblxuXHR0aGlzLmNsZWFyQ29hdCA9IHNvdXJjZS5jbGVhckNvYXQ7XG5cdHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzID0gc291cmNlLmNsZWFyQ29hdFJvdWdobmVzcztcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBzcGVjdWxhcjogPGhleD4sXG4gKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuICpcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcbiAqXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuICogfVxuICovXG5cbmZ1bmN0aW9uIE1lc2hQaG9uZ01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2Vcblx0dGhpcy5zcGVjdWxhciA9IG5ldyBDb2xvciggMHgxMTExMTEgKTtcblx0dGhpcy5zaGluaW5lc3MgPSAzMDtcblxuXHR0aGlzLm1hcCA9IG51bGw7XG5cblx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0dGhpcy5hb01hcCA9IG51bGw7XG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59XG5cbk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFBob25nTWF0ZXJpYWw7XG5cbk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hQaG9uZ01hdGVyaWFsID0gdHJ1ZTtcblxuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuXHR0aGlzLnNoaW5pbmVzcyA9IHNvdXJjZS5zaGluaW5lc3M7XG5cblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIHRha2FoaXJveCAvIGh0dHA6Ly9naXRodWIuY29tL3Rha2FoaXJveFxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgZ3JhZGllbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+IClcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBNZXNoVG9vbk1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1lc2hQaG9uZ01hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmRlZmluZXMgPSB7ICdUT09OJzogJycgfTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaFRvb25NYXRlcmlhbCc7XG5cblx0dGhpcy5ncmFkaWVudE1hcCA9IG51bGw7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufVxuXG5NZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSApO1xuTWVzaFRvb25NYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoVG9vbk1hdGVyaWFsO1xuXG5NZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xuXG5NZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5ncmFkaWVudE1hcCA9IHNvdXJjZS5ncmFkaWVudE1hcDtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcbiAqXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG4gKlxuICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcbiAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuICogfVxuICovXG5cbmZ1bmN0aW9uIE1lc2hOb3JtYWxNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XG5cblx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5mb2cgPSBmYWxzZTtcblx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufVxuXG5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xuXG5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcblxuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGVtaXNzaXZlOiA8aGV4PixcbiAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxuICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBNZXNoTGFtYmVydE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmFvTWFwID0gbnVsbDtcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59XG5cbk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG5cbk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaExhbWJlcnRNYXRlcmlhbCA9IHRydWU7XG5cbk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cblx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBzY2FsZTogPGZsb2F0PixcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcbiAqICBnYXBTaXplOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gTGluZURhc2hlZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHR0aGlzLnNjYWxlID0gMTtcblx0dGhpcy5kYXNoU2l6ZSA9IDM7XG5cdHRoaXMuZ2FwU2l6ZSA9IDE7XG5cblx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59XG5cbkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcbkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lRGFzaGVkTWF0ZXJpYWw7XG5cbkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgPSB0cnVlO1xuXG5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcblxuXHR0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xuXHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuXHR0aGlzLmdhcFNpemUgPSBzb3VyY2UuZ2FwU2l6ZTtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuXG5cbnZhciBNYXRlcmlhbHMgPSBPYmplY3QuZnJlZXplKHtcblx0U2hhZG93TWF0ZXJpYWw6IFNoYWRvd01hdGVyaWFsLFxuXHRTcHJpdGVNYXRlcmlhbDogU3ByaXRlTWF0ZXJpYWwsXG5cdFJhd1NoYWRlck1hdGVyaWFsOiBSYXdTaGFkZXJNYXRlcmlhbCxcblx0U2hhZGVyTWF0ZXJpYWw6IFNoYWRlck1hdGVyaWFsLFxuXHRQb2ludHNNYXRlcmlhbDogUG9pbnRzTWF0ZXJpYWwsXG5cdE11bHRpTWF0ZXJpYWw6IE11bHRpTWF0ZXJpYWwsXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiBNZXNoUGh5c2ljYWxNYXRlcmlhbCxcblx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6IE1lc2hTdGFuZGFyZE1hdGVyaWFsLFxuXHRNZXNoUGhvbmdNYXRlcmlhbDogTWVzaFBob25nTWF0ZXJpYWwsXG5cdE1lc2hUb29uTWF0ZXJpYWw6IE1lc2hUb29uTWF0ZXJpYWwsXG5cdE1lc2hOb3JtYWxNYXRlcmlhbDogTWVzaE5vcm1hbE1hdGVyaWFsLFxuXHRNZXNoTGFtYmVydE1hdGVyaWFsOiBNZXNoTGFtYmVydE1hdGVyaWFsLFxuXHRNZXNoRGVwdGhNYXRlcmlhbDogTWVzaERlcHRoTWF0ZXJpYWwsXG5cdE1lc2hCYXNpY01hdGVyaWFsOiBNZXNoQmFzaWNNYXRlcmlhbCxcblx0TGluZURhc2hlZE1hdGVyaWFsOiBMaW5lRGFzaGVkTWF0ZXJpYWwsXG5cdExpbmVCYXNpY01hdGVyaWFsOiBMaW5lQmFzaWNNYXRlcmlhbCxcblx0TWF0ZXJpYWw6IE1hdGVyaWFsXG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbnZhciBDYWNoZSA9IHtcblxuXHRlbmFibGVkOiBmYWxzZSxcblxuXHRmaWxlczoge30sXG5cblx0YWRkOiBmdW5jdGlvbiAoIGtleSwgZmlsZSApIHtcblxuXHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcblxuXHRcdHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcblxuXHR9LFxuXG5cdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcblxuXHRcdHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XG5cblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5maWxlcyA9IHt9O1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIExvYWRpbmdNYW5hZ2VyKCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgaXNMb2FkaW5nID0gZmFsc2UsIGl0ZW1zTG9hZGVkID0gMCwgaXRlbXNUb3RhbCA9IDA7XG5cblx0dGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xuXHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcblx0dGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcblx0dGhpcy5vbkVycm9yID0gb25FcnJvcjtcblxuXHR0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0aXRlbXNUb3RhbCArKztcblxuXHRcdGlmICggaXNMb2FkaW5nID09PSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpc0xvYWRpbmcgPSB0cnVlO1xuXG5cdH07XG5cblx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRpdGVtc0xvYWRlZCArKztcblxuXHRcdGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGl0ZW1zTG9hZGVkID09PSBpdGVtc1RvdGFsICkge1xuXG5cdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5vbkxvYWQoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzY29wZS5vbkVycm9yKCB1cmwgKTtcblxuXHRcdH1cblxuXHR9O1xuXG59XG5cbnZhciBEZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIEZpbGVMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggRmlsZUxvYWRlci5wcm90b3R5cGUsIHtcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHVybCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcblxuXHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9LCAwICk7XG5cblx0XHRcdHJldHVybiBjYWNoZWQ7XG5cblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgZGF0YTogVVJJXG5cdFx0dmFyIGRhdGFVcmlSZWdleCA9IC9eZGF0YTooLio/KSg7YmFzZTY0KT8sKC4qKSQvO1xuXHRcdHZhciBkYXRhVXJpUmVnZXhSZXN1bHQgPSB1cmwubWF0Y2goIGRhdGFVcmlSZWdleCApO1xuXG5cdFx0Ly8gU2FmYXJpIGNhbiBub3QgaGFuZGxlIERhdGEgVVJJcyB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0IHNvIHByb2Nlc3MgbWFudWFsbHlcblx0XHRpZiAoIGRhdGFVcmlSZWdleFJlc3VsdCApIHtcblxuXHRcdFx0dmFyIG1pbWVUeXBlID0gZGF0YVVyaVJlZ2V4UmVzdWx0WyAxIF07XG5cdFx0XHR2YXIgaXNCYXNlNjQgPSAhISBkYXRhVXJpUmVnZXhSZXN1bHRbIDIgXTtcblx0XHRcdHZhciBkYXRhID0gZGF0YVVyaVJlZ2V4UmVzdWx0WyAzIF07XG5cblx0XHRcdGRhdGEgPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KCBkYXRhICk7XG5cblx0XHRcdGlmICggaXNCYXNlNjQgKSBkYXRhID0gd2luZG93LmF0b2IoIGRhdGEgKTtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHR2YXIgcmVzcG9uc2U7XG5cdFx0XHRcdHZhciByZXNwb25zZVR5cGUgPSAoIHRoaXMucmVzcG9uc2VUeXBlIHx8ICcnICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRzd2l0Y2ggKCByZXNwb25zZVR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRcdFx0Y2FzZSAnYmxvYic6XG5cblx0XHRcdFx0XHQgXHRyZXNwb25zZSA9IG5ldyBBcnJheUJ1ZmZlciggZGF0YS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0dmFyIHZpZXcgPSBuZXcgVWludDhBcnJheSggcmVzcG9uc2UgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmlld1sgaSBdID0gZGF0YS5jaGFyQ29kZUF0KCBpICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCByZXNwb25zZVR5cGUgPT09ICdibG9iJyApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBCbG9iKCBbIHJlc3BvbnNlIF0sIHsgdHlwZTogbWltZVR5cGUgfSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZG9jdW1lbnQnOlxuXG5cdFx0XHRcdFx0XHR2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBtaW1lVHlwZSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2pzb24nOlxuXG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IEpTT04ucGFyc2UoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OiAvLyAndGV4dCcgb3Igb3RoZXJcblxuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBkYXRhO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2FpdCBmb3IgbmV4dCBicm93c2VyIHRpY2tcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHR9LCAwICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHQvLyBXYWl0IGZvciBuZXh0IGJyb3dzZXIgdGlja1xuXHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXJyb3IgKTtcblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0XHR9LCAwICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcblxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3BvbnNlID0gZXZlbnQudGFyZ2V0LnJlc3BvbnNlO1xuXG5cdFx0XHRcdENhY2hlLmFkZCggdXJsLCByZXNwb25zZSApO1xuXG5cdFx0XHRcdGlmICggdGhpcy5zdGF0dXMgPT09IDIwMCApIHtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnN0YXR1cyA9PT0gMCApIHtcblxuXHRcdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxuXHRcdFx0XHRcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicgKTtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIGZhbHNlICk7XG5cblx0XHRcdGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cblx0XHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH0sIGZhbHNlICk7XG5cblx0XHRcdGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG5cdFx0XHRpZiAoIHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG5cdFx0XHRpZiAoIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSApIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSggdGhpcy5taW1lVHlwZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5taW1lVHlwZSA6ICd0ZXh0L3BsYWluJyApO1xuXG5cdFx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcblxuXHRcdH1cblxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdHJldHVybiByZXF1ZXN0O1xuXG5cdH0sXG5cblx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRNaW1lVHlwZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubWltZVR5cGUgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxuICovXG5cbmZ1bmN0aW9uIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG5cdC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG5cdHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBDb21wcmVzc2VkVGV4dHVyZSgpO1xuXHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuXHRcdFx0XHRpbWFnZXNbIGkgXSA9IHtcblx0XHRcdFx0XHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG5cdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG5cdFx0XHRcdFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGxvYWRlZCArPSAxO1xuXG5cdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH1cblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XG5cblx0XHRcdHZhciBsb2FkZWQgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG5cdFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuXHRcdFx0XHRpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcblxuXHRcdFx0XHRcdHZhciBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fSxcblxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXG4gKlxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxuICovXG5cbmZ1bmN0aW9uIERhdGFUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG5cdC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG5cdHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggRGF0YVRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0dmFyIHRleERhdGEgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIgKTtcblxuXHRcdFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XG5cblx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmltYWdlICkge1xuXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YS53aWR0aDtcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWFnRmlsdGVyID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuXHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG5cdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5mb3JtYXQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcblxuXHRcdFx0fVxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xuXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIEltYWdlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59XG5cbk9iamVjdC5hc3NpZ24oIEltYWdlTG9hZGVyLnByb3RvdHlwZSwge1xuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xuXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0sIDAgKTtcblxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblxuXHRcdH1cblxuXHRcdHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnaW1nJyApO1xuXG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdENhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9LCBmYWxzZSApO1xuXG5cdFx0Lypcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIG9uUHJvZ3Jlc3MgKSBvblByb2dyZXNzKCBldmVudCApO1xuXG5cdFx0fSwgZmFsc2UgKTtcblx0XHQqL1xuXG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0fSwgZmFsc2UgKTtcblxuXHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0aW1hZ2Uuc3JjID0gdXJsO1xuXG5cdFx0cmV0dXJuIGltYWdlO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBDdWJlVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufVxuXG5PYmplY3QuYXNzaWduKCBDdWJlVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cblx0XHR2YXIgbG9hZGVkID0gMDtcblxuXHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBpICkge1xuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsc1sgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcblxuXHRcdFx0XHRsb2FkZWQgKys7XG5cblx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHRsb2FkVGV4dHVyZSggaSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fSxcblxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdC8vIEpQRUdzIGNhbid0IGhhdmUgYW4gYWxwaGEgY2hhbm5lbCwgc28gbWVtb3J5IGNhbiBiZSBzYXZlZCBieSBzdG9yaW5nIHRoZW0gYXMgUkdCLlxuXHRcdFx0dmFyIGlzSlBFRyA9IHVybC5zZWFyY2goIC9cXC4oanBnfGpwZWcpJC8gKSA+IDAgfHwgdXJsLnNlYXJjaCggL15kYXRhXFw6aW1hZ2VcXC9qcGVnLyApID09PSAwO1xuXG5cdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IGlzSlBFRyA/IFJHQkZvcm1hdCA6IFJHQkFGb3JtYXQ7XG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fSxcblxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0xpZ2h0JztcblxuXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuXHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gaW50ZW5zaXR5IDogMTtcblxuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSB1bmRlZmluZWQ7XG5cbn1cblxuTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogTGlnaHQsXG5cblx0aXNMaWdodDogdHJ1ZSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuXHRcdGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblx0XHRkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuXHRcdGlmICggdGhpcy5ncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xuXG5cdFx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG5cdFx0aWYgKCB0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XG5cdFx0aWYgKCB0aGlzLmRlY2F5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cdFx0aWYgKCB0aGlzLnBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5wZW51bWJyYSA9IHRoaXMucGVudW1icmE7XG5cblx0XHRpZiAoIHRoaXMuc2hhZG93ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuZnVuY3Rpb24gSGVtaXNwaGVyZUxpZ2h0KCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcblxuXHRMaWdodC5jYWxsKCB0aGlzLCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cblx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xuXG5cdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuRGVmYXVsdFVwICk7XG5cdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBDb2xvciggZ3JvdW5kQ29sb3IgKTtcblxufVxuXG5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogSGVtaXNwaGVyZUxpZ2h0LFxuXG5cdGlzSGVtaXNwaGVyZUxpZ2h0OiB0cnVlLFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBMaWdodFNoYWRvdyggY2FtZXJhICkge1xuXG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdHRoaXMuYmlhcyA9IDA7XG5cdHRoaXMucmFkaXVzID0gMTtcblxuXHR0aGlzLm1hcFNpemUgPSBuZXcgVmVjdG9yMiggNTEyLCA1MTIgKTtcblxuXHR0aGlzLm1hcCA9IG51bGw7XG5cdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBMaWdodFNoYWRvdy5wcm90b3R5cGUsIHtcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuY2FtZXJhID0gc291cmNlLmNhbWVyYS5jbG9uZSgpO1xuXG5cdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XG5cdFx0dGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xuXG5cdFx0dGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvYmplY3QgPSB7fTtcblxuXHRcdGlmICggdGhpcy5iaWFzICE9PSAwICkgb2JqZWN0LmJpYXMgPSB0aGlzLmJpYXM7XG5cdFx0aWYgKCB0aGlzLnJhZGl1cyAhPT0gMSApIG9iamVjdC5yYWRpdXMgPSB0aGlzLnJhZGl1cztcblx0XHRpZiAoIHRoaXMubWFwU2l6ZS54ICE9PSA1MTIgfHwgdGhpcy5tYXBTaXplLnkgIT09IDUxMiApIG9iamVjdC5tYXBTaXplID0gdGhpcy5tYXBTaXplLnRvQXJyYXkoKTtcblxuXHRcdG9iamVjdC5jYW1lcmEgPSB0aGlzLmNhbWVyYS50b0pTT04oIGZhbHNlICkub2JqZWN0O1xuXHRcdGRlbGV0ZSBvYmplY3QuY2FtZXJhLm1hdHJpeDtcblxuXHRcdHJldHVybiBvYmplY3Q7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBTcG90TGlnaHRTaGFkb3coKSB7XG5cblx0TGlnaHRTaGFkb3cuY2FsbCggdGhpcywgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA1MCwgMSwgMC41LCA1MDAgKSApO1xuXG59XG5cblNwb3RMaWdodFNoYWRvdy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodFNoYWRvdy5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBTcG90TGlnaHRTaGFkb3csXG5cblx0aXNTcG90TGlnaHRTaGFkb3c6IHRydWUsXG5cblx0dXBkYXRlOiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG5cdFx0dmFyIGZvdiA9IF9NYXRoLlJBRDJERUcgKiAyICogbGlnaHQuYW5nbGU7XG5cdFx0dmFyIGFzcGVjdCA9IHRoaXMubWFwU2l6ZS53aWR0aCAvIHRoaXMubWFwU2l6ZS5oZWlnaHQ7XG5cdFx0dmFyIGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IDUwMDtcblxuXHRcdHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcblxuXHRcdGlmICggZm92ICE9PSBjYW1lcmEuZm92IHx8IGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCB8fCBmYXIgIT09IGNhbWVyYS5mYXIgKSB7XG5cblx0XHRcdGNhbWVyYS5mb3YgPSBmb3Y7XG5cdFx0XHRjYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xuXHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcblx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR9XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBTcG90TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgcGVudW1icmEsIGRlY2F5ICkge1xuXG5cdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcblxuXHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xuXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncG93ZXInLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXG5cdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNykgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogTWF0aC5QSTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCBwb3dlciApIHtcblx0XHRcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cblx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE3KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXG5cdFx0XHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gTWF0aC5QSTtcblx0XHR9XG5cdH0gKTtcblxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cdHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XG5cdHRoaXMucGVudW1icmEgPSAoIHBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSA/IHBlbnVtYnJhIDogMDtcblx0dGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1x0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG5cdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xuXG59XG5cblNwb3RMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBTcG90TGlnaHQsXG5cblx0aXNTcG90TGlnaHQ6IHRydWUsXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0dGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcblx0XHR0aGlzLnBlbnVtYnJhID0gc291cmNlLnBlbnVtYnJhO1xuXHRcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cblx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblxuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5cbmZ1bmN0aW9uIFBvaW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcblxuXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Bvd2VyJywge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuXHRcdFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTUpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcblx0XHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIDQgKiBNYXRoLlBJO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggcG93ZXIgKSB7XG5cdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXG5cdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNSkgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxuXHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvICggNCAqIE1hdGguUEkgKTtcblx0XHR9XG5cdH0gKTtcblxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuXHR0aGlzLnNoYWRvdyA9IG5ldyBMaWdodFNoYWRvdyggbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA5MCwgMSwgMC41LCA1MDAgKSApO1xuXG59XG5cblBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogUG9pbnRMaWdodCxcblxuXHRpc1BvaW50TGlnaHQ6IHRydWUsXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCApIHtcblxuXHRMaWdodFNoYWRvdy5jYWxsKCB0aGlzLCBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDUsIDUsIDUsIC0gNSwgMC41LCA1MDAgKSApO1xuXG59XG5cbkRpcmVjdGlvbmFsTGlnaHRTaGFkb3cucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHRTaGFkb3cucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogRGlyZWN0aW9uYWxMaWdodFNoYWRvd1xuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcblxuXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG5cdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuRGVmYXVsdFVwICk7XG5cdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHR0aGlzLnNoYWRvdyA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCk7XG5cbn1cblxuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBEaXJlY3Rpb25hbExpZ2h0LFxuXG5cdGlzRGlyZWN0aW9uYWxMaWdodDogdHJ1ZSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQW1iaWVudExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxuXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XG5cbn1cblxuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IEFtYmllbnRMaWdodCxcblxuXHRpc0FtYmllbnRMaWdodDogdHJ1ZVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciB0c2Nod1xuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICovXG5cbnZhciBBbmltYXRpb25VdGlscyA9IHtcblxuXHQvLyBzYW1lIGFzIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IGFsc28gd29ya3Mgb24gdHlwZWQgYXJyYXlzXG5cdGFycmF5U2xpY2U6IGZ1bmN0aW9uKCBhcnJheSwgZnJvbSwgdG8gKSB7XG5cblx0XHRpZiAoIEFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSggYXJyYXkgKSApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBhcnJheS5jb25zdHJ1Y3RvciggYXJyYXkuc3ViYXJyYXkoIGZyb20sIHRvICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJheS5zbGljZSggZnJvbSwgdG8gKTtcblxuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxuXHRjb252ZXJ0QXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgdHlwZSwgZm9yY2VDbG9uZSApIHtcblxuXHRcdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXG5cdFx0XHRcdCEgZm9yY2VDbG9uZSAmJiBhcnJheS5jb25zdHJ1Y3RvciA9PT0gdHlwZSApIHJldHVybiBhcnJheTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHR5cGUoIGFycmF5ICk7IC8vIGNyZWF0ZSB0eXBlZCBhcnJheVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcnJheSApOyAvLyBjcmVhdGUgQXJyYXlcblxuXHR9LFxuXG5cdGlzVHlwZWRBcnJheTogZnVuY3Rpb24oIG9iamVjdCApIHtcblxuXHRcdHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoIG9iamVjdCApICYmXG5cdFx0XHRcdCEgKCBvYmplY3QgaW5zdGFuY2VvZiBEYXRhVmlldyApO1xuXG5cdH0sXG5cblx0Ly8gcmV0dXJucyBhbiBhcnJheSBieSB3aGljaCB0aW1lcyBhbmQgdmFsdWVzIGNhbiBiZSBzb3J0ZWRcblx0Z2V0S2V5ZnJhbWVPcmRlcjogZnVuY3Rpb24oIHRpbWVzICkge1xuXG5cdFx0ZnVuY3Rpb24gY29tcGFyZVRpbWUoIGksIGogKSB7XG5cblx0XHRcdHJldHVybiB0aW1lc1sgaSBdIC0gdGltZXNbIGogXTtcblxuXHRcdH1cblxuXHRcdHZhciBuID0gdGltZXMubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBuZXcgQXJyYXkoIG4gKTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSByZXN1bHRbIGkgXSA9IGk7XG5cblx0XHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fSxcblxuXHQvLyB1c2VzIHRoZSBhcnJheSBwcmV2aW91c2x5IHJldHVybmVkIGJ5ICdnZXRLZXlmcmFtZU9yZGVyJyB0byBzb3J0IGRhdGFcblx0c29ydGVkQXJyYXk6IGZ1bmN0aW9uKCB2YWx1ZXMsIHN0cmlkZSwgb3JkZXIgKSB7XG5cblx0XHR2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyB2YWx1ZXMuY29uc3RydWN0b3IoIG5WYWx1ZXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgZHN0T2Zmc2V0ID0gMDsgZHN0T2Zmc2V0ICE9PSBuVmFsdWVzOyArKyBpICkge1xuXG5cdFx0XHR2YXIgc3JjT2Zmc2V0ID0gb3JkZXJbIGkgXSAqIHN0cmlkZTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cblx0XHRcdFx0cmVzdWx0WyBkc3RPZmZzZXQgKysgXSA9IHZhbHVlc1sgc3JjT2Zmc2V0ICsgaiBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH0sXG5cblx0Ly8gZnVuY3Rpb24gZm9yIHBhcnNpbmcgQU9TIGtleWZyYW1lIGZvcm1hdHNcblx0ZmxhdHRlbkpTT046IGZ1bmN0aW9uKCBqc29uS2V5cywgdGltZXMsIHZhbHVlcywgdmFsdWVQcm9wZXJ0eU5hbWUgKSB7XG5cblx0XHR2YXIgaSA9IDEsIGtleSA9IGpzb25LZXlzWyAwIF07XG5cblx0XHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdFx0dmFyIHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0XHRkbyB7XG5cblx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaC5hcHBseSggdmFsdWVzLCB2YWx1ZSApOyAvLyBwdXNoIGFsbCBlbGVtZW50c1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIC4uLmFzc3VtZSBUSFJFRS5NYXRoLWlzaFxuXG5cdFx0XHRkbyB7XG5cblx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcblx0XHRcdFx0XHR2YWx1ZS50b0FycmF5KCB2YWx1ZXMsIHZhbHVlcy5sZW5ndGggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gb3RoZXJ3aXNlIHB1c2ggYXMtaXNcblxuXHRcdFx0ZG8ge1xuXG5cdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIG9mIGludGVycG9sYW50cyBvdmVyIHBhcmFtZXRyaWMgc2FtcGxlcy5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIGRvbWFpbiBpcyBvbmUgZGltZW5zaW9uYWwsIHR5cGljYWxseSB0aGUgdGltZSBvciBhIHBhdGhcbiAqIGFsb25nIGEgY3VydmUgZGVmaW5lZCBieSB0aGUgZGF0YS5cbiAqXG4gKiBUaGUgc2FtcGxlIHZhbHVlcyBjYW4gaGF2ZSBhbnkgZGltZW5zaW9uYWxpdHkgYW5kIGRlcml2ZWQgY2xhc3NlcyBtYXlcbiAqIGFwcGx5IHNwZWNpYWwgaW50ZXJwcmV0YXRpb25zIHRvIHRoZSBkYXRhLlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgdGhlIGludGVydmFsIHNlZWsgaW4gYSBUZW1wbGF0ZSBNZXRob2QsIGRlZmVycmluZ1xuICogdGhlIGFjdHVhbCBpbnRlcnBvbGF0aW9uIHRvIGRlcml2ZWQgY2xhc3Nlcy5cbiAqXG4gKiBUaW1lIGNvbXBsZXhpdHkgaXMgTygxKSBmb3IgbGluZWFyIGFjY2VzcyBjcm9zc2luZyBhdCBtb3N0IHR3byBwb2ludHNcbiAqIGFuZCBPKGxvZyBOKSBmb3IgcmFuZG9tIGFjY2Vzcywgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICpcbiAqIFx0XHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXG4gKlxuICogQGF1dGhvciB0c2Nod1xuICovXG5cbmZ1bmN0aW9uIEludGVycG9sYW50KFxuXHRcdHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XG5cdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblxuXHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHJlc3VsdEJ1ZmZlciA6IG5ldyBzYW1wbGVWYWx1ZXMuY29uc3RydWN0b3IoIHNhbXBsZVNpemUgKTtcblx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XG5cdHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcblxufVxuXG5JbnRlcnBvbGFudC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IEludGVycG9sYW50LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbiggdCApIHtcblxuXHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxuXHRcdFx0aTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcblxuXHRcdFx0dDEgPSBwcFsgICBpMSAgIF0sXG5cdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XG5cblx0XHRcdHNlZWs6IHtcblxuXHRcdFx0XHR2YXIgcmlnaHQ7XG5cblx0XHRcdFx0bGluZWFyX3NjYW46IHtcbi8vLSBTZWUgaHR0cDovL2pzcGVyZi5jb20vY29tcGFyaXNvbi10by11bmRlZmluZWQvM1xuLy8tIHNsb3dlciBjb2RlOlxuLy8tXG4vLy0gXHRcdFx0XHRpZiAoIHQgPj0gdDEgfHwgdDEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRmb3J3YXJkX3NjYW46IGlmICggISAoIHQgPCB0MSApICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSArIDI7IDspIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MCApIGJyZWFrIGZvcndhcmRfc2NhbjtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGFmdGVyIGVuZFxuXG5cdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZnRlckVuZF8oIGkxIC0gMSwgdCwgdDAgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXG5cblx0XHRcdFx0XHRcdFx0dDAgPSB0MTtcblx0XHRcdFx0XHRcdFx0dDEgPSBwcFsgKysgaTEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBpbmRleFxuXHRcdFx0XHRcdFx0cmlnaHQgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2NhbjtcblxuXHRcdFx0XHRcdH1cblxuLy8tIHNsb3dlciBjb2RlOlxuLy8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhICggdCA+PSB0MCApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBsb29waW5nP1xuXG5cdFx0XHRcdFx0XHR2YXIgdDFnbG9iYWwgPSBwcFsgMSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHQgPCB0MWdsb2JhbCApIHtcblxuXHRcdFx0XHRcdFx0XHRpMSA9IDI7IC8vICsgMSwgdXNpbmcgdGhlIHNjYW4gZm9yIHRoZSBkZXRhaWxzXG5cdFx0XHRcdFx0XHRcdHQwID0gdDFnbG9iYWw7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gbGluZWFyIHJldmVyc2Ugc2NhblxuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSAtIDI7IDspIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcblxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oIDAsIHQsIHQxICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG5cdFx0XHRcdFx0XHRcdHQxID0gdDA7XG5cdFx0XHRcdFx0XHRcdHQwID0gcHBbIC0tIGkxIC0gMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdCA+PSB0MCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XG5cdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xuXHRcdFx0XHRcdFx0aTEgPSAwO1xuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcblxuXHRcdFx0XHRcdGJyZWFrIHZhbGlkYXRlX2ludGVydmFsO1xuXG5cdFx0XHRcdH0gLy8gbGluZWFyIHNjYW5cblxuXHRcdFx0XHQvLyBiaW5hcnkgc2VhcmNoXG5cblx0XHRcdFx0d2hpbGUgKCBpMSA8IHJpZ2h0ICkge1xuXG5cdFx0XHRcdFx0dmFyIG1pZCA9ICggaTEgKyByaWdodCApID4+PiAxO1xuXG5cdFx0XHRcdFx0aWYgKCB0IDwgcHBbIG1pZCBdICkge1xuXG5cdFx0XHRcdFx0XHRyaWdodCA9IG1pZDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGkxID0gbWlkICsgMTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dDEgPSBwcFsgICBpMSAgIF07XG5cdFx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxuXG5cdFx0XHRcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oIDAsIHQsIHQxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQwLCB0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IC8vIHNlZWtcblxuXHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblxuXHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XG5cblx0XHR9IC8vIHZhbGlkYXRlX2ludGVydmFsXG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKTtcblxuXHR9LFxuXG5cdHNldHRpbmdzOiBudWxsLCAvLyBvcHRpb25hbCwgc3ViY2xhc3Mtc3BlY2lmaWMgc2V0dGluZ3Mgc3RydWN0dXJlXG5cdC8vIE5vdGU6IFRoZSBpbmRpcmVjdGlvbiBhbGxvd3MgY2VudHJhbCBjb250cm9sIG9mIG1hbnkgaW50ZXJwb2xhbnRzLlxuXG5cdC8vIC0tLSBQcm90ZWN0ZWQgaW50ZXJmYWNlXG5cblx0RGVmYXVsdFNldHRpbmdzXzoge30sXG5cblx0Z2V0U2V0dGluZ3NfOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldHRpbmdzIHx8IHRoaXMuRGVmYXVsdFNldHRpbmdzXztcblxuXHR9LFxuXG5cdGNvcHlTYW1wbGVWYWx1ZV86IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuXHRcdC8vIGNvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlclxuXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IGluZGV4ICogc3RyaWRlO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWVzWyBvZmZzZXQgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH0sXG5cblx0Ly8gVGVtcGxhdGUgbWV0aG9kcyBmb3IgZGVyaXZlZCBjbGFzc2VzOlxuXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2FsbCB0byBhYnN0cmFjdCBtZXRob2RcIiApO1xuXHRcdC8vIGltcGxlbWVudGF0aW9ucyBzaGFsbCByZXR1cm4gdGhpcy5yZXN1bHRCdWZmZXJcblxuXHR9LFxuXG5cdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uKCBpMSwgdDAsIHQxICkge1xuXG5cdFx0Ly8gZW1wdHlcblxuXHR9XG5cbn07XG5cbk9iamVjdC5hc3NpZ24oIEludGVycG9sYW50LnByb3RvdHlwZSwge1xuXG5cdGJlZm9yZVN0YXJ0XzogLy8oIDAsIHQsIHQwICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcblx0XHRJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxcblxuXHRhZnRlckVuZF86IC8vKCBOLTEsIHROLTEsIHQgKSwgcmV0dXJucyB0aGlzLnJlc3VsdEJ1ZmZlclxuXHRcdEludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfXG5cbn0gKTtcblxuLyoqXG4gKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxuICpcbiAqIEl0IHdhcyBkZXJpdmVkIGZyb20gYSBIZXJtaXRpYW4gY29uc3RydWN0aW9uIHNldHRpbmcgdGhlIGZpcnN0IGRlcml2YXRpdmVcbiAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcbiAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxuICpcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBDdWJpY0ludGVycG9sYW50KFxuXHRcdHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0SW50ZXJwb2xhbnQuY2FsbChcblx0XHRcdHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR0aGlzLl93ZWlnaHRQcmV2ID0gLTA7XG5cdHRoaXMuX29mZnNldFByZXYgPSAtMDtcblx0dGhpcy5fd2VpZ2h0TmV4dCA9IC0wO1xuXHR0aGlzLl9vZmZzZXROZXh0ID0gLTA7XG5cbn1cblxuQ3ViaWNJbnRlcnBvbGFudC5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IEN1YmljSW50ZXJwb2xhbnQsXG5cblx0RGVmYXVsdFNldHRpbmdzXzoge1xuXG5cdFx0ZW5kaW5nU3RhcnQ6IFx0WmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRlbmRpbmdFbmQ6XHRcdFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuXHR9LFxuXG5cdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uKCBpMSwgdDAsIHQxICkge1xuXG5cdFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHRpUHJldiA9IGkxIC0gMixcblx0XHRcdGlOZXh0ID0gaTEgKyAxLFxuXG5cdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxuXHRcdFx0dE5leHQgPSBwcFsgaU5leHQgXTtcblxuXHRcdGlmICggdFByZXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCApIHtcblxuXHRcdFx0XHRjYXNlIFplcm9TbG9wZUVuZGluZzpcblxuXHRcdFx0XHRcdC8vIGYnKHQwKSA9IDBcblx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdHRQcmV2ID0gMiAqIHQwIC0gdDE7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG5cblx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcblx0XHRcdFx0XHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XG5cdFx0XHRcdFx0dFByZXYgPSB0MCArIHBwWyBpUHJldiBdIC0gcHBbIGlQcmV2ICsgMSBdO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG5cdFx0XHRcdFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0aVByZXYgPSBpMTtcblx0XHRcdFx0XHR0UHJldiA9IHQxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHROZXh0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kICkge1xuXG5cdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxuXG5cdFx0XHRcdFx0Ly8gZicodE4pID0gMFxuXHRcdFx0XHRcdGlOZXh0ID0gaTE7XG5cdFx0XHRcdFx0dE5leHQgPSAyICogdDEgLSB0MDtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcblxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdGlOZXh0ID0gMTtcblx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbIDEgXSAtIHBwWyAwIF07XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cblx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0aU5leHQgPSBpMSAtIDE7XG5cdFx0XHRcdFx0dE5leHQgPSB0MDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGhhbGZEdCA9ICggdDEgLSB0MCApICogMC41LFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG5cblx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gaGFsZkR0IC8gKCB0MCAtIHRQcmV2ICk7XG5cdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IGhhbGZEdCAvICggdE5leHQgLSB0MSApO1xuXHRcdHRoaXMuX29mZnNldFByZXYgPSBpUHJldiAqIHN0cmlkZTtcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XG5cblx0fSxcblxuXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblxuXHRcdFx0bzEgPSBpMSAqIHN0cmlkZSxcdFx0bzAgPSBvMSAtIHN0cmlkZSxcblx0XHRcdG9QID0gdGhpcy5fb2Zmc2V0UHJldiwgXHRvTiA9IHRoaXMuX29mZnNldE5leHQsXG5cdFx0XHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXG5cblx0XHRcdHAgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXG5cdFx0XHRwcCA9IHAgKiBwLFxuXHRcdFx0cHBwID0gcHAgKiBwO1xuXG5cdFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcblxuXHRcdHZhciBzUCA9ICAgICAtIHdQICAgKiBwcHAgICArICAgICAgICAgMiAqIHdQICAgICogcHAgICAgLSAgICAgICAgICB3UCAgICogcDtcblx0XHR2YXIgczAgPSAoIDEgKyB3UCApICogcHBwICAgKyAoLTEuNSAtIDIgKiB3UCApICAqIHBwICAgICsgKCAtMC41ICsgd1AgKSAqIHAgICAgICsgMTtcblx0XHR2YXIgczEgPSAoLTEgLSB3TiApICogcHBwICAgKyAoIDEuNSArICAgd04gICApICAqIHBwICAgICsgICAgMC41ICAgICAgICAqIHA7XG5cdFx0dmFyIHNOID0gICAgICAgd04gICAqIHBwcCAgIC0gICAgICAgICAgIHdOICAgICAgKiBwcDtcblxuXHRcdC8vIGNvbWJpbmUgZGF0YSBsaW5lYXJseVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID1cblx0XHRcdFx0XHRzUCAqIHZhbHVlc1sgb1AgKyBpIF0gK1xuXHRcdFx0XHRcdHMwICogdmFsdWVzWyBvMCArIGkgXSArXG5cdFx0XHRcdFx0czEgKiB2YWx1ZXNbIG8xICsgaSBdICtcblx0XHRcdFx0XHRzTiAqIHZhbHVlc1sgb04gKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBMaW5lYXJJbnRlcnBvbGFudChcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdEludGVycG9sYW50LmNhbGwoXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbn1cblxuTGluZWFySW50ZXJwb2xhbnQucHJvdG90eXBlID1cblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBMaW5lYXJJbnRlcnBvbGFudCxcblxuXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblxuXHRcdFx0b2Zmc2V0MSA9IGkxICogc3RyaWRlLFxuXHRcdFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXG5cblx0XHRcdHdlaWdodDEgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXG5cdFx0XHR3ZWlnaHQwID0gMSAtIHdlaWdodDE7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0cmVzdWx0WyBpIF0gPVxuXHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MCArIGkgXSAqIHdlaWdodDAgK1xuXHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHdlaWdodDE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqXG4gKiBJbnRlcnBvbGFudCB0aGF0IGV2YWx1YXRlcyB0byB0aGUgc2FtcGxlIHZhbHVlIGF0IHRoZSBwb3NpdGlvbiBwcmVjZWVkaW5nXG4gKiB0aGUgcGFyYW1ldGVyLlxuICpcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBEaXNjcmV0ZUludGVycG9sYW50KFxuXHRcdHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0SW50ZXJwb2xhbnQuY2FsbChcblx0XHRcdHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxufVxuXG5EaXNjcmV0ZUludGVycG9sYW50LnByb3RvdHlwZSA9XG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogRGlzY3JldGVJbnRlcnBvbGFudCxcblxuXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cblx0fVxuXG59ICk7XG5cbnZhciBLZXlmcmFtZVRyYWNrUHJvdG90eXBlO1xuXG5LZXlmcmFtZVRyYWNrUHJvdG90eXBlID0ge1xuXG5cdFRpbWVCdWZmZXJUeXBlOiBGbG9hdDMyQXJyYXksXG5cdFZhbHVlQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxuXG5cdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZUxpbmVhcixcblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTogZnVuY3Rpb24gKCByZXN1bHQgKSB7XG5cblx0XHRyZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQoXG5cdFx0XHRcdHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcblxuXHR9LFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24gKCByZXN1bHQgKSB7XG5cblx0XHRyZXR1cm4gbmV3IExpbmVhckludGVycG9sYW50KFxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cblx0fSxcblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IGZ1bmN0aW9uICggcmVzdWx0ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBDdWJpY0ludGVycG9sYW50KFxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cblx0fSxcblxuXHRzZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoIGludGVycG9sYXRpb24gKSB7XG5cblx0XHR2YXIgZmFjdG9yeU1ldGhvZDtcblxuXHRcdHN3aXRjaCAoIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdGNhc2UgSW50ZXJwb2xhdGVEaXNjcmV0ZTpcblxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZUxpbmVhcjpcblxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgSW50ZXJwb2xhdGVTbW9vdGg6XG5cblx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBmYWN0b3J5TWV0aG9kID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBtZXNzYWdlID0gXCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcIiArXG5cdFx0XHRcdFx0dGhpcy5WYWx1ZVR5cGVOYW1lICsgXCIga2V5ZnJhbWUgdHJhY2sgbmFtZWQgXCIgKyB0aGlzLm5hbWU7XG5cblx0XHRcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGZhbGwgYmFjayB0byBkZWZhdWx0LCB1bmxlc3MgdGhlIGRlZmF1bHQgaXRzZWxmIGlzIG1lc3NlZCB1cFxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0XHR0aGlzLnNldEludGVycG9sYXRpb24oIHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLmNyZWF0ZUludGVycG9sYW50ID0gZmFjdG9yeU1ldGhvZDtcblxuXHR9LFxuXG5cdGdldEludGVycG9sYXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XG5cblx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTpcblxuXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcblxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcblxuXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVMaW5lYXI7XG5cblx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6XG5cblx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlU21vb3RoO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0VmFsdWVTaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGg7XG5cblx0fSxcblxuXHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXG5cdHNoaWZ0OiBmdW5jdGlvbiAoIHRpbWVPZmZzZXQgKSB7XG5cblx0XHRpZiAoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcblxuXHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdHRpbWVzWyBpIF0gKz0gdGltZU9mZnNldDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXG5cdHNjYWxlOiBmdW5jdGlvbiAoIHRpbWVTY2FsZSApIHtcblxuXHRcdGlmICggdGltZVNjYWxlICE9PSAxLjAgKSB7XG5cblx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cblx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xuXHR0cmltOiBmdW5jdGlvbiAoIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcblxuXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXG5cdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aCxcblx0XHRcdGZyb20gPSAwLFxuXHRcdFx0dG8gPSBuS2V5cyAtIDE7XG5cblx0XHR3aGlsZSAoIGZyb20gIT09IG5LZXlzICYmIHRpbWVzWyBmcm9tIF0gPCBzdGFydFRpbWUgKSArKyBmcm9tO1xuXHRcdHdoaWxlICggdG8gIT09IC0gMSAmJiB0aW1lc1sgdG8gXSA+IGVuZFRpbWUgKSAtLSB0bztcblxuXHRcdCsrIHRvOyAvLyBpbmNsdXNpdmUgLT4gZXhjbHVzaXZlIGJvdW5kXG5cblx0XHRpZiAoIGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzICkge1xuXG5cdFx0XHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcblx0XHRcdGlmICggZnJvbSA+PSB0byApIHRvID0gTWF0aC5tYXgoIHRvLCAxICksIGZyb20gPSB0byAtIDE7XG5cblx0XHRcdHZhciBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xuXHRcdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCBmcm9tLCB0byApO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5cblx0XHRcdFx0XHRhcnJheVNsaWNlKCB0aGlzLnZhbHVlcywgZnJvbSAqIHN0cmlkZSwgdG8gKiBzdHJpZGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Ly8gZW5zdXJlIHdlIGRvIG5vdCBnZXQgYSBHYXJiYWdlSW5HYXJiYWdlT3V0IHNpdHVhdGlvbiwgbWFrZSBzdXJlIHRyYWNrcyBhcmUgYXQgbGVhc3QgbWluaW1hbGx5IHZpYWJsZVxuXHR2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZhbGlkID0gdHJ1ZTtcblxuXHRcdHZhciB2YWx1ZVNpemUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xuXHRcdGlmICggdmFsdWVTaXplIC0gTWF0aC5mbG9vciggdmFsdWVTaXplICkgIT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiaW52YWxpZCB2YWx1ZSBzaXplIGluIHRyYWNrXCIsIHRoaXMgKTtcblx0XHRcdHZhbGlkID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxuXHRcdFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXG5cblx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXG5cdFx0aWYgKCBuS2V5cyA9PT0gMCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJ0cmFjayBpcyBlbXB0eVwiLCB0aGlzICk7XG5cdFx0XHR2YWxpZCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHByZXZUaW1lID0gbnVsbDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbktleXM7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjdXJyVGltZSA9IHRpbWVzWyBpIF07XG5cblx0XHRcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcInRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIGN1cnJUaW1lICk7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIm91dCBvZiBvcmRlciBrZXlzXCIsIHRoaXMsIGksIGN1cnJUaW1lLCBwcmV2VGltZSApO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRwcmV2VGltZSA9IGN1cnJUaW1lO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBBbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIHZhbHVlcyApICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwidmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIHZhbHVlICk7XG5cdFx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsaWQ7XG5cblx0fSxcblxuXHQvLyByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzIGFzIGNvbW1vbiBpbiBtb3JwaCB0YXJnZXQgc2VxdWVuY2VzXG5cdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXG5cdG9wdGltaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxuXHRcdFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxuXG5cdFx0XHRzbW9vdGhJbnRlcnBvbGF0aW9uID0gdGhpcy5nZXRJbnRlcnBvbGF0aW9uKCkgPT09IEludGVycG9sYXRlU21vb3RoLFxuXG5cdFx0XHR3cml0ZUluZGV4ID0gMSxcblx0XHRcdGxhc3RJbmRleCA9IHRpbWVzLmxlbmd0aCAtIDE7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPCBsYXN0SW5kZXg7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBrZWVwID0gZmFsc2U7XG5cblx0XHRcdHZhciB0aW1lID0gdGltZXNbIGkgXTtcblx0XHRcdHZhciB0aW1lTmV4dCA9IHRpbWVzWyBpICsgMSBdO1xuXG5cdFx0XHQvLyByZW1vdmUgYWRqYWNlbnQga2V5ZnJhbWVzIHNjaGVkdWxlZCBhdCB0aGUgc2FtZSB0aW1lXG5cblx0XHRcdGlmICggdGltZSAhPT0gdGltZU5leHQgJiYgKCBpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVbIDAgXSApICkge1xuXG5cdFx0XHRcdGlmICggISBzbW9vdGhJbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGtleWZyYW1lcyBzYW1lIGFzIHRoZWlyIG5laWdoYm9yc1xuXG5cdFx0XHRcdFx0dmFyIG9mZnNldCA9IGkgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxuXHRcdFx0XHRcdFx0b2Zmc2V0TiA9IG9mZnNldCArIHN0cmlkZTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNbIG9mZnNldCArIGogXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXRQICsgaiBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcblxuXHRcdFx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uga2VlcCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW4tcGxhY2UgY29tcGFjdGlvblxuXG5cdFx0XHRpZiAoIGtlZXAgKSB7XG5cblx0XHRcdFx0aWYgKCBpICE9PSB3cml0ZUluZGV4ICkge1xuXG5cdFx0XHRcdFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBpIF07XG5cblx0XHRcdFx0XHR2YXIgcmVhZE9mZnNldCA9IGkgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHR3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGU7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApXG5cblx0XHRcdFx0XHRcdHZhbHVlc1sgd3JpdGVPZmZzZXQgKyBqIF0gPSB2YWx1ZXNbIHJlYWRPZmZzZXQgKyBqIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGZsdXNoIGxhc3Qga2V5ZnJhbWUgKGNvbXBhY3Rpb24gbG9va3MgYWhlYWQpXG5cblx0XHRpZiAoIGxhc3RJbmRleCA+IDAgKSB7XG5cblx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgbGFzdEluZGV4IF07XG5cblx0XHRcdGZvciAoIHZhciByZWFkT2Zmc2V0ID0gbGFzdEluZGV4ICogc3RyaWRlLCB3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGUsIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKVxuXG5cdFx0XHRcdHZhbHVlc1sgd3JpdGVPZmZzZXQgKyBqIF0gPSB2YWx1ZXNbIHJlYWRPZmZzZXQgKyBqIF07XG5cblx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cblx0XHR9XG5cblx0XHRpZiAoIHdyaXRlSW5kZXggIT09IHRpbWVzLmxlbmd0aCApIHtcblxuXHRcdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCAwLCB3cml0ZUluZGV4ICk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHZhbHVlcywgMCwgd3JpdGVJbmRleCAqIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59O1xuXG5mdW5jdGlvbiBLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0aWYoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayBuYW1lIGlzIHVuZGVmaW5lZFwiICk7XG5cblx0aWYoIHRpbWVzID09PSB1bmRlZmluZWQgfHwgdGltZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIm5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCBcIiArIG5hbWUgKTtcblxuXHR9XG5cblx0dGhpcy5uYW1lID0gbmFtZTtcblxuXHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSApO1xuXHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdmFsdWVzLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSApO1xuXG5cdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiB8fCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XG5cblx0dGhpcy52YWxpZGF0ZSgpO1xuXHR0aGlzLm9wdGltaXplKCk7XG5cbn1cblxuLyoqXG4gKlxuICogQSBUcmFjayBvZiB2ZWN0b3JlZCBrZXlmcmFtZSB2YWx1ZXMuXG4gKlxuICpcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBWZWN0b3JLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdEtleWZyYW1lVHJhY2tDb25zdHJ1Y3Rvci5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XG5cbn1cblxuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2tQcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBWZWN0b3JLZXlmcmFtZVRyYWNrLFxuXG5cdFZhbHVlVHlwZU5hbWU6ICd2ZWN0b3InXG5cblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuXG5cdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxuXG59ICk7XG5cbi8qKlxuICogU3BoZXJpY2FsIGxpbmVhciB1bml0IHF1YXRlcm5pb24gaW50ZXJwb2xhbnQuXG4gKlxuICogQGF1dGhvciB0c2Nod1xuICovXG5cbmZ1bmN0aW9uIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudChcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdEludGVycG9sYW50LmNhbGwoXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbn1cblxuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9XG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LFxuXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRvZmZzZXQgPSBpMSAqIHN0cmlkZSxcblxuXHRcdFx0YWxwaGEgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICk7XG5cblx0XHRmb3IgKCB2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQgKSB7XG5cblx0XHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KCByZXN1bHQsIDAsXG5cdFx0XHRcdFx0dmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKlxuICogQSBUcmFjayBvZiBxdWF0ZXJuaW9uIGtleWZyYW1lIHZhbHVlcy5cbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuZnVuY3Rpb24gUXVhdGVybmlvbktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxufVxuXG5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2tQcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayxcblxuXHRWYWx1ZVR5cGVOYW1lOiAncXVhdGVybmlvbicsXG5cblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuXG5cdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZUxpbmVhcixcblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudChcblx0XHRcdFx0dGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH0sXG5cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWQgLy8gbm90IHlldCBpbXBsZW1lbnRlZFxuXG59ICk7XG5cbi8qKlxuICpcbiAqIEEgVHJhY2sgb2YgbnVtZXJpYyBrZXlmcmFtZSB2YWx1ZXMuXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICogQGF1dGhvciB0c2Nod1xuICovXG5cbmZ1bmN0aW9uIE51bWJlcktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxufVxuXG5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9XG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFja1Byb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IE51bWJlcktleWZyYW1lVHJhY2ssXG5cblx0VmFsdWVUeXBlTmFtZTogJ251bWJlcidcblxuXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXG5cbn0gKTtcblxuLyoqXG4gKlxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXG4gKlxuICpcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBTdHJpbmdLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdEtleWZyYW1lVHJhY2tDb25zdHJ1Y3Rvci5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XG5cbn1cblxuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2tQcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBTdHJpbmdLZXlmcmFtZVRyYWNrLFxuXG5cdFZhbHVlVHlwZU5hbWU6ICdzdHJpbmcnLFxuXHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxuXG5cdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkXG5cbn0gKTtcblxuLyoqXG4gKlxuICogQSBUcmFjayBvZiBCb29sZWFuIGtleWZyYW1lIHZhbHVlcy5cbiAqXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICogQGF1dGhvciB0c2Nod1xuICovXG5cbmZ1bmN0aW9uIEJvb2xlYW5LZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzICkge1xuXG5cdEtleWZyYW1lVHJhY2tDb25zdHJ1Y3Rvci5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzICk7XG5cbn1cblxuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlID1cblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrUHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogQm9vbGVhbktleWZyYW1lVHJhY2ssXG5cblx0VmFsdWVUeXBlTmFtZTogJ2Jvb2wnLFxuXHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxuXG5cdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxuXG5cdC8vIE5vdGU6IEFjdHVhbGx5IHRoaXMgdHJhY2sgY291bGQgaGF2ZSBhIG9wdGltaXplZCAvIGNvbXByZXNzZWRcblx0Ly8gcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgdmFsdWUgYW5kIGEgY3VzdG9tIGludGVycG9sYW50IHRoYXRcblx0Ly8gY29tcHV0ZXMgXCJmaXJzdFZhbHVlIF4gaXNPZGQoIGluZGV4IClcIi5cblxufSApO1xuXG4vKipcbiAqXG4gKiBBIFRyYWNrIG9mIGtleWZyYW1lIHZhbHVlcyB0aGF0IHJlcHJlc2VudCBjb2xvci5cbiAqXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICogQGF1dGhvciB0c2Nod1xuICovXG5cbmZ1bmN0aW9uIENvbG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IuY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG59XG5cbkNvbG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2tQcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBDb2xvcktleWZyYW1lVHJhY2ssXG5cblx0VmFsdWVUeXBlTmFtZTogJ2NvbG9yJ1xuXG5cdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcblxuXG5cdC8vIE5vdGU6IFZlcnkgYmFzaWMgaW1wbGVtZW50YXRpb24gYW5kIG5vdGhpbmcgc3BlY2lhbCB5ZXQuXG5cdC8vIEhvd2V2ZXIsIHRoaXMgaXMgdGhlIHBsYWNlIGZvciBjb2xvciBzcGFjZSBwYXJhbWV0ZXJpemF0aW9uLlxuXG59ICk7XG5cbi8qKlxuICpcbiAqIEEgdGltZWQgc2VxdWVuY2Ugb2Yga2V5ZnJhbWVzIGZvciBhIHNwZWNpZmljIHByb3BlcnR5LlxuICpcbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuZnVuY3Rpb24gS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG59XG5cbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gS2V5ZnJhbWVUcmFja1Byb3RvdHlwZTtcbktleWZyYW1lVHJhY2tQcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlmcmFtZVRyYWNrO1xuXG4vLyBTdGF0aWMgbWV0aG9kczpcblxuT2JqZWN0LmFzc2lnbiggS2V5ZnJhbWVUcmFjaywge1xuXG5cdC8vIFNlcmlhbGl6YXRpb24gKGluIHN0YXRpYyBjb250ZXh0LCBiZWNhdXNlIG9mIGNvbnN0cnVjdG9yIGludm9jYXRpb25cblx0Ly8gYW5kIGF1dG9tYXRpYyBpbnZvY2F0aW9uIG9mIC50b0pTT04pOlxuXG5cdHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcblxuXHRcdGlmKCBqc29uLnR5cGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcInRyYWNrIHR5cGUgdW5kZWZpbmVkLCBjYW4gbm90IHBhcnNlXCIgKTtcblxuXHRcdH1cblxuXHRcdHZhciB0cmFja1R5cGUgPSBLZXlmcmFtZVRyYWNrLl9nZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKCBqc29uLnR5cGUgKTtcblxuXHRcdGlmICgganNvbi50aW1lcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgdGltZXMgPSBbXSwgdmFsdWVzID0gW107XG5cblx0XHRcdEFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScgKTtcblxuXHRcdFx0anNvbi50aW1lcyA9IHRpbWVzO1xuXHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XG5cblx0XHR9XG5cblx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyBwYXJzZSBtZXRob2Rcblx0XHRpZiAoIHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKCBqc29uICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3NzdW1lIGEgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBiYXNlXG5cdFx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZShcblx0XHRcdFx0XHRqc29uLm5hbWUsIGpzb24udGltZXMsIGpzb24udmFsdWVzLCBqc29uLmludGVycG9sYXRpb24gKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24oIHRyYWNrICkge1xuXG5cdFx0dmFyIHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xuXG5cdFx0dmFyIGpzb247XG5cblx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXG5cdFx0aWYgKCB0cmFja1R5cGUudG9KU09OICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGpzb24gPSB0cmFja1R5cGUudG9KU09OKCB0cmFjayApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIHRoZSBkYXRhIGNhbiBiZSBzZXJpYWxpemVkIGFzLWlzXG5cdFx0XHRqc29uID0ge1xuXG5cdFx0XHRcdCduYW1lJzogdHJhY2submFtZSxcblx0XHRcdFx0J3RpbWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcblx0XHRcdFx0J3ZhbHVlcyc6IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdHJhY2sudmFsdWVzLCBBcnJheSApXG5cblx0XHRcdH07XG5cblx0XHRcdHZhciBpbnRlcnBvbGF0aW9uID0gdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpO1xuXG5cdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRyYWNrLkRlZmF1bHRJbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxuXG5cdFx0cmV0dXJuIGpzb247XG5cblx0fSxcblxuXHRfZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZTogZnVuY3Rpb24oIHR5cGVOYW1lICkge1xuXG5cdFx0c3dpdGNoKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXG5cdFx0XHRjYXNlIFwic2NhbGFyXCI6XG5cdFx0XHRjYXNlIFwiZG91YmxlXCI6XG5cdFx0XHRjYXNlIFwiZmxvYXRcIjpcblx0XHRcdGNhc2UgXCJudW1iZXJcIjpcblx0XHRcdGNhc2UgXCJpbnRlZ2VyXCI6XG5cblx0XHRcdFx0cmV0dXJuIE51bWJlcktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgXCJ2ZWN0b3JcIjpcblx0XHRcdGNhc2UgXCJ2ZWN0b3IyXCI6XG5cdFx0XHRjYXNlIFwidmVjdG9yM1wiOlxuXHRcdFx0Y2FzZSBcInZlY3RvcjRcIjpcblxuXHRcdFx0XHRyZXR1cm4gVmVjdG9yS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSBcImNvbG9yXCI6XG5cblx0XHRcdFx0cmV0dXJuIENvbG9yS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSBcInF1YXRlcm5pb25cIjpcblxuXHRcdFx0XHRyZXR1cm4gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgXCJib29sXCI6XG5cdFx0XHRjYXNlIFwiYm9vbGVhblwiOlxuXG5cdFx0XHRcdHJldHVybiBCb29sZWFuS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxuXG5cdFx0XHRcdHJldHVybiBTdHJpbmdLZXlmcmFtZVRyYWNrO1xuXG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIlVuc3VwcG9ydGVkIHR5cGVOYW1lOiBcIiArIHR5cGVOYW1lICk7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICpcbiAqIFJldXNhYmxlIHNldCBvZiBUcmFja3MgdGhhdCByZXByZXNlbnQgYW4gYW5pbWF0aW9uLlxuICpcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAqL1xuXG5mdW5jdGlvbiBBbmltYXRpb25DbGlwKCBuYW1lLCBkdXJhdGlvbiwgdHJhY2tzICkge1xuXG5cdHRoaXMubmFtZSA9IG5hbWU7XG5cdHRoaXMudHJhY2tzID0gdHJhY2tzO1xuXHR0aGlzLmR1cmF0aW9uID0gKCBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkdXJhdGlvbiA6IC0xO1xuXG5cdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3Ncblx0aWYgKCB0aGlzLmR1cmF0aW9uIDwgMCApIHtcblxuXHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xuXG5cdH1cblxuXHR0aGlzLm9wdGltaXplKCk7XG5cbn1cblxuQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IEFuaW1hdGlvbkNsaXAsXG5cblx0cmVzZXREdXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdHJhY2tzID0gdGhpcy50cmFja3MsXG5cdFx0XHRkdXJhdGlvbiA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xuXG5cdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KCBkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdH0sXG5cblx0dHJpbTogZnVuY3Rpb24oKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRvcHRpbWl6ZTogZnVuY3Rpb24oKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudHJhY2tzWyBpIF0ub3B0aW1pemUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLy8gU3RhdGljIG1ldGhvZHM6XG5cbk9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkNsaXAsIHtcblxuXHRwYXJzZTogZnVuY3Rpb24oIGpzb24gKSB7XG5cblx0XHR2YXIgdHJhY2tzID0gW10sXG5cdFx0XHRqc29uVHJhY2tzID0ganNvbi50cmFja3MsXG5cdFx0XHRmcmFtZVRpbWUgPSAxLjAgLyAoIGpzb24uZnBzIHx8IDEuMCApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0ganNvblRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnBhcnNlKCBqc29uVHJhY2tzWyBpIF0gKS5zY2FsZSggZnJhbWVUaW1lICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCgganNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MgKTtcblxuXHR9LFxuXG5cblx0dG9KU09OOiBmdW5jdGlvbiggY2xpcCApIHtcblxuXHRcdHZhciB0cmFja3MgPSBbXSxcblx0XHRcdGNsaXBUcmFja3MgPSBjbGlwLnRyYWNrcztcblxuXHRcdHZhciBqc29uID0ge1xuXG5cdFx0XHQnbmFtZSc6IGNsaXAubmFtZSxcblx0XHRcdCdkdXJhdGlvbic6IGNsaXAuZHVyYXRpb24sXG5cdFx0XHQndHJhY2tzJzogdHJhY2tzXG5cblx0XHR9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gY2xpcFRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnRvSlNPTiggY2xpcFRyYWNrc1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBqc29uO1xuXG5cdH0sXG5cblxuXHRDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZTogZnVuY3Rpb24oIG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcywgbm9Mb29wICkge1xuXG5cdFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoVGFyZ2V0U2VxdWVuY2UubGVuZ3RoO1xuXHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuXHRcdFx0dmFyIHRpbWVzID0gW107XG5cdFx0XHR2YXIgdmFsdWVzID0gW107XG5cblx0XHRcdHRpbWVzLnB1c2goXG5cdFx0XHRcdFx0KCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0KCBpICsgMSApICUgbnVtTW9ycGhUYXJnZXRzICk7XG5cblx0XHRcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XG5cblx0XHRcdHZhciBvcmRlciA9IEFuaW1hdGlvblV0aWxzLmdldEtleWZyYW1lT3JkZXIoIHRpbWVzICk7XG5cdFx0XHR0aW1lcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB0aW1lcywgMSwgb3JkZXIgKTtcblx0XHRcdHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxuXHRcdFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXG5cdFx0XHRpZiAoICEgbm9Mb29wICYmIHRpbWVzWyAwIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0dGltZXMucHVzaCggbnVtTW9ycGhUYXJnZXRzICk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZXNbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyYWNrcy5wdXNoKFxuXHRcdFx0XHRcdG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKFxuXHRcdFx0XHRcdFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbJyArIG1vcnBoVGFyZ2V0U2VxdWVuY2VbIGkgXS5uYW1lICsgJ10nLFxuXHRcdFx0XHRcdFx0dGltZXMsIHZhbHVlc1xuXHRcdFx0XHRcdCkuc2NhbGUoIDEuMCAvIGZwcyApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCBuYW1lLCAtMSwgdHJhY2tzICk7XG5cblx0fSxcblxuXHRmaW5kQnlOYW1lOiBmdW5jdGlvbiggb2JqZWN0T3JDbGlwQXJyYXksIG5hbWUgKSB7XG5cblx0XHR2YXIgY2xpcEFycmF5ID0gb2JqZWN0T3JDbGlwQXJyYXk7XG5cblx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggb2JqZWN0T3JDbGlwQXJyYXkgKSApIHtcblxuXHRcdFx0dmFyIG8gPSBvYmplY3RPckNsaXBBcnJheTtcblx0XHRcdGNsaXBBcnJheSA9IG8uZ2VvbWV0cnkgJiYgby5nZW9tZXRyeS5hbmltYXRpb25zIHx8IG8uYW5pbWF0aW9ucztcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNsaXBBcnJheS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggY2xpcEFycmF5WyBpIF0ubmFtZSA9PT0gbmFtZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9LFxuXG5cdENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzOiBmdW5jdGlvbiggbW9ycGhUYXJnZXRzLCBmcHMsIG5vTG9vcCApIHtcblxuXHRcdHZhciBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xuXHRcdC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxuXHRcdHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcblxuXHRcdC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZFxuXHRcdC8vIHBhdHRlcm5zIGxpa2UgV2Fsa18wMDEsIFdhbGtfMDAyLCBSdW5fMDAxLCBSdW5fMDAyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0XHR2YXIgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XG5cblx0XHRcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHR2YXIgbmFtZSA9IHBhcnRzWyAxIF07XG5cblx0XHRcdFx0dmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XG5cdFx0XHRcdGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY2xpcHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRjbGlwcy5wdXNoKCBBbmltYXRpb25DbGlwLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdLCBmcHMsIG5vTG9vcCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xpcHM7XG5cblx0fSxcblxuXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcblx0cGFyc2VBbmltYXRpb246IGZ1bmN0aW9uKCBhbmltYXRpb24sIGJvbmVzICkge1xuXG5cdFx0aWYgKCAhIGFuaW1hdGlvbiApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCIgIG5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGFcIiApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHR2YXIgYWRkTm9uZW1wdHlUcmFjayA9IGZ1bmN0aW9uKFxuXHRcdFx0XHR0cmFja1R5cGUsIHRyYWNrTmFtZSwgYW5pbWF0aW9uS2V5cywgcHJvcGVydHlOYW1lLCBkZXN0VHJhY2tzICkge1xuXG5cdFx0XHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cblx0XHRcdGlmICggYW5pbWF0aW9uS2V5cy5sZW5ndGggIT09IDAgKSB7XG5cblx0XHRcdFx0dmFyIHRpbWVzID0gW107XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTihcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHByb3BlcnR5TmFtZSApO1xuXG5cdFx0XHRcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cblx0XHRcdFx0aWYgKCB0aW1lcy5sZW5ndGggIT09IDAgKSB7XG5cblx0XHRcdFx0XHRkZXN0VHJhY2tzLnB1c2goIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwgdGltZXMsIHZhbHVlcyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0dmFyIGNsaXBOYW1lID0gYW5pbWF0aW9uLm5hbWUgfHwgJ2RlZmF1bHQnO1xuXHRcdC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxuXHRcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLTE7XG5cdFx0dmFyIGZwcyA9IGFuaW1hdGlvbi5mcHMgfHwgMzA7XG5cblx0XHR2YXIgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcblxuXHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGhpZXJhcmNoeVRyYWNrcy5sZW5ndGg7IGggKysgKSB7XG5cblx0XHRcdHZhciBhbmltYXRpb25LZXlzID0gaGllcmFyY2h5VHJhY2tzWyBoIF0ua2V5cztcblxuXHRcdFx0Ly8gc2tpcCBlbXB0eSB0cmFja3Ncblx0XHRcdGlmICggISBhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09PSAwICkgY29udGludWU7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggdGFyZ2V0cyBpbiBhIHdheSBleGFjdGx5IGNvbXBhdGlibGVcblx0XHRcdC8vIHdpdGggQW5pbWF0aW9uSGFuZGxlci5pbml0KCBhbmltYXRpb24gKVxuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzWzBdLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHQvLyBmaWd1cmUgb3V0IGFsbCBtb3JwaCB0YXJnZXRzIHVzZWQgaW4gdGhpcyB0cmFja1xuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xuXHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRtb3JwaFRhcmdldE5hbWVzWyBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0c1ttXSBdID0gLTE7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIHRyYWNrIGZvciBlYWNoIG1vcnBoIHRhcmdldCB3aXRoIGFsbCB6ZXJvXG5cdFx0XHRcdC8vIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoXG5cdFx0XHRcdC8vIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cblx0XHRcdFx0Zm9yICggdmFyIG1vcnBoVGFyZ2V0TmFtZSBpbiBtb3JwaFRhcmdldE5hbWVzICkge1xuXG5cdFx0XHRcdFx0dmFyIHRpbWVzID0gW107XG5cdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtICE9PSBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7ICsrIG0gKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzW2tdO1xuXG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBhbmltYXRpb25LZXkudGltZSApO1xuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goICggYW5pbWF0aW9uS2V5Lm1vcnBoVGFyZ2V0ID09PSBtb3JwaFRhcmdldE5hbWUgKSA/IDEgOiAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cmFja3MucHVzaCggbmV3IE51bWJlcktleWZyYW1lVHJhY2soJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqICggZnBzIHx8IDEuMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyAuLi5hc3N1bWUgc2tlbGV0YWwgYW5pbWF0aW9uXG5cblx0XHRcdFx0dmFyIGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbIGggXS5uYW1lICsgJ10nO1xuXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG5cdFx0XHRcdFx0XHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3BvcycsIHRyYWNrcyApO1xuXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG5cdFx0XHRcdFx0XHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnF1YXRlcm5pb24nLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyApO1xuXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG5cdFx0XHRcdFx0XHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcuc2NhbGUnLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3NjbCcsIHRyYWNrcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYWNrcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGNsaXAgPSBuZXcgQW5pbWF0aW9uQ2xpcCggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcblxuXHRcdHJldHVybiBjbGlwO1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gTWF0ZXJpYWxMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdHRoaXMudGV4dHVyZXMgPSB7fTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBNYXRlcmlhbExvYWRlci5wcm90b3R5cGUsIHtcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHNldFRleHR1cmVzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKCBuYW1lICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XG5cblx0XHR9XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWxzWyBqc29uLnR5cGUgXSgpO1xuXG5cdFx0aWYgKCBqc29uLnV1aWQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0aWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XG5cdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcblx0XHRpZiAoIGpzb24ucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcblx0XHRpZiAoIGpzb24ubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3MgPSBqc29uLm1ldGFsbmVzcztcblx0XHRpZiAoIGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleCgganNvbi5lbWlzc2l2ZSApO1xuXHRcdGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KCBqc29uLnNwZWN1bGFyICk7XG5cdFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG5cdFx0aWYgKCBqc29uLmNsZWFyQ29hdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJDb2F0ID0ganNvbi5jbGVhckNvYXQ7XG5cdFx0aWYgKCBqc29uLmNsZWFyQ29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0ganNvbi5jbGVhckNvYXRSb3VnaG5lc3M7XG5cdFx0aWYgKCBqc29uLnVuaWZvcm1zICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51bmlmb3JtcyA9IGpzb24udW5pZm9ybXM7XG5cdFx0aWYgKCBqc29uLnZlcnRleFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0ganNvbi52ZXJ0ZXhTaGFkZXI7XG5cdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG5cdFx0aWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG5cdFx0aWYgKCBqc29uLmZvZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZm9nID0ganNvbi5mb2c7XG5cdFx0aWYgKCBqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRpbmcgPSBqc29uLnNoYWRpbmc7XG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG5cdFx0aWYgKCBqc29uLnNpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG5cdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG5cdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG5cdFx0aWYgKCBqc29uLmFscGhhVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XG5cdFx0aWYgKCBqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XG5cdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG5cdFx0aWYgKCBqc29uLmNvbG9yV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yV3JpdGUgPSBqc29uLmNvbG9yV3JpdGU7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVjYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSBqc29uLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVqb2luICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0aWYgKCBqc29uLnNraW5uaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5za2lubmluZyA9IGpzb24uc2tpbm5pbmc7XG5cdFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0ganNvbi5tb3JwaFRhcmdldHM7XG5cblx0XHQvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcblxuXHRcdGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuXHRcdGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0Ly8gbWFwc1xuXG5cdFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gZ2V0VGV4dHVyZSgganNvbi5tYXAgKTtcblxuXHRcdGlmICgganNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcblx0XHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XG5cdFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XG5cblx0XHRpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm5vcm1hbE1hcCApO1xuXHRcdGlmICgganNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbm9ybWFsU2NhbGUgPSBqc29uLm5vcm1hbFNjYWxlO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5vcm1hbFNjYWxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxuXG5cdFx0XHRcdG5vcm1hbFNjYWxlID0gWyBub3JtYWxTY2FsZSwgbm9ybWFsU2NhbGUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBub3JtYWxTY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ucm91Z2huZXNzTWFwICk7XG5cdFx0aWYgKCBqc29uLm1ldGFsbmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5tZXRhbG5lc3NNYXAgKTtcblxuXHRcdGlmICgganNvbi5lbWlzc2l2ZU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVtaXNzaXZlTWFwICk7XG5cdFx0aWYgKCBqc29uLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSA9IGpzb24uZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHRpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xuXG5cdFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW52TWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcblxuXHRcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuXG5cdFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIGpzb24ubGlnaHRNYXAgKTtcblx0XHRpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XG5cdFx0aWYgKCBqc29uLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGpzb24uYW9NYXBJbnRlbnNpdHk7XG5cblx0XHRpZiAoIGpzb24uZ3JhZGllbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdyYWRpZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5ncmFkaWVudE1hcCApO1xuXG5cdFx0Ly8gTXVsdGlNYXRlcmlhbFxuXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnlMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR2YXIgaW5kZXggPSBqc29uLmRhdGEuaW5kZXg7XG5cblx0XHR2YXIgVFlQRURfQVJSQVlTID0ge1xuXHRcdFx0J0ludDhBcnJheSc6IEludDhBcnJheSxcblx0XHRcdCdVaW50OEFycmF5JzogVWludDhBcnJheSxcblx0XHRcdCdVaW50OENsYW1wZWRBcnJheSc6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHRcdFx0J0ludDE2QXJyYXknOiBJbnQxNkFycmF5LFxuXHRcdFx0J1VpbnQxNkFycmF5JzogVWludDE2QXJyYXksXG5cdFx0XHQnSW50MzJBcnJheSc6IEludDMyQXJyYXksXG5cdFx0XHQnVWludDMyQXJyYXknOiBVaW50MzJBcnJheSxcblx0XHRcdCdGbG9hdDMyQXJyYXknOiBGbG9hdDMyQXJyYXksXG5cdFx0XHQnRmxvYXQ2NEFycmF5JzogRmxvYXQ2NEFycmF5XG5cdFx0fTtcblxuXHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgVFlQRURfQVJSQVlTWyBpbmRleC50eXBlIF0oIGluZGV4LmFycmF5ICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XG5cblx0XHR9XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xuXG5cdFx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCApICk7XG5cblx0XHR9XG5cblx0XHR2YXIgZ3JvdXBzID0ganNvbi5kYXRhLmdyb3VwcyB8fCBqc29uLmRhdGEuZHJhd2NhbGxzIHx8IGpzb24uZGF0YS5vZmZzZXRzO1xuXG5cdFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZ3JvdXBzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2VudGVyLmZyb21BcnJheSggYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuZnVuY3Rpb24gTG9hZGVyKCkge1xuXG5cdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcblx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XG5cbn1cblxuTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogTG9hZGVyLFxuXG5cdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cblx0ZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0dmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcblxuXHRcdGlmICggcGFydHMubGVuZ3RoID09PSAxICkgcmV0dXJuICcuLyc7XG5cblx0XHRwYXJ0cy5wb3AoKTtcblxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcblxuXHR9LFxuXG5cdGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XG5cblx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRjcmVhdGVNYXRlcmlhbDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgQmxlbmRpbmdNb2RlID0ge1xuXHRcdFx0Tm9CbGVuZGluZzogTm9CbGVuZGluZyxcblx0XHRcdE5vcm1hbEJsZW5kaW5nOiBOb3JtYWxCbGVuZGluZyxcblx0XHRcdEFkZGl0aXZlQmxlbmRpbmc6IEFkZGl0aXZlQmxlbmRpbmcsXG5cdFx0XHRTdWJ0cmFjdGl2ZUJsZW5kaW5nOiBTdWJ0cmFjdGl2ZUJsZW5kaW5nLFxuXHRcdFx0TXVsdGlwbHlCbGVuZGluZzogTXVsdGlwbHlCbGVuZGluZyxcblx0XHRcdEN1c3RvbUJsZW5kaW5nOiBDdXN0b21CbGVuZGluZ1xuXHRcdH07XG5cblx0XHR2YXIgY29sb3IsIHRleHR1cmVMb2FkZXIsIG1hdGVyaWFsTG9hZGVyO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1hdGVyaWFsKCBtLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XG5cblx0XHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IENvbG9yKCk7XG5cdFx0XHRpZiAoIHRleHR1cmVMb2FkZXIgPT09IHVuZGVmaW5lZCApIHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuXHRcdFx0aWYgKCBtYXRlcmlhbExvYWRlciA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxMb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcblxuXHRcdFx0Ly8gY29udmVydCBmcm9tIG9sZCBtYXRlcmlhbCBmb3JtYXRcblxuXHRcdFx0dmFyIHRleHR1cmVzID0ge307XG5cblx0XHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBwYXRoLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcblxuXHRcdFx0XHR2YXIgZnVsbFBhdGggPSB0ZXh0dXJlUGF0aCArIHBhdGg7XG5cdFx0XHRcdHZhciBsb2FkZXIgPSBMb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xuXG5cdFx0XHRcdHZhciB0ZXh0dXJlO1xuXG5cdFx0XHRcdGlmICggbG9hZGVyICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApO1xuXHRcdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcmVwZWF0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIHJlcGVhdCApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXBlYXRbIDAgXSAhPT0gMSApIHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBvZmZzZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB3cmFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHdyYXBbIDAgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAwIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwUyA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAxIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwVCA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdFx0XHR0ZXh0dXJlc1sgdXVpZCBdID0gdGV4dHVyZTtcblxuXHRcdFx0XHRyZXR1cm4gdXVpZDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIganNvbiA9IHtcblx0XHRcdFx0dXVpZDogX01hdGguZ2VuZXJhdGVVVUlEKCksXG5cdFx0XHRcdHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBtWyBuYW1lIF07XG5cblx0XHRcdFx0c3dpdGNoICggbmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ0RiZ0NvbG9yJzpcblx0XHRcdFx0XHRjYXNlICdEYmdJbmRleCc6XG5cdFx0XHRcdFx0Y2FzZSAnb3B0aWNhbERlbnNpdHknOlxuXHRcdFx0XHRcdGNhc2UgJ2lsbHVtaW5hdGlvbic6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdEYmdOYW1lJzpcblx0XHRcdFx0XHRcdGpzb24ubmFtZSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnYmxlbmRpbmcnOlxuXHRcdFx0XHRcdFx0anNvbi5ibGVuZGluZyA9IEJsZW5kaW5nTW9kZVsgdmFsdWUgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yQW1iaWVudCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQW1iaWVudCc6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6JywgbmFtZSwgJ2lzIG5vIGxvbmdlciBzdXBwb3J0ZWQuJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnY29sb3JEaWZmdXNlJzpcblx0XHRcdFx0XHRcdGpzb24uY29sb3IgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjb2xvclNwZWN1bGFyJzpcblx0XHRcdFx0XHRcdGpzb24uc3BlY3VsYXIgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjb2xvckVtaXNzaXZlJzpcblx0XHRcdFx0XHRcdGpzb24uZW1pc3NpdmUgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdzcGVjdWxhckNvZWYnOlxuXHRcdFx0XHRcdFx0anNvbi5zaGluaW5lc3MgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3NoYWRpbmcnOlxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnYmFzaWMnICkganNvbi50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdzdGFuZGFyZCcgKSBqc29uLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZSc6XG5cdFx0XHRcdFx0XHRqc29uLm1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VPZmZzZXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VXcmFwJzpcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZSc6XG5cdFx0XHRcdFx0XHRqc29uLmVtaXNzaXZlTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEVtaXNzaXZlUmVwZWF0LCBtLm1hcEVtaXNzaXZlT2Zmc2V0LCBtLm1hcEVtaXNzaXZlV3JhcCwgbS5tYXBFbWlzc2l2ZUFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlUmVwZWF0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZU9mZnNldCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwRW1pc3NpdmVXcmFwJzpcblx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZUFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHQnOlxuXHRcdFx0XHRcdFx0anNvbi5saWdodE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFJlcGVhdCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRPZmZzZXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0V3JhcCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcEFPJzpcblx0XHRcdFx0XHRcdGpzb24uYW9NYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQU9SZXBlYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPT2Zmc2V0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBBT1dyYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBCdW1wJzpcblx0XHRcdFx0XHRcdGpzb24uYnVtcE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBTY2FsZSc6XG5cdFx0XHRcdFx0XHRqc29uLmJ1bXBTY2FsZSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFJlcGVhdCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcE9mZnNldCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFdyYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbCc6XG5cdFx0XHRcdFx0XHRqc29uLm5vcm1hbE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsRmFjdG9yJzpcblx0XHRcdFx0XHRcdGpzb24ubm9ybWFsU2NhbGUgPSBbIHZhbHVlLCB2YWx1ZSBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsUmVwZWF0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxPZmZzZXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbFdyYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXInOlxuXHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhck1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBTcGVjdWxhclJlcGVhdCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJPZmZzZXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyV3JhcCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcE1ldGFsbmVzcyc6XG5cdFx0XHRcdFx0XHRqc29uLm1ldGFsbmVzc01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBNZXRhbG5lc3NSZXBlYXQsIG0ubWFwTWV0YWxuZXNzT2Zmc2V0LCBtLm1hcE1ldGFsbmVzc1dyYXAsIG0ubWFwTWV0YWxuZXNzQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzUmVwZWF0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NPZmZzZXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcE1ldGFsbmVzc1dyYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcE1ldGFsbmVzc0FuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzJzpcblx0XHRcdFx0XHRcdGpzb24ucm91Z2huZXNzTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcFJvdWdobmVzc1JlcGVhdCwgbS5tYXBSb3VnaG5lc3NPZmZzZXQsIG0ubWFwUm91Z2huZXNzV3JhcCwgbS5tYXBSb3VnaG5lc3NBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBSb3VnaG5lc3NSZXBlYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzc09mZnNldCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzV3JhcCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYSc6XG5cdFx0XHRcdFx0XHRqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcEFscGhhUmVwZWF0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYU9mZnNldCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFXcmFwJzpcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYUFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZmxpcFNpZGVkJzpcblx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IEJhY2tTaWRlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZG91YmxlU2lkZWQnOlxuXHRcdFx0XHRcdFx0anNvbi5zaWRlID0gRG91YmxlU2lkZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XG5cdFx0XHRcdFx0XHRqc29uLm9wYWNpdHkgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2RlcHRoVGVzdCc6XG5cdFx0XHRcdFx0Y2FzZSAnZGVwdGhXcml0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnY29sb3JXcml0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnb3BhY2l0eSc6XG5cdFx0XHRcdFx0Y2FzZSAncmVmbGVjdGl2aXR5Jzpcblx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVudCc6XG5cdFx0XHRcdFx0Y2FzZSAndmlzaWJsZSc6XG5cdFx0XHRcdFx0Y2FzZSAnd2lyZWZyYW1lJzpcblx0XHRcdFx0XHRcdGpzb25bIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndmVydGV4Q29sb3JzJzpcblx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09IHRydWUgKSBqc29uLnZlcnRleENvbG9ycyA9IFZlcnRleENvbG9ycztcblx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICdmYWNlJyApIGpzb24udmVydGV4Q29sb3JzID0gRmFjZUNvbG9ycztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBVbnN1cHBvcnRlZCcsIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqc29uLnR5cGUgPT09ICdNZXNoQmFzaWNNYXRlcmlhbCcgKSBkZWxldGUganNvbi5lbWlzc2l2ZTtcblx0XHRcdGlmICgganNvbi50eXBlICE9PSAnTWVzaFBob25nTWF0ZXJpYWwnICkgZGVsZXRlIGpzb24uc3BlY3VsYXI7XG5cblx0XHRcdGlmICgganNvbi5vcGFjaXR5IDwgMSApIGpzb24udHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHRtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsTG9hZGVyLnBhcnNlKCBqc29uICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpXG5cbn07XG5cbkxvYWRlci5IYW5kbGVycyA9IHtcblxuXHRoYW5kbGVyczogW10sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHJlZ2V4LCBsb2FkZXIgKSB7XG5cblx0XHR0aGlzLmhhbmRsZXJzLnB1c2goIHJlZ2V4LCBsb2FkZXIgKTtcblxuXHR9LFxuXG5cdGdldDogZnVuY3Rpb24gKCBmaWxlICkge1xuXG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0dmFyIHJlZ2V4ID0gaGFuZGxlcnNbIGkgXTtcblx0XHRcdHZhciBsb2FkZXIgPSBoYW5kbGVyc1sgaSArIDEgXTtcblxuXHRcdFx0aWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGxvYWRlcjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbmZ1bmN0aW9uIEpTT05Mb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0aWYgKCB0eXBlb2YgbWFuYWdlciA9PT0gJ2Jvb2xlYW4nICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogc2hvd1N0YXR1cyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGNvbnN0cnVjdG9yLicgKTtcblx0XHRtYW5hZ2VyID0gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG59XG5cbk9iamVjdC5hc3NpZ24oIEpTT05Mb2FkZXIucHJvdG90eXBlLCB7XG5cblx0bG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IExvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cdFx0XHR2YXIgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xuXG5cdFx0XHRpZiAoIG1ldGFkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIHR5cGUgPSBtZXRhZGF0YS50eXBlO1xuXG5cdFx0XHRcdGlmICggdHlwZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdHlwZS50b0xvd2VyQ2FzZSgpID09PSAnc2NlbmUnICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLlNjZW5lTG9hZGVyIGluc3RlYWQuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG5cdFx0XHRvbkxvYWQoIG9iamVjdC5nZW9tZXRyeSwgb2JqZWN0Lm1hdGVyaWFscyApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpLFxuXHRcdHNjYWxlID0gKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSA/IDEuMCAvIGpzb24uc2NhbGUgOiAxLjA7XG5cblx0XHRwYXJzZU1vZGVsKCBzY2FsZSApO1xuXG5cdFx0cGFyc2VTa2luKCk7XG5cdFx0cGFyc2VNb3JwaGluZyggc2NhbGUgKTtcblx0XHRwYXJzZUFuaW1hdGlvbnMoKTtcblxuXHRcdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VNb2RlbCggc2NhbGUgKSB7XG5cblx0XHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGksIGosIGZpLFxuXG5cdFx0XHRvZmZzZXQsIHpMZW5ndGgsXG5cblx0XHRjb2xvckluZGV4LCBub3JtYWxJbmRleCwgdXZJbmRleCwgbWF0ZXJpYWxJbmRleCxcblxuXHRcdFx0dHlwZSxcblx0XHRcdGlzUXVhZCxcblx0XHRcdGhhc01hdGVyaWFsLFxuXHRcdFx0aGFzRmFjZVZlcnRleFV2LFxuXHRcdFx0aGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcblx0XHRcdGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yLFxuXG5cdFx0dmVydGV4LCBmYWNlLCBmYWNlQSwgZmFjZUIsIGhleCwgbm9ybWFsLFxuXG5cdFx0XHR1dkxheWVyLCB1diwgdSwgdixcblxuXHRcdFx0ZmFjZXMgPSBqc29uLmZhY2VzLFxuXHRcdFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxuXHRcdFx0bm9ybWFscyA9IGpzb24ubm9ybWFscyxcblx0XHRcdGNvbG9ycyA9IGpzb24uY29sb3JzLFxuXG5cdFx0XHRuVXZMYXllcnMgPSAwO1xuXG5cdFx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gZGlzcmVnYXJkIGVtcHR5IGFycmF5c1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuXHRcdFx0XHR2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cdFx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuXHRcdFx0XHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cblx0XHRcdFx0aXNRdWFkICAgICAgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAwICk7XG5cdFx0XHRcdGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xuXHRcdFx0XHRoYXNGYWNlVmVydGV4VXYgICAgID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcblx0XHRcdFx0aGFzRmFjZU5vcm1hbCAgICAgICA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xuXHRcdFx0XHRoYXNGYWNlQ29sb3JcdCAgICAgPSBpc0JpdFNldCggdHlwZSwgNiApO1xuXHRcdFx0XHRoYXNGYWNlVmVydGV4Q29sb3IgID0gaXNCaXRTZXQoIHR5cGUsIDcgKTtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInR5cGVcIiwgdHlwZSwgXCJiaXRzXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xuXG5cdFx0XHRcdGlmICggaXNRdWFkICkge1xuXG5cdFx0XHRcdFx0ZmFjZUEgPSBuZXcgRmFjZTMoKTtcblx0XHRcdFx0XHRmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xuXHRcdFx0XHRcdGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0XHRcdGZhY2VBLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0XHRcdFx0ZmFjZUIgPSBuZXcgRmFjZTMoKTtcblx0XHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcblx0XHRcdFx0XHRmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcblx0XHRcdFx0XHRmYWNlQi5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuXHRcdFx0XHRcdG9mZnNldCArPSA0O1xuXG5cdFx0XHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0ZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuXHRcdFx0XHRcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCA0OyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuXHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFZlY3RvcjIoIHUsIHYgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG5cdFx0XHRcdFx0XHRmYWNlQS5ub3JtYWwuc2V0KFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0KTtcblxuXG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuXHRcdFx0XHRcdFx0ZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcblx0XHRcdFx0XHRcdGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdFx0aGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggaGV4ICkgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggaGV4ICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUEgKTtcblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmYWNlID0gbmV3IEZhY2UzKCk7XG5cdFx0XHRcdFx0ZmFjZS5hID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG5cdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuXHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFZlY3RvcjIoIHUsIHYgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRcdGZhY2Uubm9ybWFsLnNldChcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMyhcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRcdGZhY2UudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggY29sb3JzWyBjb2xvckluZGV4IF0gKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG5cblx0XHRcdHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcblxuXHRcdFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG5cdFx0XHRcdFx0dmFyIHggPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNraW5XZWlnaHRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcblx0XHRcdFx0XHR2YXIgeiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAyIF0gOiAwO1xuXHRcdFx0XHRcdHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi5za2luSW5kaWNlcyApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luSW5kaWNlc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XG5cdFx0XHRcdFx0dmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcblx0XHRcdFx0XHR2YXIgZCA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAzIF0gOiAwO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cblx0XHRcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcblx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzID0gW107XG5cblx0XHRcdFx0XHR2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblx0XHRcdFx0XHR2YXIgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRcdFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XG5cblx0XHRcdFx0XHRcdGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogXCJtb3JwaENvbG9yc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzaW5nIHRoZW0gYXMgZmFjZSBjb2xvcnMuJyApO1xuXG5cdFx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXHRcdFx0XHR2YXIgbW9ycGhDb2xvcnMgPSBqc29uLm1vcnBoQ29sb3JzWyAwIF0uY29sb3JzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlc1sgaSBdLmNvbG9yLmZyb21BcnJheSggbW9ycGhDb2xvcnMsIGkgKiAzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbnMoKSB7XG5cblx0XHRcdHZhciBvdXRwdXRBbmltYXRpb25zID0gW107XG5cblx0XHRcdC8vIHBhcnNlIG9sZCBzdHlsZSBCb25lL0hpZXJhcmNoeSBhbmltYXRpb25zXG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbnMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0YW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMuY29uY2F0KCBqc29uLmFuaW1hdGlvbnMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbnMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlQW5pbWF0aW9uKCBhbmltYXRpb25zWyBpIF0sIGdlb21ldHJ5LmJvbmVzICk7XG5cdFx0XHRcdGlmICggY2xpcCApIG91dHB1dEFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHBhcnNlIGltcGxpY2l0IG1vcnBoIGFuaW1hdGlvbnNcblx0XHRcdGlmICggZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBhbiBhcHByb3ByYWl0ZSBGUFMgaXMgZm9yIG1vcnBoIHRhcmdldCBhbmltYXRpb25zIC0tIGRlZmF1bHRpbmcgdG8gMTAsIGJ1dCByZWFsbHkgaXQgaXMgY29tcGxldGVseSBhcmJpdHJhcnkuXG5cdFx0XHRcdHZhciBtb3JwaEFuaW1hdGlvbkNsaXBzID0gQW5pbWF0aW9uQ2xpcC5DcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggZ2VvbWV0cnkubW9ycGhUYXJnZXRzLCAxMCApO1xuXHRcdFx0XHRvdXRwdXRBbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucy5jb25jYXQoIG1vcnBoQW5pbWF0aW9uQ2xpcHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG91dHB1dEFuaW1hdGlvbnMubGVuZ3RoID4gMCApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5IH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0cmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5LCBtYXRlcmlhbHM6IG1hdGVyaWFscyB9O1xuXG5cdFx0fVxuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gT2JqZWN0TG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXHR0aGlzLnRleHR1cmVQYXRoID0gJyc7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggT2JqZWN0TG9hZGVyLnByb3RvdHlwZSwge1xuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xuXG5cdFx0XHR0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcblxuXHRcdH1cblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHZhciBqc29uID0gbnVsbDtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSBvbkVycm9yKCBlcnJvciApO1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRTpPYmplY3RMb2FkZXI6IENhblxcJ3QgcGFyc2UgJyArIHVybCArICcuJywgZXJyb3IubWVzc2FnZSApO1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xuXG5cdFx0XHRpZiAoIG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5JyApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCArICcuIFVzZSBUSFJFRS5KU09OTG9hZGVyIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUucGFyc2UoIGpzb24sIG9uTG9hZCApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XG5cblx0fSxcblxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcyApO1xuXG5cdFx0dmFyIGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoIGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG5cdFx0fSApO1xuXG5cdFx0dmFyIHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcblx0XHR2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XG5cblx0XHR2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xuXG5cdFx0aWYgKCBqc29uLmFuaW1hdGlvbnMgKSB7XG5cblx0XHRcdG9iamVjdC5hbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoIGpzb24uYW5pbWF0aW9ucyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLmltYWdlcyA9PT0gdW5kZWZpbmVkIHx8IGpzb24uaW1hZ2VzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdH0sXG5cblx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBKU09OTG9hZGVyKCk7XG5cdFx0XHR2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeTtcblx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnUGxhbmVHZW9tZXRyeSc6XG5cdFx0XHRcdFx0Y2FzZSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0JveEdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdCb3hCdWZmZXJHZW9tZXRyeSc6XG5cdFx0XHRcdFx0Y2FzZSAnQ3ViZUdlb21ldHJ5JzogLy8gYmFja3dhcmRzIGNvbXBhdGlibGVcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGhTZWdtZW50c1xuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdDaXJjbGVHZW9tZXRyeSc6XG5cdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzVG9wLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c0JvdHRvbSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ29uZUdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdDb25lQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLm9wZW5FbmRlZCxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NwaGVyZUdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaUxlbmd0aCxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0RvZGVjYWhlZHJvbkdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdJY29zYWhlZHJvbkdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxuXHRcdFx0XHRcdGNhc2UgJ1RldHJhaGVkcm9uR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1JpbmdHZW9tZXRyeSc6XG5cdFx0XHRcdFx0Y2FzZSAnUmluZ0J1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdGRhdGEuaW5uZXJSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEub3V0ZXJSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuYXJjXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5wLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnFcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnTGF0aGVHZW9tZXRyeSc6XG5cdFx0XHRcdFx0Y2FzZSAnTGF0aGVCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRkYXRhLnBvaW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5zZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTdGFydCxcblx0XHRcdFx0XHRcdFx0ZGF0YS5waGlMZW5ndGhcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLmRhdGEsIHRoaXMudGV4dHVyZVBhdGggKS5nZW9tZXRyeTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCInICsgZGF0YS50eXBlICsgJ1wiJyApO1xuXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcblxuXHR9LFxuXG5cdHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVzICkge1xuXG5cdFx0dmFyIG1hdGVyaWFscyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcblx0XHRcdGxvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSgganNvblsgaSBdICk7XG5cdFx0XHRcdG1hdGVyaWFsc1sgbWF0ZXJpYWwudXVpZCBdID0gbWF0ZXJpYWw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cblx0fSxcblxuXHRwYXJzZUFuaW1hdGlvbnM6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciBhbmltYXRpb25zID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKCBqc29uWyBpIF0gKTtcblxuXHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblxuXHR9LFxuXG5cdHBhcnNlSW1hZ2VzOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0dmFyIGltYWdlcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gbG9hZEltYWdlKCB1cmwgKSB7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0cmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIG1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoIG9uTG9hZCApO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCBtYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbWFnZSA9IGpzb25bIGkgXTtcblx0XHRcdFx0dmFyIHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QoIGltYWdlLnVybCApID8gaW1hZ2UudXJsIDogc2NvcGUudGV4dHVyZVBhdGggKyBpbWFnZS51cmw7XG5cblx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBsb2FkSW1hZ2UoIHBhdGggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlcztcblxuXHR9LFxuXG5cdHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uICgganNvbiwgaW1hZ2VzICkge1xuXG5cdFx0dmFyIFRleHR1cmVNYXBwaW5nID0ge1xuXHRcdFx0VVZNYXBwaW5nOiBVVk1hcHBpbmcsXG5cdFx0XHRDdWJlUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVSZWZsZWN0aW9uTWFwcGluZyxcblx0XHRcdEN1YmVSZWZyYWN0aW9uTWFwcGluZzogQ3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxuXHRcdFx0RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdFx0RXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLFxuXHRcdFx0U3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6IFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdFx0Q3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdFx0Q3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nXG5cdFx0fTtcblxuXHRcdHZhciBUZXh0dXJlV3JhcHBpbmcgPSB7XG5cdFx0XHRSZXBlYXRXcmFwcGluZzogUmVwZWF0V3JhcHBpbmcsXG5cdFx0XHRDbGFtcFRvRWRnZVdyYXBwaW5nOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRcdFx0TWlycm9yZWRSZXBlYXRXcmFwcGluZzogTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuXHRcdH07XG5cblx0XHR2YXIgVGV4dHVyZUZpbHRlciA9IHtcblx0XHRcdE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG5cdFx0XHROZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIsXG5cdFx0XHROZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyOiBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyLFxuXHRcdFx0TGluZWFyRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyLFxuXHRcdFx0TGluZWFyTWlwTWFwTGluZWFyRmlsdGVyOiBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXJcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDb25zdGFudCggdmFsdWUsIHR5cGUgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mKCB2YWx1ZSApID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xuXG5cdFx0XHRyZXR1cm4gdHlwZVsgdmFsdWUgXTtcblxuXHRcdH1cblxuXHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xuXG5cdFx0XHRcdGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcsIFRleHR1cmVNYXBwaW5nICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBkYXRhLm9mZnNldCApO1xuXHRcdFx0XHRpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIGRhdGEucmVwZWF0ICk7XG5cdFx0XHRcdGlmICggZGF0YS53cmFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0sIFRleHR1cmVXcmFwcGluZyApO1xuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSwgVGV4dHVyZVdyYXBwaW5nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5taW5GaWx0ZXIsIFRleHR1cmVGaWx0ZXIgKTtcblx0XHRcdFx0aWYgKCBkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hZ0ZpbHRlciwgVGV4dHVyZUZpbHRlciApO1xuXHRcdFx0XHRpZiAoIGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xuXG5cdFx0XHRcdGlmICggZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5mbGlwWSA9IGRhdGEuZmxpcFk7XG5cblx0XHRcdFx0dGV4dHVyZXNbIGRhdGEudXVpZCBdID0gdGV4dHVyZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmVzO1xuXG5cdH0sXG5cblx0cGFyc2VPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBvYmplY3Q7XG5cblx0XHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeScsIG5hbWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcblxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnU2NlbmUnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNjZW5lKCk7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIE51bWJlci5pc0ludGVnZXIoIGRhdGEuYmFja2dyb3VuZCApICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gbmV3IENvbG9yKCBkYXRhLmJhY2tncm91bmQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmZvZyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2cnICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cubmVhciwgZGF0YS5mb2cuZmFyICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2dFeHAyJyApIHtcblxuXHRcdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZ0V4cDIoIGRhdGEuZm9nLmNvbG9yLCBkYXRhLmZvZy5kZW5zaXR5ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEuZm9jdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5mb2N1cyA9IGRhdGEuZm9jdXM7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLnpvb20gIT09IHVuZGVmaW5lZCApIG9iamVjdC56b29tID0gZGF0YS56b29tO1xuXHRcdFx0XHRcdGlmICggZGF0YS5maWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIG9iamVjdC5maWxtR2F1Z2UgPSBkYXRhLmZpbG1HYXVnZTtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZmlsbU9mZnNldCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1PZmZzZXQgPSBkYXRhLmZpbG1PZmZzZXQ7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIGRhdGEudmlldyApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBbWJpZW50TGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEFtYmllbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01lc2gnOlxuXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTE9EJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMT0QoKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xpbmUnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTGluZVNlZ21lbnRzJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BvaW50Q2xvdWQnOlxuXHRcdFx0XHRjYXNlICdQb2ludHMnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFBvaW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3ByaXRlJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0dyb3VwJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU2tpbm5lZE1lc2gnOlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlT2JqZWN0KCkgZG9lcyBub3Qgc3VwcG9ydCBTa2lubmVkTWVzaCB0eXBlLiBJbnN0YW50aWF0ZXMgT2JqZWN0M0QgaW5zdGVhZC4nICk7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXG5cdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcblx0XHRcdFx0bWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XG5cdFx0XHRcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xuXHRcdFx0XHRpZiAoIGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBkYXRhLnF1YXRlcm5pb24gKTtcblx0XHRcdFx0aWYgKCBkYXRhLnNjYWxlICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KCBkYXRhLnNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkYXRhLmNhc3RTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xuXHRcdFx0aWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xuXG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93ICkge1xuXG5cdFx0XHRcdGlmICggZGF0YS5zaGFkb3cuYmlhcyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5iaWFzID0gZGF0YS5zaGFkb3cuYmlhcztcblx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5yYWRpdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cucmFkaXVzID0gZGF0YS5zaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRpZiAoIGRhdGEuc2hhZG93Lm1hcFNpemUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cubWFwU2l6ZS5mcm9tQXJyYXkoIGRhdGEuc2hhZG93Lm1hcFNpemUgKTtcblx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5jYW1lcmEgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cuY2FtZXJhID0gdGhpcy5wYXJzZU9iamVjdCggZGF0YS5zaGFkb3cuY2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuXHRcdFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXG5cdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgY2hpbGQgaW4gZGF0YS5jaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGRhdGEuY2hpbGRyZW5bIGNoaWxkIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcblxuXHRcdFx0XHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdFx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1sgbCBdO1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IG9iamVjdC5nZXRPYmplY3RCeVByb3BlcnR5KCAndXVpZCcsIGxldmVsLm9iamVjdCApO1xuXG5cdFx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0fTtcblxuXHR9KClcblxufSApO1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZVxuICovXG5cbmZ1bmN0aW9uIENhdG11bGxSb20oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xuXHR2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblx0dmFyIHQyID0gdCAqIHQ7XG5cdHZhciB0MyA9IHQgKiB0Mjtcblx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbn1cblxuLy9cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAgKSB7XG5cblx0dmFyIGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogcDtcblxufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKCB0LCBwICkge1xuXG5cdHJldHVybiB0ICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcDAgKSArIFF1YWRyYXRpY0JlemllclAxKCB0LCBwMSApICtcblx0XHRRdWFkcmF0aWNCZXppZXJQMiggdCwgcDIgKTtcblxufVxuXG4vL1xuXG5mdW5jdGlvbiBDdWJpY0JlemllclAwKCB0LCBwICkge1xuXG5cdHZhciBrID0gMSAtIHQ7XG5cdHJldHVybiBrICogayAqIGsgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDEoIHQsIHAgKSB7XG5cblx0dmFyIGsgPSAxIC0gdDtcblx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDIoIHQsIHAgKSB7XG5cblx0cmV0dXJuIDMgKiAoIDEgLSB0ICkgKiB0ICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMyggdCwgcCApIHtcblxuXHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllciggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cblx0cmV0dXJuIEN1YmljQmV6aWVyUDAoIHQsIHAwICkgKyBDdWJpY0JlemllclAxKCB0LCBwMSApICsgQ3ViaWNCZXppZXJQMiggdCwgcDIgKSArXG5cdFx0Q3ViaWNCZXppZXJQMyggdCwgcDMgKTtcblxufVxuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XG4gKlxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFuZ2VudEF0KHUpXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY2xhc3NlcyBzdWJjbGFzc2VzIFRIUkVFLkN1cnZlOlxuICpcbiAqIC0tIDJkIGNsYXNzZXMgLS1cbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKiBUSFJFRS5BcmNDdXJ2ZVxuICogVEhSRUUuRWxsaXBzZUN1cnZlXG4gKlxuICogLS0gM2QgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuQ2F0bXVsbFJvbUN1cnZlM1xuICpcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gQ3VydmUoKSB7fVxuXG5DdXJ2ZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IEN1cnZlLFxuXG5cdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuXHQvL1x0LSB0IFswIC4uIDFdXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9LFxuXG5cdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuXHQvLyAtIHUgWzAgLi4gMV1cblxuXHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUgKSB7XG5cblx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xuXG5cdH0sXG5cblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cblx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRcdGlmICggaXNOYU4oIGRpdmlzaW9ucyApICkgZGl2aXNpb25zID0gNTtcblxuXHRcdHZhciBwb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fSxcblxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG5cdGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRpZiAoIGlzTmFOKCBkaXZpc2lvbnMgKSApIGRpdmlzaW9ucyA9IDU7XG5cblx0XHR2YXIgcG9pbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fSxcblxuXHQvLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XG5cblx0fSxcblxuXHQvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG5cdGdldExlbmd0aHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0aWYgKCBpc05hTiggZGl2aXNpb25zICkgKSBkaXZpc2lvbnMgPSAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA/ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApIDogMjAwO1xuXG5cdFx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Roc1xuXHRcdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKVxuXHRcdFx0JiYgISB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dmFyIGNhY2hlID0gW107XG5cdFx0dmFyIGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XG5cdFx0dmFyIHAsIHN1bSA9IDA7XG5cblx0XHRjYWNoZS5wdXNoKCAwICk7XG5cblx0XHRmb3IgKCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHAgKysgKSB7XG5cblx0XHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50ICggcCAvIGRpdmlzaW9ucyApO1xuXHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuXHRcdFx0Y2FjaGUucHVzaCggc3VtICk7XG5cdFx0XHRsYXN0ID0gY3VycmVudDtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XG5cblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG5cblx0fSxcblxuXHR1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuZ2V0TGVuZ3RocygpO1xuXG5cdH0sXG5cblx0Ly8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxuXG5cdGdldFV0b1RtYXBwaW5nOiBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xuXG5cdFx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblxuXHRcdHZhciBpID0gMCwgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcblxuXHRcdHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG5cdFx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0XHR9XG5cblx0XHQvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXG5cblx0XHR2YXIgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcblxuXHRcdHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XG5cblx0XHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xuXG5cdFx0XHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xuXG5cdFx0XHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG5cdFx0XHRcdGxvdyA9IGkgKyAxO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcblxuXHRcdFx0XHRoaWdoID0gaSAtIDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aGlnaCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIERPTkVcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aSA9IGhpZ2g7XG5cblx0XHQvL2NvbnNvbGUubG9nKCdiJyAsIGksIGxvdywgaGlnaCwgRGF0ZS5ub3coKS0gdGltZSk7XG5cblx0XHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgdCA9IGkgLyAoIGlsIC0gMSApO1xuXHRcdFx0cmV0dXJuIHQ7XG5cblx0XHR9XG5cblx0XHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuXG5cdFx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcblx0XHR2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG5cdFx0dmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcblxuXHRcdC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cblx0XHR2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cblx0XHQvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cblx0XHR2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcblxuXHRcdHJldHVybiB0O1xuXG5cdH0sXG5cblx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuXHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG5cdC8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XG5cdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuXHRnZXRUYW5nZW50OiBmdW5jdGlvbiggdCApIHtcblxuXHRcdHZhciBkZWx0YSA9IDAuMDAwMTtcblx0XHR2YXIgdDEgPSB0IC0gZGVsdGE7XG5cdFx0dmFyIHQyID0gdCArIGRlbHRhO1xuXG5cdFx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG5cdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XG5cdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cblx0XHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcblx0XHR2YXIgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcblxuXHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xuXHRcdHJldHVybiB2ZWMubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcblxuXHRcdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuXHRcdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcblxuXHR9LFxuXG5cdGNvbXB1dGVGcmVuZXRGcmFtZXM6IGZ1bmN0aW9uICggc2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcblxuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIHRhbmdlbnRzID0gW107XG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHR2YXIgYmlub3JtYWxzID0gW107XG5cblx0XHR2YXIgdmVjID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgbWF0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHZhciBpLCB1LCB0aGV0YTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdHUgPSBpIC8gc2VnbWVudHM7XG5cblx0XHRcdHRhbmdlbnRzWyBpIF0gPSB0aGlzLmdldFRhbmdlbnRBdCggdSApO1xuXHRcdFx0dGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcblxuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHR2YXIgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG5cdFx0dmFyIHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xuXHRcdHZhciB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuXHRcdGlmICggdHggPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eDtcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHkgPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eTtcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHogPD0gbWluICkge1xuXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cblx0XHR9XG5cblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cblxuXHRcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuXHRcdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuXHRcdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgLSAxIF0sIHRhbmdlbnRzWyBpIF0gKTtcblxuXHRcdFx0aWYgKCB2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHR2ZWMubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG5cdFx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxuXG5cdFx0aWYgKCBjbG9zZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoZXRhID0gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgc2VnbWVudHMgXSApLCAtIDEsIDEgKSApO1xuXHRcdFx0dGhldGEgLz0gc2VnbWVudHM7XG5cblx0XHRcdGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgc2VnbWVudHMgXSApICkgPiAwICkge1xuXG5cdFx0XHRcdHRoZXRhID0gLSB0aGV0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcblx0XHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhbmdlbnRzOiB0YW5nZW50cyxcblx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXG5cdFx0XHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xuXHRcdH07XG5cblx0fVxuXG59O1xuXG5mdW5jdGlvbiBMaW5lQ3VydmUoIHYxLCB2MiApIHtcblxuXHR0aGlzLnYxID0gdjE7XG5cdHRoaXMudjIgPSB2MjtcblxufVxuXG5MaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5MaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUN1cnZlO1xuXG5MaW5lQ3VydmUucHJvdG90eXBlLmlzTGluZUN1cnZlID0gdHJ1ZTtcblxuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy52Mi5jbG9uZSgpO1xuXG5cdH1cblxuXHR2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XG5cdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cblx0cmV0dXJuIHBvaW50O1xuXG59O1xuXG4vLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xuXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XG5cbn07XG5cbkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcblxuXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBDdXJ2ZVBhdGgoKSB7XG5cblx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxuXG59XG5cbkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBDdXJ2ZVBhdGgsXG5cblx0YWRkOiBmdW5jdGlvbiAoIGN1cnZlICkge1xuXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR9LFxuXG5cdGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXG5cdFx0dmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XG5cdFx0dmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG5cdFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xuXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgTGluZUN1cnZlKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHQvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cblx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuXHQvLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cblx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuXHQvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcblx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuXHRnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0dmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcblx0XHR2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHRcdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XG5cblx0XHRcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcblxuXHRcdFx0XHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcblx0XHRcdFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcblxuXHRcdFx0XHR2YXIgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0XHR2YXIgdSA9IHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogMSAtIGRpZmYgLyBzZWdtZW50TGVuZ3RoO1xuXG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aSArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdFx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG5cblx0fSxcblxuXHQvLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG5cdC8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxuXHQvLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdFx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xuXG5cdH0sXG5cblx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxuXHR1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IG51bGw7XG5cdFx0dGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0fSxcblxuXHQvLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cblx0Ly8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuXHRnZXRDdXJ2ZUxlbmd0aHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG5cdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0XHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcblx0XHRcdGxlbmd0aHMucHVzaCggc3VtcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG5cdFx0cmV0dXJuIGxlbmd0aHM7XG5cblx0fSxcblxuXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0aWYgKCBpc05hTiggZGl2aXNpb25zICkgKSBkaXZpc2lvbnMgPSA0MDtcblxuXHRcdHZhciBwb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkgKysgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50cztcblxuXHR9LFxuXG5cdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XG5cblx0XHR2YXIgcG9pbnRzID0gW10sIGxhc3Q7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzWyBpIF07XG5cdFx0XHR2YXIgcmVzb2x1dGlvbiA9IChjdXJ2ZSAmJiBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSkgPyBkaXZpc2lvbnMgKiAyXG5cdFx0XHRcdDogKGN1cnZlICYmIGN1cnZlLmlzTGluZUN1cnZlKSA/IDFcblx0XHRcdFx0OiAoY3VydmUgJiYgY3VydmUuaXNTcGxpbmVDdXJ2ZSkgPyBkaXZpc2lvbnMgKiBjdXJ2ZS5wb2ludHMubGVuZ3RoXG5cdFx0XHRcdDogZGl2aXNpb25zO1xuXG5cdFx0XHR2YXIgcHRzID0gY3VydmUuZ2V0UG9pbnRzKCByZXNvbHV0aW9uICk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKyApIHtcblxuXHRcdFx0XHR2YXIgcG9pbnQgPSBwdHNbIGogXTtcblxuXHRcdFx0XHRpZiAoIGxhc3QgJiYgbGFzdC5lcXVhbHMoIHBvaW50ICkgKSBjb250aW51ZTsgLy8gZW5zdXJlcyBubyBjb25zZWN1dGl2ZSBwb2ludHMgYXJlIGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRwb2ludHMucHVzaCggcG9pbnQgKTtcblx0XHRcdFx0bGFzdCA9IHBvaW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYXV0b0Nsb3NlICYmIHBvaW50cy5sZW5ndGggPiAxICYmICFwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fSxcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdENyZWF0ZSBHZW9tZXRyaWVzIEhlbHBlcnNcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdC8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcblxuXHRjcmVhdGVQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHR2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxuXHR9LFxuXG5cdC8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbnQgc2FtcGxpbmcgYWxvbmcgdGhlIHBhdGhcblxuXHRjcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApO1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxuXHR9LFxuXG5cdGNyZWF0ZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0fVxuXG59ICk7XG5cbmZ1bmN0aW9uIEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0dGhpcy5hWCA9IGFYO1xuXHR0aGlzLmFZID0gYVk7XG5cblx0dGhpcy54UmFkaXVzID0geFJhZGl1cztcblx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcblxuXHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xuXG5cdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG5cblx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb24gfHwgMDtcblxufVxuXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWxsaXBzZUN1cnZlO1xuXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcblxuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0dmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG5cdHZhciBzYW1lUG9pbnRzID0gTWF0aC5hYnMoIGRlbHRhQW5nbGUgKSA8IE51bWJlci5FUFNJTE9OO1xuXG5cdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuXHR3aGlsZSAoIGRlbHRhQW5nbGUgPCAwICkgZGVsdGFBbmdsZSArPSB0d29QaTtcblx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xuXG5cdGlmICggZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0aWYgKCBzYW1lUG9pbnRzICkge1xuXG5cdFx0XHRkZWx0YUFuZ2xlID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRlbHRhQW5nbGUgPSB0d29QaTtcblxuXHRcdH1cblxuXHR9XG5cblx0aWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgJiYgISBzYW1lUG9pbnRzICkge1xuXG5cdFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcblxuXHRcdFx0ZGVsdGFBbmdsZSA9IC0gdHdvUGk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR2YXIgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHR2YXIgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcblxuXHRcdHZhciB0eCA9IHggLSB0aGlzLmFYO1xuXHRcdHZhciB0eSA9IHkgLSB0aGlzLmFZO1xuXG5cdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHRcdHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy5hWDtcblx0XHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XG5cblx0fVxuXG5cdHJldHVybiBuZXcgVmVjdG9yMiggeCwgeSApO1xuXG59O1xuXG5mdW5jdGlvbiBTcGxpbmVDdXJ2ZSggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XG5cblx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxufVxuXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcblNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwbGluZUN1cnZlO1xuXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuaXNTcGxpbmVDdXJ2ZSA9IHRydWU7XG5cblNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XG5cblx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuXHR2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuXHR2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcblx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cblx0cmV0dXJuIG5ldyBWZWN0b3IyKFxuXHRcdENhdG11bGxSb20oIHdlaWdodCwgcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLnggKSxcblx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55IClcblx0KTtcblxufTtcblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiwgdjMgKSB7XG5cblx0dGhpcy52MCA9IHYwO1xuXHR0aGlzLnYxID0gdjE7XG5cdHRoaXMudjIgPSB2Mjtcblx0dGhpcy52MyA9IHYzO1xuXG59XG5cbkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmU7XG5cbkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XG5cblx0cmV0dXJuIG5ldyBWZWN0b3IyKFxuXHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXG5cdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxuXHQpO1xuXG59O1xuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiApIHtcblxuXHR0aGlzLnYwID0gdjA7XG5cdHRoaXMudjEgPSB2MTtcblx0dGhpcy52MiA9IHYyO1xuXG59XG5cblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XG5cblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcblxuXHRyZXR1cm4gbmV3IFZlY3RvcjIoXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55IClcblx0KTtcblxufTtcblxudmFyIFBhdGhQcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZVBhdGgucHJvdG90eXBlICksIHtcblxuXHRmcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cblx0XHR0aGlzLm1vdmVUbyggdmVjdG9yc1sgMCBdLngsIHZlY3RvcnNbIDAgXS55ICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMubGluZVRvKCB2ZWN0b3JzWyBpIF0ueCwgdmVjdG9yc1sgaSBdLnkgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7IC8vIFRPRE8gY29uc2lkZXIgcmVmZXJlbmNpbmcgdmVjdG9ycyBpbnN0ZWFkIG9mIGNvcHlpbmc/XG5cblx0fSxcblxuXHRsaW5lVG86IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBMaW5lQ3VydmUoIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKCB4LCB5ICkgKTtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0fSxcblxuXHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcblxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdH0sXG5cblx0YmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xuXG5cdFx0dmFyIGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUoXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdH0sXG5cblx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuXHRcdHZhciBucHRzID0gWyB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpIF0uY29uY2F0KCBwdHMgKTtcblxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZSggbnB0cyApO1xuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBwdHNbIHB0cy5sZW5ndGggLSAxIF0gKTtcblxuXHR9LFxuXG5cdGFyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHR2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xuXHRcdHZhciB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG5cblx0XHR0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcblx0XHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuXHR9LFxuXG5cdGFic2FyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdH0sXG5cblx0ZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuXHRcdHZhciB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblxuXHRcdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cblx0fSxcblxuXHRhYnNlbGxpcHNlOiBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG5cdFx0dmFyIGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuXHRcdGlmICggdGhpcy5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Ly8gaWYgYSBwcmV2aW91cyBjdXJ2ZSBpcyBwcmVzZW50LCBhdHRlbXB0IHRvIGpvaW5cblx0XHRcdHZhciBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcblxuXHRcdFx0aWYgKCAhIGZpcnN0UG9pbnQuZXF1YWxzKCB0aGlzLmN1cnJlbnRQb2ludCApICkge1xuXG5cdFx0XHRcdHRoaXMubGluZVRvKCBmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggbGFzdFBvaW50ICk7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXG4gKiovXG5cbmZ1bmN0aW9uIFBhdGgoIHBvaW50cyApIHtcblxuXHRDdXJ2ZVBhdGguY2FsbCggdGhpcyApO1xuXHR0aGlzLmN1cnJlbnRQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cblx0aWYgKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG5cdH1cblxufVxuXG5QYXRoLnByb3RvdHlwZSA9IFBhdGhQcm90b3R5cGU7XG5QYXRoUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGF0aDtcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG4gKiovXG5cbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cbmZ1bmN0aW9uIFNoYXBlKCkge1xuXG5cdFBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdHRoaXMuaG9sZXMgPSBbXTtcblxufVxuXG5TaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQYXRoUHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogU2hhcGUsXG5cblx0Z2V0UG9pbnRzSG9sZXM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0dmFyIGhvbGVzUHRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBob2xlc1B0cztcblxuXHR9LFxuXG5cdC8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG5cdGV4dHJhY3RBbGxQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcblx0XHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG5cdFx0fTtcblxuXHR9LFxuXG5cdGV4dHJhY3RQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyggZGl2aXNpb25zICk7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogbWluaW1hbCBjbGFzcyBmb3IgcHJveGluZyBmdW5jdGlvbnMgdG8gUGF0aC4gUmVwbGFjZXMgb2xkIFwiZXh0cmFjdFN1YnBhdGhzKClcIlxuICoqL1xuXG5mdW5jdGlvbiBTaGFwZVBhdGgoKSB7XG5cblx0dGhpcy5zdWJQYXRocyA9IFtdO1xuXHR0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblxufVxuXG5TaGFwZVBhdGgucHJvdG90eXBlID0ge1xuXG5cdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0dGhpcy5zdWJQYXRocy5wdXNoKCB0aGlzLmN1cnJlbnRQYXRoICk7XG5cdFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuXHR9LFxuXG5cdGxpbmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5saW5lVG8oIHgsIHkgKTtcblxuXHR9LFxuXG5cdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKTtcblxuXHR9LFxuXG5cdGJlemllckN1cnZlVG86IGZ1bmN0aW9uICggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcblxuXHRcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApO1xuXG5cdH0sXG5cblx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUoIHB0cyApO1xuXG5cdH0sXG5cblx0dG9TaGFwZXM6IGZ1bmN0aW9uICggaXNDQ1csIG5vSG9sZXMgKSB7XG5cblx0XHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XG5cblx0XHRcdHZhciBzaGFwZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG5cdFx0XHRcdHZhciB0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuXHRcdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcblxuXHRcdFx0dmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xuXG5cdFx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuXHRcdFx0Ly8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuXHRcdFx0Ly8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuXHRcdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcblx0XHRcdHZhciBpbnNpZGUgPSBmYWxzZTtcblx0XHRcdGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XG5cblx0XHRcdFx0dmFyIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHAgXTtcblx0XHRcdFx0dmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcblxuXHRcdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XG5cdFx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cdFx0XHRcdFx0aWYgKCBlZGdlRHkgPCAwICkge1xuXG5cdFx0XHRcdFx0XHRlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xuXHRcdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBpblB0LnkgPT09IGVkZ2VMb3dQdC55ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcblx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPT09IDAgKVx0XHRcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XHRcdC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcblx0XHRcdFx0XHRpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcblx0XHRcdFx0XHQvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcblx0XHRcdFx0XHRpZiAoICggKCBlZGdlSGlnaFB0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUxvd1B0LnggKSApIHx8XG5cdFx0XHRcdFx0XHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVx0XHRyZXR1cm5cdHRydWU7XHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuXHRpbnNpZGU7XG5cblx0XHR9XG5cblx0XHR2YXIgaXNDbG9ja1dpc2UgPSBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xuXG5cdFx0dmFyIHN1YlBhdGhzID0gdGhpcy5zdWJQYXRocztcblx0XHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuXHRcdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG5cdFx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XG5cblx0XHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XG5cdFx0XHR0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuXHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHRcdHJldHVybiBzaGFwZXM7XG5cblx0XHR9XG5cblx0XHR2YXIgaG9sZXNGaXJzdCA9ICEgaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcblx0XHRob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhIGhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xuXG5cdFx0Ly8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcblxuXHRcdHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG5cdFx0dmFyIG5ld1NoYXBlcyA9IFtdO1xuXHRcdHZhciBuZXdTaGFwZUhvbGVzID0gW107XG5cdFx0dmFyIG1haW5JZHggPSAwO1xuXHRcdHZhciB0bXBQb2ludHM7XG5cblx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcblx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xuXHRcdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcblx0XHRcdHNvbGlkID0gaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xuXHRcdFx0c29saWQgPSBpc0NDVyA/ICEgc29saWQgOiBzb2xpZDtcblxuXHRcdFx0aWYgKCBzb2xpZCApIHtcblxuXHRcdFx0XHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XG5cblx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB7IHM6IG5ldyBTaGFwZSgpLCBwOiB0bXBQb2ludHMgfTtcblx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0XHRpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcblx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY3cnLCBpKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuXHRcdGlmICggISBuZXdTaGFwZXNbIDAgXSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG5cdFx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0dmFyIGFtYmlndW91cyA9IGZhbHNlO1xuXHRcdFx0dmFyIHRvQ2hhbmdlID0gW107XG5cblx0XHRcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHRcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGhJZHggPSAwOyBoSWR4IDwgc2hvLmxlbmd0aDsgaElkeCArKyApIHtcblxuXHRcdFx0XHRcdHZhciBobyA9IHNob1sgaElkeCBdO1xuXHRcdFx0XHRcdHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNJZHggIT09IHMySWR4IClcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0YW1iaWd1b3VzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuXHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XG5cdFx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJ0byBjaGFuZ2U6IFwiLCB0b0NoYW5nZSk7XG5cdFx0XHRcdGlmICggISBhbWJpZ3VvdXMgKVx0bmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciB0bXBIb2xlcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXHRcdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIEZvbnQoIGRhdGEgKSB7XG5cblx0dGhpcy5kYXRhID0gZGF0YTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBGb250LnByb3RvdHlwZSwge1xuXG5cdGlzRm9udDogdHJ1ZSxcblxuXHRnZW5lcmF0ZVNoYXBlczogZnVuY3Rpb24gKCB0ZXh0LCBzaXplLCBkaXZpc2lvbnMgKSB7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVQYXRocyggdGV4dCApIHtcblxuXHRcdFx0dmFyIGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICk7XG5cdFx0XHR2YXIgc2NhbGUgPSBzaXplIC8gZGF0YS5yZXNvbHV0aW9uO1xuXHRcdFx0dmFyIGxpbmVfaGVpZ2h0ID0gKCBkYXRhLmJvdW5kaW5nQm94LnlNYXggLSBkYXRhLmJvdW5kaW5nQm94LnlNaW4gKyBkYXRhLnVuZGVybGluZVRoaWNrbmVzcyApICogc2NhbGU7XG5cblx0XHRcdHZhciBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDA7XG5cblx0XHRcdHZhciBwYXRocyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoYXIgPSBjaGFyc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hhciA9PT0gJ1xcbicgKSB7XG5cblx0XHRcdFx0XHRvZmZzZXRYID0gMDtcblx0XHRcdFx0XHRvZmZzZXRZIC09IGxpbmVfaGVpZ2h0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgcmV0ID0gY3JlYXRlUGF0aCggY2hhciwgc2NhbGUsIG9mZnNldFgsIG9mZnNldFkgKTtcblx0XHRcdFx0XHRvZmZzZXRYICs9IHJldC5vZmZzZXRYO1xuXHRcdFx0XHRcdHBhdGhzLnB1c2goIHJldC5wYXRoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXRocztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoIGMsIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZICkge1xuXG5cdFx0XHR2YXIgZ2x5cGggPSBkYXRhLmdseXBoc1sgYyBdIHx8IGRhdGEuZ2x5cGhzWyAnPycgXTtcblxuXHRcdFx0aWYgKCAhIGdseXBoICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblxuXHRcdFx0dmFyIHB0cyA9IFtdO1xuXHRcdFx0dmFyIHgsIHksIGNweCwgY3B5LCBjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBsYXN0ZTtcblxuXHRcdFx0aWYgKCBnbHlwaC5vICkge1xuXG5cdFx0XHRcdHZhciBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb3V0bGluZS5sZW5ndGg7IGkgPCBsOyApIHtcblxuXHRcdFx0XHRcdHZhciBhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBhY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ20nOiAvLyBtb3ZlVG9cblxuXHRcdFx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXG5cdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2wnOiAvLyBsaW5lVG9cblxuXHRcdFx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCB4LCB5ICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvXG5cblx0XHRcdFx0XHRcdFx0Y3B4ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcblx0XHRcdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcblx0XHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcblx0XHRcdFx0XHRcdFx0Y3B5MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGNweDEsIGNweTEsIGNweCwgY3B5ICk7XG5cblx0XHRcdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkyID0gMTsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcblx0XHRcdFx0XHRcdFx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYic6IC8vIGJlemllckN1cnZlVG9cblxuXHRcdFx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0XHRjcHkgID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXHRcdFx0XHRcdFx0XHRjcHgxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXHRcdFx0XHRcdFx0XHRjcHgyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0XHRjcHkyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgY3B4LCBjcHkgKTtcblxuXHRcdFx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XG5cdFx0XHRcdFx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaTIgPSAxOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xuXHRcdFx0XHRcdFx0XHRcdFx0Q3ViaWNCZXppZXIoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Q3ViaWNCZXppZXIoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgb2Zmc2V0WDogZ2x5cGguaGEgKiBzY2FsZSwgcGF0aDogcGF0aCB9O1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDEwMDtcblx0XHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNDtcblxuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG5cdFx0dmFyIHBhdGhzID0gY3JlYXRlUGF0aHMoIHRleHQgKTtcblx0XHR2YXIgc2hhcGVzID0gW107XG5cblx0XHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYXBlcztcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIEZvbnRMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggRm9udExvYWRlci5wcm90b3R5cGUsIHtcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR2YXIganNvbjtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Gb250TG9hZGVyOiB0eXBlZmFjZS5qcyBzdXBwb3J0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSB0eXBlZmFjZS5qc29uIGluc3RlYWQuJyApO1xuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZSggdGV4dC5zdWJzdHJpbmcoIDY1LCB0ZXh0Lmxlbmd0aCAtIDIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBmb250ID0gc2NvcGUucGFyc2UoIGpzb24gKTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGZvbnQgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHRyZXR1cm4gbmV3IEZvbnQoIGpzb24gKTtcblxuXHR9XG5cbn0gKTtcblxudmFyIGNvbnRleHQ7XG5cbnZhciBBdWRpb0NvbnRleHQgPSB7XG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCBjb250ZXh0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnRleHQ7XG5cblx0fSxcblxuXHRzZXRDb250ZXh0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0Y29udGV4dCA9IHZhbHVlO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIFJlZWNlIEFhcm9uIExlY3JpdmFpbiAvIGh0dHA6Ly9yZWVjZW5vdGVzLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBBdWRpb0xvYWRlciggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufVxuXG5PYmplY3QuYXNzaWduKCBBdWRpb0xvYWRlci5wcm90b3R5cGUsIHtcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdHZhciBjb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcblxuXHRcdFx0Y29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIGJ1ZmZlciwgZnVuY3Rpb24gKCBhdWRpb0J1ZmZlciApIHtcblxuXHRcdFx0XHRvbkxvYWQoIGF1ZGlvQnVmZmVyICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gUmVjdEFyZWFMaWdodCAoIGNvbG9yLCBpbnRlbnNpdHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdHRoaXMudHlwZSA9ICdSZWN0QXJlYUxpZ2h0JztcblxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xuXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdHRoaXMud2lkdGggPSAoIHdpZHRoICE9PSB1bmRlZmluZWQgKSA/IHdpZHRoIDogMTA7XG5cdHRoaXMuaGVpZ2h0ID0gKCBoZWlnaHQgIT09IHVuZGVmaW5lZCApID8gaGVpZ2h0IDogMTA7XG5cblx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IGRpc3RhbmNlL2RlY2F5XG5cblx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHVwZGF0ZSBtZXRob2QgZm9yIFJlY3RBcmVhTGlnaHQgdG8gdXBkYXRlIHRyYW5zZm9ybSB0byBsb29rYXQgdGFyZ2V0XG5cblx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHNoYWRvd3Ncblx0Ly8gdGhpcy5zaGFkb3cgPSBuZXcgVEhSRUUuUmVjdEFyZWFMaWdodFNoYWRvdyggbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCA5MCwgMSwgMC41LCA1MDAgKSApO1xuXG59XG5cbi8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IHVwZGF0ZSB3aGVuIGxpZ2h0IHNoYXBlIGlzIGNoYW5nZWRcblJlY3RBcmVhTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogUmVjdEFyZWFMaWdodCxcblxuXHRpc1JlY3RBcmVhTGlnaHQ6IHRydWUsXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXG5cdFx0Ly8gdGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFN0ZXJlb0NhbWVyYSgpIHtcblxuXHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcblxuXHR0aGlzLmFzcGVjdCA9IDE7XG5cblx0dGhpcy5leWVTZXAgPSAwLjA2NDtcblxuXHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0dGhpcy5jYW1lcmFMLmxheWVycy5lbmFibGUoIDEgKTtcblx0dGhpcy5jYW1lcmFMLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLmNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0dGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcblx0dGhpcy5jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBTdGVyZW9DYW1lcmEucHJvdG90eXBlLCB7XG5cblx0dXBkYXRlOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBpbnN0YW5jZSwgZm9jdXMsIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIHpvb207XG5cblx0XHR2YXIgZXllUmlnaHQgPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBleWVMZWZ0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcblxuXHRcdFx0dmFyIG5lZWRzVXBkYXRlID0gaW5zdGFuY2UgIT09IHRoaXMgfHwgZm9jdXMgIT09IGNhbWVyYS5mb2N1cyB8fCBmb3YgIT09IGNhbWVyYS5mb3YgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0IHx8IG5lYXIgIT09IGNhbWVyYS5uZWFyIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmYXIgIT09IGNhbWVyYS5mYXIgfHwgem9vbSAhPT0gY2FtZXJhLnpvb207XG5cblx0XHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xuXHRcdFx0XHRmb2N1cyA9IGNhbWVyYS5mb2N1cztcblx0XHRcdFx0Zm92ID0gY2FtZXJhLmZvdjtcblx0XHRcdFx0YXNwZWN0ID0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0O1xuXHRcdFx0XHRuZWFyID0gY2FtZXJhLm5lYXI7XG5cdFx0XHRcdGZhciA9IGNhbWVyYS5mYXI7XG5cdFx0XHRcdHpvb20gPSBjYW1lcmEuem9vbTtcblxuXHRcdFx0XHQvLyBPZmYtYXhpcyBzdGVyZW9zY29waWMgZWZmZWN0IGJhc2VkIG9uXG5cdFx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXG5cblx0XHRcdFx0dmFyIHByb2plY3Rpb25NYXRyaXggPSBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpO1xuXHRcdFx0XHR2YXIgZXllU2VwID0gdGhpcy5leWVTZXAgLyAyO1xuXHRcdFx0XHR2YXIgZXllU2VwT25Qcm9qZWN0aW9uID0gZXllU2VwICogbmVhciAvIGZvY3VzO1xuXHRcdFx0XHR2YXIgeW1heCA9ICggbmVhciAqIE1hdGgudGFuKCBfTWF0aC5ERUcyUkFEICogZm92ICogMC41ICkgKSAvIHpvb207XG5cdFx0XHRcdHZhciB4bWluLCB4bWF4O1xuXG5cdFx0XHRcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XG5cblx0XHRcdFx0ZXllTGVmdC5lbGVtZW50c1sgMTIgXSA9IC0gZXllU2VwO1xuXHRcdFx0XHRleWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcDtcblxuXHRcdFx0XHQvLyBmb3IgbGVmdCBleWVcblxuXHRcdFx0XHR4bWluID0gLSB5bWF4ICogYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xuXHRcdFx0XHR4bWF4ID0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblxuXHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF0gPSAyICogbmVhciAvICggeG1heCAtIHhtaW4gKTtcblx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xuXG5cdFx0XHRcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0XHQvLyBmb3IgcmlnaHQgZXllXG5cblx0XHRcdFx0eG1pbiA9IC0geW1heCAqIGFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cblx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMCBdID0gMiAqIG5lYXIgLyAoIHhtYXggLSB4bWluICk7XG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcblxuXHRcdFx0XHR0aGlzLmNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBwcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVMZWZ0ICk7XG5cdFx0XHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZVJpZ2h0ICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpXG5cbn0gKTtcblxuLyoqXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcbiAqXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuZnVuY3Rpb24gQ3ViZUNhbWVyYSggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xuXG5cdHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcblxuXHR2YXIgY2FtZXJhUFggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0Y2FtZXJhUFgubG9va0F0KCBuZXcgVmVjdG9yMyggMSwgMCwgMCApICk7XG5cdHRoaXMuYWRkKCBjYW1lcmFQWCApO1xuXG5cdHZhciBjYW1lcmFOWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRjYW1lcmFOWC51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRjYW1lcmFOWC5sb29rQXQoIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuXHR2YXIgY2FtZXJhUFkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XG5cdGNhbWVyYVBZLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhUFkgKTtcblxuXHR2YXIgY2FtZXJhTlkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcblx0Y2FtZXJhTlkubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgLSAxLCAwICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYU5ZICk7XG5cblx0dmFyIGNhbWVyYVBaID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdGNhbWVyYVBaLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuXHR2YXIgY2FtZXJhTlogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0Y2FtZXJhTloubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgMCwgLSAxICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XG5cblx0dmFyIG9wdGlvbnMgPSB7IGZvcm1hdDogUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IExpbmVhckZpbHRlciwgbWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIgfTtcblxuXHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgb3B0aW9ucyApO1xuXG5cdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcblx0XHR2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcblxuXHR9O1xuXG59XG5cbkN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG5DdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmVDYW1lcmE7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBBdWRpb0xpc3RlbmVyKCkge1xuXG5cdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XG5cblx0dGhpcy5jb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcblxuXHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cblx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG59XG5cbkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogQXVkaW9MaXN0ZW5lcixcblxuXHRnZXRJbnB1dDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2FpbjtcblxuXHR9LFxuXG5cdHJlbW92ZUZpbHRlcjogZnVuY3Rpb24gKCApIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cdFx0XHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cdFx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cblx0XHR9XG5cblx0fSxcblxuXHRnZXRGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcjtcblxuXHR9LFxuXG5cdHNldEZpbHRlcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdH0sXG5cblx0Z2V0TWFzdGVyVm9sdW1lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cblx0fSxcblxuXHRzZXRNYXN0ZXJWb2x1bWU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciBvcmllbnRhdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0XHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHRcdFx0dmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xuXHRcdFx0dmFyIHVwID0gdGhpcy51cDtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG5cdFx0XHRvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRpZiAoIGxpc3RlbmVyLnBvc2l0aW9uWCApIHtcblxuXHRcdFx0XHRsaXN0ZW5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRsaXN0ZW5lci5wb3NpdGlvblkuc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRsaXN0ZW5lci5wb3NpdGlvblouc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRsaXN0ZW5lci5mb3J3YXJkWC5zZXRWYWx1ZUF0VGltZSggb3JpZW50YXRpb24ueCwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XG5cdFx0XHRcdGxpc3RlbmVyLmZvcndhcmRZLnNldFZhbHVlQXRUaW1lKCBvcmllbnRhdGlvbi55LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcblx0XHRcdFx0bGlzdGVuZXIuZm9yd2FyZFouc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRsaXN0ZW5lci51cFguc2V0VmFsdWVBdFRpbWUoIHVwLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRsaXN0ZW5lci51cFkuc2V0VmFsdWVBdFRpbWUoIHVwLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRsaXN0ZW5lci51cFouc2V0VmFsdWVBdFRpbWUoIHVwLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cdFx0XHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCB1cC54LCB1cC55LCB1cC56ICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKClcblxufSApO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFJlZWNlIEFhcm9uIExlY3JpdmFpbiAvIGh0dHA6Ly9yZWVjZW5vdGVzLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBBdWRpbyggbGlzdGVuZXIgKSB7XG5cblx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cblx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcblxuXHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xuXG5cdHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcblxuXHR0aGlzLmJ1ZmZlciA9IG51bGw7XG5cdHRoaXMubG9vcCA9IGZhbHNlO1xuXHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdHRoaXMucGxheWJhY2tSYXRlID0gMTtcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuXHR0aGlzLnNvdXJjZVR5cGUgPSAnZW1wdHknO1xuXG5cdHRoaXMuZmlsdGVycyA9IFtdO1xuXG59XG5cbkF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IEF1ZGlvLFxuXG5cdGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2FpbjtcblxuXHR9LFxuXG5cdHNldE5vZGVTb3VyY2U6IGZ1bmN0aW9uICggYXVkaW9Ob2RlICkge1xuXG5cdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcblx0XHR0aGlzLnNvdXJjZSA9IGF1ZGlvTm9kZTtcblx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0QnVmZmVyOiBmdW5jdGlvbiAoIGF1ZGlvQnVmZmVyICkge1xuXG5cdFx0dGhpcy5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcblxuXHRcdGlmICggdGhpcy5hdXRvcGxheSApIHRoaXMucGxheSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRwbGF5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXG5cdFx0c291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuXHRcdHNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xuXHRcdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcblx0XHRzb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKCB0aGlzLnBsYXliYWNrUmF0ZSwgdGhpcy5zdGFydFRpbWUgKTtcblx0XHRzb3VyY2Uuc3RhcnQoIDAsIHRoaXMuc3RhcnRUaW1lICk7XG5cblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cblx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuXHRcdHJldHVybiB0aGlzLmNvbm5lY3QoKTtcblxuXHR9LFxuXG5cdHBhdXNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldEZpbHRlcnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcnM7XG5cblx0fSxcblxuXHRzZXRGaWx0ZXJzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCAhIHZhbHVlICkgdmFsdWUgPSBbXTtcblxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuZGlzY29ubmVjdCgpO1xuXHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWU7XG5cdFx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEZpbHRlcnMoKVsgMCBdO1xuXG5cdH0sXG5cblx0c2V0RmlsdGVyOiBmdW5jdGlvbiAoIGZpbHRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZpbHRlcnMoIGZpbHRlciA/IFsgZmlsdGVyIF0gOiBbXSApO1xuXG5cdH0sXG5cblx0c2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoIHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG5cblx0fSxcblxuXHRvbkVuZGVkOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdH0sXG5cblx0Z2V0TG9vcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmxvb3A7XG5cblx0fSxcblxuXHRzZXRMb29wOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMubG9vcCA9IHZhbHVlO1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0Vm9sdW1lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cblx0fSxcblxuXG5cdHNldFZvbHVtZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbmZ1bmN0aW9uIFBvc2l0aW9uYWxBdWRpbyggbGlzdGVuZXIgKSB7XG5cblx0QXVkaW8uY2FsbCggdGhpcywgbGlzdGVuZXIgKTtcblxuXHR0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcblx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XG5cbn1cblxuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEF1ZGlvLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFBvc2l0aW9uYWxBdWRpbyxcblxuXHRnZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBhbm5lcjtcblxuXHR9LFxuXG5cdGdldFJlZkRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cblx0fSxcblxuXHRzZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XG5cblx0fSxcblxuXHRnZXRSb2xsb2ZmRmFjdG9yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcblxuXHR9LFxuXG5cdHNldFJvbGxvZmZGYWN0b3I6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG5cblx0fSxcblxuXHRnZXREaXN0YW5jZU1vZGVsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcblxuXHR9LFxuXG5cdHNldERpc3RhbmNlTW9kZWw6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG5cblx0fSxcblxuXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuXG5cdH0sXG5cblx0c2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG5cdFx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy5wYW5uZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcblxuXHRcdH07XG5cblx0fSApKClcblxuXG59ICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBBdWRpb0FuYWx5c2VyKCBhdWRpbywgZmZ0U2l6ZSApIHtcblxuXHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHR0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBmZnRTaXplICE9PSB1bmRlZmluZWQgPyBmZnRTaXplIDogMjA0ODtcblxuXHR0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSggdGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCApO1xuXG5cdGF1ZGlvLmdldE91dHB1dCgpLmNvbm5lY3QoIHRoaXMuYW5hbHlzZXIgKTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBBdWRpb0FuYWx5c2VyLnByb3RvdHlwZSwge1xuXG5cdGdldEZyZXF1ZW5jeURhdGE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoIHRoaXMuZGF0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YTtcblxuXHR9LFxuXG5cdGdldEF2ZXJhZ2VGcmVxdWVuY3k6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2YWx1ZSA9IDAsIGRhdGEgPSB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YWx1ZSArPSBkYXRhWyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWUgLyBkYXRhLmxlbmd0aDtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKlxuICogQnVmZmVyZWQgc2NlbmUgZ3JhcGggcHJvcGVydHkgdGhhdCBhbGxvd3Mgd2VpZ2h0ZWQgYWNjdW11bGF0aW9uLlxuICpcbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuZnVuY3Rpb24gUHJvcGVydHlNaXhlciggYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSApIHtcblxuXHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXHR0aGlzLnZhbHVlU2l6ZSA9IHZhbHVlU2l6ZTtcblxuXHR2YXIgYnVmZmVyVHlwZSA9IEZsb2F0NjRBcnJheSxcblx0XHRtaXhGdW5jdGlvbjtcblxuXHRzd2l0Y2ggKCB0eXBlTmFtZSApIHtcblxuXHRcdGNhc2UgJ3F1YXRlcm5pb24nOlxuXHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zbGVycDtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRjYXNlICdib29sJzpcblx0XHRcdGJ1ZmZlclR5cGUgPSBBcnJheTtcblx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2VsZWN0O1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXG5cdH1cblxuXHR0aGlzLmJ1ZmZlciA9IG5ldyBidWZmZXJUeXBlKCB2YWx1ZVNpemUgKiA0ICk7XG5cdC8vIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIF1cblx0Ly9cblx0Ly8gaW50ZXJwb2xhdG9ycyBjYW4gdXNlIC5idWZmZXIgYXMgdGhlaXIgLnJlc3VsdFxuXHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xuXHQvL1xuXHQvLyAnYWNjdTAnIGFuZCAnYWNjdTEnIGFyZSB1c2VkIGZyYW1lLWludGVybGVhdmVkIGZvclxuXHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3Rcblx0Ly8gY2hhbmdlc1xuXHQvL1xuXHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcblxuXHR0aGlzLl9taXhCdWZmZXJSZWdpb24gPSBtaXhGdW5jdGlvbjtcblxuXHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXG5cdHRoaXMudXNlQ291bnQgPSAwO1xuXHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcblxufVxuXG5Qcm9wZXJ0eU1peGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogUHJvcGVydHlNaXhlcixcblxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXG5cdGFjY3VtdWxhdGU6IGZ1bmN0aW9uKCBhY2N1SW5kZXgsIHdlaWdodCApIHtcblxuXHRcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXG5cdFx0Ly8gdGhlIHdlaWdodCBhbmQgc2hvdWxkbid0IGhhdmUgbWFkZSB0aGUgY2FsbCBpbiB0aGUgZmlyc3QgcGxhY2VcblxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXG5cdFx0XHRjdXJyZW50V2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0O1xuXG5cdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xuXG5cdFx0XHQvLyBhY2N1TiA6PSBpbmNvbWluZyAqIHdlaWdodFxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIGluY29taW5nICogd2VpZ2h0XG5cblx0XHRcdGN1cnJlbnRXZWlnaHQgKz0gd2VpZ2h0O1xuXHRcdFx0dmFyIG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcblxuXHR9LFxuXG5cdC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcblx0YXBwbHk6IGZ1bmN0aW9uKCBhY2N1SW5kZXggKSB7XG5cblx0XHR2YXIgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcblxuXHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuXHRcdGlmICggd2VpZ2h0IDwgMSApIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBvcmlnaW5hbCAqICggMSAtIGN1bXVsYXRpdmVXZWlnaHQgKVxuXG5cdFx0XHR2YXIgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIDM7XG5cblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcblx0XHRcdFx0XHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IHN0cmlkZSArIHN0cmlkZTsgaSAhPT0gZTsgKysgaSApIHtcblxuXHRcdFx0aWYgKCBidWZmZXJbIGkgXSAhPT0gYnVmZmVyWyBpICsgc3RyaWRlIF0gKSB7XG5cblx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZSggYnVmZmVyLCBvZmZzZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdC8vIHJlbWVtYmVyIHRoZSBzdGF0ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkgYW5kIGNvcHkgaXQgdG8gYm90aCBhY2N1c1xuXHRzYXZlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZztcblxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcblxuXHRcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xuXG5cdFx0Ly8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuXHRcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcblxuXHRcdFx0YnVmZmVyWyBpIF0gPSBidWZmZXJbIG9yaWdpbmFsVmFsdWVPZmZzZXQgKyAoIGkgJSBzdHJpZGUgKSBdO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuXHR9LFxuXG5cdC8vIGFwcGx5IHRoZSBzdGF0ZSBwcmV2aW91c2x5IHRha2VuIHZpYSAnc2F2ZU9yaWdpbmFsU3RhdGUnIHRvIHRoZSBiaW5kaW5nXG5cdHJlc3RvcmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gdGhpcy52YWx1ZVNpemUgKiAzO1xuXHRcdHRoaXMuYmluZGluZy5zZXRWYWx1ZSggdGhpcy5idWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcblxuXHR9LFxuXG5cblx0Ly8gbWl4IGZ1bmN0aW9uc1xuXG5cdF9zZWxlY3Q6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cblx0XHRpZiAoIHQgPj0gMC41ICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0XHRidWZmZXJbIGRzdE9mZnNldCArIGkgXSA9IGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRfc2xlcnA6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cblx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggYnVmZmVyLCBkc3RPZmZzZXQsXG5cdFx0XHRcdGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCwgdCApO1xuXG5cdH0sXG5cblx0X2xlcnA6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cblx0XHR2YXIgcyA9IDEgLSB0O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBqID0gZHN0T2Zmc2V0ICsgaTtcblxuXHRcdFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSAqIHMgKyBidWZmZXJbIHNyY09mZnNldCArIGkgXSAqIHQ7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vKipcbiAqXG4gKiBBIHJlZmVyZW5jZSB0byBhIHJlYWwgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuZnVuY3Rpb24gUHJvcGVydHlCaW5kaW5nKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcblxuXHR0aGlzLnBhdGggPSBwYXRoO1xuXHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8XG5cdFx0XHRQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHR0aGlzLm5vZGUgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoXG5cdFx0XHRyb290Tm9kZSwgdGhpcy5wYXJzZWRQYXRoLm5vZGVOYW1lICkgfHwgcm9vdE5vZGU7XG5cblx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuXG59XG5cblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFByb3BlcnR5QmluZGluZyxcblxuXHRnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVfdW5ib3VuZCggdGFyZ2V0QXJyYXksIG9mZnNldCApIHtcblxuXHRcdHRoaXMuYmluZCgpO1xuXHRcdHRoaXMuZ2V0VmFsdWUoIHRhcmdldEFycmF5LCBvZmZzZXQgKTtcblxuXHRcdC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxuXHRcdC8vICdiaW5kJyBzZXRzICd0aGlzLmdldFZhbHVlJyAvICdzZXRWYWx1ZScgYW5kIHNoYWRvd3MgdGhlXG5cdFx0Ly8gcHJvdG90eXBlIHZlcnNpb24gb2YgdGhlc2UgbWV0aG9kcyB3aXRoIG9uZSB0aGF0IHJlcHJlc2VudHNcblx0XHQvLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcblx0XHQvLyBiZWNvbWUgbm8tb3BzLlxuXG5cdH0sXG5cblx0c2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHNvdXJjZUFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmJpbmQoKTtcblx0XHR0aGlzLnNldFZhbHVlKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICk7XG5cblx0fSxcblxuXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXG5cdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZSxcblx0XHRcdHBhcnNlZFBhdGggPSB0aGlzLnBhcnNlZFBhdGgsXG5cblx0XHRcdG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWUsXG5cdFx0XHRwcm9wZXJ0eU5hbWUgPSBwYXJzZWRQYXRoLnByb3BlcnR5TmFtZSxcblx0XHRcdHByb3BlcnR5SW5kZXggPSBwYXJzZWRQYXRoLnByb3BlcnR5SW5kZXg7XG5cblx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXG5cdFx0XHR0YXJnZXRPYmplY3QgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoXG5cdFx0XHRcdFx0dGhpcy5yb290Tm9kZSwgcGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHRoaXMucm9vdE5vZGU7XG5cblx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcblxuXHRcdH1cblxuXHRcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcblxuIFx0XHQvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXG5cdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byB1cGRhdGUgbm9kZSBmb3IgdHJhY2s6IFwiICsgdGhpcy5wYXRoICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIiApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3ROYW1lICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0SW5kZXggPSBwYXJzZWRQYXRoLm9iamVjdEluZGV4O1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXG5cdFx0XHRzd2l0Y2ggKCBvYmplY3ROYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwnLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXknLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYm9uZXMnOlxuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5za2VsZXRvbiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxuXHRcdFx0XHRcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcblxuXHRcdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgaSBdLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdEluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUsIHVuZGVmaW5lZCcsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKCBvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZDpcIiwgdGhpcywgdGFyZ2V0T2JqZWN0ICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHJlc29sdmUgcHJvcGVydHlcblx0XHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcblxuXHRcdGlmICggbm9kZVByb3BlcnR5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBub2RlTmFtZSA9IHBhcnNlZFBhdGgubm9kZU5hbWU7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogXCIgKyBub2RlTmFtZSArXG5cdFx0XHRcdFx0Jy4nICsgcHJvcGVydHlOYW1lICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIiwgdGFyZ2V0T2JqZWN0ICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyBkZXRlcm1pbmUgdmVyc2lvbmluZyBzY2hlbWVcblx0XHR2YXIgdmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5Ob25lO1xuXG5cdFx0aWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcblxuXHRcdFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5OZWVkc1VwZGF0ZTtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xuXG5cdFx0fSBlbHNlIGlmICggdGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbm9kZSB0cmFuc2Zvcm1cblxuXHRcdFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5NYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XG5cblx0XHR9XG5cblx0XHQvLyBkZXRlcm1pbmUgaG93IHRoZSBwcm9wZXJ0eSBnZXRzIGJvdW5kXG5cdFx0dmFyIGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5EaXJlY3Q7XG5cblx0XHRpZiAoIHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIGFjY2VzcyBhIHN1YiBlbGVtZW50IG9mIHRoZSBwcm9wZXJ0eSBhcnJheSAob25seSBwcmltaXRpdmVzIGFyZSBzdXBwb3J0ZWQgcmlnaHQgbm93KVxuXG5cdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiApIHtcblx0XHRcdFx0Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cblx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxuXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeScsIHRoaXMgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaFRhcmdldHMnLCB0aGlzICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGUuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPT09IHByb3BlcnR5SW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XG5cblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkuZnJvbUFycmF5ICE9PSB1bmRlZmluZWQgJiYgbm9kZVByb3BlcnR5LnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cblxuXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkhhc0Zyb21Ub0FycmF5O1xuXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheTtcblxuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuR2V0dGVyQnlCaW5kaW5nVHlwZVsgYmluZGluZ1R5cGUgXTtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1sgYmluZGluZ1R5cGUgXVsgdmVyc2lvbmluZyBdO1xuXG5cdH0sXG5cblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMubm9kZSA9IG51bGw7XG5cblx0XHQvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXG5cdFx0Ly8gbm90ZTogYXZvaWRpbmcgdG8gbXV0YXRlIHRoZSBzaGFwZSBvZiAndGhpcycgdmlhICdkZWxldGUnXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cblx0fVxuXG59O1xuXG5PYmplY3QuYXNzaWduKCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLCB7IC8vIHByb3RvdHlwZSwgY29udGludWVkXG5cblx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxuXHRfZ2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uKCkge30sXG5cdF9zZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBpbml0aWFsIHN0YXRlIG9mIHRoZXNlIG1ldGhvZHMgdGhhdCBjYWxscyAnYmluZCdcblx0X2dldFZhbHVlX3VuYm91bmQ6IFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuZ2V0VmFsdWUsXG5cdF9zZXRWYWx1ZV91bmJvdW5kOiBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlLFxuXG5cdEJpbmRpbmdUeXBlOiB7XG5cdFx0RGlyZWN0OiAwLFxuXHRcdEVudGlyZUFycmF5OiAxLFxuXHRcdEFycmF5RWxlbWVudDogMixcblx0XHRIYXNGcm9tVG9BcnJheTogM1xuXHR9LFxuXG5cdFZlcnNpb25pbmc6IHtcblx0XHROb25lOiAwLFxuXHRcdE5lZWRzVXBkYXRlOiAxLFxuXHRcdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcblx0fSxcblxuXHRHZXR0ZXJCeUJpbmRpbmdUeXBlOiBbXG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdO1xuXG5cdFx0fSxcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArKyBdID0gc291cmNlWyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcblxuXHRcdH0sXG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV90b0FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0XSxcblxuXHRTZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZzogW1xuXG5cdFx0W1xuXHRcdFx0Ly8gRGlyZWN0XG5cblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH0sXG5cblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XSwgW1xuXG5cdFx0XHQvLyBFbnRpcmVBcnJheVxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRdLCBbXG5cblx0XHRcdC8vIEFycmF5RWxlbWVudFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH0sXG5cblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdF0sIFtcblxuXHRcdFx0Ly8gSGFzVG9Gcm9tQXJyYXlcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRdXG5cblx0XVxuXG59ICk7XG5cblByb3BlcnR5QmluZGluZy5Db21wb3NpdGUgPVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoICkge1xuXG5cdHZhciBwYXJzZWRQYXRoID0gb3B0aW9uYWxQYXJzZWRQYXRoIHx8XG5cdFx0XHRQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHR0aGlzLl90YXJnZXRHcm91cCA9IHRhcmdldEdyb3VwO1xuXHR0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKTtcblxufTtcblxuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUsXG5cblx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcblxuXHRcdHZhciBmaXJzdFZhbGlkSW5kZXggPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbIGZpcnN0VmFsaWRJbmRleCBdO1xuXG5cdFx0Ly8gYW5kIG9ubHkgY2FsbCAuZ2V0VmFsdWUgb24gdGhlIGZpcnN0XG5cdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0fSxcblxuXHRzZXRWYWx1ZTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRiaW5kaW5nc1sgaSBdLnNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRiaW5kOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRcdG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uYmluZCgpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRcdG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0udW5iaW5kKCk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5Qcm9wZXJ0eUJpbmRpbmcuY3JlYXRlID0gZnVuY3Rpb24oIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cblx0aWYgKCAhICggcm9vdCAmJiByb290LmlzQW5pbWF0aW9uT2JqZWN0R3JvdXAgKSApIHtcblxuXHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG5cdH1cblxufTtcblxuUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lID0gZnVuY3Rpb24oIHRyYWNrTmFtZSApIHtcblxuXHQvLyBtYXRjaGVzIHN0cmluZ3MgaW4gdGhlIGZvcm0gb2Y6XG5cdC8vICAgIG5vZGVOYW1lLnByb3BlcnR5XG5cdC8vICAgIG5vZGVOYW1lLnByb3BlcnR5W2FjY2Vzc29yXVxuXHQvLyAgICBub2RlTmFtZS5tYXRlcmlhbC5wcm9wZXJ0eVthY2Nlc3Nvcl1cblx0Ly8gICAgdXVpZC5wcm9wZXJ0eVthY2Nlc3Nvcl1cblx0Ly8gICAgdXVpZC5vYmplY3ROYW1lW29iamVjdEluZGV4XS5wcm9wZXJ0eU5hbWVbcHJvcGVydHlJbmRleF1cblx0Ly8gICAgcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVxuXHQvLyAgICBwYXJlbnROYW1lL3BhcmVudE5hbWUvbm9kZU5hbWUucHJvcGVydHlbaW5kZXhdXG5cdC8vICAgIC5ib25lW0FybWF0dXJlLkRFRl9jb2ddLnBvc2l0aW9uXG5cdC8vICAgIHNjZW5lOmhlbGl1bV9iYWxsb29uX21vZGVsOmhlbGl1bV9iYWxsb29uX21vZGVsLnBvc2l0aW9uXG5cdC8vIGNyZWF0ZWQgYW5kIHRlc3RlZCB2aWEgaHR0cHM6Ly9yZWdleDEwMS5jb20vI2phdmFzY3JpcHRcblxuXHR2YXIgcmUgPSAvXigoPzpbXFx3LV0rW1xcLzpdKSopKFtcXHctXSspPyg/OlxcLihbXFx3LV0rKSg/OlxcWyguKylcXF0pPyk/XFwuKFtcXHctXSspKD86XFxbKC4rKVxcXSk/JC87XG5cdHZhciBtYXRjaGVzID0gcmUuZXhlYyggdHJhY2tOYW1lICk7XG5cblx0aWYgKCAhIG1hdGNoZXMgKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2Fubm90IHBhcnNlIHRyYWNrTmFtZSBhdCBhbGw6IFwiICsgdHJhY2tOYW1lICk7XG5cblx0fVxuXG5cdHZhciByZXN1bHRzID0ge1xuXHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbIDEgXSwgLy8gKHRzY2h3KSBjdXJyZW50bHkgdW51c2VkXG5cdFx0bm9kZU5hbWU6IG1hdGNoZXNbIDIgXSwgXHQvLyBhbGxvd2VkIHRvIGJlIG51bGwsIHNwZWNpZmllZCByb290IG5vZGUuXG5cdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1sgMyBdLFxuXHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWyA0IF0sXG5cdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWyA1IF0sXG5cdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sgNiBdXHQvLyBhbGxvd2VkIHRvIGJlIG51bGwsIHNwZWNpZmllcyB0aGF0IHRoZSB3aG9sZSBwcm9wZXJ0eSBpcyBzZXQuXG5cdH07XG5cblx0aWYgKCByZXN1bHRzLnByb3BlcnR5TmFtZSA9PT0gbnVsbCB8fCByZXN1bHRzLnByb3BlcnR5TmFtZS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6IFwiICsgdHJhY2tOYW1lICk7XG5cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xuXG59O1xuXG5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUgPSBmdW5jdGlvbiggcm9vdCwgbm9kZU5hbWUgKSB7XG5cblx0aWYgKCAhIG5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSBcIlwiIHx8IG5vZGVOYW1lID09PSBcInJvb3RcIiB8fCBub2RlTmFtZSA9PT0gXCIuXCIgfHwgbm9kZU5hbWUgPT09IC0xIHx8IG5vZGVOYW1lID09PSByb290Lm5hbWUgfHwgbm9kZU5hbWUgPT09IHJvb3QudXVpZCApIHtcblxuXHRcdHJldHVybiByb290O1xuXG5cdH1cblxuXHQvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cblx0aWYgKCByb290LnNrZWxldG9uICkge1xuXG5cdFx0dmFyIHNlYXJjaFNrZWxldG9uID0gZnVuY3Rpb24oIHNrZWxldG9uICkge1xuXG5cdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHNrZWxldG9uLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBib25lLm5hbWUgPT09IG5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH07XG5cblx0XHR2YXIgYm9uZSA9IHNlYXJjaFNrZWxldG9uKCByb290LnNrZWxldG9uICk7XG5cblx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0fVxuXHR9XG5cblx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxuXHRpZiAoIHJvb3QuY2hpbGRyZW4gKSB7XG5cblx0XHR2YXIgc2VhcmNoTm9kZVN1YnRyZWUgPSBmdW5jdGlvbiggY2hpbGRyZW4gKSB7XG5cblx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciByZXN1bHQgPSBzZWFyY2hOb2RlU3VidHJlZSggY2hpbGROb2RlLmNoaWxkcmVuICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fTtcblxuXHRcdHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XG5cblx0XHRpZiAoIHN1YlRyZWVOb2RlICkge1xuXG5cdFx0XHRyZXR1cm4gc3ViVHJlZU5vZGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBudWxsO1xuXG59O1xuXG4vKipcbiAqXG4gKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogXHQtXHRBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxuICogXHRcdGNvbnN0cnVjdG9yIG9yIHRoZSAuY2xpcEFjdGlvbiBtZXRob2Qgb2YgQW5pbWF0aW9uTWl4ZXIuXG4gKlxuICogXHQtXHRJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxuICpcbiAqIFx0LVx0WW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcbiAqIFx0XHRpcyBydW5uaW5nLlxuICpcbiAqIE5vdGU6XG4gKlxuICogIFx0T2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcbiAqICBcdHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcbiAqICBcdG9uIHRoZSBncm91cC5cbiAqXG4gKiBMaW1pdGF0aW9uOlxuICpcbiAqIFx0LSBcdFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcbiAqIFx0XHRhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXG4gKlxuICogIC1cdEEgc2luZ2xlIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgY29udHJvbGxlZCB0aHJvdWdoIGFcbiAqICBcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxuICpcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5mdW5jdGlvbiBBbmltYXRpb25PYmplY3RHcm91cCggdmFyX2FyZ3MgKSB7XG5cblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0Ly8gY2FjaGVkIG9iamVjdHMgZm9sbG93ZWQgYnkgdGhlIGFjdGl2ZSBvbmVzXG5cdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cblx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSAwO1x0XHRcdC8vIHRocmVzaG9sZFxuXHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcblxuXHR2YXIgaW5kaWNlcyA9IHt9O1xuXHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlcztcdFx0Ly8gZm9yIGJvb2trZWVwaW5nXG5cblx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdGluZGljZXNbIGFyZ3VtZW50c1sgaSBdLnV1aWQgXSA9IGk7XG5cblx0fVxuXG5cdHRoaXMuX3BhdGhzID0gW107XHRcdFx0XHRcdC8vIGluc2lkZTogc3RyaW5nXG5cdHRoaXMuX3BhcnNlZFBhdGhzID0gW107XHRcdFx0XHQvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XG5cdHRoaXMuX2JpbmRpbmdzID0gW107IFx0XHRcdFx0Ly8gaW5zaWRlOiBBcnJheTwgUHJvcGVydHlCaW5kaW5nID5cblx0dGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoID0ge307IFx0Ly8gaW5zaWRlOiBpbmRpY2VzIGluIHRoZXNlIGFycmF5c1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dGhpcy5zdGF0cyA9IHtcblxuXHRcdG9iamVjdHM6IHtcblx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDsgfSxcblx0XHRcdGdldCBpblVzZSgpIHsgcmV0dXJuIHRoaXMudG90YWwgLSBzY29wZS5uQ2FjaGVkT2JqZWN0c187ICB9XG5cdFx0fSxcblxuXHRcdGdldCBiaW5kaW5nc1Blck9iamVjdCgpIHsgcmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7IH1cblxuXHR9O1xuXG59XG5cbkFuaW1hdGlvbk9iamVjdEdyb3VwLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogQW5pbWF0aW9uT2JqZWN0R3JvdXAsXG5cblx0aXNBbmltYXRpb25PYmplY3RHcm91cDogdHJ1ZSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcblxuXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF0sXG5cdFx0XHRcdGtub3duT2JqZWN0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gdW5rbm93biBvYmplY3QgLT4gYWRkIGl0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cblx0XHRcdFx0aW5kZXggPSBuT2JqZWN0cyArKztcblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdGJpbmRpbmdzWyBqIF0ucHVzaChcblx0XHRcdFx0XHRcdFx0bmV3IFByb3BlcnR5QmluZGluZyhcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRrbm93bk9iamVjdCA9IG9iamVjdHNbIGluZGV4IF07XG5cblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cblxuXHRcdFx0XHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcblx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XG5cblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBsYXN0Q2FjaGVkO1xuXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHNpbmNlIHdlIGRvIG5vdCBib3RoZXIgdG8gY3JlYXRlIG5ldyBiaW5kaW5nc1xuXHRcdFx0XHRcdFx0Ly8gZm9yIG9iamVjdHMgdGhhdCBhcmUgY2FjaGVkLCB0aGUgYmluZGluZyBtYXlcblx0XHRcdFx0XHRcdC8vIG9yIG1heSBub3QgZXhpc3RcblxuXHRcdFx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEIFwiICtcblx0XHRcdFx0XHRcdFwiZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBcIiArXG5cdFx0XHRcdFx0XHRcImluZnJhc3RydWN0dXJlIHdoZW4gcmVsb2FkaW5nIHNjZW5lcy4uLlwiICk7XG5cblx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxuXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggdmFyX2FyZ3MgKSB7XG5cblx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMgKSB7XG5cblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxuXG5cdFx0XHRcdHZhciBsYXN0Q2FjaGVkSW5kZXggPSBuQ2FjaGVkT2JqZWN0cyArKyxcblx0XHRcdFx0XHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdO1xuXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIGZpcnN0QWN0aXZlT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gZmlyc3RBY3RpdmVPYmplY3Q7XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gbGFzdENhY2hlZEluZGV4O1xuXHRcdFx0XHRvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXSA9IG9iamVjdDtcblxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRmaXJzdEFjdGl2ZSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0sXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gZmlyc3RBY3RpdmU7XG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG5cblx0fSxcblxuXHQvLyByZW1vdmUgJiBmb3JnZXRcblx0dW5jYWNoZTogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xuXG5cdFx0dmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcblx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxuXG5cdFx0XHRcdFx0dmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLSBuQ2FjaGVkT2JqZWN0cyxcblx0XHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0sXG5cdFx0XHRcdFx0XHRsYXN0SW5kZXggPSAtLSBuT2JqZWN0cyxcblx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcblxuXHRcdFx0XHRcdC8vIGxhc3QgY2FjaGVkIG9iamVjdCB0YWtlcyB0aGlzIG9iamVjdCdzIHBsYWNlXG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcblxuXHRcdFx0XHRcdC8vIGxhc3Qgb2JqZWN0IGdvZXMgdG8gdGhlIGFjdGl2YXRlZCBzbG90IGFuZCBwb3Bcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdE9iamVjdDtcblx0XHRcdFx0XHRvYmplY3RzLnBvcCgpO1xuXG5cdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcblx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxuXHRcdFx0XHRcdFx0XHRsYXN0ID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdDtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGFjdGl2ZSwganVzdCBzd2FwIHdpdGggdGhlIGxhc3QgYW5kIHBvcFxuXG5cdFx0XHRcdFx0dmFyIGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdE9iamVjdDtcblx0XHRcdFx0XHRvYmplY3RzLnBvcCgpO1xuXG5cdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblxuXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cblxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuXHR9LFxuXG5cdC8vIEludGVybmFsIGludGVyZmFjZSB1c2VkIGJ5IGJlZnJpZW5kZWQgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZTpcblxuXHRzdWJzY3JpYmVfOiBmdW5jdGlvbiggcGF0aCwgcGFyc2VkUGF0aCApIHtcblx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxuXG5cdFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXG5cdFx0XHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXSxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYmluZGluZ3NbIGluZGV4IF07XG5cblx0XHR2YXIgcGF0aHMgPSB0aGlzLl9wYXRocyxcblx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXG5cdFx0XHRvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0YmluZGluZ3NGb3JQYXRoID0gbmV3IEFycmF5KCBuT2JqZWN0cyApO1xuXG5cdFx0aW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRpbmRpY2VzQnlQYXRoWyBwYXRoIF0gPSBpbmRleDtcblxuXHRcdHBhdGhzLnB1c2goIHBhdGggKTtcblx0XHRwYXJzZWRQYXRocy5wdXNoKCBwYXJzZWRQYXRoICk7XG5cdFx0YmluZGluZ3MucHVzaCggYmluZGluZ3NGb3JQYXRoICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRuID0gb2JqZWN0cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHZhciBvYmplY3QgPSBvYmplY3RzWyBpIF07XG5cblx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaSBdID1cblx0XHRcdFx0XHRuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBiaW5kaW5nc0ZvclBhdGg7XG5cblx0fSxcblxuXHR1bnN1YnNjcmliZV86IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRcdC8vIHRlbGxzIHRoZSBncm91cCB0byBmb3JnZXQgYWJvdXQgYSBwcm9wZXJ0eSBwYXRoIGFuZCBubyBsb25nZXJcblx0XHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcblxuXHRcdHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxuXHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XG5cblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzWyBsYXN0QmluZGluZ3NJbmRleCBdLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcblxuXHRcdFx0aW5kaWNlc0J5UGF0aFsgbGFzdEJpbmRpbmdzUGF0aCBdID0gaW5kZXg7XG5cblx0XHRcdGJpbmRpbmdzWyBpbmRleCBdID0gbGFzdEJpbmRpbmdzO1xuXHRcdFx0YmluZGluZ3MucG9wKCk7XG5cblx0XHRcdHBhcnNlZFBhdGhzWyBpbmRleCBdID0gcGFyc2VkUGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XG5cdFx0XHRwYXJzZWRQYXRocy5wb3AoKTtcblxuXHRcdFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcblx0XHRcdHBhdGhzLnBvcCgpO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuLyoqXG4gKlxuICogQWN0aW9uIHByb3ZpZGVkIGJ5IEFuaW1hdGlvbk1peGVyIGZvciBzY2hlZHVsaW5nIGNsaXAgcGxheWJhY2sgb24gc3BlY2lmaWNcbiAqIG9iamVjdHMuXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICogQGF1dGhvciB0c2Nod1xuICpcbiAqL1xuXG5mdW5jdGlvbiBBbmltYXRpb25BY3Rpb24oIG1peGVyLCBjbGlwLCBsb2NhbFJvb3QgKSB7XG5cblx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcblx0dGhpcy5fY2xpcCA9IGNsaXA7XG5cdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdCB8fCBudWxsO1xuXG5cdHZhciB0cmFja3MgPSBjbGlwLnRyYWNrcyxcblx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHR2YXIgaW50ZXJwb2xhbnRTZXR0aW5ncyA9IHtcblx0XHRcdGVuZGluZ1N0YXJ0OiBcdFplcm9DdXJ2YXR1cmVFbmRpbmcsXG5cdFx0XHRlbmRpbmdFbmQ6XHRcdFplcm9DdXJ2YXR1cmVFbmRpbmdcblx0fTtcblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cblx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0cmFja3NbIGkgXS5jcmVhdGVJbnRlcnBvbGFudCggbnVsbCApO1xuXHRcdGludGVycG9sYW50c1sgaSBdID0gaW50ZXJwb2xhbnQ7XG5cdFx0aW50ZXJwb2xhbnQuc2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xuXG5cdH1cblxuXHR0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcblxuXHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7XHQvLyBib3VuZCBieSB0aGUgbWl4ZXJcblxuXHQvLyBpbnNpZGU6IFByb3BlcnR5TWl4ZXIgKG1hbmFnZWQgYnkgdGhlIG1peGVyKVxuXHR0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzID0gbmV3IEFycmF5KCBuVHJhY2tzICk7XG5cblx0dGhpcy5fY2FjaGVJbmRleCA9IG51bGw7XHRcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXHR0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXG5cdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXG5cdHRoaXMubG9vcCA9IExvb3BSZXBlYXQ7XG5cdHRoaXMuX2xvb3BDb3VudCA9IC0xO1xuXG5cdC8vIGdsb2JhbCBtaXhlciB0aW1lIHdoZW4gdGhlIGFjdGlvbiBpcyB0byBiZSBzdGFydGVkXG5cdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxuXHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdC8vIHNjYWxlZCBsb2NhbCB0aW1lIG9mIHRoZSBhY3Rpb25cblx0Ly8gZ2V0cyBjbGFtcGVkIG9yIHdyYXBwZWQgdG8gMC4uY2xpcC5kdXJhdGlvbiBhY2NvcmRpbmcgdG8gbG9vcFxuXHR0aGlzLnRpbWUgPSAwO1xuXG5cdHRoaXMudGltZVNjYWxlID0gMTtcblx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gMTtcblxuXHR0aGlzLndlaWdodCA9IDE7XG5cdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG5cblx0dGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5OyBcdFx0Ly8gbm8uIG9mIHJlcGV0aXRpb25zIHdoZW4gbG9vcGluZ1xuXG5cdHRoaXMucGF1c2VkID0gZmFsc2U7XHRcdFx0XHQvLyBmYWxzZSAtPiB6ZXJvIGVmZmVjdGl2ZSB0aW1lIHNjYWxlXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XHRcdFx0XHQvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxuXG5cdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgXHQ9IGZhbHNlO1x0Ly8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xuXG5cdHRoaXMuemVyb1Nsb3BlQXRTdGFydCBcdD0gdHJ1ZTtcdFx0Ly8gZm9yIHNtb290aCBpbnRlcnBvbGF0aW9uIHcvbyBzZXBhcmF0ZVxuXHR0aGlzLnplcm9TbG9wZUF0RW5kXHRcdD0gdHJ1ZTtcdFx0Ly8gY2xpcHMgZm9yIHN0YXJ0LCBsb29wIGFuZCBlbmRcblxufVxuXG5BbmltYXRpb25BY3Rpb24ucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBBbmltYXRpb25BY3Rpb24sXG5cblx0Ly8gU3RhdGUgJiBTY2hlZHVsaW5nXG5cblx0cGxheTogZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLl9taXhlci5fZGVhY3RpdmF0ZUFjdGlvbiggdGhpcyApO1xuXG5cdFx0cmV0dXJuIHRoaXMucmVzZXQoKTtcblxuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdHRoaXMudGltZSA9IDA7XHRcdFx0Ly8gcmVzdGFydCBjbGlwXG5cdFx0dGhpcy5fbG9vcENvdW50ID0gLTE7XHQvLyBmb3JnZXQgcHJldmlvdXMgbG9vcHNcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1x0Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xuXG5cdH0sXG5cblx0aXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLmVuYWJsZWQgJiYgISB0aGlzLnBhdXNlZCAmJiB0aGlzLnRpbWVTY2FsZSAhPT0gMCAmJlxuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPT09IG51bGwgJiYgdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XG5cblx0fSxcblxuXHQvLyByZXR1cm4gdHJ1ZSB3aGVuIHBsYXkgaGFzIGJlZW4gY2FsbGVkXG5cdGlzU2NoZWR1bGVkOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuXHR9LFxuXG5cdHN0YXJ0QXQ6IGZ1bmN0aW9uKCB0aW1lICkge1xuXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0TG9vcDogZnVuY3Rpb24oIG1vZGUsIHJlcGV0aXRpb25zICkge1xuXG5cdFx0dGhpcy5sb29wID0gbW9kZTtcblx0XHR0aGlzLnJlcGV0aXRpb25zID0gcmVwZXRpdGlvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdC8vIFdlaWdodFxuXG5cdC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXG5cdC8vIGFsdGhvdWdoIC5lbmFibGVkID0gZmFsc2UgeWllbGRzIGFuIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgemVybywgdGhpc1xuXHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLmVuYWJsZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXG5cdHNldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24oIHdlaWdodCApIHtcblxuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0Ly8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XG5cblx0XHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCk7XG5cblx0fSxcblxuXHQvLyByZXR1cm4gdGhlIHdlaWdodCBjb25zaWRlcmluZyBmYWRpbmcgYW5kIC5lbmFibGVkXG5cdGdldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlV2VpZ2h0O1xuXG5cdH0sXG5cblx0ZmFkZUluOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAwLCAxICk7XG5cblx0fSxcblxuXHRmYWRlT3V0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAxLCAwICk7XG5cblx0fSxcblxuXHRjcm9zc0ZhZGVGcm9tOiBmdW5jdGlvbiggZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XG5cblx0XHRmYWRlT3V0QWN0aW9uLmZhZGVPdXQoIGR1cmF0aW9uICk7XG5cdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XG5cblx0XHRpZiggd2FycCApIHtcblxuXHRcdFx0dmFyIGZhZGVJbkR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcblx0XHRcdFx0ZmFkZU91dER1cmF0aW9uID0gZmFkZU91dEFjdGlvbi5fY2xpcC5kdXJhdGlvbixcblxuXHRcdFx0XHRzdGFydEVuZFJhdGlvID0gZmFkZU91dER1cmF0aW9uIC8gZmFkZUluRHVyYXRpb24sXG5cdFx0XHRcdGVuZFN0YXJ0UmF0aW8gPSBmYWRlSW5EdXJhdGlvbiAvIGZhZGVPdXREdXJhdGlvbjtcblxuXHRcdFx0ZmFkZU91dEFjdGlvbi53YXJwKCAxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uICk7XG5cdFx0XHR0aGlzLndhcnAoIGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y3Jvc3NGYWRlVG86IGZ1bmN0aW9uKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG5cdFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKCB0aGlzLCBkdXJhdGlvbiwgd2FycCApO1xuXG5cdH0sXG5cblx0c3RvcEZhZGluZzogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdGlmICggd2VpZ2h0SW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcblx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggd2VpZ2h0SW50ZXJwb2xhbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Ly8gVGltZSBTY2FsZSBDb250cm9sXG5cblx0Ly8gc2V0IHRoZSB3ZWlnaHQgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCB3YXJwaW5nXG5cdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXG5cdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAucGF1c2VkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXHRzZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCB0aW1lU2NhbGUgKSB7XG5cblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOnRpbWVTY2FsZTtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0fSxcblxuXHQvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxuXHRnZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcblxuXHR9LFxuXG5cdHNldER1cmF0aW9uOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0fSxcblxuXHRzeW5jV2l0aDogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdHRoaXMudGltZSA9IGFjdGlvbi50aW1lO1xuXHRcdHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0fSxcblxuXHRoYWx0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy53YXJwKCB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUsIDAsIGR1cmF0aW9uICk7XG5cblx0fSxcblxuXHR3YXJwOiBmdW5jdGlvbiggc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XG5cblx0XHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcblx0XHRcdGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQsXG5cblx0XHRcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xuXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcblxuXHRcdH1cblxuXHRcdHZhciB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcblx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblxuXHRcdHRpbWVzWyAwIF0gPSBub3c7XG5cdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1xuXG5cdFx0dmFsdWVzWyAwIF0gPSBzdGFydFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblx0XHR2YWx1ZXNbIDEgXSA9IGVuZFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3RvcFdhcnBpbmc6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRpbWVTY2FsZUludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cblx0XHRpZiAoIHRpbWVTY2FsZUludGVycG9sYW50ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG5cdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHRpbWVTY2FsZUludGVycG9sYW50ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdC8vIE9iamVjdCBBY2Nlc3NvcnNcblxuXHRnZXRNaXhlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XG5cblx0fSxcblxuXHRnZXRDbGlwOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9jbGlwO1xuXG5cdH0sXG5cblx0Z2V0Um9vdDogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbG9jYWxSb290IHx8IHRoaXMuX21peGVyLl9yb290O1xuXG5cdH0sXG5cblx0Ly8gSW50ZXJuYVxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcblx0XHQvLyBjYWxsZWQgYnkgdGhlIG1peGVyXG5cblx0XHR2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lO1xuXG5cdFx0aWYgKCBzdGFydFRpbWUgIT09IG51bGwgKSB7XG5cblx0XHRcdC8vIGNoZWNrIGZvciBzY2hlZHVsZWQgc3RhcnQgb2YgYWN0aW9uXG5cblx0XHRcdHZhciB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcblx0XHRcdGlmICggdGltZVJ1bm5pbmcgPCAwIHx8IHRpbWVEaXJlY3Rpb24gPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuOyAvLyB5ZXQgdG8gY29tZSAvIGRvbid0IGRlY2lkZSB3aGVuIGRlbHRhID0gMFxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0XG5cblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcblx0XHRcdGRlbHRhVGltZSA9IHRpbWVEaXJlY3Rpb24gKiB0aW1lUnVubmluZztcblxuXHRcdH1cblxuXHRcdC8vIGFwcGx5IHRpbWUgc2NhbGUgYW5kIGFkdmFuY2UgdGltZVxuXG5cdFx0ZGVsdGFUaW1lICo9IHRoaXMuX3VwZGF0ZVRpbWVTY2FsZSggdGltZSApO1xuXHRcdHZhciBjbGlwVGltZSA9IHRoaXMuX3VwZGF0ZVRpbWUoIGRlbHRhVGltZSApO1xuXG5cdFx0Ly8gbm90ZTogX3VwZGF0ZVRpbWUgbWF5IGRpc2FibGUgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW5cblx0XHQvLyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIDBcblxuXHRcdHZhciB3ZWlnaHQgPSB0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcblxuXHRcdGlmICggd2VpZ2h0ID4gMCApIHtcblxuXHRcdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2ludGVycG9sYW50cztcblx0XHRcdHZhciBwcm9wZXJ0eU1peGVycyA9IHRoaXMuX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0aW50ZXJwb2xhbnRzWyBqIF0uZXZhbHVhdGUoIGNsaXBUaW1lICk7XG5cdFx0XHRcdHByb3BlcnR5TWl4ZXJzWyBqIF0uYWNjdW11bGF0ZSggYWNjdUluZGV4LCB3ZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0X3VwZGF0ZVdlaWdodDogZnVuY3Rpb24oIHRpbWUgKSB7XG5cblx0XHR2YXIgd2VpZ2h0ID0gMDtcblxuXHRcdGlmICggdGhpcy5lbmFibGVkICkge1xuXG5cdFx0XHR3ZWlnaHQgPSB0aGlzLndlaWdodDtcblx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0XHRpZiAoIGludGVycG9sYW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xuXG5cdFx0XHRcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG5cdFx0XHRcdGlmICggdGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sgMSBdICkge1xuXG5cdFx0XHRcdFx0dGhpcy5zdG9wRmFkaW5nKCk7XG5cblx0XHRcdFx0XHRpZiAoIGludGVycG9sYW50VmFsdWUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGZhZGVkIG91dCwgZGlzYWJsZVxuXHRcdFx0XHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0cmV0dXJuIHdlaWdodDtcblxuXHR9LFxuXG5cdF91cGRhdGVUaW1lU2NhbGU6IGZ1bmN0aW9uKCB0aW1lICkge1xuXG5cdFx0dmFyIHRpbWVTY2FsZSA9IDA7XG5cblx0XHRpZiAoICEgdGhpcy5wYXVzZWQgKSB7XG5cblx0XHRcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xuXG5cdFx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR2YXIgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHR0aW1lU2NhbGUgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHRcdFx0XHRcdGlmICggdGltZVNjYWxlID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2Vcblx0XHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcblx0XHRcdFx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdHJldHVybiB0aW1lU2NhbGU7XG5cblx0fSxcblxuXHRfdXBkYXRlVGltZTogZnVuY3Rpb24oIGRlbHRhVGltZSApIHtcblxuXHRcdHZhciB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xuXG5cdFx0aWYgKCBkZWx0YVRpbWUgPT09IDAgKSByZXR1cm4gdGltZTtcblxuXHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXG5cblx0XHRcdGxvb3AgPSB0aGlzLmxvb3AsXG5cdFx0XHRsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQ7XG5cblx0XHRpZiAoIGxvb3AgPT09IExvb3BPbmNlICkge1xuXG5cdFx0XHRpZiAoIGxvb3BDb3VudCA9PT0gLTEgKSB7XG5cdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXG5cdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IDA7XG5cdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIHRydWUsIHRydWUsIGZhbHNlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aGFuZGxlX3N0b3A6IHtcblxuXHRcdFx0XHRpZiAoIHRpbWUgPj0gZHVyYXRpb24gKSB7XG5cblx0XHRcdFx0XHR0aW1lID0gZHVyYXRpb247XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGltZSA8IDAgKSB7XG5cblx0XHRcdFx0XHR0aW1lID0gMDtcblxuXHRcdFx0XHR9IGVsc2UgYnJlYWsgaGFuZGxlX3N0b3A7XG5cblx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPCAwID8gLTEgOiAxXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHsgLy8gcmVwZXRpdGl2ZSBSZXBlYXQgb3IgUGluZ1BvbmdcblxuXHRcdFx0dmFyIHBpbmdQb25nID0gKCBsb29wID09PSBMb29wUGluZ1BvbmcgKTtcblxuXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0xICkge1xuXHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcblxuXHRcdFx0XHRpZiAoIGRlbHRhVGltZSA+PSAwICkge1xuXG5cdFx0XHRcdFx0bG9vcENvdW50ID0gMDtcblxuXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoXG5cdFx0XHRcdFx0XHRcdHRydWUsIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHBpbmdQb25nICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcblx0XHRcdFx0XHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxuXHRcdFx0XHRcdC8vIHNvIGxlYXZlIGxvb3BDb3VudCBhdCAtMVxuXG5cdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyhcblx0XHRcdFx0XHRcdFx0dGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwICkge1xuXHRcdFx0XHQvLyB3cmFwIGFyb3VuZFxuXG5cdFx0XHRcdHZhciBsb29wRGVsdGEgPSBNYXRoLmZsb29yKCB0aW1lIC8gZHVyYXRpb24gKTsgLy8gc2lnbmVkXG5cdFx0XHRcdHRpbWUgLT0gZHVyYXRpb24gKiBsb29wRGVsdGE7XG5cblx0XHRcdFx0bG9vcENvdW50ICs9IE1hdGguYWJzKCBsb29wRGVsdGEgKTtcblxuXHRcdFx0XHR2YXIgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XG5cblx0XHRcdFx0aWYgKCBwZW5kaW5nIDwgMCApIHtcblx0XHRcdFx0XHQvLyBoYXZlIHRvIHN0b3AgKHN3aXRjaCBzdGF0ZSwgY2xhbXAgdGltZSwgZmlyZSBldmVudClcblxuXHRcdFx0XHRcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XG5cblx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA+IDAgPyAxIDogLTFcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBrZWVwIHJ1bm5pbmdcblxuXHRcdFx0XHRcdGlmICggcGVuZGluZyA9PT0gMCApIHtcblx0XHRcdFx0XHRcdC8vIGVudGVyaW5nIHRoZSBsYXN0IHJvdW5kXG5cblx0XHRcdFx0XHRcdHZhciBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGZhbHNlLCBmYWxzZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcblxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6IGxvb3BEZWx0YVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApIHtcblx0XHRcdFx0Ly8gaW52ZXJ0IHRpbWUgZm9yIHRoZSBcInBvbmcgcm91bmRcIlxuXG5cdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0XHRcdHJldHVybiBkdXJhdGlvbiAtIHRpbWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0cmV0dXJuIHRpbWU7XG5cblx0fSxcblxuXHRfc2V0RW5kaW5nczogZnVuY3Rpb24oIGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZyApIHtcblxuXHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHRpZiAoIHBpbmdQb25nICkge1xuXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCBcdD0gWmVyb1Nsb3BlRW5kaW5nO1xuXHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kXHRcdD0gWmVyb1Nsb3BlRW5kaW5nO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYXNzdW1pbmcgZm9yIExvb3BPbmNlIGF0U3RhcnQgPT0gYXRFbmQgPT0gdHJ1ZVxuXG5cdFx0XHRpZiAoIGF0U3RhcnQgKSB7XG5cblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgP1xuXHRcdFx0XHRcdFx0WmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdEVuZCApIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID9cblx0XHRcdFx0XHRcdFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kIFx0ID0gV3JhcEFyb3VuZEVuZGluZztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0X3NjaGVkdWxlRmFkaW5nOiBmdW5jdGlvbiggZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbiApIHtcblxuXHRcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxuXHRcdFx0aW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cblx0XHR9XG5cblx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XG5cblx0XHR0aW1lc1sgMCBdID0gbm93OyBcdFx0XHRcdHZhbHVlc1sgMCBdID0gd2VpZ2h0Tm93O1xuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcdHZhbHVlc1sgMSBdID0gd2VpZ2h0VGhlbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKlxuICogUGxheWVyIGZvciBBbmltYXRpb25DbGlwcy5cbiAqXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICogQGF1dGhvciB0c2Nod1xuICovXG5cbmZ1bmN0aW9uIEFuaW1hdGlvbk1peGVyKCByb290ICkge1xuXG5cdHRoaXMuX3Jvb3QgPSByb290O1xuXHR0aGlzLl9pbml0TWVtb3J5TWFuYWdlcigpO1xuXHR0aGlzLl9hY2N1SW5kZXggPSAwO1xuXG5cdHRoaXMudGltZSA9IDA7XG5cblx0dGhpcy50aW1lU2NhbGUgPSAxLjA7XG5cbn1cblxuQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBBbmltYXRpb25NaXhlcixcblxuXHQvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxuXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcblx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXG5cdGNsaXBBY3Rpb246IGZ1bmN0aW9uICggY2xpcCwgb3B0aW9uYWxSb290ICkge1xuXG5cdFx0dmFyIHJvb3QgPSBvcHRpb25hbFJvb3QgfHwgdGhpcy5fcm9vdCxcblx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXG5cdFx0XHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRBbmltYXRpb25DbGlwLmZpbmRCeU5hbWUoIHJvb3QsIGNsaXAgKSA6IGNsaXAsXG5cblx0XHRcdGNsaXBVdWlkID0gY2xpcE9iamVjdCAhPT0gbnVsbCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXAsXG5cblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcblx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IG51bGw7XG5cblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBleGlzdGluZ0FjdGlvbiA9XG5cdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRpZiAoIGV4aXN0aW5nQWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGtub3cgdGhlIGNsaXAsIHNvIHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgYWxsXG5cdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcblx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xuXG5cdFx0XHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cblx0XHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApXG5cdFx0XHRcdGNsaXBPYmplY3QgPSBwcm90b3R5cGVBY3Rpb24uX2NsaXA7XG5cblx0XHR9XG5cblx0XHQvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuXHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdFx0Ly8gYWxsb2NhdGUgYWxsIHJlc291cmNlcyByZXF1aXJlZCB0byBydW4gaXRcblx0XHR2YXIgbmV3QWN0aW9uID0gbmV3IEFuaW1hdGlvbkFjdGlvbiggdGhpcywgY2xpcE9iamVjdCwgb3B0aW9uYWxSb290ICk7XG5cblx0XHR0aGlzLl9iaW5kQWN0aW9uKCBuZXdBY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApO1xuXG5cdFx0Ly8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcblx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggbmV3QWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKTtcblxuXHRcdHJldHVybiBuZXdBY3Rpb247XG5cblx0fSxcblxuXHQvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG5cdGV4aXN0aW5nQWN0aW9uOiBmdW5jdGlvbiAoIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcblxuXHRcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblxuXHRcdFx0Y2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFx0QW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKCByb290LCBjbGlwICkgOiBjbGlwLFxuXG5cdFx0XHRjbGlwVXVpZCA9IGNsaXBPYmplY3QgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwLFxuXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gfHwgbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH0sXG5cblx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcblx0c3RvcEFsbEFjdGlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XG5cblx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XG5cdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkFjdGlvbnM7ICsrIGkgKSB7XG5cblx0XHRcdGFjdGlvbnNbIGkgXS5yZXNldCgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0udXNlQ291bnQgPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvLyBhZHZhbmNlIHRoZSB0aW1lIGFuZCB1cGRhdGUgYXBwbHkgdGhlIGFuaW1hdGlvblxuXHR1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGFUaW1lICkge1xuXG5cdFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblxuXHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXG5cdFx0XHR0aW1lRGlyZWN0aW9uID0gTWF0aC5zaWduKCBkZWx0YVRpbWUgKSxcblxuXHRcdFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7XG5cblx0XHQvLyBydW4gYWN0aXZlIGFjdGlvbnNcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkFjdGlvbnM7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XG5cblx0XHRcdGlmICggYWN0aW9uLmVuYWJsZWQgKSB7XG5cblx0XHRcdFx0YWN0aW9uLl91cGRhdGUoIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcblxuXHRcdFx0YmluZGluZ3NbIGkgXS5hcHBseSggYWNjdUluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdC8vIHJldHVybiB0aGlzIG1peGVyJ3Mgcm9vdCB0YXJnZXQgb2JqZWN0XG5cdGdldFJvb3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9yb290O1xuXG5cdH0sXG5cblx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXG5cdHVuY2FjaGVDbGlwOiBmdW5jdGlvbiAoIGNsaXAgKSB7XG5cblx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRjbGlwVXVpZCA9IGNsaXAudXVpZCxcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBub3RlOiBqdXN0IGNhbGxpbmcgX3JlbW92ZUluYWN0aXZlQWN0aW9uIHdvdWxkIG1lc3MgdXAgdGhlXG5cdFx0XHQvLyBpdGVyYXRpb24gc3RhdGUgYW5kIGFsc28gcmVxdWlyZSB1cGRhdGluZyB0aGUgc3RhdGUgd2UgY2FuXG5cdFx0XHQvLyBqdXN0IHRocm93IGF3YXlcblxuXHRcdFx0dmFyIGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYWN0aW9uc1RvUmVtb3ZlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR2YXIgYWN0aW9uID0gYWN0aW9uc1RvUmVtb3ZlWyBpIF07XG5cblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdFx0dmFyIGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcblx0XHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcblxuXHRcdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuXHRcdFx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG5cdFx0XHRcdGFjdGlvbnMucG9wKCk7XG5cblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHR9XG5cblx0fSxcblxuXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHJvb3QgdGFyZ2V0IG9iamVjdFxuXHR1bmNhY2hlUm9vdDogZnVuY3Rpb24gKCByb290ICkge1xuXG5cdFx0dmFyIHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cblx0XHRmb3IgKCB2YXIgY2xpcFV1aWQgaW4gYWN0aW9uc0J5Q2xpcCApIHtcblxuXHRcdFx0dmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0uYWN0aW9uQnlSb290LFxuXHRcdFx0XHRhY3Rpb24gPSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRcdGlmICggYWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcblxuXHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xuXHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXG5cdHVuY2FjaGVBY3Rpb246IGZ1bmN0aW9uICggY2xpcCwgb3B0aW9uYWxSb290ICkge1xuXG5cdFx0dmFyIGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApO1xuXG5cdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuLy8gSW1wbGVtZW50YXRpb24gZGV0YWlsczpcblxuT2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlLCB7XG5cblx0X2JpbmRBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKSB7XG5cblx0XHR2YXIgcm9vdCA9IGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHR0cmFja3MgPSBhY3Rpb24uX2NsaXAudHJhY2tzLFxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG5cdFx0XHRiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncyxcblx0XHRcdGludGVycG9sYW50cyA9IGFjdGlvbi5faW50ZXJwb2xhbnRzLFxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdGJpbmRpbmdzQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGJpbmRpbmdzQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJpbmRpbmdzQnlOYW1lID0ge307XG5cdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdzQnlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuVHJhY2tzOyArKyBpICkge1xuXG5cdFx0XHR2YXIgdHJhY2sgPSB0cmFja3NbIGkgXSxcblx0XHRcdFx0dHJhY2tOYW1lID0gdHJhY2submFtZSxcblx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzQnlOYW1lWyB0cmFja05hbWUgXTtcblxuXHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBleGlzdGluZyBiaW5kaW5nLCBtYWtlIHN1cmUgdGhlIGNhY2hlIGtub3dzXG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGF0aCA9IHByb3RvdHlwZUFjdGlvbiAmJiBwcm90b3R5cGVBY3Rpb24uXG5cdFx0XHRcdFx0XHRfcHJvcGVydHlCaW5kaW5nc1sgaSBdLmJpbmRpbmcucGFyc2VkUGF0aDtcblxuXHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5TWl4ZXIoXG5cdFx0XHRcdFx0XHRQcm9wZXJ0eUJpbmRpbmcuY3JlYXRlKCByb290LCB0cmFja05hbWUsIHBhdGggKSxcblx0XHRcdFx0XHRcdHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpICk7XG5cblx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XG5cblx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XG5cblx0XHR9XG5cblx0fSxcblxuXHRfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xuXG5cdFx0aWYgKCAhIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuXHRcdFx0aWYgKCBhY3Rpb24uX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXG5cdFx0XHRcdC8vIGFwcGVhcnMgdG8gYmUgc3RpbGwgdXNpbmcgaXQgLT4gcmViaW5kXG5cblx0XHRcdFx0dmFyIHJvb3RVdWlkID0gKCBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZCxcblx0XHRcdFx0XHRjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxuXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdFx0XHR0aGlzLl9iaW5kQWN0aW9uKCBhY3Rpb24sXG5cdFx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCAmJiBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbIDAgXSApO1xuXG5cdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcblxuXHRcdFx0Ly8gaW5jcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGJpbmRpbmcudXNlQ291bnQgKysgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xuXHRcdFx0XHRcdGJpbmRpbmcuc2F2ZU9yaWdpbmFsU3RhdGUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGVuZEFjdGlvbiggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRfZGVhY3RpdmF0ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cblx0XHRpZiAoIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuXHRcdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHQvLyBkZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggLS0gYmluZGluZy51c2VDb3VudCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcblx0XHRcdFx0XHR0aGlzLl90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gTWVtb3J5IG1hbmFnZXJcblxuXHRfaW5pdE1lbW9yeU1hbmFnZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xuXG5cdFx0dGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9O1xuXHRcdC8vIGluc2lkZTpcblx0XHQvLyB7XG5cdFx0Ly8gXHRcdGtub3duQWN0aW9uczogQXJyYXk8IEFuaW1hdGlvbkFjdGlvbiA+XHQtIHVzZWQgYXMgcHJvdG90eXBlc1xuXHRcdC8vIFx0XHRhY3Rpb25CeVJvb3Q6IEFuaW1hdGlvbkFjdGlvblx0XHRcdC0gbG9va3VwXG5cdFx0Ly8gfVxuXG5cblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblxuXHRcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XG5cblxuXHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXG5cdFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHRoaXMuc3RhdHMgPSB7XG5cblx0XHRcdGFjdGlvbnM6IHtcblx0XHRcdFx0Z2V0IHRvdGFsKCkgeyByZXR1cm4gc2NvcGUuX2FjdGlvbnMubGVuZ3RoOyB9LFxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7IH1cblx0XHRcdH0sXG5cdFx0XHRiaW5kaW5nczoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoOyB9LFxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUJpbmRpbmdzOyB9XG5cdFx0XHR9LFxuXHRcdFx0Y29udHJvbEludGVycG9sYW50czoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGg7IH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHsgcmV0dXJuIHNjb3BlLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50czsgfVxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9LFxuXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBBbmltYXRpb25BY3Rpb24gb2JqZWN0c1xuXG5cdF9pc0FjdGl2ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cblx0XHR2YXIgaW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XG5cdFx0cmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4IDwgdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XG5cblx0fSxcblxuXHRfYWRkSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKSB7XG5cblx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB7XG5cblx0XHRcdFx0a25vd25BY3Rpb25zOiBbIGFjdGlvbiBdLFxuXHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XG5cblx0XHRcdH07XG5cblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IDA7XG5cblx0XHRcdGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0gPSBhY3Rpb25zRm9yQ2xpcDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XG5cdFx0XHRrbm93bkFjdGlvbnMucHVzaCggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcblx0XHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xuXG5cdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdID0gYWN0aW9uO1xuXG5cdH0sXG5cblx0X3JlbW92ZUluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblxuXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdLFxuXHRcdFx0Y2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblxuXHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG5cdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdGFjdGlvbnMucG9wKCk7XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xuXG5cblx0XHR2YXIgY2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLFxuXHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucyxcblxuXHRcdFx0bGFzdEtub3duQWN0aW9uID1cblx0XHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsga25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggLSAxIF0sXG5cblx0XHRcdGJ5Q2xpcENhY2hlSW5kZXggPSBhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXg7XG5cblx0XHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xuXHRcdGtub3duQWN0aW9uc0ZvckNsaXBbIGJ5Q2xpcENhY2hlSW5kZXggXSA9IGxhc3RLbm93bkFjdGlvbjtcblx0XHRrbm93bkFjdGlvbnNGb3JDbGlwLnBvcCgpO1xuXG5cdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcblxuXG5cdFx0dmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdCxcblx0XHRcdHJvb3RVdWlkID0gKCBhY3Rpb25zLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQ7XG5cblx0XHRkZWxldGUgYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHR9XG5cblx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKTtcblxuXHR9LFxuXG5cdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblxuXHRcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0aWYgKCAtLSBiaW5kaW5nLnJlZmVyZW5jZUNvdW50ID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRfbGVuZEFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cblx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHwgIGluYWN0aXZlIGFjdGlvbnMgIF1cblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHQvLyAgICAgICAgICAgICAgICAgcyAgICAgICAgYVxuXHRcdC8vICAgICAgICAgICAgICAgICAgPC1zd2FwLT5cblx0XHQvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyArKyxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdO1xuXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdID0gYWN0aW9uO1xuXG5cdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVBY3Rpb247XG5cblx0fSxcblxuXHRfdGFrZUJhY2tBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xuXG5cdFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgIHwgaW5hY3RpdmUgYWN0aW9ucyBdXG5cdFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8PCBpbmFjdGl2ZSBhY3Rpb25zICBdXG5cdFx0Ly8gICAgICAgIGEgICAgICAgIHNcblx0XHQvLyAgICAgICAgIDwtc3dhcC0+XG5cdFx0Ly8gICAgICAgIHMgICAgICAgIGFcblxuXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuXHRcdGxhc3RBY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQWN0aW9uO1xuXG5cdH0sXG5cblx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIFByb3BlcnR5TWl4ZXIgb2JqZWN0c1xuXG5cdF9hZGRJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApIHtcblxuXHRcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSxcblxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGlmICggYmluZGluZ0J5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0ge307XG5cdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdCeU5hbWU7XG5cblx0XHR9XG5cblx0XHRiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXSA9IGJpbmRpbmc7XG5cblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcblxuXHR9LFxuXG5cdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZyApIHtcblxuXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0cHJvcEJpbmRpbmcgPSBiaW5kaW5nLmJpbmRpbmcsXG5cdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXG5cdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuXHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXG5cblx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxuXHRcdFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XG5cblx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcblx0XHRiaW5kaW5ncy5wb3AoKTtcblxuXHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcblxuXHRcdHJlbW92ZV9lbXB0eV9tYXA6IHtcblxuXHRcdFx0Zm9yICggdmFyIF8gaW4gYmluZGluZ0J5TmFtZSApIGJyZWFrIHJlbW92ZV9lbXB0eV9tYXA7XG5cblx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdF9sZW5kQmluZGluZzogZnVuY3Rpb24gKCBiaW5kaW5nICkge1xuXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUJpbmRpbmc7XG5cblx0fSxcblxuXHRfdGFrZUJhY2tCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcgKSB7XG5cblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVCaW5kaW5ncyxcblxuXHRcdFx0bGFzdEFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdGJpbmRpbmdzWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRsYXN0QWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQmluZGluZztcblxuXHR9LFxuXG5cblx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgb2YgSW50ZXJwb2xhbnRzIGZvciB3ZWlnaHQgYW5kIHRpbWUgc2NhbGVcblxuXHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyArKyxcblx0XHRcdGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXTtcblxuXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aW50ZXJwb2xhbnQgPSBuZXcgTGluZWFySW50ZXJwb2xhbnQoXG5cdFx0XHRcdFx0bmV3IEZsb2F0MzJBcnJheSggMiApLCBuZXcgRmxvYXQzMkFycmF5KCAyICksXG5cdFx0XHRcdFx0XHQxLCB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyICk7XG5cblx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnBvbGFudDtcblxuXHR9LFxuXG5cdF90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24gKCBpbnRlcnBvbGFudCApIHtcblxuXHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxuXHRcdFx0cHJldkluZGV4ID0gaW50ZXJwb2xhbnQuX19jYWNoZUluZGV4LFxuXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyxcblxuXHRcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuXHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XG5cblx0XHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdGludGVycG9sYW50c1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XG5cblx0fSxcblxuXHRfY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheSggMSApXG5cbn0gKTtcblxuT2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlLCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBVbmlmb3JtKCB2YWx1ZSApIHtcblxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Vbmlmb3JtOiBUeXBlIHBhcmFtZXRlciBpcyBubyBsb25nZXIgbmVlZGVkLicgKTtcblx0XHR2YWx1ZSA9IGFyZ3VtZW50c1sgMSBdO1xuXG5cdH1cblxuXHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbn1cblxuVW5pZm9ybS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyBVbmlmb3JtKCB0aGlzLnZhbHVlLmNsb25lID09PSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogdGhpcy52YWx1ZS5jbG9uZSgpICk7XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuZnVuY3Rpb24gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKSB7XG5cblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XG5cdHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XG5cbn1cblxuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblxuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRzdGFydDogc3RhcnQsXG5cdFx0Y291bnQ6IGNvdW50LFxuXHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcblxuXHR9ICk7XG5cbn07XG5cbkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XG5cblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cblx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XG5cblx0fVxuXG5cdHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cblx0fVxuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cbmZ1bmN0aW9uIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgbm9ybWFsaXplZCApIHtcblxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHR0aGlzLm9mZnNldCA9IG9mZnNldDtcblxuXHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xuXG59XG5cblxuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcblxuXHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXG5cdGdldCBjb3VudCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuY291bnQ7XG5cblx0fSxcblxuXHRnZXQgYXJyYXkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5O1xuXG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xuXG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xuXG5cdH0sXG5cblx0Z2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG5cdH0sXG5cblx0Z2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xuXG5cdH0sXG5cblx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XG5cblx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5mdW5jdGlvbiBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIHN0cmlkZSApIHtcblxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuXHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIHN0cmlkZSA6IDA7XG5cblx0dGhpcy5keW5hbWljID0gZmFsc2U7XG5cdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXG5cdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cbn1cblxuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBJbnRlcmxlYXZlZEJ1ZmZlcixcblxuXHRpc0ludGVybGVhdmVkQnVmZmVyOiB0cnVlLFxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH0sXG5cblx0c2V0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGUgOiAwO1xuXHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcblxuXHR9LFxuXG5cdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XG5cdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcblx0XHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XG5cdFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG5cdFx0aW5kZXgxICo9IHRoaXMuc3RyaWRlO1xuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRvblVwbG9hZDogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cbmZ1bmN0aW9uIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG5cdEludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcblxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbn1cblxuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlICk7XG5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcblxuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXG5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cbmZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbn1cblxuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcbkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG5cbkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBSYXljYXN0ZXIoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XG5cblx0dGhpcy5yYXkgPSBuZXcgUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG5cdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcblx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cblx0dGhpcy5wYXJhbXMgPSB7XG5cdFx0TWVzaDoge30sXG5cdFx0TGluZToge30sXG5cdFx0TE9EOiB7fSxcblx0XHRQb2ludHM6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0U3ByaXRlOiB7fVxuXHR9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xuXHRcdFBvaW50Q2xvdWQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLlBvaW50cztcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxufVxuXG5mdW5jdGlvbiBhc2NTb3J0KCBhLCBiICkge1xuXG5cdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcblxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKSB7XG5cblx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0b2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy9cblxuUmF5Y2FzdGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogUmF5Y2FzdGVyLFxuXG5cdGxpbmVQcmVjaXNpb246IDEsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHR9LFxuXG5cdHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uICggY29vcmRzLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIChjYW1lcmEgJiYgY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEpICkge1xuXG5cdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fSBlbHNlIGlmICggKGNhbWVyYSAmJiBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpICkge1xuXG5cdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksICggY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyICkgLyAoIGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhciApICkudW5wcm9qZWN0KCBjYW1lcmEgKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cblx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG5cdFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XG5cblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHR9LFxuXG5cdGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlICkge1xuXG5cdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0cyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcblxuXHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbmZ1bmN0aW9uIENsb2NrKCBhdXRvU3RhcnQgKSB7XG5cblx0dGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xuXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcblx0dGhpcy5vbGRUaW1lID0gMDtcblx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XG5cblx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbn1cblxuQ2xvY2sucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBDbG9jayxcblxuXHRzdGFydDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAoIHBlcmZvcm1hbmNlIHx8IERhdGUgKS5ub3coKTtcblxuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuXHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cblx0fSxcblxuXHRnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5nZXREZWx0YSgpO1xuXHRcdHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xuXG5cdH0sXG5cblx0Z2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkaWZmID0gMDtcblxuXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdHRoaXMuc3RhcnQoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xuXG5cdFx0XHR2YXIgbmV3VGltZSA9ICggcGVyZm9ybWFuY2UgfHwgRGF0ZSApLm5vdygpO1xuXG5cdFx0XHRkaWZmID0gKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICkgLyAxMDAwO1xuXHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcblxuXHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRpZmY7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICpcbiAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG4gKlxuICogVGhlIHBvbGVzIChwaGkpIGFyZSBhdCB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHkgYXhpcy5cbiAqIFRoZSBlcXVhdG9yIHN0YXJ0cyBhdCBwb3NpdGl2ZSB6LlxuICovXG5cbmZ1bmN0aW9uIFNwaGVyaWNhbCggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMS4wO1xuXHR0aGlzLnBoaSA9ICggcGhpICE9PSB1bmRlZmluZWQgKSA/IHBoaSA6IDA7IC8vIHVwIC8gZG93biB0b3dhcmRzIHRvcCBhbmQgYm90dG9tIHBvbGVcblx0dGhpcy50aGV0YSA9ICggdGhldGEgIT09IHVuZGVmaW5lZCApID8gdGhldGEgOiAwOyAvLyBhcm91bmQgdGhlIGVxdWF0b3Igb2YgdGhlIHNwaGVyZVxuXG5cdHJldHVybiB0aGlzO1xuXG59XG5cblNwaGVyaWNhbC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFNwaGVyaWNhbCxcblxuXHRzZXQ6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5waGkgPSBwaGk7XG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBvdGhlciApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gb3RoZXIucmFkaXVzO1xuXHRcdHRoaXMucGhpID0gb3RoZXIucGhpO1xuXHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xuXHRtYWtlU2FmZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgRVBTID0gMC4wMDAwMDE7XG5cdFx0dGhpcy5waGkgPSBNYXRoLm1heCggRVBTLCBNYXRoLm1pbiggTWF0aC5QSSAtIEVQUywgdGhpcy5waGkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24oIHZlYzMgKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IHZlYzMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIHRoaXMucmFkaXVzID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnRoZXRhID0gMDtcblx0XHRcdHRoaXMucGhpID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB2ZWMzLngsIHZlYzMueiApOyAvLyBlcXVhdG9yIGFuZ2xlIGFyb3VuZCB5LXVwIGF4aXNcblx0XHRcdHRoaXMucGhpID0gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggdmVjMy55IC8gdGhpcy5yYWRpdXMsIC0gMSwgMSApICk7IC8vIHBvbGFyIGFuZ2xlXG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N5bGluZHJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG4gKlxuICovXG5cbmZ1bmN0aW9uIEN5bGluZHJpY2FsKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMS4wOyAvLyBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lXG5cdHRoaXMudGhldGEgPSAoIHRoZXRhICE9PSB1bmRlZmluZWQgKSA/IHRoZXRhIDogMDsgLy8gY291bnRlcmNsb2Nrd2lzZSBhbmdsZSBpbiB0aGUgeC16IHBsYW5lIG1lYXN1cmVkIGluIHJhZGlhbnMgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzXG5cdHRoaXMueSA9ICggeSAhPT0gdW5kZWZpbmVkICkgPyB5IDogMDsgLy8gaGVpZ2h0IGFib3ZlIHRoZSB4LXogcGxhbmVcblxuXHRyZXR1cm4gdGhpcztcblxufVxuXG5DeWxpbmRyaWNhbC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IEN5bGluZHJpY2FsLFxuXG5cdHNldDogZnVuY3Rpb24gKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIG90aGVyICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xuXHRcdHRoaXMueSA9IG90aGVyLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiggdmVjMyApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCB2ZWMzLnggKiB2ZWMzLnggKyB2ZWMzLnogKiB2ZWMzLnogKTtcblx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggdmVjMy54LCB2ZWMzLnogKTtcblx0XHR0aGlzLnkgPSB2ZWMzLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIE1vcnBoQmxlbmRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cclxuXHRNZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcblxyXG5cdC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuXHQvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXHJcblxyXG5cdHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcblx0dmFyIHN0YXJ0RnJhbWUgPSAwO1xyXG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XHJcblxyXG5cdHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuXHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xyXG5cdHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XHJcblxyXG59XHJcblxyXG5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApO1xyXG5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3JwaEJsZW5kTWVzaDtcclxuXHJcbk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jcmVhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIHN0YXJ0LCBlbmQsIGZwcyApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHtcclxuXHJcblx0XHRzdGFydDogc3RhcnQsXHJcblx0XHRlbmQ6IGVuZCxcclxuXHJcblx0XHRsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMSxcclxuXHJcblx0XHRmcHM6IGZwcyxcclxuXHRcdGR1cmF0aW9uOiAoIGVuZCAtIHN0YXJ0ICkgLyBmcHMsXHJcblxyXG5cdFx0bGFzdEZyYW1lOiAwLFxyXG5cdFx0Y3VycmVudEZyYW1lOiAwLFxyXG5cclxuXHRcdGFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0dGltZTogMCxcclxuXHRcdGRpcmVjdGlvbjogMSxcclxuXHRcdHdlaWdodDogMSxcclxuXHJcblx0XHRkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxyXG5cdFx0bWlycm9yZWRMb29wOiBmYWxzZVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXSA9IGFuaW1hdGlvbjtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xyXG5cclxufTtcclxuXHJcbk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5hdXRvQ3JlYXRlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICggZnBzICkge1xyXG5cclxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspL2k7XHJcblxyXG5cdHZhciBmaXJzdEFuaW1hdGlvbiwgZnJhbWVSYW5nZXMgPSB7fTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcclxuXHRcdHZhciBjaHVua3MgPSBtb3JwaC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0aWYgKCBjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZyYW1lUmFuZ2VzWyBuYW1lIF0gKSBmcmFtZVJhbmdlc1sgbmFtZSBdID0geyBzdGFydDogSW5maW5pdHksIGVuZDogLSBJbmZpbml0eSB9O1xyXG5cclxuXHRcdFx0dmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xyXG5cdFx0XHRpZiAoIGkgPiByYW5nZS5lbmQgKSByYW5nZS5lbmQgPSBpO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBuYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCB2YXIgbmFtZSBpbiBmcmFtZVJhbmdlcyApIHtcclxuXHJcblx0XHR2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG5cdFx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcclxuXHJcbn07XHJcblxyXG5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uRm9yd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24uZGlyZWN0aW9uID0gMTtcclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24uZGlyZWN0aW9uID0gLSAxO1xyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTID0gZnVuY3Rpb24gKCBuYW1lLCBmcHMgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmZwcyA9IGZwcztcclxuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmZwcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgZHVyYXRpb24gKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblx0XHRhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi50aW1lID0gdGltZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgdGltZSA9IDA7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0dGltZSA9IGFuaW1hdGlvbi50aW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aW1lO1xyXG5cclxufTtcclxuXHJcbk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGR1cmF0aW9uID0gLSAxO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBkdXJhdGlvbjtcclxuXHJcbn07XHJcblxyXG5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcblx0XHRhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuTW9ycGhCbGVuZE1lc2g6IGFuaW1hdGlvbltcIiArIG5hbWUgKyBcIl0gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKClcIiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNMaXN0WyBpIF07XHJcblxyXG5cdFx0aWYgKCAhIGFuaW1hdGlvbi5hY3RpdmUgKSBjb250aW51ZTtcclxuXHJcblx0XHR2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZGlyZWN0aW9uICogZGVsdGE7XHJcblxyXG5cdFx0aWYgKCBhbmltYXRpb24ubWlycm9yZWRMb29wICkge1xyXG5cclxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gKj0gLSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cdFx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uLnRpbWUgPSAwO1xyXG5cdFx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLnRpbWUgJSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGtleWZyYW1lID0gYW5pbWF0aW9uLnN0YXJ0ICsgX01hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcblx0XHRpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSAhPT0gYW5pbWF0aW9uLmxhc3RGcmFtZSApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IHdlaWdodDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBJbW1lZGlhdGVSZW5kZXJPYmplY3QoIG1hdGVyaWFsICkge1xuXG5cdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJDYWxsYmFjayApIHt9O1xuXG59XG5cbkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbW1lZGlhdGVSZW5kZXJPYmplY3Q7XG5cbkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgPSB0cnVlO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cbmZ1bmN0aW9uIFZlcnRleE5vcm1hbHNIZWxwZXIoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xuXG5cdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cblx0Ly9cblxuXHR2YXIgbk5vcm1hbHMgPSAwO1xuXG5cdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG5cdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcblxuXHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudDtcblxuXHR9XG5cblx0Ly9cblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcblxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG5cdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcblxuXHQvL1xuXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn1cblxuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlcnRleE5vcm1hbHNIZWxwZXI7XG5cblZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdC8vXG5cblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuXHRcdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0XHR2YXIgaWR4ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZmFjZVsga2V5c1sgaiBdIF0gXTtcblxuXHRcdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcblxuXHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0dmFyIG9iak5vcm0gPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0dmFyIGlkeCA9IDA7XG5cblx0XHRcdC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG9ialBvcy5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcblxuXHRcdFx0XHR2Mi5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxufSgpICk7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cbmZ1bmN0aW9uIFNwb3RMaWdodEhlbHBlciggbGlnaHQgKSB7XG5cblx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdHZhciBwb3NpdGlvbnMgPSBbXG5cdFx0MCwgMCwgMCwgICAwLCAgIDAsICAgMSxcblx0XHQwLCAwLCAwLCAgIDEsICAgMCwgICAxLFxuXHRcdDAsIDAsIDAsIC0gMSwgICAwLCAgIDEsXG5cdFx0MCwgMCwgMCwgICAwLCAgIDEsICAgMSxcblx0XHQwLCAwLCAwLCAgIDAsIC0gMSwgICAxXG5cdF07XG5cblx0Zm9yICggdmFyIGkgPSAwLCBqID0gMSwgbCA9IDMyOyBpIDwgbDsgaSArKywgaiArKyApIHtcblxuXHRcdHZhciBwMSA9ICggaSAvIGwgKSAqIE1hdGguUEkgKiAyO1xuXHRcdHZhciBwMiA9ICggaiAvIGwgKSAqIE1hdGguUEkgKiAyO1xuXG5cdFx0cG9zaXRpb25zLnB1c2goXG5cdFx0XHRNYXRoLmNvcyggcDEgKSwgTWF0aC5zaW4oIHAxICksIDEsXG5cdFx0XHRNYXRoLmNvcyggcDIgKSwgTWF0aC5zaW4oIHAyICksIDFcblx0XHQpO1xuXG5cdH1cblxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcblxuXHR0aGlzLmNvbmUgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn1cblxuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwb3RMaWdodEhlbHBlcjtcblxuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwO1xuXHRcdHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcblxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XG5cblx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0dmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLmNvbmUubG9va0F0KCB2ZWN0b3IyLnN1YiggdmVjdG9yICkgKTtcblxuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0fTtcblxufSgpO1xuXG4vKipcbiAqIEBhdXRob3IgU2VhbiBHcmlmZmluIC8gaHR0cDovL3R3aXR0ZXIuY29tL3NncmlmXG4gKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBTa2VsZXRvbkhlbHBlciggb2JqZWN0ICkge1xuXG5cdHRoaXMuYm9uZXMgPSB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QgKTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHR2YXIgdmVydGljZXMgPSBbXTtcblx0dmFyIGNvbG9ycyA9IFtdO1xuXG5cdHZhciBjb2xvcjEgPSBuZXcgQ29sb3IoIDAsIDAsIDEgKTtcblx0dmFyIGNvbG9yMiA9IG5ldyBDb2xvciggMCwgMSwgMCApO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcblxuXHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIgKTtcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cblx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdHRoaXMucm9vdCA9IG9iamVjdDtcblxuXHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufVxuXG5cblNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNrZWxldG9uSGVscGVyO1xuXG5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuZ2V0Qm9uZUxpc3QgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG5cdHZhciBib25lTGlzdCA9IFtdO1xuXG5cdGlmICggb2JqZWN0ICYmIG9iamVjdC5pc0JvbmUgKSB7XG5cblx0XHRib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuXHR9XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XG5cblx0fVxuXG5cdHJldHVybiBib25lTGlzdDtcblxufTtcblxuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHR2YXIgYm9uZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBNYXRyaXg0KCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRtYXRyaXhXb3JsZEludi5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xuXG5cdFx0XHRcdGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGosIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcblxuXHRcdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaiArIDEsIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcblxuXHRcdFx0XHRqICs9IDI7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG59KCk7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gUG9pbnRMaWdodEhlbHBlciggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cblx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG5cdHZhciBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0TWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHR0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdC8qXG5cdHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcblx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcblxuXHR2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xuXG5cdGlmICggZCA9PT0gMC4wICkge1xuXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG5cdH1cblxuXHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XG5cdCovXG5cbn1cblxuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApO1xuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0SGVscGVyO1xuXG5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdC8qXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXHQqL1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgYWJlbG5hdGlvbiAvIGh0dHA6Ly9naXRodWIuY29tL2FiZWxuYXRpb25cbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcbiAqL1xuXG5mdW5jdGlvbiBSZWN0QXJlYUxpZ2h0SGVscGVyKCBsaWdodCApIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0dmFyIG1hdGVyaWFsRnJvbnQgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHtcblx0XHRjb2xvcjogbGlnaHQuY29sb3IsXG5cdFx0Zm9nOiBmYWxzZVxuXHR9ICk7XG5cblx0dmFyIG1hdGVyaWFsQmFjayA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgge1xuXHRcdGNvbG9yOiBsaWdodC5jb2xvcixcblx0XHRmb2c6IGZhbHNlLFxuXHRcdHdpcmVmcmFtZTogdHJ1ZVxuXHR9ICk7XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA2ICogMyApLCAzICkgKTtcblxuXHQvLyBzaG93cyB0aGUgXCJmcm9udFwiIG9mIHRoZSBsaWdodCwgZS5nLiB3aGVyZSBsaWdodCBjb21lcyBmcm9tXG5cblx0dGhpcy5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxGcm9udCApICk7XG5cblx0Ly8gc2hvd3MgdGhlIFwiYmFja1wiIG9mIHRoZSBsaWdodCwgd2hpY2ggZG9lcyBub3QgZW1pdCBsaWdodFxuXG5cdHRoaXMuYWRkKCBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsQmFjayApICk7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufVxuXG5SZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuUmVjdEFyZWFMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0QXJlYUxpZ2h0SGVscGVyO1xuXG5SZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMuY2hpbGRyZW5bIDAgXS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdHRoaXMuY2hpbGRyZW5bIDEgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMuY2hpbGRyZW5bIDEgXS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdmVjdG9yMSA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciB2ZWN0b3IyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0dmFyIG1lc2gxID0gdGhpcy5jaGlsZHJlblsgMCBdO1xuXHRcdHZhciBtZXNoMiA9IHRoaXMuY2hpbGRyZW5bIDEgXTtcblxuXHRcdGlmICggdGhpcy5saWdodC50YXJnZXQgKSB7XG5cblx0XHRcdHZlY3RvcjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHR2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dmFyIGxvb2tWZWMgPSB2ZWN0b3IyLmNsb25lKCkuc3ViKCB2ZWN0b3IxICk7XG5cdFx0XHRtZXNoMS5sb29rQXQoIGxvb2tWZWMgKTtcblx0XHRcdG1lc2gyLmxvb2tBdCggbG9va1ZlYyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIG1hdGVyaWFsc1xuXG5cdFx0bWVzaDEubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXHRcdG1lc2gyLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuXHRcdC8vIGNhbGN1bGF0ZSBuZXcgZGltZW5zaW9ucyBvZiB0aGUgaGVscGVyXG5cblx0XHR2YXIgaHggPSB0aGlzLmxpZ2h0LndpZHRoICogMC41O1xuXHRcdHZhciBoeSA9IHRoaXMubGlnaHQuaGVpZ2h0ICogMC41O1xuXG5cdFx0Ly8gYmVjYXVzZSB0aGUgYnVmZmVyIGF0dHJpYnV0ZSBpcyBzaGFyZWQgb3ZlciBib3RoIGdlb21ldHJpZXMsIHdlIG9ubHkgaGF2ZSB0byB1cGRhdGUgb25jZVxuXG5cdFx0dmFyIHBvc2l0aW9uID0gbWVzaDEuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XG5cblx0XHQvLyBmaXJzdCBmYWNlXG5cblx0XHRhcnJheVsgIDAgXSA9ICAgaHg7IGFycmF5WyAgMSBdID0gLSBoeTsgYXJyYXlbICAyIF0gPSAwO1xuXHRcdGFycmF5WyAgMyBdID0gICBoeDsgYXJyYXlbICA0IF0gPSAgIGh5OyBhcnJheVsgIDUgXSA9IDA7XG5cdFx0YXJyYXlbICA2IF0gPSAtIGh4OyBhcnJheVsgIDcgXSA9ICAgaHk7IGFycmF5WyAgOCBdID0gMDtcblxuXHRcdC8vIHNlY29uZCBmYWNlXG5cblx0XHRhcnJheVsgIDkgXSA9IC0gaHg7IGFycmF5WyAxMCBdID0gICBoeTsgYXJyYXlbIDExIF0gPSAwO1xuXHRcdGFycmF5WyAxMiBdID0gLSBoeDsgYXJyYXlbIDEzIF0gPSAtIGh5OyBhcnJheVsgMTQgXSA9IDA7XG5cdFx0YXJyYXlbIDE1IF0gPSAgIGh4OyBhcnJheVsgMTYgXSA9IC0gaHk7IGFycmF5WyAxNyBdID0gMDtcblxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG59KCk7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICovXG5cbmZ1bmN0aW9uIEhlbWlzcGhlcmVMaWdodEhlbHBlciggbGlnaHQsIHNpemUgKSB7XG5cblx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHNpemUgKTtcblx0Z2VvbWV0cnkucm90YXRlWSggTWF0aC5QSSAqIDAuNSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcblxuXHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9uLmNvdW50ICogMyApO1xuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApICk7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufVxuXG5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xuXG5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5jaGlsZHJlblsgMCBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0dmFyIGNvbG9yMSA9IG5ldyBDb2xvcigpO1xuXHR2YXIgY29sb3IyID0gbmV3IENvbG9yKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdHZhciBtZXNoID0gdGhpcy5jaGlsZHJlblsgMCBdO1xuXG5cdFx0dmFyIGNvbG9ycyA9IG1lc2guZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAnY29sb3InICk7XG5cblx0XHRjb2xvcjEuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXHRcdGNvbG9yMi5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY29sb3IgPSAoIGkgPCAoIGwgLyAyICkgKSA/IGNvbG9yMSA6IGNvbG9yMjtcblxuXHRcdFx0Y29sb3JzLnNldFhZWiggaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0fVxuXG5cdFx0bWVzaC5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xuXG5cdFx0Y29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG59KCk7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5mdW5jdGlvbiBHcmlkSGVscGVyKCBzaXplLCBkaXZpc2lvbnMsIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdHNpemUgPSBzaXplIHx8IDEwO1xuXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTA7XG5cdGNvbG9yMSA9IG5ldyBDb2xvciggY29sb3IxICE9PSB1bmRlZmluZWQgPyBjb2xvcjEgOiAweDQ0NDQ0NCApO1xuXHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiAhPT0gdW5kZWZpbmVkID8gY29sb3IyIDogMHg4ODg4ODggKTtcblxuXHR2YXIgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcblx0dmFyIHN0ZXAgPSBzaXplIC8gZGl2aXNpb25zO1xuXHR2YXIgaGFsZlNpemUgPSBzaXplIC8gMjtcblxuXHR2YXIgdmVydGljZXMgPSBbXSwgY29sb3JzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgayA9IC0gaGFsZlNpemU7IGkgPD0gZGl2aXNpb25zOyBpICsrLCBrICs9IHN0ZXAgKSB7XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCAtIGhhbGZTaXplLCAwLCBrLCBoYWxmU2l6ZSwgMCwgayApO1xuXHRcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gaGFsZlNpemUsIGssIDAsIGhhbGZTaXplICk7XG5cblx0XHR2YXIgY29sb3IgPSBpID09PSBjZW50ZXIgPyBjb2xvcjEgOiBjb2xvcjI7XG5cblx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG5cdFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcblx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXG5cdH1cblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XG5cblx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59XG5cbkdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkSGVscGVyO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gKiBAYXV0aG9yIEhlY3RhdGUgLyBodHRwOi8vd3d3LmdpdGh1Yi5jb20vSGVjdGF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGFyR3JpZEhlbHBlciggcmFkaXVzLCByYWRpYWxzLCBjaXJjbGVzLCBkaXZpc2lvbnMsIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDtcblx0cmFkaWFscyA9IHJhZGlhbHMgfHwgMTY7XG5cdGNpcmNsZXMgPSBjaXJjbGVzIHx8IDg7XG5cdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCA2NDtcblx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgIT09IHVuZGVmaW5lZCA/IGNvbG9yMSA6IDB4NDQ0NDQ0ICk7XG5cdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICE9PSB1bmRlZmluZWQgPyBjb2xvcjIgOiAweDg4ODg4OCApO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgY29sb3JzID0gW107XG5cblx0dmFyIHgsIHo7XG5cdHZhciB2LCBpLCBqLCByLCBjb2xvcjtcblxuXHQvLyBjcmVhdGUgdGhlIHJhZGlhbHNcblxuXHRmb3IgKCBpID0gMDsgaSA8PSByYWRpYWxzOyBpICsrICkge1xuXG5cdFx0diA9ICggaSAvIHJhZGlhbHMgKSAqICggTWF0aC5QSSAqIDIgKTtcblxuXHRcdHggPSBNYXRoLnNpbiggdiApICogcmFkaXVzO1xuXHRcdHogPSBNYXRoLmNvcyggdiApICogcmFkaXVzO1xuXG5cdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcblxuXHRcdGNvbG9yID0gKCBpICYgMSApID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdH1cblxuXHQvLyBjcmVhdGUgdGhlIGNpcmNsZXNcblxuXHRmb3IgKCBpID0gMDsgaSA8PSBjaXJjbGVzOyBpICsrICkge1xuXG5cdFx0Y29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XG5cblx0XHRyID0gcmFkaXVzIC0gKCByYWRpdXMgLyBjaXJjbGVzICogaSApO1xuXG5cdFx0Zm9yICggaiA9IDA7IGogPCBkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdC8vIGZpcnN0IHZlcnRleFxuXG5cdFx0XHR2ID0gKCBqIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdHggPSBNYXRoLnNpbiggdiApICogcjtcblx0XHRcdHogPSBNYXRoLmNvcyggdiApICogcjtcblxuXHRcdFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xuXHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0Ly8gc2Vjb25kIHZlcnRleFxuXG5cdFx0XHR2ID0gKCAoIGogKyAxICkgLyBkaXZpc2lvbnMgKSAqICggTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0eCA9IE1hdGguc2luKCB2ICkgKiByO1xuXHRcdFx0eiA9IE1hdGguY29zKCB2ICkgKiByO1xuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XG5cdFx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XG5cblx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59XG5cblBvbGFyR3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5Qb2xhckdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9sYXJHcmlkSGVscGVyO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cbmZ1bmN0aW9uIEZhY2VOb3JtYWxzSGVscGVyKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG5cdC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XG5cblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHQvL1xuXG5cdHZhciBuTm9ybWFscyA9IDA7XG5cblx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cblx0aWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xuXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2VOb3JtYWxzSGVscGVyOiBvbmx5IFRIUkVFLkdlb21ldHJ5IGlzIHN1cHBvcnRlZC4gVXNlIFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIsIGluc3RlYWQuJyApO1xuXG5cdH1cblxuXHQvL1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cblx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xuXG5cdC8vXG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMudXBkYXRlKCk7XG5cbn1cblxuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmFjZU5vcm1hbHNIZWxwZXI7XG5cbkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdC8vXG5cblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cblx0XHR2YXIgaWR4ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHR2MS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKVxuXHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxuXHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKVxuXHRcdFx0XHQuZGl2aWRlU2NhbGFyKCAzIClcblx0XHRcdFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG5cdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG5cdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG5cdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0fVxuXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxufSgpICk7XG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5mdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0SGVscGVyKCBsaWdodCwgc2l6ZSApIHtcblxuXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gMTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggW1xuXHRcdC0gc2l6ZSwgICBzaXplLCAwLFxuXHRcdCAgc2l6ZSwgICBzaXplLCAwLFxuXHRcdCAgc2l6ZSwgLSBzaXplLCAwLFxuXHRcdC0gc2l6ZSwgLSBzaXplLCAwLFxuXHRcdC0gc2l6ZSwgICBzaXplLCAwXG5cdF0sIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcblxuXHR0aGlzLmFkZCggbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApICk7XG5cblx0Z2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAwLCAwLCAxIF0sIDMgKSApO1xuXG5cdHRoaXMuYWRkKCBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICkpO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn1cblxuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcblxuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgbGlnaHRQbGFuZSA9IHRoaXMuY2hpbGRyZW5bIDAgXTtcblx0dmFyIHRhcmdldExpbmUgPSB0aGlzLmNoaWxkcmVuWyAxIF07XG5cblx0bGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdGxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHR0YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cbkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdjMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0djMuc3ViVmVjdG9ycyggdjIsIHYxICk7XG5cblx0XHR2YXIgbGlnaHRQbGFuZSA9IHRoaXMuY2hpbGRyZW5bIDAgXTtcblx0XHR2YXIgdGFyZ2V0TGluZSA9IHRoaXMuY2hpbGRyZW5bIDEgXTtcblxuXHRcdGxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuXHRcdGxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdFx0dGFyZ2V0TGluZS5sb29rQXQoIHYzICk7XG5cdFx0dGFyZ2V0TGluZS5zY2FsZS56ID0gdjMubGVuZ3RoKCk7XG5cblx0fTtcblxufSgpO1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICpcbiAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcbiAqXHQtIHN1aXRhYmxlIGZvciBmYXN0IHVwZGF0ZXNcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxuICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuICovXG5cbmZ1bmN0aW9uIENhbWVyYUhlbHBlciggY2FtZXJhICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IEZhY2VDb2xvcnMgfSApO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgY29sb3JzID0gW107XG5cblx0dmFyIHBvaW50TWFwID0ge307XG5cblx0Ly8gY29sb3JzXG5cblx0dmFyIGNvbG9yRnJ1c3R1bSA9IG5ldyBDb2xvciggMHhmZmFhMDAgKTtcblx0dmFyIGNvbG9yQ29uZSA9IG5ldyBDb2xvciggMHhmZjAwMDAgKTtcblx0dmFyIGNvbG9yVXAgPSBuZXcgQ29sb3IoIDB4MDBhYWZmICk7XG5cdHZhciBjb2xvclRhcmdldCA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblx0dmFyIGNvbG9yQ3Jvc3MgPSBuZXcgQ29sb3IoIDB4MzMzMzMzICk7XG5cblx0Ly8gbmVhclxuXG5cdGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBjb2xvckZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuMlwiLCBcIm40XCIsIGNvbG9yRnJ1c3R1bSApO1xuXHRhZGRMaW5lKCBcIm40XCIsIFwibjNcIiwgY29sb3JGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBjb2xvckZydXN0dW0gKTtcblxuXHQvLyBmYXJcblxuXHRhZGRMaW5lKCBcImYxXCIsIFwiZjJcIiwgY29sb3JGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwiZjJcIiwgXCJmNFwiLCBjb2xvckZydXN0dW0gKTtcblx0YWRkTGluZSggXCJmNFwiLCBcImYzXCIsIGNvbG9yRnJ1c3R1bSApO1xuXHRhZGRMaW5lKCBcImYzXCIsIFwiZjFcIiwgY29sb3JGcnVzdHVtICk7XG5cblx0Ly8gc2lkZXNcblxuXHRhZGRMaW5lKCBcIm4xXCIsIFwiZjFcIiwgY29sb3JGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjJcIiwgXCJmMlwiLCBjb2xvckZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuM1wiLCBcImYzXCIsIGNvbG9yRnJ1c3R1bSApO1xuXHRhZGRMaW5lKCBcIm40XCIsIFwiZjRcIiwgY29sb3JGcnVzdHVtICk7XG5cblx0Ly8gY29uZVxuXG5cdGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGNvbG9yQ29uZSApO1xuXHRhZGRMaW5lKCBcInBcIiwgXCJuMlwiLCBjb2xvckNvbmUgKTtcblx0YWRkTGluZSggXCJwXCIsIFwibjNcIiwgY29sb3JDb25lICk7XG5cdGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGNvbG9yQ29uZSApO1xuXG5cdC8vIHVwXG5cblx0YWRkTGluZSggXCJ1MVwiLCBcInUyXCIsIGNvbG9yVXAgKTtcblx0YWRkTGluZSggXCJ1MlwiLCBcInUzXCIsIGNvbG9yVXAgKTtcblx0YWRkTGluZSggXCJ1M1wiLCBcInUxXCIsIGNvbG9yVXAgKTtcblxuXHQvLyB0YXJnZXRcblxuXHRhZGRMaW5lKCBcImNcIiwgXCJ0XCIsIGNvbG9yVGFyZ2V0ICk7XG5cdGFkZExpbmUoIFwicFwiLCBcImNcIiwgY29sb3JDcm9zcyApO1xuXG5cdC8vIGNyb3NzXG5cblx0YWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgY29sb3JDcm9zcyApO1xuXHRhZGRMaW5lKCBcImNuM1wiLCBcImNuNFwiLCBjb2xvckNyb3NzICk7XG5cblx0YWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgY29sb3JDcm9zcyApO1xuXHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBjb2xvckNyb3NzICk7XG5cblx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgY29sb3IgKSB7XG5cblx0XHRhZGRQb2ludCggYSwgY29sb3IgKTtcblx0XHRhZGRQb2ludCggYiwgY29sb3IgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkUG9pbnQoIGlkLCBjb2xvciApIHtcblxuXHRcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcblx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwb2ludE1hcFsgaWQgXSA9IFtdO1xuXG5cdFx0fVxuXG5cdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgLSAxICk7XG5cblx0fVxuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdGlmICggdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCApIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR0aGlzLm1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZDtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn1cblxuQ2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbkNhbWVyYUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW1lcmFIZWxwZXI7XG5cbkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cblx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciBjYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG5cblx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xuXG5cdFx0dmVjdG9yLnNldCggeCwgeSwgeiApLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0XHR2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XG5cblx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBwb2ludHNbIGkgXSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0cG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xuXG5cdFx0dmFyIHcgPSAxLCBoID0gMTtcblxuXHRcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcblx0XHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxuXG5cdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0Ly8gY2VudGVyIC8gdGFyZ2V0XG5cblx0XHRzZXRQb2ludCggXCJjXCIsIDAsIDAsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcblxuXHRcdC8vIG5lYXJcblxuXHRcdHNldFBvaW50KCBcIm4xXCIsIC0gdywgLSBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJuMlwiLCAgIHcsIC0gaCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwibjNcIiwgLSB3LCAgIGgsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcIm40XCIsICAgdywgICBoLCAtIDEgKTtcblxuXHRcdC8vIGZhclxuXG5cdFx0c2V0UG9pbnQoIFwiZjFcIiwgLSB3LCAtIGgsIDEgKTtcblx0XHRzZXRQb2ludCggXCJmMlwiLCAgIHcsIC0gaCwgMSApO1xuXHRcdHNldFBvaW50KCBcImYzXCIsIC0gdywgICBoLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiZjRcIiwgICB3LCAgIGgsIDEgKTtcblxuXHRcdC8vIHVwXG5cblx0XHRzZXRQb2ludCggXCJ1MVwiLCAgIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcInUyXCIsIC0gdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwidTNcIiwgICAgICAgICAwLCBoICogMiwgICAtIDEgKTtcblxuXHRcdC8vIGNyb3NzXG5cblx0XHRzZXRQb2ludCggXCJjZjFcIiwgLSB3LCAgIDAsIDEgKTtcblx0XHRzZXRQb2ludCggXCJjZjJcIiwgICB3LCAgIDAsIDEgKTtcblx0XHRzZXRQb2ludCggXCJjZjNcIiwgICAwLCAtIGgsIDEgKTtcblx0XHRzZXRQb2ludCggXCJjZjRcIiwgICAwLCAgIGgsIDEgKTtcblxuXHRcdHNldFBvaW50KCBcImNuMVwiLCAtIHcsICAgMCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY24yXCIsICAgdywgICAwLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJjbjNcIiwgICAwLCAtIGgsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcImNuNFwiLCAgIDAsICAgaCwgLSAxICk7XG5cblx0XHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fTtcblxufSgpO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQm94SGVscGVyKCBvYmplY3QsIGNvbG9yICkge1xuXG5cdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XG5cblx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICogMyApO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cblx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHRoaXMudXBkYXRlKCBvYmplY3QgKTtcblxuXHR9XG5cbn1cblxuQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbkJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hIZWxwZXI7XG5cbkJveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBvYmplY3QgJiYgb2JqZWN0LmlzQm94MyApIHtcblxuXHRcdFx0Ym94LmNvcHkoIG9iamVjdCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ym94LnNldEZyb21PYmplY3QoIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBib3guaXNFbXB0eSgpICkgcmV0dXJuO1xuXG5cdFx0dmFyIG1pbiA9IGJveC5taW47XG5cdFx0dmFyIG1heCA9IGJveC5tYXg7XG5cblx0XHQvKlxuXHRcdCAgNV9fX180XG5cdFx0MS9fX18wL3xcblx0XHR8IDZfX3xfN1xuXHRcdDIvX19fMy9cblxuXHRcdDA6IG1heC54LCBtYXgueSwgbWF4Lnpcblx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG5cdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4Lnpcblx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG5cdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcblx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG5cdFx0Ki9cblxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHR2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcblxuXHRcdGFycmF5WyAgMCBdID0gbWF4Lng7IGFycmF5WyAgMSBdID0gbWF4Lnk7IGFycmF5WyAgMiBdID0gbWF4Lno7XG5cdFx0YXJyYXlbICAzIF0gPSBtaW4ueDsgYXJyYXlbICA0IF0gPSBtYXgueTsgYXJyYXlbICA1IF0gPSBtYXguejtcblx0XHRhcnJheVsgIDYgXSA9IG1pbi54OyBhcnJheVsgIDcgXSA9IG1pbi55OyBhcnJheVsgIDggXSA9IG1heC56O1xuXHRcdGFycmF5WyAgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XG5cdFx0YXJyYXlbIDEyIF0gPSBtYXgueDsgYXJyYXlbIDEzIF0gPSBtYXgueTsgYXJyYXlbIDE0IF0gPSBtaW4uejtcblx0XHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xuXHRcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XG5cdFx0YXJyYXlbIDIxIF0gPSBtYXgueDsgYXJyYXlbIDIyIF0gPSBtaW4ueTsgYXJyYXlbIDIzIF0gPSBtaW4uejtcblxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0fTtcblxufSApKCk7XG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xuICpcbiAqIFBhcmFtZXRlcnM6XG4gKiAgZGlyIC0gVmVjdG9yM1xuICogIG9yaWdpbiAtIFZlY3RvcjNcbiAqICBsZW5ndGggLSBOdW1iZXJcbiAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcbiAqICBoZWFkV2lkdGggLSBOdW1iZXJcbiAqL1xuXG52YXIgbGluZUdlb21ldHJ5O1xudmFyIGNvbmVHZW9tZXRyeTtcblxuZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XG5cblx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xuXHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMTtcblx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuXHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcblxuXHRpZiAoIGxpbmVHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0bGluZUdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0bGluZUdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMSwgMCBdLCAzICkgKTtcblxuXHRcdGNvbmVHZW9tZXRyeSA9IG5ldyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcblx0XHRjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xuXG5cdH1cblxuXHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xuXG5cdHRoaXMubGluZSA9IG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cdHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcblxuXHR0aGlzLmNvbmUgPSBuZXcgTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXHR0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuXHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblxufVxuXG5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbkFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycm93SGVscGVyO1xuXG5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGF4aXMgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgcmFkaWFucztcblxuXHRyZXR1cm4gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKCBkaXIgKSB7XG5cblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xuXG5cdFx0fVxuXG5cdH07XG5cbn0oKSApO1xuXG5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG5cdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG5cdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIE1hdGgubWF4KCAwLCBsZW5ndGggLSBoZWFkTGVuZ3RoICksIDEgKTtcblx0dGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cdHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xuXHR0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cbn07XG5cbkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIGNvbG9yICk7XG5cdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBjb2xvciApO1xuXG59O1xuXG4vKipcbiAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gQXhpc0hlbHBlciggc2l6ZSApIHtcblxuXHRzaXplID0gc2l6ZSB8fCAxO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHQwLCAwLCAwLCAgc2l6ZSwgMCwgMCxcblx0XHQwLCAwLCAwLCAgMCwgc2l6ZSwgMCxcblx0XHQwLCAwLCAwLCAgMCwgMCwgc2l6ZVxuXHRdO1xuXG5cdHZhciBjb2xvcnMgPSBbXG5cdFx0MSwgMCwgMCwgIDEsIDAuNiwgMCxcblx0XHQwLCAxLCAwLCAgMC42LCAxLCAwLFxuXHRcdDAsIDAsIDEsICAwLCAwLjYsIDFcblx0XTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XG5cblx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59XG5cbkF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuQXhpc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBeGlzSGVscGVyO1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICpcbiAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cbiAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXG4gKlxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG4gKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XG4gKi9cblxuXG4vKlxuQmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxuIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NDg5NzM2L2NhdG11bGwtcm9tLWN1cnZlLXdpdGgtbm8tY3VzcHMtYW5kLW5vLXNlbGYtaW50ZXJzZWN0aW9ucy9cbiAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG5UaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXG5idXQgZm9yIHRocmVlLmpzIGN1cnZlIHVzZSwgaXQgY291bGQgYmUgcG9zc2libGUgaW5saW5lZCBhbmQgZmxhdHRlbiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGxcbndoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cbiovXG5cbmZ1bmN0aW9uIEN1YmljUG9seSgpIHtcblxuXHR2YXIgYzAgPSAwLCBjMSA9IDAsIGMyID0gMCwgYzMgPSAwO1xuXG5cdC8qXG5cdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcblx0ICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG5cdCAqIHN1Y2ggdGhhdFxuXHQgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXG5cdCAqICBhbmRcblx0ICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdCggeDAsIHgxLCB0MCwgdDEgKSB7XG5cblx0XHRjMCA9IHgwO1xuXHRcdGMxID0gdDA7XG5cdFx0YzIgPSAtIDMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xuXHRcdGMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGluaXRDYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xuXG5cdFx0XHRpbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XG5cblx0XHR9LFxuXG5cdFx0aW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXG5cdFx0XHR2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuXHRcdFx0dmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcblxuXHRcdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXG5cdFx0XHR0MSAqPSBkdDE7XG5cdFx0XHR0MiAqPSBkdDE7XG5cblx0XHRcdGluaXQoIHgxLCB4MiwgdDEsIHQyICk7XG5cblx0XHR9LFxuXG5cdFx0Y2FsYzogZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHR2YXIgdDIgPSB0ICogdDtcblx0XHRcdHZhciB0MyA9IHQyICogdDtcblx0XHRcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLy9cblxudmFyIHRtcCA9IG5ldyBWZWN0b3IzKCk7XG52YXIgcHggPSBuZXcgQ3ViaWNQb2x5KCk7XG52YXIgcHkgPSBuZXcgQ3ViaWNQb2x5KCk7XG52YXIgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21DdXJ2ZTMoIHAgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuXHR0aGlzLnBvaW50cyA9IHAgfHwgW107XG5cdHRoaXMuY2xvc2VkID0gZmFsc2U7XG5cbn1cblxuQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2F0bXVsbFJvbUN1cnZlMztcblxuQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHR2YXIgbCA9IHBvaW50cy5sZW5ndGg7XG5cblx0aWYgKCBsIDwgMiApIGNvbnNvbGUubG9nKCAnZHVoLCB5b3UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cycgKTtcblxuXHR2YXIgcG9pbnQgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcblx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0aWYgKCB0aGlzLmNsb3NlZCApIHtcblxuXHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcblxuXHR9IGVsc2UgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xuXG5cdFx0aW50UG9pbnQgPSBsIC0gMjtcblx0XHR3ZWlnaHQgPSAxO1xuXG5cdH1cblxuXHR2YXIgcDAsIHAxLCBwMiwgcDM7IC8vIDQgcG9pbnRzXG5cblx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDAgKSB7XG5cblx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcblx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuXHRcdHAwID0gdG1wO1xuXG5cdH1cblxuXHRwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XG5cdHAyID0gcG9pbnRzWyAoIGludFBvaW50ICsgMSApICUgbCBdO1xuXG5cdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgKyAyIDwgbCApIHtcblxuXHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG5cdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcblx0XHRwMyA9IHRtcDtcblxuXHR9XG5cblx0aWYgKCB0aGlzLnR5cGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnR5cGUgPT09ICdjZW50cmlwZXRhbCcgfHwgdGhpcy50eXBlID09PSAnY2hvcmRhbCcgKSB7XG5cblx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuXHRcdHZhciBwb3cgPSB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG5cdFx0dmFyIGR0MCA9IE1hdGgucG93KCBwMC5kaXN0YW5jZVRvU3F1YXJlZCggcDEgKSwgcG93ICk7XG5cdFx0dmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XG5cdFx0dmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cblx0XHQvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xuXHRcdGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcblx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG5cdFx0aWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xuXG5cdFx0cHguaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0cHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XG5cblx0fSBlbHNlIGlmICggdGhpcy50eXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cblx0XHR2YXIgdGVuc2lvbiA9IHRoaXMudGVuc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy50ZW5zaW9uIDogMC41O1xuXHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0ZW5zaW9uICk7XG5cdFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRlbnNpb24gKTtcblx0XHRwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGVuc2lvbiApO1xuXG5cdH1cblxuXHRyZXR1cm4gbmV3IFZlY3RvcjMoIHB4LmNhbGMoIHdlaWdodCApLCBweS5jYWxjKCB3ZWlnaHQgKSwgcHouY2FsYyggd2VpZ2h0ICkgKTtcblxufTtcblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZTMoIHYwLCB2MSwgdjIsIHYzICkge1xuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cdHRoaXMudjMgPSB2MztcblxufVxuXG5DdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcbkN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmUzO1xuXG5DdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcblxuXHRyZXR1cm4gbmV3IFZlY3RvcjMoXG5cdFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcblx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApLFxuXHRcdEN1YmljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56LCB2My56IClcblx0KTtcblxufTtcblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUzKCB2MCwgdjEsIHYyICkge1xuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cbn1cblxuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1YWRyYXRpY0JlemllckN1cnZlMztcblxuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcblxuXHRyZXR1cm4gbmV3IFZlY3RvcjMoXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55ICksXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcblx0KTtcblxufTtcblxuZnVuY3Rpb24gTGluZUN1cnZlMyggdjEsIHYyICkge1xuXG5cdHRoaXMudjEgPSB2MTtcblx0dGhpcy52MiA9IHYyO1xuXG59XG5cbkxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5MaW5lQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVDdXJ2ZTM7XG5cbkxpbmVDdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdGlmICggdCA9PT0gMSApIHtcblxuXHRcdHJldHVybiB0aGlzLnYyLmNsb25lKCk7XG5cblx0fVxuXG5cdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcblx0dmVjdG9yLm11bHRpcGx5U2NhbGFyKCB0ICk7XG5cdHZlY3Rvci5hZGQoIHRoaXMudjEgKTtcblxuXHRyZXR1cm4gdmVjdG9yO1xuXG59O1xuXG5mdW5jdGlvbiBBcmNDdXJ2ZSggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdEVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxufVxuXG5BcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XG5BcmNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcmNDdXJ2ZTtcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbnZhciBTY2VuZVV0aWxzID0ge1xuXG5cdGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcblxuXHRcdHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGdyb3VwLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JvdXA7XG5cblx0fSxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XG5cblx0XHRjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cdFx0cGFyZW50LnJlbW92ZSggY2hpbGQgKTtcblx0XHRzY2VuZS5hZGQoIGNoaWxkICk7XG5cblx0fSxcblxuXHRhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XG5cblx0XHR2YXIgbWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0XHRtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG5cdFx0c2NlbmUucmVtb3ZlKCBjaGlsZCApO1xuXHRcdHBhcmVudC5hZGQoIGNoaWxkICk7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gRmFjZTQoIGEsIGIsIGMsIGQsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKTtcblxufVxuXG52YXIgTGluZVN0cmlwID0gMDtcblxudmFyIExpbmVQaWVjZXMgPSAxO1xuXG5mdW5jdGlvbiBNZXNoRmFjZU1hdGVyaWFsKCBtYXRlcmlhbHMgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLk11bHRpTWF0ZXJpYWwuJyApO1xuXHRyZXR1cm4gbmV3IE11bHRpTWF0ZXJpYWwoIG1hdGVyaWFscyApO1xuXG59XG5cbmZ1bmN0aW9uIFBvaW50Q2xvdWQoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcblx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59XG5cbmZ1bmN0aW9uIFBhcnRpY2xlKCBtYXRlcmlhbCApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlNwcml0ZS4nICk7XG5cdHJldHVybiBuZXcgU3ByaXRlKCBtYXRlcmlhbCApO1xuXG59XG5cbmZ1bmN0aW9uIFBhcnRpY2xlU3lzdGVtKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xuXHRyZXR1cm4gbmV3IFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbn1cblxuZnVuY3Rpb24gUG9pbnRDbG91ZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcblx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG59XG5cbmZ1bmN0aW9uIFBhcnRpY2xlQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG5cdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufVxuXG5mdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG5cdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufVxuXG5mdW5jdGlvbiBWZXJ0ZXgoIHgsIHksIHogKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVydGV4IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5WZWN0b3IzIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gbmV3IFZlY3RvcjMoIHgsIHksIHogKTtcblxufVxuXG4vL1xuXG5mdW5jdGlvbiBEeW5hbWljQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSgpLnNldER5bmFtaWMoIHRydWUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApLnNldER5bmFtaWMoIHRydWUgKTtcblxufVxuXG5mdW5jdGlvbiBJbnQ4QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBJbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxufVxuXG5mdW5jdGlvbiBVaW50OEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQ4QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBVaW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XG5cbn1cblxuZnVuY3Rpb24gVWludDhDbGFtcGVkQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxufVxuXG5mdW5jdGlvbiBJbnQxNkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuSW50MTZCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XG5cbn1cblxuZnVuY3Rpb24gVWludDE2QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgVWludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxufVxuXG5mdW5jdGlvbiBJbnQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuSW50MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XG5cbn1cblxuZnVuY3Rpb24gVWludDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDMyQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgVWludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxufVxuXG5mdW5jdGlvbiBGbG9hdDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxufVxuXG5mdW5jdGlvbiBGbG9hdDY0QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxufVxuXG4vL1xuXG5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdCwgZ2V0UG9pbnQgKSB7XG5cblx0Y29uc29sZS5sb2coICdUSFJFRS5DdXJ2ZS5jcmVhdGUoKSBoYXMgYmVlbiBkZXByZWNhdGVkJyApO1xuXG5cdGNvbnN0cnVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcblx0Y29uc3RydWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdDtcblx0Y29uc3RydWN0LnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50O1xuXG5cdHJldHVybiBjb25zdHJ1Y3Q7XG5cbn07XG5cbi8vXG5cbmZ1bmN0aW9uIENsb3NlZFNwbGluZUN1cnZlMyggcG9pbnRzICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLicgKTtcblxuXHRDYXRtdWxsUm9tQ3VydmUzLmNhbGwoIHRoaXMsIHBvaW50cyApO1xuXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XG5cdHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxufVxuXG5DbG9zZWRTcGxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcblxuLy9cblxuZnVuY3Rpb24gU3BsaW5lQ3VydmUzKCBwb2ludHMgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzIGluc3RlYWQuJyApO1xuXG5cdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XG5cdHRoaXMudHlwZSA9ICdjYXRtdWxscm9tJztcblxufVxuXG5TcGxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcblxuLy9cblxuZnVuY3Rpb24gU3BsaW5lKCBwb2ludHMgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzIGluc3RlYWQuJyApO1xuXG5cdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XG5cdHRoaXMudHlwZSA9ICdjYXRtdWxscm9tJztcblxufVxuXG5TcGxpbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcblxuT2JqZWN0LmFzc2lnbiggU3BsaW5lLnByb3RvdHlwZSwge1xuXG5cdGluaXRGcm9tQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TcGxpbmU6IC5pbml0RnJvbUFycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblx0Z2V0Q29udHJvbFBvaW50c0FycmF5OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLmdldENvbnRyb2xQb2ludHNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH0sXG5cdHJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aDogZnVuY3Rpb24gKCBzYW1wbGluZ0NvZWYgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3BsaW5lOiAucmVwYXJhbWV0cml6ZUJ5QXJjTGVuZ3RoKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fVxuXG59ICk7XG5cbi8vXG5mdW5jdGlvbiBCb3VuZGluZ0JveEhlbHBlciggb2JqZWN0LCBjb2xvciApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3VuZGluZ0JveEhlbHBlciBoYXMgYmVlbiBkZXByZWNhdGVkLiBDcmVhdGluZyBhIFRIUkVFLkJveEhlbHBlciBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBCb3hIZWxwZXIoIG9iamVjdCwgY29sb3IgKTtcblxufVxuXG5mdW5jdGlvbiBFZGdlc0hlbHBlciggb2JqZWN0LCBoZXggKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRWRnZXNIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkVkZ2VzR2VvbWV0cnkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgRWRnZXNHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4ICE9PSB1bmRlZmluZWQgPyBoZXggOiAweGZmZmZmZiB9ICkgKTtcblxufVxuXG5HcmlkSGVscGVyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdyaWRIZWxwZXI6IHNldENvbG9ycygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBhc3MgdGhlbSBpbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZC4nICk7XG5cbn07XG5cbmZ1bmN0aW9uIFdpcmVmcmFtZUhlbHBlciggb2JqZWN0LCBoZXggKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2lyZWZyYW1lSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBMaW5lU2VnbWVudHMoIG5ldyBXaXJlZnJhbWVHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4ICE9PSB1bmRlZmluZWQgPyBoZXggOiAweGZmZmZmZiB9ICkgKTtcblxufVxuXG4vL1xuXG5mdW5jdGlvbiBYSFJMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuWEhSTG9hZGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuRmlsZUxvYWRlci4nICk7XG5cdHJldHVybiBuZXcgRmlsZUxvYWRlciggbWFuYWdlciApO1xuXG59XG5cbmZ1bmN0aW9uIEJpbmFyeVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkRhdGFUZXh0dXJlTG9hZGVyLicgKTtcblx0cmV0dXJuIG5ldyBEYXRhVGV4dHVyZUxvYWRlciggbWFuYWdlciApO1xuXG59XG5cbi8vXG5cbk9iamVjdC5hc3NpZ24oIEJveDIucHJvdG90eXBlLCB7XG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fSxcblx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xuXG5cdH0sXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XG5cblx0fSxcblx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRTaXplKCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cbn0gKTtcblxuT2JqZWN0LmFzc2lnbiggQm94My5wcm90b3R5cGUsIHtcblxuXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9LFxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG5cblx0fSxcblx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcblxuXHR9LFxuXHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG5cdH0sXG5cdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuc2l6ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldFNpemUoKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZSggb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG59ICk7XG5cbkxpbmUzLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmUzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xuXHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbn07XG5cbl9NYXRoLnJhbmRvbTE2ID0gZnVuY3Rpb24gKCkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGgucmFuZG9tMTYoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgTWF0aC5yYW5kb20oKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIE1hdGgucmFuZG9tKCk7XG5cbn07XG5cbk9iamVjdC5hc3NpZ24oIE1hdHJpeDMucHJvdG90eXBlLCB7XG5cblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRyaXgzOiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlwiICk7XG5cdFx0cmV0dXJuIHRoaXMudG9BcnJheSggYXJyYXksIG9mZnNldCApO1xuXG5cdH0sXG5cdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cblx0fSxcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cblx0fSxcblx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24oIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb0J1ZmZlcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYnVmZmVyICk7XG5cblx0fSxcblx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb1ZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH1cblxufSApO1xuXG5PYmplY3QuYXNzaWduKCBNYXRyaXg0LnByb3RvdHlwZSwge1xuXG5cdGV4dHJhY3RQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcblxuXHR9LFxuXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1hdHJpeDQ6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuXCIgKTtcblx0XHRyZXR1cm4gdGhpcy50b0FycmF5KCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0fSxcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAzICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG5cdH0sXG5cdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0fSxcblx0bXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHR9LFxuXHRtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCBhICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcblxuXHR9LFxuXHRyb3RhdGVBeGlzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0di50cmFuc2Zvcm1EaXJlY3Rpb24oIHRoaXMgKTtcblxuXHR9LFxuXHRjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHR9LFxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblx0cm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH0sXG5cdGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmFwcGx5VG9CdWZmZXIoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbWF0cml4LmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB0aGlzLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlciApO1xuXG5cdH0sXG5cdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLmFwcGx5VG9WZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24oIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm1ha2VGcnVzdHVtKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHRoaXMubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApO1xuXG5cdH1cblxufSApO1xuXG5QbGFuZS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25MaW5lID0gZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS4nICk7XG5cdHJldHVybiB0aGlzLmludGVyc2VjdHNMaW5lKCBsaW5lICk7XG5cbn07XG5cblF1YXRlcm5pb24ucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMgKTtcblxufTtcblxuT2JqZWN0LmFzc2lnbiggUmF5LnByb3RvdHlwZSwge1xuXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcblxuXHR9LFxuXHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25QbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNQbGFuZSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzUGxhbmUoIHBsYW5lICk7XG5cblx0fSxcblx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG5cdH1cblxufSApO1xuXG5PYmplY3QuYXNzaWduKCBTaGFwZS5wcm90b3R5cGUsIHtcblxuXHRleHRydWRlOiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLmV4dHJ1ZGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXh0cnVkZUdlb21ldHJ5KCkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG5ldyBFeHRydWRlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcblxuXHR9LFxuXHRtYWtlR2VvbWV0cnk6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAubWFrZUdlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFNoYXBlR2VvbWV0cnkoKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gbmV3IFNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcblxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmFzc2lnbiggVmVjdG9yMi5wcm90b3R5cGUsIHtcblxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IyOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICk7XG5cblx0fVxuXG59ICk7XG5cbk9iamVjdC5hc3NpZ24oIFZlY3RvcjMucHJvdG90eXBlLCB7XG5cblx0c2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgaW5zdGVhZC4nICk7XG5cblx0fSxcblx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC4nICk7XG5cblx0fSxcblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xuXG5cdH0sXG5cdGdldFNjYWxlRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcblxuXHR9LFxuXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbWF0cml4LCBpbmRleCApO1xuXG5cdH0sXG5cdGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5UHJvamVjdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuYXBwbHlNYXRyaXg0KCBtICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtICk7XG5cblx0fSxcblx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApO1xuXG5cdH1cblxufSApO1xuXG5PYmplY3QuYXNzaWduKCBWZWN0b3I0LnByb3RvdHlwZSwge1xuXG5cdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjQ6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKTtcblxuXHR9XG5cbn0gKTtcblxuLy9cblxuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVUYW5nZW50cyA9IGZ1bmN0aW9uICgpIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG59O1xuXG5PYmplY3QuYXNzaWduKCBPYmplY3QzRC5wcm90b3R5cGUsIHtcblxuXHRnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcblxuXHR9LFxuXHRyZW5kZXJEZXB0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5yZW5kZXJEZXB0aCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnJlbmRlck9yZGVyLCBpbnN0ZWFkLicgKTtcblxuXHR9LFxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggZGlzdGFuY2UsIGF4aXMgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKTtcblxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE9iamVjdDNELnByb3RvdHlwZSwge1xuXG5cdGV1bGVyT3JkZXI6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XG5cblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xuXHRcdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHR1c2VRdWF0ZXJuaW9uOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuXHRcdH1cblx0fVxuXG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMT0QucHJvdG90eXBlLCB7XG5cblx0b2JqZWN0czoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5sZXZlbHM7XG5cblx0XHR9XG5cdH1cblxufSApO1xuXG4vL1xuXG5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZpbG1HYXVnZSApIHtcblxuXHRjb25zb2xlLndhcm4oIFwiVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEuc2V0TGVucyBpcyBkZXByZWNhdGVkLiBcIiArXG5cdFx0XHRcIlVzZSAuc2V0Rm9jYWxMZW5ndGggYW5kIC5maWxtR2F1Z2UgZm9yIGEgcGhvdG9ncmFwaGljIHNldHVwLlwiICk7XG5cblx0aWYgKCBmaWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIHRoaXMuZmlsbUdhdWdlID0gZmlsbUdhdWdlO1xuXHR0aGlzLnNldEZvY2FsTGVuZ3RoKCBmb2NhbExlbmd0aCApO1xuXG59O1xuXG4vL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGlnaHQucHJvdG90eXBlLCB7XG5cdG9ubHlTaGFkb3c6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFGb3Y6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRm92IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mb3YuJyApO1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZvdiA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFMZWZ0OiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUxlZnQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmxlZnQuJyApO1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmxlZnQgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhUmlnaHQ6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhUmlnaHQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLnJpZ2h0LicgKTtcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFUb3A6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVG9wIGlzIG5vdyAuc2hhZG93LmNhbWVyYS50b3AuJyApO1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLnRvcCA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFCb3R0b206IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhQm90dG9tIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5ib3R0b20uJyApO1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmJvdHRvbSA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFOZWFyOiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYU5lYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLm5lYXIuJyApO1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLm5lYXIgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhRmFyOiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZmFyLicgKTtcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mYXIgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhVmlzaWJsZToge1xuXHRcdHNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdy5jYW1lcmEgKSBpbnN0ZWFkLicgKTtcblxuXHRcdH1cblx0fSxcblx0c2hhZG93Qmlhczoge1xuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dCaWFzIGlzIG5vdyAuc2hhZG93LmJpYXMuJyApO1xuXHRcdFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dEYXJrbmVzczoge1xuXHRcdHNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0RhcmtuZXNzIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dNYXBXaWR0aDoge1xuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBXaWR0aCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLndpZHRoLicgKTtcblx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0c2hhZG93TWFwSGVpZ2h0OiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcEhlaWdodCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLmhlaWdodC4nICk7XG5cdFx0XHR0aGlzLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XG5cblx0bGVuZ3RoOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmNvdW50IGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuXG5cdFx0fVxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XG5cblx0YWRkSW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XG5cdFx0dGhpcy5zZXRJbmRleCggaW5kZXggKTtcblxuXHR9LFxuXHRhZGREcmF3Q2FsbDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluZGV4T2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIGluZGV4T2Zmc2V0LicgKTtcblxuXHRcdH1cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicgKTtcblx0XHR0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcblxuXHR9LFxuXHRjbGVhckRyYXdDYWxsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jbGVhckRyYXdDYWxscygpIGlzIG5vdyAuY2xlYXJHcm91cHMoKS4nICk7XG5cdFx0dGhpcy5jbGVhckdyb3VwcygpO1xuXG5cdH0sXG5cdGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXHRjb21wdXRlT2Zmc2V0czogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH1cblxufSApO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XG5cblx0ZHJhd2NhbGxzOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xuXG5cdFx0fVxuXHR9LFxuXHRvZmZzZXRzOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAub2Zmc2V0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xuXG5cdFx0fVxuXHR9XG5cbn0gKTtcblxuLy9cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFVuaWZvcm0ucHJvdG90eXBlLCB7XG5cblx0ZHluYW1pYzoge1xuXHRcdHNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Vbmlmb3JtOiAuZHluYW1pYyBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugb2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCkgaW5zdGVhZC4nICk7XG5cblx0XHR9XG5cdH0sXG5cdG9uVXBkYXRlOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogLm9uVXBkYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG9iamVjdC5vbkJlZm9yZVJlbmRlcigpIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cdH1cblxufSApO1xuXG4vL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTWF0ZXJpYWwucHJvdG90eXBlLCB7XG5cblx0d3JhcEFyb3VuZDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9XG5cdH0sXG5cdHdyYXBSR0I6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcigpO1xuXG5cdFx0fVxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSwge1xuXG5cdG1ldGFsOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsOiAubWV0YWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZCcgKTtcblxuXHRcdH1cblx0fVxuXG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUsIHtcblxuXHRkZXJpdmF0aXZlczoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXM7XG5cblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuIFNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xuXHRcdFx0dGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzID0gdmFsdWU7XG5cblx0XHR9XG5cdH1cblxufSApO1xuXG4vL1xuXG5PYmplY3QuYXNzaWduKCBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZSwge1xuXG5cdHN1cHBvcnRzRmxvYXRUZXh0dXJlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyApO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cblx0fSxcblx0c3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XFwnICkuJyApO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuXHR9LFxuXHRzdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXCcgKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cblx0fSxcblx0c3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyApO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cblx0fSxcblx0c3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXFwnICkuJyApO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG5cdH0sXG5cdHN1cHBvcnRzQmxlbmRNaW5NYXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnRVhUX2JsZW5kX21pbm1heFxcJyApLicgKTtcblx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cblx0fSxcblx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMoKSBpcyBub3cgLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcy4nICk7XG5cdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXG5cdH0sXG5cdHN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHR9LFxuXHRlbmFibGVTY2lzc29yVGVzdDogZnVuY3Rpb24gKCBib29sZWFuICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicgKTtcblx0XHR0aGlzLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XG5cblx0fSxcblx0aW5pdE1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblx0YWRkUHJlUGx1Z2luOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblx0YWRkUG9zdFBsdWdpbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXHR1cGRhdGVTaGFkb3dNYXA6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLCB7XG5cblx0c2hhZG93TWFwRW5hYmxlZDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuZW5hYmxlZDtcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLicgKTtcblx0XHRcdHRoaXMuc2hhZG93TWFwLmVuYWJsZWQgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0c2hhZG93TWFwVHlwZToge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAudHlwZTtcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcblx0XHRcdHRoaXMuc2hhZG93TWFwLnR5cGUgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLmN1bGxGYWNlO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS4nICk7XG5cdFx0XHR0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9XG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFNoYWRvd01hcC5wcm90b3R5cGUsIHtcblxuXHRjdWxsRmFjZToge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPyBDdWxsRmFjZUZyb250IDogQ3VsbEZhY2VCYWNrO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggY3VsbEZhY2UgKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9ICggY3VsbEZhY2UgIT09IEN1bGxGYWNlQmFjayApO1xuXHRcdFx0Y29uc29sZS53YXJuKCBcIldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAuY3VsbEZhY2UgaXMgZGVwcmVjYXRlZC4gU2V0IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIHRvIFwiICsgdmFsdWUgKyBcIi5cIiApO1xuXHRcdFx0dGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPSB2YWx1ZTtcblxuXHRcdH1cblx0fVxuXG59ICk7XG5cbi8vXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcblxuXHR3cmFwUzoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS53cmFwUyA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHR3cmFwVDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBUO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS53cmFwVCA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRtYWdGaWx0ZXI6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0bWluRmlsdGVyOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XG5cblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XG5cdFx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XG5cblx0XHR9XG5cdH0sXG5cdGFuaXNvdHJvcHk6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuYW5pc290cm9weTtcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmFuaXNvdHJvcHkgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0b2Zmc2V0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5vZmZzZXQ7XG5cblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XG5cdFx0XHR0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XG5cblx0XHR9XG5cdH0sXG5cdHJlcGVhdDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LicgKTtcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xuXHRcdFx0dGhpcy50ZXh0dXJlLnJlcGVhdCA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRmb3JtYXQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmZvcm1hdDtcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS5mb3JtYXQgPSB2YWx1ZTtcblxuXHRcdH1cblx0fSxcblx0dHlwZToge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS50eXBlO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XG5cdFx0XHR0aGlzLnRleHR1cmUudHlwZSA9IHZhbHVlO1xuXG5cdFx0fVxuXHR9LFxuXHRnZW5lcmF0ZU1pcG1hcHM6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB2YWx1ZTtcblxuXHRcdH1cblx0fVxuXG59ICk7XG5cbi8vXG5cbkF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiAubG9hZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQXVkaW9Mb2FkZXIgaW5zdGVhZC4nICk7XG5cdHZhciBzY29wZSA9IHRoaXM7XG5cdHZhciBhdWRpb0xvYWRlciA9IG5ldyBBdWRpb0xvYWRlcigpO1xuXHRhdWRpb0xvYWRlci5sb2FkKCBmaWxlLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdHNjb3BlLnNldEJ1ZmZlciggYnVmZmVyICk7XG5cblx0fSApO1xuXHRyZXR1cm4gdGhpcztcblxufTtcblxuQXVkaW9BbmFseXNlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpb0FuYWx5c2VyOiAuZ2V0RGF0YSgpIGlzIG5vdyAuZ2V0RnJlcXVlbmN5RGF0YSgpLicgKTtcblx0cmV0dXJuIHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xuXG59O1xuXG4vL1xuXG52YXIgR2VvbWV0cnlVdGlscyA9IHtcblxuXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XG5cdFx0dmFyIG1hdHJpeDtcblxuXHRcdGlmICggZ2VvbWV0cnkyLmlzTWVzaCApIHtcblxuXHRcdFx0Z2VvbWV0cnkyLm1hdHJpeEF1dG9VcGRhdGUgJiYgZ2VvbWV0cnkyLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHRtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xuXHRcdFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkyLmdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkxLm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLmNlbnRlcigpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkuY2VudGVyKCkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xuXG5cdH1cblxufTtcblxudmFyIEltYWdlVXRpbHMgPSB7XG5cblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLlRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG5cdFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIHVybHMsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBDdWJlVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcblxuXHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9LFxuXG5cdGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XG5cblx0fSxcblxuXHRsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XG5cblx0fVxuXG59O1xuXG4vL1xuXG5mdW5jdGlvbiBQcm9qZWN0b3IoKSB7XG5cblx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XG5cblx0dGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG5cdFx0dmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xuXG5cdH07XG5cblx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XG5cdFx0dmVjdG9yLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0fTtcblxuXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yOiAucGlja2luZ1JheSgpIGlzIG5vdyByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSgpLicgKTtcblxuXHR9O1xuXG59XG5cbi8vXG5cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKCkge1xuXG5cdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL0NhbnZhc1JlbmRlcmVyLmpzJyApO1xuXG5cdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge307XG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XG5cdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHt9O1xuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7fTtcblxufVxuXG5leHBvcnQgeyBXZWJHTFJlbmRlclRhcmdldEN1YmUsIFdlYkdMUmVuZGVyVGFyZ2V0LCBXZWJHTFJlbmRlcmVyLCBTaGFkZXJMaWIsIFVuaWZvcm1zTGliLCBVbmlmb3Jtc1V0aWxzLCBTaGFkZXJDaHVuaywgRm9nRXhwMiwgRm9nLCBTY2VuZSwgTGVuc0ZsYXJlLCBTcHJpdGUsIExPRCwgU2tpbm5lZE1lc2gsIFNrZWxldG9uLCBCb25lLCBNZXNoLCBMaW5lU2VnbWVudHMsIExpbmUsIFBvaW50cywgR3JvdXAsIFZpZGVvVGV4dHVyZSwgRGF0YVRleHR1cmUsIENvbXByZXNzZWRUZXh0dXJlLCBDdWJlVGV4dHVyZSwgQ2FudmFzVGV4dHVyZSwgRGVwdGhUZXh0dXJlLCBUZXh0dXJlLCBDb21wcmVzc2VkVGV4dHVyZUxvYWRlciwgRGF0YVRleHR1cmVMb2FkZXIsIEN1YmVUZXh0dXJlTG9hZGVyLCBUZXh0dXJlTG9hZGVyLCBPYmplY3RMb2FkZXIsIE1hdGVyaWFsTG9hZGVyLCBCdWZmZXJHZW9tZXRyeUxvYWRlciwgRGVmYXVsdExvYWRpbmdNYW5hZ2VyLCBMb2FkaW5nTWFuYWdlciwgSlNPTkxvYWRlciwgSW1hZ2VMb2FkZXIsIEZvbnRMb2FkZXIsIEZpbGVMb2FkZXIsIExvYWRlciwgQ2FjaGUsIEF1ZGlvTG9hZGVyLCBTcG90TGlnaHRTaGFkb3csIFNwb3RMaWdodCwgUG9pbnRMaWdodCwgUmVjdEFyZWFMaWdodCwgSGVtaXNwaGVyZUxpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0U2hhZG93LCBEaXJlY3Rpb25hbExpZ2h0LCBBbWJpZW50TGlnaHQsIExpZ2h0U2hhZG93LCBMaWdodCwgU3RlcmVvQ2FtZXJhLCBQZXJzcGVjdGl2ZUNhbWVyYSwgT3J0aG9ncmFwaGljQ2FtZXJhLCBDdWJlQ2FtZXJhLCBDYW1lcmEsIEF1ZGlvTGlzdGVuZXIsIFBvc2l0aW9uYWxBdWRpbywgQXVkaW9Db250ZXh0LCBBdWRpb0FuYWx5c2VyLCBBdWRpbywgVmVjdG9yS2V5ZnJhbWVUcmFjaywgU3RyaW5nS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIE51bWJlcktleWZyYW1lVHJhY2ssIENvbG9yS2V5ZnJhbWVUcmFjaywgQm9vbGVhbktleWZyYW1lVHJhY2ssIFByb3BlcnR5TWl4ZXIsIFByb3BlcnR5QmluZGluZywgS2V5ZnJhbWVUcmFjaywgQW5pbWF0aW9uVXRpbHMsIEFuaW1hdGlvbk9iamVjdEdyb3VwLCBBbmltYXRpb25NaXhlciwgQW5pbWF0aW9uQ2xpcCwgVW5pZm9ybSwgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckdlb21ldHJ5LCBHZW9tZXRyeUlkQ291bnQsIEdlb21ldHJ5LCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyLCBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsIEZhY2UzLCBPYmplY3QzRCwgUmF5Y2FzdGVyLCBMYXllcnMsIEV2ZW50RGlzcGF0Y2hlciwgQ2xvY2ssIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCwgTGluZWFySW50ZXJwb2xhbnQsIERpc2NyZXRlSW50ZXJwb2xhbnQsIEN1YmljSW50ZXJwb2xhbnQsIEludGVycG9sYW50LCBUcmlhbmdsZSwgX01hdGggYXMgTWF0aCwgU3BoZXJpY2FsLCBDeWxpbmRyaWNhbCwgUGxhbmUsIEZydXN0dW0sIFNwaGVyZSwgUmF5LCBNYXRyaXg0LCBNYXRyaXgzLCBCb3gzLCBCb3gyLCBMaW5lMywgRXVsZXIsIFZlY3RvcjQsIFZlY3RvcjMsIFZlY3RvcjIsIFF1YXRlcm5pb24sIENvbG9yLCBNb3JwaEJsZW5kTWVzaCwgSW1tZWRpYXRlUmVuZGVyT2JqZWN0LCBWZXJ0ZXhOb3JtYWxzSGVscGVyLCBTcG90TGlnaHRIZWxwZXIsIFNrZWxldG9uSGVscGVyLCBQb2ludExpZ2h0SGVscGVyLCBSZWN0QXJlYUxpZ2h0SGVscGVyLCBIZW1pc3BoZXJlTGlnaHRIZWxwZXIsIEdyaWRIZWxwZXIsIFBvbGFyR3JpZEhlbHBlciwgRmFjZU5vcm1hbHNIZWxwZXIsIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIsIENhbWVyYUhlbHBlciwgQm94SGVscGVyLCBBcnJvd0hlbHBlciwgQXhpc0hlbHBlciwgQ2F0bXVsbFJvbUN1cnZlMywgQ3ViaWNCZXppZXJDdXJ2ZTMsIFF1YWRyYXRpY0JlemllckN1cnZlMywgTGluZUN1cnZlMywgQXJjQ3VydmUsIEVsbGlwc2VDdXJ2ZSwgU3BsaW5lQ3VydmUsIEN1YmljQmV6aWVyQ3VydmUsIFF1YWRyYXRpY0JlemllckN1cnZlLCBMaW5lQ3VydmUsIFNoYXBlLCBQYXRoLCBTaGFwZVBhdGgsIEZvbnQsIEN1cnZlUGF0aCwgQ3VydmUsIFNoYXBlVXRpbHMsIFNjZW5lVXRpbHMsIFdpcmVmcmFtZUdlb21ldHJ5LCBQYXJhbWV0cmljR2VvbWV0cnksIFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSwgVGV0cmFoZWRyb25HZW9tZXRyeSwgVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSwgT2N0YWhlZHJvbkdlb21ldHJ5LCBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnksIEljb3NhaGVkcm9uR2VvbWV0cnksIEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnksIERvZGVjYWhlZHJvbkdlb21ldHJ5LCBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSwgUG9seWhlZHJvbkdlb21ldHJ5LCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnksIFR1YmVHZW9tZXRyeSwgVHViZUJ1ZmZlckdlb21ldHJ5LCBUb3J1c0tub3RHZW9tZXRyeSwgVG9ydXNLbm90QnVmZmVyR2VvbWV0cnksIFRvcnVzR2VvbWV0cnksIFRvcnVzQnVmZmVyR2VvbWV0cnksIFRleHRHZW9tZXRyeSwgU3BoZXJlR2VvbWV0cnksIFNwaGVyZUJ1ZmZlckdlb21ldHJ5LCBSaW5nR2VvbWV0cnksIFJpbmdCdWZmZXJHZW9tZXRyeSwgUGxhbmVHZW9tZXRyeSwgUGxhbmVCdWZmZXJHZW9tZXRyeSwgTGF0aGVHZW9tZXRyeSwgTGF0aGVCdWZmZXJHZW9tZXRyeSwgU2hhcGVHZW9tZXRyeSwgU2hhcGVCdWZmZXJHZW9tZXRyeSwgRXh0cnVkZUdlb21ldHJ5LCBFZGdlc0dlb21ldHJ5LCBDb25lR2VvbWV0cnksIENvbmVCdWZmZXJHZW9tZXRyeSwgQ3lsaW5kZXJHZW9tZXRyeSwgQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSwgQ2lyY2xlR2VvbWV0cnksIENpcmNsZUJ1ZmZlckdlb21ldHJ5LCBCb3hHZW9tZXRyeSwgQm94QnVmZmVyR2VvbWV0cnksIFNoYWRvd01hdGVyaWFsLCBTcHJpdGVNYXRlcmlhbCwgUmF3U2hhZGVyTWF0ZXJpYWwsIFNoYWRlck1hdGVyaWFsLCBQb2ludHNNYXRlcmlhbCwgTXVsdGlNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBNZXNoUGhvbmdNYXRlcmlhbCwgTWVzaFRvb25NYXRlcmlhbCwgTWVzaE5vcm1hbE1hdGVyaWFsLCBNZXNoTGFtYmVydE1hdGVyaWFsLCBNZXNoRGVwdGhNYXRlcmlhbCwgTWVzaEJhc2ljTWF0ZXJpYWwsIExpbmVEYXNoZWRNYXRlcmlhbCwgTGluZUJhc2ljTWF0ZXJpYWwsIE1hdGVyaWFsLCBGbG9hdDY0QnVmZmVyQXR0cmlidXRlLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUsIEludDMyQnVmZmVyQXR0cmlidXRlLCBVaW50MTZCdWZmZXJBdHRyaWJ1dGUsIEludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUsIFVpbnQ4QnVmZmVyQXR0cmlidXRlLCBJbnQ4QnVmZmVyQXR0cmlidXRlLCBCdWZmZXJBdHRyaWJ1dGUsIFJFVklTSU9OLCBNT1VTRSwgQ3VsbEZhY2VOb25lLCBDdWxsRmFjZUJhY2ssIEN1bGxGYWNlRnJvbnQsIEN1bGxGYWNlRnJvbnRCYWNrLCBGcm9udEZhY2VEaXJlY3Rpb25DVywgRnJvbnRGYWNlRGlyZWN0aW9uQ0NXLCBCYXNpY1NoYWRvd01hcCwgUENGU2hhZG93TWFwLCBQQ0ZTb2Z0U2hhZG93TWFwLCBGcm9udFNpZGUsIEJhY2tTaWRlLCBEb3VibGVTaWRlLCBGbGF0U2hhZGluZywgU21vb3RoU2hhZGluZywgTm9Db2xvcnMsIEZhY2VDb2xvcnMsIFZlcnRleENvbG9ycywgTm9CbGVuZGluZywgTm9ybWFsQmxlbmRpbmcsIEFkZGl0aXZlQmxlbmRpbmcsIFN1YnRyYWN0aXZlQmxlbmRpbmcsIE11bHRpcGx5QmxlbmRpbmcsIEN1c3RvbUJsZW5kaW5nLCBBZGRFcXVhdGlvbiwgU3VidHJhY3RFcXVhdGlvbiwgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24sIE1pbkVxdWF0aW9uLCBNYXhFcXVhdGlvbiwgWmVyb0ZhY3RvciwgT25lRmFjdG9yLCBTcmNDb2xvckZhY3RvciwgT25lTWludXNTcmNDb2xvckZhY3RvciwgU3JjQWxwaGFGYWN0b3IsIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IsIERzdEFscGhhRmFjdG9yLCBPbmVNaW51c0RzdEFscGhhRmFjdG9yLCBEc3RDb2xvckZhY3RvciwgT25lTWludXNEc3RDb2xvckZhY3RvciwgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciwgTmV2ZXJEZXB0aCwgQWx3YXlzRGVwdGgsIExlc3NEZXB0aCwgTGVzc0VxdWFsRGVwdGgsIEVxdWFsRGVwdGgsIEdyZWF0ZXJFcXVhbERlcHRoLCBHcmVhdGVyRGVwdGgsIE5vdEVxdWFsRGVwdGgsIE11bHRpcGx5T3BlcmF0aW9uLCBNaXhPcGVyYXRpb24sIEFkZE9wZXJhdGlvbiwgTm9Ub25lTWFwcGluZywgTGluZWFyVG9uZU1hcHBpbmcsIFJlaW5oYXJkVG9uZU1hcHBpbmcsIFVuY2hhcnRlZDJUb25lTWFwcGluZywgQ2luZW9uVG9uZU1hcHBpbmcsIFVWTWFwcGluZywgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZywgU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZywgUmVwZWF0V3JhcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgVW5zaWduZWRCeXRlVHlwZSwgQnl0ZVR5cGUsIFNob3J0VHlwZSwgVW5zaWduZWRTaG9ydFR5cGUsIEludFR5cGUsIFVuc2lnbmVkSW50VHlwZSwgRmxvYXRUeXBlLCBIYWxmRmxvYXRUeXBlLCBVbnNpZ25lZFNob3J0NDQ0NFR5cGUsIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSwgVW5zaWduZWRTaG9ydDU2NVR5cGUsIFVuc2lnbmVkSW50MjQ4VHlwZSwgQWxwaGFGb3JtYXQsIFJHQkZvcm1hdCwgUkdCQUZvcm1hdCwgTHVtaW5hbmNlRm9ybWF0LCBMdW1pbmFuY2VBbHBoYUZvcm1hdCwgUkdCRUZvcm1hdCwgRGVwdGhGb3JtYXQsIERlcHRoU3RlbmNpbEZvcm1hdCwgUkdCX1MzVENfRFhUMV9Gb3JtYXQsIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDNfRm9ybWF0LCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQsIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0LCBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0LCBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQsIFJHQl9FVEMxX0Zvcm1hdCwgTG9vcE9uY2UsIExvb3BSZXBlYXQsIExvb3BQaW5nUG9uZywgSW50ZXJwb2xhdGVEaXNjcmV0ZSwgSW50ZXJwb2xhdGVMaW5lYXIsIEludGVycG9sYXRlU21vb3RoLCBaZXJvQ3VydmF0dXJlRW5kaW5nLCBaZXJvU2xvcGVFbmRpbmcsIFdyYXBBcm91bmRFbmRpbmcsIFRyaWFuZ2xlc0RyYXdNb2RlLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIExpbmVhckVuY29kaW5nLCBzUkdCRW5jb2RpbmcsIEdhbW1hRW5jb2RpbmcsIFJHQkVFbmNvZGluZywgTG9nTHV2RW5jb2RpbmcsIFJHQk03RW5jb2RpbmcsIFJHQk0xNkVuY29kaW5nLCBSR0JERW5jb2RpbmcsIEJhc2ljRGVwdGhQYWNraW5nLCBSR0JBRGVwdGhQYWNraW5nLCBCb3hHZW9tZXRyeSBhcyBDdWJlR2VvbWV0cnksIEZhY2U0LCBMaW5lU3RyaXAsIExpbmVQaWVjZXMsIE1lc2hGYWNlTWF0ZXJpYWwsIFBvaW50Q2xvdWQsIFBhcnRpY2xlLCBQYXJ0aWNsZVN5c3RlbSwgUG9pbnRDbG91ZE1hdGVyaWFsLCBQYXJ0aWNsZUJhc2ljTWF0ZXJpYWwsIFBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwsIFZlcnRleCwgRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSwgSW50OEF0dHJpYnV0ZSwgVWludDhBdHRyaWJ1dGUsIFVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSwgSW50MTZBdHRyaWJ1dGUsIFVpbnQxNkF0dHJpYnV0ZSwgSW50MzJBdHRyaWJ1dGUsIFVpbnQzMkF0dHJpYnV0ZSwgRmxvYXQzMkF0dHJpYnV0ZSwgRmxvYXQ2NEF0dHJpYnV0ZSwgQ2xvc2VkU3BsaW5lQ3VydmUzLCBTcGxpbmVDdXJ2ZTMsIFNwbGluZSwgQm91bmRpbmdCb3hIZWxwZXIsIEVkZ2VzSGVscGVyLCBXaXJlZnJhbWVIZWxwZXIsIFhIUkxvYWRlciwgQmluYXJ5VGV4dHVyZUxvYWRlciwgR2VvbWV0cnlVdGlscywgSW1hZ2VVdGlscywgUHJvamVjdG9yLCBDYW52YXNSZW5kZXJlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RocmVlL2J1aWxkL3RocmVlLm1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDIuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCdXR0b24gZnJvbSAnLi9fX2J1dHRvbi9mb3JtLWJ1dHRvbidcclxuaW1wb3J0IElucHV0IGZyb20gJy4vX19pbnB1dC9mb3JtLWlucHV0J1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7ZGF0YToge319KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzID0gW107XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9zZXRBdHRycyh0aGlzLmRhdGEuZm9ybS5hdHRycywgdGhpcy5lbCk7XHJcbiAgICAgICAgbGV0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmRhdGEudGl0bGUudHlwZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cnModGhpcy5kYXRhLnRpdGxlLmF0dHJzLCB0aXRsZSk7XHJcbiAgICAgICAgdGl0bGUuaW5uZXJIVE1MID0gdGhpcy5kYXRhLnRpdGxlLnRleHQ7XHJcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aXRsZSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmZpZWxkcyA9IHRoaXMuX2dldEZpZWxkcygpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMgPSB0aGlzLl9nZXRDb250cm9scygpO1xyXG4gICAgICAgIHRoaXMuX2ZpZWxkc0FwcGVuZFRvKHRoaXMuZmllbGRzLCB0aGlzLmVsKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29udHJvbHNBcHBlbmRUbyh0aGlzLmNvbnRyb2xzLCB0aGlzLmVsKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFbGVtKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldEZpZWxkcygpIHtcclxuICAgICAgICBsZXQge2ZpZWxkcyA9IFtdfT10aGlzLmRhdGE7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5wdXQoZGF0YSkuZ2V0RWxlbSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9zZXRBdHRycyhhdHRycywgZWxlbSkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBfZmllbGRzQXBwZW5kVG8oYXJyYXksIGVsZW0pIHtcclxuICAgICAgICBhcnJheS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGl0ZW0uZWwpO1xyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGl0ZW0uaGVscF9lbCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBfY29udHJvbHNBcHBlbmRUbyhhcnJheSwgZWxlbSkge1xyXG4gICAgICAgIGFycmF5LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoaXRlbS5lbCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0Q29udHJvbHMoKSB7XHJcbiAgICAgICAgbGV0IHtjb250cm9scyA9IFtdfT10aGlzLmRhdGE7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzLm1hcChkYXRhID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdXR0b24oZGF0YSkuZ2V0RWxlbSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsLm91dGVySFRNTDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRGb3JtRGF0YSgpIHtcclxuICAgICAgICBsZXQgZWxlbWVudHMgPSB0aGlzLmVsLmVsZW1lbnRzO1xyXG4gICAgICAgIGxldCBmaWVsZHMgPSB7fTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudHMpLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBuYW1lID0gZWxlbWVudHNbZWxlbWVudF0ubmFtZTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudHNbZWxlbWVudF0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmllbGRzW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkcztcclxuICAgIH1cclxufVxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZWxlbWVudHMvZm9ybS9mb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwMi4wNC4yMDE3LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2luZ2xlUGxheWVyU3RyYXRlZ3l7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2FtZUxvb3AoKXtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRHYW1lTG9vcCgpIHtcclxuICAgICAgICB0aGlzLmludGV2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmdhbWVMb29wKCksIDEwMCk7XHJcbiAgICB9XHJcblxyXG5cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWUvbW9kdWxlcy9zdHJhdGVnaWVzL1NpbmdsZXBsYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDMuMDMuMjAxNy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrRmllbGRzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgX2NoZWNrTGF0aW4odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWF0Y2goL1vQsC3Rj9CQLdCv0ZHQgV0rLykgPT09IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNoZWNrTG9naW4ob2JqKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tMYXRpbihvYmouZmllbGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGVycl90ZXh0OiAnT25seSBMYXRpbicsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmouZmllbGQudmFsdWUubGVuZ3RoIDwgNCkge1xyXG4gICAgICAgICAgICBhcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBlcnJfdGV4dDogJzQgLSBtaW4gbGVuZ3RoJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvYmouaGVscC50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgIGFyci5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkU2V0RXJyKG9iai5maWVsZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRSZW1vdmVPayhvYmouZmllbGQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9iai5oZWxwLnRleHRDb250ZW50ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgb2JqLmhlbHAudGV4dENvbnRlbnQgPSBpdGVtLmVycl90ZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2JqLmhlbHAudGV4dENvbnRlbnQgPSBgJHtvYmouaGVscC50ZXh0Q29udGVudH0sJHtpdGVtLmVycl90ZXh0fWA7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhvYmouaGVscC50ZXh0Q29udGVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5maWVsZFNldE9rKG9iai5maWVsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgX2NoZWNrUGFzc0xlbmd0aCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gODtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgX2NoZWNrUGFzc0VxdWFscyh2YWx1ZTEsIHZhbHVlMikge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgY2hlY2tFbXB0eSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyBjaGVja1Bhc3N3b3JkKG9iajEsIG9iajIpIHtcclxuICAgICAgICBsZXQgYXJyID0gW107XHJcbiAgICAgICAgbGV0IGNoZWNrID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKGNoZWNrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tQYXNzTGVuZ3RoKG9iajEuZmllbGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyX3RleHQ6ICc4IC0gbWluIGxlbmd0aCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG9iajEuZmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVscDogb2JqMS5oZWxwXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tQYXNzRXF1YWxzKG9iajEuZmllbGQudmFsdWUsIG9iajIuZmllbGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyX3RleHQ6ICdQYXNzd29yZHMgbm90IGVxdWFscycsXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG9iajEuZmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVscDogb2JqMS5oZWxwXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJfdGV4dDogJ1Bhc3N3b3JkcyBub3QgZXF1YWxzJyxcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogb2JqMi5maWVsZCxcclxuICAgICAgICAgICAgICAgICAgICBoZWxwOiBvYmoyLmhlbHBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvYmoxLmhlbHAudGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICBvYmoyLmhlbHAudGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICBhcnIuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgdGhpcy5maWVsZFNldEVycihpdGVtLmZpZWxkKTtcclxuICAgICAgICAgICAgdGhpcy5maWVsZFJlbW92ZU9rKGl0ZW0uZmllbGQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW0uaGVscC50ZXh0Q29udGVudCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0uaGVscC50ZXh0Q29udGVudCA9IGl0ZW0uZXJyX3RleHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmhlbHAudGV4dENvbnRlbnQgPSBgJHtpdGVtLmhlbHAudGV4dENvbnRlbnR9LiR7aXRlbS5lcnJfdGV4dH1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRTZXRPayhvYmoxLmZpZWxkKTtcclxuICAgICAgICAgICAgdGhpcy5maWVsZFNldE9rKG9iajIuZmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaGVscFNldFRleHQoZWxlbSwgdmFsdWUpIHtcclxuICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZpZWxkU2V0VGV4dChlbGVtLCB2YWx1ZSkge1xyXG4gICAgICAgIGVsZW0udmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZmllbGRTZXRFcnIoZWxlbSkge1xyXG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZCgnZm9ybV9faW5wdXRfZXJyb3InKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZmllbGRSZW1vdmVFcnIoZWxlbSkge1xyXG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnZm9ybV9faW5wdXRfZXJyb3InKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZmllbGRTZXRPayhlbGVtKSB7XHJcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKCdmb3JtX19pbnB1dF9vaycpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmaWVsZFJlbW92ZU9rKGVsZW0pIHtcclxuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2Zvcm1fX2lucHV0X29rJyk7XHJcbiAgICB9XHJcblxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL21lbnUvYWN0aW9ucy9DaGVja0ZpZWxkcy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMjQuMDMuMjAxNy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlclVybHN7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuTUFJTiA9ICcvJztcclxuICAgICAgICB0aGlzLkxPR0lOID0gJy9sb2dpbic7XHJcbiAgICAgICAgdGhpcy5TSUdOVVAgPSAnL3NpZ251cCc7XHJcbiAgICAgICAgdGhpcy5MRUFERVJCT0FSRCA9ICcvbGVhZGVyYm9hcmQnO1xyXG4gICAgICAgIHRoaXMuQUJPVVQgPSAnL2Fib3V0JztcclxuICAgICAgICB0aGlzLlBST0ZJTEUgPSAnL3Byb2ZpbGUnO1xyXG5cclxuICAgICAgICB0aGlzLkdBTUUgPSAnL2dhbWUnO1xyXG4gICAgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvc3VwcG9ydC9yb3V0ZXIvUm91dGVyVXJscy5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDQuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBSb3V0ZXIgZnJvbSBcIi4vc3VwcG9ydC9yb3V0ZXIvUm91dGVyXCI7XHJcbmltcG9ydCBNZW51VmlldyBmcm9tIFwiLi4vdmlld3MvbWVudS12aWV3L01lbnVWaWV3XCI7XHJcbmltcG9ydCBMb2dpblZpZXcgZnJvbSBcIi4uL3ZpZXdzL2VudGVyLXZpZXdzL0xvZ2luVmlld1wiO1xyXG5pbXBvcnQgU2lnblVwVmlldyBmcm9tIFwiLi4vdmlld3MvZW50ZXItdmlld3MvU2lnblVwVmlld1wiO1xyXG5pbXBvcnQgTGVhZGVyQm9hcmRWaWV3IGZyb20gXCIuLi92aWV3cy9sZWFkZXJib2FyZC12aWV3L0xlYWRlckJvYXJkVmlld1wiO1xyXG5pbXBvcnQgQWJvdXRWaWV3IGZyb20gXCIuLi92aWV3cy9hYm91dC12aWV3L0Fib3V0Vmlld1wiO1xyXG5pbXBvcnQgUHJvZmlsZVZpZXcgZnJvbSBcIi4uL3ZpZXdzL3Byb2ZpbGUtdmlldy9Qcm9maWxlVmlld1wiO1xyXG5pbXBvcnQgR2FtZVZpZXcgZnJvbSBcIi4uL3ZpZXdzL2dhbWUtdmlldy9HYW1lVmlld1wiO1xyXG5cclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuL3N1cHBvcnQvc2VydmljZS9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tICcuL2dhbWUvb2JqZWN0L1N0b3JhZ2UnO1xyXG5cclxubmV3IFVzZXJTZXJ2aWNlKCkuZ2V0VXNlcigpLnRoZW4odXNlciA9PiB7XHJcbiAgICBTdG9yYWdlLnVzZXIgPSB1c2VyO1xyXG4gICAgc3RhcnRSb3V0ZSgpO1xyXG59KS5jYXRjaChlcnIgPT4ge1xyXG4gICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgIHN0YXJ0Um91dGUoKTtcclxufSk7XHJcblxyXG5cclxuZnVuY3Rpb24gc3RhcnRSb3V0ZSgpIHtcclxuICAgIGxldCByb3V0ZXIgPSBuZXcgUm91dGVyKHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xyXG4gICAgcm91dGVyLmluaXQoe1xyXG4gICAgICAgICcvJzoge1xyXG4gICAgICAgICAgICBWaWV3OiBNZW51VmlldyxcclxuICAgICAgICAgICAgZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51LXZpZXcnKSxcclxuICAgICAgICB9LFxyXG4gICAgICAgICcvbG9naW4nOiB7XHJcbiAgICAgICAgICAgIFZpZXc6IExvZ2luVmlldyxcclxuICAgICAgICAgICAgZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dpbi12aWV3JylcclxuICAgICAgICB9LFxyXG4gICAgICAgICcvc2lnbnVwJzoge1xyXG4gICAgICAgICAgICBWaWV3OiBTaWduVXBWaWV3LFxyXG4gICAgICAgICAgICBlbDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpZ251cC12aWV3JylcclxuICAgICAgICB9LFxyXG4gICAgICAgICcvbGVhZGVyYm9hcmQnOiB7XHJcbiAgICAgICAgICAgIFZpZXc6IExlYWRlckJvYXJkVmlldyxcclxuICAgICAgICAgICAgZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsZWFkZXJib2FyZC12aWV3JylcclxuICAgICAgICB9LFxyXG4gICAgICAgICcvYWJvdXQnOiB7XHJcbiAgICAgICAgICAgIFZpZXc6IEFib3V0VmlldyxcclxuICAgICAgICAgICAgZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhYm91dC12aWV3JylcclxuICAgICAgICB9LFxyXG4gICAgICAgICcvcHJvZmlsZSc6IHtcclxuICAgICAgICAgICAgVmlldzogUHJvZmlsZVZpZXcsXHJcbiAgICAgICAgICAgIGVsOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZmlsZS12aWV3JylcclxuICAgICAgICB9LFxyXG4gICAgICAgICcvZ2FtZSc6IHtcclxuICAgICAgICAgICAgVmlldzogR2FtZVZpZXcsXHJcbiAgICAgICAgICAgIGVsOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZS12aWV3JylcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByb3V0ZXIuc3RhcnQoKTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvQXBwbGljYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qXHJcbiAqIGl6aVRvYXN0IHwgdjEuMS4wXHJcbiAqIGh0dHA6Ly9peml0b2FzdC5tYXJjZWxvZG9sY2UuY29tXHJcbiAqIGJ5IE1hcmNlbG8gRG9sY2UuXHJcbiAqLyBcclxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KHJvb3QpKTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyb290Lml6aVRvYXN0ID0gZmFjdG9yeShyb290KTtcclxuXHR9XHJcbn0pKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0aGlzLndpbmRvdyB8fCB0aGlzLmdsb2JhbCwgZnVuY3Rpb24gKHJvb3QpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHQvL1xyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdC8vXHJcblx0dmFyICRpemlUb2FzdCA9IHt9LFxyXG5cdFx0UExVR0lOX05BTUUgPSAnaXppVG9hc3QnLFxyXG5cdFx0Qk9EWSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSxcclxuXHRcdElTTU9CSUxFID0gKC9Nb2JpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSA/IHRydWUgOiBmYWxzZSxcclxuXHRcdElTQ0hST01FID0gL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvR29vZ2xlIEluYy8udGVzdChuYXZpZ2F0b3IudmVuZG9yKSxcclxuXHRcdElTRklSRUZPWCA9IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcsXHJcblx0XHRBQ0NFUFRTVE9VQ0ggPSAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblx0XHRQT1NJVElPTlMgPSBbJ2JvdHRvbVJpZ2h0JywnYm90dG9tTGVmdCcsJ2JvdHRvbUNlbnRlcicsJ3RvcFJpZ2h0JywndG9wTGVmdCcsJ3RvcENlbnRlcicsJ2NlbnRlciddLFxyXG5cdFx0VEhFTUVTID0ge1xyXG5cdFx0XHRpbmZvOiB7XHJcblx0XHRcdFx0Y29sb3I6IFwiYmx1ZVwiLFxyXG5cdFx0XHRcdGljb246IFwiaWNvLWluZm9cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzdWNjZXNzOiB7XHJcblx0XHRcdFx0Y29sb3I6IFwiZ3JlZW5cIixcclxuXHRcdFx0XHRpY29uOiBcImljby1jaGVja1wiLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHR3YXJuaW5nOiB7XHJcblx0XHRcdFx0Y29sb3I6IFwieWVsbG93XCIsXHJcblx0XHRcdFx0aWNvbjogXCJpY28td2FybmluZ1wiLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRlcnJvcjoge1xyXG5cdFx0XHRcdGNvbG9yOiBcInJlZFwiLFxyXG5cdFx0XHRcdGljb246IFwiaWNvLWVycm9yXCIsXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRNT0JJTEVXSURUSCA9IDU2OCxcclxuXHRcdENPTkZJRyA9IHt9O1xyXG5cclxuXHQvLyBEZWZhdWx0IHNldHRpbmdzXHJcblx0dmFyIGRlZmF1bHRzID0ge1xyXG5cdFx0Y2xhc3M6ICcnLFxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cdFx0dGl0bGVDb2xvcjogJycsXHJcblx0XHRtZXNzYWdlOiAnJyxcclxuXHRcdG1lc3NhZ2VDb2xvcjogJycsXHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICcnLFxyXG5cdFx0Y29sb3I6ICcnLCAvLyBibHVlLCByZWQsIGdyZWVuLCB5ZWxsb3dcclxuXHRcdGljb246ICcnLFxyXG5cdFx0aWNvblRleHQ6ICcnLFxyXG5cdFx0aWNvbkNvbG9yOiAnJyxcclxuXHRcdGltYWdlOiAnJyxcclxuXHRcdGltYWdlV2lkdGg6IDUwLFxyXG5cdFx0emluZGV4OiA5OTk5OSxcclxuXHRcdGxheW91dDogMSxcclxuXHRcdGJhbGxvb246IGZhbHNlLFxyXG5cdFx0Y2xvc2U6IHRydWUsXHJcblx0XHRydGw6IGZhbHNlLFxyXG5cdFx0cG9zaXRpb246ICdib3R0b21SaWdodCcsIC8vIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgdG9wTGVmdCwgdG9wQ2VudGVyLCBib3R0b21DZW50ZXIsIGNlbnRlclxyXG5cdFx0dGFyZ2V0OiAnJyxcclxuXHRcdHRhcmdldEZpcnN0OiB0cnVlLFxyXG5cdFx0dGltZW91dDogNTAwMCxcclxuXHRcdGRyYWc6IHRydWUsXHJcblx0XHRwYXVzZU9uSG92ZXI6IHRydWUsXHJcblx0XHRyZXNldE9uSG92ZXI6IGZhbHNlLFxyXG5cdFx0cHJvZ3Jlc3NCYXI6IHRydWUsXHJcblx0XHRwcm9ncmVzc0JhckNvbG9yOiAnJyxcclxuXHRcdGFuaW1hdGVJbnNpZGU6IHRydWUsXHJcblx0XHRidXR0b25zOiB7fSxcclxuXHRcdHRyYW5zaXRpb25JbjogJ2ZhZGVJblVwJywgLy8gYm91bmNlSW5MZWZ0LCBib3VuY2VJblJpZ2h0LCBib3VuY2VJblVwLCBib3VuY2VJbkRvd24sIGZhZGVJbiwgZmFkZUluRG93biwgZmFkZUluVXAsIGZhZGVJbkxlZnQsIGZhZGVJblJpZ2h0LCBmbGlwSW5YXHJcblx0XHR0cmFuc2l0aW9uT3V0OiAnZmFkZU91dCcsIC8vIGZhZGVPdXQsIGZhZGVPdXRVcCwgZmFkZU91dERvd24sIGZhZGVPdXRMZWZ0LCBmYWRlT3V0UmlnaHQsIGZsaXBPdXRYXHJcblx0XHR0cmFuc2l0aW9uSW5Nb2JpbGU6ICdmYWRlSW5VcCcsXHJcblx0XHR0cmFuc2l0aW9uT3V0TW9iaWxlOiAnZmFkZU91dERvd24nLFxyXG5cdFx0b25PcGVuOiBmdW5jdGlvbiAoKSB7fSxcclxuXHRcdG9uQ2xvc2U6IGZ1bmN0aW9uICgpIHt9XHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHQvLyBNZXRob2RzXHJcblx0Ly9cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBvbHlmaWxsIGZvciByZW1vdmUoKSBtZXRob2RcclxuXHQgKi9cclxuXHRpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuXHQgICAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQSBzaW1wbGUgZm9yRWFjaCgpIGltcGxlbWVudGF0aW9uIGZvciBBcnJheXMsIE9iamVjdHMgYW5kIE5vZGVMaXN0c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R8Tm9kZUxpc3R9IGNvbGxlY3Rpb24gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byBpdGVyYXRlXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlcmF0aW9uXHJcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R8Tm9kZUxpc3R9IHNjb3BlIE9iamVjdC9Ob2RlTGlzdC9BcnJheSB0aGF0IGZvckVhY2ggaXMgaXRlcmF0aW5nIG92ZXIgKGFrYSBgdGhpc2ApXHJcblx0ICovXHJcblx0dmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHNjb3BlKSB7XHJcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbGxlY3Rpb24pID09PSAnW29iamVjdCBPYmplY3RdJykge1xyXG5cdFx0XHRmb3IgKHZhciBwcm9wIGluIGNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIHByb3ApKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNjb3BlLCBjb2xsZWN0aW9uW3Byb3BdLCBwcm9wLCBjb2xsZWN0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmKGNvbGxlY3Rpb24pe1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2xsZWN0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNjb3BlLCBjb2xsZWN0aW9uW2ldLCBpLCBjb2xsZWN0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBNZXJnZSBkZWZhdWx0cyB3aXRoIHVzZXIgb3B0aW9uc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzIERlZmF1bHQgc2V0dGluZ3NcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBVc2VyIG9wdGlvbnNcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBNZXJnZWQgdmFsdWVzIG9mIGRlZmF1bHRzIGFuZCBvcHRpb25zXHJcblx0ICovXHJcblx0dmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cywgb3B0aW9ucykge1xyXG5cdFx0dmFyIGV4dGVuZGVkID0ge307XHJcblx0XHRmb3JFYWNoKGRlZmF1bHRzLCBmdW5jdGlvbiAodmFsdWUsIHByb3ApIHtcclxuXHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcclxuXHRcdH0pO1xyXG5cdFx0Zm9yRWFjaChvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIHByb3ApIHtcclxuXHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gZXh0ZW5kZWQ7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhIGZyYWdtZW50IERPTSBlbGVtZW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dmFyIGNyZWF0ZUZyYWdFbGVtID0gZnVuY3Rpb24oaHRtbFN0cikge1xyXG5cdFx0dmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcblx0XHRcdHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHRlbXAuaW5uZXJIVE1MID0gaHRtbFN0cjtcclxuXHRcdHdoaWxlICh0ZW1wLmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0ZnJhZy5hcHBlbmRDaGlsZCh0ZW1wLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZyYWc7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIGlzIGEgY29sb3JcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHZhciBpc0NvbG9yID0gZnVuY3Rpb24oY29sb3Ipe1xyXG5cdFx0aWYoIGNvbG9yLnN1YnN0cmluZygwLDEpID09IFwiI1wiIHx8IGNvbG9yLnN1YnN0cmluZygwLDMpID09IFwicmdiXCIgfHwgY29sb3Iuc3Vic3RyaW5nKDAsMykgPT0gXCJoc2xcIiApe1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRHJhZyBtZXRob2Qgb2YgdG9hc3RzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR2YXIgZHJhZyA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgICBcclxuXHQgICAgcmV0dXJuIHtcclxuXHQgICAgICAgIG1vdmU6IGZ1bmN0aW9uKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIHhwb3MpIHtcclxuXHJcblx0ICAgICAgICBcdHZhciBvcGFjaXR5LFxyXG5cdCAgICAgICAgXHRcdG9wYWNpdHlSYW5nZSA9IDAuMyxcclxuXHQgICAgICAgIFx0XHRkaXN0YW5jZSA9IDE4MDtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB0b2FzdC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnK3hwb3MgKyAncHgpJztcclxuXHJcblx0ICAgICAgICAgICAgaWYoeHBvcyA+IDApe1xyXG5cdCAgICAgICAgICAgIFx0b3BhY2l0eSA9IChkaXN0YW5jZS14cG9zKSAvIGRpc3RhbmNlO1xyXG5cdCAgICAgICAgICAgIFx0aWYob3BhY2l0eSA8IG9wYWNpdHlSYW5nZSl7XHJcblx0XHRcdFx0XHRcdGluc3RhbmNlLmhpZGUoZXh0ZW5kKHNldHRpbmdzLCB7IHRyYW5zaXRpb25PdXQ6ICdmYWRlT3V0UmlnaHQnLCB0cmFuc2l0aW9uT3V0TW9iaWxlOiAnZmFkZU91dFJpZ2h0JyB9KSwgdG9hc3QsICdkcmFnJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBcdG9wYWNpdHkgPSAoZGlzdGFuY2UreHBvcykgLyBkaXN0YW5jZTtcclxuXHQgICAgICAgICAgICBcdGlmKG9wYWNpdHkgPCBvcGFjaXR5UmFuZ2Upe1xyXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5oaWRlKGV4dGVuZChzZXR0aW5ncywgeyB0cmFuc2l0aW9uT3V0OiAnZmFkZU91dExlZnQnLCB0cmFuc2l0aW9uT3V0TW9iaWxlOiAnZmFkZU91dExlZnQnIH0pLCB0b2FzdCwgJ2RyYWcnKTtcclxuXHRcdFx0XHRcdH1cclxuXHQgICAgICAgICAgICB9XHJcblx0XHRcdFx0dG9hc3Quc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRcclxuXHRcdFx0XHRpZihvcGFjaXR5IDwgb3BhY2l0eVJhbmdlKXtcclxuXHJcblx0XHRcdFx0XHRpZihJU0NIUk9NRSB8fCBJU0ZJUkVGT1gpXHJcblx0XHRcdFx0XHRcdHRvYXN0LnN0eWxlLmxlZnQgPSB4cG9zKydweCc7XHJcblxyXG5cdFx0XHRcdFx0dG9hc3QucGFyZW50Tm9kZS5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eVJhbmdlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdG9wTW92aW5nKHRvYXN0LCBudWxsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3RhcnRNb3Zpbmc6IGZ1bmN0aW9uKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIGUpIHtcclxuXHJcblx0ICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdCAgICAgICAgICAgIHZhciBwb3NYID0gKChBQ0NFUFRTVE9VQ0gpID8gZS50b3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFgpLFxyXG5cdCAgICAgICAgICAgICAgICB0b2FzdExlZnQgPSB0b2FzdC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgncHgpJywgJycpO1xyXG5cdCAgICAgICAgICAgICAgICB0b2FzdExlZnQgPSB0b2FzdExlZnQucmVwbGFjZSgndHJhbnNsYXRlWCgnLCAnJyk7XHJcblx0ICAgICAgICAgICAgdmFyIG9mZnNldFggPSBwb3NYIC0gdG9hc3RMZWZ0O1xyXG5cclxuXHRcdFx0XHR0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKHNldHRpbmdzLnRyYW5zaXRpb25Jbik7XHJcblx0XHRcdFx0dG9hc3QuY2xhc3NMaXN0LnJlbW92ZShzZXR0aW5ncy50cmFuc2l0aW9uSW5Nb2JpbGUpO1xyXG5cdFx0XHRcdHRvYXN0LnN0eWxlLnRyYW5zaXRpb24gPSBcIlwiO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoQUNDRVBUU1RPVUNIKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50Lm9udG91Y2htb3ZlID0gZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBvc1ggPSBlLnRvdWNoZXNbMF0uY2xpZW50WCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFggPSBwb3NYIC0gb2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZy5tb3ZlKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIGZpbmFsWCk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBmdW5jdGlvbihlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcG9zWCA9IGUuY2xpZW50WCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFggPSBwb3NYIC0gb2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZy5tb3ZlKHRvYXN0LCBpbnN0YW5jZSwgc2V0dGluZ3MsIGZpbmFsWCk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdG9wTW92aW5nOiBmdW5jdGlvbih0b2FzdCwgZSkge1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoQUNDRVBUU1RPVUNIKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50Lm9udG91Y2htb3ZlID0gZnVuY3Rpb24oKSB7fTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIFx0ZG9jdW1lbnQub25tb3VzZW1vdmUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHRcdFx0XHR0b2FzdC5zdHlsZS50cmFuc2l0aW9uID0gXCJ0cmFuc2Zvcm0gMC40cyBlYXNlLCBvcGFjaXR5IDAuNHMgZWFzZVwiO1xyXG5cdFx0XHRcdHRvYXN0LnN0eWxlLm9wYWNpdHkgPSBcIlwiO1xyXG5cdFx0XHRcdHRvYXN0LnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7XHJcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0b2FzdC5zdHlsZS50cmFuc2l0aW9uID0gXCJcIjtcclxuXHRcdFx0XHR9LCA0MDApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cclxuXHR9KCk7XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBEbyB0aGUgY2FsY3VsYXRpb24gdG8gbW92ZSB0aGUgcHJvZ3Jlc3MgYmFyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR2YXIgbW92ZVByb2dyZXNzID0gZnVuY3Rpb24odG9hc3QsIHNldHRpbmdzLCBjYWxsYmFjayl7XHJcblxyXG5cdFx0dmFyIGlzUGF1c2VkID0gZmFsc2U7XHJcblx0XHR2YXIgaXNSZXNldGVkID0gZmFsc2U7XHJcblx0XHR2YXIgaXNDbG9zZWQgPSBmYWxzZTtcclxuXHRcdHZhciB0aW1lclRpbWVvdXQgPSBudWxsO1xyXG5cdFx0dmFyIGVsZW0gPSB0b2FzdC5xdWVyeVNlbGVjdG9yKFwiLlwiK1BMVUdJTl9OQU1FK1wiLXByb2dyZXNzYmFyIGRpdlwiKTtcclxuXHRcdHZhciBwcm9ncmVzc0JhciA9IHtcclxuXHRcdFx0aGlkZUV0YTogbnVsbCxcclxuXHRcdFx0bWF4SGlkZVRpbWU6IG51bGwsXHJcblx0XHRcdGN1cnJlbnRUaW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcclxuXHRcdFx0dXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uKClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlzUGF1c2VkID0gdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKFBMVUdJTl9OQU1FKyctcGF1c2VkJykgPyB0cnVlIDogZmFsc2U7XHJcblx0XHRcdFx0aXNSZXNldGVkID0gdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKFBMVUdJTl9OQU1FKyctcmVzZXRlZCcpID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdFx0XHRcdGlzQ2xvc2VkID0gdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKFBMVUdJTl9OQU1FKyctY2xvc2VkJykgPyB0cnVlIDogZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmKGlzUmVzZXRlZCl7XHJcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcclxuXHRcdFx0XHRcdGVsZW0uc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblx0XHRcdFx0XHRtb3ZlUHJvZ3Jlc3ModG9hc3QsIHNldHRpbmdzLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0XHR0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKFBMVUdJTl9OQU1FKyctcmVzZXRlZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihpc0Nsb3NlZCl7XHJcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcclxuXHRcdFx0XHRcdHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoUExVR0lOX05BTUUrJy1jbG9zZWQnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKCFpc1BhdXNlZCAmJiAhaXNSZXNldGVkICYmICFpc0Nsb3NlZCl7XHJcblx0XHRcdFx0XHRwcm9ncmVzc0Jhci5jdXJyZW50VGltZSA9IHByb2dyZXNzQmFyLmN1cnJlbnRUaW1lKzEwO1xyXG5cdFx0XHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSAoKHByb2dyZXNzQmFyLmhpZGVFdGEgLSAocHJvZ3Jlc3NCYXIuY3VycmVudFRpbWUpKSAvIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lKSAqIDEwMDtcclxuXHRcdFx0XHRcdGVsZW0uc3R5bGUud2lkdGggPSBwZXJjZW50YWdlICsgJyUnO1xyXG5cclxuXHRcdFx0XHRcdGlmKE1hdGgucm91bmQocGVyY2VudGFnZSkgPCAwIHx8IHR5cGVvZiB0b2FzdCAhPSAnb2JqZWN0Jyl7XHJcblx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRpZiAoc2V0dGluZ3MudGltZW91dCA+IDApIHtcclxuXHRcdFx0cHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWUgPSBwYXJzZUZsb2F0KHNldHRpbmdzLnRpbWVvdXQpO1xyXG5cdFx0XHRwcm9ncmVzc0Jhci5oaWRlRXRhID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZTtcclxuXHRcdFx0dGltZXJUaW1lb3V0ID0gc2V0SW50ZXJ2YWwocHJvZ3Jlc3NCYXIudXBkYXRlUHJvZ3Jlc3MsIDEwKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEZXN0cm95IHRoZSBjdXJyZW50IGluaXRpYWxpemF0aW9uLlxyXG5cdCAqIEBwdWJsaWNcclxuXHQgKi9cclxuXHQkaXppVG9hc3QuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3JFYWNoKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nK1BMVUdJTl9OQU1FKyctd3JhcHBlcicpLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0XHRlbGVtZW50LnJlbW92ZSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zm9yRWFjaChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJytQTFVHSU5fTkFNRSksIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XHJcblx0XHRcdGVsZW1lbnQucmVtb3ZlKCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFBMVUdJTl9OQU1FKyctb3BlbicsIHt9LCBmYWxzZSk7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFBMVUdJTl9OQU1FKyctY2xvc2UnLCB7fSwgZmFsc2UpO1xyXG5cclxuXHRcdC8vIFJlc2V0IHZhcmlhYmxlc1xyXG5cdFx0Q09ORklHID0ge307XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSBQbHVnaW5cclxuXHQgKiBAcHVibGljXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVXNlciBzZXR0aW5nc1xyXG5cdCAqL1xyXG5cdCRpemlUb2FzdC5zZXR0aW5ncyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0Ly8gRGVzdHJveSBhbnkgZXhpc3RpbmcgaW5pdGlhbGl6YXRpb25zXHJcblx0XHQkaXppVG9hc3QuZGVzdHJveSgpO1xyXG5cclxuXHRcdENPTkZJRyA9IG9wdGlvbnM7XHJcblx0XHRkZWZhdWx0cyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJ1aWxkaW5nIHRoZW1lcyBmdW5jdGlvbnMuXHJcblx0ICogQHB1YmxpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFVzZXIgc2V0dGluZ3NcclxuXHQgKi9cclxuXHRmb3JFYWNoKFRIRU1FUywgZnVuY3Rpb24gKHRoZW1lLCBuYW1lKSB7XHJcblxyXG5cdFx0JGl6aVRvYXN0W25hbWVdID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRcdHZhciBzZXR0aW5ncyA9IGV4dGVuZChDT05GSUcsIG9wdGlvbnMgfHwge30pO1xyXG5cdFx0XHRzZXR0aW5ncyA9IGV4dGVuZCh0aGVtZSwgc2V0dGluZ3MgfHwge30pO1xyXG5cclxuXHRcdFx0dGhpcy5zaG93KHNldHRpbmdzKTtcclxuXHRcdH07XHJcblxyXG5cdH0pO1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQ2xvc2UgdGhlIHNwZWNpZmljIFRvYXN0XHJcblx0ICogQHB1YmxpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFVzZXIgc2V0dGluZ3NcclxuXHQgKi9cclxuXHQkaXppVG9hc3QuaGlkZSA9IGZ1bmN0aW9uIChvcHRpb25zLCAkdG9hc3QsIGNsb3NlZEJ5KSB7XHJcblxyXG5cdFx0dmFyIHNldHRpbmdzID0gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcclxuXHRcdFx0Y2xvc2VkQnkgPSBjbG9zZWRCeSB8fCBmYWxzZTtcclxuXHJcblx0XHRpZih0eXBlb2YgJHRvYXN0ICE9ICdvYmplY3QnKXtcclxuXHRcdFx0JHRvYXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigkdG9hc3QpO1xyXG5cdFx0fVxyXG5cdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1jbG9zZWQnKTtcclxuXHJcblx0XHRpZihzZXR0aW5ncy50cmFuc2l0aW9uSW4gfHwgc2V0dGluZ3MudHJhbnNpdGlvbkluTW9iaWxlKXtcclxuXHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoc2V0dGluZ3MudHJhbnNpdGlvbkluKTtcclxuXHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoc2V0dGluZ3MudHJhbnNpdGlvbkluTW9iaWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSBNT0JJTEVXSURUSCl7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25PdXRNb2JpbGUpXHJcblx0XHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoc2V0dGluZ3MudHJhbnNpdGlvbk91dE1vYmlsZSk7XHJcblx0XHR9IGVsc2V7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25PdXQpXHJcblx0XHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoc2V0dGluZ3MudHJhbnNpdGlvbk91dCk7XHJcblx0XHR9XHJcblx0XHR2YXIgSCA9ICR0b2FzdC5wYXJlbnROb2RlLm9mZnNldEhlaWdodDtcclxuXHRcdFx0XHQkdG9hc3QucGFyZW50Tm9kZS5zdHlsZS5oZWlnaHQgPSBIKydweCc7XHJcblx0XHRcdFx0JHRvYXN0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcblx0XHRcclxuXHRcdGlmKCFJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA+IE1PQklMRVdJRFRIKXtcclxuXHRcdFx0JHRvYXN0LnBhcmVudE5vZGUuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gJzAuMnMnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdCR0b2FzdC5wYXJlbnROb2RlLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xyXG5cdFx0XHQkdG9hc3QucGFyZW50Tm9kZS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xyXG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdCR0b2FzdC5wYXJlbnROb2RlLnJlbW92ZSgpO1xyXG5cdFx0XHR9LDEwMDApO1xyXG5cdFx0fSwyMDApO1xyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jbGFzcyl7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dmFyIGV2ZW50O1xyXG5cdFx0XHRcdGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcclxuXHRcdFx0XHRcdGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFBMVUdJTl9OQU1FKyctY2xvc2UnLCB7ZGV0YWlsOiB7Y2xhc3M6IHNldHRpbmdzLmNsYXNzfX0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG5cdFx0XHRcdFx0ZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFBMVUdJTl9OQU1FKyctY2xvc2UnLCB0cnVlLCB0cnVlLCB7Y2xhc3M6IHNldHRpbmdzLmNsYXNzfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdFx0XHR9IGNhdGNoKGV4KXtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodHlwZW9mIHNldHRpbmdzLm9uQ2xvc2UgIT09IFwidW5kZWZpbmVkXCIpe1xyXG5cdFx0XHRzZXR0aW5ncy5vbkNsb3NlLmFwcGx5KG51bGwsIFtzZXR0aW5ncywgJHRvYXN0LCBjbG9zZWRCeV0pO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhbmQgc2hvdyB0aGUgVG9hc3RcclxuXHQgKiBAcHVibGljXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVXNlciBzZXR0aW5nc1xyXG5cdCAqL1xyXG5cdCRpemlUb2FzdC5zaG93ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gTWVyZ2UgdXNlciBvcHRpb25zIHdpdGggZGVmYXVsdHNcclxuXHRcdHZhciBzZXR0aW5ncyA9IGV4dGVuZChDT05GSUcsIG9wdGlvbnMgfHwge30pO1xyXG5cdFx0XHRzZXR0aW5ncyA9IGV4dGVuZChkZWZhdWx0cywgc2V0dGluZ3MpO1xyXG5cclxuXHRcdHZhciAkdG9hc3RDYXBzdWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdFx0JHRvYXN0Q2Fwc3VsZS5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FK1wiLWNhcHN1bGVcIik7XHJcblxyXG5cdFx0dmFyICR0b2FzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FKTtcclxuXHJcblx0XHRpZihJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSBNT0JJTEVXSURUSCl7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25Jbk1vYmlsZS5sZW5ndGg+MClcclxuXHRcdFx0XHQkdG9hc3QuY2xhc3NMaXN0LmFkZChzZXR0aW5ncy50cmFuc2l0aW9uSW5Nb2JpbGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYoc2V0dGluZ3MudHJhbnNpdGlvbkluLmxlbmd0aD4wKVxyXG5cdFx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKHNldHRpbmdzLnRyYW5zaXRpb25Jbik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MucnRsKXtcclxuXHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUgKyAnLXJ0bCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jb2xvci5sZW5ndGggPiAwKSB7IC8vIywgcmdiLCByZ2JhLCBoc2xcclxuXHRcdFx0XHJcblx0XHRcdGlmKCBpc0NvbG9yKHNldHRpbmdzLmNvbG9yKSApe1xyXG5cdFx0XHRcdCR0b2FzdC5zdHlsZS5iYWNrZ3JvdW5kID0gc2V0dGluZ3MuY29sb3I7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0LmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1jb2xvci0nK3NldHRpbmdzLmNvbG9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHNldHRpbmdzLmJhY2tncm91bmRDb2xvci5sZW5ndGggPiAwKSB7XHJcblx0XHRcdCR0b2FzdC5zdHlsZS5iYWNrZ3JvdW5kID0gc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jbGFzcyl7XHJcblx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKHNldHRpbmdzLmNsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2V0dGluZ3MuaW1hZ2UpIHtcclxuXHRcdFx0dmFyICRjb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCRjb3Zlci5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FICsgJy1jb3ZlcicpO1xyXG5cdFx0XHQkY292ZXIuc3R5bGUud2lkdGggPSBzZXR0aW5ncy5pbWFnZVdpZHRoICsgXCJweFwiO1xyXG5cdFx0XHQkY292ZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgc2V0dGluZ3MuaW1hZ2UgKyAnKSc7XHJcblx0XHRcdCR0b2FzdC5hcHBlbmRDaGlsZCgkY292ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciAkYnV0dG9uQ2xvc2U7XHJcblx0XHRpZihzZXR0aW5ncy5jbG9zZSl7XHJcblx0XHRcdCRidXR0b25DbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcblx0XHRcdCRidXR0b25DbG9zZS5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FICsgJy1jbG9zZScpO1xyXG5cdFx0XHQkdG9hc3QuYXBwZW5kQ2hpbGQoJGJ1dHRvbkNsb3NlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmKHNldHRpbmdzLnJ0bCl7XHJcblx0XHRcdFx0JHRvYXN0LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIzMHB4XCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMzBweFwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNldHRpbmdzLnByb2dyZXNzQmFyKSB7XHJcblxyXG5cdFx0XHR2YXIgJHByb2dyZXNzQmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdFx0XHQkcHJvZ3Jlc3NCYXIuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRSArICctcHJvZ3Jlc3NiYXInKTtcclxuXHJcblx0XHRcdHZhciAkcHJvZ3Jlc3NCYXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0XHRcdCRwcm9ncmVzc0JhckRpdi5zdHlsZS5iYWNrZ3JvdW5kID0gc2V0dGluZ3MucHJvZ3Jlc3NCYXJDb2xvcjtcclxuXHJcblx0XHRcdCRwcm9ncmVzc0Jhci5hcHBlbmRDaGlsZCgkcHJvZ3Jlc3NCYXJEaXYpO1xyXG5cdFx0XHQkdG9hc3QuYXBwZW5kQ2hpbGQoJHByb2dyZXNzQmFyKTtcclxuXHRcdFx0XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bW92ZVByb2dyZXNzKCR0b2FzdCwgc2V0dGluZ3MsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHR0aGF0LmhpZGUoc2V0dGluZ3MsICR0b2FzdCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0sMzAwKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoIHNldHRpbmdzLnByb2dyZXNzQmFyID09PSBmYWxzZSAmJiBzZXR0aW5ncy50aW1lb3V0ID4gMCl7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhhdC5oaWRlKHNldHRpbmdzLCAkdG9hc3QpO1xyXG5cdFx0XHR9LCBzZXR0aW5ncy50aW1lb3V0KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgJHRvYXN0Qm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCR0b2FzdEJvZHkuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRSArICctYm9keScpO1xyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5pbWFnZSkge1xyXG5cdFx0XHRpZihzZXR0aW5ncy5ydGwpe1xyXG5cdFx0XHRcdCR0b2FzdEJvZHkuc3R5bGUubWFyZ2luUmlnaHQgPSAoc2V0dGluZ3MuaW1hZ2VXaWR0aCArIDEwKSArICdweCc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0Qm9keS5zdHlsZS5tYXJnaW5MZWZ0ID0gKHNldHRpbmdzLmltYWdlV2lkdGggKyAxMCkgKyAncHgnO1x0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2V0dGluZ3MuaWNvbikge1xyXG5cdFx0XHR2YXIgJGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuXHRcdFx0XHQkaWNvbi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBQTFVHSU5fTkFNRSArICctaWNvbiAnICsgc2V0dGluZ3MuaWNvbik7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuaWNvblRleHQpe1xyXG5cdFx0XHRcdCRpY29uLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNldHRpbmdzLmljb25UZXh0KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHNldHRpbmdzLnJ0bCl7XHJcblx0XHRcdFx0JHRvYXN0Qm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnMzNweCc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JHRvYXN0Qm9keS5zdHlsZS5wYWRkaW5nTGVmdCA9ICczM3B4JztcdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuaWNvbkNvbG9yKXtcclxuXHRcdFx0XHQkaWNvbi5zdHlsZS5jb2xvciA9IHNldHRpbmdzLmljb25Db2xvcjtcclxuXHRcdFx0fVxyXG5cdFx0XHQkdG9hc3RCb2R5LmFwcGVuZENoaWxkKCRpY29uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgJHN0cm9uZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHJvbmdcIik7XHJcblx0XHRpZiAoc2V0dGluZ3MudGl0bGVDb2xvci5sZW5ndGggPiAwKSB7XHJcblx0XHRcdCRzdHJvbmcuc3R5bGUuY29sb3IgPSBzZXR0aW5ncy50aXRsZUNvbG9yO1xyXG5cdFx0fVxyXG5cdFx0JHN0cm9uZy5hcHBlbmRDaGlsZChjcmVhdGVGcmFnRWxlbShzZXR0aW5ncy50aXRsZSkpO1xyXG5cclxuXHRcdHZhciAkcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xyXG5cdFx0aWYgKHNldHRpbmdzLm1lc3NhZ2VDb2xvci5sZW5ndGggPiAwKSB7XHJcblx0XHRcdCRwLnN0eWxlLmNvbG9yID0gc2V0dGluZ3MubWVzc2FnZUNvbG9yO1xyXG5cdFx0fVxyXG5cdFx0JHAuYXBwZW5kQ2hpbGQoY3JlYXRlRnJhZ0VsZW0oc2V0dGluZ3MubWVzc2FnZSkpO1xyXG5cclxuXHRcdGlmKHNldHRpbmdzLmxheW91dCA+IDEpe1xyXG5cdFx0XHQkdG9hc3QuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRStcIi1sYXlvdXRcIitzZXR0aW5ncy5sYXlvdXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHNldHRpbmdzLmJhbGxvb24pe1xyXG5cdFx0XHQkdG9hc3QuY2xhc3NMaXN0LmFkZChQTFVHSU5fTkFNRStcIi1iYWxsb29uXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCR0b2FzdEJvZHkuYXBwZW5kQ2hpbGQoJHN0cm9uZyk7XHJcblx0XHQkdG9hc3RCb2R5LmFwcGVuZENoaWxkKCRwKTtcclxuXHJcblx0XHR2YXIgJGJ1dHRvbnM7XHJcblx0XHRpZiAoc2V0dGluZ3MuYnV0dG9ucy5sZW5ndGggPiAwKSB7XHJcblxyXG5cdFx0XHQkYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdCRidXR0b25zLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUgKyAnLWJ1dHRvbnMnKTtcclxuXHJcblx0XHRcdCRwLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzE1cHgnO1xyXG5cclxuXHRcdFx0dmFyIGkgPSAwO1xyXG5cdFx0XHRmb3JFYWNoKHNldHRpbmdzLmJ1dHRvbnMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcclxuXHRcdFx0XHQkYnV0dG9ucy5hcHBlbmRDaGlsZChjcmVhdGVGcmFnRWxlbSh2YWx1ZVswXSkpO1xyXG5cclxuXHRcdFx0XHR2YXIgJGJ0bnMgPSAkYnV0dG9ucy5jaGlsZE5vZGVzO1xyXG5cclxuXHRcdFx0XHQkYnRuc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHR2YXIgdHMgPSB2YWx1ZVsxXTtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgdHModGhhdCwgJHRvYXN0KTsgXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0fSk7XHJcblx0XHRcdCR0b2FzdEJvZHkuYXBwZW5kQ2hpbGQoJGJ1dHRvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCR0b2FzdC5hcHBlbmRDaGlsZCgkdG9hc3RCb2R5KTtcclxuXHRcdCR0b2FzdENhcHN1bGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdFx0JHRvYXN0Q2Fwc3VsZS5hcHBlbmRDaGlsZCgkdG9hc3QpO1xyXG5cclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBIID0gJHRvYXN0Lm9mZnNldEhlaWdodDtcclxuXHRcdFx0dmFyIHN0eWxlID0gJHRvYXN0LmN1cnJlbnRTdHlsZSB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgkdG9hc3QpO1xyXG5cdFx0XHR2YXIgbWFyZ2luVG9wID0gc3R5bGUubWFyZ2luVG9wO1xyXG5cdFx0XHRcdG1hcmdpblRvcCA9IG1hcmdpblRvcC5zcGxpdChcInB4XCIpO1xyXG5cdFx0XHRcdG1hcmdpblRvcCA9IHBhcnNlSW50KG1hcmdpblRvcFswXSk7XHJcblx0XHRcdHZhciBtYXJnaW5Cb3R0b20gPSBzdHlsZS5tYXJnaW5Cb3R0b207XHJcblx0XHRcdFx0bWFyZ2luQm90dG9tID0gbWFyZ2luQm90dG9tLnNwbGl0KFwicHhcIik7XHJcblx0XHRcdFx0bWFyZ2luQm90dG9tID0gcGFyc2VJbnQobWFyZ2luQm90dG9tWzBdKTtcclxuXHJcblx0XHRcdCR0b2FzdENhcHN1bGUuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cdFx0XHQkdG9hc3RDYXBzdWxlLnN0eWxlLmhlaWdodCA9IChIK21hcmdpbkJvdHRvbSttYXJnaW5Ub3ApKydweCc7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JHRvYXN0Q2Fwc3VsZS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcblx0XHRcdFx0aWYoc2V0dGluZ3MudGFyZ2V0KXtcclxuXHRcdFx0XHRcdCR0b2FzdENhcHN1bGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LDEwMDApO1xyXG5cdFx0fSwgMTAwKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBzZXR0aW5ncy5wb3NpdGlvbixcclxuXHRcdFx0JHdyYXBwZXI7XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MudGFyZ2V0KXtcclxuXHJcblx0XHRcdCR3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZXR0aW5ncy50YXJnZXQpO1xyXG5cdFx0XHQkd3JhcHBlci5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FICsgJy10YXJnZXQnKTtcclxuXHJcblx0XHRcdGlmIChzZXR0aW5ncy50YXJnZXRGaXJzdCkge1xyXG5cdFx0XHRcdCR3cmFwcGVyLmluc2VydEJlZm9yZSgkdG9hc3RDYXBzdWxlLCAkd3JhcHBlci5maXJzdENoaWxkKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkd3JhcHBlci5hcHBlbmRDaGlsZCgkdG9hc3RDYXBzdWxlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiggUE9TSVRJT05TLmluZGV4T2Yoc2V0dGluZ3MucG9zaXRpb24pID09IC0xICl7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiW1wiK1BMVUdJTl9OQU1FK1wiXSBJbmNvcnJlY3QgcG9zaXRpb24uXFxuSXQgY2FuIGJlIOKAuiBcIiArIFBPU0lUSU9OUyk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihJU01PQklMRSB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSBNT0JJTEVXSURUSCl7XHJcblx0XHRcdFx0aWYoc2V0dGluZ3MucG9zaXRpb24gPT0gXCJib3R0b21MZWZ0XCIgfHwgc2V0dGluZ3MucG9zaXRpb24gPT0gXCJib3R0b21SaWdodFwiIHx8IHNldHRpbmdzLnBvc2l0aW9uID09IFwiYm90dG9tQ2VudGVyXCIpe1xyXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBQTFVHSU5fTkFNRSsnLXdyYXBwZXItYm90dG9tQ2VudGVyJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZihzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcExlZnRcIiB8fCBzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcFJpZ2h0XCIgfHwgc2V0dGluZ3MucG9zaXRpb24gPT0gXCJ0b3BDZW50ZXJcIil7XHJcblx0XHRcdFx0XHRwb3NpdGlvbiA9IFBMVUdJTl9OQU1FKyctd3JhcHBlci10b3BDZW50ZXInO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBQTFVHSU5fTkFNRSsnLXdyYXBwZXItY2VudGVyJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cG9zaXRpb24gPSBQTFVHSU5fTkFNRSsnLXdyYXBwZXItJytwb3NpdGlvbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQkd3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgUExVR0lOX05BTUUgKyAnLXdyYXBwZXIuJytwb3NpdGlvbik7XHJcblxyXG5cdFx0XHRpZiAoISR3cmFwcGVyKSB7XHJcblx0XHRcdFx0JHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0XHRcdCR3cmFwcGVyLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUgKyAnLXdyYXBwZXInKTtcclxuXHRcdFx0XHQkd3JhcHBlci5jbGFzc0xpc3QuYWRkKHBvc2l0aW9uKTtcclxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCR3cmFwcGVyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcExlZnRcIiB8fCBzZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcENlbnRlclwiIHx8IHNldHRpbmdzLnBvc2l0aW9uID09IFwidG9wUmlnaHRcIil7XHJcblx0XHRcdFx0JHdyYXBwZXIuaW5zZXJ0QmVmb3JlKCR0b2FzdENhcHN1bGUsICR3cmFwcGVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCR3cmFwcGVyLmFwcGVuZENoaWxkKCR0b2FzdENhcHN1bGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc05hTihzZXR0aW5ncy56aW5kZXgpKSB7XHJcblx0XHRcdCR3cmFwcGVyLnN0eWxlLnpJbmRleCA9IHNldHRpbmdzLnppbmRleDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnNvbGUud2FybihcIltcIitQTFVHSU5fTkFNRStcIl0gSW52YWxpZCB6SW5kZXguXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNldHRpbmdzLm9uT3Blbi5hcHBseShudWxsLCBbc2V0dGluZ3MsICR0b2FzdF0pO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHZhciBldmVudDtcclxuXHRcdFx0aWYgKHdpbmRvdy5DdXN0b21FdmVudCkge1xyXG5cdFx0XHRcdGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFBMVUdJTl9OQU1FKyctb3BlbicsIHtkZXRhaWw6IHtjbGFzczogc2V0dGluZ3MuY2xhc3N9fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcclxuXHRcdFx0XHRldmVudC5pbml0Q3VzdG9tRXZlbnQoUExVR0lOX05BTUUrJy1vcGVuJywgdHJ1ZSwgdHJ1ZSwge2NsYXNzOiBzZXR0aW5ncy5jbGFzc30pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdFx0fSBjYXRjaChleCl7XHJcblx0XHRcdGNvbnNvbGUud2FybihleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MuYW5pbWF0ZUluc2lkZSl7XHJcblx0XHRcdCR0b2FzdC5jbGFzc0xpc3QuYWRkKFBMVUdJTl9OQU1FKyctYW5pbWF0ZUluc2lkZScpO1xyXG5cdFx0XHJcblx0XHRcdHZhciB0aW1lQW5pbWF0aW9uMSA9IDIwMDtcclxuXHRcdFx0dmFyIHRpbWVBbmltYXRpb24yID0gMTAwO1xyXG5cdFx0XHR2YXIgdGltZUFuaW1hdGlvbjMgPSAzMDA7XHJcblx0XHRcdGlmKHNldHRpbmdzLnRyYW5zaXRpb25JbiA9PSBcImJvdW5jZUluTGVmdFwiKXtcclxuXHRcdFx0XHR0aW1lQW5pbWF0aW9uMSA9IDQwMDtcclxuXHRcdFx0XHR0aW1lQW5pbWF0aW9uMiA9IDIwMDtcclxuXHRcdFx0XHR0aW1lQW5pbWF0aW9uMyA9IDQwMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHQkc3Ryb25nLmNsYXNzTGlzdC5hZGQoJ3NsaWRlSW4nKTtcclxuXHRcdFx0fSx0aW1lQW5pbWF0aW9uMSk7XHJcblxyXG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdCRwLmNsYXNzTGlzdC5hZGQoJ3NsaWRlSW4nKTtcclxuXHRcdFx0fSx0aW1lQW5pbWF0aW9uMik7XHJcblxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuaWNvbikge1xyXG5cdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHQkaWNvbi5jbGFzc0xpc3QuYWRkKCdyZXZlYWxJbicpO1xyXG5cdFx0XHRcdH0sdGltZUFuaW1hdGlvbjMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc2V0dGluZ3MuYnV0dG9ucy5sZW5ndGggPiAwICYmICRidXR0b25zKSB7XHJcblx0XHRcdFx0dmFyIGNvdW50ZXIgPSAxNTA7XHJcblx0XHRcdFx0Zm9yRWFjaCgkYnV0dG9ucy5jaGlsZE5vZGVzLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cclxuXHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncmV2ZWFsSW4nKTtcclxuXHRcdFx0XHRcdH0sY291bnRlcik7XHJcblx0XHRcdFx0XHRjb3VudGVyID0gY291bnRlciArIGNvdW50ZXI7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYoJGJ1dHRvbkNsb3NlKXtcclxuXHRcdFx0JGJ1dHRvbkNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR2YXIgYnV0dG9uID0gZS50YXJnZXQ7XHJcblx0XHRcdFx0dGhhdC5oaWRlKHNldHRpbmdzLCAkdG9hc3QsICdidXR0b24nKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MucGF1c2VPbkhvdmVyKXtcclxuXHRcdFx0XHJcblx0XHRcdCR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR0aGlzLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1wYXVzZWQnKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdCR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR0aGlzLmNsYXNzTGlzdC5yZW1vdmUoUExVR0lOX05BTUUrJy1wYXVzZWQnKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc2V0dGluZ3MucmVzZXRPbkhvdmVyKXtcclxuXHJcblx0XHRcdCR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR0aGlzLmNsYXNzTGlzdC5hZGQoUExVR0lOX05BTUUrJy1yZXNldGVkJyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0dGhpcy5jbGFzc0xpc3QucmVtb3ZlKFBMVUdJTl9OQU1FKyctcmVzZXRlZCcpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihzZXR0aW5ncy5kcmFnKXtcclxuXHJcblx0XHRcdGlmIChBQ0NFUFRTVE9VQ0gpIHtcclxuXHJcblx0XHRcdCAgICAkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0ICAgICAgICBkcmFnLnN0YXJ0TW92aW5nKHRoaXMsIHRoYXQsIHNldHRpbmdzLCBlKTtcclxuXHRcdFx0ICAgIH0sIGZhbHNlKTtcclxuXHJcblx0XHRcdCAgICAkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdCAgICAgICAgZHJhZy5zdG9wTW92aW5nKHRoaXMsIGUpO1xyXG5cdFx0XHQgICAgfSwgZmFsc2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ICAgICR0b2FzdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdCAgICBcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0ICAgICAgICBkcmFnLnN0YXJ0TW92aW5nKHRoaXMsIHRoYXQsIHNldHRpbmdzLCBlKTtcclxuXHRcdFx0ICAgIH0sIGZhbHNlKTtcclxuXHJcblx0XHRcdCAgICAkdG9hc3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0ICAgIFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHQgICAgICAgIGRyYWcuc3RvcE1vdmluZyh0aGlzLCBlKTtcclxuXHRcdFx0ICAgIH0sIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuICRpemlUb2FzdDtcclxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2l6aXRvYXN0L2Rpc3QvanMvaXppVG9hc3QuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8vIFBvbHlmaWxsc1xyXG5cclxuaWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHROdW1iZXIuRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDUyICk7XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuaWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXHJcblxyXG5cdE1hdGguc2lnbiA9IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6ICsgeDtcclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcbmlmICggRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0Ly8gTWlzc2luZyBpbiBJRTktMTEuXHJcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZVxyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy50b1N0cmluZygpLm1hdGNoKCAvXlxccypmdW5jdGlvblxccyooW15cXChcXHNdKikvIClbIDEgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcbn1cclxuXHJcbmlmICggT2JqZWN0LmFzc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBNaXNzaW5nIGluIElFLlxyXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cclxuXHJcblx0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0T2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgb3V0cHV0ID0gT2JqZWN0KCB0YXJnZXQgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzb3VyY2UgPSBhcmd1bWVudHNbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdGlmICggc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBuZXh0S2V5IGluIHNvdXJjZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBzb3VyY2UsIG5leHRLZXkgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0b3V0cHV0WyBuZXh0S2V5IF0gPSBzb3VyY2VbIG5leHRLZXkgXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCk7XHJcblxyXG59XG5cbi8qXHJcbiAqIEEgbGlzdCBvZiBjb25zdGFudHMgYnVpbHQtaW4gZm9yXHJcbiAqIHRoZSBwaHlzaWNzIGVuZ2luZS5cclxuICovXHJcblxyXG52YXIgUkVWSVNJT04gPSAnMS4wLjknO1xyXG5cclxuLy8gQnJvYWRQaGFzZVxyXG52YXIgQlJfTlVMTCA9IDA7XHJcbnZhciBCUl9CUlVURV9GT1JDRSA9IDE7XHJcbnZhciBCUl9TV0VFUF9BTkRfUFJVTkUgPSAyO1xyXG52YXIgQlJfQk9VTkRJTkdfVk9MVU1FX1RSRUUgPSAzO1xyXG5cclxuLy8gQm9keSB0eXBlXHJcbnZhciBCT0RZX05VTEwgPSAwO1xyXG52YXIgQk9EWV9EWU5BTUlDID0gMTtcclxudmFyIEJPRFlfU1RBVElDID0gMjtcclxudmFyIEJPRFlfS0lORU1BVElDID0gMztcclxudmFyIEJPRFlfR0hPU1QgPSA0O1xyXG5cclxuLy8gU2hhcGUgdHlwZVxyXG52YXIgU0hBUEVfTlVMTCA9IDA7XHJcbnZhciBTSEFQRV9TUEhFUkUgPSAxO1xyXG52YXIgU0hBUEVfQk9YID0gMjtcclxudmFyIFNIQVBFX0NZTElOREVSID0gMztcclxudmFyIFNIQVBFX1BMQU5FID0gNDtcclxudmFyIFNIQVBFX1BBUlRJQ0xFID0gNTtcclxudmFyIFNIQVBFX1RFVFJBID0gNjtcclxuXHJcbi8vIEpvaW50IHR5cGVcclxudmFyIEpPSU5UX05VTEwgPSAwO1xyXG52YXIgSk9JTlRfRElTVEFOQ0UgPSAxO1xyXG52YXIgSk9JTlRfQkFMTF9BTkRfU09DS0VUID0gMjtcclxudmFyIEpPSU5UX0hJTkdFID0gMztcclxudmFyIEpPSU5UX1dIRUVMID0gNDtcclxudmFyIEpPSU5UX1NMSURFUiA9IDU7XHJcbnZhciBKT0lOVF9QUklTTUFUSUMgPSA2O1xyXG5cclxuLy8gQUFCQiBhcHJveGltYXRpb25cclxudmFyIEFBQkJfUFJPWCA9IDAuMDA1O1xuXG52YXIgX01hdGggPSB7XHJcblxyXG4gICAgc3FydCAgIDogTWF0aC5zcXJ0LFxyXG4gICAgYWJzICAgIDogTWF0aC5hYnMsXHJcbiAgICBmbG9vciAgOiBNYXRoLmZsb29yLFxyXG4gICAgY29zICAgIDogTWF0aC5jb3MsXHJcbiAgICBzaW4gICAgOiBNYXRoLnNpbixcclxuICAgIGFjb3MgICA6IE1hdGguYWNvcyxcclxuICAgIGFzaW4gICA6IE1hdGguYXNpbixcclxuICAgIGF0YW4yICA6IE1hdGguYXRhbjIsXHJcbiAgICByb3VuZCAgOiBNYXRoLnJvdW5kLFxyXG4gICAgcG93ICAgIDogTWF0aC5wb3csXHJcbiAgICBtYXggICAgOiBNYXRoLm1heCxcclxuICAgIG1pbiAgICA6IE1hdGgubWluLFxyXG4gICAgcmFuZG9tIDogTWF0aC5yYW5kb20sXHJcblxyXG4gICAgZGVndG9yYWQgOiAwLjAxNzQ1MzI5MjUxOTk0MzI5NTcsXHJcbiAgICByYWR0b2RlZyA6IDU3LjI5NTc3OTUxMzA4MjMyMDg3NixcclxuICAgIFBJICAgICAgIDogMy4xNDE1OTI2NTM1ODk3OTMsXHJcbiAgICBUd29QSSAgICA6IDYuMjgzMTg1MzA3MTc5NTg2LFxyXG4gICAgUEk5MCAgICAgOiAxLjU3MDc5NjMyNjc5NDg5NixcclxuICAgIFBJMjcwICAgIDogNC43MTIzODg5ODAzODQ2ODksXHJcblxyXG4gICAgSU5GICAgICAgOiBJbmZpbml0eSxcclxuICAgIEVQWiAgICAgIDogMC4wMDAwMSxcclxuICAgIEVQWjIgICAgICA6IDAuMDAwMDAxLFxyXG5cclxuICAgIGxlcnA6IGZ1bmN0aW9uICggeCwgeSwgdCApIHsgXHJcblxyXG4gICAgICAgIHJldHVybiAoIDEgLSB0ICkgKiB4ICsgdCAqIHk7IFxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7IFxyXG5cclxuICAgICAgICByZXR1cm4gbG93ICsgX01hdGguZmxvb3IoIF9NYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7IFxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmFuZDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7IFxyXG5cclxuICAgICAgICByZXR1cm4gbG93ICsgX01hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTsgXHJcblxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2VuZXJhdGVVVUlEOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXHJcblxyXG4gICAgICAgIHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoICcnICk7XHJcbiAgICAgICAgdmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XHJcbiAgICAgICAgdmFyIHJuZCA9IDAsIHI7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGkgPT09IDggfHwgaSA9PT0gMTMgfHwgaSA9PT0gMTggfHwgaSA9PT0gMjMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHV1aWRbIGkgXSA9ICctJztcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpID09PSAxNCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXVpZFsgaSBdID0gJzQnO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHJuZCAmIDB4ZjtcclxuICAgICAgICAgICAgICAgICAgICBybmQgPSBybmQgPj4gNDtcclxuICAgICAgICAgICAgICAgICAgICB1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHV1aWQuam9pbiggJycgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgaW50OiBmdW5jdGlvbiggeCApIHsgXHJcblxyXG4gICAgICAgIHJldHVybiBfTWF0aC5mbG9vcih4KTsgXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmaXg6IGZ1bmN0aW9uKCB4LCBuICkgeyBcclxuXHJcbiAgICAgICAgcmV0dXJuIHgudG9GaXhlZChuIHx8IDMsIDEwKTsgXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7IFxyXG5cclxuICAgICAgICByZXR1cm4gX01hdGgubWF4KCBtaW4sIF9NYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7IFxyXG5cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vY2xhbXA6IGZ1bmN0aW9uICggeCwgYSwgYiApIHsgcmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7IH0sXHJcblxyXG4gICAgXHJcblxyXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uKCBwMSwgcDIgKXtcclxuXHJcbiAgICAgICAgdmFyIHhkID0gcDJbMF0tcDFbMF07XHJcbiAgICAgICAgdmFyIHlkID0gcDJbMV0tcDFbMV07XHJcbiAgICAgICAgdmFyIHpkID0gcDJbMl0tcDFbMl07XHJcbiAgICAgICAgcmV0dXJuIF9NYXRoLnNxcnQoeGQqeGQgKyB5ZCp5ZCArIHpkKnpkKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qdW53cmFwRGVncmVlczogZnVuY3Rpb24gKCByICkge1xyXG5cclxuICAgICAgICByID0gciAlIDM2MDtcclxuICAgICAgICBpZiAociA+IDE4MCkgciAtPSAzNjA7XHJcbiAgICAgICAgaWYgKHIgPCAtMTgwKSByICs9IDM2MDtcclxuICAgICAgICByZXR1cm4gcjtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVud3JhcFJhZGlhbjogZnVuY3Rpb24oIHIgKXtcclxuXHJcbiAgICAgICAgciA9IHIgJSBfTWF0aC5Ud29QSTtcclxuICAgICAgICBpZiAociA+IF9NYXRoLlBJKSByIC09IF9NYXRoLlR3b1BJO1xyXG4gICAgICAgIGlmIChyIDwgLV9NYXRoLlBJKSByICs9IF9NYXRoLlR3b1BJO1xyXG4gICAgICAgIHJldHVybiByO1xyXG5cclxuICAgIH0sKi9cclxuXHJcbiAgICBhY29zQ2xhbXA6IGZ1bmN0aW9uICggY29zICkge1xyXG5cclxuICAgICAgICBpZihjb3M+MSlyZXR1cm4gMDtcclxuICAgICAgICBlbHNlIGlmKGNvczwtMSlyZXR1cm4gX01hdGguUEk7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gX01hdGguYWNvcyhjb3MpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VWZWN0b3I6IGZ1bmN0aW9uKCB2MSwgdjIgKXtcclxuXHJcbiAgICAgICAgdmFyIHhkID0gdjEueCAtIHYyLng7XHJcbiAgICAgICAgdmFyIHlkID0gdjEueSAtIHYyLnk7XHJcbiAgICAgICAgdmFyIHpkID0gdjEueiAtIHYyLno7XHJcbiAgICAgICAgcmV0dXJuIHhkICogeGQgKyB5ZCAqIHlkICsgemQgKiB6ZDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRvdFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueSArIGEueiAqIGIuejtcclxuXHJcbiAgICB9LFxyXG5cclxufTtcblxuZnVuY3Rpb24gcHJpbnRFcnJvciggY2xhenosIG1zZyApe1xyXG4gICAgY29uc29sZS5lcnJvcihcIltPSU1PXSBcIiArIGNsYXp6ICsgXCI6IFwiICsgbXNnKTtcclxufVxyXG5cclxuLy8gQSBwZXJmb3JtYW5jZSBldmFsdWF0b3JcclxuXHJcbmZ1bmN0aW9uIEluZm9EaXNwbGF5KHdvcmxkKXtcclxuXHJcbiAgICB0aGlzLnBhcmVudCA9IHdvcmxkO1xyXG5cclxuICAgIHRoaXMuaW5mb3MgPSBuZXcgRmxvYXQzMkFycmF5KCAxMyApO1xyXG4gICAgdGhpcy5mID0gWzAsMCwwXTtcclxuXHJcbiAgICB0aGlzLnRpbWVzID0gWzAsMCwwLDBdO1xyXG5cclxuICAgIHRoaXMuYnJvYWRQaGFzZSA9IHRoaXMucGFyZW50LmJyb2FkUGhhc2VUeXBlO1xyXG5cclxuICAgIHRoaXMudmVyc2lvbiA9IFJFVklTSU9OO1xyXG5cclxuICAgIHRoaXMuZnBzID0gMDtcclxuXHJcbiAgICB0aGlzLnR0ID0gMDtcclxuXHJcbiAgICB0aGlzLmJyb2FkUGhhc2VUaW1lID0gMDtcclxuICAgIHRoaXMubmFycm93UGhhc2VUaW1lID0gMDtcclxuICAgIHRoaXMuc29sdmluZ1RpbWUgPSAwO1xyXG4gICAgdGhpcy50b3RhbFRpbWUgPSAwO1xyXG4gICAgdGhpcy51cGRhdGVUaW1lID0gMDtcclxuXHJcbiAgICB0aGlzLk1heEJyb2FkUGhhc2VUaW1lID0gMDtcclxuICAgIHRoaXMuTWF4TmFycm93UGhhc2VUaW1lID0gMDtcclxuICAgIHRoaXMuTWF4U29sdmluZ1RpbWUgPSAwO1xyXG4gICAgdGhpcy5NYXhUb3RhbFRpbWUgPSAwO1xyXG4gICAgdGhpcy5NYXhVcGRhdGVUaW1lID0gMDtcclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggSW5mb0Rpc3BsYXkucHJvdG90eXBlLCB7XHJcblxyXG4gICAgc2V0VGltZTogZnVuY3Rpb24obil7XHJcbiAgICAgICAgdGhpcy50aW1lc1sgbiB8fCAwIF0gPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRNYXg6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHRoaXMuTWF4QnJvYWRQaGFzZVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuTWF4TmFycm93UGhhc2VUaW1lID0gMDtcclxuICAgICAgICB0aGlzLk1heFNvbHZpbmdUaW1lID0gMDtcclxuICAgICAgICB0aGlzLk1heFRvdGFsVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5NYXhVcGRhdGVUaW1lID0gMDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNhbGNCcm9hZFBoYXNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VGltZSggMiApO1xyXG4gICAgICAgIHRoaXMuYnJvYWRQaGFzZVRpbWUgPSB0aGlzLnRpbWVzWyAyIF0gLSB0aGlzLnRpbWVzWyAxIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjYWxjTmFycm93UGhhc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRUaW1lKCAzICk7XHJcbiAgICAgICAgdGhpcy5uYXJyb3dQaGFzZVRpbWUgPSB0aGlzLnRpbWVzWyAzIF0gLSB0aGlzLnRpbWVzWyAyIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjYWxjRW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VGltZSggMiApO1xyXG4gICAgICAgIHRoaXMuc29sdmluZ1RpbWUgPSB0aGlzLnRpbWVzWyAyIF0gLSB0aGlzLnRpbWVzWyAxIF07XHJcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0aGlzLnRpbWVzWyAyIF0gLSB0aGlzLnRpbWVzWyAwIF07XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lID0gdGhpcy50b3RhbFRpbWUgLSAoIHRoaXMuYnJvYWRQaGFzZVRpbWUgKyB0aGlzLm5hcnJvd1BoYXNlVGltZSArIHRoaXMuc29sdmluZ1RpbWUgKTtcclxuXHJcbiAgICAgICAgaWYoIHRoaXMudHQgPT09IDEwMCApIHRoaXMucmVzZXRNYXgoKTtcclxuXHJcbiAgICAgICAgaWYoIHRoaXMudHQgPiAxMDAgKXtcclxuICAgICAgICAgICAgaWYoIHRoaXMuYnJvYWRQaGFzZVRpbWUgPiB0aGlzLk1heEJyb2FkUGhhc2VUaW1lICkgdGhpcy5NYXhCcm9hZFBoYXNlVGltZSA9IHRoaXMuYnJvYWRQaGFzZVRpbWU7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLm5hcnJvd1BoYXNlVGltZSA+IHRoaXMuTWF4TmFycm93UGhhc2VUaW1lICkgdGhpcy5NYXhOYXJyb3dQaGFzZVRpbWUgPSB0aGlzLm5hcnJvd1BoYXNlVGltZTtcclxuICAgICAgICAgICAgaWYoIHRoaXMuc29sdmluZ1RpbWUgPiB0aGlzLk1heFNvbHZpbmdUaW1lICkgdGhpcy5NYXhTb2x2aW5nVGltZSA9IHRoaXMuc29sdmluZ1RpbWU7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLnRvdGFsVGltZSA+IHRoaXMuTWF4VG90YWxUaW1lICkgdGhpcy5NYXhUb3RhbFRpbWUgPSB0aGlzLnRvdGFsVGltZTtcclxuICAgICAgICAgICAgaWYoIHRoaXMudXBkYXRlVGltZSA+IHRoaXMuTWF4VXBkYXRlVGltZSApIHRoaXMuTWF4VXBkYXRlVGltZSA9IHRoaXMudXBkYXRlVGltZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB0aGlzLnVwZnBzKCk7XHJcblxyXG4gICAgICAgIHRoaXMudHQgKys7XHJcbiAgICAgICAgaWYodGhpcy50dCA+IDUwMCkgdGhpcy50dCA9IDA7XHJcblxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgdXBmcHMgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuZlsxXSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZlsxXS0xMDAwPnRoaXMuZlswXSl7IHRoaXMuZlswXSA9IHRoaXMuZlsxXTsgdGhpcy5mcHMgPSB0aGlzLmZbMl07IHRoaXMuZlsyXSA9IDA7IH0gdGhpcy5mWzJdKys7XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3c6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGluZm8gPVtcclxuICAgICAgICAgICAgXCJPaW1vLmpzIFwiK3RoaXMudmVyc2lvbitcIjxicj5cIixcclxuICAgICAgICAgICAgdGhpcy5icm9hZFBoYXNlICsgXCI8YnI+PGJyPlwiLFxyXG4gICAgICAgICAgICBcIkZQUzogXCIgKyB0aGlzLmZwcyArXCIgZnBzPGJyPjxicj5cIixcclxuICAgICAgICAgICAgXCJyaWdpZGJvZHkgXCIrdGhpcy5wYXJlbnQubnVtUmlnaWRCb2RpZXMrXCI8YnI+XCIsXHJcbiAgICAgICAgICAgIFwiY29udGFjdCAmbmJzcDsmbmJzcDtcIit0aGlzLnBhcmVudC5udW1Db250YWN0cytcIjxicj5cIixcclxuICAgICAgICAgICAgXCJjdC1wb2ludCAmbmJzcDtcIit0aGlzLnBhcmVudC5udW1Db250YWN0UG9pbnRzK1wiPGJyPlwiLFxyXG4gICAgICAgICAgICBcInBhaXJjaGVjayBcIit0aGlzLnBhcmVudC5icm9hZFBoYXNlLm51bVBhaXJDaGVja3MrXCI8YnI+XCIsXHJcbiAgICAgICAgICAgIFwiaXNsYW5kICZuYnNwOyZuYnNwOyZuYnNwO1wiK3RoaXMucGFyZW50Lm51bUlzbGFuZHMgK1wiPGJyPjxicj5cIixcclxuICAgICAgICAgICAgXCJUaW1lIGluIG1pbGxpc2Vjb25kczxicj48YnI+XCIsXHJcbiAgICAgICAgICAgIFwiYnJvYWRwaGFzZSAmbmJzcDtcIisgX01hdGguZml4KHRoaXMuYnJvYWRQaGFzZVRpbWUpICsgXCIgfCBcIiArIF9NYXRoLmZpeCh0aGlzLk1heEJyb2FkUGhhc2VUaW1lKSArXCI8YnI+XCIsXHJcbiAgICAgICAgICAgIFwibmFycm93cGhhc2UgXCIrIF9NYXRoLmZpeCh0aGlzLm5hcnJvd1BoYXNlVGltZSkgICsgXCIgfCBcIiArIF9NYXRoLmZpeCh0aGlzLk1heE5hcnJvd1BoYXNlVGltZSkgKyBcIjxicj5cIixcclxuICAgICAgICAgICAgXCJzb2x2aW5nICZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1wiKyBfTWF0aC5maXgodGhpcy5zb2x2aW5nVGltZSkrIFwiIHwgXCIgKyBfTWF0aC5maXgodGhpcy5NYXhTb2x2aW5nVGltZSkgKyBcIjxicj5cIixcclxuICAgICAgICAgICAgXCJ0b3RhbCAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcIisgX01hdGguZml4KHRoaXMudG90YWxUaW1lKSArIFwiIHwgXCIgKyBfTWF0aC5maXgodGhpcy5NYXhUb3RhbFRpbWUpICsgXCI8YnI+XCIsXHJcbiAgICAgICAgICAgIFwidXBkYXRpbmcgJm5ic3A7Jm5ic3A7Jm5ic3A7XCIrIF9NYXRoLmZpeCh0aGlzLnVwZGF0ZVRpbWUpICsgXCIgfCBcIiArIF9NYXRoLmZpeCh0aGlzLk1heFVwZGF0ZVRpbWUpICsgXCI8YnI+XCJcclxuICAgICAgICBdLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgcmV0dXJuIGluZm87XHJcbiAgICB9LFxyXG5cclxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5pbmZvc1swXSA9IHRoaXMucGFyZW50LmJyb2FkUGhhc2UudHlwZXM7XHJcbiAgICAgICAgdGhpcy5pbmZvc1sxXSA9IHRoaXMucGFyZW50Lm51bVJpZ2lkQm9kaWVzO1xyXG4gICAgICAgIHRoaXMuaW5mb3NbMl0gPSB0aGlzLnBhcmVudC5udW1Db250YWN0cztcclxuICAgICAgICB0aGlzLmluZm9zWzNdID0gdGhpcy5wYXJlbnQuYnJvYWRQaGFzZS5udW1QYWlyQ2hlY2tzO1xyXG4gICAgICAgIHRoaXMuaW5mb3NbNF0gPSB0aGlzLnBhcmVudC5udW1Db250YWN0UG9pbnRzO1xyXG4gICAgICAgIHRoaXMuaW5mb3NbNV0gPSB0aGlzLnBhcmVudC5udW1Jc2xhbmRzO1xyXG4gICAgICAgIHRoaXMuaW5mb3NbNl0gPSB0aGlzLmJyb2FkUGhhc2VUaW1lO1xyXG4gICAgICAgIHRoaXMuaW5mb3NbN10gPSB0aGlzLm5hcnJvd1BoYXNlVGltZTtcclxuICAgICAgICB0aGlzLmluZm9zWzhdID0gdGhpcy5zb2x2aW5nVGltZTtcclxuICAgICAgICB0aGlzLmluZm9zWzldID0gdGhpcy51cGRhdGVUaW1lO1xyXG4gICAgICAgIHRoaXMuaW5mb3NbMTBdID0gdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgICAgdGhpcy5pbmZvc1sxMV0gPSB0aGlzLmZwcztcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmZvcztcclxuICAgIH1cclxuICAgIFxyXG59KTtcblxuZnVuY3Rpb24gVmVjMyAoIHgsIHksIHogKSB7XG5cbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICAgIHRoaXMueiA9IHogfHwgMDtcbiAgICBcbn1cblxuT2JqZWN0LmFzc2lnbiggVmVjMy5wcm90b3R5cGUsIHtcblxuICAgIFZlYzM6IHRydWUsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKCB4LCB5LCB6ICl7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICAgICAgaWYgKCBiICE9PSB1bmRlZmluZWQgKSByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCBhLCBiICk7XG5cbiAgICAgICAgdGhpcy54ICs9IGEueDtcbiAgICAgICAgdGhpcy55ICs9IGEueTtcbiAgICAgICAgdGhpcy56ICs9IGEuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55ICsgYi55O1xuICAgICAgICB0aGlzLnogPSBhLnogKyBiLno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGFkZEVxdWFsOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgICAgdGhpcy55ICs9IHYueTtcbiAgICAgICAgdGhpcy56ICs9IHYuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICAgICAgaWYgKCBiICE9PSB1bmRlZmluZWQgKSByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCBhLCBiICk7XG5cbiAgICAgICAgdGhpcy54IC09IGEueDtcbiAgICAgICAgdGhpcy55IC09IGEueTtcbiAgICAgICAgdGhpcy56IC09IGEuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xuICAgICAgICB0aGlzLnogPSBhLnogLSBiLno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YkVxdWFsOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgICAgdGhpcy55IC09IHYueTtcbiAgICAgICAgdGhpcy56IC09IHYuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuICAgICAgICB0aGlzLnggPSB2LnggKiBzO1xuICAgICAgICB0aGlzLnkgPSB2LnkgKiBzO1xuICAgICAgICB0aGlzLnogPSB2LnogKiBzO1xuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBzY2FsZUVxdWFsOiBmdW5jdGlvbiggcyApe1xuXG4gICAgICAgIHRoaXMueCAqPSBzO1xuICAgICAgICB0aGlzLnkgKj0gcztcbiAgICAgICAgdGhpcy56ICo9IHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiggdiApe1xuXG4gICAgICAgIHRoaXMueCAqPSB2Lng7XG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XG4gICAgICAgIHRoaXMueiAqPSB2Lno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiggcyApe1xuXG4gICAgICAgIHRoaXMueCAqPSBzO1xuICAgICAgICB0aGlzLnkgKj0gcztcbiAgICAgICAgdGhpcy56ICo9IHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qc2NhbGVWOiBmdW5jdGlvbiggdiApe1xuXG4gICAgICAgIHRoaXMueCAqPSB2Lng7XG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XG4gICAgICAgIHRoaXMueiAqPSB2Lno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHNjYWxlVmVjdG9yRXF1YWw6IGZ1bmN0aW9uKCB2ICl7XG5cbiAgICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgICAgdGhpcy56ICo9IHYuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LCovXG5cbiAgICBhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuICAgICAgICB0aGlzLnggKz0gdi54ICogcztcbiAgICAgICAgdGhpcy55ICs9IHYueSAqIHM7XG4gICAgICAgIHRoaXMueiArPSB2LnogKiBzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHN1YlNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG4gICAgICAgIHRoaXMueCAtPSB2LnggKiBzO1xuICAgICAgICB0aGlzLnkgLT0gdi55ICogcztcbiAgICAgICAgdGhpcy56IC09IHYueiAqIHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyphZGRUaW1lOiBmdW5jdGlvbiAoIHYsIHQgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHYueCAqIHQ7XG4gICAgICAgIHRoaXMueSArPSB2LnkgKiB0O1xuICAgICAgICB0aGlzLnogKz0gdi56ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuICAgIFxuICAgIGFkZFNjYWxlOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cbiAgICAgICAgdGhpcy54ICs9IHYueCAqIHM7XG4gICAgICAgIHRoaXMueSArPSB2LnkgKiBzO1xuICAgICAgICB0aGlzLnogKz0gdi56ICogcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc3ViU2NhbGU6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuICAgICAgICB0aGlzLnggLT0gdi54ICogcztcbiAgICAgICAgdGhpcy55IC09IHYueSAqIHM7XG4gICAgICAgIHRoaXMueiAtPSB2LnogKiBzO1xuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sKi9cbiAgIFxuICAgIGNyb3NzOiBmdW5jdGlvbiggYSwgYiApIHtcblxuICAgICAgICBpZiAoIGIgIT09IHVuZGVmaW5lZCApIHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggYSwgYiApO1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG4gICAgICAgIHRoaXMueCA9IHkgKiBhLnogLSB6ICogYS55O1xuICAgICAgICB0aGlzLnkgPSB6ICogYS54IC0geCAqIGEuejtcbiAgICAgICAgdGhpcy56ID0geCAqIGEueSAtIHkgKiBhLng7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICAgICAgdmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG4gICAgICAgIHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG4gICAgICAgIHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgICAgICB0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICAgICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgdGFuZ2VudDogZnVuY3Rpb24gKCBhICkge1xuXG4gICAgICAgIHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXG4gICAgICAgIHRoaXMueCA9IGF5ICogYXggLSBheiAqIGF6O1xuICAgICAgICB0aGlzLnkgPSAtIGF6ICogYXkgLSBheCAqIGF4O1xuICAgICAgICB0aGlzLnogPSBheCAqIGF6ICsgYXkgKiBheTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBcblxuICAgIFxuXG4gICAgaW52ZXJ0OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICAgICAgdGhpcy54PS12Lng7XG4gICAgICAgIHRoaXMueT0tdi55O1xuICAgICAgICB0aGlzLno9LXYuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy54ID0gLSB0aGlzLng7XG4gICAgICAgIHRoaXMueSA9IC0gdGhpcy55O1xuICAgICAgICB0aGlzLnogPSAtIHRoaXMuejtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG4gICAgfSxcblxuICAgIGFkZGl0aW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMueSArIHRoaXMuejtcblxuICAgIH0sXG5cbiAgICBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIF9NYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCB2ICl7XG5cbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICAgIHRoaXMueiA9IHYuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyptdWw6IGZ1bmN0aW9uKCBiLCBhLCBtICl7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubXVsTWF0KCBtLCBhICkuYWRkKCBiICk7XG5cbiAgICB9LFxuXG4gICAgbXVsTWF0OiBmdW5jdGlvbiggbSwgYSApe1xuXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcbiAgICAgICAgdmFyIHggPSBhLngsIHkgPSBhLnksIHogPSBhLno7XG5cbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDEgXSAqIHkgKyBlWyAyIF0gKiB6O1xuICAgICAgICB0aGlzLnkgPSBlWyAzIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDUgXSAqIHo7XG4gICAgICAgIHRoaXMueiA9IGVbIDYgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgOCBdICogejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LCovXG5cbiAgICBhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSwgdHJhbnNwb3NlICkge1xuXG4gICAgICAgIC8vaWYoIHRyYW5zcG9zZSApIG0gPSBtLmNsb25lKCkudHJhbnNwb3NlKCk7XG4gICAgICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgICAgaWYoIHRyYW5zcG9zZSApe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMSBdICogeSArIGVbIDIgXSAqIHo7XG4gICAgICAgICAgICB0aGlzLnkgPSBlWyAzIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDUgXSAqIHo7XG4gICAgICAgICAgICB0aGlzLnogPSBlWyA2IF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDggXSAqIHo7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuICAgICAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuICAgICAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgICAgICB2YXIgcXggPSBxLng7XG4gICAgICAgIHZhciBxeSA9IHEueTtcbiAgICAgICAgdmFyIHF6ID0gcS56O1xuICAgICAgICB2YXIgcXcgPSBxLnc7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuICAgICAgICB2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgICAgICB2YXIgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICAgICAgICB2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgICAgICB2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgICAgICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcbiAgICAgICAgdGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcbiAgICAgICAgdGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0ZXN0WmVybzogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmKHRoaXMueCE9PTAgfHwgdGhpcy55IT09MCB8fCB0aGlzLnohPT0wKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgdGVzdERpZmY6IGZ1bmN0aW9uKCB2ICl7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKCB2ICkgPyBmYWxzZSA6IHRydWU7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICAgICAgcmV0dXJuIHYueCA9PT0gdGhpcy54ICYmIHYueSA9PT0gdGhpcy55ICYmIHYueiA9PT0gdGhpcy56O1xuXG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgcmV0dXJuXCJWZWMzW1wiK3RoaXMueC50b0ZpeGVkKDQpK1wiLCBcIit0aGlzLnkudG9GaXhlZCg0KStcIiwgXCIrdGhpcy56LnRvRml4ZWQoNCkrXCJdXCI7XG4gICAgICAgIFxuICAgIH0sXG5cbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICAgICAgaWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XG4gICAgICAgICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgICAgIHRoaXMueiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICB9LFxuXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuICAgIH0sXG5cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICl7XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuXG59ICk7XG5cbmZ1bmN0aW9uIFF1YXQgKCB4LCB5LCB6LCB3ICl7XG5cbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICAgIHRoaXMueiA9IHogfHwgMDtcbiAgICB0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggUXVhdC5wcm90b3R5cGUsIHtcblxuICAgIFF1YXQ6IHRydWUsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuICAgICAgICBcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgdGhpcy53ID0gdztcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBhZGRUaW1lOiBmdW5jdGlvbiggdiwgdCApe1xuXG4gICAgICAgIHZhciBheCA9IHYueCwgYXkgPSB2LnksIGF6ID0gdi56O1xuICAgICAgICB2YXIgcXcgPSB0aGlzLncsIHF4ID0gdGhpcy54LCBxeSA9IHRoaXMueSwgcXogPSB0aGlzLno7XG4gICAgICAgIHQgKj0gMC41OyAgICBcbiAgICAgICAgdGhpcy54ICs9IHQgKiAoICBheCpxdyArIGF5KnF6IC0gYXoqcXkgKTtcbiAgICAgICAgdGhpcy55ICs9IHQgKiAoICBheSpxdyArIGF6KnF4IC0gYXgqcXogKTtcbiAgICAgICAgdGhpcy56ICs9IHQgKiAoICBheipxdyArIGF4KnF5IC0gYXkqcXggKTtcbiAgICAgICAgdGhpcy53ICs9IHQgKiAoIC1heCpxeCAtIGF5KnF5IC0gYXoqcXogKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyptdWw6IGZ1bmN0aW9uKCBxMSwgcTIgKXtcblxuICAgICAgICB2YXIgYXggPSBxMS54LCBheSA9IHExLnksIGF6ID0gcTEueiwgYXMgPSBxMS53LFxuICAgICAgICBieCA9IHEyLngsIGJ5ID0gcTIueSwgYnogPSBxMi56LCBicyA9IHEyLnc7XG4gICAgICAgIHRoaXMueCA9IGF4ICogYnMgKyBhcyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgICAgIHRoaXMueSA9IGF5ICogYnMgKyBhcyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgICAgIHRoaXMueiA9IGF6ICogYnMgKyBhcyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgICAgIHRoaXMudyA9IGFzICogYnMgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSwqL1xuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcblxuICAgICAgICBpZiAoIHAgIT09IHVuZGVmaW5lZCApIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG4gICAgfSxcblxuICAgIG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgICAgICB2YXIgcWF4ID0gYS54LCBxYXkgPSBhLnksIHFheiA9IGEueiwgcWF3ID0gYS53O1xuICAgICAgICB2YXIgcWJ4ID0gYi54LCBxYnkgPSBiLnksIHFieiA9IGIueiwgcWJ3ID0gYi53O1xuXG4gICAgICAgIHRoaXMueCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcbiAgICAgICAgdGhpcy55ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuICAgICAgICB0aGlzLnogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG4gICAgICAgIHRoaXMudyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiggdjEsIHYyICkge1xuXG4gICAgICAgIHZhciB2eCA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHZhciByID0gdjEuZG90KCB2MiApICsgMTtcblxuICAgICAgICBpZiAoIHIgPCBfTWF0aC5FUFMyICkge1xuXG4gICAgICAgICAgICByID0gMDtcbiAgICAgICAgICAgIGlmICggX01hdGguYWJzKCB2MS54ICkgPiBfTWF0aC5hYnMoIHYxLnogKSApIHZ4LnNldCggLSB2MS55LCB2MS54LCAwICk7XG4gICAgICAgICAgICBlbHNlIHZ4LnNldCggMCwgLSB2MS56LCB2MS55ICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdnguY3Jvc3NWZWN0b3JzKCB2MSwgdjIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5feCA9IHZ4Lng7XG4gICAgICAgIHRoaXMuX3kgPSB2eC55O1xuICAgICAgICB0aGlzLl96ID0gdnguejtcbiAgICAgICAgdGhpcy5fdyA9IHI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICB9LFxuXG4gICAgYXJjOiBmdW5jdGlvbiggdjEsIHYyICl7XG5cbiAgICAgICAgdmFyIHgxID0gdjEueDtcbiAgICAgICAgdmFyIHkxID0gdjEueTtcbiAgICAgICAgdmFyIHoxID0gdjEuejtcbiAgICAgICAgdmFyIHgyID0gdjIueDtcbiAgICAgICAgdmFyIHkyID0gdjIueTtcbiAgICAgICAgdmFyIHoyID0gdjIuejtcbiAgICAgICAgdmFyIGQgPSB4MSp4MiArIHkxKnkyICsgejEqejI7XG4gICAgICAgIGlmKCBkPT0tMSApe1xuICAgICAgICAgICAgeDIgPSB5MSp4MSAtIHoxKnoxO1xuICAgICAgICAgICAgeTIgPSAtejEqeTEgLSB4MSp4MTtcbiAgICAgICAgICAgIHoyID0geDEqejEgKyB5MSp5MTtcbiAgICAgICAgICAgIGQgPSAxIC8gX01hdGguc3FydCggeDIqeDIgKyB5Mip5MiArIHoyKnoyICk7XG4gICAgICAgICAgICB0aGlzLncgPSAwO1xuICAgICAgICAgICAgdGhpcy54ID0geDIqZDtcbiAgICAgICAgICAgIHRoaXMueSA9IHkyKmQ7XG4gICAgICAgICAgICB0aGlzLnogPSB6MipkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN4ID0geTEqejIgLSB6MSp5MjtcbiAgICAgICAgdmFyIGN5ID0gejEqeDIgLSB4MSp6MjtcbiAgICAgICAgdmFyIGN6ID0geDEqeTIgLSB5MSp4MjtcbiAgICAgICAgdGhpcy53ID0gX01hdGguc3FydCggKCAxICsgZCkgKiAwLjUgKTtcbiAgICAgICAgZCA9IDAuNSAvIHRoaXMudztcbiAgICAgICAgdGhpcy54ID0gY3ggKiBkO1xuICAgICAgICB0aGlzLnkgPSBjeSAqIGQ7XG4gICAgICAgIHRoaXMueiA9IGN6ICogZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBsID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKCBsID09PSAwICkge1xuICAgICAgICAgICAgdGhpcy5zZXQoIDAsIDAsIDAsIDEgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSAxIC8gbDtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCAqIGw7XG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnkgKiBsO1xuICAgICAgICAgICAgdGhpcy56ID0gdGhpcy56ICogbDtcbiAgICAgICAgICAgIHRoaXMudyA9IHRoaXMudyAqIGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgaW52ZXJzZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG4gICAgfSxcblxuICAgIGludmVydDogZnVuY3Rpb24gKCBxICkge1xuXG4gICAgICAgIHRoaXMueCA9IHEueDtcbiAgICAgICAgdGhpcy55ID0gcS55O1xuICAgICAgICB0aGlzLnogPSBxLno7XG4gICAgICAgIHRoaXMudyA9IHEudztcbiAgICAgICAgdGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgY29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy54ICo9IC0gMTtcbiAgICAgICAgdGhpcy55ICo9IC0gMTtcbiAgICAgICAgdGhpcy56ICo9IC0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHJldHVybiBfTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgICk7XG5cbiAgICB9LFxuXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xuXG4gICAgfSxcbiAgICBcbiAgICBjb3B5OiBmdW5jdGlvbiggcSApe1xuICAgICAgICBcbiAgICAgICAgdGhpcy54ID0gcS54O1xuICAgICAgICB0aGlzLnkgPSBxLnk7XG4gICAgICAgIHRoaXMueiA9IHEuejtcbiAgICAgICAgdGhpcy53ID0gcS53O1xuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oIHEgKXtcblxuICAgICAgICByZXR1cm4gbmV3IFF1YXQoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xuXG4gICAgfSxcblxuICAgIHRlc3REaWZmOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKCBxICkgPyBmYWxzZSA6IHRydWU7XG5cbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcS54ICYmIHRoaXMueSA9PT0gcS55ICYmIHRoaXMueiA9PT0gcS56ICYmIHRoaXMudyA9PT0gcS53O1xuXG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHJldHVyblwiUXVhdFtcIit0aGlzLngudG9GaXhlZCg0KStcIiwgKFwiK3RoaXMueS50b0ZpeGVkKDQpK1wiLCBcIit0aGlzLnoudG9GaXhlZCg0KStcIiwgXCIrdGhpcy53LnRvRml4ZWQoNCkrXCIpXVwiO1xuICAgICAgICBcbiAgICB9LFxuXG4gICAgc2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIHgsIHksIHogKXtcblxuICAgICAgICB2YXIgYzEgPSBNYXRoLmNvcyggeCAqIDAuNSApO1xuICAgICAgICB2YXIgYzIgPSBNYXRoLmNvcyggeSAqIDAuNSApO1xuICAgICAgICB2YXIgYzMgPSBNYXRoLmNvcyggeiAqIDAuNSApO1xuICAgICAgICB2YXIgczEgPSBNYXRoLnNpbiggeCAqIDAuNSApO1xuICAgICAgICB2YXIgczIgPSBNYXRoLnNpbiggeSAqIDAuNSApO1xuICAgICAgICB2YXIgczMgPSBNYXRoLnNpbiggeiAqIDAuNSApO1xuXG4gICAgICAgIC8vIFhZWlxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuICAgIFxuICAgIHNldEZyb21BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIHJhZCApIHtcblxuICAgICAgICBheGlzLm5vcm1hbGl6ZSgpO1xuICAgICAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgICAgIHZhciBzID0gX01hdGguc2luKCByYWQgKTtcbiAgICAgICAgdGhpcy54ID0gcyAqIGF4aXMueDtcbiAgICAgICAgdGhpcy55ID0gcyAqIGF4aXMueTtcbiAgICAgICAgdGhpcy56ID0gcyAqIGF4aXMuejtcbiAgICAgICAgdGhpcy53ID0gX01hdGguY29zKCByYWQgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgc2V0RnJvbU1hdDMzOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAgICAgdmFyIHRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICAgICAgICB2YXIgcztcblxuICAgICAgICBpZiAoIHRyYWNlID4gMCApIHtcblxuICAgICAgICAgICAgcyA9IF9NYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG4gICAgICAgICAgICB0aGlzLncgPSAwLjUgLyBzO1xuICAgICAgICAgICAgcyA9IDAuNSAvIHM7XG4gICAgICAgICAgICB0aGlzLnggPSAoIG1bNV0gLSBtWzddICkgKiBzO1xuICAgICAgICAgICAgdGhpcy55ID0gKCBtWzZdIC0gbVsyXSApICogcztcbiAgICAgICAgICAgIHRoaXMueiA9ICggbVsxXSAtIG1bM10gKSAqIHM7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgaWYgKCBtWzRdID4gbVswXSApIGkgPSAxO1xuICAgICAgICAgICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKSBpID0gMjtcblxuICAgICAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xuICAgICAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzID0gX01hdGguc3FydCggbVtpKjMraV0gLSBtW2oqMytqXSAtIG1bayozK2tdICsgMS4wICk7XG4gICAgICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgICAgIHMgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgICAgIHRoaXMudyA9ICggbVtqKjMra10gLSBtW2sqMytqXSApICogcztcbiAgICAgICAgICAgIG91dFtqXSA9ICggbVtqKjMraV0gKyBtW2kqMytqXSApICogcztcbiAgICAgICAgICAgIG91dFtrXSA9ICggbVtrKjMraV0gKyBtW2kqMytrXSApICogcztcblxuICAgICAgICAgICAgdGhpcy54ID0gb3V0WzFdO1xuICAgICAgICAgICAgdGhpcy55ID0gb3V0WzJdO1xuICAgICAgICAgICAgdGhpcy56ID0gb3V0WzNdO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG4gICAgfSxcblxuICAgIGZyb21BcnJheTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKXtcblxuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgdGhpcy5zZXQoIGFycmF5WyBvZmZzZXQgXSwgYXJyYXlbIG9mZnNldCArIDEgXSwgYXJyYXlbIG9mZnNldCArIDIgXSwgYXJyYXlbIG9mZnNldCArIDMgXSApO1xuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIE1hdDMzICggZTAwLCBlMDEsIGUwMiwgZTEwLCBlMTEsIGUxMiwgZTIwLCBlMjEsIGUyMiApe1xyXG5cclxuICAgIHRoaXMuZWxlbWVudHMgPSBbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgIF07XHJcblxyXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ09JTU8uTWF0MzM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIE1hdDMzLnByb3RvdHlwZSwge1xyXG5cclxuICAgIE1hdDMzOiB0cnVlLFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCBlMDAsIGUwMSwgZTAyLCBlMTAsIGUxMSwgZTEyLCBlMjAsIGUyMSwgZTIyICl7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdGVbMF0gPSBlMDA7IHRlWzFdID0gZTAxOyB0ZVsyXSA9IGUwMjtcclxuICAgICAgICB0ZVszXSA9IGUxMDsgdGVbNF0gPSBlMTE7IHRlWzVdID0gZTEyO1xyXG4gICAgICAgIHRlWzZdID0gZTIwOyB0ZVs3XSA9IGUyMTsgdGVbOF0gPSBlMjI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgYWRkOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIGlmKCBiICE9PSB1bmRlZmluZWQgKSByZXR1cm4gdGhpcy5hZGRNYXRyaXhzKCBhLCBiICk7XHJcblxyXG4gICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cywgdGUgPSBhLmVsZW1lbnRzO1xyXG4gICAgICAgIGVbMF0gKz0gdGVbMF07IGVbMV0gKz0gdGVbMV07IGVbMl0gKz0gdGVbMl07XHJcbiAgICAgICAgZVszXSArPSB0ZVszXTsgZVs0XSArPSB0ZVs0XTsgZVs1XSArPSB0ZVs1XTtcclxuICAgICAgICBlWzZdICs9IHRlWzZdOyBlWzddICs9IHRlWzddOyBlWzhdICs9IHRlWzhdO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkTWF0cml4czogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLCB0ZW0xID0gYS5lbGVtZW50cywgdGVtMiA9IGIuZWxlbWVudHM7XHJcbiAgICAgICAgdGVbMF0gPSB0ZW0xWzBdICsgdGVtMlswXTsgdGVbMV0gPSB0ZW0xWzFdICsgdGVtMlsxXTsgdGVbMl0gPSB0ZW0xWzJdICsgdGVtMlsyXTtcclxuICAgICAgICB0ZVszXSA9IHRlbTFbM10gKyB0ZW0yWzNdOyB0ZVs0XSA9IHRlbTFbNF0gKyB0ZW0yWzRdOyB0ZVs1XSA9IHRlbTFbNV0gKyB0ZW0yWzVdO1xyXG4gICAgICAgIHRlWzZdID0gdGVtMVs2XSArIHRlbTJbNl07IHRlWzddID0gdGVtMVs3XSArIHRlbTJbN107IHRlWzhdID0gdGVtMVs4XSArIHRlbTJbOF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRFcXVhbDogZnVuY3Rpb24oIG0gKXtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cywgdGVtID0gbS5lbGVtZW50cztcclxuICAgICAgICB0ZVswXSArPSB0ZW1bMF07IHRlWzFdICs9IHRlbVsxXTsgdGVbMl0gKz0gdGVtWzJdO1xyXG4gICAgICAgIHRlWzNdICs9IHRlbVszXTsgdGVbNF0gKz0gdGVtWzRdOyB0ZVs1XSArPSB0ZW1bNV07XHJcbiAgICAgICAgdGVbNl0gKz0gdGVtWzZdOyB0ZVs3XSArPSB0ZW1bN107IHRlWzhdICs9IHRlbVs4XTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN1YjogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICBpZiggYiAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHRoaXMuc3ViTWF0cml4cyggYSwgYiApO1xyXG5cclxuICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHMsIHRlID0gYS5lbGVtZW50cztcclxuICAgICAgICBlWzBdIC09IHRlWzBdOyBlWzFdIC09IHRlWzFdOyBlWzJdIC09IHRlWzJdO1xyXG4gICAgICAgIGVbM10gLT0gdGVbM107IGVbNF0gLT0gdGVbNF07IGVbNV0gLT0gdGVbNV07XHJcbiAgICAgICAgZVs2XSAtPSB0ZVs2XTsgZVs3XSAtPSB0ZVs3XTsgZVs4XSAtPSB0ZVs4XTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN1Yk1hdHJpeHM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cywgdGVtMSA9IGEuZWxlbWVudHMsIHRlbTIgPSBiLmVsZW1lbnRzO1xyXG4gICAgICAgIHRlWzBdID0gdGVtMVswXSAtIHRlbTJbMF07IHRlWzFdID0gdGVtMVsxXSAtIHRlbTJbMV07IHRlWzJdID0gdGVtMVsyXSAtIHRlbTJbMl07XHJcbiAgICAgICAgdGVbM10gPSB0ZW0xWzNdIC0gdGVtMlszXTsgdGVbNF0gPSB0ZW0xWzRdIC0gdGVtMls0XTsgdGVbNV0gPSB0ZW0xWzVdIC0gdGVtMls1XTtcclxuICAgICAgICB0ZVs2XSA9IHRlbTFbNl0gLSB0ZW0yWzZdOyB0ZVs3XSA9IHRlbTFbN10gLSB0ZW0yWzddOyB0ZVs4XSA9IHRlbTFbOF0gLSB0ZW0yWzhdO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViRXF1YWw6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cywgdGVtID0gbS5lbGVtZW50cztcclxuICAgICAgICB0ZVswXSAtPSB0ZW1bMF07IHRlWzFdIC09IHRlbVsxXTsgdGVbMl0gLT0gdGVtWzJdO1xyXG4gICAgICAgIHRlWzNdIC09IHRlbVszXTsgdGVbNF0gLT0gdGVtWzRdOyB0ZVs1XSAtPSB0ZW1bNV07XHJcbiAgICAgICAgdGVbNl0gLT0gdGVtWzZdOyB0ZVs3XSAtPSB0ZW1bN107IHRlWzhdIC09IHRlbVs4XTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiBmdW5jdGlvbiAoIG0sIHMgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHMsIHRtID0gbS5lbGVtZW50cztcclxuICAgICAgICB0ZVswXSA9IHRtWzBdICogczsgdGVbMV0gPSB0bVsxXSAqIHM7IHRlWzJdID0gdG1bMl0gKiBzO1xyXG4gICAgICAgIHRlWzNdID0gdG1bM10gKiBzOyB0ZVs0XSA9IHRtWzRdICogczsgdGVbNV0gPSB0bVs1XSAqIHM7XHJcbiAgICAgICAgdGVbNl0gPSB0bVs2XSAqIHM7IHRlWzddID0gdG1bN10gKiBzOyB0ZVs4XSA9IHRtWzhdICogcztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlRXF1YWw6IGZ1bmN0aW9uICggcyApey8vIG11bHRpcGx5U2NhbGFyXHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdGVbMF0gKj0gczsgdGVbMV0gKj0gczsgdGVbMl0gKj0gcztcclxuICAgICAgICB0ZVszXSAqPSBzOyB0ZVs0XSAqPSBzOyB0ZVs1XSAqPSBzO1xyXG4gICAgICAgIHRlWzZdICo9IHM7IHRlWzddICo9IHM7IHRlWzhdICo9IHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIG0xLCBtMiwgdHJhbnNwb3NlICkge1xyXG5cclxuICAgICAgICBpZiggdHJhbnNwb3NlICkgbTIgPSBtMi5jbG9uZSgpLnRyYW5zcG9zZSgpO1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciB0bTEgPSBtMS5lbGVtZW50cztcclxuICAgICAgICB2YXIgdG0yID0gbTIuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHZhciBhMCA9IHRtMVswXSwgYTMgPSB0bTFbM10sIGE2ID0gdG0xWzZdO1xyXG4gICAgICAgIHZhciBhMSA9IHRtMVsxXSwgYTQgPSB0bTFbNF0sIGE3ID0gdG0xWzddO1xyXG4gICAgICAgIHZhciBhMiA9IHRtMVsyXSwgYTUgPSB0bTFbNV0sIGE4ID0gdG0xWzhdO1xyXG5cclxuICAgICAgICB2YXIgYjAgPSB0bTJbMF0sIGIzID0gdG0yWzNdLCBiNiA9IHRtMls2XTtcclxuICAgICAgICB2YXIgYjEgPSB0bTJbMV0sIGI0ID0gdG0yWzRdLCBiNyA9IHRtMls3XTtcclxuICAgICAgICB2YXIgYjIgPSB0bTJbMl0sIGI1ID0gdG0yWzVdLCBiOCA9IHRtMls4XTtcclxuXHJcbiAgICAgICAgdGVbMF0gPSBhMCpiMCArIGExKmIzICsgYTIqYjY7XHJcbiAgICAgICAgdGVbMV0gPSBhMCpiMSArIGExKmI0ICsgYTIqYjc7XHJcbiAgICAgICAgdGVbMl0gPSBhMCpiMiArIGExKmI1ICsgYTIqYjg7XHJcbiAgICAgICAgdGVbM10gPSBhMypiMCArIGE0KmIzICsgYTUqYjY7XHJcbiAgICAgICAgdGVbNF0gPSBhMypiMSArIGE0KmI0ICsgYTUqYjc7XHJcbiAgICAgICAgdGVbNV0gPSBhMypiMiArIGE0KmI1ICsgYTUqYjg7XHJcbiAgICAgICAgdGVbNl0gPSBhNipiMCArIGE3KmIzICsgYTgqYjY7XHJcbiAgICAgICAgdGVbN10gPSBhNipiMSArIGE3KmI0ICsgYTgqYjc7XHJcbiAgICAgICAgdGVbOF0gPSBhNipiMiArIGE3KmI1ICsgYTgqYjg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyptdWw6IGZ1bmN0aW9uICggbTEsIG0yLCB0cmFuc3Bvc2UgKSB7XHJcblxyXG4gICAgICAgIGlmKCB0cmFuc3Bvc2UgKSBtMiA9IG0yLmNsb25lKCkudHJhbnNwb3NlKCk7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHRtMSA9IG0xLmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciB0bTIgPSBtMi5lbGVtZW50cztcclxuICAgICAgICAvL3ZhciB0bXA7XHJcblxyXG4gICAgICAgIHZhciBhMCA9IHRtMVswXSwgYTMgPSB0bTFbM10sIGE2ID0gdG0xWzZdO1xyXG4gICAgICAgIHZhciBhMSA9IHRtMVsxXSwgYTQgPSB0bTFbNF0sIGE3ID0gdG0xWzddO1xyXG4gICAgICAgIHZhciBhMiA9IHRtMVsyXSwgYTUgPSB0bTFbNV0sIGE4ID0gdG0xWzhdO1xyXG5cclxuICAgICAgICB2YXIgYjAgPSB0bTJbMF0sIGIzID0gdG0yWzNdLCBiNiA9IHRtMls2XTtcclxuICAgICAgICB2YXIgYjEgPSB0bTJbMV0sIGI0ID0gdG0yWzRdLCBiNyA9IHRtMls3XTtcclxuICAgICAgICB2YXIgYjIgPSB0bTJbMl0sIGI1ID0gdG0yWzVdLCBiOCA9IHRtMls4XTtcclxuXHJcbiAgICAgICAgLyppZiggdHJhbnNwb3NlICl7XHJcblxyXG4gICAgICAgICAgICB0bXAgPSBiMTsgYjEgPSBiMzsgYjMgPSB0bXA7XHJcbiAgICAgICAgICAgIHRtcCA9IGIyOyBiMiA9IGI2OyBiNiA9IHRtcDtcclxuICAgICAgICAgICAgdG1wID0gYjU7IGI1ID0gYjc7IGI3ID0gdG1wO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRlWzBdID0gYTAqYjAgKyBhMSpiMyArIGEyKmI2O1xyXG4gICAgICAgIHRlWzFdID0gYTAqYjEgKyBhMSpiNCArIGEyKmI3O1xyXG4gICAgICAgIHRlWzJdID0gYTAqYjIgKyBhMSpiNSArIGEyKmI4O1xyXG4gICAgICAgIHRlWzNdID0gYTMqYjAgKyBhNCpiMyArIGE1KmI2O1xyXG4gICAgICAgIHRlWzRdID0gYTMqYjEgKyBhNCpiNCArIGE1KmI3O1xyXG4gICAgICAgIHRlWzVdID0gYTMqYjIgKyBhNCpiNSArIGE1KmI4O1xyXG4gICAgICAgIHRlWzZdID0gYTYqYjAgKyBhNypiMyArIGE4KmI2O1xyXG4gICAgICAgIHRlWzddID0gYTYqYjEgKyBhNypiNCArIGE4KmI3O1xyXG4gICAgICAgIHRlWzhdID0gYTYqYjIgKyBhNypiNSArIGE4KmI4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LCovXHJcblxyXG4gICAgdHJhbnNwb3NlOiBmdW5jdGlvbiAoIG0gKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoIG0gIT09IHVuZGVmaW5lZCApe1xyXG4gICAgICAgICAgICB2YXIgYSA9IG0uZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCBhWzBdLCBhWzNdLCBhWzZdLCBhWzFdLCBhWzRdLCBhWzddLCBhWzJdLCBhWzVdLCBhWzhdICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgYTAxID0gdGVbMV0sIGEwMiA9IHRlWzJdLCBhMTIgPSB0ZVs1XTtcclxuICAgICAgICB0ZVsxXSA9IHRlWzNdO1xyXG4gICAgICAgIHRlWzJdID0gdGVbNl07XHJcbiAgICAgICAgdGVbM10gPSBhMDE7XHJcbiAgICAgICAgdGVbNV0gPSB0ZVs3XTtcclxuICAgICAgICB0ZVs2XSA9IGEwMjtcclxuICAgICAgICB0ZVs3XSA9IGExMjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG4gICAgLyptdWxTY2FsZTogZnVuY3Rpb24gKCBtLCBzeCwgc3ksIHN6LCBQcmVwZW5kICkge1xyXG5cclxuICAgICAgICB2YXIgcHJlcGVuZCA9IFByZXBlbmQgfHwgZmFsc2U7XHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cywgdG0gPSBtLmVsZW1lbnRzO1xyXG4gICAgICAgIGlmKHByZXBlbmQpe1xyXG4gICAgICAgICAgICB0ZVswXSA9IHN4KnRtWzBdOyB0ZVsxXSA9IHN4KnRtWzFdOyB0ZVsyXSA9IHN4KnRtWzJdO1xyXG4gICAgICAgICAgICB0ZVszXSA9IHN5KnRtWzNdOyB0ZVs0XSA9IHN5KnRtWzRdOyB0ZVs1XSA9IHN5KnRtWzVdO1xyXG4gICAgICAgICAgICB0ZVs2XSA9IHN6KnRtWzZdOyB0ZVs3XSA9IHN6KnRtWzddOyB0ZVs4XSA9IHN6KnRtWzhdO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0ZVswXSA9IHRtWzBdKnN4OyB0ZVsxXSA9IHRtWzFdKnN5OyB0ZVsyXSA9IHRtWzJdKnN6O1xyXG4gICAgICAgICAgICB0ZVszXSA9IHRtWzNdKnN4OyB0ZVs0XSA9IHRtWzRdKnN5OyB0ZVs1XSA9IHRtWzVdKnN6O1xyXG4gICAgICAgICAgICB0ZVs2XSA9IHRtWzZdKnN4OyB0ZVs3XSA9IHRtWzddKnN5OyB0ZVs4XSA9IHRtWzhdKnN6O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLCB0bSA9IG0uZWxlbWVudHM7XHJcbiAgICAgICAgdGVbMF0gPSB0bVswXTsgdGVbMV0gPSB0bVszXTsgdGVbMl0gPSB0bVs2XTtcclxuICAgICAgICB0ZVszXSA9IHRtWzFdOyB0ZVs0XSA9IHRtWzRdOyB0ZVs1XSA9IHRtWzddO1xyXG4gICAgICAgIHRlWzZdID0gdG1bMl07IHRlWzddID0gdG1bNV07IHRlWzhdID0gdG1bOF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSwqL1xyXG5cclxuICAgIHNldFF1YXQ6IGZ1bmN0aW9uICggcSApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcclxuICAgICAgICB2YXIgeDIgPSB4ICsgeCwgIHkyID0geSArIHksIHoyID0geiArIHo7XHJcbiAgICAgICAgdmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XHJcbiAgICAgICAgdmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XHJcbiAgICAgICAgdmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGVbMF0gPSAxIC0gKCB5eSArIHp6ICk7XHJcbiAgICAgICAgdGVbMV0gPSB4eSAtIHd6O1xyXG4gICAgICAgIHRlWzJdID0geHogKyB3eTtcclxuXHJcbiAgICAgICAgdGVbM10gPSB4eSArIHd6O1xyXG4gICAgICAgIHRlWzRdID0gMSAtICggeHggKyB6eiApO1xyXG4gICAgICAgIHRlWzVdID0geXogLSB3eDtcclxuXHJcbiAgICAgICAgdGVbNl0gPSB4eiAtIHd5O1xyXG4gICAgICAgIHRlWzddID0geXogKyB3eDtcclxuICAgICAgICB0ZVs4XSA9IDEgLSAoIHh4ICsgeXkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpbnZlcnQ6IGZ1bmN0aW9uKCBtICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLCB0bSA9IG0uZWxlbWVudHMsXHJcbiAgICAgICAgYTAwID0gdG1bMF0sIGExMCA9IHRtWzNdLCBhMjAgPSB0bVs2XSxcclxuICAgICAgICBhMDEgPSB0bVsxXSwgYTExID0gdG1bNF0sIGEyMSA9IHRtWzddLFxyXG4gICAgICAgIGEwMiA9IHRtWzJdLCBhMTIgPSB0bVs1XSwgYTIyID0gdG1bOF0sXHJcbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxyXG4gICAgICAgIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjAsXHJcbiAgICAgICAgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwLFxyXG4gICAgICAgIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcclxuXHJcbiAgICAgICAgaWYgKCBkZXQgPT09IDAgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcImNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aXR5KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XHJcbiAgICAgICAgdGVbMF0gPSBiMDEgKiBkZXQ7XHJcbiAgICAgICAgdGVbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XHJcbiAgICAgICAgdGVbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcclxuICAgICAgICB0ZVszXSA9IGIxMSAqIGRldDtcclxuICAgICAgICB0ZVs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xyXG4gICAgICAgIHRlWzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xyXG4gICAgICAgIHRlWzZdID0gYjIxICogZGV0O1xyXG4gICAgICAgIHRlWzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xyXG4gICAgICAgIHRlWzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRPZmZzZXQ6IGZ1bmN0aW9uICggbSwgdiApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlbFggPSB2Lng7XHJcbiAgICAgICAgdmFyIHJlbFkgPSB2Lnk7XHJcbiAgICAgICAgdmFyIHJlbFogPSB2Lno7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdGVbMF0gKz0gbSAqICggcmVsWSAqIHJlbFkgKyByZWxaICogcmVsWiApO1xyXG4gICAgICAgIHRlWzRdICs9IG0gKiAoIHJlbFggKiByZWxYICsgcmVsWiAqIHJlbFogKTtcclxuICAgICAgICB0ZVs4XSArPSBtICogKCByZWxYICogcmVsWCArIHJlbFkgKiByZWxZICk7XHJcbiAgICAgICAgdmFyIHh5ID0gbSAqIHJlbFggKiByZWxZO1xyXG4gICAgICAgIHZhciB5eiA9IG0gKiByZWxZICogcmVsWjtcclxuICAgICAgICB2YXIgenggPSBtICogcmVsWiAqIHJlbFg7XHJcbiAgICAgICAgdGVbMV0gLT0geHk7XHJcbiAgICAgICAgdGVbM10gLT0geHk7XHJcbiAgICAgICAgdGVbMl0gLT0geXo7XHJcbiAgICAgICAgdGVbNl0gLT0geXo7XHJcbiAgICAgICAgdGVbNV0gLT0geng7XHJcbiAgICAgICAgdGVbN10gLT0geng7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWJPZmZzZXQ6IGZ1bmN0aW9uICggbSwgdiApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlbFggPSB2Lng7XHJcbiAgICAgICAgdmFyIHJlbFkgPSB2Lnk7XHJcbiAgICAgICAgdmFyIHJlbFogPSB2Lno7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdGVbMF0gLT0gbSAqICggcmVsWSAqIHJlbFkgKyByZWxaICogcmVsWiApO1xyXG4gICAgICAgIHRlWzRdIC09IG0gKiAoIHJlbFggKiByZWxYICsgcmVsWiAqIHJlbFogKTtcclxuICAgICAgICB0ZVs4XSAtPSBtICogKCByZWxYICogcmVsWCArIHJlbFkgKiByZWxZICk7XHJcbiAgICAgICAgdmFyIHh5ID0gbSAqIHJlbFggKiByZWxZO1xyXG4gICAgICAgIHZhciB5eiA9IG0gKiByZWxZICogcmVsWjtcclxuICAgICAgICB2YXIgenggPSBtICogcmVsWiAqIHJlbFg7XHJcbiAgICAgICAgdGVbMV0gKz0geHk7XHJcbiAgICAgICAgdGVbM10gKz0geHk7XHJcbiAgICAgICAgdGVbMl0gKz0geXo7XHJcbiAgICAgICAgdGVbNl0gKz0geXo7XHJcbiAgICAgICAgdGVbNV0gKz0geng7XHJcbiAgICAgICAgdGVbN10gKz0geng7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBPSyBcclxuXHJcbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xyXG4gICAgICAgIHRlWyAxIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgNyBdICo9IHM7XHJcbiAgICAgICAgdGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnNldCggMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSApO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgTWF0MzMoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgOTsgaSArKyApIHRoaXMuZWxlbWVudHNbIGkgXSA9IG0uZWxlbWVudHNbIGkgXTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXHJcbiAgICAgICAgICAgIGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXHJcbiAgICAgICAgICAgIGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XHJcblxyXG4gICAgICAgIHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgOTsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59ICk7XG5cbi8qKlxyXG4gKiBBbiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94LlxyXG4gKlxyXG4gKiBAYXV0aG9yIHNhaGFyYW5cclxuICogQGF1dGhvciBsby10aFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEFBQkIoIG1pblgsIG1heFgsIG1pblksIG1heFksIG1pblosIG1heFogKXtcclxuXHJcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xyXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICB0ZVswXSA9IG1pblggfHwgMDsgdGVbMV0gPSBtaW5ZIHx8IDA7IHRlWzJdID0gbWluWiB8fCAwO1xyXG4gICAgdGVbM10gPSBtYXhYIHx8IDA7IHRlWzRdID0gbWF4WSB8fCAwOyB0ZVs1XSA9IG1heFogfHwgMDtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIEFBQkIucHJvdG90eXBlLCB7XHJcblxyXG5cdEFBQkI6IHRydWUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24obWluWCwgbWF4WCwgbWluWSwgbWF4WSwgbWluWiwgbWF4Wil7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHRlWzBdID0gbWluWDtcclxuXHRcdHRlWzNdID0gbWF4WDtcclxuXHRcdHRlWzFdID0gbWluWTtcclxuXHRcdHRlWzRdID0gbWF4WTtcclxuXHRcdHRlWzJdID0gbWluWjtcclxuXHRcdHRlWzVdID0gbWF4WjtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFRlc3Q6IGZ1bmN0aW9uICggYWFiYiApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHVlID0gYWFiYi5lbGVtZW50cztcclxuXHRcdHJldHVybiB0ZVswXSA+IHVlWzNdIHx8IHRlWzFdID4gdWVbNF0gfHwgdGVbMl0gPiB1ZVs1XSB8fCB0ZVszXSA8IHVlWzBdIHx8IHRlWzRdIDwgdWVbMV0gfHwgdGVbNV0gPCB1ZVsyXSA/IHRydWUgOiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0VGVzdFR3bzogZnVuY3Rpb24gKCBhYWJiICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdWUgPSBhYWJiLmVsZW1lbnRzO1xyXG5cdFx0cmV0dXJuIHRlWzBdIDwgdWVbMF0gfHwgdGVbMV0gPCB1ZVsxXSB8fCB0ZVsyXSA8IHVlWzJdIHx8IHRlWzNdID4gdWVbM10gfHwgdGVbNF0gPiB1ZVs0XSB8fCB0ZVs1XSA+IHVlWzVdID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGFhYmIsIG1hcmdpbiApIHtcclxuXHJcblx0XHR2YXIgbSA9IG1hcmdpbiB8fCAwO1xyXG5cdFx0dmFyIG1lID0gYWFiYi5lbGVtZW50cztcclxuXHRcdHRoaXMuc2V0KCBtZVsgMCBdLW0sIG1lWyAzIF0rbSwgbWVbIDEgXS1tLCBtZVsgNCBdK20sIG1lWyAyIF0tbSwgbWVbIDUgXSttICk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFNldCB0aGlzIEFBQkIgdG8gdGhlIGNvbWJpbmVkIEFBQkIgb2YgYWFiYjEgYW5kIGFhYmIyLlxyXG5cclxuXHRjb21iaW5lOiBmdW5jdGlvbiggYWFiYjEsIGFhYmIyICkge1xyXG5cclxuXHRcdHZhciBhID0gYWFiYjEuZWxlbWVudHM7XHJcblx0XHR2YXIgYiA9IGFhYmIyLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVswXSA9IGFbMF0gPCBiWzBdID8gYVswXSA6IGJbMF07XHJcblx0XHR0ZVsxXSA9IGFbMV0gPCBiWzFdID8gYVsxXSA6IGJbMV07XHJcblx0XHR0ZVsyXSA9IGFbMl0gPCBiWzJdID8gYVsyXSA6IGJbMl07XHJcblxyXG5cdFx0dGVbM10gPSBhWzNdID4gYlszXSA/IGFbM10gOiBiWzNdO1xyXG5cdFx0dGVbNF0gPSBhWzRdID4gYls0XSA/IGFbNF0gOiBiWzRdO1xyXG5cdFx0dGVbNV0gPSBhWzVdID4gYls1XSA/IGFbNV0gOiBiWzVdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gR2V0IHRoZSBzdXJmYWNlIGFyZWEuXHJcblxyXG5cdHN1cmZhY2VBcmVhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBhID0gdGVbM10gLSB0ZVswXTtcclxuXHRcdHZhciBoID0gdGVbNF0gLSB0ZVsxXTtcclxuXHRcdHZhciBkID0gdGVbNV0gLSB0ZVsyXTtcclxuXHRcdHJldHVybiAyICogKGEgKiAoaCArIGQpICsgaCAqIGQgKTtcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEdldCB3aGV0aGVyIHRoZSBBQUJCIGludGVyc2VjdHMgd2l0aCB0aGUgcG9pbnQgb3Igbm90LlxyXG5cclxuXHRpbnRlcnNlY3RzV2l0aFBvaW50OmZ1bmN0aW9uKHgseSx6KXtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0cmV0dXJuIHg+PXRlWzBdICYmIHg8PXRlWzNdICYmIHk+PXRlWzFdICYmIHk8PXRlWzRdICYmIHo+PXRlWzJdICYmIHo8PXRlWzVdO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIEFBQkIgZnJvbSBhbiBhcnJheVxyXG5cdCAqIG9mIHZlcnRpY2VzLiBGcm9tIFRIUkVFLlxyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXlcclxuXHQgKiBAYXV0aG9yIHhwcm9ncmFtXHJcblx0ICovXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uKGFycil7XHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludChhcnJbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG1ha2VFbXB0eTogZnVuY3Rpb24oKXtcclxuXHRcdHRoaXMuc2V0KC1JbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHkpO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uKHB0KXtcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0X01hdGgubWluKHRlWyAwIF0sIHB0LngpLCBfTWF0aC5taW4odGVbIDEgXSwgcHQueSksIF9NYXRoLm1pbih0ZVsgMiBdLCBwdC56KSxcclxuXHRcdFx0X01hdGgubWF4KHRlWyAzIF0sIHB0LngpLCBfTWF0aC5tYXgodGVbIDQgXSwgcHQueSksIF9NYXRoLm1heCh0ZVsgNSBdLCBwdC56KVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24ocyl7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHRlWzBdICs9IC1zO1xyXG5cdFx0dGVbMV0gKz0gLXM7XHJcblx0XHR0ZVsyXSArPSAtcztcclxuXHRcdHRlWzNdICs9IHM7XHJcblx0XHR0ZVs0XSArPSBzO1xyXG5cdFx0dGVbNV0gKz0gcztcclxuXHR9XHJcblxyXG59KTtcblxudmFyIGNvdW50ID0gMDtcclxuZnVuY3Rpb24gU2hhcGVJZENvdW50KCkgeyByZXR1cm4gY291bnQrKzsgfVxyXG5cclxuLyoqXHJcbiAqIEEgc2hhcGUgaXMgdXNlZCB0byBkZXRlY3QgY29sbGlzaW9ucyBvZiByaWdpZCBib2RpZXMuXHJcbiAqXHJcbiAqIEBhdXRob3Igc2FoYXJhblxyXG4gKiBAYXV0aG9yIGxvLXRoXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gU2hhcGUgKCBjb25maWcgKSB7XHJcblxyXG4gICAgdGhpcy50eXBlID0gU0hBUEVfTlVMTDtcclxuXHJcbiAgICAvLyBnbG9iYWwgaWRlbnRpZmljYXRpb24gb2YgdGhlIHNoYXBlIHNob3VsZCBiZSB1bmlxdWUgdG8gdGhlIHNoYXBlLlxyXG4gICAgdGhpcy5pZCA9IFNoYXBlSWRDb3VudCgpO1xyXG5cclxuICAgIC8vIHByZXZpb3VzIHNoYXBlIGluIHBhcmVudCByaWdpZCBib2R5LiBVc2VkIGZvciBmYXN0IGludGVyYXRpb25zLlxyXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcclxuXHJcbiAgICAvLyBuZXh0IHNoYXBlIGluIHBhcmVudCByaWdpZCBib2R5LiBVc2VkIGZvciBmYXN0IGludGVyYXRpb25zLlxyXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuXHJcbiAgICAvLyBwcm94eSBvZiB0aGUgc2hhcGUgdXNlZCBmb3IgYnJvYWQtcGhhc2UgY29sbGlzaW9uIGRldGVjdGlvbi5cclxuICAgIHRoaXMucHJveHkgPSBudWxsO1xyXG5cclxuICAgIC8vIHBhcmVudCByaWdpZCBib2R5IG9mIHRoZSBzaGFwZS5cclxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0aGUgY29udGFjdHMgd2l0aCB0aGUgc2hhcGUuXHJcbiAgICB0aGlzLmNvbnRhY3RMaW5rID0gbnVsbDtcclxuXHJcbiAgICAvLyBudW1iZXIgb2YgdGhlIGNvbnRhY3RzIHdpdGggdGhlIHNoYXBlLlxyXG4gICAgdGhpcy5udW1Db250YWN0cyA9IDA7XHJcblxyXG4gICAgLy8gY2VudGVyIG9mIGdyYXZpdHkgb2YgdGhlIHNoYXBlIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLy8gcm90YXRpb24gbWF0cml4IG9mIHRoZSBzaGFwZSBpbiB3b3JsZCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgIHRoaXMucm90YXRpb24gPSBuZXcgTWF0MzMoKTtcclxuXHJcbiAgICAvLyBwb3NpdGlvbiBvZiB0aGUgc2hhcGUgaW4gcGFyZW50J3MgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICB0aGlzLnJlbGF0aXZlUG9zaXRpb24gPSBuZXcgVmVjMygpLmNvcHkoIGNvbmZpZy5yZWxhdGl2ZVBvc2l0aW9uICk7XHJcblxyXG4gICAgLy8gcm90YXRpb24gbWF0cml4IG9mIHRoZSBzaGFwZSBpbiBwYXJlbnQncyBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgIHRoaXMucmVsYXRpdmVSb3RhdGlvbiA9IG5ldyBNYXQzMygpLmNvcHkoIGNvbmZpZy5yZWxhdGl2ZVJvdGF0aW9uICk7XHJcblxyXG4gICAgLy8gYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiB0aGUgc2hhcGUuXHJcbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xyXG5cclxuICAgIC8vIGRlbnNpdHkgb2YgdGhlIHNoYXBlLlxyXG4gICAgdGhpcy5kZW5zaXR5ID0gY29uZmlnLmRlbnNpdHk7XHJcblxyXG4gICAgLy8gY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb2YgdGhlIHNoYXBlLlxyXG4gICAgdGhpcy5mcmljdGlvbiA9IGNvbmZpZy5mcmljdGlvbjtcclxuXHJcbiAgICAvLyBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGUgc2hhcGUuXHJcbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gY29uZmlnLnJlc3RpdHV0aW9uO1xyXG5cclxuICAgIC8vIGJpdHMgb2YgdGhlIGNvbGxpc2lvbiBncm91cHMgdG8gd2hpY2ggdGhlIHNoYXBlIGJlbG9uZ3MuXHJcbiAgICB0aGlzLmJlbG9uZ3NUbyA9IGNvbmZpZy5iZWxvbmdzVG87XHJcblxyXG4gICAgLy8gYml0cyBvZiB0aGUgY29sbGlzaW9uIGdyb3VwcyB3aXRoIHdoaWNoIHRoZSBzaGFwZSBjb2xsaWRlcy5cclxuICAgIHRoaXMuY29sbGlkZXNXaXRoID0gY29uZmlnLmNvbGxpZGVzV2l0aDtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIFNoYXBlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIFNoYXBlOiB0cnVlLFxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWFzcyBpbmZvcm1hdGlvbiBvZiB0aGUgc2hhcGUuXHJcblxyXG4gICAgY2FsY3VsYXRlTWFzc0luZm86IGZ1bmN0aW9uKCBvdXQgKXtcclxuXHJcbiAgICAgICAgcHJpbnRFcnJvcihcIlNoYXBlXCIsIFwiSW5oZXJpdGFuY2UgZXJyb3IuXCIpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBwcm94eSBvZiB0aGUgc2hhcGUuXHJcblxyXG4gICAgdXBkYXRlUHJveHk6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHByaW50RXJyb3IoXCJTaGFwZVwiLCBcIkluaGVyaXRhbmNlIGVycm9yLlwiKTtcclxuXHJcbiAgICB9XHJcblxyXG59KTtcblxuLyoqXHJcbiAqIEJveCBzaGFwZS5cclxuICogQGF1dGhvciBzYWhhcmFuXHJcbiAqIEBhdXRob3IgbG8tdGhcclxuICovXHJcbiBcclxuZnVuY3Rpb24gQm94ICggY29uZmlnLCBXaWR0aCwgSGVpZ2h0LCBEZXB0aCApIHtcclxuXHJcbiAgICBTaGFwZS5jYWxsKCB0aGlzLCBjb25maWcgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBTSEFQRV9CT1g7XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IFdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBIZWlnaHQ7XHJcbiAgICB0aGlzLmRlcHRoID0gRGVwdGg7XHJcblxyXG4gICAgdGhpcy5oYWxmV2lkdGggPSBXaWR0aCAqIDAuNTtcclxuICAgIHRoaXMuaGFsZkhlaWdodCA9IEhlaWdodCAqIDAuNTtcclxuICAgIHRoaXMuaGFsZkRlcHRoID0gRGVwdGggKiAwLjU7XHJcblxyXG4gICAgdGhpcy5kaW1lbnRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggMTggKTtcclxuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCAyNCApO1xyXG5cclxufVxyXG5cclxuQm94LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFNoYXBlLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBCb3gsXHJcblxyXG5cdGNhbGN1bGF0ZU1hc3NJbmZvOiBmdW5jdGlvbiAoIG91dCApIHtcclxuXHJcblx0XHR2YXIgbWFzcyA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIHRoaXMuZGVwdGggKiB0aGlzLmRlbnNpdHk7XHJcblx0XHR2YXIgZGl2aWQgPSAxLzEyO1xyXG5cdFx0b3V0Lm1hc3MgPSBtYXNzO1xyXG5cdFx0b3V0LmluZXJ0aWEuc2V0KFxyXG5cdFx0XHRtYXNzICogKCB0aGlzLmhlaWdodCAqIHRoaXMuaGVpZ2h0ICsgdGhpcy5kZXB0aCAqIHRoaXMuZGVwdGggKSAqIGRpdmlkLCAwLCAwLFxyXG5cdFx0XHQwLCBtYXNzICogKCB0aGlzLndpZHRoICogdGhpcy53aWR0aCArIHRoaXMuZGVwdGggKiB0aGlzLmRlcHRoICkgKiBkaXZpZCwgMCxcclxuXHRcdFx0MCwgMCwgbWFzcyAqICggdGhpcy53aWR0aCAqIHRoaXMud2lkdGggKyB0aGlzLmhlaWdodCAqIHRoaXMuaGVpZ2h0ICkgKiBkaXZpZFxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLnJvdGF0aW9uLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGRpID0gdGhpcy5kaW1lbnRpb25zO1xyXG5cdFx0Ly8gV2lkdGhcclxuXHRcdGRpWzBdID0gdGVbMF07XHJcblx0XHRkaVsxXSA9IHRlWzNdO1xyXG5cdFx0ZGlbMl0gPSB0ZVs2XTtcclxuXHRcdC8vIEhlaWdodFxyXG5cdFx0ZGlbM10gPSB0ZVsxXTtcclxuXHRcdGRpWzRdID0gdGVbNF07XHJcblx0XHRkaVs1XSA9IHRlWzddO1xyXG5cdFx0Ly8gRGVwdGhcclxuXHRcdGRpWzZdID0gdGVbMl07XHJcblx0XHRkaVs3XSA9IHRlWzVdO1xyXG5cdFx0ZGlbOF0gPSB0ZVs4XTtcclxuXHRcdC8vIGhhbGYgV2lkdGhcclxuXHRcdGRpWzldID0gdGVbMF0gKiB0aGlzLmhhbGZXaWR0aDtcclxuXHRcdGRpWzEwXSA9IHRlWzNdICogdGhpcy5oYWxmV2lkdGg7XHJcblx0XHRkaVsxMV0gPSB0ZVs2XSAqIHRoaXMuaGFsZldpZHRoO1xyXG5cdFx0Ly8gaGFsZiBIZWlnaHRcclxuXHRcdGRpWzEyXSA9IHRlWzFdICogdGhpcy5oYWxmSGVpZ2h0O1xyXG5cdFx0ZGlbMTNdID0gdGVbNF0gKiB0aGlzLmhhbGZIZWlnaHQ7XHJcblx0XHRkaVsxNF0gPSB0ZVs3XSAqIHRoaXMuaGFsZkhlaWdodDtcclxuXHRcdC8vIGhhbGYgRGVwdGhcclxuXHRcdGRpWzE1XSA9IHRlWzJdICogdGhpcy5oYWxmRGVwdGg7XHJcblx0XHRkaVsxNl0gPSB0ZVs1XSAqIHRoaXMuaGFsZkRlcHRoO1xyXG5cdFx0ZGlbMTddID0gdGVbOF0gKiB0aGlzLmhhbGZEZXB0aDtcclxuXHJcblx0XHR2YXIgd3ggPSBkaVs5XTtcclxuXHRcdHZhciB3eSA9IGRpWzEwXTtcclxuXHRcdHZhciB3eiA9IGRpWzExXTtcclxuXHRcdHZhciBoeCA9IGRpWzEyXTtcclxuXHRcdHZhciBoeSA9IGRpWzEzXTtcclxuXHRcdHZhciBoeiA9IGRpWzE0XTtcclxuXHRcdHZhciBkeCA9IGRpWzE1XTtcclxuXHRcdHZhciBkeSA9IGRpWzE2XTtcclxuXHRcdHZhciBkeiA9IGRpWzE3XTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMucG9zaXRpb24ueDtcclxuXHRcdHZhciB5ID0gdGhpcy5wb3NpdGlvbi55O1xyXG5cdFx0dmFyIHogPSB0aGlzLnBvc2l0aW9uLno7XHJcblxyXG5cdFx0dmFyIHYgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0Ly92MVxyXG5cdFx0dlswXSA9IHggKyB3eCArIGh4ICsgZHg7XHJcblx0XHR2WzFdID0geSArIHd5ICsgaHkgKyBkeTtcclxuXHRcdHZbMl0gPSB6ICsgd3ogKyBoeiArIGR6O1xyXG5cdFx0Ly92MlxyXG5cdFx0dlszXSA9IHggKyB3eCArIGh4IC0gZHg7XHJcblx0XHR2WzRdID0geSArIHd5ICsgaHkgLSBkeTtcclxuXHRcdHZbNV0gPSB6ICsgd3ogKyBoeiAtIGR6O1xyXG5cdFx0Ly92M1xyXG5cdFx0dls2XSA9IHggKyB3eCAtIGh4ICsgZHg7XHJcblx0XHR2WzddID0geSArIHd5IC0gaHkgKyBkeTtcclxuXHRcdHZbOF0gPSB6ICsgd3ogLSBoeiArIGR6O1xyXG5cdFx0Ly92NFxyXG5cdFx0dls5XSA9IHggKyB3eCAtIGh4IC0gZHg7XHJcblx0XHR2WzEwXSA9IHkgKyB3eSAtIGh5IC0gZHk7XHJcblx0XHR2WzExXSA9IHogKyB3eiAtIGh6IC0gZHo7XHJcblx0XHQvL3Y1XHJcblx0XHR2WzEyXSA9IHggLSB3eCArIGh4ICsgZHg7XHJcblx0XHR2WzEzXSA9IHkgLSB3eSArIGh5ICsgZHk7XHJcblx0XHR2WzE0XSA9IHogLSB3eiArIGh6ICsgZHo7XHJcblx0XHQvL3Y2XHJcblx0XHR2WzE1XSA9IHggLSB3eCArIGh4IC0gZHg7XHJcblx0XHR2WzE2XSA9IHkgLSB3eSArIGh5IC0gZHk7XHJcblx0XHR2WzE3XSA9IHogLSB3eiArIGh6IC0gZHo7XHJcblx0XHQvL3Y3XHJcblx0XHR2WzE4XSA9IHggLSB3eCAtIGh4ICsgZHg7XHJcblx0XHR2WzE5XSA9IHkgLSB3eSAtIGh5ICsgZHk7XHJcblx0XHR2WzIwXSA9IHogLSB3eiAtIGh6ICsgZHo7XHJcblx0XHQvL3Y4XHJcblx0XHR2WzIxXSA9IHggLSB3eCAtIGh4IC0gZHg7XHJcblx0XHR2WzIyXSA9IHkgLSB3eSAtIGh5IC0gZHk7XHJcblx0XHR2WzIzXSA9IHogLSB3eiAtIGh6IC0gZHo7XHJcblxyXG5cdFx0dmFyIHcgPSBkaVs5XSA8IDAgPyAtZGlbOV0gOiBkaVs5XTtcclxuXHRcdHZhciBoID0gZGlbMTBdIDwgMCA/IC1kaVsxMF0gOiBkaVsxMF07XHJcblx0XHR2YXIgZCA9IGRpWzExXSA8IDAgPyAtZGlbMTFdIDogZGlbMTFdO1xyXG5cclxuXHRcdHcgPSBkaVsxMl0gPCAwID8gdyAtIGRpWzEyXSA6IHcgKyBkaVsxMl07XHJcblx0XHRoID0gZGlbMTNdIDwgMCA/IGggLSBkaVsxM10gOiBoICsgZGlbMTNdO1xyXG5cdFx0ZCA9IGRpWzE0XSA8IDAgPyBkIC0gZGlbMTRdIDogZCArIGRpWzE0XTtcclxuXHJcblx0XHR3ID0gZGlbMTVdIDwgMCA/IHcgLSBkaVsxNV0gOiB3ICsgZGlbMTVdO1xyXG5cdFx0aCA9IGRpWzE2XSA8IDAgPyBoIC0gZGlbMTZdIDogaCArIGRpWzE2XTtcclxuXHRcdGQgPSBkaVsxN10gPCAwID8gZCAtIGRpWzE3XSA6IGQgKyBkaVsxN107XHJcblxyXG5cdFx0dmFyIHAgPSBBQUJCX1BST1g7XHJcblxyXG5cdFx0dGhpcy5hYWJiLnNldChcclxuXHRcdFx0dGhpcy5wb3NpdGlvbi54IC0gdyAtIHAsIHRoaXMucG9zaXRpb24ueCArIHcgKyBwLFxyXG5cdFx0XHR0aGlzLnBvc2l0aW9uLnkgLSBoIC0gcCwgdGhpcy5wb3NpdGlvbi55ICsgaCArIHAsXHJcblx0XHRcdHRoaXMucG9zaXRpb24ueiAtIGQgLSBwLCB0aGlzLnBvc2l0aW9uLnogKyBkICsgcFxyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAoIHRoaXMucHJveHkgIT0gbnVsbCApIHRoaXMucHJveHkudXBkYXRlKCk7XHJcblxyXG5cdH1cclxufSk7XG5cbi8qKlxyXG4gKiBTcGhlcmUgc2hhcGVcclxuICogQGF1dGhvciBzYWhhcmFuXHJcbiAqIEBhdXRob3IgbG8tdGhcclxuICovXHJcblxyXG5mdW5jdGlvbiBTcGhlcmUoIGNvbmZpZywgcmFkaXVzICkge1xyXG5cclxuICAgIFNoYXBlLmNhbGwoIHRoaXMsIGNvbmZpZyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9IFNIQVBFX1NQSEVSRTtcclxuXHJcbiAgICAvLyByYWRpdXMgb2YgdGhlIHNoYXBlLlxyXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblxyXG59XHJcblxyXG5TcGhlcmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggU2hhcGUucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFNwaGVyZSxcclxuXHJcblx0dm9sdW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9NYXRoLlBJICogdGhpcy5yYWRpdXMgKiAxLjMzMzMzMztcclxuXHJcblx0fSxcclxuXHJcblx0Y2FsY3VsYXRlTWFzc0luZm86IGZ1bmN0aW9uICggb3V0ICkge1xyXG5cclxuXHRcdHZhciBtYXNzID0gdGhpcy52b2x1bWUoKSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKiB0aGlzLmRlbnNpdHk7IC8vMS4zMzMgKiBfTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyAqIHRoaXMuZGVuc2l0eTtcclxuXHRcdG91dC5tYXNzID0gbWFzcztcclxuXHRcdHZhciBpbmVydGlhID0gbWFzcyAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKiAwLjQ7XHJcblx0XHRvdXQuaW5lcnRpYS5zZXQoIGluZXJ0aWEsIDAsIDAsIDAsIGluZXJ0aWEsIDAsIDAsIDAsIGluZXJ0aWEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcCA9IEFBQkJfUFJPWDtcclxuXHJcblx0XHR0aGlzLmFhYmIuc2V0KFxyXG5cdFx0XHR0aGlzLnBvc2l0aW9uLnggLSB0aGlzLnJhZGl1cyAtIHAsIHRoaXMucG9zaXRpb24ueCArIHRoaXMucmFkaXVzICsgcCxcclxuXHRcdFx0dGhpcy5wb3NpdGlvbi55IC0gdGhpcy5yYWRpdXMgLSBwLCB0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLnJhZGl1cyArIHAsXHJcblx0XHRcdHRoaXMucG9zaXRpb24ueiAtIHRoaXMucmFkaXVzIC0gcCwgdGhpcy5wb3NpdGlvbi56ICsgdGhpcy5yYWRpdXMgKyBwXHJcblx0XHQpO1xyXG5cclxuXHRcdGlmICggdGhpcy5wcm94eSAhPSBudWxsICkgdGhpcy5wcm94eS51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxufSk7XG5cbi8qKlxyXG4gKiBDeWxpbmRlciBzaGFwZVxyXG4gKiBAYXV0aG9yIHNhaGFyYW5cclxuICogQGF1dGhvciBsby10aFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEN5bGluZGVyICggY29uZmlnLCByYWRpdXMsIGhlaWdodCApIHtcclxuXHJcbiAgICBTaGFwZS5jYWxsKCB0aGlzLCBjb25maWcgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBTSEFQRV9DWUxJTkRFUjtcclxuXHJcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5oYWxmSGVpZ2h0ID0gaGVpZ2h0ICogMC41O1xyXG5cclxuICAgIHRoaXMubm9ybWFsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMuaGFsZkRpcmVjdGlvbiA9IG5ldyBWZWMzKCk7XHJcblxyXG59XHJcblxyXG5DeWxpbmRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBTaGFwZS5wcm90b3R5cGUgKSwge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBDeWxpbmRlcixcclxuXHJcbiAgICBjYWxjdWxhdGVNYXNzSW5mbzogZnVuY3Rpb24gKCBvdXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByc3EgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHZhciBtYXNzID0gX01hdGguUEkgKiByc3EgKiB0aGlzLmhlaWdodCAqIHRoaXMuZGVuc2l0eTtcclxuICAgICAgICB2YXIgaW5lcnRpYVhaID0gKCAoIDAuMjUgKiByc3EgKSArICggMC4wODMzICogdGhpcy5oZWlnaHQgKiB0aGlzLmhlaWdodCApICkgKiBtYXNzO1xyXG4gICAgICAgIHZhciBpbmVydGlhWSA9IDAuNSAqIHJzcTtcclxuICAgICAgICBvdXQubWFzcyA9IG1hc3M7XHJcbiAgICAgICAgb3V0LmluZXJ0aWEuc2V0KCBpbmVydGlhWFosIDAsIDAsICAwLCBpbmVydGlhWSwgMCwgIDAsIDAsIGluZXJ0aWFYWiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5yb3RhdGlvbi5lbGVtZW50cztcclxuICAgICAgICB2YXIgbGVuLCB3eCwgaHksIGR6LCB4eCwgeXksIHp6LCB3LCBoLCBkLCBwO1xyXG5cclxuICAgICAgICB4eCA9IHRlWzFdICogdGVbMV07XHJcbiAgICAgICAgeXkgPSB0ZVs0XSAqIHRlWzRdO1xyXG4gICAgICAgIHp6ID0gdGVbN10gKiB0ZVs3XTtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWxEaXJlY3Rpb24uc2V0KCB0ZVsxXSwgdGVbNF0sIHRlWzddICk7XHJcbiAgICAgICAgdGhpcy5oYWxmRGlyZWN0aW9uLnNjYWxlKCB0aGlzLm5vcm1hbERpcmVjdGlvbiwgdGhpcy5oYWxmSGVpZ2h0ICk7XHJcblxyXG4gICAgICAgIHd4ID0gMSAtIHh4O1xyXG4gICAgICAgIGxlbiA9IF9NYXRoLnNxcnQod3gqd3ggKyB4eCp5eSArIHh4Knp6KTtcclxuICAgICAgICBpZihsZW4+MCkgbGVuID0gdGhpcy5yYWRpdXMvbGVuO1xyXG4gICAgICAgIHd4ICo9IGxlbjtcclxuICAgICAgICBoeSA9IDEgLSB5eTtcclxuICAgICAgICBsZW4gPSBfTWF0aC5zcXJ0KHl5Knh4ICsgaHkqaHkgKyB5eSp6eik7XHJcbiAgICAgICAgaWYobGVuPjApIGxlbiA9IHRoaXMucmFkaXVzL2xlbjtcclxuICAgICAgICBoeSAqPSBsZW47XHJcbiAgICAgICAgZHogPSAxIC0geno7XHJcbiAgICAgICAgbGVuID0gX01hdGguc3FydCh6eip4eCArIHp6Knl5ICsgZHoqZHopO1xyXG4gICAgICAgIGlmKGxlbj4wKSBsZW4gPSB0aGlzLnJhZGl1cy9sZW47XHJcbiAgICAgICAgZHogKj0gbGVuO1xyXG5cclxuICAgICAgICB3ID0gdGhpcy5oYWxmRGlyZWN0aW9uLnggPCAwID8gLXRoaXMuaGFsZkRpcmVjdGlvbi54IDogdGhpcy5oYWxmRGlyZWN0aW9uLng7XHJcbiAgICAgICAgaCA9IHRoaXMuaGFsZkRpcmVjdGlvbi55IDwgMCA/IC10aGlzLmhhbGZEaXJlY3Rpb24ueSA6IHRoaXMuaGFsZkRpcmVjdGlvbi55O1xyXG4gICAgICAgIGQgPSB0aGlzLmhhbGZEaXJlY3Rpb24ueiA8IDAgPyAtdGhpcy5oYWxmRGlyZWN0aW9uLnogOiB0aGlzLmhhbGZEaXJlY3Rpb24uejtcclxuXHJcbiAgICAgICAgdyA9IHd4IDwgMCA/IHcgLSB3eCA6IHcgKyB3eDtcclxuICAgICAgICBoID0gaHkgPCAwID8gaCAtIGh5IDogaCArIGh5O1xyXG4gICAgICAgIGQgPSBkeiA8IDAgPyBkIC0gZHogOiBkICsgZHo7XHJcblxyXG4gICAgICAgIHAgPSBBQUJCX1BST1g7XHJcblxyXG4gICAgICAgIHRoaXMuYWFiYi5zZXQoXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCAtIHcgLSBwLCB0aGlzLnBvc2l0aW9uLnggKyB3ICsgcCxcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55IC0gaCAtIHAsIHRoaXMucG9zaXRpb24ueSArIGggKyBwLFxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnogLSBkIC0gcCwgdGhpcy5wb3NpdGlvbi56ICsgZCArIHBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMucHJveHkgIT0gbnVsbCApIHRoaXMucHJveHkudXBkYXRlKCk7XHJcblxyXG4gICAgfVxyXG5cclxufSk7XG5cbi8qKlxyXG4gKiBQbGFuZSBzaGFwZS5cclxuICogQGF1dGhvciBsby10aFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFBsYW5lKCBjb25maWcsIG5vcm1hbCApIHtcclxuXHJcbiAgICBTaGFwZS5jYWxsKCB0aGlzLCBjb25maWcgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBTSEFQRV9QTEFORTtcclxuXHJcbiAgICAvLyByYWRpdXMgb2YgdGhlIHNoYXBlLlxyXG4gICAgdGhpcy5ub3JtYWwgPSBuZXcgVmVjMyggMCwgMSwgMCApO1xyXG5cclxufVxyXG5cclxuUGxhbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggU2hhcGUucHJvdG90eXBlICksIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogUGxhbmUsXHJcblxyXG4gICAgdm9sdW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2FsY3VsYXRlTWFzc0luZm86IGZ1bmN0aW9uICggb3V0ICkge1xyXG5cclxuICAgICAgICBvdXQubWFzcyA9IHRoaXMuZGVuc2l0eTsvLzAuMDAwMTtcclxuICAgICAgICB2YXIgaW5lcnRpYSA9IDE7XHJcbiAgICAgICAgb3V0LmluZXJ0aWEuc2V0KCBpbmVydGlhLCAwLCAwLCAwLCBpbmVydGlhLCAwLCAwLCAwLCBpbmVydGlhICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVQcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcCA9IEFBQkJfUFJPWDtcclxuXHJcbiAgICAgICAgdmFyIG1pbiA9IC1fTWF0aC5JTkY7XHJcbiAgICAgICAgdmFyIG1heCA9IF9NYXRoLklORjtcclxuICAgICAgICB2YXIgbiA9IHRoaXMubm9ybWFsO1xyXG4gICAgICAgIC8vIFRoZSBwbGFuZSBBQUJCIGlzIGluZmluaXRlLCBleGNlcHQgaWYgdGhlIG5vcm1hbCBpcyBwb2ludGluZyBhbG9uZyBhbnkgYXhpc1xyXG4gICAgICAgIHRoaXMuYWFiYi5zZXQoXHJcbiAgICAgICAgICAgIG4ueCA9PT0gLTEgPyB0aGlzLnBvc2l0aW9uLnggLSBwIDogbWluLCBuLnggPT09IDEgPyB0aGlzLnBvc2l0aW9uLnggKyBwIDogbWF4LFxyXG4gICAgICAgICAgICBuLnkgPT09IC0xID8gdGhpcy5wb3NpdGlvbi55IC0gcCA6IG1pbiwgbi55ID09PSAxID8gdGhpcy5wb3NpdGlvbi55ICsgcCA6IG1heCxcclxuICAgICAgICAgICAgbi56ID09PSAtMSA/IHRoaXMucG9zaXRpb24ueiAtIHAgOiBtaW4sIG4ueiA9PT0gMSA/IHRoaXMucG9zaXRpb24ueiArIHAgOiBtYXhcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMucHJveHkgIT0gbnVsbCApIHRoaXMucHJveHkudXBkYXRlKCk7XHJcblxyXG4gICAgfVxyXG5cclxufSk7XG5cbi8qKlxyXG4gKiBBIFBhcnRpY3VsZSBzaGFwZVxyXG4gKiBAYXV0aG9yIGxvLXRoXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gUGFydGljbGUoIGNvbmZpZywgbm9ybWFsICkge1xyXG5cclxuICAgIFNoYXBlLmNhbGwoIHRoaXMsIGNvbmZpZyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9IFNIQVBFX1BBUlRJQ0xFO1xyXG5cclxufVxyXG5cclxuUGFydGljbGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggU2hhcGUucHJvdG90eXBlICksIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogUGFydGljbGUsXHJcblxyXG4gICAgdm9sdW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2FsY3VsYXRlTWFzc0luZm86IGZ1bmN0aW9uICggb3V0ICkge1xyXG5cclxuICAgICAgICB2YXIgaW5lcnRpYSA9IDA7XHJcbiAgICAgICAgb3V0LmluZXJ0aWEuc2V0KCBpbmVydGlhLCAwLCAwLCAwLCBpbmVydGlhLCAwLCAwLCAwLCBpbmVydGlhICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVQcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcCA9IDA7Ly9BQUJCX1BST1g7XHJcblxyXG4gICAgICAgIHRoaXMuYWFiYi5zZXQoXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCAtIHAsIHRoaXMucG9zaXRpb24ueCArIHAsXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSAtIHAsIHRoaXMucG9zaXRpb24ueSArIHAsXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueiAtIHAsIHRoaXMucG9zaXRpb24ueiArIHBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMucHJveHkgIT0gbnVsbCApIHRoaXMucHJveHkudXBkYXRlKCk7XHJcblxyXG4gICAgfVxyXG5cclxufSk7XG5cbi8qKlxyXG4gKiBBIHNoYXBlIGNvbmZpZ3VyYXRpb24gaG9sZHMgY29tbW9uIGNvbmZpZ3VyYXRpb24gZGF0YSBmb3IgY29uc3RydWN0aW5nIGEgc2hhcGUuXHJcbiAqIFRoZXNlIGNvbmZpZ3VyYXRpb25zIGNhbiBiZSByZXVzZWQgc2FmZWx5LlxyXG4gKlxyXG4gKiBAYXV0aG9yIHNhaGFyYW5cclxuICogQGF1dGhvciBsby10aFxyXG4gKi9cclxuIFxyXG5mdW5jdGlvbiBTaGFwZUNvbmZpZygpe1xyXG5cclxuICAgIC8vIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSBpbiBwYXJlbnQncyBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgIHRoaXMucmVsYXRpdmVQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XHJcbiAgICAvLyByb3RhdGlvbiBtYXRyaXggb2YgdGhlIHNoYXBlIGluIHBhcmVudCdzIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgdGhpcy5yZWxhdGl2ZVJvdGF0aW9uID0gbmV3IE1hdDMzKCk7XHJcbiAgICAvLyBjb2VmZmljaWVudCBvZiBmcmljdGlvbiBvZiB0aGUgc2hhcGUuXHJcbiAgICB0aGlzLmZyaWN0aW9uID0gMC4yOyAvLyAwLjRcclxuICAgIC8vIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIHRoZSBzaGFwZS5cclxuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjI7XHJcbiAgICAvLyBkZW5zaXR5IG9mIHRoZSBzaGFwZS5cclxuICAgIHRoaXMuZGVuc2l0eSA9IDE7XHJcbiAgICAvLyBiaXRzIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBzIHRvIHdoaWNoIHRoZSBzaGFwZSBiZWxvbmdzLlxyXG4gICAgdGhpcy5iZWxvbmdzVG8gPSAxO1xyXG4gICAgLy8gYml0cyBvZiB0aGUgY29sbGlzaW9uIGdyb3VwcyB3aXRoIHdoaWNoIHRoZSBzaGFwZSBjb2xsaWRlcy5cclxuICAgIHRoaXMuY29sbGlkZXNXaXRoID0gMHhmZmZmZmZmZjtcclxuXHJcbn1cblxuLyoqXG4qIEFuIGluZm9ybWF0aW9uIG9mIGxpbWl0IGFuZCBtb3Rvci5cbipcbiogQGF1dGhvciBzYWhhcmFuXG4qL1xuXG5mdW5jdGlvbiBMaW1pdE1vdG9yICggYXhpcywgZml4ZWQgKSB7XG5cbiAgICBmaXhlZCA9IGZpeGVkIHx8IGZhbHNlO1xuICAgIC8vIFRoZSBheGlzIG9mIHRoZSBjb25zdHJhaW50LlxuICAgIHRoaXMuYXhpcyA9IGF4aXM7XG4gICAgLy8gVGhlIGN1cnJlbnQgYW5nbGUgZm9yIHJvdGF0aW9uYWwgY29uc3RyYWludHMuXG4gICAgdGhpcy5hbmdsZSA9IDA7XG4gICAgLy8gVGhlIGxvd2VyIGxpbWl0LiBTZXQgbG93ZXIgPiB1cHBlciB0byBkaXNhYmxlXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gZml4ZWQgPyAwIDogMTtcblxuICAgIC8vICBUaGUgdXBwZXIgbGltaXQuIFNldCBsb3dlciA+IHVwcGVyIHRvIGRpc2FibGUuXG4gICAgdGhpcy51cHBlckxpbWl0ID0gMDtcbiAgICAvLyBUaGUgdGFyZ2V0IG1vdG9yIHNwZWVkLlxuICAgIHRoaXMubW90b3JTcGVlZCA9IDA7XG4gICAgLy8gVGhlIG1heGltdW0gbW90b3IgZm9yY2Ugb3IgdG9ycXVlLiBTZXQgMCB0byBkaXNhYmxlLlxuICAgIHRoaXMubWF4TW90b3JGb3JjZSA9IDA7XG4gICAgLy8gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nLiBTZXQgMCB0byBkaXNhYmxlLlxuICAgIHRoaXMuZnJlcXVlbmN5ID0gMDtcbiAgICAvLyBUaGUgZGFtcGluZyByYXRpbyBvZiB0aGUgc3ByaW5nLiBTZXQgMCBmb3Igbm8gZGFtcGluZywgMSBmb3IgY3JpdGljYWwgZGFtcGluZy5cbiAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IDA7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggTGltaXRNb3Rvci5wcm90b3R5cGUsIHtcblxuICAgIExpbWl0TW90b3I6IHRydWUsXG5cbiAgICAvLyBTZXQgbGltaXQgZGF0YSBpbnRvIHRoaXMgY29uc3RyYWludC5cbiAgICBzZXRMaW1pdDpmdW5jdGlvbiAoIGxvd2VyTGltaXQsIHVwcGVyTGltaXQgKSB7XG5cbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXJMaW1pdDtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXJMaW1pdDtcblxuICAgIH0sXG5cbiAgICAvLyBTZXQgbW90b3IgZGF0YSBpbnRvIHRoaXMgY29uc3RyYWludC5cbiAgICBzZXRNb3RvcjpmdW5jdGlvbiAoIG1vdG9yU3BlZWQsIG1heE1vdG9yRm9yY2UgKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm1vdG9yU3BlZWQgPSBtb3RvclNwZWVkO1xuICAgICAgICB0aGlzLm1heE1vdG9yRm9yY2UgPSBtYXhNb3RvckZvcmNlO1xuXG4gICAgfSxcblxuICAgIC8vIFNldCBzcHJpbmcgZGF0YSBpbnRvIHRoaXMgY29uc3RyYWludC5cbiAgICBzZXRTcHJpbmc6ZnVuY3Rpb24gKCBmcmVxdWVuY3ksIGRhbXBpbmdSYXRpbyApIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gZnJlcXVlbmN5O1xuICAgICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IGRhbXBpbmdSYXRpbztcbiAgICAgICAgXG4gICAgfVxuXG59KTtcblxuLyoqXHJcbiAqIFRoZSBiYXNlIGNsYXNzIG9mIGFsbCB0eXBlIG9mIHRoZSBjb25zdHJhaW50cy5cclxuICpcclxuICogQGF1dGhvciBzYWhhcmFuXHJcbiAqIEBhdXRob3IgbG8tdGhcclxuICovXHJcblxyXG5mdW5jdGlvbiBDb25zdHJhaW50KCl7XHJcblxyXG4gICAgLy8gcGFyZW50IHdvcmxkIG9mIHRoZSBjb25zdHJhaW50LlxyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8vIGZpcnN0IGJvZHkgb2YgdGhlIGNvbnN0cmFpbnQuXHJcbiAgICB0aGlzLmJvZHkxID0gbnVsbDtcclxuXHJcbiAgICAvLyBzZWNvbmQgYm9keSBvZiB0aGUgY29uc3RyYWludC5cclxuICAgIHRoaXMuYm9keTIgPSBudWxsO1xyXG5cclxuICAgIC8vIEludGVybmFsXHJcbiAgICB0aGlzLmFkZGVkVG9Jc2xhbmQgPSBmYWxzZTtcclxuICAgIFxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBDb25zdHJhaW50LnByb3RvdHlwZSwge1xyXG5cclxuICAgIENvbnN0cmFpbnQ6IHRydWUsXHJcblxyXG4gICAgLy8gUHJlcGFyZSBmb3Igc29sdmluZyB0aGUgY29uc3RyYWludFxyXG4gICAgcHJlU29sdmU6IGZ1bmN0aW9uKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKXtcclxuXHJcbiAgICAgICAgcHJpbnRFcnJvcihcIkNvbnN0cmFpbnRcIiwgXCJJbmhlcml0YW5jZSBlcnJvci5cIik7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTb2x2ZSB0aGUgY29uc3RyYWludC4gVGhpcyBpcyB1c3VhbGx5IGNhbGxlZCBpdGVyYXRpdmVseS5cclxuICAgIHNvbHZlOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICBwcmludEVycm9yKFwiQ29uc3RyYWludFwiLCBcIkluaGVyaXRhbmNlIGVycm9yLlwiKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERvIHRoZSBwb3N0LXByb2Nlc3NpbmcuXHJcbiAgICBwb3N0U29sdmU6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHByaW50RXJyb3IoXCJDb25zdHJhaW50XCIsIFwiSW5oZXJpdGFuY2UgZXJyb3IuXCIpO1xyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG5mdW5jdGlvbiBKb2ludExpbmsgKCBqb2ludCApe1xyXG4gICAgXHJcbiAgICAvLyBUaGUgcHJldmlvdXMgam9pbnQgbGluay5cclxuICAgIHRoaXMucHJldiA9IG51bGw7XHJcbiAgICAvLyBUaGUgbmV4dCBqb2ludCBsaW5rLlxyXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgIC8vIFRoZSBvdGhlciByaWdpZCBib2R5IGNvbm5lY3RlZCB0byB0aGUgam9pbnQuXHJcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG4gICAgLy8gVGhlIGpvaW50IG9mIHRoZSBsaW5rLlxyXG4gICAgdGhpcy5qb2ludCA9IGpvaW50O1xyXG5cclxufVxuXG4vKipcbiAqIEpvaW50cyBhcmUgdXNlZCB0byBjb25zdHJhaW4gdGhlIG1vdGlvbiBiZXR3ZWVuIHR3byByaWdpZCBib2RpZXMuXG4gKlxuICogQGF1dGhvciBzYWhhcmFuXG4gKiBAYXV0aG9yIGxvLXRoXG4gKi9cblxuZnVuY3Rpb24gSm9pbnQgKCBjb25maWcgKXtcblxuICAgIENvbnN0cmFpbnQuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5zY2FsZSA9IDE7XG4gICAgdGhpcy5pbnZTY2FsZSA9IDE7XG5cbiAgICAvLyBqb2ludCBuYW1lXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICB0aGlzLmlkID0gTmFOO1xuXG4gICAgLy8gVGhlIHR5cGUgb2YgdGhlIGpvaW50LlxuICAgIHRoaXMudHlwZSA9IEpPSU5UX05VTEw7XG4gICAgLy8gIFRoZSBwcmV2aW91cyBqb2ludCBpbiB0aGUgd29ybGQuXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAvLyBUaGUgbmV4dCBqb2ludCBpbiB0aGUgd29ybGQuXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuYm9keTEgPSBjb25maWcuYm9keTE7XG4gICAgdGhpcy5ib2R5MiA9IGNvbmZpZy5ib2R5MjtcblxuICAgIC8vIGFuY2hvciBwb2ludCBvbiB0aGUgZmlyc3QgcmlnaWQgYm9keSBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICB0aGlzLmxvY2FsQW5jaG9yUG9pbnQxID0gbmV3IFZlYzMoKS5jb3B5KCBjb25maWcubG9jYWxBbmNob3JQb2ludDEgKTtcbiAgICAvLyBhbmNob3IgcG9pbnQgb24gdGhlIHNlY29uZCByaWdpZCBib2R5IGluIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIHRoaXMubG9jYWxBbmNob3JQb2ludDIgPSBuZXcgVmVjMygpLmNvcHkoIGNvbmZpZy5sb2NhbEFuY2hvclBvaW50MiApO1xuICAgIC8vIGFuY2hvciBwb2ludCBvbiB0aGUgZmlyc3QgcmlnaWQgYm9keSBpbiB3b3JsZCBjb29yZGluYXRlIHN5c3RlbSByZWxhdGl2ZSB0byB0aGUgYm9keSdzIG9yaWdpbi5cbiAgICB0aGlzLnJlbGF0aXZlQW5jaG9yUG9pbnQxID0gbmV3IFZlYzMoKTtcbiAgICAvLyBhbmNob3IgcG9pbnQgb24gdGhlIHNlY29uZCByaWdpZCBib2R5IGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtIHJlbGF0aXZlIHRvIHRoZSBib2R5J3Mgb3JpZ2luLlxuICAgIHRoaXMucmVsYXRpdmVBbmNob3JQb2ludDIgPSBuZXcgVmVjMygpO1xuICAgIC8vICBhbmNob3IgcG9pbnQgb24gdGhlIGZpcnN0IHJpZ2lkIGJvZHkgaW4gd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgdGhpcy5hbmNob3JQb2ludDEgPSBuZXcgVmVjMygpO1xuICAgIC8vIGFuY2hvciBwb2ludCBvbiB0aGUgc2Vjb25kIHJpZ2lkIGJvZHkgaW4gd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgdGhpcy5hbmNob3JQb2ludDIgPSBuZXcgVmVjMygpO1xuICAgIC8vIFdoZXRoZXIgYWxsb3cgY29sbGlzaW9uIGJldHdlZW4gY29ubmVjdGVkIHJpZ2lkIGJvZGllcyBvciBub3QuXG4gICAgdGhpcy5hbGxvd0NvbGxpc2lvbiA9IGNvbmZpZy5hbGxvd0NvbGxpc2lvbjtcblxuICAgIHRoaXMuYjFMaW5rID0gbmV3IEpvaW50TGluayggdGhpcyApO1xuICAgIHRoaXMuYjJMaW5rID0gbmV3IEpvaW50TGluayggdGhpcyApO1xuXG59XG5cbkpvaW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENvbnN0cmFpbnQucHJvdG90eXBlICksIHtcblxuICAgIGNvbnN0cnVjdG9yOiBKb2ludCxcblxuICAgIHNldElkOiBmdW5jdGlvbiAoIG4gKSB7IFxuXG4gICAgICAgIHRoaXMuaWQgPSBpOyBcblxuICAgIH0sXG5cbiAgICBzZXRQYXJlbnQ6IGZ1bmN0aW9uICggd29ybGQgKSB7XG5cbiAgICAgICAgdGhpcy5wYXJlbnQgPSB3b3JsZDtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMucGFyZW50LnNjYWxlO1xuICAgICAgICB0aGlzLmludlNjYWxlID0gdGhpcy5wYXJlbnQuaW52U2NhbGU7XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLnBhcmVudC5udW1Kb2ludHM7XG4gICAgICAgIGlmKCAhdGhpcy5uYW1lICkgdGhpcy5uYW1lID0gJ0onICsgIHRoaXMuaWQ7XG5cbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGFsbCB0aGUgYW5jaG9yIHBvaW50cy5cblxuICAgIHVwZGF0ZUFuY2hvclBvaW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMucmVsYXRpdmVBbmNob3JQb2ludDEuY29weSggdGhpcy5sb2NhbEFuY2hvclBvaW50MSApLmFwcGx5TWF0cml4MyggdGhpcy5ib2R5MS5yb3RhdGlvbiwgdHJ1ZSApO1xuICAgICAgICB0aGlzLnJlbGF0aXZlQW5jaG9yUG9pbnQyLmNvcHkoIHRoaXMubG9jYWxBbmNob3JQb2ludDIgKS5hcHBseU1hdHJpeDMoIHRoaXMuYm9keTIucm90YXRpb24sIHRydWUgKTtcblxuICAgICAgICB0aGlzLmFuY2hvclBvaW50MS5hZGQoIHRoaXMucmVsYXRpdmVBbmNob3JQb2ludDEsIHRoaXMuYm9keTEucG9zaXRpb24gKTtcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludDIuYWRkKCB0aGlzLnJlbGF0aXZlQW5jaG9yUG9pbnQyLCB0aGlzLmJvZHkyLnBvc2l0aW9uICk7XG5cbiAgICB9LFxuXG4gICAgLy8gQXR0YWNoIHRoZSBqb2ludCBmcm9tIHRoZSBib2RpZXMuXG5cbiAgICBhdHRhY2g6IGZ1bmN0aW9uICggaXNYICkge1xuXG4gICAgICAgIHRoaXMuYjFMaW5rLmJvZHkgPSB0aGlzLmJvZHkyO1xuICAgICAgICB0aGlzLmIyTGluay5ib2R5ID0gdGhpcy5ib2R5MTtcblxuICAgICAgICBpZihpc1gpe1xuXG4gICAgICAgICAgICB0aGlzLmJvZHkxLmpvaW50TGluay5wdXNoKCB0aGlzLmIxTGluayApO1xuICAgICAgICAgICAgdGhpcy5ib2R5Mi5qb2ludExpbmsucHVzaCggdGhpcy5iMkxpbmsgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZih0aGlzLmJvZHkxLmpvaW50TGluayAhPSBudWxsKSAodGhpcy5iMUxpbmsubmV4dD10aGlzLmJvZHkxLmpvaW50TGluaykucHJldiA9IHRoaXMuYjFMaW5rO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmIxTGluay5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYm9keTEuam9pbnRMaW5rID0gdGhpcy5iMUxpbms7XG4gICAgICAgICAgICB0aGlzLmJvZHkxLm51bUpvaW50cysrO1xuICAgICAgICAgICAgaWYodGhpcy5ib2R5Mi5qb2ludExpbmsgIT0gbnVsbCkgKHRoaXMuYjJMaW5rLm5leHQ9dGhpcy5ib2R5Mi5qb2ludExpbmspLnByZXYgPSB0aGlzLmIyTGluaztcbiAgICAgICAgICAgIGVsc2UgdGhpcy5iMkxpbmsubmV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJvZHkyLmpvaW50TGluayA9IHRoaXMuYjJMaW5rO1xuICAgICAgICAgICAgdGhpcy5ib2R5Mi5udW1Kb2ludHMrKztcblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gRGV0YWNoIHRoZSBqb2ludCBmcm9tIHRoZSBib2RpZXMuXG5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uICggaXNYICkge1xuXG4gICAgICAgIGlmKCBpc1ggKXtcblxuICAgICAgICAgICAgdGhpcy5ib2R5MS5qb2ludExpbmsuc3BsaWNlKCB0aGlzLmJvZHkxLmpvaW50TGluay5pbmRleE9mKCB0aGlzLmIxTGluayApLCAxICk7XG4gICAgICAgICAgICB0aGlzLmJvZHkyLmpvaW50TGluay5zcGxpY2UoIHRoaXMuYm9keTIuam9pbnRMaW5rLmluZGV4T2YoIHRoaXMuYjJMaW5rICksIDEgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuYjFMaW5rLnByZXY7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuYjFMaW5rLm5leHQ7XG4gICAgICAgICAgICBpZihwcmV2ICE9IG51bGwpIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICBpZihuZXh0ICE9IG51bGwpIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgICAgICBpZih0aGlzLmJvZHkxLmpvaW50TGluayA9PSB0aGlzLmIxTGluaykgdGhpcy5ib2R5MS5qb2ludExpbmsgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5iMUxpbmsucHJldiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmIxTGluay5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYjFMaW5rLmJvZHkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ib2R5MS5udW1Kb2ludHMtLTtcblxuICAgICAgICAgICAgcHJldiA9IHRoaXMuYjJMaW5rLnByZXY7XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5iMkxpbmsubmV4dDtcbiAgICAgICAgICAgIGlmKHByZXYgIT0gbnVsbCkgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIGlmKG5leHQgIT0gbnVsbCkgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgICAgIGlmKHRoaXMuYm9keTIuam9pbnRMaW5rPT10aGlzLmIyTGluaykgdGhpcy5ib2R5Mi5qb2ludExpbmsgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5iMkxpbmsucHJldiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmIyTGluay5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYjJMaW5rLmJvZHkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ib2R5Mi5udW1Kb2ludHMtLTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iMUxpbmsuYm9keSA9IG51bGw7XG4gICAgICAgIHRoaXMuYjJMaW5rLmJvZHkgPSBudWxsO1xuXG4gICAgfSxcblxuXG4gICAgLy8gQXdha2UgdGhlIGJvZGllcy5cblxuICAgIGF3YWtlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5ib2R5MS5hd2FrZSgpO1xuICAgICAgICB0aGlzLmJvZHkyLmF3YWtlKCk7XG5cbiAgICB9LFxuXG4gICAgLy8gY2FsY3VsYXRpb24gZnVuY3Rpb25cblxuICAgIHByZVNvbHZlOiBmdW5jdGlvbiAoIHRpbWVTdGVwLCBpbnZUaW1lU3RlcCApIHtcblxuICAgIH0sXG5cbiAgICBzb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgfSxcblxuICAgIHBvc3RTb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgfSxcblxuICAgIC8vIERlbGV0ZSBwcm9jZXNzXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlSm9pbnQoIHRoaXMgKTtcblxuICAgIH0sXG5cblxuICAgIC8vIFRocmVlIGpzIGFkZFxuXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgcDEgPSBuZXcgVmVjMygpLnNjYWxlKCB0aGlzLmFuY2hvclBvaW50MSwgdGhpcy5zY2FsZSApO1xuICAgICAgICB2YXIgcDIgPSBuZXcgVmVjMygpLnNjYWxlKCB0aGlzLmFuY2hvclBvaW50MiwgdGhpcy5zY2FsZSApO1xuICAgICAgICByZXR1cm4gWyBwMSwgcDIgXTtcblxuICAgIH1cblxufSk7XG5cbi8qKlxuKiBBIGxpbmVhciBjb25zdHJhaW50IGZvciBhbGwgYXhlcyBmb3IgdmFyaW91cyBqb2ludHMuXG4qIEBhdXRob3Igc2FoYXJhblxuKi9cbmZ1bmN0aW9uIExpbmVhckNvbnN0cmFpbnQgKCBqb2ludCApe1xuXG4gICAgdGhpcy5tMT1OYU47XG4gICAgdGhpcy5tMj1OYU47XG5cbiAgICB0aGlzLmlpMSA9IG51bGw7XG4gICAgdGhpcy5paTIgPSBudWxsO1xuICAgIHRoaXMuZGQgPSBudWxsO1xuXG4gICAgdGhpcy5yMXg9TmFOO1xuICAgIHRoaXMucjF5PU5hTjtcbiAgICB0aGlzLnIxej1OYU47XG5cbiAgICB0aGlzLnIyeD1OYU47XG4gICAgdGhpcy5yMnk9TmFOO1xuICAgIHRoaXMucjJ6PU5hTjtcblxuICAgIHRoaXMuYXgxeD1OYU47XG4gICAgdGhpcy5heDF5PU5hTjtcbiAgICB0aGlzLmF4MXo9TmFOO1xuICAgIHRoaXMuYXkxeD1OYU47XG4gICAgdGhpcy5heTF5PU5hTjtcbiAgICB0aGlzLmF5MXo9TmFOO1xuICAgIHRoaXMuYXoxeD1OYU47XG4gICAgdGhpcy5hejF5PU5hTjtcbiAgICB0aGlzLmF6MXo9TmFOO1xuXG4gICAgdGhpcy5heDJ4PU5hTjtcbiAgICB0aGlzLmF4Mnk9TmFOO1xuICAgIHRoaXMuYXgyej1OYU47XG4gICAgdGhpcy5heTJ4PU5hTjtcbiAgICB0aGlzLmF5Mnk9TmFOO1xuICAgIHRoaXMuYXkyej1OYU47XG4gICAgdGhpcy5hejJ4PU5hTjtcbiAgICB0aGlzLmF6Mnk9TmFOO1xuICAgIHRoaXMuYXoyej1OYU47XG5cbiAgICB0aGlzLnZlbD1OYU47XG4gICAgdGhpcy52ZWx4PU5hTjtcbiAgICB0aGlzLnZlbHk9TmFOO1xuICAgIHRoaXMudmVsej1OYU47XG5cblxuICAgIHRoaXMuam9pbnQgPSBqb2ludDtcbiAgICB0aGlzLnIxID0gam9pbnQucmVsYXRpdmVBbmNob3JQb2ludDE7XG4gICAgdGhpcy5yMiA9IGpvaW50LnJlbGF0aXZlQW5jaG9yUG9pbnQyO1xuICAgIHRoaXMucDEgPSBqb2ludC5hbmNob3JQb2ludDE7XG4gICAgdGhpcy5wMiA9IGpvaW50LmFuY2hvclBvaW50MjtcbiAgICB0aGlzLmIxID0gam9pbnQuYm9keTE7XG4gICAgdGhpcy5iMiA9IGpvaW50LmJvZHkyO1xuICAgIHRoaXMubDEgPSB0aGlzLmIxLmxpbmVhclZlbG9jaXR5O1xuICAgIHRoaXMubDIgPSB0aGlzLmIyLmxpbmVhclZlbG9jaXR5O1xuICAgIHRoaXMuYTEgPSB0aGlzLmIxLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmEyID0gdGhpcy5iMi5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdGhpcy5pMSA9IHRoaXMuYjEuaW52ZXJzZUluZXJ0aWE7XG4gICAgdGhpcy5pMiA9IHRoaXMuYjIuaW52ZXJzZUluZXJ0aWE7XG4gICAgdGhpcy5pbXB4ID0gMDtcbiAgICB0aGlzLmltcHkgPSAwO1xuICAgIHRoaXMuaW1weiA9IDA7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggTGluZWFyQ29uc3RyYWludC5wcm90b3R5cGUsIHtcblxuICAgIExpbmVhckNvbnN0cmFpbnQ6IHRydWUsXG5cbiAgICBwcmVTb2x2ZTogZnVuY3Rpb24gKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnIxeCA9IHRoaXMucjEueDtcbiAgICAgICAgdGhpcy5yMXkgPSB0aGlzLnIxLnk7XG4gICAgICAgIHRoaXMucjF6ID0gdGhpcy5yMS56O1xuXG4gICAgICAgIHRoaXMucjJ4ID0gdGhpcy5yMi54O1xuICAgICAgICB0aGlzLnIyeSA9IHRoaXMucjIueTtcbiAgICAgICAgdGhpcy5yMnogPSB0aGlzLnIyLno7XG5cbiAgICAgICAgdGhpcy5tMSA9IHRoaXMuYjEuaW52ZXJzZU1hc3M7XG4gICAgICAgIHRoaXMubTIgPSB0aGlzLmIyLmludmVyc2VNYXNzO1xuXG4gICAgICAgIHRoaXMuaWkxID0gdGhpcy5pMS5jbG9uZSgpO1xuICAgICAgICB0aGlzLmlpMiA9IHRoaXMuaTIuY2xvbmUoKTtcblxuICAgICAgICB2YXIgaWkxID0gdGhpcy5paTEuZWxlbWVudHM7XG4gICAgICAgIHZhciBpaTIgPSB0aGlzLmlpMi5lbGVtZW50cztcblxuICAgICAgICB0aGlzLmF4MXggPSB0aGlzLnIxeippaTFbMV0rLXRoaXMucjF5KmlpMVsyXTtcbiAgICAgICAgdGhpcy5heDF5ID0gdGhpcy5yMXoqaWkxWzRdKy10aGlzLnIxeSppaTFbNV07XG4gICAgICAgIHRoaXMuYXgxeiA9IHRoaXMucjF6KmlpMVs3XSstdGhpcy5yMXkqaWkxWzhdO1xuICAgICAgICB0aGlzLmF5MXggPSAtdGhpcy5yMXoqaWkxWzBdK3RoaXMucjF4KmlpMVsyXTtcbiAgICAgICAgdGhpcy5heTF5ID0gLXRoaXMucjF6KmlpMVszXSt0aGlzLnIxeCppaTFbNV07XG4gICAgICAgIHRoaXMuYXkxeiA9IC10aGlzLnIxeippaTFbNl0rdGhpcy5yMXgqaWkxWzhdO1xuICAgICAgICB0aGlzLmF6MXggPSB0aGlzLnIxeSppaTFbMF0rLXRoaXMucjF4KmlpMVsxXTtcbiAgICAgICAgdGhpcy5hejF5ID0gdGhpcy5yMXkqaWkxWzNdKy10aGlzLnIxeCppaTFbNF07XG4gICAgICAgIHRoaXMuYXoxeiA9IHRoaXMucjF5KmlpMVs2XSstdGhpcy5yMXgqaWkxWzddO1xuICAgICAgICB0aGlzLmF4MnggPSB0aGlzLnIyeippaTJbMV0rLXRoaXMucjJ5KmlpMlsyXTtcbiAgICAgICAgdGhpcy5heDJ5ID0gdGhpcy5yMnoqaWkyWzRdKy10aGlzLnIyeSppaTJbNV07XG4gICAgICAgIHRoaXMuYXgyeiA9IHRoaXMucjJ6KmlpMls3XSstdGhpcy5yMnkqaWkyWzhdO1xuICAgICAgICB0aGlzLmF5MnggPSAtdGhpcy5yMnoqaWkyWzBdK3RoaXMucjJ4KmlpMlsyXTtcbiAgICAgICAgdGhpcy5heTJ5ID0gLXRoaXMucjJ6KmlpMlszXSt0aGlzLnIyeCppaTJbNV07XG4gICAgICAgIHRoaXMuYXkyeiA9IC10aGlzLnIyeippaTJbNl0rdGhpcy5yMngqaWkyWzhdO1xuICAgICAgICB0aGlzLmF6MnggPSB0aGlzLnIyeSppaTJbMF0rLXRoaXMucjJ4KmlpMlsxXTtcbiAgICAgICAgdGhpcy5hejJ5ID0gdGhpcy5yMnkqaWkyWzNdKy10aGlzLnIyeCppaTJbNF07XG4gICAgICAgIHRoaXMuYXoyeiA9IHRoaXMucjJ5KmlpMls2XSstdGhpcy5yMngqaWkyWzddO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwb2ludC10by1wb2ludCBtYXNzIG1hdHJpeFxuICAgICAgICAvLyBmcm9tIGltcHVsc2UgZXF1YXRpb25cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIE0gPSAoWy9tXSAtIFtyXl1bL0ldW3JeXSkgXiAtMVxuICAgICAgICAvLyBcbiAgICAgICAgLy8gd2hlcmVcbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFsvbV0gPSB8MS9tLCAwLCAwfFxuICAgICAgICAvLyAgICAgICAgfDAsIDEvbSwgMHxcbiAgICAgICAgLy8gICAgICAgIHwwLCAwLCAxL218XG4gICAgICAgIC8vIFxuICAgICAgICAvLyBbcl5dID0gfDAsIC1yeiwgcnl8XG4gICAgICAgIC8vICAgICAgICB8cnosIDAsIC1yeHxcbiAgICAgICAgLy8gICAgICAgIHwtcnksIHJ4LCAwfFxuICAgICAgICAvLyBcbiAgICAgICAgLy8gWy9JXSA9IEludmVydGVkIG1vbWVudCBpbmVydGlhXG5cbiAgICAgICAgdmFyIHJ4eCA9IHRoaXMubTErdGhpcy5tMjtcblxuICAgICAgICB2YXIga2sgPSBuZXcgTWF0MzMoKS5zZXQoIHJ4eCwgMCwgMCwgIDAsIHJ4eCwgMCwgIDAsIDAsIHJ4eCApO1xuICAgICAgICB2YXIgayA9IGtrLmVsZW1lbnRzO1xuXG4gICAgICAgIGtbMF0gKz0gaWkxWzRdKnRoaXMucjF6KnRoaXMucjF6LShpaTFbN10raWkxWzVdKSp0aGlzLnIxeSp0aGlzLnIxeitpaTFbOF0qdGhpcy5yMXkqdGhpcy5yMXk7XG4gICAgICAgIGtbMV0gKz0gKGlpMVs2XSp0aGlzLnIxeStpaTFbNV0qdGhpcy5yMXgpKnRoaXMucjF6LWlpMVszXSp0aGlzLnIxeip0aGlzLnIxei1paTFbOF0qdGhpcy5yMXgqdGhpcy5yMXk7XG4gICAgICAgIGtbMl0gKz0gKGlpMVszXSp0aGlzLnIxeS1paTFbNF0qdGhpcy5yMXgpKnRoaXMucjF6LWlpMVs2XSp0aGlzLnIxeSp0aGlzLnIxeStpaTFbN10qdGhpcy5yMXgqdGhpcy5yMXk7XG4gICAgICAgIGtbM10gKz0gKGlpMVsyXSp0aGlzLnIxeStpaTFbN10qdGhpcy5yMXgpKnRoaXMucjF6LWlpMVsxXSp0aGlzLnIxeip0aGlzLnIxei1paTFbOF0qdGhpcy5yMXgqdGhpcy5yMXk7XG4gICAgICAgIGtbNF0gKz0gaWkxWzBdKnRoaXMucjF6KnRoaXMucjF6LShpaTFbNl0raWkxWzJdKSp0aGlzLnIxeCp0aGlzLnIxeitpaTFbOF0qdGhpcy5yMXgqdGhpcy5yMXg7XG4gICAgICAgIGtbNV0gKz0gKGlpMVsxXSp0aGlzLnIxeC1paTFbMF0qdGhpcy5yMXkpKnRoaXMucjF6LWlpMVs3XSp0aGlzLnIxeCp0aGlzLnIxeCtpaTFbNl0qdGhpcy5yMXgqdGhpcy5yMXk7XG4gICAgICAgIGtbNl0gKz0gKGlpMVsxXSp0aGlzLnIxeS1paTFbNF0qdGhpcy5yMXgpKnRoaXMucjF6LWlpMVsyXSp0aGlzLnIxeSp0aGlzLnIxeStpaTFbNV0qdGhpcy5yMXgqdGhpcy5yMXk7XG4gICAgICAgIGtbN10gKz0gKGlpMVszXSp0aGlzLnIxeC1paTFbMF0qdGhpcy5yMXkpKnRoaXMucjF6LWlpMVs1XSp0aGlzLnIxeCp0aGlzLnIxeCtpaTFbMl0qdGhpcy5yMXgqdGhpcy5yMXk7XG4gICAgICAgIGtbOF0gKz0gaWkxWzBdKnRoaXMucjF5KnRoaXMucjF5LShpaTFbM10raWkxWzFdKSp0aGlzLnIxeCp0aGlzLnIxeStpaTFbNF0qdGhpcy5yMXgqdGhpcy5yMXg7XG5cbiAgICAgICAga1swXSArPSBpaTJbNF0qdGhpcy5yMnoqdGhpcy5yMnotKGlpMls3XStpaTJbNV0pKnRoaXMucjJ5KnRoaXMucjJ6K2lpMls4XSp0aGlzLnIyeSp0aGlzLnIyeTtcbiAgICAgICAga1sxXSArPSAoaWkyWzZdKnRoaXMucjJ5K2lpMls1XSp0aGlzLnIyeCkqdGhpcy5yMnotaWkyWzNdKnRoaXMucjJ6KnRoaXMucjJ6LWlpMls4XSp0aGlzLnIyeCp0aGlzLnIyeTtcbiAgICAgICAga1syXSArPSAoaWkyWzNdKnRoaXMucjJ5LWlpMls0XSp0aGlzLnIyeCkqdGhpcy5yMnotaWkyWzZdKnRoaXMucjJ5KnRoaXMucjJ5K2lpMls3XSp0aGlzLnIyeCp0aGlzLnIyeTtcbiAgICAgICAga1szXSArPSAoaWkyWzJdKnRoaXMucjJ5K2lpMls3XSp0aGlzLnIyeCkqdGhpcy5yMnotaWkyWzFdKnRoaXMucjJ6KnRoaXMucjJ6LWlpMls4XSp0aGlzLnIyeCp0aGlzLnIyeTtcbiAgICAgICAga1s0XSArPSBpaTJbMF0qdGhpcy5yMnoqdGhpcy5yMnotKGlpMls2XStpaTJbMl0pKnRoaXMucjJ4KnRoaXMucjJ6K2lpMls4XSp0aGlzLnIyeCp0aGlzLnIyeDtcbiAgICAgICAga1s1XSArPSAoaWkyWzFdKnRoaXMucjJ4LWlpMlswXSp0aGlzLnIyeSkqdGhpcy5yMnotaWkyWzddKnRoaXMucjJ4KnRoaXMucjJ4K2lpMls2XSp0aGlzLnIyeCp0aGlzLnIyeTtcbiAgICAgICAga1s2XSArPSAoaWkyWzFdKnRoaXMucjJ5LWlpMls0XSp0aGlzLnIyeCkqdGhpcy5yMnotaWkyWzJdKnRoaXMucjJ5KnRoaXMucjJ5K2lpMls1XSp0aGlzLnIyeCp0aGlzLnIyeTtcbiAgICAgICAga1s3XSArPSAoaWkyWzNdKnRoaXMucjJ4LWlpMlswXSp0aGlzLnIyeSkqdGhpcy5yMnotaWkyWzVdKnRoaXMucjJ4KnRoaXMucjJ4K2lpMlsyXSp0aGlzLnIyeCp0aGlzLnIyeTtcbiAgICAgICAga1s4XSArPSBpaTJbMF0qdGhpcy5yMnkqdGhpcy5yMnktKGlpMlszXStpaTJbMV0pKnRoaXMucjJ4KnRoaXMucjJ5K2lpMls0XSp0aGlzLnIyeCp0aGlzLnIyeDtcblxuICAgICAgICB2YXIgaW52PTEvKCBrWzBdKihrWzRdKmtbOF0ta1s3XSprWzVdKSArIGtbM10qKGtbN10qa1syXS1rWzFdKmtbOF0pICsga1s2XSooa1sxXSprWzVdLWtbNF0qa1syXSkgKTtcbiAgICAgICAgdGhpcy5kZCA9IG5ldyBNYXQzMygpLnNldChcbiAgICAgICAgICAgIGtbNF0qa1s4XS1rWzVdKmtbN10sIGtbMl0qa1s3XS1rWzFdKmtbOF0sIGtbMV0qa1s1XS1rWzJdKmtbNF0sXG4gICAgICAgICAgICBrWzVdKmtbNl0ta1szXSprWzhdLCBrWzBdKmtbOF0ta1syXSprWzZdLCBrWzJdKmtbM10ta1swXSprWzVdLFxuICAgICAgICAgICAga1szXSprWzddLWtbNF0qa1s2XSwga1sxXSprWzZdLWtbMF0qa1s3XSwga1swXSprWzRdLWtbMV0qa1szXVxuICAgICAgICApLnNjYWxlRXF1YWwoIGludiApO1xuXG4gICAgICAgIHRoaXMudmVseCA9IHRoaXMucDIueC10aGlzLnAxLng7XG4gICAgICAgIHRoaXMudmVseSA9IHRoaXMucDIueS10aGlzLnAxLnk7XG4gICAgICAgIHRoaXMudmVseiA9IHRoaXMucDIuei10aGlzLnAxLno7XG4gICAgICAgIHZhciBsZW4gPSBfTWF0aC5zcXJ0KHRoaXMudmVseCp0aGlzLnZlbHgrdGhpcy52ZWx5KnRoaXMudmVseSt0aGlzLnZlbHoqdGhpcy52ZWx6KTtcbiAgICAgICAgaWYobGVuPjAuMDA1KXtcbiAgICAgICAgICAgIGxlbiA9ICgwLjAwNS1sZW4pL2xlbippbnZUaW1lU3RlcCowLjA1O1xuICAgICAgICAgICAgdGhpcy52ZWx4ICo9IGxlbjtcbiAgICAgICAgICAgIHRoaXMudmVseSAqPSBsZW47XG4gICAgICAgICAgICB0aGlzLnZlbHogKj0gbGVuO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMudmVseCA9IDA7XG4gICAgICAgICAgICB0aGlzLnZlbHkgPSAwO1xuICAgICAgICAgICAgdGhpcy52ZWx6ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1weCAqPSAwLjk1O1xuICAgICAgICB0aGlzLmltcHkgKj0gMC45NTtcbiAgICAgICAgdGhpcy5pbXB6ICo9IDAuOTU7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmwxLnggKz0gdGhpcy5pbXB4KnRoaXMubTE7XG4gICAgICAgIHRoaXMubDEueSArPSB0aGlzLmltcHkqdGhpcy5tMTtcbiAgICAgICAgdGhpcy5sMS56ICs9IHRoaXMuaW1weip0aGlzLm0xO1xuICAgICAgICB0aGlzLmExLnggKz0gdGhpcy5pbXB4KnRoaXMuYXgxeCt0aGlzLmltcHkqdGhpcy5heTF4K3RoaXMuaW1weip0aGlzLmF6MXg7XG4gICAgICAgIHRoaXMuYTEueSArPSB0aGlzLmltcHgqdGhpcy5heDF5K3RoaXMuaW1weSp0aGlzLmF5MXkrdGhpcy5pbXB6KnRoaXMuYXoxeTtcbiAgICAgICAgdGhpcy5hMS56ICs9IHRoaXMuaW1weCp0aGlzLmF4MXordGhpcy5pbXB5KnRoaXMuYXkxeit0aGlzLmltcHoqdGhpcy5hejF6O1xuICAgICAgICB0aGlzLmwyLnggLT0gdGhpcy5pbXB4KnRoaXMubTI7XG4gICAgICAgIHRoaXMubDIueSAtPSB0aGlzLmltcHkqdGhpcy5tMjtcbiAgICAgICAgdGhpcy5sMi56IC09IHRoaXMuaW1weip0aGlzLm0yO1xuICAgICAgICB0aGlzLmEyLnggLT0gdGhpcy5pbXB4KnRoaXMuYXgyeCt0aGlzLmltcHkqdGhpcy5heTJ4K3RoaXMuaW1weip0aGlzLmF6Mng7XG4gICAgICAgIHRoaXMuYTIueSAtPSB0aGlzLmltcHgqdGhpcy5heDJ5K3RoaXMuaW1weSp0aGlzLmF5MnkrdGhpcy5pbXB6KnRoaXMuYXoyeTtcbiAgICAgICAgdGhpcy5hMi56IC09IHRoaXMuaW1weCp0aGlzLmF4MnordGhpcy5pbXB5KnRoaXMuYXkyeit0aGlzLmltcHoqdGhpcy5hejJ6O1xuICAgIH0sXG5cbiAgICBzb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBkID0gdGhpcy5kZC5lbGVtZW50cztcbiAgICAgICAgdmFyIHJ2eCA9IHRoaXMubDIueC10aGlzLmwxLngrdGhpcy5hMi55KnRoaXMucjJ6LXRoaXMuYTIueip0aGlzLnIyeS10aGlzLmExLnkqdGhpcy5yMXordGhpcy5hMS56KnRoaXMucjF5LXRoaXMudmVseDtcbiAgICAgICAgdmFyIHJ2eSA9IHRoaXMubDIueS10aGlzLmwxLnkrdGhpcy5hMi56KnRoaXMucjJ4LXRoaXMuYTIueCp0aGlzLnIyei10aGlzLmExLnoqdGhpcy5yMXgrdGhpcy5hMS54KnRoaXMucjF6LXRoaXMudmVseTtcbiAgICAgICAgdmFyIHJ2eiA9IHRoaXMubDIuei10aGlzLmwxLnordGhpcy5hMi54KnRoaXMucjJ5LXRoaXMuYTIueSp0aGlzLnIyeC10aGlzLmExLngqdGhpcy5yMXkrdGhpcy5hMS55KnRoaXMucjF4LXRoaXMudmVsejtcbiAgICAgICAgdmFyIG5pbXB4ID0gcnZ4KmRbMF0rcnZ5KmRbMV0rcnZ6KmRbMl07XG4gICAgICAgIHZhciBuaW1weSA9IHJ2eCpkWzNdK3J2eSpkWzRdK3J2eipkWzVdO1xuICAgICAgICB2YXIgbmltcHogPSBydngqZFs2XStydnkqZFs3XStydnoqZFs4XTtcbiAgICAgICAgdGhpcy5pbXB4ICs9IG5pbXB4O1xuICAgICAgICB0aGlzLmltcHkgKz0gbmltcHk7XG4gICAgICAgIHRoaXMuaW1weiArPSBuaW1wejtcbiAgICAgICAgdGhpcy5sMS54ICs9IG5pbXB4KnRoaXMubTE7XG4gICAgICAgIHRoaXMubDEueSArPSBuaW1weSp0aGlzLm0xO1xuICAgICAgICB0aGlzLmwxLnogKz0gbmltcHoqdGhpcy5tMTtcbiAgICAgICAgdGhpcy5hMS54ICs9IG5pbXB4KnRoaXMuYXgxeCtuaW1weSp0aGlzLmF5MXgrbmltcHoqdGhpcy5hejF4O1xuICAgICAgICB0aGlzLmExLnkgKz0gbmltcHgqdGhpcy5heDF5K25pbXB5KnRoaXMuYXkxeStuaW1weip0aGlzLmF6MXk7XG4gICAgICAgIHRoaXMuYTEueiArPSBuaW1weCp0aGlzLmF4MXorbmltcHkqdGhpcy5heTF6K25pbXB6KnRoaXMuYXoxejtcbiAgICAgICAgdGhpcy5sMi54IC09IG5pbXB4KnRoaXMubTI7XG4gICAgICAgIHRoaXMubDIueSAtPSBuaW1weSp0aGlzLm0yO1xuICAgICAgICB0aGlzLmwyLnogLT0gbmltcHoqdGhpcy5tMjtcbiAgICAgICAgdGhpcy5hMi54IC09IG5pbXB4KnRoaXMuYXgyeCtuaW1weSp0aGlzLmF5MngrbmltcHoqdGhpcy5hejJ4O1xuICAgICAgICB0aGlzLmEyLnkgLT0gbmltcHgqdGhpcy5heDJ5K25pbXB5KnRoaXMuYXkyeStuaW1weip0aGlzLmF6Mnk7XG4gICAgICAgIHRoaXMuYTIueiAtPSBuaW1weCp0aGlzLmF4MnorbmltcHkqdGhpcy5heTJ6K25pbXB6KnRoaXMuYXoyejtcblxuICAgIH1cblxufSApO1xuXG4vKipcbiogQSB0aHJlZS1heGlzIHJvdGF0aW9uYWwgY29uc3RyYWludCBmb3IgdmFyaW91cyBqb2ludHMuXG4qIEBhdXRob3Igc2FoYXJhblxuKi9cblxuZnVuY3Rpb24gUm90YXRpb25hbDNDb25zdHJhaW50ICggam9pbnQsIGxpbWl0TW90b3IxLCBsaW1pdE1vdG9yMiwgbGltaXRNb3RvcjMgKSB7XG4gICAgXG4gICAgdGhpcy5jZm0xPU5hTjtcbiAgICB0aGlzLmNmbTI9TmFOO1xuICAgIHRoaXMuY2ZtMz1OYU47XG4gICAgdGhpcy5pMWUwMD1OYU47XG4gICAgdGhpcy5pMWUwMT1OYU47XG4gICAgdGhpcy5pMWUwMj1OYU47XG4gICAgdGhpcy5pMWUxMD1OYU47XG4gICAgdGhpcy5pMWUxMT1OYU47XG4gICAgdGhpcy5pMWUxMj1OYU47XG4gICAgdGhpcy5pMWUyMD1OYU47XG4gICAgdGhpcy5pMWUyMT1OYU47XG4gICAgdGhpcy5pMWUyMj1OYU47XG4gICAgdGhpcy5pMmUwMD1OYU47XG4gICAgdGhpcy5pMmUwMT1OYU47XG4gICAgdGhpcy5pMmUwMj1OYU47XG4gICAgdGhpcy5pMmUxMD1OYU47XG4gICAgdGhpcy5pMmUxMT1OYU47XG4gICAgdGhpcy5pMmUxMj1OYU47XG4gICAgdGhpcy5pMmUyMD1OYU47XG4gICAgdGhpcy5pMmUyMT1OYU47XG4gICAgdGhpcy5pMmUyMj1OYU47XG4gICAgdGhpcy5heDE9TmFOO1xuICAgIHRoaXMuYXkxPU5hTjtcbiAgICB0aGlzLmF6MT1OYU47XG4gICAgdGhpcy5heDI9TmFOO1xuICAgIHRoaXMuYXkyPU5hTjtcbiAgICB0aGlzLmF6Mj1OYU47XG4gICAgdGhpcy5heDM9TmFOO1xuICAgIHRoaXMuYXkzPU5hTjtcbiAgICB0aGlzLmF6Mz1OYU47XG5cbiAgICB0aGlzLmExeDE9TmFOOyAvLyBqYWNvaWFuc1xuICAgIHRoaXMuYTF5MT1OYU47XG4gICAgdGhpcy5hMXoxPU5hTjtcbiAgICB0aGlzLmEyeDE9TmFOO1xuICAgIHRoaXMuYTJ5MT1OYU47XG4gICAgdGhpcy5hMnoxPU5hTjtcbiAgICB0aGlzLmExeDI9TmFOO1xuICAgIHRoaXMuYTF5Mj1OYU47XG4gICAgdGhpcy5hMXoyPU5hTjtcbiAgICB0aGlzLmEyeDI9TmFOO1xuICAgIHRoaXMuYTJ5Mj1OYU47XG4gICAgdGhpcy5hMnoyPU5hTjtcbiAgICB0aGlzLmExeDM9TmFOO1xuICAgIHRoaXMuYTF5Mz1OYU47XG4gICAgdGhpcy5hMXozPU5hTjtcbiAgICB0aGlzLmEyeDM9TmFOO1xuICAgIHRoaXMuYTJ5Mz1OYU47XG4gICAgdGhpcy5hMnozPU5hTjtcblxuICAgIHRoaXMubG93ZXJMaW1pdDE9TmFOO1xuICAgIHRoaXMudXBwZXJMaW1pdDE9TmFOO1xuICAgIHRoaXMubGltaXRWZWxvY2l0eTE9TmFOO1xuICAgIHRoaXMubGltaXRTdGF0ZTE9MDsgLy8gLTE6IGF0IGxvd2VyLCAwOiBsb2NrZWQsIDE6IGF0IHVwcGVyLCAyOiBmcmVlXG4gICAgdGhpcy5lbmFibGVNb3RvcjE9ZmFsc2U7XG4gICAgdGhpcy5tb3RvclNwZWVkMT1OYU47XG4gICAgdGhpcy5tYXhNb3RvckZvcmNlMT1OYU47XG4gICAgdGhpcy5tYXhNb3RvckltcHVsc2UxPU5hTjtcbiAgICB0aGlzLmxvd2VyTGltaXQyPU5hTjtcbiAgICB0aGlzLnVwcGVyTGltaXQyPU5hTjtcbiAgICB0aGlzLmxpbWl0VmVsb2NpdHkyPU5hTjtcbiAgICB0aGlzLmxpbWl0U3RhdGUyPTA7IC8vIC0xOiBhdCBsb3dlciwgMDogbG9ja2VkLCAxOiBhdCB1cHBlciwgMjogZnJlZVxuICAgIHRoaXMuZW5hYmxlTW90b3IyPWZhbHNlO1xuICAgIHRoaXMubW90b3JTcGVlZDI9TmFOO1xuICAgIHRoaXMubWF4TW90b3JGb3JjZTI9TmFOO1xuICAgIHRoaXMubWF4TW90b3JJbXB1bHNlMj1OYU47XG4gICAgdGhpcy5sb3dlckxpbWl0Mz1OYU47XG4gICAgdGhpcy51cHBlckxpbWl0Mz1OYU47XG4gICAgdGhpcy5saW1pdFZlbG9jaXR5Mz1OYU47XG4gICAgdGhpcy5saW1pdFN0YXRlMz0wOyAvLyAtMTogYXQgbG93ZXIsIDA6IGxvY2tlZCwgMTogYXQgdXBwZXIsIDI6IGZyZWVcbiAgICB0aGlzLmVuYWJsZU1vdG9yMz1mYWxzZTtcbiAgICB0aGlzLm1vdG9yU3BlZWQzPU5hTjtcbiAgICB0aGlzLm1heE1vdG9yRm9yY2UzPU5hTjtcbiAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTM9TmFOO1xuXG4gICAgdGhpcy5rMDA9TmFOOyAvLyBLID0gSipNKkpUXG4gICAgdGhpcy5rMDE9TmFOO1xuICAgIHRoaXMuazAyPU5hTjtcbiAgICB0aGlzLmsxMD1OYU47XG4gICAgdGhpcy5rMTE9TmFOO1xuICAgIHRoaXMuazEyPU5hTjtcbiAgICB0aGlzLmsyMD1OYU47XG4gICAgdGhpcy5rMjE9TmFOO1xuICAgIHRoaXMuazIyPU5hTjtcblxuICAgIHRoaXMua3YwMD1OYU47IC8vIGRpYWdvbmFscyB3aXRob3V0IENGTXNcbiAgICB0aGlzLmt2MTE9TmFOO1xuICAgIHRoaXMua3YyMj1OYU47XG5cbiAgICB0aGlzLmR2MDA9TmFOOyAvLyAuLi5pbnZlcnRlZFxuICAgIHRoaXMuZHYxMT1OYU47XG4gICAgdGhpcy5kdjIyPU5hTjtcblxuICAgIHRoaXMuZDAwPU5hTjsgIC8vIEteLTFcbiAgICB0aGlzLmQwMT1OYU47XG4gICAgdGhpcy5kMDI9TmFOO1xuICAgIHRoaXMuZDEwPU5hTjtcbiAgICB0aGlzLmQxMT1OYU47XG4gICAgdGhpcy5kMTI9TmFOO1xuICAgIHRoaXMuZDIwPU5hTjtcbiAgICB0aGlzLmQyMT1OYU47XG4gICAgdGhpcy5kMjI9TmFOO1xuXG4gICAgdGhpcy5saW1pdE1vdG9yMT1saW1pdE1vdG9yMTtcbiAgICB0aGlzLmxpbWl0TW90b3IyPWxpbWl0TW90b3IyO1xuICAgIHRoaXMubGltaXRNb3RvcjM9bGltaXRNb3RvcjM7XG4gICAgdGhpcy5iMT1qb2ludC5ib2R5MTtcbiAgICB0aGlzLmIyPWpvaW50LmJvZHkyO1xuICAgIHRoaXMuYTE9dGhpcy5iMS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdGhpcy5hMj10aGlzLmIyLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmkxPXRoaXMuYjEuaW52ZXJzZUluZXJ0aWE7XG4gICAgdGhpcy5pMj10aGlzLmIyLmludmVyc2VJbmVydGlhO1xuICAgIHRoaXMubGltaXRJbXB1bHNlMT0wO1xuICAgIHRoaXMubW90b3JJbXB1bHNlMT0wO1xuICAgIHRoaXMubGltaXRJbXB1bHNlMj0wO1xuICAgIHRoaXMubW90b3JJbXB1bHNlMj0wO1xuICAgIHRoaXMubGltaXRJbXB1bHNlMz0wO1xuICAgIHRoaXMubW90b3JJbXB1bHNlMz0wO1xuXG59XG5cbk9iamVjdC5hc3NpZ24oIFJvdGF0aW9uYWwzQ29uc3RyYWludC5wcm90b3R5cGUsIHtcblxuICAgIFJvdGF0aW9uYWwzQ29uc3RyYWludDogdHJ1ZSxcblxuICAgIHByZVNvbHZlOiBmdW5jdGlvbiggdGltZVN0ZXAsIGludlRpbWVTdGVwICl7XG5cbiAgICAgICAgdGhpcy5heDE9dGhpcy5saW1pdE1vdG9yMS5heGlzLng7XG4gICAgICAgIHRoaXMuYXkxPXRoaXMubGltaXRNb3RvcjEuYXhpcy55O1xuICAgICAgICB0aGlzLmF6MT10aGlzLmxpbWl0TW90b3IxLmF4aXMuejtcbiAgICAgICAgdGhpcy5heDI9dGhpcy5saW1pdE1vdG9yMi5heGlzLng7XG4gICAgICAgIHRoaXMuYXkyPXRoaXMubGltaXRNb3RvcjIuYXhpcy55O1xuICAgICAgICB0aGlzLmF6Mj10aGlzLmxpbWl0TW90b3IyLmF4aXMuejtcbiAgICAgICAgdGhpcy5heDM9dGhpcy5saW1pdE1vdG9yMy5heGlzLng7XG4gICAgICAgIHRoaXMuYXkzPXRoaXMubGltaXRNb3RvcjMuYXhpcy55O1xuICAgICAgICB0aGlzLmF6Mz10aGlzLmxpbWl0TW90b3IzLmF4aXMuejtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0MT10aGlzLmxpbWl0TW90b3IxLmxvd2VyTGltaXQ7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdDE9dGhpcy5saW1pdE1vdG9yMS51cHBlckxpbWl0O1xuICAgICAgICB0aGlzLm1vdG9yU3BlZWQxPXRoaXMubGltaXRNb3RvcjEubW90b3JTcGVlZDtcbiAgICAgICAgdGhpcy5tYXhNb3RvckZvcmNlMT10aGlzLmxpbWl0TW90b3IxLm1heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMuZW5hYmxlTW90b3IxPXRoaXMubWF4TW90b3JGb3JjZTE+MDtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0Mj10aGlzLmxpbWl0TW90b3IyLmxvd2VyTGltaXQ7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdDI9dGhpcy5saW1pdE1vdG9yMi51cHBlckxpbWl0O1xuICAgICAgICB0aGlzLm1vdG9yU3BlZWQyPXRoaXMubGltaXRNb3RvcjIubW90b3JTcGVlZDtcbiAgICAgICAgdGhpcy5tYXhNb3RvckZvcmNlMj10aGlzLmxpbWl0TW90b3IyLm1heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMuZW5hYmxlTW90b3IyPXRoaXMubWF4TW90b3JGb3JjZTI+MDtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0Mz10aGlzLmxpbWl0TW90b3IzLmxvd2VyTGltaXQ7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdDM9dGhpcy5saW1pdE1vdG9yMy51cHBlckxpbWl0O1xuICAgICAgICB0aGlzLm1vdG9yU3BlZWQzPXRoaXMubGltaXRNb3RvcjMubW90b3JTcGVlZDtcbiAgICAgICAgdGhpcy5tYXhNb3RvckZvcmNlMz10aGlzLmxpbWl0TW90b3IzLm1heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMuZW5hYmxlTW90b3IzPXRoaXMubWF4TW90b3JGb3JjZTM+MDtcblxuICAgICAgICB2YXIgdGkxID0gdGhpcy5pMS5lbGVtZW50cztcbiAgICAgICAgdmFyIHRpMiA9IHRoaXMuaTIuZWxlbWVudHM7XG4gICAgICAgIHRoaXMuaTFlMDA9dGkxWzBdO1xuICAgICAgICB0aGlzLmkxZTAxPXRpMVsxXTtcbiAgICAgICAgdGhpcy5pMWUwMj10aTFbMl07XG4gICAgICAgIHRoaXMuaTFlMTA9dGkxWzNdO1xuICAgICAgICB0aGlzLmkxZTExPXRpMVs0XTtcbiAgICAgICAgdGhpcy5pMWUxMj10aTFbNV07XG4gICAgICAgIHRoaXMuaTFlMjA9dGkxWzZdO1xuICAgICAgICB0aGlzLmkxZTIxPXRpMVs3XTtcbiAgICAgICAgdGhpcy5pMWUyMj10aTFbOF07XG5cbiAgICAgICAgdGhpcy5pMmUwMD10aTJbMF07XG4gICAgICAgIHRoaXMuaTJlMDE9dGkyWzFdO1xuICAgICAgICB0aGlzLmkyZTAyPXRpMlsyXTtcbiAgICAgICAgdGhpcy5pMmUxMD10aTJbM107XG4gICAgICAgIHRoaXMuaTJlMTE9dGkyWzRdO1xuICAgICAgICB0aGlzLmkyZTEyPXRpMls1XTtcbiAgICAgICAgdGhpcy5pMmUyMD10aTJbNl07XG4gICAgICAgIHRoaXMuaTJlMjE9dGkyWzddO1xuICAgICAgICB0aGlzLmkyZTIyPXRpMls4XTtcblxuICAgICAgICB2YXIgZnJlcXVlbmN5MT10aGlzLmxpbWl0TW90b3IxLmZyZXF1ZW5jeTtcbiAgICAgICAgdmFyIGZyZXF1ZW5jeTI9dGhpcy5saW1pdE1vdG9yMi5mcmVxdWVuY3k7XG4gICAgICAgIHZhciBmcmVxdWVuY3kzPXRoaXMubGltaXRNb3RvcjMuZnJlcXVlbmN5O1xuICAgICAgICB2YXIgZW5hYmxlU3ByaW5nMT1mcmVxdWVuY3kxPjA7XG4gICAgICAgIHZhciBlbmFibGVTcHJpbmcyPWZyZXF1ZW5jeTI+MDtcbiAgICAgICAgdmFyIGVuYWJsZVNwcmluZzM9ZnJlcXVlbmN5Mz4wO1xuICAgICAgICB2YXIgZW5hYmxlTGltaXQxPXRoaXMubG93ZXJMaW1pdDE8PXRoaXMudXBwZXJMaW1pdDE7XG4gICAgICAgIHZhciBlbmFibGVMaW1pdDI9dGhpcy5sb3dlckxpbWl0Mjw9dGhpcy51cHBlckxpbWl0MjtcbiAgICAgICAgdmFyIGVuYWJsZUxpbWl0Mz10aGlzLmxvd2VyTGltaXQzPD10aGlzLnVwcGVyTGltaXQzO1xuICAgICAgICB2YXIgYW5nbGUxPXRoaXMubGltaXRNb3RvcjEuYW5nbGU7XG4gICAgICAgIGlmKGVuYWJsZUxpbWl0MSl7XG4gICAgICAgICAgICBpZih0aGlzLmxvd2VyTGltaXQxPT10aGlzLnVwcGVyTGltaXQxKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUxIT0wKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMT0wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTE9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5MT10aGlzLmxvd2VyTGltaXQxLWFuZ2xlMTtcbiAgICAgICAgICAgIH1lbHNlIGlmKGFuZ2xlMTx0aGlzLmxvd2VyTGltaXQxKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUxIT0tMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTE9LTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMT0wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkxPXRoaXMubG93ZXJMaW1pdDEtYW5nbGUxO1xuICAgICAgICAgICAgfWVsc2UgaWYoYW5nbGUxPnRoaXMudXBwZXJMaW1pdDEpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZTEhPTEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUxPTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMT0wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkxPXRoaXMudXBwZXJMaW1pdDEtYW5nbGUxO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMT0yO1xuICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMT0wO1xuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTE9MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFlbmFibGVTcHJpbmcxKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0VmVsb2NpdHkxPjAuMDIpdGhpcy5saW1pdFZlbG9jaXR5MS09MC4wMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMubGltaXRWZWxvY2l0eTE8LTAuMDIpdGhpcy5saW1pdFZlbG9jaXR5MSs9MC4wMjtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMubGltaXRWZWxvY2l0eTE9MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUxPTI7XG4gICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTE9MDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmdsZTI9dGhpcy5saW1pdE1vdG9yMi5hbmdsZTtcbiAgICAgICAgaWYoZW5hYmxlTGltaXQyKXtcbiAgICAgICAgICAgIGlmKHRoaXMubG93ZXJMaW1pdDI9PXRoaXMudXBwZXJMaW1pdDIpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZTIhPTApe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUyPTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMj0wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkyPXRoaXMubG93ZXJMaW1pdDItYW5nbGUyO1xuICAgICAgICAgICAgfWVsc2UgaWYoYW5nbGUyPHRoaXMubG93ZXJMaW1pdDIpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZTIhPS0xKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMj0tMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTI9dGhpcy5sb3dlckxpbWl0Mi1hbmdsZTI7XG4gICAgICAgICAgICB9ZWxzZSBpZihhbmdsZTI+dGhpcy51cHBlckxpbWl0Mil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMiE9MSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTI9MTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTI9dGhpcy51cHBlckxpbWl0Mi1hbmdsZTI7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUyPTI7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyPTA7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mj0wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWVuYWJsZVNwcmluZzIpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRWZWxvY2l0eTI+MC4wMil0aGlzLmxpbWl0VmVsb2NpdHkyLT0wLjAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5saW1pdFZlbG9jaXR5MjwtMC4wMil0aGlzLmxpbWl0VmVsb2NpdHkyKz0wLjAyO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5saW1pdFZlbG9jaXR5Mj0wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTI9MjtcbiAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMj0wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuZ2xlMz10aGlzLmxpbWl0TW90b3IzLmFuZ2xlO1xuICAgICAgICBpZihlbmFibGVMaW1pdDMpe1xuICAgICAgICAgICAgaWYodGhpcy5sb3dlckxpbWl0Mz09dGhpcy51cHBlckxpbWl0Myl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMyE9MCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTM9MDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UzPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTM9dGhpcy5sb3dlckxpbWl0My1hbmdsZTM7XG4gICAgICAgICAgICB9ZWxzZSBpZihhbmdsZTM8dGhpcy5sb3dlckxpbWl0Myl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMyE9LTEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUzPS0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTM9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mz10aGlzLmxvd2VyTGltaXQzLWFuZ2xlMztcbiAgICAgICAgICAgIH1lbHNlIGlmKGFuZ2xlMz50aGlzLnVwcGVyTGltaXQzKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUzIT0xKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMz0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTM9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mz10aGlzLnVwcGVyTGltaXQzLWFuZ2xlMztcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTM9MjtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTM9MDtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkzPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWVuYWJsZVNwcmluZzMpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRWZWxvY2l0eTM+MC4wMil0aGlzLmxpbWl0VmVsb2NpdHkzLT0wLjAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5saW1pdFZlbG9jaXR5MzwtMC4wMil0aGlzLmxpbWl0VmVsb2NpdHkzKz0wLjAyO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5saW1pdFZlbG9jaXR5Mz0wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTM9MjtcbiAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMz0wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5lbmFibGVNb3RvcjEmJih0aGlzLmxpbWl0U3RhdGUxIT0wfHxlbmFibGVTcHJpbmcxKSl7XG4gICAgICAgICAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTE9dGhpcy5tYXhNb3RvckZvcmNlMSp0aW1lU3RlcDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTE9MDtcbiAgICAgICAgICAgIHRoaXMubWF4TW90b3JJbXB1bHNlMT0wO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlTW90b3IyJiYodGhpcy5saW1pdFN0YXRlMiE9MHx8ZW5hYmxlU3ByaW5nMikpe1xuICAgICAgICAgICAgdGhpcy5tYXhNb3RvckltcHVsc2UyPXRoaXMubWF4TW90b3JGb3JjZTIqdGltZVN0ZXA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UyPTA7XG4gICAgICAgICAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTI9MDtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmVuYWJsZU1vdG9yMyYmKHRoaXMubGltaXRTdGF0ZTMhPTB8fGVuYWJsZVNwcmluZzMpKXtcbiAgICAgICAgICAgIHRoaXMubWF4TW90b3JJbXB1bHNlMz10aGlzLm1heE1vdG9yRm9yY2UzKnRpbWVTdGVwO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMz0wO1xuICAgICAgICAgICAgdGhpcy5tYXhNb3RvckltcHVsc2UzPTA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCBqYWNvYmlhbnNcbiAgICAgICAgdGhpcy5hMXgxPXRoaXMuYXgxKnRoaXMuaTFlMDArdGhpcy5heTEqdGhpcy5pMWUwMSt0aGlzLmF6MSp0aGlzLmkxZTAyO1xuICAgICAgICB0aGlzLmExeTE9dGhpcy5heDEqdGhpcy5pMWUxMCt0aGlzLmF5MSp0aGlzLmkxZTExK3RoaXMuYXoxKnRoaXMuaTFlMTI7XG4gICAgICAgIHRoaXMuYTF6MT10aGlzLmF4MSp0aGlzLmkxZTIwK3RoaXMuYXkxKnRoaXMuaTFlMjErdGhpcy5hejEqdGhpcy5pMWUyMjtcbiAgICAgICAgdGhpcy5hMngxPXRoaXMuYXgxKnRoaXMuaTJlMDArdGhpcy5heTEqdGhpcy5pMmUwMSt0aGlzLmF6MSp0aGlzLmkyZTAyO1xuICAgICAgICB0aGlzLmEyeTE9dGhpcy5heDEqdGhpcy5pMmUxMCt0aGlzLmF5MSp0aGlzLmkyZTExK3RoaXMuYXoxKnRoaXMuaTJlMTI7XG4gICAgICAgIHRoaXMuYTJ6MT10aGlzLmF4MSp0aGlzLmkyZTIwK3RoaXMuYXkxKnRoaXMuaTJlMjErdGhpcy5hejEqdGhpcy5pMmUyMjtcblxuICAgICAgICB0aGlzLmExeDI9dGhpcy5heDIqdGhpcy5pMWUwMCt0aGlzLmF5Mip0aGlzLmkxZTAxK3RoaXMuYXoyKnRoaXMuaTFlMDI7XG4gICAgICAgIHRoaXMuYTF5Mj10aGlzLmF4Mip0aGlzLmkxZTEwK3RoaXMuYXkyKnRoaXMuaTFlMTErdGhpcy5hejIqdGhpcy5pMWUxMjtcbiAgICAgICAgdGhpcy5hMXoyPXRoaXMuYXgyKnRoaXMuaTFlMjArdGhpcy5heTIqdGhpcy5pMWUyMSt0aGlzLmF6Mip0aGlzLmkxZTIyO1xuICAgICAgICB0aGlzLmEyeDI9dGhpcy5heDIqdGhpcy5pMmUwMCt0aGlzLmF5Mip0aGlzLmkyZTAxK3RoaXMuYXoyKnRoaXMuaTJlMDI7XG4gICAgICAgIHRoaXMuYTJ5Mj10aGlzLmF4Mip0aGlzLmkyZTEwK3RoaXMuYXkyKnRoaXMuaTJlMTErdGhpcy5hejIqdGhpcy5pMmUxMjtcbiAgICAgICAgdGhpcy5hMnoyPXRoaXMuYXgyKnRoaXMuaTJlMjArdGhpcy5heTIqdGhpcy5pMmUyMSt0aGlzLmF6Mip0aGlzLmkyZTIyO1xuXG4gICAgICAgIHRoaXMuYTF4Mz10aGlzLmF4Myp0aGlzLmkxZTAwK3RoaXMuYXkzKnRoaXMuaTFlMDErdGhpcy5hejMqdGhpcy5pMWUwMjtcbiAgICAgICAgdGhpcy5hMXkzPXRoaXMuYXgzKnRoaXMuaTFlMTArdGhpcy5heTMqdGhpcy5pMWUxMSt0aGlzLmF6Myp0aGlzLmkxZTEyO1xuICAgICAgICB0aGlzLmExejM9dGhpcy5heDMqdGhpcy5pMWUyMCt0aGlzLmF5Myp0aGlzLmkxZTIxK3RoaXMuYXozKnRoaXMuaTFlMjI7XG4gICAgICAgIHRoaXMuYTJ4Mz10aGlzLmF4Myp0aGlzLmkyZTAwK3RoaXMuYXkzKnRoaXMuaTJlMDErdGhpcy5hejMqdGhpcy5pMmUwMjtcbiAgICAgICAgdGhpcy5hMnkzPXRoaXMuYXgzKnRoaXMuaTJlMTArdGhpcy5heTMqdGhpcy5pMmUxMSt0aGlzLmF6Myp0aGlzLmkyZTEyO1xuICAgICAgICB0aGlzLmEyejM9dGhpcy5heDMqdGhpcy5pMmUyMCt0aGlzLmF5Myp0aGlzLmkyZTIxK3RoaXMuYXozKnRoaXMuaTJlMjI7XG5cbiAgICAgICAgLy8gYnVpbGQgYW4gaW1wdWxzZSBtYXRyaXhcbiAgICAgICAgdGhpcy5rMDA9dGhpcy5heDEqKHRoaXMuYTF4MSt0aGlzLmEyeDEpK3RoaXMuYXkxKih0aGlzLmExeTErdGhpcy5hMnkxKSt0aGlzLmF6MSoodGhpcy5hMXoxK3RoaXMuYTJ6MSk7XG4gICAgICAgIHRoaXMuazAxPXRoaXMuYXgxKih0aGlzLmExeDIrdGhpcy5hMngyKSt0aGlzLmF5MSoodGhpcy5hMXkyK3RoaXMuYTJ5MikrdGhpcy5hejEqKHRoaXMuYTF6Mit0aGlzLmEyejIpO1xuICAgICAgICB0aGlzLmswMj10aGlzLmF4MSoodGhpcy5hMXgzK3RoaXMuYTJ4MykrdGhpcy5heTEqKHRoaXMuYTF5Myt0aGlzLmEyeTMpK3RoaXMuYXoxKih0aGlzLmExejMrdGhpcy5hMnozKTtcbiAgICAgICAgdGhpcy5rMTA9dGhpcy5heDIqKHRoaXMuYTF4MSt0aGlzLmEyeDEpK3RoaXMuYXkyKih0aGlzLmExeTErdGhpcy5hMnkxKSt0aGlzLmF6MioodGhpcy5hMXoxK3RoaXMuYTJ6MSk7XG4gICAgICAgIHRoaXMuazExPXRoaXMuYXgyKih0aGlzLmExeDIrdGhpcy5hMngyKSt0aGlzLmF5MioodGhpcy5hMXkyK3RoaXMuYTJ5MikrdGhpcy5hejIqKHRoaXMuYTF6Mit0aGlzLmEyejIpO1xuICAgICAgICB0aGlzLmsxMj10aGlzLmF4MioodGhpcy5hMXgzK3RoaXMuYTJ4MykrdGhpcy5heTIqKHRoaXMuYTF5Myt0aGlzLmEyeTMpK3RoaXMuYXoyKih0aGlzLmExejMrdGhpcy5hMnozKTtcbiAgICAgICAgdGhpcy5rMjA9dGhpcy5heDMqKHRoaXMuYTF4MSt0aGlzLmEyeDEpK3RoaXMuYXkzKih0aGlzLmExeTErdGhpcy5hMnkxKSt0aGlzLmF6MyoodGhpcy5hMXoxK3RoaXMuYTJ6MSk7XG4gICAgICAgIHRoaXMuazIxPXRoaXMuYXgzKih0aGlzLmExeDIrdGhpcy5hMngyKSt0aGlzLmF5MyoodGhpcy5hMXkyK3RoaXMuYTJ5MikrdGhpcy5hejMqKHRoaXMuYTF6Mit0aGlzLmEyejIpO1xuICAgICAgICB0aGlzLmsyMj10aGlzLmF4MyoodGhpcy5hMXgzK3RoaXMuYTJ4MykrdGhpcy5heTMqKHRoaXMuYTF5Myt0aGlzLmEyeTMpK3RoaXMuYXozKih0aGlzLmExejMrdGhpcy5hMnozKTtcblxuICAgICAgICB0aGlzLmt2MDA9dGhpcy5rMDA7XG4gICAgICAgIHRoaXMua3YxMT10aGlzLmsxMTtcbiAgICAgICAgdGhpcy5rdjIyPXRoaXMuazIyO1xuICAgICAgICB0aGlzLmR2MDA9MS90aGlzLmt2MDA7XG4gICAgICAgIHRoaXMuZHYxMT0xL3RoaXMua3YxMTtcbiAgICAgICAgdGhpcy5kdjIyPTEvdGhpcy5rdjIyO1xuXG4gICAgICAgIGlmKGVuYWJsZVNwcmluZzEmJnRoaXMubGltaXRTdGF0ZTEhPTIpe1xuICAgICAgICAgICAgdmFyIG9tZWdhPTYuMjgzMTg1MypmcmVxdWVuY3kxO1xuICAgICAgICAgICAgdmFyIGs9b21lZ2Eqb21lZ2EqdGltZVN0ZXA7XG4gICAgICAgICAgICB2YXIgZG1wPWludlRpbWVTdGVwLyhrKzIqdGhpcy5saW1pdE1vdG9yMS5kYW1waW5nUmF0aW8qb21lZ2EpO1xuICAgICAgICAgICAgdGhpcy5jZm0xPXRoaXMua3YwMCpkbXA7XG4gICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkxKj1rKmRtcDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLmNmbTE9MDtcbiAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTEqPWludlRpbWVTdGVwKjAuMDU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbmFibGVTcHJpbmcyJiZ0aGlzLmxpbWl0U3RhdGUyIT0yKXtcbiAgICAgICAgICAgIG9tZWdhPTYuMjgzMTg1MypmcmVxdWVuY3kyO1xuICAgICAgICAgICAgaz1vbWVnYSpvbWVnYSp0aW1lU3RlcDtcbiAgICAgICAgICAgIGRtcD1pbnZUaW1lU3RlcC8oaysyKnRoaXMubGltaXRNb3RvcjIuZGFtcGluZ1JhdGlvKm9tZWdhKTtcbiAgICAgICAgICAgIHRoaXMuY2ZtMj10aGlzLmt2MTEqZG1wO1xuICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mio9aypkbXA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5jZm0yPTA7XG4gICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkyKj1pbnZUaW1lU3RlcCowLjA1O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZW5hYmxlU3ByaW5nMyYmdGhpcy5saW1pdFN0YXRlMyE9Mil7XG4gICAgICAgICAgICBvbWVnYT02LjI4MzE4NTMqZnJlcXVlbmN5MztcbiAgICAgICAgICAgIGs9b21lZ2Eqb21lZ2EqdGltZVN0ZXA7XG4gICAgICAgICAgICBkbXA9aW52VGltZVN0ZXAvKGsrMip0aGlzLmxpbWl0TW90b3IzLmRhbXBpbmdSYXRpbypvbWVnYSk7XG4gICAgICAgICAgICB0aGlzLmNmbTM9dGhpcy5rdjIyKmRtcDtcbiAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTMqPWsqZG1wO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMuY2ZtMz0wO1xuICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Myo9aW52VGltZVN0ZXAqMC4wNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuazAwKz10aGlzLmNmbTE7XG4gICAgICAgIHRoaXMuazExKz10aGlzLmNmbTI7XG4gICAgICAgIHRoaXMuazIyKz10aGlzLmNmbTM7XG5cbiAgICAgICAgdmFyIGludj0xLyhcbiAgICAgICAgdGhpcy5rMDAqKHRoaXMuazExKnRoaXMuazIyLXRoaXMuazIxKnRoaXMuazEyKStcbiAgICAgICAgdGhpcy5rMTAqKHRoaXMuazIxKnRoaXMuazAyLXRoaXMuazAxKnRoaXMuazIyKStcbiAgICAgICAgdGhpcy5rMjAqKHRoaXMuazAxKnRoaXMuazEyLXRoaXMuazExKnRoaXMuazAyKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmQwMD0odGhpcy5rMTEqdGhpcy5rMjItdGhpcy5rMTIqdGhpcy5rMjEpKmludjtcbiAgICAgICAgdGhpcy5kMDE9KHRoaXMuazAyKnRoaXMuazIxLXRoaXMuazAxKnRoaXMuazIyKSppbnY7XG4gICAgICAgIHRoaXMuZDAyPSh0aGlzLmswMSp0aGlzLmsxMi10aGlzLmswMip0aGlzLmsxMSkqaW52O1xuICAgICAgICB0aGlzLmQxMD0odGhpcy5rMTIqdGhpcy5rMjAtdGhpcy5rMTAqdGhpcy5rMjIpKmludjtcbiAgICAgICAgdGhpcy5kMTE9KHRoaXMuazAwKnRoaXMuazIyLXRoaXMuazAyKnRoaXMuazIwKSppbnY7XG4gICAgICAgIHRoaXMuZDEyPSh0aGlzLmswMip0aGlzLmsxMC10aGlzLmswMCp0aGlzLmsxMikqaW52O1xuICAgICAgICB0aGlzLmQyMD0odGhpcy5rMTAqdGhpcy5rMjEtdGhpcy5rMTEqdGhpcy5rMjApKmludjtcbiAgICAgICAgdGhpcy5kMjE9KHRoaXMuazAxKnRoaXMuazIwLXRoaXMuazAwKnRoaXMuazIxKSppbnY7XG4gICAgICAgIHRoaXMuZDIyPSh0aGlzLmswMCp0aGlzLmsxMS10aGlzLmswMSp0aGlzLmsxMCkqaW52O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UxKj0wLjk1O1xuICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTEqPTAuOTU7XG4gICAgICAgIHRoaXMubGltaXRJbXB1bHNlMio9MC45NTtcbiAgICAgICAgdGhpcy5tb3RvckltcHVsc2UyKj0wLjk1O1xuICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTMqPTAuOTU7XG4gICAgICAgIHRoaXMubW90b3JJbXB1bHNlMyo9MC45NTtcbiAgICAgICAgdmFyIHRvdGFsSW1wdWxzZTE9dGhpcy5saW1pdEltcHVsc2UxK3RoaXMubW90b3JJbXB1bHNlMTtcbiAgICAgICAgdmFyIHRvdGFsSW1wdWxzZTI9dGhpcy5saW1pdEltcHVsc2UyK3RoaXMubW90b3JJbXB1bHNlMjtcbiAgICAgICAgdmFyIHRvdGFsSW1wdWxzZTM9dGhpcy5saW1pdEltcHVsc2UzK3RoaXMubW90b3JJbXB1bHNlMztcbiAgICAgICAgdGhpcy5hMS54Kz10b3RhbEltcHVsc2UxKnRoaXMuYTF4MSt0b3RhbEltcHVsc2UyKnRoaXMuYTF4Mit0b3RhbEltcHVsc2UzKnRoaXMuYTF4MztcbiAgICAgICAgdGhpcy5hMS55Kz10b3RhbEltcHVsc2UxKnRoaXMuYTF5MSt0b3RhbEltcHVsc2UyKnRoaXMuYTF5Mit0b3RhbEltcHVsc2UzKnRoaXMuYTF5MztcbiAgICAgICAgdGhpcy5hMS56Kz10b3RhbEltcHVsc2UxKnRoaXMuYTF6MSt0b3RhbEltcHVsc2UyKnRoaXMuYTF6Mit0b3RhbEltcHVsc2UzKnRoaXMuYTF6MztcbiAgICAgICAgdGhpcy5hMi54LT10b3RhbEltcHVsc2UxKnRoaXMuYTJ4MSt0b3RhbEltcHVsc2UyKnRoaXMuYTJ4Mit0b3RhbEltcHVsc2UzKnRoaXMuYTJ4MztcbiAgICAgICAgdGhpcy5hMi55LT10b3RhbEltcHVsc2UxKnRoaXMuYTJ5MSt0b3RhbEltcHVsc2UyKnRoaXMuYTJ5Mit0b3RhbEltcHVsc2UzKnRoaXMuYTJ5MztcbiAgICAgICAgdGhpcy5hMi56LT10b3RhbEltcHVsc2UxKnRoaXMuYTJ6MSt0b3RhbEltcHVsc2UyKnRoaXMuYTJ6Mit0b3RhbEltcHVsc2UzKnRoaXMuYTJ6MztcbiAgICB9LFxuICAgIHNvbHZlXzpmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBydng9dGhpcy5hMi54LXRoaXMuYTEueDtcbiAgICAgICAgdmFyIHJ2eT10aGlzLmEyLnktdGhpcy5hMS55O1xuICAgICAgICB2YXIgcnZ6PXRoaXMuYTIuei10aGlzLmExLno7XG5cbiAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mz0zMDtcbiAgICAgICAgdmFyIHJ2bjE9cnZ4KnRoaXMuYXgxK3J2eSp0aGlzLmF5MStydnoqdGhpcy5hejEtdGhpcy5saW1pdFZlbG9jaXR5MTtcbiAgICAgICAgdmFyIHJ2bjI9cnZ4KnRoaXMuYXgyK3J2eSp0aGlzLmF5MitydnoqdGhpcy5hejItdGhpcy5saW1pdFZlbG9jaXR5MjtcbiAgICAgICAgdmFyIHJ2bjM9cnZ4KnRoaXMuYXgzK3J2eSp0aGlzLmF5MytydnoqdGhpcy5hejMtdGhpcy5saW1pdFZlbG9jaXR5MztcblxuICAgICAgICB2YXIgZExpbWl0SW1wdWxzZTE9cnZuMSp0aGlzLmQwMCtydm4yKnRoaXMuZDAxK3J2bjMqdGhpcy5kMDI7XG4gICAgICAgIHZhciBkTGltaXRJbXB1bHNlMj1ydm4xKnRoaXMuZDEwK3J2bjIqdGhpcy5kMTErcnZuMyp0aGlzLmQxMjtcbiAgICAgICAgdmFyIGRMaW1pdEltcHVsc2UzPXJ2bjEqdGhpcy5kMjArcnZuMip0aGlzLmQyMStydm4zKnRoaXMuZDIyO1xuXG4gICAgICAgIHRoaXMubGltaXRJbXB1bHNlMSs9ZExpbWl0SW1wdWxzZTE7XG4gICAgICAgIHRoaXMubGltaXRJbXB1bHNlMis9ZExpbWl0SW1wdWxzZTI7XG4gICAgICAgIHRoaXMubGltaXRJbXB1bHNlMys9ZExpbWl0SW1wdWxzZTM7XG5cbiAgICAgICAgdGhpcy5hMS54Kz1kTGltaXRJbXB1bHNlMSp0aGlzLmExeDErZExpbWl0SW1wdWxzZTIqdGhpcy5hMXgyK2RMaW1pdEltcHVsc2UzKnRoaXMuYTF4MztcbiAgICAgICAgdGhpcy5hMS55Kz1kTGltaXRJbXB1bHNlMSp0aGlzLmExeTErZExpbWl0SW1wdWxzZTIqdGhpcy5hMXkyK2RMaW1pdEltcHVsc2UzKnRoaXMuYTF5MztcbiAgICAgICAgdGhpcy5hMS56Kz1kTGltaXRJbXB1bHNlMSp0aGlzLmExejErZExpbWl0SW1wdWxzZTIqdGhpcy5hMXoyK2RMaW1pdEltcHVsc2UzKnRoaXMuYTF6MztcbiAgICAgICAgdGhpcy5hMi54LT1kTGltaXRJbXB1bHNlMSp0aGlzLmEyeDErZExpbWl0SW1wdWxzZTIqdGhpcy5hMngyK2RMaW1pdEltcHVsc2UzKnRoaXMuYTJ4MztcbiAgICAgICAgdGhpcy5hMi55LT1kTGltaXRJbXB1bHNlMSp0aGlzLmEyeTErZExpbWl0SW1wdWxzZTIqdGhpcy5hMnkyK2RMaW1pdEltcHVsc2UzKnRoaXMuYTJ5MztcbiAgICAgICAgdGhpcy5hMi56LT1kTGltaXRJbXB1bHNlMSp0aGlzLmEyejErZExpbWl0SW1wdWxzZTIqdGhpcy5hMnoyK2RMaW1pdEltcHVsc2UzKnRoaXMuYTJ6MztcbiAgICB9LFxuICAgIHNvbHZlOmZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIHJ2eD10aGlzLmEyLngtdGhpcy5hMS54O1xuICAgICAgICB2YXIgcnZ5PXRoaXMuYTIueS10aGlzLmExLnk7XG4gICAgICAgIHZhciBydno9dGhpcy5hMi56LXRoaXMuYTEuejtcblxuICAgICAgICB2YXIgcnZuMT1ydngqdGhpcy5heDErcnZ5KnRoaXMuYXkxK3J2eip0aGlzLmF6MTtcbiAgICAgICAgdmFyIHJ2bjI9cnZ4KnRoaXMuYXgyK3J2eSp0aGlzLmF5MitydnoqdGhpcy5hejI7XG4gICAgICAgIHZhciBydm4zPXJ2eCp0aGlzLmF4MytydnkqdGhpcy5heTMrcnZ6KnRoaXMuYXozO1xuXG4gICAgICAgIHZhciBvbGRNb3RvckltcHVsc2UxPXRoaXMubW90b3JJbXB1bHNlMTtcbiAgICAgICAgdmFyIG9sZE1vdG9ySW1wdWxzZTI9dGhpcy5tb3RvckltcHVsc2UyO1xuICAgICAgICB2YXIgb2xkTW90b3JJbXB1bHNlMz10aGlzLm1vdG9ySW1wdWxzZTM7XG5cbiAgICAgICAgdmFyIGRNb3RvckltcHVsc2UxPTA7XG4gICAgICAgIHZhciBkTW90b3JJbXB1bHNlMj0wO1xuICAgICAgICB2YXIgZE1vdG9ySW1wdWxzZTM9MDtcblxuICAgICAgICBpZih0aGlzLmVuYWJsZU1vdG9yMSl7XG4gICAgICAgICAgICBkTW90b3JJbXB1bHNlMT0ocnZuMS10aGlzLm1vdG9yU3BlZWQxKSp0aGlzLmR2MDA7XG4gICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTErPWRNb3RvckltcHVsc2UxO1xuICAgICAgICAgICAgaWYodGhpcy5tb3RvckltcHVsc2UxPnRoaXMubWF4TW90b3JJbXB1bHNlMSl7IC8vIGNsYW1wIG1vdG9yIGltcHVsc2VcbiAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMT10aGlzLm1heE1vdG9ySW1wdWxzZTE7XG4gICAgICAgICAgICB9ZWxzZSBpZih0aGlzLm1vdG9ySW1wdWxzZTE8LXRoaXMubWF4TW90b3JJbXB1bHNlMSl7XG4gICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTE9LXRoaXMubWF4TW90b3JJbXB1bHNlMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRNb3RvckltcHVsc2UxPXRoaXMubW90b3JJbXB1bHNlMS1vbGRNb3RvckltcHVsc2UxO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlTW90b3IyKXtcbiAgICAgICAgICAgIGRNb3RvckltcHVsc2UyPShydm4yLXRoaXMubW90b3JTcGVlZDIpKnRoaXMuZHYxMTtcbiAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMis9ZE1vdG9ySW1wdWxzZTI7XG4gICAgICAgICAgICBpZih0aGlzLm1vdG9ySW1wdWxzZTI+dGhpcy5tYXhNb3RvckltcHVsc2UyKXsgLy8gY2xhbXAgbW90b3IgaW1wdWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMj10aGlzLm1heE1vdG9ySW1wdWxzZTI7XG4gICAgICAgICAgICB9ZWxzZSBpZih0aGlzLm1vdG9ySW1wdWxzZTI8LXRoaXMubWF4TW90b3JJbXB1bHNlMil7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UyPS10aGlzLm1heE1vdG9ySW1wdWxzZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkTW90b3JJbXB1bHNlMj10aGlzLm1vdG9ySW1wdWxzZTItb2xkTW90b3JJbXB1bHNlMjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmVuYWJsZU1vdG9yMyl7XG4gICAgICAgICAgICBkTW90b3JJbXB1bHNlMz0ocnZuMy10aGlzLm1vdG9yU3BlZWQzKSp0aGlzLmR2MjI7XG4gICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTMrPWRNb3RvckltcHVsc2UzO1xuICAgICAgICAgICAgaWYodGhpcy5tb3RvckltcHVsc2UzPnRoaXMubWF4TW90b3JJbXB1bHNlMyl7IC8vIGNsYW1wIG1vdG9yIGltcHVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTM9dGhpcy5tYXhNb3RvckltcHVsc2UzO1xuICAgICAgICAgICAgfWVsc2UgaWYodGhpcy5tb3RvckltcHVsc2UzPC10aGlzLm1heE1vdG9ySW1wdWxzZTMpe1xuICAgICAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMz0tdGhpcy5tYXhNb3RvckltcHVsc2UzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZE1vdG9ySW1wdWxzZTM9dGhpcy5tb3RvckltcHVsc2UzLW9sZE1vdG9ySW1wdWxzZTM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBtb3RvciBpbXB1bHNlIHRvIHJlbGF0aXZlIHZlbG9jaXR5XG4gICAgICAgIHJ2bjErPWRNb3RvckltcHVsc2UxKnRoaXMua3YwMCtkTW90b3JJbXB1bHNlMip0aGlzLmswMStkTW90b3JJbXB1bHNlMyp0aGlzLmswMjtcbiAgICAgICAgcnZuMis9ZE1vdG9ySW1wdWxzZTEqdGhpcy5rMTArZE1vdG9ySW1wdWxzZTIqdGhpcy5rdjExK2RNb3RvckltcHVsc2UzKnRoaXMuazEyO1xuICAgICAgICBydm4zKz1kTW90b3JJbXB1bHNlMSp0aGlzLmsyMCtkTW90b3JJbXB1bHNlMip0aGlzLmsyMStkTW90b3JJbXB1bHNlMyp0aGlzLmt2MjI7XG5cbiAgICAgICAgLy8gc3VidHJhY3QgdGFyZ2V0IHZlbG9jaXR5IGFuZCBhcHBsaWVkIGltcHVsc2VcbiAgICAgICAgcnZuMS09dGhpcy5saW1pdFZlbG9jaXR5MSt0aGlzLmxpbWl0SW1wdWxzZTEqdGhpcy5jZm0xO1xuICAgICAgICBydm4yLT10aGlzLmxpbWl0VmVsb2NpdHkyK3RoaXMubGltaXRJbXB1bHNlMip0aGlzLmNmbTI7XG4gICAgICAgIHJ2bjMtPXRoaXMubGltaXRWZWxvY2l0eTMrdGhpcy5saW1pdEltcHVsc2UzKnRoaXMuY2ZtMztcblxuICAgICAgICB2YXIgb2xkTGltaXRJbXB1bHNlMT10aGlzLmxpbWl0SW1wdWxzZTE7XG4gICAgICAgIHZhciBvbGRMaW1pdEltcHVsc2UyPXRoaXMubGltaXRJbXB1bHNlMjtcbiAgICAgICAgdmFyIG9sZExpbWl0SW1wdWxzZTM9dGhpcy5saW1pdEltcHVsc2UzO1xuXG4gICAgICAgIHZhciBkTGltaXRJbXB1bHNlMT1ydm4xKnRoaXMuZDAwK3J2bjIqdGhpcy5kMDErcnZuMyp0aGlzLmQwMjtcbiAgICAgICAgdmFyIGRMaW1pdEltcHVsc2UyPXJ2bjEqdGhpcy5kMTArcnZuMip0aGlzLmQxMStydm4zKnRoaXMuZDEyO1xuICAgICAgICB2YXIgZExpbWl0SW1wdWxzZTM9cnZuMSp0aGlzLmQyMCtydm4yKnRoaXMuZDIxK3J2bjMqdGhpcy5kMjI7XG5cbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UxKz1kTGltaXRJbXB1bHNlMTtcbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyKz1kTGltaXRJbXB1bHNlMjtcbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UzKz1kTGltaXRJbXB1bHNlMztcblxuICAgICAgICAvLyBjbGFtcFxuICAgICAgICB2YXIgY2xhbXBTdGF0ZT0wO1xuICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUxPT0yfHx0aGlzLmxpbWl0SW1wdWxzZTEqdGhpcy5saW1pdFN0YXRlMTwwKXtcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UxPS1vbGRMaW1pdEltcHVsc2UxO1xuICAgICAgICAgICAgcnZuMis9ZExpbWl0SW1wdWxzZTEqdGhpcy5rMTA7XG4gICAgICAgICAgICBydm4zKz1kTGltaXRJbXB1bHNlMSp0aGlzLmsyMDtcbiAgICAgICAgICAgIGNsYW1wU3RhdGV8PTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMj09Mnx8dGhpcy5saW1pdEltcHVsc2UyKnRoaXMubGltaXRTdGF0ZTI8MCl7XG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMj0tb2xkTGltaXRJbXB1bHNlMjtcbiAgICAgICAgICAgIHJ2bjErPWRMaW1pdEltcHVsc2UyKnRoaXMuazAxO1xuICAgICAgICAgICAgcnZuMys9ZExpbWl0SW1wdWxzZTIqdGhpcy5rMjE7XG4gICAgICAgICAgICBjbGFtcFN0YXRlfD0yO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZTM9PTJ8fHRoaXMubGltaXRJbXB1bHNlMyp0aGlzLmxpbWl0U3RhdGUzPDApe1xuICAgICAgICAgICAgZExpbWl0SW1wdWxzZTM9LW9sZExpbWl0SW1wdWxzZTM7XG4gICAgICAgICAgICBydm4xKz1kTGltaXRJbXB1bHNlMyp0aGlzLmswMjtcbiAgICAgICAgICAgIHJ2bjIrPWRMaW1pdEltcHVsc2UzKnRoaXMuazEyO1xuICAgICAgICAgICAgY2xhbXBTdGF0ZXw9NDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB1bi1jbGFtcGVkIGltcHVsc2VcbiAgICAgICAgLy8gVE9ETzogaXNvbGF0ZSBkaXZpc2lvblxuICAgICAgICB2YXIgZGV0O1xuICAgICAgICBzd2l0Y2goY2xhbXBTdGF0ZSl7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIHVwZGF0ZSAyIDNcbiAgICAgICAgICAgIGRldD0xLyh0aGlzLmsxMSp0aGlzLmsyMi10aGlzLmsxMip0aGlzLmsyMSk7XG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMj0odGhpcy5rMjIqcnZuMistdGhpcy5rMTIqcnZuMykqZGV0O1xuICAgICAgICAgICAgZExpbWl0SW1wdWxzZTM9KC10aGlzLmsyMSpydm4yK3RoaXMuazExKnJ2bjMpKmRldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOiAvLyB1cGRhdGUgMSAzXG4gICAgICAgICAgICBkZXQ9MS8odGhpcy5rMDAqdGhpcy5rMjItdGhpcy5rMDIqdGhpcy5rMjApO1xuICAgICAgICAgICAgZExpbWl0SW1wdWxzZTE9KHRoaXMuazIyKnJ2bjErLXRoaXMuazAyKnJ2bjMpKmRldDtcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UzPSgtdGhpcy5rMjAqcnZuMSt0aGlzLmswMCpydm4zKSpkZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogLy8gdXBkYXRlIDNcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UzPXJ2bjMvdGhpcy5rMjI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDogLy8gdXBkYXRlIDEgMlxuICAgICAgICAgICAgZGV0PTEvKHRoaXMuazAwKnRoaXMuazExLXRoaXMuazAxKnRoaXMuazEwKTtcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UxPSh0aGlzLmsxMSpydm4xKy10aGlzLmswMSpydm4yKSpkZXQ7XG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMj0oLXRoaXMuazEwKnJ2bjErdGhpcy5rMDAqcnZuMikqZGV0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6IC8vIHVwZGF0ZSAyXG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMj1ydm4yL3RoaXMuazExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6IC8vIHVwZGF0ZSAxXG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMT1ydm4xL3RoaXMuazAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTE9ZExpbWl0SW1wdWxzZTErb2xkTGltaXRJbXB1bHNlMTtcbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyPWRMaW1pdEltcHVsc2UyK29sZExpbWl0SW1wdWxzZTI7XG4gICAgICAgIHRoaXMubGltaXRJbXB1bHNlMz1kTGltaXRJbXB1bHNlMytvbGRMaW1pdEltcHVsc2UzO1xuXG4gICAgICAgIHZhciBkSW1wdWxzZTE9ZE1vdG9ySW1wdWxzZTErZExpbWl0SW1wdWxzZTE7XG4gICAgICAgIHZhciBkSW1wdWxzZTI9ZE1vdG9ySW1wdWxzZTIrZExpbWl0SW1wdWxzZTI7XG4gICAgICAgIHZhciBkSW1wdWxzZTM9ZE1vdG9ySW1wdWxzZTMrZExpbWl0SW1wdWxzZTM7XG5cbiAgICAgICAgLy8gYXBwbHkgaW1wdWxzZVxuICAgICAgICB0aGlzLmExLngrPWRJbXB1bHNlMSp0aGlzLmExeDErZEltcHVsc2UyKnRoaXMuYTF4MitkSW1wdWxzZTMqdGhpcy5hMXgzO1xuICAgICAgICB0aGlzLmExLnkrPWRJbXB1bHNlMSp0aGlzLmExeTErZEltcHVsc2UyKnRoaXMuYTF5MitkSW1wdWxzZTMqdGhpcy5hMXkzO1xuICAgICAgICB0aGlzLmExLnorPWRJbXB1bHNlMSp0aGlzLmExejErZEltcHVsc2UyKnRoaXMuYTF6MitkSW1wdWxzZTMqdGhpcy5hMXozO1xuICAgICAgICB0aGlzLmEyLngtPWRJbXB1bHNlMSp0aGlzLmEyeDErZEltcHVsc2UyKnRoaXMuYTJ4MitkSW1wdWxzZTMqdGhpcy5hMngzO1xuICAgICAgICB0aGlzLmEyLnktPWRJbXB1bHNlMSp0aGlzLmEyeTErZEltcHVsc2UyKnRoaXMuYTJ5MitkSW1wdWxzZTMqdGhpcy5hMnkzO1xuICAgICAgICB0aGlzLmEyLnotPWRJbXB1bHNlMSp0aGlzLmEyejErZEltcHVsc2UyKnRoaXMuYTJ6MitkSW1wdWxzZTMqdGhpcy5hMnozO1xuICAgICAgICBydng9dGhpcy5hMi54LXRoaXMuYTEueDtcbiAgICAgICAgcnZ5PXRoaXMuYTIueS10aGlzLmExLnk7XG4gICAgICAgIHJ2ej10aGlzLmEyLnotdGhpcy5hMS56O1xuXG4gICAgICAgIHJ2bjI9cnZ4KnRoaXMuYXgyK3J2eSp0aGlzLmF5MitydnoqdGhpcy5hejI7XG4gICAgfVxuICAgIFxufSApO1xuXG4vKipcbiAqIEEgaGluZ2Ugam9pbnQgYWxsb3dzIG9ubHkgZm9yIHJlbGF0aXZlIHJvdGF0aW9uIG9mIHJpZ2lkIGJvZGllcyBhbG9uZyB0aGUgYXhpcy5cbiAqXG4gKiBAYXV0aG9yIHNhaGFyYW5cbiAqIEBhdXRob3IgbG8tdGhcbiAqL1xuXG5mdW5jdGlvbiBIaW5nZUpvaW50ICggY29uZmlnLCBsb3dlckFuZ2xlTGltaXQsIHVwcGVyQW5nbGVMaW1pdCApIHtcblxuICAgIEpvaW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG4gICAgdGhpcy50eXBlID0gSk9JTlRfSElOR0U7XG5cbiAgICAvLyBUaGUgYXhpcyBpbiB0aGUgZmlyc3QgYm9keSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIHRoaXMubG9jYWxBeGlzMSA9IGNvbmZpZy5sb2NhbEF4aXMxLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgLy8gVGhlIGF4aXMgaW4gdGhlIHNlY29uZCBib2R5J3MgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgdGhpcy5sb2NhbEF4aXMyID0gY29uZmlnLmxvY2FsQXhpczIuY2xvbmUoKS5ub3JtYWxpemUoKTtcblxuICAgIC8vIG1ha2UgYW5nbGUgYXhpc1xuICAgIHZhciBhcmMgPSBuZXcgTWF0MzMoKS5zZXRRdWF0KCBuZXcgUXVhdCgpLnNldEZyb21Vbml0VmVjdG9ycyggdGhpcy5sb2NhbEF4aXMxLCB0aGlzLmxvY2FsQXhpczIgKSApO1xuICAgIHRoaXMubG9jYWxBbmdsZTEgPSBuZXcgVmVjMygpLnRhbmdlbnQoIHRoaXMubG9jYWxBeGlzMSApLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMubG9jYWxBbmdsZTIgPSB0aGlzLmxvY2FsQW5nbGUxLmNsb25lKCkuYXBwbHlNYXRyaXgzKCBhcmMsIHRydWUgKTtcblxuICAgIHRoaXMuYXgxID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmF4MiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbjEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW4yID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMudG1wID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMubm9yID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRhbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5iaW4gPSBuZXcgVmVjMygpO1xuXG4gICAgLy8gVGhlIHJvdGF0aW9uYWwgbGltaXQgYW5kIG1vdG9yIGluZm9ybWF0aW9uIG9mIHRoZSBqb2ludC5cbiAgICB0aGlzLmxpbWl0TW90b3IgPSBuZXcgTGltaXRNb3RvciggdGhpcy5ub3IsIGZhbHNlICk7XG4gICAgdGhpcy5saW1pdE1vdG9yLmxvd2VyTGltaXQgPSBsb3dlckFuZ2xlTGltaXQ7XG4gICAgdGhpcy5saW1pdE1vdG9yLnVwcGVyTGltaXQgPSB1cHBlckFuZ2xlTGltaXQ7XG5cbiAgICB0aGlzLmxjID0gbmV3IExpbmVhckNvbnN0cmFpbnQoIHRoaXMgKTtcbiAgICB0aGlzLnIzID0gbmV3IFJvdGF0aW9uYWwzQ29uc3RyYWludCggdGhpcywgdGhpcy5saW1pdE1vdG9yLCBuZXcgTGltaXRNb3RvciggdGhpcy50YW4sIHRydWUgKSwgbmV3IExpbWl0TW90b3IoIHRoaXMuYmluLCB0cnVlICkgKTtcbn1cblxuSGluZ2VKb2ludC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBKb2ludC5wcm90b3R5cGUgKSwge1xuXG4gICAgY29uc3RydWN0b3I6IEhpbmdlSm9pbnQsXG5cblxuICAgIHByZVNvbHZlOiBmdW5jdGlvbiAoIHRpbWVTdGVwLCBpbnZUaW1lU3RlcCApIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZUFuY2hvclBvaW50cygpO1xuXG4gICAgICAgIHRoaXMuYXgxLmNvcHkoIHRoaXMubG9jYWxBeGlzMSApLmFwcGx5TWF0cml4MyggdGhpcy5ib2R5MS5yb3RhdGlvbiwgdHJ1ZSApO1xuICAgICAgICB0aGlzLmF4Mi5jb3B5KCB0aGlzLmxvY2FsQXhpczIgKS5hcHBseU1hdHJpeDMoIHRoaXMuYm9keTIucm90YXRpb24sIHRydWUgKTtcblxuICAgICAgICB0aGlzLmFuMS5jb3B5KCB0aGlzLmxvY2FsQW5nbGUxICkuYXBwbHlNYXRyaXgzKCB0aGlzLmJvZHkxLnJvdGF0aW9uLCB0cnVlICk7XG4gICAgICAgIHRoaXMuYW4yLmNvcHkoIHRoaXMubG9jYWxBbmdsZTIgKS5hcHBseU1hdHJpeDMoIHRoaXMuYm9keTIucm90YXRpb24sIHRydWUgKTtcblxuICAgICAgICAvLyBub3JtYWwgdGFuZ2VudCBiaW5vcm1hbFxuXG4gICAgICAgIHRoaXMubm9yLnNldChcbiAgICAgICAgICAgIHRoaXMuYXgxLngqdGhpcy5ib2R5Mi5pbnZlcnNlTWFzcyArIHRoaXMuYXgyLngqdGhpcy5ib2R5MS5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgIHRoaXMuYXgxLnkqdGhpcy5ib2R5Mi5pbnZlcnNlTWFzcyArIHRoaXMuYXgyLnkqdGhpcy5ib2R5MS5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgIHRoaXMuYXgxLnoqdGhpcy5ib2R5Mi5pbnZlcnNlTWFzcyArIHRoaXMuYXgyLnoqdGhpcy5ib2R5MS5pbnZlcnNlTWFzc1xuICAgICAgICApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMudGFuLnRhbmdlbnQoIHRoaXMubm9yICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5iaW4uY3Jvc3NWZWN0b3JzKCB0aGlzLm5vciwgdGhpcy50YW4gKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgaGluZ2UgYW5nbGVcblxuICAgICAgICB2YXIgbGltaXRlID0gX01hdGguYWNvc0NsYW1wKCBfTWF0aC5kb3RWZWN0b3JzKCB0aGlzLmFuMSwgdGhpcy5hbjIgKSApO1xuXG4gICAgICAgIHRoaXMudG1wLmNyb3NzVmVjdG9ycyggdGhpcy5hbjEsIHRoaXMuYW4yICk7XG5cbiAgICAgICAgaWYoIF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMubm9yLCB0aGlzLnRtcCApIDwgMCApIHRoaXMubGltaXRNb3Rvci5hbmdsZSA9IC1saW1pdGU7XG4gICAgICAgIGVsc2UgdGhpcy5saW1pdE1vdG9yLmFuZ2xlID0gbGltaXRlO1xuXG4gICAgICAgIHRoaXMudG1wLmNyb3NzVmVjdG9ycyggdGhpcy5heDEsIHRoaXMuYXgyICk7XG5cbiAgICAgICAgdGhpcy5yMy5saW1pdE1vdG9yMi5hbmdsZSA9IF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMudGFuLCB0aGlzLnRtcCApO1xuICAgICAgICB0aGlzLnIzLmxpbWl0TW90b3IzLmFuZ2xlID0gX01hdGguZG90VmVjdG9ycyggdGhpcy5iaW4sIHRoaXMudG1wICk7XG5cbiAgICAgICAgLy8gcHJlU29sdmVcbiAgICAgICAgXG4gICAgICAgIHRoaXMucjMucHJlU29sdmUoIHRpbWVTdGVwLCBpbnZUaW1lU3RlcCApO1xuICAgICAgICB0aGlzLmxjLnByZVNvbHZlKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKTtcblxuICAgIH0sXG5cbiAgICBzb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMucjMuc29sdmUoKTtcbiAgICAgICAgdGhpcy5sYy5zb2x2ZSgpO1xuXG4gICAgfSxcblxuICAgIHBvc3RTb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBBIGJhbGwtYW5kLXNvY2tldCBqb2ludCBsaW1pdHMgcmVsYXRpdmUgdHJhbnNsYXRpb24gb24gdHdvIGFuY2hvciBwb2ludHMgb24gcmlnaWQgYm9kaWVzLlxuICpcbiAqIEBhdXRob3Igc2FoYXJhblxuICogQGF1dGhvciBsby10aFxuICovXG5cbmZ1bmN0aW9uIEJhbGxBbmRTb2NrZXRKb2ludCAoIGNvbmZpZyApe1xuXG4gICAgSm9pbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cbiAgICB0aGlzLnR5cGUgPSBKT0lOVF9CQUxMX0FORF9TT0NLRVQ7XG4gICAgXG4gICAgdGhpcy5sYyA9IG5ldyBMaW5lYXJDb25zdHJhaW50KCB0aGlzICk7XG5cbn1cblxuQmFsbEFuZFNvY2tldEpvaW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEpvaW50LnByb3RvdHlwZSApLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogQmFsbEFuZFNvY2tldEpvaW50LFxuXG4gICAgcHJlU29sdmU6IGZ1bmN0aW9uICggdGltZVN0ZXAsIGludlRpbWVTdGVwICkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlQW5jaG9yUG9pbnRzKCk7XG5cbiAgICAgICAgLy8gcHJlU29sdmVcblxuICAgICAgICB0aGlzLmxjLnByZVNvbHZlKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKTtcblxuICAgIH0sXG5cbiAgICBzb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMubGMuc29sdmUoKTtcblxuICAgIH0sXG5cbiAgICBwb3N0U29sdmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIH1cblxufSk7XG5cbi8qKlxuKiBBIHRyYW5zbGF0aW9uYWwgY29uc3RyYWludCBmb3IgdmFyaW91cyBqb2ludHMuXG4qIEBhdXRob3Igc2FoYXJhblxuKi9cbmZ1bmN0aW9uIFRyYW5zbGF0aW9uYWxDb25zdHJhaW50ICggam9pbnQsIGxpbWl0TW90b3IgKXtcbiAgICB0aGlzLmNmbT1OYU47XG4gICAgdGhpcy5tMT1OYU47XG4gICAgdGhpcy5tMj1OYU47XG4gICAgdGhpcy5pMWUwMD1OYU47XG4gICAgdGhpcy5pMWUwMT1OYU47XG4gICAgdGhpcy5pMWUwMj1OYU47XG4gICAgdGhpcy5pMWUxMD1OYU47XG4gICAgdGhpcy5pMWUxMT1OYU47XG4gICAgdGhpcy5pMWUxMj1OYU47XG4gICAgdGhpcy5pMWUyMD1OYU47XG4gICAgdGhpcy5pMWUyMT1OYU47XG4gICAgdGhpcy5pMWUyMj1OYU47XG4gICAgdGhpcy5pMmUwMD1OYU47XG4gICAgdGhpcy5pMmUwMT1OYU47XG4gICAgdGhpcy5pMmUwMj1OYU47XG4gICAgdGhpcy5pMmUxMD1OYU47XG4gICAgdGhpcy5pMmUxMT1OYU47XG4gICAgdGhpcy5pMmUxMj1OYU47XG4gICAgdGhpcy5pMmUyMD1OYU47XG4gICAgdGhpcy5pMmUyMT1OYU47XG4gICAgdGhpcy5pMmUyMj1OYU47XG4gICAgdGhpcy5tb3RvckRlbm9tPU5hTjtcbiAgICB0aGlzLmludk1vdG9yRGVub209TmFOO1xuICAgIHRoaXMuaW52RGVub209TmFOO1xuICAgIHRoaXMuYXg9TmFOO1xuICAgIHRoaXMuYXk9TmFOO1xuICAgIHRoaXMuYXo9TmFOO1xuICAgIHRoaXMucjF4PU5hTjtcbiAgICB0aGlzLnIxeT1OYU47XG4gICAgdGhpcy5yMXo9TmFOO1xuICAgIHRoaXMucjJ4PU5hTjtcbiAgICB0aGlzLnIyeT1OYU47XG4gICAgdGhpcy5yMno9TmFOO1xuICAgIHRoaXMudDF4PU5hTjtcbiAgICB0aGlzLnQxeT1OYU47XG4gICAgdGhpcy50MXo9TmFOO1xuICAgIHRoaXMudDJ4PU5hTjtcbiAgICB0aGlzLnQyeT1OYU47XG4gICAgdGhpcy50Mno9TmFOO1xuICAgIHRoaXMubDF4PU5hTjtcbiAgICB0aGlzLmwxeT1OYU47XG4gICAgdGhpcy5sMXo9TmFOO1xuICAgIHRoaXMubDJ4PU5hTjtcbiAgICB0aGlzLmwyeT1OYU47XG4gICAgdGhpcy5sMno9TmFOO1xuICAgIHRoaXMuYTF4PU5hTjtcbiAgICB0aGlzLmExeT1OYU47XG4gICAgdGhpcy5hMXo9TmFOO1xuICAgIHRoaXMuYTJ4PU5hTjtcbiAgICB0aGlzLmEyeT1OYU47XG4gICAgdGhpcy5hMno9TmFOO1xuICAgIHRoaXMubG93ZXJMaW1pdD1OYU47XG4gICAgdGhpcy51cHBlckxpbWl0PU5hTjtcbiAgICB0aGlzLmxpbWl0VmVsb2NpdHk9TmFOO1xuICAgIHRoaXMubGltaXRTdGF0ZT0wOyAvLyAtMTogYXQgbG93ZXIsIDA6IGxvY2tlZCwgMTogYXQgdXBwZXIsIDI6IGZyZWVcbiAgICB0aGlzLmVuYWJsZU1vdG9yPWZhbHNlO1xuICAgIHRoaXMubW90b3JTcGVlZD1OYU47XG4gICAgdGhpcy5tYXhNb3RvckZvcmNlPU5hTjtcbiAgICB0aGlzLm1heE1vdG9ySW1wdWxzZT1OYU47XG5cbiAgICB0aGlzLmxpbWl0TW90b3I9bGltaXRNb3RvcjtcbiAgICB0aGlzLmIxPWpvaW50LmJvZHkxO1xuICAgIHRoaXMuYjI9am9pbnQuYm9keTI7XG4gICAgdGhpcy5wMT1qb2ludC5hbmNob3JQb2ludDE7XG4gICAgdGhpcy5wMj1qb2ludC5hbmNob3JQb2ludDI7XG4gICAgdGhpcy5yMT1qb2ludC5yZWxhdGl2ZUFuY2hvclBvaW50MTtcbiAgICB0aGlzLnIyPWpvaW50LnJlbGF0aXZlQW5jaG9yUG9pbnQyO1xuICAgIHRoaXMubDE9dGhpcy5iMS5saW5lYXJWZWxvY2l0eTtcbiAgICB0aGlzLmwyPXRoaXMuYjIubGluZWFyVmVsb2NpdHk7XG4gICAgdGhpcy5hMT10aGlzLmIxLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmEyPXRoaXMuYjIuYW5ndWxhclZlbG9jaXR5O1xuICAgIHRoaXMuaTE9dGhpcy5iMS5pbnZlcnNlSW5lcnRpYTtcbiAgICB0aGlzLmkyPXRoaXMuYjIuaW52ZXJzZUluZXJ0aWE7XG4gICAgdGhpcy5saW1pdEltcHVsc2U9MDtcbiAgICB0aGlzLm1vdG9ySW1wdWxzZT0wO1xufVxuXG5PYmplY3QuYXNzaWduKCBUcmFuc2xhdGlvbmFsQ29uc3RyYWludC5wcm90b3R5cGUsIHtcblxuICAgIFRyYW5zbGF0aW9uYWxDb25zdHJhaW50OiB0cnVlLFxuXG4gICAgcHJlU29sdmU6ZnVuY3Rpb24odGltZVN0ZXAsaW52VGltZVN0ZXApe1xuICAgICAgICB0aGlzLmF4PXRoaXMubGltaXRNb3Rvci5heGlzLng7XG4gICAgICAgIHRoaXMuYXk9dGhpcy5saW1pdE1vdG9yLmF4aXMueTtcbiAgICAgICAgdGhpcy5hej10aGlzLmxpbWl0TW90b3IuYXhpcy56O1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQ9dGhpcy5saW1pdE1vdG9yLmxvd2VyTGltaXQ7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdD10aGlzLmxpbWl0TW90b3IudXBwZXJMaW1pdDtcbiAgICAgICAgdGhpcy5tb3RvclNwZWVkPXRoaXMubGltaXRNb3Rvci5tb3RvclNwZWVkO1xuICAgICAgICB0aGlzLm1heE1vdG9yRm9yY2U9dGhpcy5saW1pdE1vdG9yLm1heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMuZW5hYmxlTW90b3I9dGhpcy5tYXhNb3RvckZvcmNlPjA7XG4gICAgICAgIHRoaXMubTE9dGhpcy5iMS5pbnZlcnNlTWFzcztcbiAgICAgICAgdGhpcy5tMj10aGlzLmIyLmludmVyc2VNYXNzO1xuXG4gICAgICAgIHZhciB0aTEgPSB0aGlzLmkxLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdGkyID0gdGhpcy5pMi5lbGVtZW50cztcbiAgICAgICAgdGhpcy5pMWUwMD10aTFbMF07XG4gICAgICAgIHRoaXMuaTFlMDE9dGkxWzFdO1xuICAgICAgICB0aGlzLmkxZTAyPXRpMVsyXTtcbiAgICAgICAgdGhpcy5pMWUxMD10aTFbM107XG4gICAgICAgIHRoaXMuaTFlMTE9dGkxWzRdO1xuICAgICAgICB0aGlzLmkxZTEyPXRpMVs1XTtcbiAgICAgICAgdGhpcy5pMWUyMD10aTFbNl07XG4gICAgICAgIHRoaXMuaTFlMjE9dGkxWzddO1xuICAgICAgICB0aGlzLmkxZTIyPXRpMVs4XTtcblxuICAgICAgICB0aGlzLmkyZTAwPXRpMlswXTtcbiAgICAgICAgdGhpcy5pMmUwMT10aTJbMV07XG4gICAgICAgIHRoaXMuaTJlMDI9dGkyWzJdO1xuICAgICAgICB0aGlzLmkyZTEwPXRpMlszXTtcbiAgICAgICAgdGhpcy5pMmUxMT10aTJbNF07XG4gICAgICAgIHRoaXMuaTJlMTI9dGkyWzVdO1xuICAgICAgICB0aGlzLmkyZTIwPXRpMls2XTtcbiAgICAgICAgdGhpcy5pMmUyMT10aTJbN107XG4gICAgICAgIHRoaXMuaTJlMjI9dGkyWzhdO1xuXG4gICAgICAgIHZhciBkeD10aGlzLnAyLngtdGhpcy5wMS54O1xuICAgICAgICB2YXIgZHk9dGhpcy5wMi55LXRoaXMucDEueTtcbiAgICAgICAgdmFyIGR6PXRoaXMucDIuei10aGlzLnAxLno7XG4gICAgICAgIHZhciBkPWR4KnRoaXMuYXgrZHkqdGhpcy5heStkeip0aGlzLmF6O1xuICAgICAgICB2YXIgZnJlcXVlbmN5PXRoaXMubGltaXRNb3Rvci5mcmVxdWVuY3k7XG4gICAgICAgIHZhciBlbmFibGVTcHJpbmc9ZnJlcXVlbmN5PjA7XG4gICAgICAgIHZhciBlbmFibGVMaW1pdD10aGlzLmxvd2VyTGltaXQ8PXRoaXMudXBwZXJMaW1pdDtcbiAgICAgICAgaWYoZW5hYmxlU3ByaW5nJiZkPjIwfHxkPC0yMCl7XG4gICAgICAgICAgICBlbmFibGVTcHJpbmc9ZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbmFibGVMaW1pdCl7XG4gICAgICAgICAgICBpZih0aGlzLmxvd2VyTGltaXQ9PXRoaXMudXBwZXJMaW1pdCl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlIT0wKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlPTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eT10aGlzLmxvd2VyTGltaXQtZDtcbiAgICAgICAgICAgICAgICBpZighZW5hYmxlU3ByaW5nKWQ9dGhpcy5sb3dlckxpbWl0O1xuICAgICAgICAgICAgfWVsc2UgaWYoZDx0aGlzLmxvd2VyTGltaXQpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZSE9LTEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGU9LTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eT10aGlzLmxvd2VyTGltaXQtZDtcbiAgICAgICAgICAgICAgICBpZighZW5hYmxlU3ByaW5nKWQ9dGhpcy5sb3dlckxpbWl0O1xuICAgICAgICAgICAgfWVsc2UgaWYoZD50aGlzLnVwcGVyTGltaXQpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZSE9MSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZT0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZT0wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHk9dGhpcy51cHBlckxpbWl0LWQ7XG4gICAgICAgICAgICAgICAgaWYoIWVuYWJsZVNwcmluZylkPXRoaXMudXBwZXJMaW1pdDtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZT0yO1xuICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlPTA7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5PTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighZW5hYmxlU3ByaW5nKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0VmVsb2NpdHk+MC4wMDUpdGhpcy5saW1pdFZlbG9jaXR5LT0wLjAwNTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMubGltaXRWZWxvY2l0eTwtMC4wMDUpdGhpcy5saW1pdFZlbG9jaXR5Kz0wLjAwNTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMubGltaXRWZWxvY2l0eT0wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZT0yO1xuICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2U9MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlTW90b3ImJih0aGlzLmxpbWl0U3RhdGUhPTB8fGVuYWJsZVNwcmluZykpe1xuICAgICAgICAgICAgdGhpcy5tYXhNb3RvckltcHVsc2U9dGhpcy5tYXhNb3RvckZvcmNlKnRpbWVTdGVwO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlPTA7XG4gICAgICAgICAgICB0aGlzLm1heE1vdG9ySW1wdWxzZT0wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJkeD1kKnRoaXMuYXg7XG4gICAgICAgIHZhciByZHk9ZCp0aGlzLmF5O1xuICAgICAgICB2YXIgcmR6PWQqdGhpcy5hejtcbiAgICAgICAgdmFyIHcxPXRoaXMubTEvKHRoaXMubTErdGhpcy5tMik7XG4gICAgICAgIHZhciB3Mj0xLXcxO1xuICAgICAgICB0aGlzLnIxeD10aGlzLnIxLngrcmR4KncxO1xuICAgICAgICB0aGlzLnIxeT10aGlzLnIxLnkrcmR5KncxO1xuICAgICAgICB0aGlzLnIxej10aGlzLnIxLnorcmR6KncxO1xuICAgICAgICB0aGlzLnIyeD10aGlzLnIyLngtcmR4KncyO1xuICAgICAgICB0aGlzLnIyeT10aGlzLnIyLnktcmR5KncyO1xuICAgICAgICB0aGlzLnIyej10aGlzLnIyLnotcmR6KncyO1xuXG4gICAgICAgIHRoaXMudDF4PXRoaXMucjF5KnRoaXMuYXotdGhpcy5yMXoqdGhpcy5heTtcbiAgICAgICAgdGhpcy50MXk9dGhpcy5yMXoqdGhpcy5heC10aGlzLnIxeCp0aGlzLmF6O1xuICAgICAgICB0aGlzLnQxej10aGlzLnIxeCp0aGlzLmF5LXRoaXMucjF5KnRoaXMuYXg7XG4gICAgICAgIHRoaXMudDJ4PXRoaXMucjJ5KnRoaXMuYXotdGhpcy5yMnoqdGhpcy5heTtcbiAgICAgICAgdGhpcy50Mnk9dGhpcy5yMnoqdGhpcy5heC10aGlzLnIyeCp0aGlzLmF6O1xuICAgICAgICB0aGlzLnQyej10aGlzLnIyeCp0aGlzLmF5LXRoaXMucjJ5KnRoaXMuYXg7XG4gICAgICAgIHRoaXMubDF4PXRoaXMuYXgqdGhpcy5tMTtcbiAgICAgICAgdGhpcy5sMXk9dGhpcy5heSp0aGlzLm0xO1xuICAgICAgICB0aGlzLmwxej10aGlzLmF6KnRoaXMubTE7XG4gICAgICAgIHRoaXMubDJ4PXRoaXMuYXgqdGhpcy5tMjtcbiAgICAgICAgdGhpcy5sMnk9dGhpcy5heSp0aGlzLm0yO1xuICAgICAgICB0aGlzLmwyej10aGlzLmF6KnRoaXMubTI7XG4gICAgICAgIHRoaXMuYTF4PXRoaXMudDF4KnRoaXMuaTFlMDArdGhpcy50MXkqdGhpcy5pMWUwMSt0aGlzLnQxeip0aGlzLmkxZTAyO1xuICAgICAgICB0aGlzLmExeT10aGlzLnQxeCp0aGlzLmkxZTEwK3RoaXMudDF5KnRoaXMuaTFlMTErdGhpcy50MXoqdGhpcy5pMWUxMjtcbiAgICAgICAgdGhpcy5hMXo9dGhpcy50MXgqdGhpcy5pMWUyMCt0aGlzLnQxeSp0aGlzLmkxZTIxK3RoaXMudDF6KnRoaXMuaTFlMjI7XG4gICAgICAgIHRoaXMuYTJ4PXRoaXMudDJ4KnRoaXMuaTJlMDArdGhpcy50MnkqdGhpcy5pMmUwMSt0aGlzLnQyeip0aGlzLmkyZTAyO1xuICAgICAgICB0aGlzLmEyeT10aGlzLnQyeCp0aGlzLmkyZTEwK3RoaXMudDJ5KnRoaXMuaTJlMTErdGhpcy50MnoqdGhpcy5pMmUxMjtcbiAgICAgICAgdGhpcy5hMno9dGhpcy50MngqdGhpcy5pMmUyMCt0aGlzLnQyeSp0aGlzLmkyZTIxK3RoaXMudDJ6KnRoaXMuaTJlMjI7XG4gICAgICAgIHRoaXMubW90b3JEZW5vbT1cbiAgICAgICAgdGhpcy5tMSt0aGlzLm0yK1xuICAgICAgICAgICAgdGhpcy5heCoodGhpcy5hMXkqdGhpcy5yMXotdGhpcy5hMXoqdGhpcy5yMXkrdGhpcy5hMnkqdGhpcy5yMnotdGhpcy5hMnoqdGhpcy5yMnkpK1xuICAgICAgICAgICAgdGhpcy5heSoodGhpcy5hMXoqdGhpcy5yMXgtdGhpcy5hMXgqdGhpcy5yMXordGhpcy5hMnoqdGhpcy5yMngtdGhpcy5hMngqdGhpcy5yMnopK1xuICAgICAgICAgICAgdGhpcy5heioodGhpcy5hMXgqdGhpcy5yMXktdGhpcy5hMXkqdGhpcy5yMXgrdGhpcy5hMngqdGhpcy5yMnktdGhpcy5hMnkqdGhpcy5yMngpO1xuXG4gICAgICAgIHRoaXMuaW52TW90b3JEZW5vbT0xL3RoaXMubW90b3JEZW5vbTtcblxuICAgICAgICBpZihlbmFibGVTcHJpbmcmJnRoaXMubGltaXRTdGF0ZSE9Mil7XG4gICAgICAgICAgICB2YXIgb21lZ2E9Ni4yODMxODUzKmZyZXF1ZW5jeTtcbiAgICAgICAgICAgIHZhciBrPW9tZWdhKm9tZWdhKnRpbWVTdGVwO1xuICAgICAgICAgICAgdmFyIGRtcD1pbnZUaW1lU3RlcC8oaysyKnRoaXMubGltaXRNb3Rvci5kYW1waW5nUmF0aW8qb21lZ2EpO1xuICAgICAgICAgICAgdGhpcy5jZm09dGhpcy5tb3RvckRlbm9tKmRtcDtcbiAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eSo9aypkbXA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5jZm09MDtcbiAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eSo9aW52VGltZVN0ZXAqMC4wNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW52RGVub209MS8odGhpcy5tb3RvckRlbm9tK3RoaXMuY2ZtKTtcblxuICAgICAgICB2YXIgdG90YWxJbXB1bHNlPXRoaXMubGltaXRJbXB1bHNlK3RoaXMubW90b3JJbXB1bHNlO1xuICAgICAgICB0aGlzLmwxLngrPXRvdGFsSW1wdWxzZSp0aGlzLmwxeDtcbiAgICAgICAgdGhpcy5sMS55Kz10b3RhbEltcHVsc2UqdGhpcy5sMXk7XG4gICAgICAgIHRoaXMubDEueis9dG90YWxJbXB1bHNlKnRoaXMubDF6O1xuICAgICAgICB0aGlzLmExLngrPXRvdGFsSW1wdWxzZSp0aGlzLmExeDtcbiAgICAgICAgdGhpcy5hMS55Kz10b3RhbEltcHVsc2UqdGhpcy5hMXk7XG4gICAgICAgIHRoaXMuYTEueis9dG90YWxJbXB1bHNlKnRoaXMuYTF6O1xuICAgICAgICB0aGlzLmwyLngtPXRvdGFsSW1wdWxzZSp0aGlzLmwyeDtcbiAgICAgICAgdGhpcy5sMi55LT10b3RhbEltcHVsc2UqdGhpcy5sMnk7XG4gICAgICAgIHRoaXMubDIuei09dG90YWxJbXB1bHNlKnRoaXMubDJ6O1xuICAgICAgICB0aGlzLmEyLngtPXRvdGFsSW1wdWxzZSp0aGlzLmEyeDtcbiAgICAgICAgdGhpcy5hMi55LT10b3RhbEltcHVsc2UqdGhpcy5hMnk7XG4gICAgICAgIHRoaXMuYTIuei09dG90YWxJbXB1bHNlKnRoaXMuYTJ6O1xuICAgIH0sXG4gICAgc29sdmU6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJ2bj1cbiAgICAgICAgICAgIHRoaXMuYXgqKHRoaXMubDIueC10aGlzLmwxLngpK3RoaXMuYXkqKHRoaXMubDIueS10aGlzLmwxLnkpK3RoaXMuYXoqKHRoaXMubDIuei10aGlzLmwxLnopK1xuICAgICAgICAgICAgdGhpcy50MngqdGhpcy5hMi54LXRoaXMudDF4KnRoaXMuYTEueCt0aGlzLnQyeSp0aGlzLmEyLnktdGhpcy50MXkqdGhpcy5hMS55K3RoaXMudDJ6KnRoaXMuYTIuei10aGlzLnQxeip0aGlzLmExLno7XG5cbiAgICAgICAgLy8gbW90b3IgcGFydFxuICAgICAgICB2YXIgbmV3TW90b3JJbXB1bHNlO1xuICAgICAgICBpZih0aGlzLmVuYWJsZU1vdG9yKXtcbiAgICAgICAgICAgIG5ld01vdG9ySW1wdWxzZT0ocnZuLXRoaXMubW90b3JTcGVlZCkqdGhpcy5pbnZNb3RvckRlbm9tO1xuICAgICAgICAgICAgdmFyIG9sZE1vdG9ySW1wdWxzZT10aGlzLm1vdG9ySW1wdWxzZTtcbiAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlKz1uZXdNb3RvckltcHVsc2U7XG4gICAgICAgICAgICBpZih0aGlzLm1vdG9ySW1wdWxzZT50aGlzLm1heE1vdG9ySW1wdWxzZSl0aGlzLm1vdG9ySW1wdWxzZT10aGlzLm1heE1vdG9ySW1wdWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5tb3RvckltcHVsc2U8LXRoaXMubWF4TW90b3JJbXB1bHNlKXRoaXMubW90b3JJbXB1bHNlPS10aGlzLm1heE1vdG9ySW1wdWxzZTtcbiAgICAgICAgICAgIG5ld01vdG9ySW1wdWxzZT10aGlzLm1vdG9ySW1wdWxzZS1vbGRNb3RvckltcHVsc2U7XG4gICAgICAgICAgICBydm4tPW5ld01vdG9ySW1wdWxzZSp0aGlzLm1vdG9yRGVub207XG4gICAgICAgIH1lbHNlIG5ld01vdG9ySW1wdWxzZT0wO1xuXG4gICAgICAgIC8vIGxpbWl0IHBhcnRcbiAgICAgICAgdmFyIG5ld0xpbWl0SW1wdWxzZTtcbiAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlIT0yKXtcbiAgICAgICAgICAgIG5ld0xpbWl0SW1wdWxzZT0ocnZuLXRoaXMubGltaXRWZWxvY2l0eS10aGlzLmxpbWl0SW1wdWxzZSp0aGlzLmNmbSkqdGhpcy5pbnZEZW5vbTtcbiAgICAgICAgICAgIHZhciBvbGRMaW1pdEltcHVsc2U9dGhpcy5saW1pdEltcHVsc2U7XG4gICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZSs9bmV3TGltaXRJbXB1bHNlO1xuICAgICAgICAgICAgaWYodGhpcy5saW1pdEltcHVsc2UqdGhpcy5saW1pdFN0YXRlPDApdGhpcy5saW1pdEltcHVsc2U9MDtcbiAgICAgICAgICAgIG5ld0xpbWl0SW1wdWxzZT10aGlzLmxpbWl0SW1wdWxzZS1vbGRMaW1pdEltcHVsc2U7XG4gICAgICAgIH1lbHNlIG5ld0xpbWl0SW1wdWxzZT0wO1xuICAgICAgICBcbiAgICAgICAgdmFyIHRvdGFsSW1wdWxzZT1uZXdMaW1pdEltcHVsc2UrbmV3TW90b3JJbXB1bHNlO1xuICAgICAgICB0aGlzLmwxLngrPXRvdGFsSW1wdWxzZSp0aGlzLmwxeDtcbiAgICAgICAgdGhpcy5sMS55Kz10b3RhbEltcHVsc2UqdGhpcy5sMXk7XG4gICAgICAgIHRoaXMubDEueis9dG90YWxJbXB1bHNlKnRoaXMubDF6O1xuICAgICAgICB0aGlzLmExLngrPXRvdGFsSW1wdWxzZSp0aGlzLmExeDtcbiAgICAgICAgdGhpcy5hMS55Kz10b3RhbEltcHVsc2UqdGhpcy5hMXk7XG4gICAgICAgIHRoaXMuYTEueis9dG90YWxJbXB1bHNlKnRoaXMuYTF6O1xuICAgICAgICB0aGlzLmwyLngtPXRvdGFsSW1wdWxzZSp0aGlzLmwyeDtcbiAgICAgICAgdGhpcy5sMi55LT10b3RhbEltcHVsc2UqdGhpcy5sMnk7XG4gICAgICAgIHRoaXMubDIuei09dG90YWxJbXB1bHNlKnRoaXMubDJ6O1xuICAgICAgICB0aGlzLmEyLngtPXRvdGFsSW1wdWxzZSp0aGlzLmEyeDtcbiAgICAgICAgdGhpcy5hMi55LT10b3RhbEltcHVsc2UqdGhpcy5hMnk7XG4gICAgICAgIHRoaXMuYTIuei09dG90YWxJbXB1bHNlKnRoaXMuYTJ6O1xuICAgIH1cbn0gKTtcblxuLyoqXG4gKiBBIGRpc3RhbmNlIGpvaW50IGxpbWl0cyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gYW5jaG9yIHBvaW50cyBvbiByaWdpZCBib2RpZXMuXG4gKlxuICogQGF1dGhvciBzYWhhcmFuXG4gKiBAYXV0aG9yIGxvLXRoXG4gKi9cblxuZnVuY3Rpb24gRGlzdGFuY2VKb2ludCAoIGNvbmZpZywgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlICl7XG5cbiAgICBKb2ludC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuICAgIHRoaXMudHlwZSA9IEpPSU5UX0RJU1RBTkNFO1xuICAgIFxuICAgIHRoaXMubm9yID0gbmV3IFZlYzMoKTtcblxuICAgIC8vIFRoZSBsaW1pdCBhbmQgbW90b3IgaW5mb3JtYXRpb24gb2YgdGhlIGpvaW50LlxuICAgIHRoaXMubGltaXRNb3RvciA9IG5ldyBMaW1pdE1vdG9yKCB0aGlzLm5vciwgdHJ1ZSApO1xuICAgIHRoaXMubGltaXRNb3Rvci5sb3dlckxpbWl0ID0gbWluRGlzdGFuY2U7XG4gICAgdGhpcy5saW1pdE1vdG9yLnVwcGVyTGltaXQgPSBtYXhEaXN0YW5jZTtcblxuICAgIHRoaXMudCA9IG5ldyBUcmFuc2xhdGlvbmFsQ29uc3RyYWludCggdGhpcywgdGhpcy5saW1pdE1vdG9yICk7XG5cbn1cblxuRGlzdGFuY2VKb2ludC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBKb2ludC5wcm90b3R5cGUgKSwge1xuXG4gICAgY29uc3RydWN0b3I6IERpc3RhbmNlSm9pbnQsXG5cbiAgICBwcmVTb2x2ZTogZnVuY3Rpb24gKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVBbmNob3JQb2ludHMoKTtcblxuICAgICAgICB0aGlzLm5vci5zdWIoIHRoaXMuYW5jaG9yUG9pbnQyLCB0aGlzLmFuY2hvclBvaW50MSApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIC8vIHByZVNvbHZlXG5cbiAgICAgICAgdGhpcy50LnByZVNvbHZlKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKTtcblxuICAgIH0sXG5cbiAgICBzb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMudC5zb2x2ZSgpO1xuXG4gICAgfSxcblxuICAgIHBvc3RTb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgfVxuXG59KTtcblxuLyoqXG4qIEFuIGFuZ3VsYXIgY29uc3RyYWludCBmb3IgYWxsIGF4ZXMgZm9yIHZhcmlvdXMgam9pbnRzLlxuKiBAYXV0aG9yIHNhaGFyYW5cbiovXG5cbmZ1bmN0aW9uIEFuZ3VsYXJDb25zdHJhaW50KCBqb2ludCwgdGFyZ2V0T3JpZW50YXRpb24gKSB7XG5cbiAgICB0aGlzLmpvaW50ID0gam9pbnQ7XG5cbiAgICB0aGlzLnRhcmdldE9yaWVudGF0aW9uID0gbmV3IFF1YXQoKS5pbnZlcnQoIHRhcmdldE9yaWVudGF0aW9uICk7XG5cbiAgICB0aGlzLnJlbGF0aXZlT3JpZW50YXRpb24gPSBuZXcgUXVhdCgpO1xuXG4gICAgdGhpcy5paTEgPSBudWxsO1xuICAgIHRoaXMuaWkyID0gbnVsbDtcbiAgICB0aGlzLmRkID0gbnVsbDtcblxuICAgIHRoaXMudmVsID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmltcCA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLnJuMCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5ybjEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMucm4yID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMuYjEgPSBqb2ludC5ib2R5MTtcbiAgICB0aGlzLmIyID0gam9pbnQuYm9keTI7XG4gICAgdGhpcy5hMSA9IHRoaXMuYjEuYW5ndWxhclZlbG9jaXR5O1xuICAgIHRoaXMuYTIgPSB0aGlzLmIyLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmkxID0gdGhpcy5iMS5pbnZlcnNlSW5lcnRpYTtcbiAgICB0aGlzLmkyID0gdGhpcy5iMi5pbnZlcnNlSW5lcnRpYTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBBbmd1bGFyQ29uc3RyYWludC5wcm90b3R5cGUsIHtcblxuICAgIEFuZ3VsYXJDb25zdHJhaW50OiB0cnVlLFxuXG4gICAgcHJlU29sdmU6IGZ1bmN0aW9uICggdGltZVN0ZXAsIGludlRpbWVTdGVwICkge1xuXG4gICAgICAgIHZhciBpbnYsIGxlbiwgdjtcblxuICAgICAgICB0aGlzLmlpMSA9IHRoaXMuaTEuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5paTIgPSB0aGlzLmkyLmNsb25lKCk7XG5cbiAgICAgICAgdiA9IG5ldyBNYXQzMygpLmFkZCh0aGlzLmlpMSwgdGhpcy5paTIpLmVsZW1lbnRzO1xuICAgICAgICBpbnYgPSAxLyggdlswXSoodls0XSp2WzhdLXZbN10qdls1XSkgICsgIHZbM10qKHZbN10qdlsyXS12WzFdKnZbOF0pICArICB2WzZdKih2WzFdKnZbNV0tdls0XSp2WzJdKSApO1xuICAgICAgICB0aGlzLmRkID0gbmV3IE1hdDMzKCkuc2V0KFxuICAgICAgICAgICAgdls0XSp2WzhdLXZbNV0qdls3XSwgdlsyXSp2WzddLXZbMV0qdls4XSwgdlsxXSp2WzVdLXZbMl0qdls0XSxcbiAgICAgICAgICAgIHZbNV0qdls2XS12WzNdKnZbOF0sIHZbMF0qdls4XS12WzJdKnZbNl0sIHZbMl0qdlszXS12WzBdKnZbNV0sXG4gICAgICAgICAgICB2WzNdKnZbN10tdls0XSp2WzZdLCB2WzFdKnZbNl0tdlswXSp2WzddLCB2WzBdKnZbNF0tdlsxXSp2WzNdXG4gICAgICAgICkubXVsdGlwbHlTY2FsYXIoIGludiApO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9yaWVudGF0aW9uLmludmVydCggdGhpcy5iMS5vcmllbnRhdGlvbiApLm11bHRpcGx5KCB0aGlzLnRhcmdldE9yaWVudGF0aW9uICkubXVsdGlwbHkoIHRoaXMuYjIub3JpZW50YXRpb24gKTtcblxuICAgICAgICBpbnYgPSB0aGlzLnJlbGF0aXZlT3JpZW50YXRpb24udyoyO1xuXG4gICAgICAgIHRoaXMudmVsLmNvcHkoIHRoaXMucmVsYXRpdmVPcmllbnRhdGlvbiApLm11bHRpcGx5U2NhbGFyKCBpbnYgKTtcblxuICAgICAgICBsZW4gPSB0aGlzLnZlbC5sZW5ndGgoKTtcblxuICAgICAgICBpZiggbGVuID4gMC4wMiApIHtcbiAgICAgICAgICAgIGxlbiA9ICgwLjAyLWxlbikvbGVuKmludlRpbWVTdGVwKjAuMDU7XG4gICAgICAgICAgICB0aGlzLnZlbC5tdWx0aXBseVNjYWxhciggbGVuICk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy52ZWwuc2V0KDAsMCwwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucm4xLmNvcHkoIHRoaXMuaW1wICkuYXBwbHlNYXRyaXgzKCB0aGlzLmlpMSwgdHJ1ZSApO1xuICAgICAgICB0aGlzLnJuMi5jb3B5KCB0aGlzLmltcCApLmFwcGx5TWF0cml4MyggdGhpcy5paTIsIHRydWUgKTtcblxuICAgICAgICB0aGlzLmExLmFkZCggdGhpcy5ybjEgKTtcbiAgICAgICAgdGhpcy5hMi5zdWIoIHRoaXMucm4yICk7XG5cbiAgICB9LFxuXG4gICAgc29sdmU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgciA9IHRoaXMuYTIuY2xvbmUoKS5zdWIoIHRoaXMuYTEgKS5zdWIoIHRoaXMudmVsICk7XG5cbiAgICAgICAgdGhpcy5ybjAuY29weSggciApLmFwcGx5TWF0cml4MyggdGhpcy5kZCwgdHJ1ZSApO1xuICAgICAgICB0aGlzLnJuMS5jb3B5KCB0aGlzLnJuMCApLmFwcGx5TWF0cml4MyggdGhpcy5paTEsIHRydWUgKTtcbiAgICAgICAgdGhpcy5ybjIuY29weSggdGhpcy5ybjAgKS5hcHBseU1hdHJpeDMoIHRoaXMuaWkyLCB0cnVlICk7XG5cbiAgICAgICAgdGhpcy5pbXAuYWRkKCB0aGlzLnJuMCApO1xuICAgICAgICB0aGlzLmExLmFkZCggdGhpcy5ybjEgKTtcbiAgICAgICAgdGhpcy5hMi5zdWIoIHRoaXMucm4yICk7XG5cbiAgICB9XG5cbn0gKTtcblxuLyoqXG4qIEEgdGhyZWUtYXhpcyB0cmFuc2xhdGlvbmFsIGNvbnN0cmFpbnQgZm9yIHZhcmlvdXMgam9pbnRzLlxuKiBAYXV0aG9yIHNhaGFyYW5cbiovXG5mdW5jdGlvbiBUcmFuc2xhdGlvbmFsM0NvbnN0cmFpbnQgKGpvaW50LGxpbWl0TW90b3IxLGxpbWl0TW90b3IyLGxpbWl0TW90b3IzKXtcblxuICAgIHRoaXMubTE9TmFOO1xuICAgIHRoaXMubTI9TmFOO1xuICAgIHRoaXMuaTFlMDA9TmFOO1xuICAgIHRoaXMuaTFlMDE9TmFOO1xuICAgIHRoaXMuaTFlMDI9TmFOO1xuICAgIHRoaXMuaTFlMTA9TmFOO1xuICAgIHRoaXMuaTFlMTE9TmFOO1xuICAgIHRoaXMuaTFlMTI9TmFOO1xuICAgIHRoaXMuaTFlMjA9TmFOO1xuICAgIHRoaXMuaTFlMjE9TmFOO1xuICAgIHRoaXMuaTFlMjI9TmFOO1xuICAgIHRoaXMuaTJlMDA9TmFOO1xuICAgIHRoaXMuaTJlMDE9TmFOO1xuICAgIHRoaXMuaTJlMDI9TmFOO1xuICAgIHRoaXMuaTJlMTA9TmFOO1xuICAgIHRoaXMuaTJlMTE9TmFOO1xuICAgIHRoaXMuaTJlMTI9TmFOO1xuICAgIHRoaXMuaTJlMjA9TmFOO1xuICAgIHRoaXMuaTJlMjE9TmFOO1xuICAgIHRoaXMuaTJlMjI9TmFOO1xuICAgIHRoaXMuYXgxPU5hTjtcbiAgICB0aGlzLmF5MT1OYU47XG4gICAgdGhpcy5hejE9TmFOO1xuICAgIHRoaXMuYXgyPU5hTjtcbiAgICB0aGlzLmF5Mj1OYU47XG4gICAgdGhpcy5hejI9TmFOO1xuICAgIHRoaXMuYXgzPU5hTjtcbiAgICB0aGlzLmF5Mz1OYU47XG4gICAgdGhpcy5hejM9TmFOO1xuICAgIHRoaXMucjF4PU5hTjtcbiAgICB0aGlzLnIxeT1OYU47XG4gICAgdGhpcy5yMXo9TmFOO1xuICAgIHRoaXMucjJ4PU5hTjtcbiAgICB0aGlzLnIyeT1OYU47XG4gICAgdGhpcy5yMno9TmFOO1xuICAgIHRoaXMudDF4MT1OYU47Ly8gamFjb2JpYW5zXG4gICAgdGhpcy50MXkxPU5hTjtcbiAgICB0aGlzLnQxejE9TmFOO1xuICAgIHRoaXMudDJ4MT1OYU47XG4gICAgdGhpcy50MnkxPU5hTjtcbiAgICB0aGlzLnQyejE9TmFOO1xuICAgIHRoaXMubDF4MT1OYU47XG4gICAgdGhpcy5sMXkxPU5hTjtcbiAgICB0aGlzLmwxejE9TmFOO1xuICAgIHRoaXMubDJ4MT1OYU47XG4gICAgdGhpcy5sMnkxPU5hTjtcbiAgICB0aGlzLmwyejE9TmFOO1xuICAgIHRoaXMuYTF4MT1OYU47XG4gICAgdGhpcy5hMXkxPU5hTjtcbiAgICB0aGlzLmExejE9TmFOO1xuICAgIHRoaXMuYTJ4MT1OYU47XG4gICAgdGhpcy5hMnkxPU5hTjtcbiAgICB0aGlzLmEyejE9TmFOO1xuICAgIHRoaXMudDF4Mj1OYU47XG4gICAgdGhpcy50MXkyPU5hTjtcbiAgICB0aGlzLnQxejI9TmFOO1xuICAgIHRoaXMudDJ4Mj1OYU47XG4gICAgdGhpcy50MnkyPU5hTjtcbiAgICB0aGlzLnQyejI9TmFOO1xuICAgIHRoaXMubDF4Mj1OYU47XG4gICAgdGhpcy5sMXkyPU5hTjtcbiAgICB0aGlzLmwxejI9TmFOO1xuICAgIHRoaXMubDJ4Mj1OYU47XG4gICAgdGhpcy5sMnkyPU5hTjtcbiAgICB0aGlzLmwyejI9TmFOO1xuICAgIHRoaXMuYTF4Mj1OYU47XG4gICAgdGhpcy5hMXkyPU5hTjtcbiAgICB0aGlzLmExejI9TmFOO1xuICAgIHRoaXMuYTJ4Mj1OYU47XG4gICAgdGhpcy5hMnkyPU5hTjtcbiAgICB0aGlzLmEyejI9TmFOO1xuICAgIHRoaXMudDF4Mz1OYU47XG4gICAgdGhpcy50MXkzPU5hTjtcbiAgICB0aGlzLnQxejM9TmFOO1xuICAgIHRoaXMudDJ4Mz1OYU47XG4gICAgdGhpcy50MnkzPU5hTjtcbiAgICB0aGlzLnQyejM9TmFOO1xuICAgIHRoaXMubDF4Mz1OYU47XG4gICAgdGhpcy5sMXkzPU5hTjtcbiAgICB0aGlzLmwxejM9TmFOO1xuICAgIHRoaXMubDJ4Mz1OYU47XG4gICAgdGhpcy5sMnkzPU5hTjtcbiAgICB0aGlzLmwyejM9TmFOO1xuICAgIHRoaXMuYTF4Mz1OYU47XG4gICAgdGhpcy5hMXkzPU5hTjtcbiAgICB0aGlzLmExejM9TmFOO1xuICAgIHRoaXMuYTJ4Mz1OYU47XG4gICAgdGhpcy5hMnkzPU5hTjtcbiAgICB0aGlzLmEyejM9TmFOO1xuICAgIHRoaXMubG93ZXJMaW1pdDE9TmFOO1xuICAgIHRoaXMudXBwZXJMaW1pdDE9TmFOO1xuICAgIHRoaXMubGltaXRWZWxvY2l0eTE9TmFOO1xuICAgIHRoaXMubGltaXRTdGF0ZTE9MDsgLy8gLTE6IGF0IGxvd2VyLCAwOiBsb2NrZWQsIDE6IGF0IHVwcGVyLCAyOiB1bmxpbWl0ZWRcbiAgICB0aGlzLmVuYWJsZU1vdG9yMT1mYWxzZTtcbiAgICB0aGlzLm1vdG9yU3BlZWQxPU5hTjtcbiAgICB0aGlzLm1heE1vdG9yRm9yY2UxPU5hTjtcbiAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTE9TmFOO1xuICAgIHRoaXMubG93ZXJMaW1pdDI9TmFOO1xuICAgIHRoaXMudXBwZXJMaW1pdDI9TmFOO1xuICAgIHRoaXMubGltaXRWZWxvY2l0eTI9TmFOO1xuICAgIHRoaXMubGltaXRTdGF0ZTI9MDsgLy8gLTE6IGF0IGxvd2VyLCAwOiBsb2NrZWQsIDE6IGF0IHVwcGVyLCAyOiB1bmxpbWl0ZWRcbiAgICB0aGlzLmVuYWJsZU1vdG9yMj1mYWxzZTtcbiAgICB0aGlzLm1vdG9yU3BlZWQyPU5hTjtcbiAgICB0aGlzLm1heE1vdG9yRm9yY2UyPU5hTjtcbiAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTI9TmFOO1xuICAgIHRoaXMubG93ZXJMaW1pdDM9TmFOO1xuICAgIHRoaXMudXBwZXJMaW1pdDM9TmFOO1xuICAgIHRoaXMubGltaXRWZWxvY2l0eTM9TmFOO1xuICAgIHRoaXMubGltaXRTdGF0ZTM9MDsgLy8gLTE6IGF0IGxvd2VyLCAwOiBsb2NrZWQsIDE6IGF0IHVwcGVyLCAyOiB1bmxpbWl0ZWRcbiAgICB0aGlzLmVuYWJsZU1vdG9yMz1mYWxzZTtcbiAgICB0aGlzLm1vdG9yU3BlZWQzPU5hTjtcbiAgICB0aGlzLm1heE1vdG9yRm9yY2UzPU5hTjtcbiAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTM9TmFOO1xuICAgIHRoaXMuazAwPU5hTjsgLy8gSyA9IEoqTSpKVFxuICAgIHRoaXMuazAxPU5hTjtcbiAgICB0aGlzLmswMj1OYU47XG4gICAgdGhpcy5rMTA9TmFOO1xuICAgIHRoaXMuazExPU5hTjtcbiAgICB0aGlzLmsxMj1OYU47XG4gICAgdGhpcy5rMjA9TmFOO1xuICAgIHRoaXMuazIxPU5hTjtcbiAgICB0aGlzLmsyMj1OYU47XG4gICAgdGhpcy5rdjAwPU5hTjsgLy8gZGlhZ29uYWxzIHdpdGhvdXQgQ0ZNc1xuICAgIHRoaXMua3YxMT1OYU47XG4gICAgdGhpcy5rdjIyPU5hTjtcbiAgICB0aGlzLmR2MDA9TmFOOyAvLyAuLi5pbnZlcnRlZFxuICAgIHRoaXMuZHYxMT1OYU47XG4gICAgdGhpcy5kdjIyPU5hTjtcbiAgICB0aGlzLmQwMD1OYU47IC8vIEteLTFcbiAgICB0aGlzLmQwMT1OYU47XG4gICAgdGhpcy5kMDI9TmFOO1xuICAgIHRoaXMuZDEwPU5hTjtcbiAgICB0aGlzLmQxMT1OYU47XG4gICAgdGhpcy5kMTI9TmFOO1xuICAgIHRoaXMuZDIwPU5hTjtcbiAgICB0aGlzLmQyMT1OYU47XG4gICAgdGhpcy5kMjI9TmFOO1xuXG4gICAgdGhpcy5saW1pdE1vdG9yMT1saW1pdE1vdG9yMTtcbiAgICB0aGlzLmxpbWl0TW90b3IyPWxpbWl0TW90b3IyO1xuICAgIHRoaXMubGltaXRNb3RvcjM9bGltaXRNb3RvcjM7XG4gICAgdGhpcy5iMT1qb2ludC5ib2R5MTtcbiAgICB0aGlzLmIyPWpvaW50LmJvZHkyO1xuICAgIHRoaXMucDE9am9pbnQuYW5jaG9yUG9pbnQxO1xuICAgIHRoaXMucDI9am9pbnQuYW5jaG9yUG9pbnQyO1xuICAgIHRoaXMucjE9am9pbnQucmVsYXRpdmVBbmNob3JQb2ludDE7XG4gICAgdGhpcy5yMj1qb2ludC5yZWxhdGl2ZUFuY2hvclBvaW50MjtcbiAgICB0aGlzLmwxPXRoaXMuYjEubGluZWFyVmVsb2NpdHk7XG4gICAgdGhpcy5sMj10aGlzLmIyLmxpbmVhclZlbG9jaXR5O1xuICAgIHRoaXMuYTE9dGhpcy5iMS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdGhpcy5hMj10aGlzLmIyLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmkxPXRoaXMuYjEuaW52ZXJzZUluZXJ0aWE7XG4gICAgdGhpcy5pMj10aGlzLmIyLmludmVyc2VJbmVydGlhO1xuICAgIHRoaXMubGltaXRJbXB1bHNlMT0wO1xuICAgIHRoaXMubW90b3JJbXB1bHNlMT0wO1xuICAgIHRoaXMubGltaXRJbXB1bHNlMj0wO1xuICAgIHRoaXMubW90b3JJbXB1bHNlMj0wO1xuICAgIHRoaXMubGltaXRJbXB1bHNlMz0wO1xuICAgIHRoaXMubW90b3JJbXB1bHNlMz0wO1xuICAgIHRoaXMuY2ZtMT0wOy8vIENvbnN0cmFpbnQgRm9yY2UgTWl4aW5nXG4gICAgdGhpcy5jZm0yPTA7XG4gICAgdGhpcy5jZm0zPTA7XG4gICAgdGhpcy53ZWlnaHQ9LTE7XG59XG5cbk9iamVjdC5hc3NpZ24oIFRyYW5zbGF0aW9uYWwzQ29uc3RyYWludC5wcm90b3R5cGUsIHtcblxuICAgIFRyYW5zbGF0aW9uYWwzQ29uc3RyYWludDogdHJ1ZSxcblxuICAgIHByZVNvbHZlOmZ1bmN0aW9uKHRpbWVTdGVwLGludlRpbWVTdGVwKXtcbiAgICAgICAgdGhpcy5heDE9dGhpcy5saW1pdE1vdG9yMS5heGlzLng7XG4gICAgICAgIHRoaXMuYXkxPXRoaXMubGltaXRNb3RvcjEuYXhpcy55O1xuICAgICAgICB0aGlzLmF6MT10aGlzLmxpbWl0TW90b3IxLmF4aXMuejtcbiAgICAgICAgdGhpcy5heDI9dGhpcy5saW1pdE1vdG9yMi5heGlzLng7XG4gICAgICAgIHRoaXMuYXkyPXRoaXMubGltaXRNb3RvcjIuYXhpcy55O1xuICAgICAgICB0aGlzLmF6Mj10aGlzLmxpbWl0TW90b3IyLmF4aXMuejtcbiAgICAgICAgdGhpcy5heDM9dGhpcy5saW1pdE1vdG9yMy5heGlzLng7XG4gICAgICAgIHRoaXMuYXkzPXRoaXMubGltaXRNb3RvcjMuYXhpcy55O1xuICAgICAgICB0aGlzLmF6Mz10aGlzLmxpbWl0TW90b3IzLmF4aXMuejtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0MT10aGlzLmxpbWl0TW90b3IxLmxvd2VyTGltaXQ7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdDE9dGhpcy5saW1pdE1vdG9yMS51cHBlckxpbWl0O1xuICAgICAgICB0aGlzLm1vdG9yU3BlZWQxPXRoaXMubGltaXRNb3RvcjEubW90b3JTcGVlZDtcbiAgICAgICAgdGhpcy5tYXhNb3RvckZvcmNlMT10aGlzLmxpbWl0TW90b3IxLm1heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMuZW5hYmxlTW90b3IxPXRoaXMubWF4TW90b3JGb3JjZTE+MDtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0Mj10aGlzLmxpbWl0TW90b3IyLmxvd2VyTGltaXQ7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdDI9dGhpcy5saW1pdE1vdG9yMi51cHBlckxpbWl0O1xuICAgICAgICB0aGlzLm1vdG9yU3BlZWQyPXRoaXMubGltaXRNb3RvcjIubW90b3JTcGVlZDtcbiAgICAgICAgdGhpcy5tYXhNb3RvckZvcmNlMj10aGlzLmxpbWl0TW90b3IyLm1heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMuZW5hYmxlTW90b3IyPXRoaXMubWF4TW90b3JGb3JjZTI+MDtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0Mz10aGlzLmxpbWl0TW90b3IzLmxvd2VyTGltaXQ7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdDM9dGhpcy5saW1pdE1vdG9yMy51cHBlckxpbWl0O1xuICAgICAgICB0aGlzLm1vdG9yU3BlZWQzPXRoaXMubGltaXRNb3RvcjMubW90b3JTcGVlZDtcbiAgICAgICAgdGhpcy5tYXhNb3RvckZvcmNlMz10aGlzLmxpbWl0TW90b3IzLm1heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMuZW5hYmxlTW90b3IzPXRoaXMubWF4TW90b3JGb3JjZTM+MDtcbiAgICAgICAgdGhpcy5tMT10aGlzLmIxLmludmVyc2VNYXNzO1xuICAgICAgICB0aGlzLm0yPXRoaXMuYjIuaW52ZXJzZU1hc3M7XG5cbiAgICAgICAgdmFyIHRpMSA9IHRoaXMuaTEuZWxlbWVudHM7XG4gICAgICAgIHZhciB0aTIgPSB0aGlzLmkyLmVsZW1lbnRzO1xuICAgICAgICB0aGlzLmkxZTAwPXRpMVswXTtcbiAgICAgICAgdGhpcy5pMWUwMT10aTFbMV07XG4gICAgICAgIHRoaXMuaTFlMDI9dGkxWzJdO1xuICAgICAgICB0aGlzLmkxZTEwPXRpMVszXTtcbiAgICAgICAgdGhpcy5pMWUxMT10aTFbNF07XG4gICAgICAgIHRoaXMuaTFlMTI9dGkxWzVdO1xuICAgICAgICB0aGlzLmkxZTIwPXRpMVs2XTtcbiAgICAgICAgdGhpcy5pMWUyMT10aTFbN107XG4gICAgICAgIHRoaXMuaTFlMjI9dGkxWzhdO1xuXG4gICAgICAgIHRoaXMuaTJlMDA9dGkyWzBdO1xuICAgICAgICB0aGlzLmkyZTAxPXRpMlsxXTtcbiAgICAgICAgdGhpcy5pMmUwMj10aTJbMl07XG4gICAgICAgIHRoaXMuaTJlMTA9dGkyWzNdO1xuICAgICAgICB0aGlzLmkyZTExPXRpMls0XTtcbiAgICAgICAgdGhpcy5pMmUxMj10aTJbNV07XG4gICAgICAgIHRoaXMuaTJlMjA9dGkyWzZdO1xuICAgICAgICB0aGlzLmkyZTIxPXRpMls3XTtcbiAgICAgICAgdGhpcy5pMmUyMj10aTJbOF07XG5cbiAgICAgICAgdmFyIGR4PXRoaXMucDIueC10aGlzLnAxLng7XG4gICAgICAgIHZhciBkeT10aGlzLnAyLnktdGhpcy5wMS55O1xuICAgICAgICB2YXIgZHo9dGhpcy5wMi56LXRoaXMucDEuejtcbiAgICAgICAgdmFyIGQxPWR4KnRoaXMuYXgxK2R5KnRoaXMuYXkxK2R6KnRoaXMuYXoxO1xuICAgICAgICB2YXIgZDI9ZHgqdGhpcy5heDIrZHkqdGhpcy5heTIrZHoqdGhpcy5hejI7XG4gICAgICAgIHZhciBkMz1keCp0aGlzLmF4MytkeSp0aGlzLmF5Mytkeip0aGlzLmF6MztcbiAgICAgICAgdmFyIGZyZXF1ZW5jeTE9dGhpcy5saW1pdE1vdG9yMS5mcmVxdWVuY3k7XG4gICAgICAgIHZhciBmcmVxdWVuY3kyPXRoaXMubGltaXRNb3RvcjIuZnJlcXVlbmN5O1xuICAgICAgICB2YXIgZnJlcXVlbmN5Mz10aGlzLmxpbWl0TW90b3IzLmZyZXF1ZW5jeTtcbiAgICAgICAgdmFyIGVuYWJsZVNwcmluZzE9ZnJlcXVlbmN5MT4wO1xuICAgICAgICB2YXIgZW5hYmxlU3ByaW5nMj1mcmVxdWVuY3kyPjA7XG4gICAgICAgIHZhciBlbmFibGVTcHJpbmczPWZyZXF1ZW5jeTM+MDtcbiAgICAgICAgdmFyIGVuYWJsZUxpbWl0MT10aGlzLmxvd2VyTGltaXQxPD10aGlzLnVwcGVyTGltaXQxO1xuICAgICAgICB2YXIgZW5hYmxlTGltaXQyPXRoaXMubG93ZXJMaW1pdDI8PXRoaXMudXBwZXJMaW1pdDI7XG4gICAgICAgIHZhciBlbmFibGVMaW1pdDM9dGhpcy5sb3dlckxpbWl0Mzw9dGhpcy51cHBlckxpbWl0MztcblxuICAgICAgICAvLyBmb3Igc3RhYmlsaXR5XG4gICAgICAgIGlmKGVuYWJsZVNwcmluZzEmJmQxPjIwfHxkMTwtMjApe1xuICAgICAgICAgICAgZW5hYmxlU3ByaW5nMT1mYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZihlbmFibGVTcHJpbmcyJiZkMj4yMHx8ZDI8LTIwKXtcbiAgICAgICAgICAgIGVuYWJsZVNwcmluZzI9ZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZW5hYmxlU3ByaW5nMyYmZDM+MjB8fGQzPC0yMCl7XG4gICAgICAgICAgICBlbmFibGVTcHJpbmczPWZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZW5hYmxlTGltaXQxKXtcbiAgICAgICAgICAgIGlmKHRoaXMubG93ZXJMaW1pdDE9PXRoaXMudXBwZXJMaW1pdDEpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZTEhPTApe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUxPTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMT0wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkxPXRoaXMubG93ZXJMaW1pdDEtZDE7XG4gICAgICAgICAgICAgICAgaWYoIWVuYWJsZVNwcmluZzEpZDE9dGhpcy5sb3dlckxpbWl0MTtcbiAgICAgICAgICAgIH1lbHNlIGlmKGQxPHRoaXMubG93ZXJMaW1pdDEpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZTEhPS0xKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMT0tMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UxPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTE9dGhpcy5sb3dlckxpbWl0MS1kMTtcbiAgICAgICAgICAgICAgICBpZighZW5hYmxlU3ByaW5nMSlkMT10aGlzLmxvd2VyTGltaXQxO1xuICAgICAgICAgICAgfWVsc2UgaWYoZDE+dGhpcy51cHBlckxpbWl0MSl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMSE9MSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTE9MTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UxPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTE9dGhpcy51cHBlckxpbWl0MS1kMTtcbiAgICAgICAgICAgICAgICBpZighZW5hYmxlU3ByaW5nMSlkMT10aGlzLnVwcGVyTGltaXQxO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMT0yO1xuICAgICAgICAgICAgICAgIHRoaXMubGltaXRJbXB1bHNlMT0wO1xuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTE9MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFlbmFibGVTcHJpbmcxKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0VmVsb2NpdHkxPjAuMDA1KXRoaXMubGltaXRWZWxvY2l0eTEtPTAuMDA1O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5saW1pdFZlbG9jaXR5MTwtMC4wMDUpdGhpcy5saW1pdFZlbG9jaXR5MSs9MC4wMDU7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLmxpbWl0VmVsb2NpdHkxPTA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMT0yO1xuICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UxPTA7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbmFibGVMaW1pdDIpe1xuICAgICAgICAgICAgaWYodGhpcy5sb3dlckxpbWl0Mj09dGhpcy51cHBlckxpbWl0Mil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMiE9MCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRTdGF0ZTI9MDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyPTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTI9dGhpcy5sb3dlckxpbWl0Mi1kMjtcbiAgICAgICAgICAgICAgICBpZighZW5hYmxlU3ByaW5nMilkMj10aGlzLmxvd2VyTGltaXQyO1xuICAgICAgICAgICAgfWVsc2UgaWYoZDI8dGhpcy5sb3dlckxpbWl0Mil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMiE9LTEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUyPS0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTI9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mj10aGlzLmxvd2VyTGltaXQyLWQyO1xuICAgICAgICAgICAgICAgIGlmKCFlbmFibGVTcHJpbmcyKWQyPXRoaXMubG93ZXJMaW1pdDI7XG4gICAgICAgICAgICB9ZWxzZSBpZihkMj50aGlzLnVwcGVyTGltaXQyKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUyIT0xKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMj0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTI9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mj10aGlzLnVwcGVyTGltaXQyLWQyO1xuICAgICAgICAgICAgICAgIGlmKCFlbmFibGVTcHJpbmcyKWQyPXRoaXMudXBwZXJMaW1pdDI7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUyPTI7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyPTA7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mj0wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWVuYWJsZVNwcmluZzIpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRWZWxvY2l0eTI+MC4wMDUpdGhpcy5saW1pdFZlbG9jaXR5Mi09MC4wMDU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZih0aGlzLmxpbWl0VmVsb2NpdHkyPC0wLjAwNSl0aGlzLmxpbWl0VmVsb2NpdHkyKz0wLjAwNTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMubGltaXRWZWxvY2l0eTI9MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUyPTI7XG4gICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTI9MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVuYWJsZUxpbWl0Myl7XG4gICAgICAgICAgICBpZih0aGlzLmxvd2VyTGltaXQzPT10aGlzLnVwcGVyTGltaXQzKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUzIT0wKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMz0wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTM9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mz10aGlzLmxvd2VyTGltaXQzLWQzO1xuICAgICAgICAgICAgICAgIGlmKCFlbmFibGVTcHJpbmczKWQzPXRoaXMubG93ZXJMaW1pdDM7XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoZDM8dGhpcy5sb3dlckxpbWl0Myl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMyE9LTEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUzPS0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTM9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mz10aGlzLmxvd2VyTGltaXQzLWQzO1xuICAgICAgICAgICAgICAgIGlmKCFlbmFibGVTcHJpbmczKWQzPXRoaXMubG93ZXJMaW1pdDM7XG4gICAgICAgICAgICB9ZWxzZSBpZihkMz50aGlzLnVwcGVyTGltaXQzKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUzIT0xKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFN0YXRlMz0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTM9MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mz10aGlzLnVwcGVyTGltaXQzLWQzO1xuICAgICAgICAgICAgICAgIGlmKCFlbmFibGVTcHJpbmczKWQzPXRoaXMudXBwZXJMaW1pdDM7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUzPTI7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdEltcHVsc2UzPTA7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mz0wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWVuYWJsZVNwcmluZzMpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubGltaXRWZWxvY2l0eTM+MC4wMDUpdGhpcy5saW1pdFZlbG9jaXR5My09MC4wMDU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZih0aGlzLmxpbWl0VmVsb2NpdHkzPC0wLjAwNSl0aGlzLmxpbWl0VmVsb2NpdHkzKz0wLjAwNTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMubGltaXRWZWxvY2l0eTM9MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLmxpbWl0U3RhdGUzPTI7XG4gICAgICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTM9MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlTW90b3IxJiYodGhpcy5saW1pdFN0YXRlMSE9MHx8ZW5hYmxlU3ByaW5nMSkpe1xuICAgICAgICAgICAgdGhpcy5tYXhNb3RvckltcHVsc2UxPXRoaXMubWF4TW90b3JGb3JjZTEqdGltZVN0ZXA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UxPTA7XG4gICAgICAgICAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTE9MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlTW90b3IyJiYodGhpcy5saW1pdFN0YXRlMiE9MHx8ZW5hYmxlU3ByaW5nMikpe1xuICAgICAgICAgICAgdGhpcy5tYXhNb3RvckltcHVsc2UyPXRoaXMubWF4TW90b3JGb3JjZTIqdGltZVN0ZXA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UyPTA7XG4gICAgICAgICAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTI9MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlTW90b3IzJiYodGhpcy5saW1pdFN0YXRlMyE9MHx8ZW5hYmxlU3ByaW5nMykpe1xuICAgICAgICAgICAgdGhpcy5tYXhNb3RvckltcHVsc2UzPXRoaXMubWF4TW90b3JGb3JjZTMqdGltZVN0ZXA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UzPTA7XG4gICAgICAgICAgICB0aGlzLm1heE1vdG9ySW1wdWxzZTM9MDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHJkeD1kMSp0aGlzLmF4MStkMip0aGlzLmF4MitkMyp0aGlzLmF4MjtcbiAgICAgICAgdmFyIHJkeT1kMSp0aGlzLmF5MStkMip0aGlzLmF5MitkMyp0aGlzLmF5MjtcbiAgICAgICAgdmFyIHJkej1kMSp0aGlzLmF6MStkMip0aGlzLmF6MitkMyp0aGlzLmF6MjtcbiAgICAgICAgdmFyIHcxPXRoaXMubTIvKHRoaXMubTErdGhpcy5tMik7XG4gICAgICAgIGlmKHRoaXMud2VpZ2h0Pj0wKXcxPXRoaXMud2VpZ2h0OyAvLyB1c2UgZ2l2ZW4gd2VpZ2h0XG4gICAgICAgIHZhciB3Mj0xLXcxO1xuICAgICAgICB0aGlzLnIxeD10aGlzLnIxLngrcmR4KncxO1xuICAgICAgICB0aGlzLnIxeT10aGlzLnIxLnkrcmR5KncxO1xuICAgICAgICB0aGlzLnIxej10aGlzLnIxLnorcmR6KncxO1xuICAgICAgICB0aGlzLnIyeD10aGlzLnIyLngtcmR4KncyO1xuICAgICAgICB0aGlzLnIyeT10aGlzLnIyLnktcmR5KncyO1xuICAgICAgICB0aGlzLnIyej10aGlzLnIyLnotcmR6KncyO1xuXG4gICAgICAgIC8vIGJ1aWxkIGphY29iaWFuc1xuICAgICAgICB0aGlzLnQxeDE9dGhpcy5yMXkqdGhpcy5hejEtdGhpcy5yMXoqdGhpcy5heTE7XG4gICAgICAgIHRoaXMudDF5MT10aGlzLnIxeip0aGlzLmF4MS10aGlzLnIxeCp0aGlzLmF6MTtcbiAgICAgICAgdGhpcy50MXoxPXRoaXMucjF4KnRoaXMuYXkxLXRoaXMucjF5KnRoaXMuYXgxO1xuICAgICAgICB0aGlzLnQyeDE9dGhpcy5yMnkqdGhpcy5hejEtdGhpcy5yMnoqdGhpcy5heTE7XG4gICAgICAgIHRoaXMudDJ5MT10aGlzLnIyeip0aGlzLmF4MS10aGlzLnIyeCp0aGlzLmF6MTtcbiAgICAgICAgdGhpcy50MnoxPXRoaXMucjJ4KnRoaXMuYXkxLXRoaXMucjJ5KnRoaXMuYXgxO1xuICAgICAgICB0aGlzLmwxeDE9dGhpcy5heDEqdGhpcy5tMTtcbiAgICAgICAgdGhpcy5sMXkxPXRoaXMuYXkxKnRoaXMubTE7XG4gICAgICAgIHRoaXMubDF6MT10aGlzLmF6MSp0aGlzLm0xO1xuICAgICAgICB0aGlzLmwyeDE9dGhpcy5heDEqdGhpcy5tMjtcbiAgICAgICAgdGhpcy5sMnkxPXRoaXMuYXkxKnRoaXMubTI7XG4gICAgICAgIHRoaXMubDJ6MT10aGlzLmF6MSp0aGlzLm0yO1xuICAgICAgICB0aGlzLmExeDE9dGhpcy50MXgxKnRoaXMuaTFlMDArdGhpcy50MXkxKnRoaXMuaTFlMDErdGhpcy50MXoxKnRoaXMuaTFlMDI7XG4gICAgICAgIHRoaXMuYTF5MT10aGlzLnQxeDEqdGhpcy5pMWUxMCt0aGlzLnQxeTEqdGhpcy5pMWUxMSt0aGlzLnQxejEqdGhpcy5pMWUxMjtcbiAgICAgICAgdGhpcy5hMXoxPXRoaXMudDF4MSp0aGlzLmkxZTIwK3RoaXMudDF5MSp0aGlzLmkxZTIxK3RoaXMudDF6MSp0aGlzLmkxZTIyO1xuICAgICAgICB0aGlzLmEyeDE9dGhpcy50MngxKnRoaXMuaTJlMDArdGhpcy50MnkxKnRoaXMuaTJlMDErdGhpcy50MnoxKnRoaXMuaTJlMDI7XG4gICAgICAgIHRoaXMuYTJ5MT10aGlzLnQyeDEqdGhpcy5pMmUxMCt0aGlzLnQyeTEqdGhpcy5pMmUxMSt0aGlzLnQyejEqdGhpcy5pMmUxMjtcbiAgICAgICAgdGhpcy5hMnoxPXRoaXMudDJ4MSp0aGlzLmkyZTIwK3RoaXMudDJ5MSp0aGlzLmkyZTIxK3RoaXMudDJ6MSp0aGlzLmkyZTIyO1xuXG4gICAgICAgIHRoaXMudDF4Mj10aGlzLnIxeSp0aGlzLmF6Mi10aGlzLnIxeip0aGlzLmF5MjtcbiAgICAgICAgdGhpcy50MXkyPXRoaXMucjF6KnRoaXMuYXgyLXRoaXMucjF4KnRoaXMuYXoyO1xuICAgICAgICB0aGlzLnQxejI9dGhpcy5yMXgqdGhpcy5heTItdGhpcy5yMXkqdGhpcy5heDI7XG4gICAgICAgIHRoaXMudDJ4Mj10aGlzLnIyeSp0aGlzLmF6Mi10aGlzLnIyeip0aGlzLmF5MjtcbiAgICAgICAgdGhpcy50MnkyPXRoaXMucjJ6KnRoaXMuYXgyLXRoaXMucjJ4KnRoaXMuYXoyO1xuICAgICAgICB0aGlzLnQyejI9dGhpcy5yMngqdGhpcy5heTItdGhpcy5yMnkqdGhpcy5heDI7XG4gICAgICAgIHRoaXMubDF4Mj10aGlzLmF4Mip0aGlzLm0xO1xuICAgICAgICB0aGlzLmwxeTI9dGhpcy5heTIqdGhpcy5tMTtcbiAgICAgICAgdGhpcy5sMXoyPXRoaXMuYXoyKnRoaXMubTE7XG4gICAgICAgIHRoaXMubDJ4Mj10aGlzLmF4Mip0aGlzLm0yO1xuICAgICAgICB0aGlzLmwyeTI9dGhpcy5heTIqdGhpcy5tMjtcbiAgICAgICAgdGhpcy5sMnoyPXRoaXMuYXoyKnRoaXMubTI7XG4gICAgICAgIHRoaXMuYTF4Mj10aGlzLnQxeDIqdGhpcy5pMWUwMCt0aGlzLnQxeTIqdGhpcy5pMWUwMSt0aGlzLnQxejIqdGhpcy5pMWUwMjtcbiAgICAgICAgdGhpcy5hMXkyPXRoaXMudDF4Mip0aGlzLmkxZTEwK3RoaXMudDF5Mip0aGlzLmkxZTExK3RoaXMudDF6Mip0aGlzLmkxZTEyO1xuICAgICAgICB0aGlzLmExejI9dGhpcy50MXgyKnRoaXMuaTFlMjArdGhpcy50MXkyKnRoaXMuaTFlMjErdGhpcy50MXoyKnRoaXMuaTFlMjI7XG4gICAgICAgIHRoaXMuYTJ4Mj10aGlzLnQyeDIqdGhpcy5pMmUwMCt0aGlzLnQyeTIqdGhpcy5pMmUwMSt0aGlzLnQyejIqdGhpcy5pMmUwMjtcbiAgICAgICAgdGhpcy5hMnkyPXRoaXMudDJ4Mip0aGlzLmkyZTEwK3RoaXMudDJ5Mip0aGlzLmkyZTExK3RoaXMudDJ6Mip0aGlzLmkyZTEyO1xuICAgICAgICB0aGlzLmEyejI9dGhpcy50MngyKnRoaXMuaTJlMjArdGhpcy50MnkyKnRoaXMuaTJlMjErdGhpcy50MnoyKnRoaXMuaTJlMjI7XG5cbiAgICAgICAgdGhpcy50MXgzPXRoaXMucjF5KnRoaXMuYXozLXRoaXMucjF6KnRoaXMuYXkzO1xuICAgICAgICB0aGlzLnQxeTM9dGhpcy5yMXoqdGhpcy5heDMtdGhpcy5yMXgqdGhpcy5hejM7XG4gICAgICAgIHRoaXMudDF6Mz10aGlzLnIxeCp0aGlzLmF5My10aGlzLnIxeSp0aGlzLmF4MztcbiAgICAgICAgdGhpcy50MngzPXRoaXMucjJ5KnRoaXMuYXozLXRoaXMucjJ6KnRoaXMuYXkzO1xuICAgICAgICB0aGlzLnQyeTM9dGhpcy5yMnoqdGhpcy5heDMtdGhpcy5yMngqdGhpcy5hejM7XG4gICAgICAgIHRoaXMudDJ6Mz10aGlzLnIyeCp0aGlzLmF5My10aGlzLnIyeSp0aGlzLmF4MztcbiAgICAgICAgdGhpcy5sMXgzPXRoaXMuYXgzKnRoaXMubTE7XG4gICAgICAgIHRoaXMubDF5Mz10aGlzLmF5Myp0aGlzLm0xO1xuICAgICAgICB0aGlzLmwxejM9dGhpcy5hejMqdGhpcy5tMTtcbiAgICAgICAgdGhpcy5sMngzPXRoaXMuYXgzKnRoaXMubTI7XG4gICAgICAgIHRoaXMubDJ5Mz10aGlzLmF5Myp0aGlzLm0yO1xuICAgICAgICB0aGlzLmwyejM9dGhpcy5hejMqdGhpcy5tMjtcbiAgICAgICAgdGhpcy5hMXgzPXRoaXMudDF4Myp0aGlzLmkxZTAwK3RoaXMudDF5Myp0aGlzLmkxZTAxK3RoaXMudDF6Myp0aGlzLmkxZTAyO1xuICAgICAgICB0aGlzLmExeTM9dGhpcy50MXgzKnRoaXMuaTFlMTArdGhpcy50MXkzKnRoaXMuaTFlMTErdGhpcy50MXozKnRoaXMuaTFlMTI7XG4gICAgICAgIHRoaXMuYTF6Mz10aGlzLnQxeDMqdGhpcy5pMWUyMCt0aGlzLnQxeTMqdGhpcy5pMWUyMSt0aGlzLnQxejMqdGhpcy5pMWUyMjtcbiAgICAgICAgdGhpcy5hMngzPXRoaXMudDJ4Myp0aGlzLmkyZTAwK3RoaXMudDJ5Myp0aGlzLmkyZTAxK3RoaXMudDJ6Myp0aGlzLmkyZTAyO1xuICAgICAgICB0aGlzLmEyeTM9dGhpcy50MngzKnRoaXMuaTJlMTArdGhpcy50MnkzKnRoaXMuaTJlMTErdGhpcy50MnozKnRoaXMuaTJlMTI7XG4gICAgICAgIHRoaXMuYTJ6Mz10aGlzLnQyeDMqdGhpcy5pMmUyMCt0aGlzLnQyeTMqdGhpcy5pMmUyMSt0aGlzLnQyejMqdGhpcy5pMmUyMjtcblxuICAgICAgICAvLyBidWlsZCBhbiBpbXB1bHNlIG1hdHJpeFxuICAgICAgICB2YXIgbTEyPXRoaXMubTErdGhpcy5tMjtcbiAgICAgICAgdGhpcy5rMDA9KHRoaXMuYXgxKnRoaXMuYXgxK3RoaXMuYXkxKnRoaXMuYXkxK3RoaXMuYXoxKnRoaXMuYXoxKSptMTI7XG4gICAgICAgIHRoaXMuazAxPSh0aGlzLmF4MSp0aGlzLmF4Mit0aGlzLmF5MSp0aGlzLmF5Mit0aGlzLmF6MSp0aGlzLmF6MikqbTEyO1xuICAgICAgICB0aGlzLmswMj0odGhpcy5heDEqdGhpcy5heDMrdGhpcy5heTEqdGhpcy5heTMrdGhpcy5hejEqdGhpcy5hejMpKm0xMjtcbiAgICAgICAgdGhpcy5rMTA9KHRoaXMuYXgyKnRoaXMuYXgxK3RoaXMuYXkyKnRoaXMuYXkxK3RoaXMuYXoyKnRoaXMuYXoxKSptMTI7XG4gICAgICAgIHRoaXMuazExPSh0aGlzLmF4Mip0aGlzLmF4Mit0aGlzLmF5Mip0aGlzLmF5Mit0aGlzLmF6Mip0aGlzLmF6MikqbTEyO1xuICAgICAgICB0aGlzLmsxMj0odGhpcy5heDIqdGhpcy5heDMrdGhpcy5heTIqdGhpcy5heTMrdGhpcy5hejIqdGhpcy5hejMpKm0xMjtcbiAgICAgICAgdGhpcy5rMjA9KHRoaXMuYXgzKnRoaXMuYXgxK3RoaXMuYXkzKnRoaXMuYXkxK3RoaXMuYXozKnRoaXMuYXoxKSptMTI7XG4gICAgICAgIHRoaXMuazIxPSh0aGlzLmF4Myp0aGlzLmF4Mit0aGlzLmF5Myp0aGlzLmF5Mit0aGlzLmF6Myp0aGlzLmF6MikqbTEyO1xuICAgICAgICB0aGlzLmsyMj0odGhpcy5heDMqdGhpcy5heDMrdGhpcy5heTMqdGhpcy5heTMrdGhpcy5hejMqdGhpcy5hejMpKm0xMjtcblxuICAgICAgICB0aGlzLmswMCs9dGhpcy50MXgxKnRoaXMuYTF4MSt0aGlzLnQxeTEqdGhpcy5hMXkxK3RoaXMudDF6MSp0aGlzLmExejE7XG4gICAgICAgIHRoaXMuazAxKz10aGlzLnQxeDEqdGhpcy5hMXgyK3RoaXMudDF5MSp0aGlzLmExeTIrdGhpcy50MXoxKnRoaXMuYTF6MjtcbiAgICAgICAgdGhpcy5rMDIrPXRoaXMudDF4MSp0aGlzLmExeDMrdGhpcy50MXkxKnRoaXMuYTF5Myt0aGlzLnQxejEqdGhpcy5hMXozO1xuICAgICAgICB0aGlzLmsxMCs9dGhpcy50MXgyKnRoaXMuYTF4MSt0aGlzLnQxeTIqdGhpcy5hMXkxK3RoaXMudDF6Mip0aGlzLmExejE7XG4gICAgICAgIHRoaXMuazExKz10aGlzLnQxeDIqdGhpcy5hMXgyK3RoaXMudDF5Mip0aGlzLmExeTIrdGhpcy50MXoyKnRoaXMuYTF6MjtcbiAgICAgICAgdGhpcy5rMTIrPXRoaXMudDF4Mip0aGlzLmExeDMrdGhpcy50MXkyKnRoaXMuYTF5Myt0aGlzLnQxejIqdGhpcy5hMXozO1xuICAgICAgICB0aGlzLmsyMCs9dGhpcy50MXgzKnRoaXMuYTF4MSt0aGlzLnQxeTMqdGhpcy5hMXkxK3RoaXMudDF6Myp0aGlzLmExejE7XG4gICAgICAgIHRoaXMuazIxKz10aGlzLnQxeDMqdGhpcy5hMXgyK3RoaXMudDF5Myp0aGlzLmExeTIrdGhpcy50MXozKnRoaXMuYTF6MjtcbiAgICAgICAgdGhpcy5rMjIrPXRoaXMudDF4Myp0aGlzLmExeDMrdGhpcy50MXkzKnRoaXMuYTF5Myt0aGlzLnQxejMqdGhpcy5hMXozO1xuXG4gICAgICAgIHRoaXMuazAwKz10aGlzLnQyeDEqdGhpcy5hMngxK3RoaXMudDJ5MSp0aGlzLmEyeTErdGhpcy50MnoxKnRoaXMuYTJ6MTtcbiAgICAgICAgdGhpcy5rMDErPXRoaXMudDJ4MSp0aGlzLmEyeDIrdGhpcy50MnkxKnRoaXMuYTJ5Mit0aGlzLnQyejEqdGhpcy5hMnoyO1xuICAgICAgICB0aGlzLmswMis9dGhpcy50MngxKnRoaXMuYTJ4Myt0aGlzLnQyeTEqdGhpcy5hMnkzK3RoaXMudDJ6MSp0aGlzLmEyejM7XG4gICAgICAgIHRoaXMuazEwKz10aGlzLnQyeDIqdGhpcy5hMngxK3RoaXMudDJ5Mip0aGlzLmEyeTErdGhpcy50MnoyKnRoaXMuYTJ6MTtcbiAgICAgICAgdGhpcy5rMTErPXRoaXMudDJ4Mip0aGlzLmEyeDIrdGhpcy50MnkyKnRoaXMuYTJ5Mit0aGlzLnQyejIqdGhpcy5hMnoyO1xuICAgICAgICB0aGlzLmsxMis9dGhpcy50MngyKnRoaXMuYTJ4Myt0aGlzLnQyeTIqdGhpcy5hMnkzK3RoaXMudDJ6Mip0aGlzLmEyejM7XG4gICAgICAgIHRoaXMuazIwKz10aGlzLnQyeDMqdGhpcy5hMngxK3RoaXMudDJ5Myp0aGlzLmEyeTErdGhpcy50MnozKnRoaXMuYTJ6MTtcbiAgICAgICAgdGhpcy5rMjErPXRoaXMudDJ4Myp0aGlzLmEyeDIrdGhpcy50MnkzKnRoaXMuYTJ5Mit0aGlzLnQyejMqdGhpcy5hMnoyO1xuICAgICAgICB0aGlzLmsyMis9dGhpcy50MngzKnRoaXMuYTJ4Myt0aGlzLnQyeTMqdGhpcy5hMnkzK3RoaXMudDJ6Myp0aGlzLmEyejM7XG5cbiAgICAgICAgdGhpcy5rdjAwPXRoaXMuazAwO1xuICAgICAgICB0aGlzLmt2MTE9dGhpcy5rMTE7XG4gICAgICAgIHRoaXMua3YyMj10aGlzLmsyMjtcblxuICAgICAgICB0aGlzLmR2MDA9MS90aGlzLmt2MDA7XG4gICAgICAgIHRoaXMuZHYxMT0xL3RoaXMua3YxMTtcbiAgICAgICAgdGhpcy5kdjIyPTEvdGhpcy5rdjIyO1xuXG4gICAgICAgIGlmKGVuYWJsZVNwcmluZzEmJnRoaXMubGltaXRTdGF0ZTEhPTIpe1xuICAgICAgICAgICAgdmFyIG9tZWdhPTYuMjgzMTg1MypmcmVxdWVuY3kxO1xuICAgICAgICAgICAgdmFyIGs9b21lZ2Eqb21lZ2EqdGltZVN0ZXA7XG4gICAgICAgICAgICB2YXIgZG1wPWludlRpbWVTdGVwLyhrKzIqdGhpcy5saW1pdE1vdG9yMS5kYW1waW5nUmF0aW8qb21lZ2EpO1xuICAgICAgICAgICAgdGhpcy5jZm0xPXRoaXMua3YwMCpkbXA7XG4gICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkxKj1rKmRtcDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLmNmbTE9MDtcbiAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTEqPWludlRpbWVTdGVwKjAuMDU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZW5hYmxlU3ByaW5nMiYmdGhpcy5saW1pdFN0YXRlMiE9Mil7XG4gICAgICAgICAgICBvbWVnYT02LjI4MzE4NTMqZnJlcXVlbmN5MjtcbiAgICAgICAgICAgIGs9b21lZ2Eqb21lZ2EqdGltZVN0ZXA7XG4gICAgICAgICAgICBkbXA9aW52VGltZVN0ZXAvKGsrMip0aGlzLmxpbWl0TW90b3IyLmRhbXBpbmdSYXRpbypvbWVnYSk7XG4gICAgICAgICAgICB0aGlzLmNmbTI9dGhpcy5rdjExKmRtcDtcbiAgICAgICAgICAgIHRoaXMubGltaXRWZWxvY2l0eTIqPWsqZG1wO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMuY2ZtMj0wO1xuICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Mio9aW52VGltZVN0ZXAqMC4wNTtcbiAgICAgICAgfVxuICAgICAgICBpZihlbmFibGVTcHJpbmczJiZ0aGlzLmxpbWl0U3RhdGUzIT0yKXtcbiAgICAgICAgICAgIG9tZWdhPTYuMjgzMTg1MypmcmVxdWVuY3kzO1xuICAgICAgICAgICAgaz1vbWVnYSpvbWVnYSp0aW1lU3RlcDtcbiAgICAgICAgICAgIGRtcD1pbnZUaW1lU3RlcC8oaysyKnRoaXMubGltaXRNb3RvcjMuZGFtcGluZ1JhdGlvKm9tZWdhKTtcbiAgICAgICAgICAgIHRoaXMuY2ZtMz10aGlzLmt2MjIqZG1wO1xuICAgICAgICAgICAgdGhpcy5saW1pdFZlbG9jaXR5Myo9aypkbXA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5jZm0zPTA7XG4gICAgICAgICAgICB0aGlzLmxpbWl0VmVsb2NpdHkzKj1pbnZUaW1lU3RlcCowLjA1O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuazAwKz10aGlzLmNmbTE7XG4gICAgICAgIHRoaXMuazExKz10aGlzLmNmbTI7XG4gICAgICAgIHRoaXMuazIyKz10aGlzLmNmbTM7XG5cbiAgICAgICAgdmFyIGludj0xLyhcbiAgICAgICAgdGhpcy5rMDAqKHRoaXMuazExKnRoaXMuazIyLXRoaXMuazIxKnRoaXMuazEyKStcbiAgICAgICAgdGhpcy5rMTAqKHRoaXMuazIxKnRoaXMuazAyLXRoaXMuazAxKnRoaXMuazIyKStcbiAgICAgICAgdGhpcy5rMjAqKHRoaXMuazAxKnRoaXMuazEyLXRoaXMuazExKnRoaXMuazAyKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmQwMD0odGhpcy5rMTEqdGhpcy5rMjItdGhpcy5rMTIqdGhpcy5rMjEpKmludjtcbiAgICAgICAgdGhpcy5kMDE9KHRoaXMuazAyKnRoaXMuazIxLXRoaXMuazAxKnRoaXMuazIyKSppbnY7XG4gICAgICAgIHRoaXMuZDAyPSh0aGlzLmswMSp0aGlzLmsxMi10aGlzLmswMip0aGlzLmsxMSkqaW52O1xuICAgICAgICB0aGlzLmQxMD0odGhpcy5rMTIqdGhpcy5rMjAtdGhpcy5rMTAqdGhpcy5rMjIpKmludjtcbiAgICAgICAgdGhpcy5kMTE9KHRoaXMuazAwKnRoaXMuazIyLXRoaXMuazAyKnRoaXMuazIwKSppbnY7XG4gICAgICAgIHRoaXMuZDEyPSh0aGlzLmswMip0aGlzLmsxMC10aGlzLmswMCp0aGlzLmsxMikqaW52O1xuICAgICAgICB0aGlzLmQyMD0odGhpcy5rMTAqdGhpcy5rMjEtdGhpcy5rMTEqdGhpcy5rMjApKmludjtcbiAgICAgICAgdGhpcy5kMjE9KHRoaXMuazAxKnRoaXMuazIwLXRoaXMuazAwKnRoaXMuazIxKSppbnY7XG4gICAgICAgIHRoaXMuZDIyPSh0aGlzLmswMCp0aGlzLmsxMS10aGlzLmswMSp0aGlzLmsxMCkqaW52O1xuXG4gICAgICAgIC8vIHdhcm0gc3RhcnRpbmdcbiAgICAgICAgdmFyIHRvdGFsSW1wdWxzZTE9dGhpcy5saW1pdEltcHVsc2UxK3RoaXMubW90b3JJbXB1bHNlMTtcbiAgICAgICAgdmFyIHRvdGFsSW1wdWxzZTI9dGhpcy5saW1pdEltcHVsc2UyK3RoaXMubW90b3JJbXB1bHNlMjtcbiAgICAgICAgdmFyIHRvdGFsSW1wdWxzZTM9dGhpcy5saW1pdEltcHVsc2UzK3RoaXMubW90b3JJbXB1bHNlMztcbiAgICAgICAgdGhpcy5sMS54Kz10b3RhbEltcHVsc2UxKnRoaXMubDF4MSt0b3RhbEltcHVsc2UyKnRoaXMubDF4Mit0b3RhbEltcHVsc2UzKnRoaXMubDF4MztcbiAgICAgICAgdGhpcy5sMS55Kz10b3RhbEltcHVsc2UxKnRoaXMubDF5MSt0b3RhbEltcHVsc2UyKnRoaXMubDF5Mit0b3RhbEltcHVsc2UzKnRoaXMubDF5MztcbiAgICAgICAgdGhpcy5sMS56Kz10b3RhbEltcHVsc2UxKnRoaXMubDF6MSt0b3RhbEltcHVsc2UyKnRoaXMubDF6Mit0b3RhbEltcHVsc2UzKnRoaXMubDF6MztcbiAgICAgICAgdGhpcy5hMS54Kz10b3RhbEltcHVsc2UxKnRoaXMuYTF4MSt0b3RhbEltcHVsc2UyKnRoaXMuYTF4Mit0b3RhbEltcHVsc2UzKnRoaXMuYTF4MztcbiAgICAgICAgdGhpcy5hMS55Kz10b3RhbEltcHVsc2UxKnRoaXMuYTF5MSt0b3RhbEltcHVsc2UyKnRoaXMuYTF5Mit0b3RhbEltcHVsc2UzKnRoaXMuYTF5MztcbiAgICAgICAgdGhpcy5hMS56Kz10b3RhbEltcHVsc2UxKnRoaXMuYTF6MSt0b3RhbEltcHVsc2UyKnRoaXMuYTF6Mit0b3RhbEltcHVsc2UzKnRoaXMuYTF6MztcbiAgICAgICAgdGhpcy5sMi54LT10b3RhbEltcHVsc2UxKnRoaXMubDJ4MSt0b3RhbEltcHVsc2UyKnRoaXMubDJ4Mit0b3RhbEltcHVsc2UzKnRoaXMubDJ4MztcbiAgICAgICAgdGhpcy5sMi55LT10b3RhbEltcHVsc2UxKnRoaXMubDJ5MSt0b3RhbEltcHVsc2UyKnRoaXMubDJ5Mit0b3RhbEltcHVsc2UzKnRoaXMubDJ5MztcbiAgICAgICAgdGhpcy5sMi56LT10b3RhbEltcHVsc2UxKnRoaXMubDJ6MSt0b3RhbEltcHVsc2UyKnRoaXMubDJ6Mit0b3RhbEltcHVsc2UzKnRoaXMubDJ6MztcbiAgICAgICAgdGhpcy5hMi54LT10b3RhbEltcHVsc2UxKnRoaXMuYTJ4MSt0b3RhbEltcHVsc2UyKnRoaXMuYTJ4Mit0b3RhbEltcHVsc2UzKnRoaXMuYTJ4MztcbiAgICAgICAgdGhpcy5hMi55LT10b3RhbEltcHVsc2UxKnRoaXMuYTJ5MSt0b3RhbEltcHVsc2UyKnRoaXMuYTJ5Mit0b3RhbEltcHVsc2UzKnRoaXMuYTJ5MztcbiAgICAgICAgdGhpcy5hMi56LT10b3RhbEltcHVsc2UxKnRoaXMuYTJ6MSt0b3RhbEltcHVsc2UyKnRoaXMuYTJ6Mit0b3RhbEltcHVsc2UzKnRoaXMuYTJ6MztcbiAgICB9LFxuXG4gICAgc29sdmU6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJ2eD10aGlzLmwyLngtdGhpcy5sMS54K3RoaXMuYTIueSp0aGlzLnIyei10aGlzLmEyLnoqdGhpcy5yMnktdGhpcy5hMS55KnRoaXMucjF6K3RoaXMuYTEueip0aGlzLnIxeTtcbiAgICAgICAgdmFyIHJ2eT10aGlzLmwyLnktdGhpcy5sMS55K3RoaXMuYTIueip0aGlzLnIyeC10aGlzLmEyLngqdGhpcy5yMnotdGhpcy5hMS56KnRoaXMucjF4K3RoaXMuYTEueCp0aGlzLnIxejtcbiAgICAgICAgdmFyIHJ2ej10aGlzLmwyLnotdGhpcy5sMS56K3RoaXMuYTIueCp0aGlzLnIyeS10aGlzLmEyLnkqdGhpcy5yMngtdGhpcy5hMS54KnRoaXMucjF5K3RoaXMuYTEueSp0aGlzLnIxeDtcbiAgICAgICAgdmFyIHJ2bjE9cnZ4KnRoaXMuYXgxK3J2eSp0aGlzLmF5MStydnoqdGhpcy5hejE7XG4gICAgICAgIHZhciBydm4yPXJ2eCp0aGlzLmF4MitydnkqdGhpcy5heTIrcnZ6KnRoaXMuYXoyO1xuICAgICAgICB2YXIgcnZuMz1ydngqdGhpcy5heDMrcnZ5KnRoaXMuYXkzK3J2eip0aGlzLmF6MztcbiAgICAgICAgdmFyIG9sZE1vdG9ySW1wdWxzZTE9dGhpcy5tb3RvckltcHVsc2UxO1xuICAgICAgICB2YXIgb2xkTW90b3JJbXB1bHNlMj10aGlzLm1vdG9ySW1wdWxzZTI7XG4gICAgICAgIHZhciBvbGRNb3RvckltcHVsc2UzPXRoaXMubW90b3JJbXB1bHNlMztcbiAgICAgICAgdmFyIGRNb3RvckltcHVsc2UxPTA7XG4gICAgICAgIHZhciBkTW90b3JJbXB1bHNlMj0wO1xuICAgICAgICB2YXIgZE1vdG9ySW1wdWxzZTM9MDtcbiAgICAgICAgaWYodGhpcy5lbmFibGVNb3RvcjEpe1xuICAgICAgICAgICAgZE1vdG9ySW1wdWxzZTE9KHJ2bjEtdGhpcy5tb3RvclNwZWVkMSkqdGhpcy5kdjAwO1xuICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UxKz1kTW90b3JJbXB1bHNlMTtcbiAgICAgICAgICAgIGlmKHRoaXMubW90b3JJbXB1bHNlMT50aGlzLm1heE1vdG9ySW1wdWxzZTEpeyAvLyBjbGFtcCBtb3RvciBpbXB1bHNlXG4gICAgICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UxPXRoaXMubWF4TW90b3JJbXB1bHNlMTtcbiAgICAgICAgICAgIH1lbHNlIGlmKHRoaXMubW90b3JJbXB1bHNlMTwtdGhpcy5tYXhNb3RvckltcHVsc2UxKXtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTE9LXRoaXMubWF4TW90b3JJbXB1bHNlMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRNb3RvckltcHVsc2UxPXRoaXMubW90b3JJbXB1bHNlMS1vbGRNb3RvckltcHVsc2UxO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlTW90b3IyKXtcbiAgICAgICAgICAgIGRNb3RvckltcHVsc2UyPShydm4yLXRoaXMubW90b3JTcGVlZDIpKnRoaXMuZHYxMTtcbiAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMis9ZE1vdG9ySW1wdWxzZTI7XG4gICAgICAgICAgICBpZih0aGlzLm1vdG9ySW1wdWxzZTI+dGhpcy5tYXhNb3RvckltcHVsc2UyKXsgLy8gY2xhbXAgbW90b3IgaW1wdWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMj10aGlzLm1heE1vdG9ySW1wdWxzZTI7XG4gICAgICAgICAgICB9ZWxzZSBpZih0aGlzLm1vdG9ySW1wdWxzZTI8LXRoaXMubWF4TW90b3JJbXB1bHNlMil7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3RvckltcHVsc2UyPS10aGlzLm1heE1vdG9ySW1wdWxzZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkTW90b3JJbXB1bHNlMj10aGlzLm1vdG9ySW1wdWxzZTItb2xkTW90b3JJbXB1bHNlMjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmVuYWJsZU1vdG9yMyl7XG4gICAgICAgICAgICBkTW90b3JJbXB1bHNlMz0ocnZuMy10aGlzLm1vdG9yU3BlZWQzKSp0aGlzLmR2MjI7XG4gICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTMrPWRNb3RvckltcHVsc2UzO1xuICAgICAgICAgICAgaWYodGhpcy5tb3RvckltcHVsc2UzPnRoaXMubWF4TW90b3JJbXB1bHNlMyl7IC8vIGNsYW1wIG1vdG9yIGltcHVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1vdG9ySW1wdWxzZTM9dGhpcy5tYXhNb3RvckltcHVsc2UzO1xuICAgICAgICAgICAgfWVsc2UgaWYodGhpcy5tb3RvckltcHVsc2UzPC10aGlzLm1heE1vdG9ySW1wdWxzZTMpe1xuICAgICAgICAgICAgICAgIHRoaXMubW90b3JJbXB1bHNlMz0tdGhpcy5tYXhNb3RvckltcHVsc2UzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZE1vdG9ySW1wdWxzZTM9dGhpcy5tb3RvckltcHVsc2UzLW9sZE1vdG9ySW1wdWxzZTM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBtb3RvciBpbXB1bHNlIHRvIHJlbGF0aXZlIHZlbG9jaXR5XG4gICAgICAgIHJ2bjErPWRNb3RvckltcHVsc2UxKnRoaXMua3YwMCtkTW90b3JJbXB1bHNlMip0aGlzLmswMStkTW90b3JJbXB1bHNlMyp0aGlzLmswMjtcbiAgICAgICAgcnZuMis9ZE1vdG9ySW1wdWxzZTEqdGhpcy5rMTArZE1vdG9ySW1wdWxzZTIqdGhpcy5rdjExK2RNb3RvckltcHVsc2UzKnRoaXMuazEyO1xuICAgICAgICBydm4zKz1kTW90b3JJbXB1bHNlMSp0aGlzLmsyMCtkTW90b3JJbXB1bHNlMip0aGlzLmsyMStkTW90b3JJbXB1bHNlMyp0aGlzLmt2MjI7XG5cbiAgICAgICAgLy8gc3VidHJhY3QgdGFyZ2V0IHZlbG9jaXR5IGFuZCBhcHBsaWVkIGltcHVsc2VcbiAgICAgICAgcnZuMS09dGhpcy5saW1pdFZlbG9jaXR5MSt0aGlzLmxpbWl0SW1wdWxzZTEqdGhpcy5jZm0xO1xuICAgICAgICBydm4yLT10aGlzLmxpbWl0VmVsb2NpdHkyK3RoaXMubGltaXRJbXB1bHNlMip0aGlzLmNmbTI7XG4gICAgICAgIHJ2bjMtPXRoaXMubGltaXRWZWxvY2l0eTMrdGhpcy5saW1pdEltcHVsc2UzKnRoaXMuY2ZtMztcblxuICAgICAgICB2YXIgb2xkTGltaXRJbXB1bHNlMT10aGlzLmxpbWl0SW1wdWxzZTE7XG4gICAgICAgIHZhciBvbGRMaW1pdEltcHVsc2UyPXRoaXMubGltaXRJbXB1bHNlMjtcbiAgICAgICAgdmFyIG9sZExpbWl0SW1wdWxzZTM9dGhpcy5saW1pdEltcHVsc2UzO1xuXG4gICAgICAgIHZhciBkTGltaXRJbXB1bHNlMT1ydm4xKnRoaXMuZDAwK3J2bjIqdGhpcy5kMDErcnZuMyp0aGlzLmQwMjtcbiAgICAgICAgdmFyIGRMaW1pdEltcHVsc2UyPXJ2bjEqdGhpcy5kMTArcnZuMip0aGlzLmQxMStydm4zKnRoaXMuZDEyO1xuICAgICAgICB2YXIgZExpbWl0SW1wdWxzZTM9cnZuMSp0aGlzLmQyMCtydm4yKnRoaXMuZDIxK3J2bjMqdGhpcy5kMjI7XG5cbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UxKz1kTGltaXRJbXB1bHNlMTtcbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyKz1kTGltaXRJbXB1bHNlMjtcbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UzKz1kTGltaXRJbXB1bHNlMztcblxuICAgICAgICAvLyBjbGFtcFxuICAgICAgICB2YXIgY2xhbXBTdGF0ZT0wO1xuICAgICAgICBpZih0aGlzLmxpbWl0U3RhdGUxPT0yfHx0aGlzLmxpbWl0SW1wdWxzZTEqdGhpcy5saW1pdFN0YXRlMTwwKXtcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UxPS1vbGRMaW1pdEltcHVsc2UxO1xuICAgICAgICAgICAgcnZuMis9ZExpbWl0SW1wdWxzZTEqdGhpcy5rMTA7XG4gICAgICAgICAgICBydm4zKz1kTGltaXRJbXB1bHNlMSp0aGlzLmsyMDtcbiAgICAgICAgICAgIGNsYW1wU3RhdGV8PTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5saW1pdFN0YXRlMj09Mnx8dGhpcy5saW1pdEltcHVsc2UyKnRoaXMubGltaXRTdGF0ZTI8MCl7XG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMj0tb2xkTGltaXRJbXB1bHNlMjtcbiAgICAgICAgICAgIHJ2bjErPWRMaW1pdEltcHVsc2UyKnRoaXMuazAxO1xuICAgICAgICAgICAgcnZuMys9ZExpbWl0SW1wdWxzZTIqdGhpcy5rMjE7XG4gICAgICAgICAgICBjbGFtcFN0YXRlfD0yO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMubGltaXRTdGF0ZTM9PTJ8fHRoaXMubGltaXRJbXB1bHNlMyp0aGlzLmxpbWl0U3RhdGUzPDApe1xuICAgICAgICAgICAgZExpbWl0SW1wdWxzZTM9LW9sZExpbWl0SW1wdWxzZTM7XG4gICAgICAgICAgICBydm4xKz1kTGltaXRJbXB1bHNlMyp0aGlzLmswMjtcbiAgICAgICAgICAgIHJ2bjIrPWRMaW1pdEltcHVsc2UzKnRoaXMuazEyO1xuICAgICAgICAgICAgY2xhbXBTdGF0ZXw9NDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB1bi1jbGFtcGVkIGltcHVsc2VcbiAgICAgICAgLy8gVE9ETzogaXNvbGF0ZSBkaXZpc2lvblxuICAgICAgICB2YXIgZGV0O1xuICAgICAgICBzd2l0Y2goY2xhbXBTdGF0ZSl7XG4gICAgICAgICAgICBjYXNlIDE6Ly8gdXBkYXRlIDIgM1xuICAgICAgICAgICAgZGV0PTEvKHRoaXMuazExKnRoaXMuazIyLXRoaXMuazEyKnRoaXMuazIxKTtcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UyPSh0aGlzLmsyMipydm4yKy10aGlzLmsxMipydm4zKSpkZXQ7XG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMz0oLXRoaXMuazIxKnJ2bjIrdGhpcy5rMTEqcnZuMykqZGV0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6Ly8gdXBkYXRlIDEgM1xuICAgICAgICAgICAgZGV0PTEvKHRoaXMuazAwKnRoaXMuazIyLXRoaXMuazAyKnRoaXMuazIwKTtcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UxPSh0aGlzLmsyMipydm4xKy10aGlzLmswMipydm4zKSpkZXQ7XG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMz0oLXRoaXMuazIwKnJ2bjErdGhpcy5rMDAqcnZuMykqZGV0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6Ly8gdXBkYXRlIDNcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UzPXJ2bjMvdGhpcy5rMjI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDovLyB1cGRhdGUgMSAyXG4gICAgICAgICAgICBkZXQ9MS8odGhpcy5rMDAqdGhpcy5rMTEtdGhpcy5rMDEqdGhpcy5rMTApO1xuICAgICAgICAgICAgZExpbWl0SW1wdWxzZTE9KHRoaXMuazExKnJ2bjErLXRoaXMuazAxKnJ2bjIpKmRldDtcbiAgICAgICAgICAgIGRMaW1pdEltcHVsc2UyPSgtdGhpcy5rMTAqcnZuMSt0aGlzLmswMCpydm4yKSpkZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTovLyB1cGRhdGUgMlxuICAgICAgICAgICAgZExpbWl0SW1wdWxzZTI9cnZuMi90aGlzLmsxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2Oi8vIHVwZGF0ZSAxXG4gICAgICAgICAgICBkTGltaXRJbXB1bHNlMT1ydm4xL3RoaXMuazAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpbWl0SW1wdWxzZTE9b2xkTGltaXRJbXB1bHNlMStkTGltaXRJbXB1bHNlMTtcbiAgICAgICAgdGhpcy5saW1pdEltcHVsc2UyPW9sZExpbWl0SW1wdWxzZTIrZExpbWl0SW1wdWxzZTI7XG4gICAgICAgIHRoaXMubGltaXRJbXB1bHNlMz1vbGRMaW1pdEltcHVsc2UzK2RMaW1pdEltcHVsc2UzO1xuXG4gICAgICAgIHZhciBkSW1wdWxzZTE9ZE1vdG9ySW1wdWxzZTErZExpbWl0SW1wdWxzZTE7XG4gICAgICAgIHZhciBkSW1wdWxzZTI9ZE1vdG9ySW1wdWxzZTIrZExpbWl0SW1wdWxzZTI7XG4gICAgICAgIHZhciBkSW1wdWxzZTM9ZE1vdG9ySW1wdWxzZTMrZExpbWl0SW1wdWxzZTM7XG5cbiAgICAgICAgLy8gYXBwbHkgaW1wdWxzZVxuICAgICAgICB0aGlzLmwxLngrPWRJbXB1bHNlMSp0aGlzLmwxeDErZEltcHVsc2UyKnRoaXMubDF4MitkSW1wdWxzZTMqdGhpcy5sMXgzO1xuICAgICAgICB0aGlzLmwxLnkrPWRJbXB1bHNlMSp0aGlzLmwxeTErZEltcHVsc2UyKnRoaXMubDF5MitkSW1wdWxzZTMqdGhpcy5sMXkzO1xuICAgICAgICB0aGlzLmwxLnorPWRJbXB1bHNlMSp0aGlzLmwxejErZEltcHVsc2UyKnRoaXMubDF6MitkSW1wdWxzZTMqdGhpcy5sMXozO1xuICAgICAgICB0aGlzLmExLngrPWRJbXB1bHNlMSp0aGlzLmExeDErZEltcHVsc2UyKnRoaXMuYTF4MitkSW1wdWxzZTMqdGhpcy5hMXgzO1xuICAgICAgICB0aGlzLmExLnkrPWRJbXB1bHNlMSp0aGlzLmExeTErZEltcHVsc2UyKnRoaXMuYTF5MitkSW1wdWxzZTMqdGhpcy5hMXkzO1xuICAgICAgICB0aGlzLmExLnorPWRJbXB1bHNlMSp0aGlzLmExejErZEltcHVsc2UyKnRoaXMuYTF6MitkSW1wdWxzZTMqdGhpcy5hMXozO1xuICAgICAgICB0aGlzLmwyLngtPWRJbXB1bHNlMSp0aGlzLmwyeDErZEltcHVsc2UyKnRoaXMubDJ4MitkSW1wdWxzZTMqdGhpcy5sMngzO1xuICAgICAgICB0aGlzLmwyLnktPWRJbXB1bHNlMSp0aGlzLmwyeTErZEltcHVsc2UyKnRoaXMubDJ5MitkSW1wdWxzZTMqdGhpcy5sMnkzO1xuICAgICAgICB0aGlzLmwyLnotPWRJbXB1bHNlMSp0aGlzLmwyejErZEltcHVsc2UyKnRoaXMubDJ6MitkSW1wdWxzZTMqdGhpcy5sMnozO1xuICAgICAgICB0aGlzLmEyLngtPWRJbXB1bHNlMSp0aGlzLmEyeDErZEltcHVsc2UyKnRoaXMuYTJ4MitkSW1wdWxzZTMqdGhpcy5hMngzO1xuICAgICAgICB0aGlzLmEyLnktPWRJbXB1bHNlMSp0aGlzLmEyeTErZEltcHVsc2UyKnRoaXMuYTJ5MitkSW1wdWxzZTMqdGhpcy5hMnkzO1xuICAgICAgICB0aGlzLmEyLnotPWRJbXB1bHNlMSp0aGlzLmEyejErZEltcHVsc2UyKnRoaXMuYTJ6MitkSW1wdWxzZTMqdGhpcy5hMnozO1xuICAgIH1cbiAgICBcbn0gKTtcblxuLyoqXG4gKiBBIHByaXNtYXRpYyBqb2ludCBhbGxvd3Mgb25seSBmb3IgcmVsYXRpdmUgdHJhbnNsYXRpb24gb2YgcmlnaWQgYm9kaWVzIGFsb25nIHRoZSBheGlzLlxuICpcbiAqIEBhdXRob3Igc2FoYXJhblxuICogQGF1dGhvciBsby10aFxuICovXG5cbmZ1bmN0aW9uIFByaXNtYXRpY0pvaW50KCBjb25maWcsIGxvd2VyVHJhbnNsYXRpb24sIHVwcGVyVHJhbnNsYXRpb24gKXtcblxuICAgIEpvaW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG4gICAgdGhpcy50eXBlID0gSk9JTlRfUFJJU01BVElDO1xuXG4gICAgLy8gVGhlIGF4aXMgaW4gdGhlIGZpcnN0IGJvZHkncyBjb29yZGluYXRlIHN5c3RlbS5cbiAgICB0aGlzLmxvY2FsQXhpczEgPSBjb25maWcubG9jYWxBeGlzMS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuICAgIC8vIFRoZSBheGlzIGluIHRoZSBzZWNvbmQgYm9keSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIHRoaXMubG9jYWxBeGlzMiA9IGNvbmZpZy5sb2NhbEF4aXMyLmNsb25lKCkubm9ybWFsaXplKCk7XG5cbiAgICB0aGlzLmF4MSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5heDIgPSBuZXcgVmVjMygpO1xuICAgIFxuICAgIHRoaXMubm9yID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRhbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5iaW4gPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy5hYyA9IG5ldyBBbmd1bGFyQ29uc3RyYWludCggdGhpcywgbmV3IFF1YXQoKS5zZXRGcm9tVW5pdFZlY3RvcnMoIHRoaXMubG9jYWxBeGlzMSwgdGhpcy5sb2NhbEF4aXMyICkgKTtcblxuICAgIC8vIFRoZSB0cmFuc2xhdGlvbmFsIGxpbWl0IGFuZCBtb3RvciBpbmZvcm1hdGlvbiBvZiB0aGUgam9pbnQuXG4gICAgdGhpcy5saW1pdE1vdG9yID0gbmV3IExpbWl0TW90b3IoIHRoaXMubm9yLCB0cnVlICk7XG4gICAgdGhpcy5saW1pdE1vdG9yLmxvd2VyTGltaXQgPSBsb3dlclRyYW5zbGF0aW9uO1xuICAgIHRoaXMubGltaXRNb3Rvci51cHBlckxpbWl0ID0gdXBwZXJUcmFuc2xhdGlvbjtcbiAgICB0aGlzLnQzID0gbmV3IFRyYW5zbGF0aW9uYWwzQ29uc3RyYWludCggdGhpcywgdGhpcy5saW1pdE1vdG9yLCBuZXcgTGltaXRNb3RvciggdGhpcy50YW4sIHRydWUgKSwgbmV3IExpbWl0TW90b3IoIHRoaXMuYmluLCB0cnVlICkgKTtcblxufVxuXG5QcmlzbWF0aWNKb2ludC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBKb2ludC5wcm90b3R5cGUgKSwge1xuXG4gICAgY29uc3RydWN0b3I6IFByaXNtYXRpY0pvaW50LFxuXG4gICAgcHJlU29sdmU6IGZ1bmN0aW9uICggdGltZVN0ZXAsIGludlRpbWVTdGVwICkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlQW5jaG9yUG9pbnRzKCk7XG5cbiAgICAgICAgdGhpcy5heDEuY29weSggdGhpcy5sb2NhbEF4aXMxICkuYXBwbHlNYXRyaXgzKCB0aGlzLmJvZHkxLnJvdGF0aW9uLCB0cnVlICk7XG4gICAgICAgIHRoaXMuYXgyLmNvcHkoIHRoaXMubG9jYWxBeGlzMiApLmFwcGx5TWF0cml4MyggdGhpcy5ib2R5Mi5yb3RhdGlvbiwgdHJ1ZSApO1xuXG4gICAgICAgIC8vIG5vcm1hbCB0YW5nZW50IGJpbm9ybWFsXG5cbiAgICAgICAgdGhpcy5ub3Iuc2V0KFxuICAgICAgICAgICAgdGhpcy5heDEueCp0aGlzLmJvZHkyLmludmVyc2VNYXNzICsgdGhpcy5heDIueCp0aGlzLmJvZHkxLmludmVyc2VNYXNzLFxuICAgICAgICAgICAgdGhpcy5heDEueSp0aGlzLmJvZHkyLmludmVyc2VNYXNzICsgdGhpcy5heDIueSp0aGlzLmJvZHkxLmludmVyc2VNYXNzLFxuICAgICAgICAgICAgdGhpcy5heDEueip0aGlzLmJvZHkyLmludmVyc2VNYXNzICsgdGhpcy5heDIueip0aGlzLmJvZHkxLmludmVyc2VNYXNzXG4gICAgICAgICkubm9ybWFsaXplKCk7XG4gICAgICAgIHRoaXMudGFuLnRhbmdlbnQoIHRoaXMubm9yICkubm9ybWFsaXplKCk7XG4gICAgICAgIHRoaXMuYmluLmNyb3NzVmVjdG9ycyggdGhpcy5ub3IsIHRoaXMudGFuICk7XG5cbiAgICAgICAgLy8gcHJlU29sdmVcblxuICAgICAgICB0aGlzLmFjLnByZVNvbHZlKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKTtcbiAgICAgICAgdGhpcy50My5wcmVTb2x2ZSggdGltZVN0ZXAsIGludlRpbWVTdGVwICk7XG5cbiAgICB9LFxuXG4gICAgc29sdmU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLmFjLnNvbHZlKCk7XG4gICAgICAgIHRoaXMudDMuc29sdmUoKTtcbiAgICAgICAgXG4gICAgfSxcblxuICAgIHBvc3RTb2x2ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBBIHNsaWRlciBqb2ludCBhbGxvd3MgZm9yIHJlbGF0aXZlIHRyYW5zbGF0aW9uIGFuZCByZWxhdGl2ZSByb3RhdGlvbiBiZXR3ZWVuIHR3byByaWdpZCBib2RpZXMgYWxvbmcgdGhlIGF4aXMuXG4gKlxuICogQGF1dGhvciBzYWhhcmFuXG4gKiBAYXV0aG9yIGxvLXRoXG4gKi9cblxuZnVuY3Rpb24gU2xpZGVySm9pbnQoIGNvbmZpZywgbG93ZXJUcmFuc2xhdGlvbiwgdXBwZXJUcmFuc2xhdGlvbiApe1xuXG4gICAgSm9pbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cbiAgICB0aGlzLnR5cGUgPSBKT0lOVF9TTElERVI7XG5cbiAgICAvLyBUaGUgYXhpcyBpbiB0aGUgZmlyc3QgYm9keSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIHRoaXMubG9jYWxBeGlzMSA9IGNvbmZpZy5sb2NhbEF4aXMxLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgLy8gVGhlIGF4aXMgaW4gdGhlIHNlY29uZCBib2R5J3MgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgdGhpcy5sb2NhbEF4aXMyID0gY29uZmlnLmxvY2FsQXhpczIuY2xvbmUoKS5ub3JtYWxpemUoKTtcblxuICAgIC8vIG1ha2UgYW5nbGUgYXhpc1xuICAgIHZhciBhcmMgPSBuZXcgTWF0MzMoKS5zZXRRdWF0KCBuZXcgUXVhdCgpLnNldEZyb21Vbml0VmVjdG9ycyggdGhpcy5sb2NhbEF4aXMxLCB0aGlzLmxvY2FsQXhpczIgKSApO1xuICAgIHRoaXMubG9jYWxBbmdsZTEgPSBuZXcgVmVjMygpLnRhbmdlbnQoIHRoaXMubG9jYWxBeGlzMSApLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMubG9jYWxBbmdsZTIgPSB0aGlzLmxvY2FsQW5nbGUxLmNsb25lKCkuYXBwbHlNYXRyaXgzKCBhcmMsIHRydWUgKTtcblxuICAgIHRoaXMuYXgxID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmF4MiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbjEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW4yID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMudG1wID0gbmV3IFZlYzMoKTtcbiAgICBcbiAgICB0aGlzLm5vciA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50YW4gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYmluID0gbmV3IFZlYzMoKTtcblxuICAgIC8vIFRoZSBsaW1pdCBhbmQgbW90b3IgZm9yIHRoZSByb3RhdGlvblxuICAgIHRoaXMucm90YXRpb25hbExpbWl0TW90b3IgPSBuZXcgTGltaXRNb3RvciggdGhpcy5ub3IsIGZhbHNlICk7XG4gICAgdGhpcy5yMyA9IG5ldyBSb3RhdGlvbmFsM0NvbnN0cmFpbnQoIHRoaXMsIHRoaXMucm90YXRpb25hbExpbWl0TW90b3IsIG5ldyBMaW1pdE1vdG9yKCB0aGlzLnRhbiwgdHJ1ZSApLCBuZXcgTGltaXRNb3RvciggdGhpcy5iaW4sIHRydWUgKSApO1xuXG4gICAgLy8gVGhlIGxpbWl0IGFuZCBtb3RvciBmb3IgdGhlIHRyYW5zbGF0aW9uLlxuICAgIHRoaXMudHJhbnNsYXRpb25hbExpbWl0TW90b3IgPSBuZXcgTGltaXRNb3RvciggdGhpcy5ub3IsIHRydWUgKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yLmxvd2VyTGltaXQgPSBsb3dlclRyYW5zbGF0aW9uO1xuICAgIHRoaXMudHJhbnNsYXRpb25hbExpbWl0TW90b3IudXBwZXJMaW1pdCA9IHVwcGVyVHJhbnNsYXRpb247XG4gICAgdGhpcy50MyA9IG5ldyBUcmFuc2xhdGlvbmFsM0NvbnN0cmFpbnQoIHRoaXMsIHRoaXMudHJhbnNsYXRpb25hbExpbWl0TW90b3IsIG5ldyBMaW1pdE1vdG9yKCB0aGlzLnRhbiwgdHJ1ZSApLCBuZXcgTGltaXRNb3RvciggdGhpcy5iaW4sIHRydWUgKSApO1xuXG59XG5cblNsaWRlckpvaW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEpvaW50LnByb3RvdHlwZSApLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU2xpZGVySm9pbnQsXG5cbiAgICBwcmVTb2x2ZTogZnVuY3Rpb24gKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVBbmNob3JQb2ludHMoKTtcblxuICAgICAgICB0aGlzLmF4MS5jb3B5KCB0aGlzLmxvY2FsQXhpczEgKS5hcHBseU1hdHJpeDMoIHRoaXMuYm9keTEucm90YXRpb24sIHRydWUgKTtcbiAgICAgICAgdGhpcy5hbjEuY29weSggdGhpcy5sb2NhbEFuZ2xlMSApLmFwcGx5TWF0cml4MyggdGhpcy5ib2R5MS5yb3RhdGlvbiwgdHJ1ZSApO1xuXG4gICAgICAgIHRoaXMuYXgyLmNvcHkoIHRoaXMubG9jYWxBeGlzMiApLmFwcGx5TWF0cml4MyggdGhpcy5ib2R5Mi5yb3RhdGlvbiwgdHJ1ZSApO1xuICAgICAgICB0aGlzLmFuMi5jb3B5KCB0aGlzLmxvY2FsQW5nbGUyICkuYXBwbHlNYXRyaXgzKCB0aGlzLmJvZHkyLnJvdGF0aW9uLCB0cnVlICk7XG5cbiAgICAgICAgLy8gbm9ybWFsIHRhbmdlbnQgYmlub3JtYWxcblxuICAgICAgICB0aGlzLm5vci5zZXQoXG4gICAgICAgICAgICB0aGlzLmF4MS54KnRoaXMuYm9keTIuaW52ZXJzZU1hc3MgKyB0aGlzLmF4Mi54KnRoaXMuYm9keTEuaW52ZXJzZU1hc3MsXG4gICAgICAgICAgICB0aGlzLmF4MS55KnRoaXMuYm9keTIuaW52ZXJzZU1hc3MgKyB0aGlzLmF4Mi55KnRoaXMuYm9keTEuaW52ZXJzZU1hc3MsXG4gICAgICAgICAgICB0aGlzLmF4MS56KnRoaXMuYm9keTIuaW52ZXJzZU1hc3MgKyB0aGlzLmF4Mi56KnRoaXMuYm9keTEuaW52ZXJzZU1hc3NcbiAgICAgICAgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdGhpcy50YW4udGFuZ2VudCggdGhpcy5ub3IgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdGhpcy5iaW4uY3Jvc3NWZWN0b3JzKCB0aGlzLm5vciwgdGhpcy50YW4gKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgaGluZ2UgYW5nbGVcblxuICAgICAgICB0aGlzLnRtcC5jcm9zc1ZlY3RvcnMoIHRoaXMuYW4xLCB0aGlzLmFuMiApO1xuXG4gICAgICAgIHZhciBsaW1pdGUgPSBfTWF0aC5hY29zQ2xhbXAoIF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMuYW4xLCB0aGlzLmFuMiApICk7XG5cbiAgICAgICAgaWYoIF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMubm9yLCB0aGlzLnRtcCApIDwgMCApIHRoaXMucm90YXRpb25hbExpbWl0TW90b3IuYW5nbGUgPSAtbGltaXRlO1xuICAgICAgICBlbHNlIHRoaXMucm90YXRpb25hbExpbWl0TW90b3IuYW5nbGUgPSBsaW1pdGU7XG5cbiAgICAgICAgLy8gYW5ndWxhciBlcnJvclxuXG4gICAgICAgIHRoaXMudG1wLmNyb3NzVmVjdG9ycyggdGhpcy5heDEsIHRoaXMuYXgyICk7XG4gICAgICAgIHRoaXMucjMubGltaXRNb3RvcjIuYW5nbGUgPSBfTWF0aC5kb3RWZWN0b3JzKCB0aGlzLnRhbiwgdGhpcy50bXAgKTtcbiAgICAgICAgdGhpcy5yMy5saW1pdE1vdG9yMy5hbmdsZSA9IF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMuYmluLCB0aGlzLnRtcCApO1xuXG4gICAgICAgIC8vIHByZVNvbHZlXG4gICAgICAgIFxuICAgICAgICB0aGlzLnIzLnByZVNvbHZlKCB0aW1lU3RlcCwgaW52VGltZVN0ZXAgKTtcbiAgICAgICAgdGhpcy50My5wcmVTb2x2ZSggdGltZVN0ZXAsIGludlRpbWVTdGVwICk7XG5cbiAgICB9LFxuXG4gICAgc29sdmU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLnIzLnNvbHZlKCk7XG4gICAgICAgIHRoaXMudDMuc29sdmUoKTtcblxuICAgIH0sXG5cbiAgICBwb3N0U29sdmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIH1cblxufSk7XG5cbi8qKlxuICogQSB3aGVlbCBqb2ludCBhbGxvd3MgZm9yIHJlbGF0aXZlIHJvdGF0aW9uIGJldHdlZW4gdHdvIHJpZ2lkIGJvZGllcyBhbG9uZyB0d28gYXhlcy5cbiAqIFRoZSB3aGVlbCBqb2ludCBhbHNvIGFsbG93cyBmb3IgcmVsYXRpdmUgdHJhbnNsYXRpb24gZm9yIHRoZSBzdXNwZW5zaW9uLlxuICpcbiAqIEBhdXRob3Igc2FoYXJhblxuICogQGF1dGhvciBsby10aFxuICovXG5cbmZ1bmN0aW9uIFdoZWVsSm9pbnQgKCBjb25maWcgKXtcblxuICAgIEpvaW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG4gICAgdGhpcy50eXBlID0gSk9JTlRfV0hFRUw7XG5cbiAgICAvLyBUaGUgYXhpcyBpbiB0aGUgZmlyc3QgYm9keSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIHRoaXMubG9jYWxBeGlzMSA9IGNvbmZpZy5sb2NhbEF4aXMxLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgLy8gVGhlIGF4aXMgaW4gdGhlIHNlY29uZCBib2R5J3MgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgdGhpcy5sb2NhbEF4aXMyID0gY29uZmlnLmxvY2FsQXhpczIuY2xvbmUoKS5ub3JtYWxpemUoKTtcblxuICAgIHRoaXMubG9jYWxBbmdsZTEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMubG9jYWxBbmdsZTIgPSBuZXcgVmVjMygpO1xuXG4gICAgdmFyIGRvdCA9IF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMubG9jYWxBeGlzMSwgdGhpcy5sb2NhbEF4aXMyICk7XG5cbiAgICBpZiggZG90ID4gLTEgJiYgZG90IDwgMSApe1xuXG4gICAgICAgIHRoaXMubG9jYWxBbmdsZTEuc2V0KFxuICAgICAgICAgICAgdGhpcy5sb2NhbEF4aXMyLnggLSBkb3QqdGhpcy5sb2NhbEF4aXMxLngsXG4gICAgICAgICAgICB0aGlzLmxvY2FsQXhpczIueSAtIGRvdCp0aGlzLmxvY2FsQXhpczEueSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxBeGlzMi56IC0gZG90KnRoaXMubG9jYWxBeGlzMS56XG4gICAgICAgICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5sb2NhbEFuZ2xlMi5zZXQoXG4gICAgICAgICAgICB0aGlzLmxvY2FsQXhpczEueCAtIGRvdCp0aGlzLmxvY2FsQXhpczIueCxcbiAgICAgICAgICAgIHRoaXMubG9jYWxBeGlzMS55IC0gZG90KnRoaXMubG9jYWxBeGlzMi55LFxuICAgICAgICAgICAgdGhpcy5sb2NhbEF4aXMxLnogLSBkb3QqdGhpcy5sb2NhbEF4aXMyLnpcbiAgICAgICAgKS5ub3JtYWxpemUoKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIGFyYyA9IG5ldyBNYXQzMygpLnNldFF1YXQoIG5ldyBRdWF0KCkuc2V0RnJvbVVuaXRWZWN0b3JzKCB0aGlzLmxvY2FsQXhpczEsIHRoaXMubG9jYWxBeGlzMiApICk7XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZTEudGFuZ2VudCggdGhpcy5sb2NhbEF4aXMxICkubm9ybWFsaXplKCk7XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZTIgPSB0aGlzLmxvY2FsQW5nbGUxLmNsb25lKCkuYXBwbHlNYXRyaXgzKCBhcmMsIHRydWUgKTtcblxuICAgIH1cblxuICAgIHRoaXMuYXgxID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmF4MiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbjEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW4yID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMudG1wID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMubm9yID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRhbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5iaW4gPSBuZXcgVmVjMygpO1xuXG4gICAgLy8gVGhlIHRyYW5zbGF0aW9uYWwgbGltaXQgYW5kIG1vdG9yIGluZm9ybWF0aW9uIG9mIHRoZSBqb2ludC5cbiAgICB0aGlzLnRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yID0gbmV3IExpbWl0TW90b3IoIHRoaXMudGFuLHRydWUgKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yLmZyZXF1ZW5jeSA9IDg7XG4gICAgdGhpcy50cmFuc2xhdGlvbmFsTGltaXRNb3Rvci5kYW1waW5nUmF0aW8gPSAxO1xuICAgIC8vIFRoZSBmaXJzdCByb3RhdGlvbmFsIGxpbWl0IGFuZCBtb3RvciBpbmZvcm1hdGlvbiBvZiB0aGUgam9pbnQuXG4gICAgdGhpcy5yb3RhdGlvbmFsTGltaXRNb3RvcjEgPSBuZXcgTGltaXRNb3RvciggdGhpcy50YW4sIGZhbHNlICk7XG4gICAgLy8gVGhlIHNlY29uZCByb3RhdGlvbmFsIGxpbWl0IGFuZCBtb3RvciBpbmZvcm1hdGlvbiBvZiB0aGUgam9pbnQuXG4gICAgdGhpcy5yb3RhdGlvbmFsTGltaXRNb3RvcjIgPSBuZXcgTGltaXRNb3RvciggdGhpcy5iaW4sIGZhbHNlICk7XG5cbiAgICB0aGlzLnQzID0gbmV3IFRyYW5zbGF0aW9uYWwzQ29uc3RyYWludCggdGhpcywgbmV3IExpbWl0TW90b3IoIHRoaXMubm9yLCB0cnVlICksdGhpcy50cmFuc2xhdGlvbmFsTGltaXRNb3RvcixuZXcgTGltaXRNb3RvciggdGhpcy5iaW4sIHRydWUgKSk7XG4gICAgdGhpcy50My53ZWlnaHQgPSAxO1xuICAgIHRoaXMucjMgPSBuZXcgUm90YXRpb25hbDNDb25zdHJhaW50KHRoaXMsbmV3IExpbWl0TW90b3IoIHRoaXMubm9yLCB0cnVlICksdGhpcy5yb3RhdGlvbmFsTGltaXRNb3RvcjEsdGhpcy5yb3RhdGlvbmFsTGltaXRNb3RvcjIpO1xuXG59XG5cbldoZWVsSm9pbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSm9pbnQucHJvdG90eXBlICksIHtcblxuICAgIGNvbnN0cnVjdG9yOiBXaGVlbEpvaW50LFxuXG4gICAgcHJlU29sdmU6IGZ1bmN0aW9uICggdGltZVN0ZXAsIGludlRpbWVTdGVwICkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlQW5jaG9yUG9pbnRzKCk7XG5cbiAgICAgICAgdGhpcy5heDEuY29weSggdGhpcy5sb2NhbEF4aXMxICkuYXBwbHlNYXRyaXgzKCB0aGlzLmJvZHkxLnJvdGF0aW9uLCB0cnVlICk7XG4gICAgICAgIHRoaXMuYW4xLmNvcHkoIHRoaXMubG9jYWxBbmdsZTEgKS5hcHBseU1hdHJpeDMoIHRoaXMuYm9keTEucm90YXRpb24sIHRydWUgKTtcblxuICAgICAgICB0aGlzLmF4Mi5jb3B5KCB0aGlzLmxvY2FsQXhpczIgKS5hcHBseU1hdHJpeDMoIHRoaXMuYm9keTIucm90YXRpb24sIHRydWUgKTtcbiAgICAgICAgdGhpcy5hbjIuY29weSggdGhpcy5sb2NhbEFuZ2xlMiApLmFwcGx5TWF0cml4MyggdGhpcy5ib2R5Mi5yb3RhdGlvbiwgdHJ1ZSApO1xuXG4gICAgICAgIHRoaXMucjMubGltaXRNb3RvcjEuYW5nbGUgPSBfTWF0aC5kb3RWZWN0b3JzKCB0aGlzLmF4MSwgdGhpcy5heDIgKTtcblxuICAgICAgICB2YXIgbGltaXRlID0gX01hdGguZG90VmVjdG9ycyggdGhpcy5hbjEsIHRoaXMuYXgyICk7XG5cbiAgICAgICAgaWYoIF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMuYXgxLCB0aGlzLnRtcC5jcm9zc1ZlY3RvcnMoIHRoaXMuYW4xLCB0aGlzLmF4MiApICkgPCAwICkgdGhpcy5yb3RhdGlvbmFsTGltaXRNb3RvcjEuYW5nbGUgPSAtbGltaXRlO1xuICAgICAgICBlbHNlIHRoaXMucm90YXRpb25hbExpbWl0TW90b3IxLmFuZ2xlID0gbGltaXRlO1xuXG4gICAgICAgIGxpbWl0ZSA9IF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMuYW4yLCB0aGlzLmF4MSApO1xuXG4gICAgICAgIGlmKCBfTWF0aC5kb3RWZWN0b3JzKCB0aGlzLmF4MiwgdGhpcy50bXAuY3Jvc3NWZWN0b3JzKCB0aGlzLmFuMiwgdGhpcy5heDEgKSApIDwgMCApIHRoaXMucm90YXRpb25hbExpbWl0TW90b3IyLmFuZ2xlID0gLWxpbWl0ZTtcbiAgICAgICAgZWxzZSB0aGlzLnJvdGF0aW9uYWxMaW1pdE1vdG9yMi5hbmdsZSA9IGxpbWl0ZTtcblxuICAgICAgICB0aGlzLm5vci5jcm9zc1ZlY3RvcnMoIHRoaXMuYXgxLCB0aGlzLmF4MiApLm5vcm1hbGl6ZSgpO1xuICAgICAgICB0aGlzLnRhbi5jcm9zc1ZlY3RvcnMoIHRoaXMubm9yLCB0aGlzLmF4MiApLm5vcm1hbGl6ZSgpO1xuICAgICAgICB0aGlzLmJpbi5jcm9zc1ZlY3RvcnMoIHRoaXMubm9yLCB0aGlzLmF4MSApLm5vcm1hbGl6ZSgpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yMy5wcmVTb2x2ZSh0aW1lU3RlcCxpbnZUaW1lU3RlcCk7XG4gICAgICAgIHRoaXMudDMucHJlU29sdmUodGltZVN0ZXAsaW52VGltZVN0ZXApO1xuXG4gICAgfSxcblxuICAgIHNvbHZlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5yMy5zb2x2ZSgpO1xuICAgICAgICB0aGlzLnQzLnNvbHZlKCk7XG5cbiAgICB9LFxuXG4gICAgcG9zdFNvbHZlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBKb2ludENvbmZpZygpe1xyXG5cclxuICAgIHRoaXMuc2NhbGUgPSAxO1xyXG4gICAgdGhpcy5pbnZTY2FsZSA9IDE7XHJcblxyXG4gICAgLy8gVGhlIGZpcnN0IHJpZ2lkIGJvZHkgb2YgdGhlIGpvaW50LlxyXG4gICAgdGhpcy5ib2R5MSA9IG51bGw7XHJcbiAgICAvLyBUaGUgc2Vjb25kIHJpZ2lkIGJvZHkgb2YgdGhlIGpvaW50LlxyXG4gICAgdGhpcy5ib2R5MiA9IG51bGw7XHJcbiAgICAvLyBUaGUgYW5jaG9yIHBvaW50IG9uIHRoZSBmaXJzdCByaWdpZCBib2R5IGluIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgdGhpcy5sb2NhbEFuY2hvclBvaW50MSA9IG5ldyBWZWMzKCk7XHJcbiAgICAvLyAgVGhlIGFuY2hvciBwb2ludCBvbiB0aGUgc2Vjb25kIHJpZ2lkIGJvZHkgaW4gbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICB0aGlzLmxvY2FsQW5jaG9yUG9pbnQyID0gbmV3IFZlYzMoKTtcclxuICAgIC8vIFRoZSBheGlzIGluIHRoZSBmaXJzdCBib2R5J3MgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAvLyBoaXMgcHJvcGVydHkgaXMgYXZhaWxhYmxlIGluIHNvbWUgam9pbnRzLlxyXG4gICAgdGhpcy5sb2NhbEF4aXMxID0gbmV3IFZlYzMoKTtcclxuICAgIC8vIFRoZSBheGlzIGluIHRoZSBzZWNvbmQgYm9keSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBhdmFpbGFibGUgaW4gc29tZSBqb2ludHMuXHJcbiAgICB0aGlzLmxvY2FsQXhpczIgPSBuZXcgVmVjMygpO1xyXG4gICAgLy8gIFdoZXRoZXIgYWxsb3cgY29sbGlzaW9uIGJldHdlZW4gY29ubmVjdGVkIHJpZ2lkIGJvZGllcyBvciBub3QuXHJcbiAgICB0aGlzLmFsbG93Q29sbGlzaW9uID0gZmFsc2U7XHJcblxyXG59XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGhvbGRzIG1hc3MgaW5mb3JtYXRpb24gb2YgYSBzaGFwZS5cclxuICogQGF1dGhvciBsby10aFxyXG4gKiBAYXV0aG9yIHNhaGFyYW5cclxuICovXHJcblxyXG5mdW5jdGlvbiBNYXNzSW5mbyAoKXtcclxuXHJcbiAgICAvLyBNYXNzIG9mIHRoZSBzaGFwZS5cclxuICAgIHRoaXMubWFzcyA9IDA7XHJcblxyXG4gICAgLy8gVGhlIG1vbWVudCBpbmVydGlhIG9mIHRoZSBzaGFwZS5cclxuICAgIHRoaXMuaW5lcnRpYSA9IG5ldyBNYXQzMygpO1xyXG5cclxufVxuXG4vKipcbiogQSBsaW5rIGxpc3Qgb2YgY29udGFjdHMuXG4qIEBhdXRob3Igc2FoYXJhblxuKi9cbmZ1bmN0aW9uIENvbnRhY3RMaW5rICggY29udGFjdCApe1xuICAgIFxuXHQvLyBUaGUgcHJldmlvdXMgY29udGFjdCBsaW5rLlxuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgLy8gVGhlIG5leHQgY29udGFjdCBsaW5rLlxuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgLy8gVGhlIHNoYXBlIG9mIHRoZSBjb250YWN0LlxuICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgIC8vIFRoZSBvdGhlciByaWdpZCBib2R5LlxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgLy8gVGhlIGNvbnRhY3Qgb2YgdGhlIGxpbmsuXG4gICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcblxufVxuXG5mdW5jdGlvbiBJbXB1bHNlRGF0YUJ1ZmZlciAoKXtcblxuICAgIHRoaXMubHAxWCA9IE5hTjtcbiAgICB0aGlzLmxwMVkgPSBOYU47XG4gICAgdGhpcy5scDFaID0gTmFOO1xuICAgIHRoaXMubHAyWCA9IE5hTjtcbiAgICB0aGlzLmxwMlkgPSBOYU47XG4gICAgdGhpcy5scDJaID0gTmFOO1xuICAgIHRoaXMuaW1wdWxzZSA9IE5hTjtcblxufVxuXG4vKipcbiogVGhlIGNsYXNzIGhvbGRzIGRldGFpbHMgb2YgdGhlIGNvbnRhY3QgcG9pbnQuXG4qIEBhdXRob3Igc2FoYXJhblxuKi9cblxuZnVuY3Rpb24gTWFuaWZvbGRQb2ludCgpe1xuXG4gICAgLy8gV2hldGhlciB0aGlzIG1hbmlmb2xkIHBvaW50IGlzIHBlcnNpc3Rpbmcgb3Igbm90LlxuICAgIHRoaXMud2FybVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAvLyAgVGhlIHBvc2l0aW9uIG9mIHRoaXMgbWFuaWZvbGQgcG9pbnQuXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgLy8gVGhlIHBvc2l0aW9uIGluIHRoZSBmaXJzdCBzaGFwZSdzIGNvb3JkaW5hdGUuXG4gICAgdGhpcy5sb2NhbFBvaW50MSA9IG5ldyBWZWMzKCk7XG4gICAgLy8gIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2Vjb25kIHNoYXBlJ3MgY29vcmRpbmF0ZS5cbiAgICB0aGlzLmxvY2FsUG9pbnQyID0gbmV3IFZlYzMoKTtcbiAgICAvLyBUaGUgbm9ybWFsIHZlY3RvciBvZiB0aGlzIG1hbmlmb2xkIHBvaW50LlxuICAgIHRoaXMubm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAvLyBUaGUgdGFuZ2VudCB2ZWN0b3Igb2YgdGhpcyBtYW5pZm9sZCBwb2ludC5cbiAgICB0aGlzLnRhbmdlbnQgPSBuZXcgVmVjMygpO1xuICAgIC8vIFRoZSBiaW5vcm1hbCB2ZWN0b3Igb2YgdGhpcyBtYW5pZm9sZCBwb2ludC5cbiAgICB0aGlzLmJpbm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAvLyBUaGUgaW1wdWxzZSBpbiBub3JtYWwgZGlyZWN0aW9uLlxuICAgIHRoaXMubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgLy8gVGhlIGltcHVsc2UgaW4gdGFuZ2VudCBkaXJlY3Rpb24uXG4gICAgdGhpcy50YW5nZW50SW1wdWxzZSA9IDA7XG4gICAgLy8gVGhlIGltcHVsc2UgaW4gYmlub3JtYWwgZGlyZWN0aW9uLlxuICAgIHRoaXMuYmlub3JtYWxJbXB1bHNlID0gMDtcbiAgICAvLyBUaGUgZGVub21pbmF0b3IgaW4gbm9ybWFsIGRpcmVjdGlvbi5cbiAgICB0aGlzLm5vcm1hbERlbm9taW5hdG9yID0gMDtcbiAgICAvLyBUaGUgZGVub21pbmF0b3IgaW4gdGFuZ2VudCBkaXJlY3Rpb24uXG4gICAgdGhpcy50YW5nZW50RGVub21pbmF0b3IgPSAwO1xuICAgIC8vIFRoZSBkZW5vbWluYXRvciBpbiBiaW5vcm1hbCBkaXJlY3Rpb24uXG4gICAgdGhpcy5iaW5vcm1hbERlbm9taW5hdG9yID0gMDtcbiAgICAvLyBUaGUgZGVwdGggb2YgcGVuZXRyYXRpb24uXG4gICAgdGhpcy5wZW5ldHJhdGlvbiA9IDA7XG5cbn1cblxuLyoqXG4qIEEgY29udGFjdCBtYW5pZm9sZCBiZXR3ZWVuIHR3byBzaGFwZXMuXG4qIEBhdXRob3Igc2FoYXJhblxuKiBAYXV0aG9yIGxvLXRoXG4qL1xuXG5mdW5jdGlvbiBDb250YWN0TWFuaWZvbGQgKCkge1xuXG4gICAgLy8gVGhlIGZpcnN0IHJpZ2lkIGJvZHkuXG4gICAgdGhpcy5ib2R5MSA9IG51bGw7XG4gICAgLy8gVGhlIHNlY29uZCByaWdpZCBib2R5LlxuICAgIHRoaXMuYm9keTIgPSBudWxsO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgbWFuaWZvbGQgcG9pbnRzLlxuICAgIHRoaXMubnVtUG9pbnRzID0gMDtcbiAgICAvLyBUaGUgbWFuaWZvbGQgcG9pbnRzLlxuICAgIHRoaXMucG9pbnRzID0gW1xuICAgICAgICBuZXcgTWFuaWZvbGRQb2ludCgpLFxuICAgICAgICBuZXcgTWFuaWZvbGRQb2ludCgpLFxuICAgICAgICBuZXcgTWFuaWZvbGRQb2ludCgpLFxuICAgICAgICBuZXcgTWFuaWZvbGRQb2ludCgpXG4gICAgXTtcblxufVxuXG5Db250YWN0TWFuaWZvbGQucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IENvbnRhY3RNYW5pZm9sZCxcblxuICAgIC8vUmVzZXQgdGhlIG1hbmlmb2xkLlxuICAgIHJlc2V0OmZ1bmN0aW9uKCBzaGFwZTEsIHNoYXBlMiApe1xuXG4gICAgICAgIHRoaXMuYm9keTEgPSBzaGFwZTEucGFyZW50O1xuICAgICAgICB0aGlzLmJvZHkyID0gc2hhcGUyLnBhcmVudDtcbiAgICAgICAgdGhpcy5udW1Qb2ludHMgPSAwO1xuXG4gICAgfSxcblxuICAgIC8vICBBZGQgYSBwb2ludCBpbnRvIHRoaXMgbWFuaWZvbGQuXG4gICAgYWRkUG9pbnRWZWM6IGZ1bmN0aW9uICggcG9zLCBub3JtLCBwZW5ldHJhdGlvbiwgZmxpcCApIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHNbIHRoaXMubnVtUG9pbnRzKysgXTtcblxuICAgICAgICBwLnBvc2l0aW9uLmNvcHkoIHBvcyApO1xuICAgICAgICBwLmxvY2FsUG9pbnQxLnN1YiggcG9zLCB0aGlzLmJvZHkxLnBvc2l0aW9uICkuYXBwbHlNYXRyaXgzKCB0aGlzLmJvZHkxLnJvdGF0aW9uICk7XG4gICAgICAgIHAubG9jYWxQb2ludDIuc3ViKCBwb3MsIHRoaXMuYm9keTIucG9zaXRpb24gKS5hcHBseU1hdHJpeDMoIHRoaXMuYm9keTIucm90YXRpb24gKTtcblxuICAgICAgICBwLm5vcm1hbC5jb3B5KCBub3JtICk7XG4gICAgICAgIGlmKCBmbGlwICkgcC5ub3JtYWwubmVnYXRlKCk7XG5cbiAgICAgICAgcC5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICAgICAgcC5wZW5ldHJhdGlvbiA9IHBlbmV0cmF0aW9uO1xuICAgICAgICBwLndhcm1TdGFydGVkID0gZmFsc2U7XG4gICAgICAgIFxuICAgIH0sXG5cbiAgICAvLyAgQWRkIGEgcG9pbnQgaW50byB0aGlzIG1hbmlmb2xkLlxuICAgIGFkZFBvaW50OiBmdW5jdGlvbiAoIHgsIHksIHosIG54LCBueSwgbnosIHBlbmV0cmF0aW9uLCBmbGlwICkge1xuICAgICAgICBcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50c1sgdGhpcy5udW1Qb2ludHMrKyBdO1xuXG4gICAgICAgIHAucG9zaXRpb24uc2V0KCB4LCB5LCB6ICk7XG4gICAgICAgIHAubG9jYWxQb2ludDEuc3ViKCBwLnBvc2l0aW9uLCB0aGlzLmJvZHkxLnBvc2l0aW9uICkuYXBwbHlNYXRyaXgzKCB0aGlzLmJvZHkxLnJvdGF0aW9uICk7XG4gICAgICAgIHAubG9jYWxQb2ludDIuc3ViKCBwLnBvc2l0aW9uLCB0aGlzLmJvZHkyLnBvc2l0aW9uICkuYXBwbHlNYXRyaXgzKCB0aGlzLmJvZHkyLnJvdGF0aW9uICk7XG5cbiAgICAgICAgcC5ub3JtYWxJbXB1bHNlID0gMDtcblxuICAgICAgICBwLm5vcm1hbC5zZXQoIG54LCBueSwgbnogKTtcbiAgICAgICAgaWYoIGZsaXAgKSBwLm5vcm1hbC5uZWdhdGUoKTtcblxuICAgICAgICBwLnBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247XG4gICAgICAgIHAud2FybVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgfVxufTtcblxuZnVuY3Rpb24gQ29udGFjdFBvaW50RGF0YUJ1ZmZlciAoKXtcblxuICAgIHRoaXMubm9yID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRhbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5iaW4gPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy5ub3JVMSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50YW5VMSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5iaW5VMSA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLm5vclUyID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRhblUyID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmJpblUyID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMubm9yVDEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudGFuVDEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYmluVDEgPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy5ub3JUMiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50YW5UMiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5iaW5UMiA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLm5vclRVMSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50YW5UVTEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYmluVFUxID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMubm9yVFUyID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRhblRVMiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5iaW5UVTIgPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy5ub3JJbXAgPSAwO1xuICAgIHRoaXMudGFuSW1wID0gMDtcbiAgICB0aGlzLmJpbkltcCA9IDA7XG5cbiAgICB0aGlzLm5vckRlbiA9IDA7XG4gICAgdGhpcy50YW5EZW4gPSAwO1xuICAgIHRoaXMuYmluRGVuID0gMDtcblxuICAgIHRoaXMubm9yVGFyID0gMDtcblxuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gZmFsc2U7XG5cbn1cblxuLyoqXG4qIC4uLlxuKiBAYXV0aG9yIHNhaGFyYW5cbiovXG5mdW5jdGlvbiBDb250YWN0Q29uc3RyYWludCAoIG1hbmlmb2xkICl7XG4gICAgXG4gICAgQ29uc3RyYWludC5jYWxsKCB0aGlzICk7XG4gICAgLy8gVGhlIGNvbnRhY3QgbWFuaWZvbGQgb2YgdGhlIGNvbnN0cmFpbnQuXG4gICAgdGhpcy5tYW5pZm9sZCA9IG1hbmlmb2xkO1xuICAgIC8vIFRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGUgY29uc3RyYWludC5cbiAgICB0aGlzLnJlc3RpdHV0aW9uPU5hTjtcbiAgICAvLyBUaGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb2YgdGhlIGNvbnN0cmFpbnQuXG4gICAgdGhpcy5mcmljdGlvbj1OYU47XG4gICAgdGhpcy5wMT1udWxsO1xuICAgIHRoaXMucDI9bnVsbDtcbiAgICB0aGlzLmx2MT1udWxsO1xuICAgIHRoaXMubHYyPW51bGw7XG4gICAgdGhpcy5hdjE9bnVsbDtcbiAgICB0aGlzLmF2Mj1udWxsO1xuICAgIHRoaXMuaTE9bnVsbDtcbiAgICB0aGlzLmkyPW51bGw7XG5cbiAgICAvL3RoaXMuaWkxID0gbnVsbDtcbiAgICAvL3RoaXMuaWkyID0gbnVsbDtcblxuICAgIHRoaXMudG1wID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRtcEMxID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRtcEMyID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMudG1wUDEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudG1wUDIgPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy50bXBsdjEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudG1wbHYyID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnRtcGF2MSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50bXBhdjIgPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy5tMT1OYU47XG4gICAgdGhpcy5tMj1OYU47XG4gICAgdGhpcy5udW09MDtcbiAgICBcbiAgICB0aGlzLnBzID0gbWFuaWZvbGQucG9pbnRzO1xuICAgIHRoaXMuY3MgPSBuZXcgQ29udGFjdFBvaW50RGF0YUJ1ZmZlcigpO1xuICAgIHRoaXMuY3MubmV4dCA9IG5ldyBDb250YWN0UG9pbnREYXRhQnVmZmVyKCk7XG4gICAgdGhpcy5jcy5uZXh0Lm5leHQgPSBuZXcgQ29udGFjdFBvaW50RGF0YUJ1ZmZlcigpO1xuICAgIHRoaXMuY3MubmV4dC5uZXh0Lm5leHQgPSBuZXcgQ29udGFjdFBvaW50RGF0YUJ1ZmZlcigpO1xufVxuXG5Db250YWN0Q29uc3RyYWludC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDb25zdHJhaW50LnByb3RvdHlwZSApLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogQ29udGFjdENvbnN0cmFpbnQsXG5cbiAgICAvLyBBdHRhY2ggdGhlIGNvbnN0cmFpbnQgdG8gdGhlIGJvZGllcy5cbiAgICBhdHRhY2g6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdGhpcy5wMT10aGlzLmJvZHkxLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnAyPXRoaXMuYm9keTIucG9zaXRpb247XG4gICAgICAgIHRoaXMubHYxPXRoaXMuYm9keTEubGluZWFyVmVsb2NpdHk7XG4gICAgICAgIHRoaXMuYXYxPXRoaXMuYm9keTEuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICB0aGlzLmx2Mj10aGlzLmJvZHkyLmxpbmVhclZlbG9jaXR5O1xuICAgICAgICB0aGlzLmF2Mj10aGlzLmJvZHkyLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgdGhpcy5pMT10aGlzLmJvZHkxLmludmVyc2VJbmVydGlhO1xuICAgICAgICB0aGlzLmkyPXRoaXMuYm9keTIuaW52ZXJzZUluZXJ0aWE7XG5cbiAgICB9LFxuXG4gICAgLy8gRGV0YWNoIHRoZSBjb25zdHJhaW50IGZyb20gdGhlIGJvZGllcy5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdGhpcy5wMT1udWxsO1xuICAgICAgICB0aGlzLnAyPW51bGw7XG4gICAgICAgIHRoaXMubHYxPW51bGw7XG4gICAgICAgIHRoaXMubHYyPW51bGw7XG4gICAgICAgIHRoaXMuYXYxPW51bGw7XG4gICAgICAgIHRoaXMuYXYyPW51bGw7XG4gICAgICAgIHRoaXMuaTE9bnVsbDtcbiAgICAgICAgdGhpcy5pMj1udWxsO1xuXG4gICAgfSxcblxuICAgIHByZVNvbHZlOiBmdW5jdGlvbiggdGltZVN0ZXAsIGludlRpbWVTdGVwICl7XG5cbiAgICAgICAgdGhpcy5tMSA9IHRoaXMuYm9keTEuaW52ZXJzZU1hc3M7XG4gICAgICAgIHRoaXMubTIgPSB0aGlzLmJvZHkyLmludmVyc2VNYXNzO1xuXG4gICAgICAgIHZhciBtMW0yID0gdGhpcy5tMSArIHRoaXMubTI7XG5cbiAgICAgICAgdGhpcy5udW0gPSB0aGlzLm1hbmlmb2xkLm51bVBvaW50cztcblxuICAgICAgICB2YXIgYyA9IHRoaXMuY3M7XG4gICAgICAgIHZhciBwLCBydm4sIGxlbiwgbm9ySW1wLCBub3JUYXIsIHNlcFYsIGkxLCBpMjtcblxuICAgICAgICBmb3IoIHZhciBpPTA7IGkgPCB0aGlzLm51bTsgaSsrICl7XG5cbiAgICAgICAgICAgIHAgPSB0aGlzLnBzW2ldO1xuXG4gICAgICAgICAgICB0aGlzLnRtcFAxLnN1YiggcC5wb3NpdGlvbiwgdGhpcy5wMSApO1xuICAgICAgICAgICAgdGhpcy50bXBQMi5zdWIoIHAucG9zaXRpb24sIHRoaXMucDIgKTtcblxuICAgICAgICAgICAgdGhpcy50bXBDMS5jcm9zc1ZlY3RvcnMoIHRoaXMuYXYxLCB0aGlzLnRtcFAxICk7XG4gICAgICAgICAgICB0aGlzLnRtcEMyLmNyb3NzVmVjdG9ycyggdGhpcy5hdjIsIHRoaXMudG1wUDIgKTtcblxuICAgICAgICAgICAgYy5ub3JJbXAgPSBwLm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICBjLnRhbkltcCA9IHAudGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICBjLmJpbkltcCA9IHAuYmlub3JtYWxJbXB1bHNlO1xuXG4gICAgICAgICAgICBjLm5vci5jb3B5KCBwLm5vcm1hbCApO1xuXG4gICAgICAgICAgICB0aGlzLnRtcC5zZXQoXG5cbiAgICAgICAgICAgICAgICAoIHRoaXMubHYyLnggKyB0aGlzLnRtcEMyLnggKSAtICggdGhpcy5sdjEueCArIHRoaXMudG1wQzEueCApLFxuICAgICAgICAgICAgICAgICggdGhpcy5sdjIueSArIHRoaXMudG1wQzIueSApIC0gKCB0aGlzLmx2MS55ICsgdGhpcy50bXBDMS55ICksXG4gICAgICAgICAgICAgICAgKCB0aGlzLmx2Mi56ICsgdGhpcy50bXBDMi56ICkgLSAoIHRoaXMubHYxLnogKyB0aGlzLnRtcEMxLnogKVxuXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBydm4gPSBfTWF0aC5kb3RWZWN0b3JzKCBjLm5vciwgdGhpcy50bXAgKTtcblxuICAgICAgICAgICAgYy50YW4uc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMudG1wLnggLSBydm4gKiBjLm5vci54LFxuICAgICAgICAgICAgICAgIHRoaXMudG1wLnkgLSBydm4gKiBjLm5vci55LFxuICAgICAgICAgICAgICAgIHRoaXMudG1wLnogLSBydm4gKiBjLm5vci56XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZW4gPSBfTWF0aC5kb3RWZWN0b3JzKCBjLnRhbiwgYy50YW4gKTtcblxuICAgICAgICAgICAgaWYoIGxlbiA8PSAwLjA0ICkge1xuICAgICAgICAgICAgICAgIGMudGFuLnRhbmdlbnQoIGMubm9yICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMudGFuLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICBjLmJpbi5jcm9zc1ZlY3RvcnMoIGMubm9yLCBjLnRhbiApO1xuXG4gICAgICAgICAgICBjLm5vclUxLnNjYWxlKCBjLm5vciwgdGhpcy5tMSApO1xuICAgICAgICAgICAgYy5ub3JVMi5zY2FsZSggYy5ub3IsIHRoaXMubTIgKTtcblxuICAgICAgICAgICAgYy50YW5VMS5zY2FsZSggYy50YW4sIHRoaXMubTEgKTtcbiAgICAgICAgICAgIGMudGFuVTIuc2NhbGUoIGMudGFuLCB0aGlzLm0yICk7XG5cbiAgICAgICAgICAgIGMuYmluVTEuc2NhbGUoIGMuYmluLCB0aGlzLm0xICk7XG4gICAgICAgICAgICBjLmJpblUyLnNjYWxlKCBjLmJpbiwgdGhpcy5tMiApO1xuXG4gICAgICAgICAgICBjLm5vclQxLmNyb3NzVmVjdG9ycyggdGhpcy50bXBQMSwgYy5ub3IgKTtcbiAgICAgICAgICAgIGMudGFuVDEuY3Jvc3NWZWN0b3JzKCB0aGlzLnRtcFAxLCBjLnRhbiApO1xuICAgICAgICAgICAgYy5iaW5UMS5jcm9zc1ZlY3RvcnMoIHRoaXMudG1wUDEsIGMuYmluICk7XG5cbiAgICAgICAgICAgIGMubm9yVDIuY3Jvc3NWZWN0b3JzKCB0aGlzLnRtcFAyLCBjLm5vciApO1xuICAgICAgICAgICAgYy50YW5UMi5jcm9zc1ZlY3RvcnMoIHRoaXMudG1wUDIsIGMudGFuICk7XG4gICAgICAgICAgICBjLmJpblQyLmNyb3NzVmVjdG9ycyggdGhpcy50bXBQMiwgYy5iaW4gKTtcblxuICAgICAgICAgICAgaTEgPSB0aGlzLmkxO1xuICAgICAgICAgICAgaTIgPSB0aGlzLmkyO1xuXG4gICAgICAgICAgICBjLm5vclRVMS5jb3B5KCBjLm5vclQxICkuYXBwbHlNYXRyaXgzKCBpMSwgdHJ1ZSApO1xuICAgICAgICAgICAgYy50YW5UVTEuY29weSggYy50YW5UMSApLmFwcGx5TWF0cml4MyggaTEsIHRydWUgKTtcbiAgICAgICAgICAgIGMuYmluVFUxLmNvcHkoIGMuYmluVDEgKS5hcHBseU1hdHJpeDMoIGkxLCB0cnVlICk7XG5cbiAgICAgICAgICAgIGMubm9yVFUyLmNvcHkoIGMubm9yVDIgKS5hcHBseU1hdHJpeDMoIGkyLCB0cnVlICk7XG4gICAgICAgICAgICBjLnRhblRVMi5jb3B5KCBjLnRhblQyICkuYXBwbHlNYXRyaXgzKCBpMiwgdHJ1ZSApO1xuICAgICAgICAgICAgYy5iaW5UVTIuY29weSggYy5iaW5UMiApLmFwcGx5TWF0cml4MyggaTIsIHRydWUgKTtcblxuICAgICAgICAgICAgLypjLm5vclRVMS5tdWxNYXQoIHRoaXMuaTEsIGMubm9yVDEgKTtcbiAgICAgICAgICAgIGMudGFuVFUxLm11bE1hdCggdGhpcy5pMSwgYy50YW5UMSApO1xuICAgICAgICAgICAgYy5iaW5UVTEubXVsTWF0KCB0aGlzLmkxLCBjLmJpblQxICk7XG5cbiAgICAgICAgICAgIGMubm9yVFUyLm11bE1hdCggdGhpcy5pMiwgYy5ub3JUMiApO1xuICAgICAgICAgICAgYy50YW5UVTIubXVsTWF0KCB0aGlzLmkyLCBjLnRhblQyICk7XG4gICAgICAgICAgICBjLmJpblRVMi5tdWxNYXQoIHRoaXMuaTIsIGMuYmluVDIgKTsqL1xuXG4gICAgICAgICAgICB0aGlzLnRtcEMxLmNyb3NzVmVjdG9ycyggYy5ub3JUVTEsIHRoaXMudG1wUDEgKTtcbiAgICAgICAgICAgIHRoaXMudG1wQzIuY3Jvc3NWZWN0b3JzKCBjLm5vclRVMiwgdGhpcy50bXBQMiApO1xuICAgICAgICAgICAgdGhpcy50bXAuYWRkKCB0aGlzLnRtcEMxLCB0aGlzLnRtcEMyICk7XG4gICAgICAgICAgICBjLm5vckRlbiA9IDEgLyAoIG0xbTIgK19NYXRoLmRvdFZlY3RvcnMoIGMubm9yLCB0aGlzLnRtcCApKTtcblxuICAgICAgICAgICAgdGhpcy50bXBDMS5jcm9zc1ZlY3RvcnMoIGMudGFuVFUxLCB0aGlzLnRtcFAxICk7XG4gICAgICAgICAgICB0aGlzLnRtcEMyLmNyb3NzVmVjdG9ycyggYy50YW5UVTIsIHRoaXMudG1wUDIgKTtcbiAgICAgICAgICAgIHRoaXMudG1wLmFkZCggdGhpcy50bXBDMSwgdGhpcy50bXBDMiApO1xuICAgICAgICAgICAgYy50YW5EZW4gPSAxIC8gKCBtMW0yICtfTWF0aC5kb3RWZWN0b3JzKCBjLnRhbiwgdGhpcy50bXAgKSk7XG5cbiAgICAgICAgICAgIHRoaXMudG1wQzEuY3Jvc3NWZWN0b3JzKCBjLmJpblRVMSwgdGhpcy50bXBQMSApO1xuICAgICAgICAgICAgdGhpcy50bXBDMi5jcm9zc1ZlY3RvcnMoIGMuYmluVFUyLCB0aGlzLnRtcFAyICk7XG4gICAgICAgICAgICB0aGlzLnRtcC5hZGQoIHRoaXMudG1wQzEsIHRoaXMudG1wQzIgKTtcbiAgICAgICAgICAgIGMuYmluRGVuID0gMSAvICggbTFtMiArX01hdGguZG90VmVjdG9ycyggYy5iaW4sIHRoaXMudG1wICkpO1xuXG4gICAgICAgICAgICBpZiggcC53YXJtU3RhcnRlZCApe1xuXG4gICAgICAgICAgICAgICAgbm9ySW1wID0gcC5ub3JtYWxJbXB1bHNlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sdjEuYWRkU2NhbGVkVmVjdG9yKCBjLm5vclUxLCBub3JJbXAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF2MS5hZGRTY2FsZWRWZWN0b3IoIGMubm9yVFUxLCBub3JJbXAgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubHYyLnN1YlNjYWxlZFZlY3RvciggYy5ub3JVMiwgbm9ySW1wICk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdjIuc3ViU2NhbGVkVmVjdG9yKCBjLm5vclRVMiwgbm9ySW1wICk7XG5cbiAgICAgICAgICAgICAgICBjLm5vckltcCA9IG5vckltcDtcbiAgICAgICAgICAgICAgICBjLnRhbkltcCA9IDA7XG4gICAgICAgICAgICAgICAgYy5iaW5JbXAgPSAwO1xuICAgICAgICAgICAgICAgIHJ2biA9IDA7IC8vIGRpc2FibGUgYm91bmNpbmdcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGMubm9ySW1wPTA7XG4gICAgICAgICAgICAgICAgYy50YW5JbXA9MDtcbiAgICAgICAgICAgICAgICBjLmJpbkltcD0wO1xuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYocnZuPi0xKSBydm49MDsgLy8gZGlzYWJsZSBib3VuY2luZ1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBub3JUYXIgPSB0aGlzLnJlc3RpdHV0aW9uKi1ydm47XG4gICAgICAgICAgICBzZXBWID0gLShwLnBlbmV0cmF0aW9uKzAuMDA1KSppbnZUaW1lU3RlcCowLjA1OyAvLyBhbGxvdyAwLjVjbSBlcnJvclxuICAgICAgICAgICAgaWYobm9yVGFyPHNlcFYpIG5vclRhcj1zZXBWO1xuICAgICAgICAgICAgYy5ub3JUYXIgPSBub3JUYXI7XG4gICAgICAgICAgICBjLmxhc3QgPSBpPT10aGlzLm51bS0xO1xuICAgICAgICAgICAgYyA9IGMubmV4dDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzb2x2ZTogZnVuY3Rpb24oKXtcblxuICAgICAgICB0aGlzLnRtcGx2MS5jb3B5KCB0aGlzLmx2MSApO1xuICAgICAgICB0aGlzLnRtcGx2Mi5jb3B5KCB0aGlzLmx2MiApO1xuICAgICAgICB0aGlzLnRtcGF2MS5jb3B5KCB0aGlzLmF2MSApO1xuICAgICAgICB0aGlzLnRtcGF2Mi5jb3B5KCB0aGlzLmF2MiApO1xuXG4gICAgICAgIHZhciBvbGRJbXAxLCBuZXdJbXAxLCBvbGRJbXAyLCBuZXdJbXAyLCBydm4sIG5vckltcCwgdGFuSW1wLCBiaW5JbXAsIG1heCwgbGVuO1xuXG4gICAgICAgIHZhciBjID0gdGhpcy5jcztcblxuICAgICAgICB3aGlsZSh0cnVlKXtcblxuICAgICAgICAgICAgbm9ySW1wID0gYy5ub3JJbXA7XG4gICAgICAgICAgICB0YW5JbXAgPSBjLnRhbkltcDtcbiAgICAgICAgICAgIGJpbkltcCA9IGMuYmluSW1wO1xuICAgICAgICAgICAgbWF4ID0gLW5vckltcCAqIHRoaXMuZnJpY3Rpb247XG5cbiAgICAgICAgICAgIHRoaXMudG1wLnN1YiggdGhpcy50bXBsdjIsIHRoaXMudG1wbHYxICk7XG5cbiAgICAgICAgICAgIHJ2biA9IF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMudG1wLCBjLnRhbiApICsgX01hdGguZG90VmVjdG9ycyggdGhpcy50bXBhdjIsIGMudGFuVDIgKSAtIF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMudG1wYXYxLCBjLnRhblQxICk7XG4gICAgICAgIFxuICAgICAgICAgICAgb2xkSW1wMSA9IHRhbkltcDtcbiAgICAgICAgICAgIG5ld0ltcDEgPSBydm4qYy50YW5EZW47XG4gICAgICAgICAgICB0YW5JbXAgKz0gbmV3SW1wMTtcblxuICAgICAgICAgICAgcnZuID0gX01hdGguZG90VmVjdG9ycyggdGhpcy50bXAsIGMuYmluICkgKyBfTWF0aC5kb3RWZWN0b3JzKCB0aGlzLnRtcGF2MiwgYy5iaW5UMiApIC0gX01hdGguZG90VmVjdG9ycyggdGhpcy50bXBhdjEsIGMuYmluVDEgKTtcbiAgICAgIFxuICAgICAgICAgICAgb2xkSW1wMiA9IGJpbkltcDtcbiAgICAgICAgICAgIG5ld0ltcDIgPSBydm4qYy5iaW5EZW47XG4gICAgICAgICAgICBiaW5JbXAgKz0gbmV3SW1wMjtcblxuICAgICAgICAgICAgLy8gY29uZSBmcmljdGlvbiBjbGFtcFxuICAgICAgICAgICAgbGVuID0gdGFuSW1wKnRhbkltcCArIGJpbkltcCpiaW5JbXA7XG4gICAgICAgICAgICBpZihsZW4gPiBtYXggKiBtYXggKXtcbiAgICAgICAgICAgICAgICBsZW4gPSBtYXgvX01hdGguc3FydChsZW4pO1xuICAgICAgICAgICAgICAgIHRhbkltcCAqPSBsZW47XG4gICAgICAgICAgICAgICAgYmluSW1wICo9IGxlbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3SW1wMSA9IHRhbkltcC1vbGRJbXAxO1xuICAgICAgICAgICAgbmV3SW1wMiA9IGJpbkltcC1vbGRJbXAyO1xuXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICB0aGlzLnRtcC5zZXQoIFxuICAgICAgICAgICAgICAgIGMudGFuVTEueCpuZXdJbXAxICsgYy5iaW5VMS54Km5ld0ltcDIsXG4gICAgICAgICAgICAgICAgYy50YW5VMS55Km5ld0ltcDEgKyBjLmJpblUxLnkqbmV3SW1wMixcbiAgICAgICAgICAgICAgICBjLnRhblUxLnoqbmV3SW1wMSArIGMuYmluVTEueipuZXdJbXAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnRtcGx2MS5hZGRFcXVhbCggdGhpcy50bXAgKTtcblxuICAgICAgICAgICAgdGhpcy50bXAuc2V0KFxuICAgICAgICAgICAgICAgIGMudGFuVFUxLngqbmV3SW1wMSArIGMuYmluVFUxLngqbmV3SW1wMixcbiAgICAgICAgICAgICAgICBjLnRhblRVMS55Km5ld0ltcDEgKyBjLmJpblRVMS55Km5ld0ltcDIsXG4gICAgICAgICAgICAgICAgYy50YW5UVTEueipuZXdJbXAxICsgYy5iaW5UVTEueipuZXdJbXAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnRtcGF2MS5hZGRFcXVhbCggdGhpcy50bXAgKTtcblxuICAgICAgICAgICAgdGhpcy50bXAuc2V0KFxuICAgICAgICAgICAgICAgIGMudGFuVTIueCpuZXdJbXAxICsgYy5iaW5VMi54Km5ld0ltcDIsXG4gICAgICAgICAgICAgICAgYy50YW5VMi55Km5ld0ltcDEgKyBjLmJpblUyLnkqbmV3SW1wMixcbiAgICAgICAgICAgICAgICBjLnRhblUyLnoqbmV3SW1wMSArIGMuYmluVTIueipuZXdJbXAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnRtcGx2Mi5zdWJFcXVhbCggdGhpcy50bXAgKTtcblxuICAgICAgICAgICAgdGhpcy50bXAuc2V0KFxuICAgICAgICAgICAgICAgIGMudGFuVFUyLngqbmV3SW1wMSArIGMuYmluVFUyLngqbmV3SW1wMixcbiAgICAgICAgICAgICAgICBjLnRhblRVMi55Km5ld0ltcDEgKyBjLmJpblRVMi55Km5ld0ltcDIsXG4gICAgICAgICAgICAgICAgYy50YW5UVTIueipuZXdJbXAxICsgYy5iaW5UVTIueipuZXdJbXAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnRtcGF2Mi5zdWJFcXVhbCggdGhpcy50bXAgKTtcblxuICAgICAgICAgICAgLy8gcmVzdGl0dXRpb24gcGFydFxuXG4gICAgICAgICAgICB0aGlzLnRtcC5zdWIoIHRoaXMudG1wbHYyLCB0aGlzLnRtcGx2MSApO1xuXG4gICAgICAgICAgICBydm4gPSBfTWF0aC5kb3RWZWN0b3JzKCB0aGlzLnRtcCwgYy5ub3IgKSArIF9NYXRoLmRvdFZlY3RvcnMoIHRoaXMudG1wYXYyLCBjLm5vclQyICkgLSBfTWF0aC5kb3RWZWN0b3JzKCB0aGlzLnRtcGF2MSwgYy5ub3JUMSApO1xuXG4gICAgICAgICAgICBvbGRJbXAxID0gbm9ySW1wO1xuICAgICAgICAgICAgbmV3SW1wMSA9IChydm4tYy5ub3JUYXIpKmMubm9yRGVuO1xuICAgICAgICAgICAgbm9ySW1wICs9IG5ld0ltcDE7XG4gICAgICAgICAgICBpZiggbm9ySW1wID4gMCApIG5vckltcCA9IDA7XG5cbiAgICAgICAgICAgIG5ld0ltcDEgPSBub3JJbXAgLSBvbGRJbXAxO1xuXG4gICAgICAgICAgICB0aGlzLnRtcGx2MS5hZGRTY2FsZWRWZWN0b3IoIGMubm9yVTEsIG5ld0ltcDEgKTtcbiAgICAgICAgICAgIHRoaXMudG1wYXYxLmFkZFNjYWxlZFZlY3RvciggYy5ub3JUVTEsIG5ld0ltcDEgKTtcbiAgICAgICAgICAgIHRoaXMudG1wbHYyLnN1YlNjYWxlZFZlY3RvciggYy5ub3JVMiwgbmV3SW1wMSApO1xuICAgICAgICAgICAgdGhpcy50bXBhdjIuc3ViU2NhbGVkVmVjdG9yKCBjLm5vclRVMiwgbmV3SW1wMSApO1xuXG4gICAgICAgICAgICBjLm5vckltcCA9IG5vckltcDtcbiAgICAgICAgICAgIGMudGFuSW1wID0gdGFuSW1wO1xuICAgICAgICAgICAgYy5iaW5JbXAgPSBiaW5JbXA7XG5cbiAgICAgICAgICAgIGlmKGMubGFzdClicmVhaztcbiAgICAgICAgICAgIGMgPSBjLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmx2MS5jb3B5KCB0aGlzLnRtcGx2MSApO1xuICAgICAgICB0aGlzLmx2Mi5jb3B5KCB0aGlzLnRtcGx2MiApO1xuICAgICAgICB0aGlzLmF2MS5jb3B5KCB0aGlzLnRtcGF2MSApO1xuICAgICAgICB0aGlzLmF2Mi5jb3B5KCB0aGlzLnRtcGF2MiApO1xuXG4gICAgfSxcblxuICAgIHBvc3RTb2x2ZTogZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgYyA9IHRoaXMuY3MsIHA7XG4gICAgICAgIHZhciBpID0gdGhpcy5udW07XG4gICAgICAgIHdoaWxlKGktLSl7XG4gICAgICAgIC8vZm9yKHZhciBpPTA7aTx0aGlzLm51bTtpKyspe1xuICAgICAgICAgICAgcCA9IHRoaXMucHNbaV07XG4gICAgICAgICAgICBwLm5vcm1hbC5jb3B5KCBjLm5vciApO1xuICAgICAgICAgICAgcC50YW5nZW50LmNvcHkoIGMudGFuICk7XG4gICAgICAgICAgICBwLmJpbm9ybWFsLmNvcHkoIGMuYmluICk7XG5cbiAgICAgICAgICAgIHAubm9ybWFsSW1wdWxzZSA9IGMubm9ySW1wO1xuICAgICAgICAgICAgcC50YW5nZW50SW1wdWxzZSA9IGMudGFuSW1wO1xuICAgICAgICAgICAgcC5iaW5vcm1hbEltcHVsc2UgPSBjLmJpbkltcDtcbiAgICAgICAgICAgIHAubm9ybWFsRGVub21pbmF0b3IgPSBjLm5vckRlbjtcbiAgICAgICAgICAgIHAudGFuZ2VudERlbm9taW5hdG9yID0gYy50YW5EZW47XG4gICAgICAgICAgICBwLmJpbm9ybWFsRGVub21pbmF0b3IgPSBjLmJpbkRlbjtcbiAgICAgICAgICAgIGM9Yy5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuLyoqXG4qIEEgY29udGFjdCBpcyBhIHBhaXIgb2Ygc2hhcGVzIHdob3NlIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyBhcmUgb3ZlcmxhcHBpbmcuXG4qIEBhdXRob3Igc2FoYXJhblxuKi9cblxuZnVuY3Rpb24gQ29udGFjdCgpe1xuXG4gICAgLy8gVGhlIGZpcnN0IHNoYXBlLlxuICAgIHRoaXMuc2hhcGUxID0gbnVsbDtcbiAgICAvLyBUaGUgc2Vjb25kIHNoYXBlLlxuICAgIHRoaXMuc2hhcGUyID0gbnVsbDtcbiAgICAvLyBUaGUgZmlyc3QgcmlnaWQgYm9keS5cbiAgICB0aGlzLmJvZHkxID0gbnVsbDtcbiAgICAvLyBUaGUgc2Vjb25kIHJpZ2lkIGJvZHkuXG4gICAgdGhpcy5ib2R5MiA9IG51bGw7XG4gICAgLy8gVGhlIHByZXZpb3VzIGNvbnRhY3QgaW4gdGhlIHdvcmxkLlxuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgLy8gVGhlIG5leHQgY29udGFjdCBpbiB0aGUgd29ybGQuXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAvLyBJbnRlcm5hbFxuICAgIHRoaXMucGVyc2lzdGluZyA9IGZhbHNlO1xuICAgIC8vIFdoZXRoZXIgYm90aCB0aGUgcmlnaWQgYm9kaWVzIGFyZSBzbGVlcGluZyBvciBub3QuXG4gICAgdGhpcy5zbGVlcGluZyA9IGZhbHNlO1xuICAgIC8vIFRoZSBjb2xsaXNpb24gZGV0ZWN0b3IgYmV0d2VlbiB0d28gc2hhcGVzLlxuICAgIHRoaXMuZGV0ZWN0b3IgPSBudWxsO1xuICAgIC8vIFRoZSBjb250YWN0IGNvbnN0cmFpbnQgb2YgdGhlIGNvbnRhY3QuXG4gICAgdGhpcy5jb25zdHJhaW50ID0gbnVsbDtcbiAgICAvLyBXaGV0aGVyIHRoZSBzaGFwZXMgYXJlIHRvdWNoaW5nIG9yIG5vdC5cbiAgICB0aGlzLnRvdWNoaW5nID0gZmFsc2U7XG4gICAgLy8gc2hhcGVzIGlzIHZlcnkgY2xvc2UgYW5kIHRvdWNoaW5nIFxuICAgIHRoaXMuY2xvc2UgPSBmYWxzZTtcblxuICAgIHRoaXMuZGlzdCA9IF9NYXRoLklORjtcblxuICAgIHRoaXMuYjFMaW5rID0gbmV3IENvbnRhY3RMaW5rKCB0aGlzICk7XG4gICAgdGhpcy5iMkxpbmsgPSBuZXcgQ29udGFjdExpbmsoIHRoaXMgKTtcbiAgICB0aGlzLnMxTGluayA9IG5ldyBDb250YWN0TGluayggdGhpcyApO1xuICAgIHRoaXMuczJMaW5rID0gbmV3IENvbnRhY3RMaW5rKCB0aGlzICk7XG5cbiAgICAvLyBUaGUgY29udGFjdCBtYW5pZm9sZCBvZiB0aGUgY29udGFjdC5cbiAgICB0aGlzLm1hbmlmb2xkID0gbmV3IENvbnRhY3RNYW5pZm9sZCgpO1xuXG4gICAgdGhpcy5idWZmZXIgPSBbXG5cbiAgICAgICAgbmV3IEltcHVsc2VEYXRhQnVmZmVyKCksXG4gICAgICAgIG5ldyBJbXB1bHNlRGF0YUJ1ZmZlcigpLFxuICAgICAgICBuZXcgSW1wdWxzZURhdGFCdWZmZXIoKSxcbiAgICAgICAgbmV3IEltcHVsc2VEYXRhQnVmZmVyKClcblxuICAgIF07XG5cbiAgICB0aGlzLnBvaW50cyA9IHRoaXMubWFuaWZvbGQucG9pbnRzO1xuICAgIHRoaXMuY29uc3RyYWludCA9IG5ldyBDb250YWN0Q29uc3RyYWludCggdGhpcy5tYW5pZm9sZCApO1xuICAgIFxufVxuXG5PYmplY3QuYXNzaWduKCBDb250YWN0LnByb3RvdHlwZSwge1xuXG4gICAgQ29udGFjdDogdHJ1ZSxcblxuICAgIG1peFJlc3RpdHV0aW9uOiBmdW5jdGlvbiAoIHJlc3RpdHV0aW9uMSwgcmVzdGl0dXRpb24yICkge1xuXG4gICAgICAgIHJldHVybiBfTWF0aC5zcXJ0KHJlc3RpdHV0aW9uMSpyZXN0aXR1dGlvbjIpO1xuXG4gICAgfSxcbiAgICBtaXhGcmljdGlvbjogZnVuY3Rpb24gKCBmcmljdGlvbjEsIGZyaWN0aW9uMiApIHtcblxuICAgICAgICByZXR1cm4gX01hdGguc3FydChmcmljdGlvbjEqZnJpY3Rpb24yKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFVwZGF0ZSB0aGUgY29udGFjdCBtYW5pZm9sZC5cbiAgICAqL1xuICAgIHVwZGF0ZU1hbmlmb2xkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5jb25zdHJhaW50LnJlc3RpdHV0aW9uID10aGlzLm1peFJlc3RpdHV0aW9uKHRoaXMuc2hhcGUxLnJlc3RpdHV0aW9uLHRoaXMuc2hhcGUyLnJlc3RpdHV0aW9uKTtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50LmZyaWN0aW9uPXRoaXMubWl4RnJpY3Rpb24odGhpcy5zaGFwZTEuZnJpY3Rpb24sdGhpcy5zaGFwZTIuZnJpY3Rpb24pO1xuICAgICAgICB2YXIgbnVtQnVmZmVycz10aGlzLm1hbmlmb2xkLm51bVBvaW50cztcbiAgICAgICAgdmFyIGkgPSBudW1CdWZmZXJzO1xuICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAvL2Zvcih2YXIgaT0wO2k8bnVtQnVmZmVycztpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgICAgICBiLmxwMVg9cC5sb2NhbFBvaW50MS54O1xuICAgICAgICAgICAgYi5scDFZPXAubG9jYWxQb2ludDEueTtcbiAgICAgICAgICAgIGIubHAxWj1wLmxvY2FsUG9pbnQxLno7XG4gICAgICAgICAgICBiLmxwMlg9cC5sb2NhbFBvaW50Mi54O1xuICAgICAgICAgICAgYi5scDJZPXAubG9jYWxQb2ludDIueTtcbiAgICAgICAgICAgIGIubHAyWj1wLmxvY2FsUG9pbnQyLno7XG4gICAgICAgICAgICBiLmltcHVsc2U9cC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFuaWZvbGQubnVtUG9pbnRzPTA7XG4gICAgICAgIHRoaXMuZGV0ZWN0b3IuZGV0ZWN0Q29sbGlzaW9uKHRoaXMuc2hhcGUxLHRoaXMuc2hhcGUyLHRoaXMubWFuaWZvbGQpO1xuICAgICAgICB2YXIgbnVtPXRoaXMubWFuaWZvbGQubnVtUG9pbnRzO1xuICAgICAgICBpZihudW09PTApe1xuICAgICAgICAgICAgdGhpcy50b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXN0ID0gX01hdGguSU5GO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHRoaXMudG91Y2hpbmcgfHwgdGhpcy5kaXN0IDwgMC4wMDEgKSB0aGlzLmNsb3NlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50b3VjaGluZz10cnVlO1xuICAgICAgICBpID0gbnVtO1xuICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAvL2ZvcihpPTA7IGk8bnVtOyBpKyspe1xuICAgICAgICAgICAgcD10aGlzLnBvaW50c1tpXTtcbiAgICAgICAgICAgIHZhciBscDF4PXAubG9jYWxQb2ludDEueDtcbiAgICAgICAgICAgIHZhciBscDF5PXAubG9jYWxQb2ludDEueTtcbiAgICAgICAgICAgIHZhciBscDF6PXAubG9jYWxQb2ludDEuejtcbiAgICAgICAgICAgIHZhciBscDJ4PXAubG9jYWxQb2ludDIueDtcbiAgICAgICAgICAgIHZhciBscDJ5PXAubG9jYWxQb2ludDIueTtcbiAgICAgICAgICAgIHZhciBscDJ6PXAubG9jYWxQb2ludDIuejtcbiAgICAgICAgICAgIHZhciBpbmRleD0tMTtcbiAgICAgICAgICAgIHZhciBtaW5EaXN0YW5jZT0wLjAwMDQ7XG4gICAgICAgICAgICB2YXIgaiA9IG51bUJ1ZmZlcnM7XG4gICAgICAgICAgICB3aGlsZShqLS0pe1xuICAgICAgICAgICAgLy9mb3IodmFyIGo9MDtqPG51bUJ1ZmZlcnM7aisrKXtcbiAgICAgICAgICAgICAgICBiPXRoaXMuYnVmZmVyW2pdO1xuICAgICAgICAgICAgICAgIHZhciBkeD1iLmxwMVgtbHAxeDtcbiAgICAgICAgICAgICAgICB2YXIgZHk9Yi5scDFZLWxwMXk7XG4gICAgICAgICAgICAgICAgdmFyIGR6PWIubHAxWi1scDF6O1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZTE9ZHgqZHgrZHkqZHkrZHoqZHo7XG4gICAgICAgICAgICAgICAgZHg9Yi5scDJYLWxwMng7XG4gICAgICAgICAgICAgICAgZHk9Yi5scDJZLWxwMnk7XG4gICAgICAgICAgICAgICAgZHo9Yi5scDJaLWxwMno7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlMj1keCpkeCtkeSpkeStkeipkejtcbiAgICAgICAgICAgICAgICBpZihkaXN0YW5jZTE8ZGlzdGFuY2UyKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGlzdGFuY2UxPG1pbkRpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlPWRpc3RhbmNlMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4PWo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGlzdGFuY2UyPG1pbkRpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlPWRpc3RhbmNlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4PWo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiggbWluRGlzdGFuY2UgPCB0aGlzLmRpc3QgKSB0aGlzLmRpc3QgPSBtaW5EaXN0YW5jZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaW5kZXghPS0xKXtcbiAgICAgICAgICAgICAgICB2YXIgdG1wPXRoaXMuYnVmZmVyW2luZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF09dGhpcy5idWZmZXJbLS1udW1CdWZmZXJzXTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltudW1CdWZmZXJzXT10bXA7XG4gICAgICAgICAgICAgICAgcC5ub3JtYWxJbXB1bHNlPXRtcC5pbXB1bHNlO1xuICAgICAgICAgICAgICAgIHAud2FybVN0YXJ0ZWQ9dHJ1ZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHAubm9ybWFsSW1wdWxzZT0wO1xuICAgICAgICAgICAgICAgIHAud2FybVN0YXJ0ZWQ9ZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICogQXR0YWNoIHRoZSBjb250YWN0IHRvIHRoZSBzaGFwZXMuXG4gICAgKiBAcGFyYW0gICBzaGFwZTFcbiAgICAqIEBwYXJhbSAgIHNoYXBlMlxuICAgICovXG4gICAgYXR0YWNoOmZ1bmN0aW9uKHNoYXBlMSxzaGFwZTIpe1xuICAgICAgICB0aGlzLnNoYXBlMT1zaGFwZTE7XG4gICAgICAgIHRoaXMuc2hhcGUyPXNoYXBlMjtcbiAgICAgICAgdGhpcy5ib2R5MT1zaGFwZTEucGFyZW50O1xuICAgICAgICB0aGlzLmJvZHkyPXNoYXBlMi5wYXJlbnQ7XG5cbiAgICAgICAgdGhpcy5tYW5pZm9sZC5ib2R5MT10aGlzLmJvZHkxO1xuICAgICAgICB0aGlzLm1hbmlmb2xkLmJvZHkyPXRoaXMuYm9keTI7XG4gICAgICAgIHRoaXMuY29uc3RyYWludC5ib2R5MT10aGlzLmJvZHkxO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnQuYm9keTI9dGhpcy5ib2R5MjtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50LmF0dGFjaCgpO1xuXG4gICAgICAgIHRoaXMuczFMaW5rLnNoYXBlPXNoYXBlMjtcbiAgICAgICAgdGhpcy5zMUxpbmsuYm9keT10aGlzLmJvZHkyO1xuICAgICAgICB0aGlzLnMyTGluay5zaGFwZT1zaGFwZTE7XG4gICAgICAgIHRoaXMuczJMaW5rLmJvZHk9dGhpcy5ib2R5MTtcblxuICAgICAgICBpZihzaGFwZTEuY29udGFjdExpbmshPW51bGwpKHRoaXMuczFMaW5rLm5leHQ9c2hhcGUxLmNvbnRhY3RMaW5rKS5wcmV2PXRoaXMuczFMaW5rO1xuICAgICAgICBlbHNlIHRoaXMuczFMaW5rLm5leHQ9bnVsbDtcbiAgICAgICAgc2hhcGUxLmNvbnRhY3RMaW5rPXRoaXMuczFMaW5rO1xuICAgICAgICBzaGFwZTEubnVtQ29udGFjdHMrKztcblxuICAgICAgICBpZihzaGFwZTIuY29udGFjdExpbmshPW51bGwpKHRoaXMuczJMaW5rLm5leHQ9c2hhcGUyLmNvbnRhY3RMaW5rKS5wcmV2PXRoaXMuczJMaW5rO1xuICAgICAgICBlbHNlIHRoaXMuczJMaW5rLm5leHQ9bnVsbDtcbiAgICAgICAgc2hhcGUyLmNvbnRhY3RMaW5rPXRoaXMuczJMaW5rO1xuICAgICAgICBzaGFwZTIubnVtQ29udGFjdHMrKztcblxuICAgICAgICB0aGlzLmIxTGluay5zaGFwZT1zaGFwZTI7XG4gICAgICAgIHRoaXMuYjFMaW5rLmJvZHk9dGhpcy5ib2R5MjtcbiAgICAgICAgdGhpcy5iMkxpbmsuc2hhcGU9c2hhcGUxO1xuICAgICAgICB0aGlzLmIyTGluay5ib2R5PXRoaXMuYm9keTE7XG5cbiAgICAgICAgaWYodGhpcy5ib2R5MS5jb250YWN0TGluayE9bnVsbCkodGhpcy5iMUxpbmsubmV4dD10aGlzLmJvZHkxLmNvbnRhY3RMaW5rKS5wcmV2PXRoaXMuYjFMaW5rO1xuICAgICAgICBlbHNlIHRoaXMuYjFMaW5rLm5leHQ9bnVsbDtcbiAgICAgICAgdGhpcy5ib2R5MS5jb250YWN0TGluaz10aGlzLmIxTGluaztcbiAgICAgICAgdGhpcy5ib2R5MS5udW1Db250YWN0cysrO1xuXG4gICAgICAgIGlmKHRoaXMuYm9keTIuY29udGFjdExpbmshPW51bGwpKHRoaXMuYjJMaW5rLm5leHQ9dGhpcy5ib2R5Mi5jb250YWN0TGluaykucHJldj10aGlzLmIyTGluaztcbiAgICAgICAgZWxzZSB0aGlzLmIyTGluay5uZXh0PW51bGw7XG4gICAgICAgIHRoaXMuYm9keTIuY29udGFjdExpbms9dGhpcy5iMkxpbms7XG4gICAgICAgIHRoaXMuYm9keTIubnVtQ29udGFjdHMrKztcblxuICAgICAgICB0aGlzLnByZXY9bnVsbDtcbiAgICAgICAgdGhpcy5uZXh0PW51bGw7XG5cbiAgICAgICAgdGhpcy5wZXJzaXN0aW5nPXRydWU7XG4gICAgICAgIHRoaXMuc2xlZXBpbmc9dGhpcy5ib2R5MS5zbGVlcGluZyYmdGhpcy5ib2R5Mi5zbGVlcGluZztcbiAgICAgICAgdGhpcy5tYW5pZm9sZC5udW1Qb2ludHM9MDtcbiAgICB9LFxuICAgIC8qKlxuICAgICogRGV0YWNoIHRoZSBjb250YWN0IGZyb20gdGhlIHNoYXBlcy5cbiAgICAqL1xuICAgIGRldGFjaDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcHJldj10aGlzLnMxTGluay5wcmV2O1xuICAgICAgICB2YXIgbmV4dD10aGlzLnMxTGluay5uZXh0O1xuICAgICAgICBpZihwcmV2IT09bnVsbClwcmV2Lm5leHQ9bmV4dDtcbiAgICAgICAgaWYobmV4dCE9PW51bGwpbmV4dC5wcmV2PXByZXY7XG4gICAgICAgIGlmKHRoaXMuc2hhcGUxLmNvbnRhY3RMaW5rPT10aGlzLnMxTGluayl0aGlzLnNoYXBlMS5jb250YWN0TGluaz1uZXh0O1xuICAgICAgICB0aGlzLnMxTGluay5wcmV2PW51bGw7XG4gICAgICAgIHRoaXMuczFMaW5rLm5leHQ9bnVsbDtcbiAgICAgICAgdGhpcy5zMUxpbmsuc2hhcGU9bnVsbDtcbiAgICAgICAgdGhpcy5zMUxpbmsuYm9keT1udWxsO1xuICAgICAgICB0aGlzLnNoYXBlMS5udW1Db250YWN0cy0tO1xuXG4gICAgICAgIHByZXY9dGhpcy5zMkxpbmsucHJldjtcbiAgICAgICAgbmV4dD10aGlzLnMyTGluay5uZXh0O1xuICAgICAgICBpZihwcmV2IT09bnVsbClwcmV2Lm5leHQ9bmV4dDtcbiAgICAgICAgaWYobmV4dCE9PW51bGwpbmV4dC5wcmV2PXByZXY7XG4gICAgICAgIGlmKHRoaXMuc2hhcGUyLmNvbnRhY3RMaW5rPT10aGlzLnMyTGluayl0aGlzLnNoYXBlMi5jb250YWN0TGluaz1uZXh0O1xuICAgICAgICB0aGlzLnMyTGluay5wcmV2PW51bGw7XG4gICAgICAgIHRoaXMuczJMaW5rLm5leHQ9bnVsbDtcbiAgICAgICAgdGhpcy5zMkxpbmsuc2hhcGU9bnVsbDtcbiAgICAgICAgdGhpcy5zMkxpbmsuYm9keT1udWxsO1xuICAgICAgICB0aGlzLnNoYXBlMi5udW1Db250YWN0cy0tO1xuXG4gICAgICAgIHByZXY9dGhpcy5iMUxpbmsucHJldjtcbiAgICAgICAgbmV4dD10aGlzLmIxTGluay5uZXh0O1xuICAgICAgICBpZihwcmV2IT09bnVsbClwcmV2Lm5leHQ9bmV4dDtcbiAgICAgICAgaWYobmV4dCE9PW51bGwpbmV4dC5wcmV2PXByZXY7XG4gICAgICAgIGlmKHRoaXMuYm9keTEuY29udGFjdExpbms9PXRoaXMuYjFMaW5rKXRoaXMuYm9keTEuY29udGFjdExpbms9bmV4dDtcbiAgICAgICAgdGhpcy5iMUxpbmsucHJldj1udWxsO1xuICAgICAgICB0aGlzLmIxTGluay5uZXh0PW51bGw7XG4gICAgICAgIHRoaXMuYjFMaW5rLnNoYXBlPW51bGw7XG4gICAgICAgIHRoaXMuYjFMaW5rLmJvZHk9bnVsbDtcbiAgICAgICAgdGhpcy5ib2R5MS5udW1Db250YWN0cy0tO1xuXG4gICAgICAgIHByZXY9dGhpcy5iMkxpbmsucHJldjtcbiAgICAgICAgbmV4dD10aGlzLmIyTGluay5uZXh0O1xuICAgICAgICBpZihwcmV2IT09bnVsbClwcmV2Lm5leHQ9bmV4dDtcbiAgICAgICAgaWYobmV4dCE9PW51bGwpbmV4dC5wcmV2PXByZXY7XG4gICAgICAgIGlmKHRoaXMuYm9keTIuY29udGFjdExpbms9PXRoaXMuYjJMaW5rKXRoaXMuYm9keTIuY29udGFjdExpbms9bmV4dDtcbiAgICAgICAgdGhpcy5iMkxpbmsucHJldj1udWxsO1xuICAgICAgICB0aGlzLmIyTGluay5uZXh0PW51bGw7XG4gICAgICAgIHRoaXMuYjJMaW5rLnNoYXBlPW51bGw7XG4gICAgICAgIHRoaXMuYjJMaW5rLmJvZHk9bnVsbDtcbiAgICAgICAgdGhpcy5ib2R5Mi5udW1Db250YWN0cy0tO1xuXG4gICAgICAgIHRoaXMubWFuaWZvbGQuYm9keTE9bnVsbDtcbiAgICAgICAgdGhpcy5tYW5pZm9sZC5ib2R5Mj1udWxsO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnQuYm9keTE9bnVsbDtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50LmJvZHkyPW51bGw7XG4gICAgICAgIHRoaXMuY29uc3RyYWludC5kZXRhY2goKTtcblxuICAgICAgICB0aGlzLnNoYXBlMT1udWxsO1xuICAgICAgICB0aGlzLnNoYXBlMj1udWxsO1xuICAgICAgICB0aGlzLmJvZHkxPW51bGw7XG4gICAgICAgIHRoaXMuYm9keTI9bnVsbDtcbiAgICB9XG5cbn0gKTtcblxuLyoqXHJcbiogVGhlIGNsYXNzIG9mIHJpZ2lkIGJvZHkuXHJcbiogUmlnaWQgYm9keSBoYXMgdGhlIHNoYXBlIG9mIGEgc2luZ2xlIG9yIG11bHRpcGxlIGNvbGxpc2lvbiBwcm9jZXNzaW5nLFxyXG4qIEkgY2FuIHNldCB0aGUgcGFyYW1ldGVycyBpbmRpdmlkdWFsbHkuXHJcbiogQGF1dGhvciBzYWhhcmFuXHJcbiogQGF1dGhvciBsby10aFxyXG4qL1xyXG5cclxuZnVuY3Rpb24gUmlnaWRCb2R5ICggUG9zaXRpb24sIFJvdGF0aW9uICkge1xyXG5cclxuICAgIHRoaXMucG9zaXRpb24gPSBQb3NpdGlvbiB8fCBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IFJvdGF0aW9uIHx8IG5ldyBRdWF0KCk7XHJcblxyXG4gICAgdGhpcy5zY2FsZSA9IDE7XHJcbiAgICB0aGlzLmludlNjYWxlID0gMTtcclxuXHJcbiAgICAvLyBwb3NzaWJsZSBsaW5rIHRvIHRocmVlIE1lc2g7XHJcbiAgICB0aGlzLm1lc2ggPSBudWxsO1xyXG5cclxuICAgIHRoaXMuaWQgPSBOYU47XHJcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNoYXBlcyB0aGF0IGNhbiBiZSBhZGRlZCB0byBhIG9uZSByaWdpZC5cclxuICAgIC8vdGhpcy5NQVhfU0hBUEVTID0gNjQ7Ly82NDtcclxuXHJcbiAgICB0aGlzLnByZXYgPSBudWxsO1xyXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuXHJcbiAgICAvLyBJIHJlcHJlc2VudCB0aGUga2luZCBvZiByaWdpZCBib2R5LlxyXG4gICAgLy8gUGxlYXNlIGRvIG5vdCBjaGFuZ2UgZnJvbSB0aGUgb3V0c2lkZSB0aGlzIHZhcmlhYmxlLlxyXG4gICAgLy8gSWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSB0eXBlIG9mIHJpZ2lkIGJvZHksIGFsd2F5c1xyXG4gICAgLy8gUGxlYXNlIHNwZWNpZnkgdGhlIHR5cGUgeW91IHdhbnQgdG8gc2V0IHRoZSBhcmd1bWVudHMgb2Ygc2V0dXBNYXNzIG1ldGhvZC5cclxuICAgIHRoaXMudHlwZSA9IEJPRFlfTlVMTDtcclxuXHJcbiAgICB0aGlzLm1hc3NJbmZvID0gbmV3IE1hc3NJbmZvKCk7XHJcblxyXG4gICAgdGhpcy5uZXdQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLmNvbnRyb2xQb3MgPSBmYWxzZTtcclxuICAgIHRoaXMubmV3T3JpZW50YXRpb24gPSBuZXcgUXVhdCgpO1xyXG4gICAgdGhpcy5uZXdSb3RhdGlvbiA9IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLmNvbnRyb2xSb3QgPSBmYWxzZTtcclxuICAgIHRoaXMuY29udHJvbFJvdEluVGltZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0KCk7XHJcbiAgICB0aGlzLnBvcyA9IG5ldyBWZWMzKCk7XHJcblxyXG5cclxuXHJcbiAgICAvLyBJcyB0aGUgdHJhbnNsYXRpb25hbCB2ZWxvY2l0eS5cclxuICAgIHRoaXMubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xyXG4gICAgLy8gSXMgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuXHJcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gIFBsZWFzZSBkbyBub3QgY2hhbmdlIGZyb20gdGhlIG91dHNpZGUgdGhpcyB2YXJpYWJsZXMuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gSXQgaXMgYSB3b3JsZCB0aGF0IHJpZ2lkIGJvZHkgaGFzIGJlZW4gYWRkZWQuXHJcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmNvbnRhY3RMaW5rID0gbnVsbDtcclxuICAgIHRoaXMubnVtQ29udGFjdHMgPSAwO1xyXG5cclxuICAgIC8vIEFuIGFycmF5IG9mIHNoYXBlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiB0aGUgcmlnaWQgYm9keS5cclxuICAgIHRoaXMuc2hhcGVzID0gbnVsbDtcclxuICAgIC8vIFRoZSBudW1iZXIgb2Ygc2hhcGVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIHRoZSByaWdpZCBib2R5LlxyXG4gICAgdGhpcy5udW1TaGFwZXMgPSAwO1xyXG5cclxuICAgIC8vIEl0IGlzIHRoZSBsaW5rIGFycmF5IG9mIGpvaW50IHRoYXQgaXMgY29ubmVjdGVkIHRvIHRoZSByaWdpZCBib2R5LlxyXG4gICAgdGhpcy5qb2ludExpbmsgPSBudWxsO1xyXG4gICAgLy8gVGhlIG51bWJlciBvZiBqb2ludHMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSByaWdpZCBib2R5LlxyXG4gICAgdGhpcy5udW1Kb2ludHMgPSAwO1xyXG5cclxuICAgIC8vIEl0IGlzIHRoZSB3b3JsZCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgZ3Jhdml0eSBpbiB0aGUgc2xlZXAganVzdCBiZWZvcmUuXHJcbiAgICB0aGlzLnNsZWVwUG9zaXRpb24gPSBuZXcgVmVjMygpO1xyXG4gICAgLy8gSXQgaXMgYSBxdWF0ZXJuaW9uIHRoYXQgcmVwcmVzZW50cyB0aGUgYXR0aXR1ZGUgb2Ygc2xlZXAganVzdCBiZWZvcmUuXHJcbiAgICB0aGlzLnNsZWVwT3JpZW50YXRpb24gPSBuZXcgUXVhdCgpO1xyXG4gICAgLy8gSSB3aWxsIHNob3cgdGhpcyByaWdpZCBib2R5IHRvIGRldGVybWluZSB3aGV0aGVyIGl0IGlzIGEgcmlnaWQgYm9keSBzdGF0aWMuXHJcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAvLyBJIGluZGljYXRlcyB0aGF0IHRoaXMgcmlnaWQgYm9keSB0byBkZXRlcm1pbmUgd2hldGhlciBpdCBpcyBhIHJpZ2lkIGJvZHkgZHluYW1pYy5cclxuICAgIHRoaXMuaXNEeW5hbWljID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5pc0tpbmVtYXRpYyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEl0IGlzIGEgcm90YXRpb24gbWF0cml4IHJlcHJlc2VudGluZyB0aGUgb3JpZW50YXRpb24uXHJcbiAgICB0aGlzLnJvdGF0aW9uID0gbmV3IE1hdDMzKCk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gSXQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBzaGFwZSwgd2hpY2ggaXMgaW5jbHVkZWQuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gVGhpcyBpcyB0aGUgd2VpZ2h0LlxyXG4gICAgdGhpcy5tYXNzID0gMDtcclxuICAgIC8vIEl0IGlzIHRoZSByZWNpcHJvY2FsIG9mIHRoZSBtYXNzLlxyXG4gICAgdGhpcy5pbnZlcnNlTWFzcyA9IDA7XHJcbiAgICAvLyBJdCBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaW5lcnRpYSB0ZW5zb3IgaW4gdGhlIHdvcmxkIHN5c3RlbS5cclxuICAgIHRoaXMuaW52ZXJzZUluZXJ0aWEgPSBuZXcgTWF0MzMoKTtcclxuICAgIC8vIEl0IGlzIHRoZSBpbmVydGlhIHRlbnNvciBpbiB0aGUgaW5pdGlhbCBzdGF0ZS5cclxuICAgIHRoaXMubG9jYWxJbmVydGlhID0gbmV3IE1hdDMzKCk7XHJcbiAgICAvLyBJdCBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaW5lcnRpYSB0ZW5zb3IgaW4gdGhlIGluaXRpYWwgc3RhdGUuXHJcbiAgICB0aGlzLmludmVyc2VMb2NhbEluZXJ0aWEgPSBuZXcgTWF0MzMoKTtcclxuXHJcbiAgICB0aGlzLnRtcEluZXJ0aWEgPSBuZXcgTWF0MzMoKTtcclxuXHJcblxyXG4gICAgLy8gSSBpbmRpY2F0ZXMgcmlnaWQgYm9keSB3aGV0aGVyIGl0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBzaW11bGF0aW9uIElzbGFuZC5cclxuICAgIHRoaXMuYWRkZWRUb0lzbGFuZCA9IGZhbHNlO1xyXG4gICAgLy8gSXQgc2hvd3MgaG93IHRvIHNsZWVwIHJpZ2lkIGJvZHkuXHJcbiAgICB0aGlzLmFsbG93U2xlZXAgPSB0cnVlO1xyXG4gICAgLy8gVGhpcyBpcyB0aGUgdGltZSBmcm9tIHdoZW4gdGhlIHJpZ2lkIGJvZHkgYXQgcmVzdC5cclxuICAgIHRoaXMuc2xlZXBUaW1lID0gMDtcclxuICAgIC8vIEkgc2hvd3MgcmlnaWQgYm9keSB0byBkZXRlcm1pbmUgd2hldGhlciBpdCBpcyBhIHNsZWVwIHN0YXRlLlxyXG4gICAgdGhpcy5zbGVlcGluZyA9IGZhbHNlO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggUmlnaWRCb2R5LnByb3RvdHlwZSwge1xyXG5cclxuICAgIHNldFBhcmVudDogZnVuY3Rpb24gKCB3b3JsZCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB3b3JsZDtcclxuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5wYXJlbnQuc2NhbGU7XHJcbiAgICAgICAgdGhpcy5pbnZTY2FsZSA9IHRoaXMucGFyZW50LmludlNjYWxlO1xyXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLnBhcmVudC5udW1SaWdpZEJvZGllcztcclxuICAgICAgICBpZiggIXRoaXMubmFtZSApIHRoaXMubmFtZSA9IHRoaXMuaWQ7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaCgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJJ2xsIGFkZCBhIHNoYXBlIHRvIHJpZ2lkIGJvZHkuXHJcbiAgICAgKiBJZiB5b3UgYWRkIGEgc2hhcGUsIHBsZWFzZSBjYWxsIHRoZSBzZXR1cE1hc3MgbWV0aG9kIHRvIHN0ZXAgdXAgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0LlxyXG4gICAgICogQHBhcmFtICAgc2hhcGUgc2hhcGUgdG8gQWRkXHJcbiAgICAgKi9cclxuICAgIGFkZFNoYXBlOmZ1bmN0aW9uKHNoYXBlKXtcclxuXHJcbiAgICAgICAgaWYoc2hhcGUucGFyZW50KXtcclxuXHRcdFx0cHJpbnRFcnJvcihcIlJpZ2lkQm9keVwiLCBcIkl0IGlzIG5vdCBwb3NzaWJsZSB0aGF0IHlvdSBhZGQgYSBzaGFwZSB3aGljaCBhbHJlYWR5IGhhcyBhbiBhc3NvY2lhdGVkIGJvZHkuXCIpO1xyXG5cdFx0fVxyXG5cclxuICAgICAgICBpZih0aGlzLnNoYXBlcyE9bnVsbCkoIHRoaXMuc2hhcGVzLnByZXYgPSBzaGFwZSApLm5leHQgPSB0aGlzLnNoYXBlcztcclxuICAgICAgICB0aGlzLnNoYXBlcyA9IHNoYXBlO1xyXG4gICAgICAgIHNoYXBlLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgaWYodGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LmFkZFNoYXBlKCBzaGFwZSApO1xyXG4gICAgICAgIHRoaXMubnVtU2hhcGVzKys7XHJcblxyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogSSB3aWxsIGRlbGV0ZSB0aGUgc2hhcGUgZnJvbSB0aGUgcmlnaWQgYm9keS5cclxuICAgICAqIElmIHlvdSBkZWxldGUgYSBzaGFwZSwgcGxlYXNlIGNhbGwgdGhlIHNldHVwTWFzcyBtZXRob2QgdG8gc3RlcCB1cCB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQuXHJcbiAgICAgKiBAcGFyYW0gc2hhcGUge1NoYXBlfSB0byBkZWxldGVcclxuICAgICAqIEByZXR1cm4gdm9pZFxyXG4gICAgICovXHJcbiAgICByZW1vdmVTaGFwZTpmdW5jdGlvbihzaGFwZSl7XHJcblxyXG4gICAgICAgIHZhciByZW1vdmUgPSBzaGFwZTtcclxuICAgICAgICBpZihyZW1vdmUucGFyZW50IT10aGlzKXJldHVybjtcclxuICAgICAgICB2YXIgcHJldj1yZW1vdmUucHJldjtcclxuICAgICAgICB2YXIgbmV4dD1yZW1vdmUubmV4dDtcclxuICAgICAgICBpZihwcmV2IT1udWxsKSBwcmV2Lm5leHQ9bmV4dDtcclxuICAgICAgICBpZihuZXh0IT1udWxsKSBuZXh0LnByZXY9cHJldjtcclxuICAgICAgICBpZih0aGlzLnNoYXBlcz09cmVtb3ZlKXRoaXMuc2hhcGVzPW5leHQ7XHJcbiAgICAgICAgcmVtb3ZlLnByZXY9bnVsbDtcclxuICAgICAgICByZW1vdmUubmV4dD1udWxsO1xyXG4gICAgICAgIHJlbW92ZS5wYXJlbnQ9bnVsbDtcclxuICAgICAgICBpZih0aGlzLnBhcmVudCl0aGlzLnBhcmVudC5yZW1vdmVTaGFwZShyZW1vdmUpO1xyXG4gICAgICAgIHRoaXMubnVtU2hhcGVzLS07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZVJpZ2lkQm9keSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2hlY2tDb250YWN0OiBmdW5jdGlvbiggbmFtZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tDb250YWN0KCB0aGlzLm5hbWUsIG5hbWUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsdWxhdGVzIG1hc3MgZGF0YXMoY2VudGVyIG9mIGdyYXZpdHksIG1hc3MsIG1vbWVudCBpbmVydGlhLCBldGMuLi4pLlxyXG4gICAgICogSWYgdGhlIHBhcmFtZXRlciB0eXBlIGlzIHNldCB0byBCT0RZX1NUQVRJQywgdGhlIHJpZ2lkIGJvZHkgd2lsbCBiZSBmaXhlZCB0byB0aGUgc3BhY2UuXHJcbiAgICAgKiBJZiB0aGUgcGFyYW1ldGVyIGFkanVzdFBvc2l0aW9uIGlzIHNldCB0byB0cnVlLCB0aGUgc2hhcGVzJyByZWxhdGl2ZSBwb3NpdGlvbnMgYW5kXHJcbiAgICAgKiB0aGUgcmlnaWQgYm9keSdzIHBvc2l0aW9uIHdpbGwgYmUgYWRqdXN0ZWQgdG8gdGhlIGNlbnRlciBvZiBncmF2aXR5LlxyXG4gICAgICogQHBhcmFtIHR5cGVcclxuICAgICAqIEBwYXJhbSBhZGp1c3RQb3NpdGlvblxyXG4gICAgICogQHJldHVybiB2b2lkXHJcbiAgICAgKi9cclxuICAgIHNldHVwTWFzczogZnVuY3Rpb24gKCB0eXBlLCBBZGp1c3RQb3NpdGlvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIGFkanVzdFBvc2l0aW9uID0gKCBBZGp1c3RQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBBZGp1c3RQb3NpdGlvbiA6IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgQk9EWV9TVEFUSUM7XHJcbiAgICAgICAgdGhpcy5pc0R5bmFtaWMgPSB0aGlzLnR5cGUgPT09IEJPRFlfRFlOQU1JQztcclxuICAgICAgICB0aGlzLmlzU3RhdGljID0gdGhpcy50eXBlID09PSBCT0RZX1NUQVRJQztcclxuXHJcbiAgICAgICAgdGhpcy5tYXNzID0gMDtcclxuICAgICAgICB0aGlzLmxvY2FsSW5lcnRpYS5zZXQoMCwwLDAsMCwwLDAsMCwwLDApO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHRtcE0gPSBuZXcgTWF0MzMoKTtcclxuICAgICAgICB2YXIgdG1wViA9IG5ldyBWZWMzKCk7XHJcblxyXG4gICAgICAgIGZvciggdmFyIHNoYXBlID0gdGhpcy5zaGFwZXM7IHNoYXBlICE9PSBudWxsOyBzaGFwZSA9IHNoYXBlLm5leHQgKXtcclxuXHJcbiAgICAgICAgICAgIHNoYXBlLmNhbGN1bGF0ZU1hc3NJbmZvKCB0aGlzLm1hc3NJbmZvICk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZU1hc3MgPSB0aGlzLm1hc3NJbmZvLm1hc3M7XHJcbiAgICAgICAgICAgIHRtcFYuYWRkU2NhbGVkVmVjdG9yKHNoYXBlLnJlbGF0aXZlUG9zaXRpb24sIHNoYXBlTWFzcyk7XHJcbiAgICAgICAgICAgIHRoaXMubWFzcyArPSBzaGFwZU1hc3M7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRlSW5lcnRpYSggc2hhcGUucmVsYXRpdmVSb3RhdGlvbiwgdGhpcy5tYXNzSW5mby5pbmVydGlhLCB0bXBNICk7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxJbmVydGlhLmFkZCggdG1wTSApO1xyXG5cclxuICAgICAgICAgICAgLy8gYWRkIG9mZnNldCBpbmVydGlhXHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxJbmVydGlhLmFkZE9mZnNldCggc2hhcGVNYXNzLCBzaGFwZS5yZWxhdGl2ZVBvc2l0aW9uICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbnZlcnNlTWFzcyA9IDEgLyB0aGlzLm1hc3M7XHJcbiAgICAgICAgdG1wVi5zY2FsZUVxdWFsKCB0aGlzLmludmVyc2VNYXNzICk7XHJcblxyXG4gICAgICAgIGlmKCBhZGp1c3RQb3NpdGlvbiApe1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZCggdG1wViApO1xyXG4gICAgICAgICAgICBmb3IoIHNoYXBlPXRoaXMuc2hhcGVzOyBzaGFwZSAhPT0gbnVsbDsgc2hhcGUgPSBzaGFwZS5uZXh0ICl7XHJcbiAgICAgICAgICAgICAgICBzaGFwZS5yZWxhdGl2ZVBvc2l0aW9uLnN1YkVxdWFsKHRtcFYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzdWJ0cmFjdCBvZmZzZXQgaW5lcnRpYVxyXG4gICAgICAgICAgICB0aGlzLmxvY2FsSW5lcnRpYS5zdWJPZmZzZXQoIHRoaXMubWFzcywgdG1wViApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW52ZXJzZUxvY2FsSW5lcnRpYS5pbnZlcnQoIHRoaXMubG9jYWxJbmVydGlhICk7XHJcblxyXG4gICAgICAgIC8vfVxyXG5cclxuICAgICAgICBpZiggdGhpcy50eXBlID09PSBCT0RZX1NUQVRJQyApe1xyXG4gICAgICAgICAgICB0aGlzLmludmVyc2VNYXNzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5pbnZlcnNlTG9jYWxJbmVydGlhLnNldCgwLDAsMCwwLDAsMCwwLDAsMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN5bmNTaGFwZXMoKTtcclxuICAgICAgICB0aGlzLmF3YWtlKCk7XHJcblxyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQXdha2UgdGhlIHJpZ2lkIGJvZHkuXHJcbiAgICAgKi9cclxuICAgIGF3YWtlOmZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIGlmKCAhdGhpcy5hbGxvd1NsZWVwIHx8ICF0aGlzLnNsZWVwaW5nICkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuc2xlZXBpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNsZWVwVGltZSA9IDA7XHJcbiAgICAgICAgLy8gYXdha2UgY29ubmVjdGVkIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jb250YWN0TGluaztcclxuICAgICAgICB3aGlsZShjcyAhPSBudWxsKXtcclxuICAgICAgICAgICAgY3MuYm9keS5zbGVlcFRpbWUgPSAwO1xyXG4gICAgICAgICAgICBjcy5ib2R5LnNsZWVwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNzID0gY3MubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGpzID0gdGhpcy5qb2ludExpbms7XHJcbiAgICAgICAgd2hpbGUoanMgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIGpzLmJvZHkuc2xlZXBUaW1lID0gMDtcclxuICAgICAgICAgICAganMuYm9keS5zbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBqcyA9IGpzLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgc2hhcGUgPSB0aGlzLnNoYXBlczsgc2hhcGUhPW51bGw7IHNoYXBlID0gc2hhcGUubmV4dCl7XHJcbiAgICAgICAgICAgIHNoYXBlLnVwZGF0ZVByb3h5KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFNsZWVwIHRoZSByaWdpZCBib2R5LlxyXG4gICAgICovXHJcbiAgICBzbGVlcDpmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICBpZiggIXRoaXMuYWxsb3dTbGVlcCB8fCB0aGlzLnNsZWVwaW5nICkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmxpbmVhclZlbG9jaXR5LnNldCgwLDAsMCk7XHJcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKTtcclxuICAgICAgICB0aGlzLnNsZWVwUG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbiApO1xyXG4gICAgICAgIHRoaXMuc2xlZXBPcmllbnRhdGlvbi5jb3B5KCB0aGlzLm9yaWVudGF0aW9uICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2xlZXBUaW1lID0gMDtcclxuICAgICAgICB0aGlzLnNsZWVwaW5nID0gdHJ1ZTtcclxuICAgICAgICBmb3IoIHZhciBzaGFwZSA9IHRoaXMuc2hhcGVzOyBzaGFwZSAhPSBudWxsOyBzaGFwZSA9IHNoYXBlLm5leHQgKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnVwZGF0ZVByb3h5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0ZXN0V2FrZVVwOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICBpZiggdGhpcy5saW5lYXJWZWxvY2l0eS50ZXN0WmVybygpIHx8IHRoaXMuYW5ndWxhclZlbG9jaXR5LnRlc3RaZXJvKCkgfHwgdGhpcy5wb3NpdGlvbi50ZXN0RGlmZiggdGhpcy5zbGVlcFBvc2l0aW9uICkgfHwgdGhpcy5vcmllbnRhdGlvbi50ZXN0RGlmZiggdGhpcy5zbGVlcE9yaWVudGF0aW9uICkpIHRoaXMuYXdha2UoKTsgLy8gYXdha2UgdGhlIGJvZHlcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHdoZXRoZXIgdGhlIHJpZ2lkIGJvZHkgaGFzIG5vdCBhbnkgY29ubmVjdGlvbiB3aXRoIG90aGVycy5cclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGlzTG9uZWx5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtSm9pbnRzPT0wICYmIHRoaXMubnVtQ29udGFjdHM9PTA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRpbWUgaW50ZWdyYXRpb24gb2YgdGhlIG1vdGlvbiBvZiBhIHJpZ2lkIGJvZHksIHlvdSBjYW4gdXBkYXRlIHRoZSBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSBzaGFwZS5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYXV0b21hdGljYWxseSB3aGVuIGNhbGxpbmcgdGhlIHN0ZXAgb2YgdGhlIFdvcmxkLFxyXG4gICAgICogVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGZyb20gb3V0c2lkZSB1c3VhbGx5LlxyXG4gICAgICogQHBhcmFtICB0aW1lU3RlcCB0aW1lXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXHJcblxyXG4gICAgdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICggdGltZVN0ZXAgKSB7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgQk9EWV9TVEFUSUM6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVhclZlbG9jaXR5LnNldCgwLDAsMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5zZXQoMCwwLDApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE9OTFkgRk9SIFRFU1RcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29udHJvbFBvcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMubmV3UG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbFBvcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb250cm9sUm90KXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWVudGF0aW9uLmNvcHkodGhpcy5uZXdPcmllbnRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sUm90ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKnRoaXMubGluZWFyVmVsb2NpdHkueD0wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lYXJWZWxvY2l0eS55PTA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVhclZlbG9jaXR5Lno9MDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5Lng9MDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5Lnk9MDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5Lno9MDsqL1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCT0RZX0RZTkFNSUM6XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuaXNLaW5lbWF0aWMgKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lYXJWZWxvY2l0eS5zZXQoMCwwLDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnNldCgwLDAsMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29udHJvbFBvcyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZWFyVmVsb2NpdHkuc3ViVmVjdG9ycyggdGhpcy5uZXdQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbiApLm11bHRpcGx5U2NhbGFyKDEvdGltZVN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbFBvcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29udHJvbFJvdCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNvcHkoIHRoaXMuZ2V0QXhpcygpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbi5jb3B5KCB0aGlzLm5ld09yaWVudGF0aW9uICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sUm90ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkU2NhbGVkVmVjdG9yKHRoaXMubGluZWFyVmVsb2NpdHksIHRpbWVTdGVwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZW50YXRpb24uYWRkVGltZSh0aGlzLmFuZ3VsYXJWZWxvY2l0eSwgdGltZVN0ZXApO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWVzaCgpO1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHByaW50RXJyb3IoXCJSaWdpZEJvZHlcIiwgXCJJbnZhbGlkIHR5cGUuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zeW5jU2hhcGVzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNZXNoKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMyggMCwxLDAgKS5hcHBseU1hdHJpeDMoIHRoaXMuaW52ZXJzZUxvY2FsSW5lcnRpYSwgdHJ1ZSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlSW5lcnRpYTogZnVuY3Rpb24gKCByb3QsIGluZXJ0aWEsIG91dCApIHtcclxuXHJcbiAgICAgICAgdGhpcy50bXBJbmVydGlhLm11bHRpcGx5TWF0cmljZXMoIHJvdCwgaW5lcnRpYSApO1xyXG4gICAgICAgIG91dC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnRtcEluZXJ0aWEsIHJvdCwgdHJ1ZSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3luY1NoYXBlczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnJvdGF0aW9uLnNldFF1YXQoIHRoaXMub3JpZW50YXRpb24gKTtcclxuICAgICAgICB0aGlzLnJvdGF0ZUluZXJ0aWEoIHRoaXMucm90YXRpb24sIHRoaXMuaW52ZXJzZUxvY2FsSW5lcnRpYSwgdGhpcy5pbnZlcnNlSW5lcnRpYSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgc2hhcGUgPSB0aGlzLnNoYXBlczsgc2hhcGUhPW51bGw7IHNoYXBlID0gc2hhcGUubmV4dCl7XHJcblxyXG4gICAgICAgICAgICBzaGFwZS5wb3NpdGlvbi5jb3B5KCBzaGFwZS5yZWxhdGl2ZVBvc2l0aW9uICkuYXBwbHlNYXRyaXgzKCB0aGlzLnJvdGF0aW9uLCB0cnVlICkuYWRkKCB0aGlzLnBvc2l0aW9uICk7XHJcbiAgICAgICAgICAgIC8vIGFkZCBieSBRdWF6aUtiXHJcbiAgICAgICAgICAgIHNoYXBlLnJvdGF0aW9uLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucm90YXRpb24sIHNoYXBlLnJlbGF0aXZlUm90YXRpb24gKTtcclxuICAgICAgICAgICAgc2hhcGUudXBkYXRlUHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQVBQTFkgSU1QVUxTRSBGT1JDRVxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBhcHBseUltcHVsc2U6IGZ1bmN0aW9uKHBvc2l0aW9uLCBmb3JjZSl7XHJcbiAgICAgICAgdGhpcy5saW5lYXJWZWxvY2l0eS5hZGRTY2FsZWRWZWN0b3IoZm9yY2UsIHRoaXMuaW52ZXJzZU1hc3MpO1xyXG4gICAgICAgIHZhciByZWwgPSBuZXcgVmVjMygpLmNvcHkoIHBvc2l0aW9uICkuc3ViKCB0aGlzLnBvc2l0aW9uICkuY3Jvc3MoIGZvcmNlICkuYXBwbHlNYXRyaXgzKCB0aGlzLmludmVyc2VJbmVydGlhLCB0cnVlICk7XHJcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuYWRkKCByZWwgKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBTRVQgRFlOQU1JUVVFIFBPU0lUSU9OIEFORCBST1RBVElPTlxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zKXtcclxuICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uLmNvcHkoIHBvcyApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmludlNjYWxlICk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sUG9zID0gdHJ1ZTtcclxuICAgICAgICBpZiggIXRoaXMuaXNLaW5lbWF0aWMgKSB0aGlzLmlzS2luZW1hdGljID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UXVhdGVybmlvbjogZnVuY3Rpb24ocSl7XHJcbiAgICAgICAgdGhpcy5uZXdPcmllbnRhdGlvbi5zZXQocS54LCBxLnksIHEueiwgcS53KTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xSb3QgPSB0cnVlO1xyXG4gICAgICAgIGlmKCAhdGhpcy5pc0tpbmVtYXRpYyApIHRoaXMuaXNLaW5lbWF0aWMgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKCByb3QgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubmV3T3JpZW50YXRpb24gPSBuZXcgUXVhdCgpLnNldEZyb21FdWxlciggcm90LnggKiBfTWF0aC5kZWd0b3JhZCwgcm90LnkgKiBfTWF0aC5kZWd0b3JhZCwgcm90LnkgKiBfTWF0aC5kZWd0b3JhZCApOy8vdGhpcy5yb3RhdGlvblZlY3RUb1F1YWQoIHJvdCApO1xyXG4gICAgICAgIHRoaXMuY29udHJvbFJvdCA9IHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUkVTRVQgRFlOQU1JUVVFIFBPU0lUSU9OIEFORCBST1RBVElPTlxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICByZXNldFBvc2l0aW9uOmZ1bmN0aW9uKHgseSx6KXtcclxuXHJcbiAgICAgICAgdGhpcy5saW5lYXJWZWxvY2l0eS5zZXQoIDAsIDAsIDAgKTtcclxuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5zZXQoIDAsIDAsIDAgKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnNldCggeCwgeSwgeiApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmludlNjYWxlICk7XHJcbiAgICAgICAgLy90aGlzLnBvc2l0aW9uLnNldCggeCpPSU1PLldvcmxkU2NhbGUuaW52U2NhbGUsIHkqT0lNTy5Xb3JsZFNjYWxlLmludlNjYWxlLCB6Kk9JTU8uV29ybGRTY2FsZS5pbnZTY2FsZSApO1xyXG4gICAgICAgIHRoaXMuYXdha2UoKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRRdWF0ZXJuaW9uOmZ1bmN0aW9uKCBxICl7XHJcblxyXG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnNldCgwLDAsMCk7XHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IG5ldyBRdWF0KCBxLngsIHEueSwgcS56LCBxLncgKTtcclxuICAgICAgICB0aGlzLmF3YWtlKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZXNldFJvdGF0aW9uOmZ1bmN0aW9uKHgseSx6KXtcclxuXHJcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKTtcclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gbmV3IFF1YXQoKS5zZXRGcm9tRXVsZXIoIHggKiBfTWF0aC5kZWd0b3JhZCwgeSAqIF9NYXRoLmRlZ3RvcmFkLCAgeiAqIF9NYXRoLmRlZ3RvcmFkICk7Ly90aGlzLnJvdGF0aW9uVmVjdFRvUXVhZCggbmV3IFZlYzMoeCx5LHopICk7XHJcbiAgICAgICAgdGhpcy5hd2FrZSgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEdFVCBQT1NJVElPTiBBTkQgUk9UQVRJT05cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgZ2V0UG9zaXRpb246ZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wb3M7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnF1YXRlcm5pb247XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQVVUTyBVUERBVEUgVEhSRUUgTUVTSFxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjb25uZWN0TWVzaDogZnVuY3Rpb24gKCBtZXNoICkge1xyXG5cclxuICAgICAgICB0aGlzLm1lc2ggPSBtZXNoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaCgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlTWVzaDogZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgdGhpcy5wb3Muc2NhbGUoIHRoaXMucG9zaXRpb24sIHRoaXMuc2NhbGUgKTtcclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weSggdGhpcy5vcmllbnRhdGlvbiApO1xyXG5cclxuICAgICAgICBpZiggdGhpcy5tZXNoID09PSBudWxsICkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLm1lc2gucG9zaXRpb24uY29weSggdGhpcy5nZXRQb3NpdGlvbigpICk7XHJcbiAgICAgICAgdGhpcy5tZXNoLnF1YXRlcm5pb24uY29weSggdGhpcy5nZXRRdWF0ZXJuaW9uKCkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxufSApO1xuXG4vKipcclxuKiBBIHBhaXIgb2Ygc2hhcGVzIHRoYXQgbWF5IGNvbGxpZGUuXHJcbiogQGF1dGhvciBzYWhhcmFuXHJcbiovXHJcbmZ1bmN0aW9uIFBhaXIgKCBzMSwgczIgKXtcclxuXHJcbiAgICAvLyBUaGUgZmlyc3Qgc2hhcGUuXHJcbiAgICB0aGlzLnNoYXBlMSA9IHMxIHx8IG51bGw7XHJcbiAgICAvLyBUaGUgc2Vjb25kIHNoYXBlLlxyXG4gICAgdGhpcy5zaGFwZTIgPSBzMiB8fCBudWxsO1xyXG5cclxufVxuXG4vKipcclxuKiBUaGUgYnJvYWQtcGhhc2UgaXMgdXNlZCBmb3IgY29sbGVjdGluZyBhbGwgcG9zc2libGUgcGFpcnMgZm9yIGNvbGxpc2lvbi5cclxuKi9cclxuXHJcbiBmdW5jdGlvbiBCcm9hZFBoYXNlKCl7XHJcblxyXG4gICAgdGhpcy50eXBlcyA9IEJSX05VTEw7XHJcbiAgICB0aGlzLm51bVBhaXJDaGVja3MgPSAwO1xyXG4gICAgdGhpcy5udW1QYWlycyA9IDA7XHJcbiAgICB0aGlzLnBhaXJzID0gW107XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBCcm9hZFBoYXNlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIEJyb2FkUGhhc2U6IHRydWUsXHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHByb3h5LlxyXG4gICAgY3JlYXRlUHJveHk6IGZ1bmN0aW9uICggc2hhcGUgKSB7XHJcblxyXG4gICAgICAgIHByaW50RXJyb3IoXCJCcm9hZFBoYXNlXCIsXCJJbmhlcml0YW5jZSBlcnJvci5cIik7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBZGQgdGhlIHByb3h5IGludG8gdGhlIGJyb2FkLXBoYXNlLlxyXG4gICAgYWRkUHJveHk6IGZ1bmN0aW9uICggcHJveHkgKSB7XHJcblxyXG4gICAgICAgIHByaW50RXJyb3IoXCJCcm9hZFBoYXNlXCIsXCJJbmhlcml0YW5jZSBlcnJvci5cIik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgcHJveHkgZnJvbSB0aGUgYnJvYWQtcGhhc2UuXHJcbiAgICByZW1vdmVQcm94eTogZnVuY3Rpb24gKCBwcm94eSApIHtcclxuXHJcbiAgICAgICAgcHJpbnRFcnJvcihcIkJyb2FkUGhhc2VcIixcIkluaGVyaXRhbmNlIGVycm9yLlwiKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJldHVybnMgd2hldGhlciB0aGUgcGFpciBpcyBhdmFpbGFibGUgb3Igbm90LlxyXG4gICAgaXNBdmFpbGFibGVQYWlyOiBmdW5jdGlvbiAoIHMxLCBzMiApIHtcclxuXHJcbiAgICAgICAgdmFyIGIxID0gczEucGFyZW50O1xyXG4gICAgICAgIHZhciBiMiA9IHMyLnBhcmVudDtcclxuICAgICAgICBpZiggYjEgPT0gYjIgfHwgLy8gc2FtZSBwYXJlbnRzXHJcbiAgICAgICAgICAgICghYjEuaXNEeW5hbWljICYmICFiMi5pc0R5bmFtaWMpIHx8IC8vIHN0YXRpYyBvciBraW5lbWF0aWMgb2JqZWN0XHJcbiAgICAgICAgICAgIChzMS5iZWxvbmdzVG8mczIuY29sbGlkZXNXaXRoKT09MCB8fFxyXG4gICAgICAgICAgICAoczIuYmVsb25nc1RvJnMxLmNvbGxpZGVzV2l0aCk9PTAgLy8gY29sbGlzaW9uIGZpbHRlcmluZ1xyXG4gICAgICAgICl7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBqcztcclxuICAgICAgICBpZihiMS5udW1Kb2ludHM8YjIubnVtSm9pbnRzKSBqcyA9IGIxLmpvaW50TGluaztcclxuICAgICAgICBlbHNlIGpzID0gYjIuam9pbnRMaW5rO1xyXG4gICAgICAgIHdoaWxlKGpzIT09bnVsbCl7XHJcbiAgICAgICAgICAgdmFyIGpvaW50ID0ganMuam9pbnQ7XHJcbiAgICAgICAgICAgaWYoICFqb2ludC5hbGxvd0NvbGxpc2lvbiAmJiAoKGpvaW50LmJvZHkxPT1iMSAmJiBqb2ludC5ib2R5Mj09YjIpIHx8IChqb2ludC5ib2R5MT09YjIgJiYgam9pbnQuYm9keTI9PWIxKSkgKXsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgICAganMgPSBqcy5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBEZXRlY3Qgb3ZlcmxhcHBpbmcgcGFpcnMuXHJcbiAgICBkZXRlY3RQYWlyczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBjbGVhciBvbGRcclxuICAgICAgICB0aGlzLnBhaXJzID0gW107XHJcbiAgICAgICAgdGhpcy5udW1QYWlycyA9IDA7XHJcbiAgICAgICAgdGhpcy5udW1QYWlyQ2hlY2tzID0gMDtcclxuICAgICAgICB0aGlzLmNvbGxlY3RQYWlycygpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29sbGVjdFBhaXJzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIEVycm9yKFwiQnJvYWRQaGFzZVwiLCBcIkluaGVyaXRhbmNlIGVycm9yLlwiKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFBhaXI6IGZ1bmN0aW9uICggczEsIHMyICkge1xyXG5cclxuICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyKCBzMSwgczIgKTtcclxuICAgICAgICB0aGlzLnBhaXJzLnB1c2gocGFpcik7XHJcbiAgICAgICAgdGhpcy5udW1QYWlycysrO1xyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG52YXIgY291bnQkMSA9IDA7XHJcbmZ1bmN0aW9uIFByb3h5SWRDb3VudCgpIHsgcmV0dXJuIGNvdW50JDErKzsgfVxyXG5cclxuLyoqXHJcbiAqIEEgcHJveHkgaXMgdXNlZCBmb3IgYnJvYWQtcGhhc2UgY29sbGVjdGluZyBwYWlycyB0aGF0IGNhbiBiZSBjb2xsaWRpbmcuXHJcbiAqXHJcbiAqIEBhdXRob3IgbG8tdGhcclxuICovXHJcblxyXG5mdW5jdGlvbiBQcm94eSggc2hhcGUgKSB7XHJcblxyXG5cdC8vVGhlIHBhcmVudCBzaGFwZS5cclxuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcclxuXHJcbiAgICAvL1RoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94LlxyXG4gICAgdGhpcy5hYWJiID0gc2hhcGUuYWFiYjtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIFByb3h5LnByb3RvdHlwZSwge1xyXG5cclxuICAgIFByb3h5OiB0cnVlLFxyXG5cclxuXHQvLyBVcGRhdGUgdGhlIHByb3h5LiBNdXN0IGJlIGluaGVyaXRlZCBieSBhIGNoaWxkLlxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgcHJpbnRFcnJvcihcIlByb3h5XCIsXCJJbmhlcml0YW5jZSBlcnJvci5cIik7XHJcblxyXG4gICAgfVxyXG5cclxufSk7XG5cbi8qKlxyXG4qIEEgYmFzaWMgaW1wbGVtZW50YXRpb24gb2YgcHJveGllcy5cclxuKlxyXG4qIEBhdXRob3Igc2FoYXJhblxyXG4qL1xyXG5cclxuZnVuY3Rpb24gQmFzaWNQcm94eSAoIHNoYXBlICkge1xyXG5cclxuICAgIFByb3h5LmNhbGwoIHRoaXMsIHNoYXBlICk7XHJcblxyXG4gICAgdGhpcy5pZCA9IFByb3h5SWRDb3VudCgpO1xyXG5cclxufVxyXG5cclxuQmFzaWNQcm94eS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQcm94eS5wcm90b3R5cGUgKSwge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBCYXNpY1Byb3h5LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG4vKipcclxuKiBBIGJyb2FkLXBoYXNlIGFsZ29yaXRobSB3aXRoIGJydXRlLWZvcmNlIHNlYXJjaC5cclxuKiBUaGlzIGFsd2F5cyBjaGVja3MgZm9yIGFsbCBwb3NzaWJsZSBwYWlycy5cclxuKi9cclxuXHJcbmZ1bmN0aW9uIEJydXRlRm9yY2VCcm9hZFBoYXNlKCl7XHJcblxyXG4gICAgQnJvYWRQaGFzZS5jYWxsKCB0aGlzICk7XHJcbiAgICB0aGlzLnR5cGVzID0gQlJfQlJVVEVfRk9SQ0U7XHJcbiAgICAvL3RoaXMubnVtUHJveGllcz0wO1xyXG4gICAgLy8vdGhpcy5tYXhQcm94aWVzID0gMjU2O1xyXG4gICAgdGhpcy5wcm94aWVzID0gW107XHJcbiAgICAvL3RoaXMucHJveGllcy5sZW5ndGggPSAyNTY7XHJcblxyXG59XHJcblxyXG5cclxuQnJ1dGVGb3JjZUJyb2FkUGhhc2UucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQnJvYWRQaGFzZS5wcm90b3R5cGUgKSwge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBCcnV0ZUZvcmNlQnJvYWRQaGFzZSxcclxuXHJcbiAgICBjcmVhdGVQcm94eTogZnVuY3Rpb24gKCBzaGFwZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNpY1Byb3h5KCBzaGFwZSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkUHJveHk6IGZ1bmN0aW9uICggcHJveHkgKSB7XHJcblxyXG4gICAgICAgIC8qaWYodGhpcy5udW1Qcm94aWVzPT10aGlzLm1heFByb3hpZXMpe1xyXG4gICAgICAgICAgICAvL3RoaXMubWF4UHJveGllczw8PTE7XHJcbiAgICAgICAgICAgIHRoaXMubWF4UHJveGllcyo9MjtcclxuICAgICAgICAgICAgdmFyIG5ld1Byb3hpZXM9W107XHJcbiAgICAgICAgICAgIG5ld1Byb3hpZXMubGVuZ3RoID0gdGhpcy5tYXhQcm94aWVzO1xyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMubnVtUHJveGllcztcclxuICAgICAgICAgICAgd2hpbGUoaS0tKXtcclxuICAgICAgICAgICAgLy9mb3IodmFyIGk9MCwgbD10aGlzLm51bVByb3hpZXM7aTxsO2krKyl7XHJcbiAgICAgICAgICAgICAgICBuZXdQcm94aWVzW2ldPXRoaXMucHJveGllc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnByb3hpZXM9bmV3UHJveGllcztcclxuICAgICAgICB9Ki9cclxuICAgICAgICAvL3RoaXMucHJveGllc1t0aGlzLm51bVByb3hpZXMrK10gPSBwcm94eTtcclxuICAgICAgICB0aGlzLnByb3hpZXMucHVzaCggcHJveHkgKTtcclxuICAgICAgICAvL3RoaXMubnVtUHJveGllcysrO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlUHJveHk6IGZ1bmN0aW9uICggcHJveHkgKSB7XHJcblxyXG4gICAgICAgIHZhciBuID0gdGhpcy5wcm94aWVzLmluZGV4T2YoIHByb3h5ICk7XHJcbiAgICAgICAgaWYgKCBuID4gLTEgKXtcclxuICAgICAgICAgICAgdGhpcy5wcm94aWVzLnNwbGljZSggbiwgMSApO1xyXG4gICAgICAgICAgICAvL3RoaXMubnVtUHJveGllcy0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyp2YXIgaSA9IHRoaXMubnVtUHJveGllcztcclxuICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIC8vZm9yKHZhciBpPTAsIGw9dGhpcy5udW1Qcm94aWVzO2k8bDtpKyspe1xyXG4gICAgICAgICAgICBpZih0aGlzLnByb3hpZXNbaV0gPT0gcHJveHkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm94aWVzW2ldID0gdGhpcy5wcm94aWVzWy0tdGhpcy5udW1Qcm94aWVzXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJveGllc1t0aGlzLm51bVByb3hpZXNdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0qL1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29sbGVjdFBhaXJzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBpID0gMCwgaiwgcDEsIHAyO1xyXG5cclxuICAgICAgICB2YXIgcHggPSB0aGlzLnByb3hpZXM7XHJcbiAgICAgICAgdmFyIGwgPSBweC5sZW5ndGg7Ly90aGlzLm51bVByb3hpZXM7XHJcbiAgICAgICAgLy92YXIgYXIxID0gW107XHJcbiAgICAgICAgLy92YXIgYXIyID0gW107XHJcblxyXG4gICAgICAgIC8vZm9yKCBpID0gcHgubGVuZ3RoIDsgaS0tIDsgYXIxWyBpIF0gPSBweFsgaSBdICl7fTtcclxuICAgICAgICAvL2ZvciggaSA9IHB4Lmxlbmd0aCA7IGktLSA7IGFyMlsgaSBdID0gcHhbIGkgXSApe307XHJcblxyXG4gICAgICAgIC8vdmFyIGFyMSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wcm94aWVzKSlcclxuICAgICAgICAvL3ZhciBhcjIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucHJveGllcykpXHJcblxyXG4gICAgICAgIHRoaXMubnVtUGFpckNoZWNrcyA9IGwqKGwtMSk+PjE7XHJcbiAgICAgICAgLy90aGlzLm51bVBhaXJDaGVja3M9dGhpcy5udW1Qcm94aWVzKih0aGlzLm51bVByb3hpZXMtMSkqMC41O1xyXG5cclxuICAgICAgICB3aGlsZSggaSA8IGwgKXtcclxuICAgICAgICAgICAgcDEgPSBweFtpKytdO1xyXG4gICAgICAgICAgICBqID0gaSArIDE7XHJcbiAgICAgICAgICAgIHdoaWxlKCBqIDwgbCApe1xyXG4gICAgICAgICAgICAgICAgcDIgPSBweFtqKytdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwMS5hYWJiLmludGVyc2VjdFRlc3QoIHAyLmFhYmIgKSB8fCAhdGhpcy5pc0F2YWlsYWJsZVBhaXIoIHAxLnNoYXBlLCBwMi5zaGFwZSApICkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhaXIoIHAxLnNoYXBlLCBwMi5zaGFwZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG4vKipcclxuICogQSBwcm9qZWN0aW9uIGF4aXMgZm9yIHN3ZWVwIGFuZCBwcnVuZSBicm9hZC1waGFzZS5cclxuICogQGF1dGhvciBzYWhhcmFuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gU0FQQXhpcyAoKXtcclxuXHJcbiAgICB0aGlzLm51bUVsZW1lbnRzID0gMDtcclxuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IDI1NjtcclxuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICAgIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gdGhpcy5idWZmZXJTaXplO1xyXG4gICAgdGhpcy5zdGFjayA9IG5ldyBGbG9hdDMyQXJyYXkoIDY0ICk7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBTQVBBeGlzLnByb3RvdHlwZSwge1xyXG5cclxuICAgIFNBUEF4aXM6IHRydWUsXHJcblxyXG4gICAgYWRkRWxlbWVudHM6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubnVtRWxlbWVudHMrMj49dGhpcy5idWZmZXJTaXplKXtcclxuICAgICAgICAgICAgLy90aGlzLmJ1ZmZlclNpemU8PD0xO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclNpemUqPTI7XHJcbiAgICAgICAgICAgIHZhciBuZXdFbGVtZW50cz1bXTtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm51bUVsZW1lbnRzO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICAvL2Zvcih2YXIgaT0wLCBsPXRoaXMubnVtRWxlbWVudHM7IGk8bDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsZW1lbnRzW3RoaXMubnVtRWxlbWVudHMrK10gPSBtaW47XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1t0aGlzLm51bUVsZW1lbnRzKytdID0gbWF4O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlRWxlbWVudHM6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIHZhciBtaW5JbmRleD0tMTtcclxuICAgICAgICB2YXIgbWF4SW5kZXg9LTE7XHJcbiAgICAgICAgZm9yKHZhciBpPTAsIGw9dGhpcy5udW1FbGVtZW50czsgaTxsOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgZT10aGlzLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZihlPT1taW58fGU9PW1heCl7XHJcbiAgICAgICAgICAgICAgICBpZihtaW5JbmRleD09LTEpe1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGV4PWk7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBtYXhJbmRleD1pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGkgPSBtaW5JbmRleCsxLCBsID0gbWF4SW5kZXg7IGkgPCBsOyBpKyspe1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ktMV0gPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IoaSA9IG1heEluZGV4KzEsIGwgPSB0aGlzLm51bUVsZW1lbnRzOyBpIDwgbDsgaSsrKXtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpLTJdID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudHNbLS10aGlzLm51bUVsZW1lbnRzXSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1stLXRoaXMubnVtRWxlbWVudHNdID0gbnVsbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNvcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICB2YXIgdGhyZXNob2xkID0gMTtcclxuICAgICAgICB3aGlsZSgodGhpcy5udW1FbGVtZW50cyA+PiB0aHJlc2hvbGQpICE9IDAgKSB0aHJlc2hvbGQrKztcclxuICAgICAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgKiB0aGlzLm51bUVsZW1lbnRzID4+IDI7XHJcbiAgICAgICAgY291bnQgPSAwO1xyXG5cclxuICAgICAgICB2YXIgZ2l2ZXVwID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBmb3IoIHZhciBpID0gMSwgbCA9IHRoaXMubnVtRWxlbWVudHM7IGkgPCBsOyBpKyspeyAvLyB0cnkgaW5zZXJ0aW9uIHNvcnRcclxuICAgICAgICAgICAgdmFyIHRtcD1lbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgdmFyIHBpdm90PXRtcC52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHRtcDI9ZWxlbWVudHNbaS0xXTtcclxuICAgICAgICAgICAgaWYodG1wMi52YWx1ZT5waXZvdCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgaj1pO1xyXG4gICAgICAgICAgICAgICAgZG97XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal09dG1wMjtcclxuICAgICAgICAgICAgICAgICAgICBpZigtLWo9PTApYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wMj1lbGVtZW50c1tqLTFdO1xyXG4gICAgICAgICAgICAgICAgfXdoaWxlKHRtcDIudmFsdWU+cGl2b3QpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNbal09dG1wO1xyXG4gICAgICAgICAgICAgICAgY291bnQrPWktajtcclxuICAgICAgICAgICAgICAgIGlmKGNvdW50PnRocmVzaG9sZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2l2ZXVwPXRydWU7IC8vIHN0b3AgYW5kIHVzZSBxdWljayBzb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIWdpdmV1cClyZXR1cm47XHJcbiAgICAgICAgY291bnQ9Mjt2YXIgc3RhY2s9dGhpcy5zdGFjaztcclxuICAgICAgICBzdGFja1swXT0wO1xyXG4gICAgICAgIHN0YWNrWzFdPXRoaXMubnVtRWxlbWVudHMtMTtcclxuICAgICAgICB3aGlsZShjb3VudD4wKXtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0PXN0YWNrWy0tY291bnRdO1xyXG4gICAgICAgICAgICB2YXIgbGVmdD1zdGFja1stLWNvdW50XTtcclxuICAgICAgICAgICAgdmFyIGRpZmY9cmlnaHQtbGVmdDtcclxuICAgICAgICAgICAgaWYoZGlmZj4xNil7ICAvLyBxdWljayBzb3J0XHJcbiAgICAgICAgICAgICAgICAvL3ZhciBtaWQ9bGVmdCsoZGlmZj4+MSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkID0gbGVmdCArIChfTWF0aC5mbG9vcihkaWZmKjAuNSkpO1xyXG4gICAgICAgICAgICAgICAgdG1wID0gZWxlbWVudHNbbWlkXTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzW21pZF0gPSBlbGVtZW50c1tyaWdodF07XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tyaWdodF0gPSB0bXA7XHJcbiAgICAgICAgICAgICAgICBwaXZvdCA9IHRtcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSBsZWZ0LTE7XHJcbiAgICAgICAgICAgICAgICBqID0gcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSggdHJ1ZSApe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWo7XHJcbiAgICAgICAgICAgICAgICAgICAgZG97IGVpID0gZWxlbWVudHNbKytpXTsgfSB3aGlsZSggZWkudmFsdWUgPCBwaXZvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG97IGVqID0gZWxlbWVudHNbLS1qXTsgfSB3aGlsZSggcGl2b3QgPCBlai52YWx1ZSAmJiBqICE9IGxlZnQgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiggaSA+PSBqICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbaV0gPSBlajtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXSA9IGVpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzW3JpZ2h0XSA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNbaV0gPSB0bXA7XHJcbiAgICAgICAgICAgICAgICBpZiggaSAtIGxlZnQgPiByaWdodCAtIGkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbY291bnQrK10gPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW2NvdW50KytdID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbY291bnQrK10gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbY291bnQrK10gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW2NvdW50KytdID0gbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IGkgLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGZvciggaSA9IGxlZnQgKyAxOyBpIDw9IHJpZ2h0OyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3QgPSB0bXAudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wMiA9IGVsZW1lbnRzW2ktMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIHRtcDIudmFsdWUgPiBwaXZvdCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRve1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0gPSB0bXAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIC0taiA9PSAwICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAyID0gZWxlbWVudHNbai0xXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfXdoaWxlKCB0bXAyLnZhbHVlID4gcGl2b3QgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0gPSB0bXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICBjYWxjdWxhdGVUZXN0Q291bnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG51bSA9IDE7XHJcbiAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMSwgbCA9IHRoaXMubnVtRWxlbWVudHM7IGk8bDsgaSsrKXtcclxuICAgICAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXS5tYXgpe1xyXG4gICAgICAgICAgICAgICAgbnVtLS07XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IG51bTtcclxuICAgICAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcblxyXG4gICAgfVxyXG5cclxufSk7XG5cbi8qKlxyXG4gKiBBbiBlbGVtZW50IG9mIHByb3hpZXMuXHJcbiAqIEBhdXRob3Igc2FoYXJhblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFNBUEVsZW1lbnQgKCBwcm94eSwgbWF4ICkge1xyXG5cclxuICAgIC8vIFRoZSBwYXJlbnQgcHJveHlcclxuICAgIHRoaXMucHJveHkgPSBwcm94eTtcclxuXHQvLyBUaGUgcGFpciBlbGVtZW50LlxyXG4gICAgdGhpcy5wYWlyID0gbnVsbDtcclxuICAgIC8vIFRoZSBtaW5pbXVtIGVsZW1lbnQgb24gb3RoZXIgYXhpcy5cclxuICAgIHRoaXMubWluMSA9IG51bGw7XHJcbiAgICAvLyBUaGUgbWF4aW11bSBlbGVtZW50IG9uIG90aGVyIGF4aXMuXHJcbiAgICB0aGlzLm1heDEgPSBudWxsO1xyXG4gICAgLy8gVGhlIG1pbmltdW0gZWxlbWVudCBvbiBvdGhlciBheGlzLlxyXG4gICAgdGhpcy5taW4yID0gbnVsbDtcclxuICAgIC8vIFRoZSBtYXhpbXVtIGVsZW1lbnQgb24gb3RoZXIgYXhpcy5cclxuICAgIHRoaXMubWF4MiA9IG51bGw7XHJcbiAgICAvLyBXaGV0aGVyIHRoZSBlbGVtZW50IGhhcyBtYXhpbXVtIHZhbHVlIG9yIG5vdC5cclxuICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgLy8gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxyXG4gICAgdGhpcy52YWx1ZSA9IDA7XHJcblxyXG59XG5cbi8qKlxyXG4gKiBBIHByb3h5IGZvciBzd2VlcCBhbmQgcHJ1bmUgYnJvYWQtcGhhc2UuXHJcbiAqIEBhdXRob3Igc2FoYXJhblxyXG4gKiBAYXV0aG9yIGxvLXRoXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gU0FQUHJveHkgKCBzYXAsIHNoYXBlICl7XHJcblxyXG4gICAgUHJveHkuY2FsbCggdGhpcywgc2hhcGUgKTtcclxuICAgIC8vIFR5cGUgb2YgdGhlIGF4aXMgdG8gd2hpY2ggdGhlIHByb3h5IGJlbG9uZ3MgdG8uIFswOm5vbmUsIDE6ZHluYW1pYywgMjpzdGF0aWNdXHJcbiAgICB0aGlzLmJlbG9uZ3NUbyA9IDA7XHJcbiAgICAvLyBUaGUgbWF4aW11bSBlbGVtZW50cyBvbiBlYWNoIGF4aXMuXHJcbiAgICB0aGlzLm1heCA9IFtdO1xyXG4gICAgLy8gVGhlIG1pbmltdW0gZWxlbWVudHMgb24gZWFjaCBheGlzLlxyXG4gICAgdGhpcy5taW4gPSBbXTtcclxuICAgIFxyXG4gICAgdGhpcy5zYXAgPSBzYXA7XHJcbiAgICB0aGlzLm1pblswXSA9IG5ldyBTQVBFbGVtZW50KCB0aGlzLCBmYWxzZSApO1xyXG4gICAgdGhpcy5tYXhbMF0gPSBuZXcgU0FQRWxlbWVudCggdGhpcywgdHJ1ZSApO1xyXG4gICAgdGhpcy5taW5bMV0gPSBuZXcgU0FQRWxlbWVudCggdGhpcywgZmFsc2UgKTtcclxuICAgIHRoaXMubWF4WzFdID0gbmV3IFNBUEVsZW1lbnQoIHRoaXMsIHRydWUgKTtcclxuICAgIHRoaXMubWluWzJdID0gbmV3IFNBUEVsZW1lbnQoIHRoaXMsIGZhbHNlICk7XHJcbiAgICB0aGlzLm1heFsyXSA9IG5ldyBTQVBFbGVtZW50KCB0aGlzLCB0cnVlICk7XHJcbiAgICB0aGlzLm1heFswXS5wYWlyID0gdGhpcy5taW5bMF07XHJcbiAgICB0aGlzLm1heFsxXS5wYWlyID0gdGhpcy5taW5bMV07XHJcbiAgICB0aGlzLm1heFsyXS5wYWlyID0gdGhpcy5taW5bMl07XHJcbiAgICB0aGlzLm1pblswXS5taW4xID0gdGhpcy5taW5bMV07XHJcbiAgICB0aGlzLm1pblswXS5tYXgxID0gdGhpcy5tYXhbMV07XHJcbiAgICB0aGlzLm1pblswXS5taW4yID0gdGhpcy5taW5bMl07XHJcbiAgICB0aGlzLm1pblswXS5tYXgyID0gdGhpcy5tYXhbMl07XHJcbiAgICB0aGlzLm1pblsxXS5taW4xID0gdGhpcy5taW5bMF07XHJcbiAgICB0aGlzLm1pblsxXS5tYXgxID0gdGhpcy5tYXhbMF07XHJcbiAgICB0aGlzLm1pblsxXS5taW4yID0gdGhpcy5taW5bMl07XHJcbiAgICB0aGlzLm1pblsxXS5tYXgyID0gdGhpcy5tYXhbMl07XHJcbiAgICB0aGlzLm1pblsyXS5taW4xID0gdGhpcy5taW5bMF07XHJcbiAgICB0aGlzLm1pblsyXS5tYXgxID0gdGhpcy5tYXhbMF07XHJcbiAgICB0aGlzLm1pblsyXS5taW4yID0gdGhpcy5taW5bMV07XHJcbiAgICB0aGlzLm1pblsyXS5tYXgyID0gdGhpcy5tYXhbMV07XHJcblxyXG59XHJcblxyXG5TQVBQcm94eS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQcm94eS5wcm90b3R5cGUgKSwge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBTQVBQcm94eSxcclxuXHJcblxyXG4gICAgLy8gUmV0dXJucyB3aGV0aGVyIHRoZSBwcm94eSBpcyBkeW5hbWljIG9yIG5vdC5cclxuICAgIGlzRHluYW1pYzogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgYm9keSA9IHRoaXMuc2hhcGUucGFyZW50O1xyXG4gICAgICAgIHJldHVybiBib2R5LmlzRHluYW1pYyAmJiAhYm9keS5zbGVlcGluZztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmFhYmIuZWxlbWVudHM7XHJcbiAgICAgICAgdGhpcy5taW5bMF0udmFsdWUgPSB0ZVswXTtcclxuICAgICAgICB0aGlzLm1pblsxXS52YWx1ZSA9IHRlWzFdO1xyXG4gICAgICAgIHRoaXMubWluWzJdLnZhbHVlID0gdGVbMl07XHJcbiAgICAgICAgdGhpcy5tYXhbMF0udmFsdWUgPSB0ZVszXTtcclxuICAgICAgICB0aGlzLm1heFsxXS52YWx1ZSA9IHRlWzRdO1xyXG4gICAgICAgIHRoaXMubWF4WzJdLnZhbHVlID0gdGVbNV07XHJcblxyXG4gICAgICAgIGlmKCB0aGlzLmJlbG9uZ3NUbyA9PSAxICYmICF0aGlzLmlzRHluYW1pYygpIHx8IHRoaXMuYmVsb25nc1RvID09IDIgJiYgdGhpcy5pc0R5bmFtaWMoKSApe1xyXG4gICAgICAgICAgICB0aGlzLnNhcC5yZW1vdmVQcm94eSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5zYXAuYWRkUHJveHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG4vKipcclxuICogQSBicm9hZC1waGFzZSBjb2xsaXNpb24gZGV0ZWN0aW9uIGFsZ29yaXRobSB1c2luZyBzd2VlcCBhbmQgcHJ1bmUuXHJcbiAqIEBhdXRob3Igc2FoYXJhblxyXG4gKiBAYXV0aG9yIGxvLXRoXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gU0FQQnJvYWRQaGFzZSAoKSB7XHJcblxyXG4gICAgQnJvYWRQaGFzZS5jYWxsKCB0aGlzKTtcclxuICAgIHRoaXMudHlwZXMgPSBCUl9TV0VFUF9BTkRfUFJVTkU7XHJcblxyXG4gICAgdGhpcy5udW1FbGVtZW50c0QgPSAwO1xyXG4gICAgdGhpcy5udW1FbGVtZW50c1MgPSAwO1xyXG4gICAgLy8gZHluYW1pYyBwcm94aWVzXHJcbiAgICB0aGlzLmF4ZXNEID0gW1xyXG4gICAgICAgbmV3IFNBUEF4aXMoKSxcclxuICAgICAgIG5ldyBTQVBBeGlzKCksXHJcbiAgICAgICBuZXcgU0FQQXhpcygpXHJcbiAgICBdO1xyXG4gICAgLy8gc3RhdGljIG9yIHNsZWVwaW5nIHByb3hpZXNcclxuICAgIHRoaXMuYXhlc1MgPSBbXHJcbiAgICAgICBuZXcgU0FQQXhpcygpLFxyXG4gICAgICAgbmV3IFNBUEF4aXMoKSxcclxuICAgICAgIG5ldyBTQVBBeGlzKClcclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5pbmRleDEgPSAwO1xyXG4gICAgdGhpcy5pbmRleDIgPSAxO1xyXG5cclxufVxyXG5cclxuU0FQQnJvYWRQaGFzZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBCcm9hZFBoYXNlLnByb3RvdHlwZSApLCB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFNBUEJyb2FkUGhhc2UsXHJcblxyXG4gICAgY3JlYXRlUHJveHk6IGZ1bmN0aW9uICggc2hhcGUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgU0FQUHJveHkoIHRoaXMsIHNoYXBlICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRQcm94eTogZnVuY3Rpb24gKCBwcm94eSApIHtcclxuXHJcbiAgICAgICAgdmFyIHAgPSBwcm94eTtcclxuICAgICAgICBpZihwLmlzRHluYW1pYygpKXtcclxuICAgICAgICAgICAgdGhpcy5heGVzRFswXS5hZGRFbGVtZW50cyggcC5taW5bMF0sIHAubWF4WzBdICk7XHJcbiAgICAgICAgICAgIHRoaXMuYXhlc0RbMV0uYWRkRWxlbWVudHMoIHAubWluWzFdLCBwLm1heFsxXSApO1xyXG4gICAgICAgICAgICB0aGlzLmF4ZXNEWzJdLmFkZEVsZW1lbnRzKCBwLm1pblsyXSwgcC5tYXhbMl0gKTtcclxuICAgICAgICAgICAgcC5iZWxvbmdzVG8gPSAxO1xyXG4gICAgICAgICAgICB0aGlzLm51bUVsZW1lbnRzRCArPSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXhlc1NbMF0uYWRkRWxlbWVudHMoIHAubWluWzBdLCBwLm1heFswXSApO1xyXG4gICAgICAgICAgICB0aGlzLmF4ZXNTWzFdLmFkZEVsZW1lbnRzKCBwLm1pblsxXSwgcC5tYXhbMV0gKTtcclxuICAgICAgICAgICAgdGhpcy5heGVzU1syXS5hZGRFbGVtZW50cyggcC5taW5bMl0sIHAubWF4WzJdICk7XHJcbiAgICAgICAgICAgIHAuYmVsb25nc1RvID0gMjtcclxuICAgICAgICAgICAgdGhpcy5udW1FbGVtZW50c1MgKz0gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVQcm94eTogZnVuY3Rpb24gKCBwcm94eSApIHtcclxuXHJcbiAgICAgICAgdmFyIHAgPSBwcm94eTtcclxuICAgICAgICBpZiAoIHAuYmVsb25nc1RvID09IDAgKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8qZWxzZSBpZiAoIHAuYmVsb25nc1RvID09IDEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXhlc0RbMF0ucmVtb3ZlRWxlbWVudHMoIHAubWluWzBdLCBwLm1heFswXSApO1xyXG4gICAgICAgICAgICB0aGlzLmF4ZXNEWzFdLnJlbW92ZUVsZW1lbnRzKCBwLm1pblsxXSwgcC5tYXhbMV0gKTtcclxuICAgICAgICAgICAgdGhpcy5heGVzRFsyXS5yZW1vdmVFbGVtZW50cyggcC5taW5bMl0sIHAubWF4WzJdICk7XHJcbiAgICAgICAgICAgIHRoaXMubnVtRWxlbWVudHNEIC09IDI7XHJcbiAgICAgICAgfSBlbHNlIGlmICggcC5iZWxvbmdzVG8gPT0gMiApIHtcclxuICAgICAgICAgICAgdGhpcy5heGVzU1swXS5yZW1vdmVFbGVtZW50cyggcC5taW5bMF0sIHAubWF4WzBdICk7XHJcbiAgICAgICAgICAgIHRoaXMuYXhlc1NbMV0ucmVtb3ZlRWxlbWVudHMoIHAubWluWzFdLCBwLm1heFsxXSApO1xyXG4gICAgICAgICAgICB0aGlzLmF4ZXNTWzJdLnJlbW92ZUVsZW1lbnRzKCBwLm1pblsyXSwgcC5tYXhbMl0gKTtcclxuICAgICAgICAgICAgdGhpcy5udW1FbGVtZW50c1MgLT0gMjtcclxuICAgICAgICB9Ki9cclxuXHJcbiAgICAgICAgc3dpdGNoKCBwLmJlbG9uZ3NUbyApe1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuYXhlc0RbMF0ucmVtb3ZlRWxlbWVudHMoIHAubWluWzBdLCBwLm1heFswXSApO1xyXG4gICAgICAgICAgICB0aGlzLmF4ZXNEWzFdLnJlbW92ZUVsZW1lbnRzKCBwLm1pblsxXSwgcC5tYXhbMV0gKTtcclxuICAgICAgICAgICAgdGhpcy5heGVzRFsyXS5yZW1vdmVFbGVtZW50cyggcC5taW5bMl0sIHAubWF4WzJdICk7XHJcbiAgICAgICAgICAgIHRoaXMubnVtRWxlbWVudHNEIC09IDI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuYXhlc1NbMF0ucmVtb3ZlRWxlbWVudHMoIHAubWluWzBdLCBwLm1heFswXSApO1xyXG4gICAgICAgICAgICB0aGlzLmF4ZXNTWzFdLnJlbW92ZUVsZW1lbnRzKCBwLm1pblsxXSwgcC5tYXhbMV0gKTtcclxuICAgICAgICAgICAgdGhpcy5heGVzU1syXS5yZW1vdmVFbGVtZW50cyggcC5taW5bMl0sIHAubWF4WzJdICk7XHJcbiAgICAgICAgICAgIHRoaXMubnVtRWxlbWVudHNTIC09IDI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcC5iZWxvbmdzVG8gPSAwO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29sbGVjdFBhaXJzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGlmKCB0aGlzLm51bUVsZW1lbnRzRCA9PSAwICkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgYXhpczEgPSB0aGlzLmF4ZXNEW3RoaXMuaW5kZXgxXTtcclxuICAgICAgICB2YXIgYXhpczIgPSB0aGlzLmF4ZXNEW3RoaXMuaW5kZXgyXTtcclxuXHJcbiAgICAgICAgYXhpczEuc29ydCgpO1xyXG4gICAgICAgIGF4aXMyLnNvcnQoKTtcclxuXHJcbiAgICAgICAgdmFyIGNvdW50MSA9IGF4aXMxLmNhbGN1bGF0ZVRlc3RDb3VudCgpO1xyXG4gICAgICAgIHZhciBjb3VudDIgPSBheGlzMi5jYWxjdWxhdGVUZXN0Q291bnQoKTtcclxuICAgICAgICB2YXIgZWxlbWVudHNEO1xyXG4gICAgICAgIHZhciBlbGVtZW50c1M7XHJcbiAgICAgICAgaWYoIGNvdW50MSA8PSBjb3VudDIgKXsvLyBzZWxlY3QgdGhlIGJlc3QgYXhpc1xyXG4gICAgICAgICAgICBheGlzMiA9IHRoaXMuYXhlc1NbdGhpcy5pbmRleDFdO1xyXG4gICAgICAgICAgICBheGlzMi5zb3J0KCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzRCA9IGF4aXMxLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBlbGVtZW50c1MgPSBheGlzMi5lbGVtZW50cztcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgYXhpczEgPSB0aGlzLmF4ZXNTW3RoaXMuaW5kZXgyXTtcclxuICAgICAgICAgICAgYXhpczEuc29ydCgpO1xyXG4gICAgICAgICAgICBlbGVtZW50c0QgPSBheGlzMi5lbGVtZW50cztcclxuICAgICAgICAgICAgZWxlbWVudHNTID0gYXhpczEuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXgxIF49IHRoaXMuaW5kZXgyO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4MiBePSB0aGlzLmluZGV4MTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleDEgXj0gdGhpcy5pbmRleDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhY3RpdmVEO1xyXG4gICAgICAgIHZhciBhY3RpdmVTO1xyXG4gICAgICAgIHZhciBwID0gMDtcclxuICAgICAgICB2YXIgcSA9IDA7XHJcbiAgICAgICAgd2hpbGUoIHAgPCB0aGlzLm51bUVsZW1lbnRzRCApe1xyXG4gICAgICAgICAgICB2YXIgZTE7XHJcbiAgICAgICAgICAgIHZhciBkeW47XHJcbiAgICAgICAgICAgIGlmIChxID09IHRoaXMubnVtRWxlbWVudHNTICl7XHJcbiAgICAgICAgICAgICAgICBlMSA9IGVsZW1lbnRzRFtwXTtcclxuICAgICAgICAgICAgICAgIGR5biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwKys7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBlbGVtZW50c0RbcF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGVsZW1lbnRzU1txXTtcclxuICAgICAgICAgICAgICAgIGlmKCBkLnZhbHVlIDwgcy52YWx1ZSApe1xyXG4gICAgICAgICAgICAgICAgICAgIGUxID0gZDtcclxuICAgICAgICAgICAgICAgICAgICBkeW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHArKztcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGUxID0gcztcclxuICAgICAgICAgICAgICAgICAgICBkeW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoICFlMS5tYXggKXtcclxuICAgICAgICAgICAgICAgIHZhciBzMSA9IGUxLnByb3h5LnNoYXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pbjEgPSBlMS5taW4xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heDEgPSBlMS5tYXgxLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pbjIgPSBlMS5taW4yLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heDIgPSBlMS5tYXgyLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciggdmFyIGUyID0gYWN0aXZlRDsgZTIgIT0gbnVsbDsgZTIgPSBlMi5wYWlyICkgey8vIHRlc3QgZm9yIGR5bmFtaWNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczIgPSBlMi5wcm94eS5zaGFwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udW1QYWlyQ2hlY2tzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIG1pbjEgPiBlMi5tYXgxLnZhbHVlIHx8IG1heDEgPCBlMi5taW4xLnZhbHVlIHx8IG1pbjIgPiBlMi5tYXgyLnZhbHVlIHx8IG1heDIgPCBlMi5taW4yLnZhbHVlIHx8ICF0aGlzLmlzQXZhaWxhYmxlUGFpciggczEsIHMyICkgKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhaXIoIHMxLCBzMiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIGR5biApe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciggZTIgPSBhY3RpdmVTOyBlMiAhPSBudWxsOyBlMiA9IGUyLnBhaXIgKSB7Ly8gdGVzdCBmb3Igc3RhdGljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gZTIucHJveHkuc2hhcGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm51bVBhaXJDaGVja3MrKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBtaW4xID4gZTIubWF4MS52YWx1ZSB8fCBtYXgxIDwgZTIubWluMS52YWx1ZXx8IG1pbjIgPiBlMi5tYXgyLnZhbHVlIHx8IG1heDIgPCBlMi5taW4yLnZhbHVlIHx8ICF0aGlzLmlzQXZhaWxhYmxlUGFpcihzMSxzMikgKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYWlyKCBzMSwgczIgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZTEucGFpciA9IGFjdGl2ZUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRCA9IGUxO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZTEucGFpciA9IGFjdGl2ZVM7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlUyA9IGUxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBlMS5wYWlyO1xyXG4gICAgICAgICAgICAgICAgaWYoIGR5biApe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCBtaW4gPT0gYWN0aXZlRCApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVEID0gYWN0aXZlRC5wYWlyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZTEgPSBhY3RpdmVEO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCBtaW4gPT0gYWN0aXZlUyApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTID0gYWN0aXZlUy5wYWlyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZTEgPSBhY3RpdmVTO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRve1xyXG4gICAgICAgICAgICAgICAgICAgIGUyID0gZTEucGFpcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiggZTIgPT0gbWluICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUxLnBhaXIgPSBlMi5wYWlyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZTEgPSBlMjtcclxuICAgICAgICAgICAgICAgIH13aGlsZSggZTEgIT0gbnVsbCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5kZXgyID0gKHRoaXMuaW5kZXgxfHRoaXMuaW5kZXgyKV4zO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxufSk7XG5cbi8qKlxyXG4qIEEgbm9kZSBvZiB0aGUgZHluYW1pYyBib3VuZGluZyB2b2x1bWUgdHJlZS5cclxuKiBAYXV0aG9yIHNhaGFyYW5cclxuKi9cclxuXHJcbmZ1bmN0aW9uIERCVlROb2RlKCl7XHJcbiAgICBcclxuXHQvLyBUaGUgZmlyc3QgY2hpbGQgbm9kZSBvZiB0aGlzIG5vZGUuXHJcbiAgICB0aGlzLmNoaWxkMSA9IG51bGw7XHJcbiAgICAvLyBUaGUgc2Vjb25kIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlLlxyXG4gICAgdGhpcy5jaGlsZDIgPSBudWxsO1xyXG4gICAgLy8gIFRoZSBwYXJlbnQgbm9kZSBvZiB0aGlzIHRyZWUuXHJcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAvLyBUaGUgcHJveHkgb2YgdGhpcyBub2RlLiBUaGlzIGhhcyBubyB2YWx1ZSBpZiB0aGlzIG5vZGUgaXMgbm90IGxlYWYuXHJcbiAgICB0aGlzLnByb3h5ID0gbnVsbDtcclxuICAgIC8vIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGZyb20gbGVhZiBub2Rlcy5cclxuICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgIC8vIFRoZSBBQUJCIG9mIHRoaXMgbm9kZS5cclxuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG59XG5cbi8qKlxyXG4gKiBBIGR5bmFtaWMgYm91bmRpbmcgdm9sdW1lIHRyZWUgZm9yIHRoZSBicm9hZC1waGFzZSBhbGdvcml0aG0uXHJcbiAqXHJcbiAqIEBhdXRob3Igc2FoYXJhblxyXG4gKiBAYXV0aG9yIGxvLXRoXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gREJWVCgpe1xyXG5cclxuICAgIC8vIFRoZSByb290IG9mIHRoZSB0cmVlLlxyXG4gICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgIHRoaXMuZnJlZU5vZGVzID0gW107XHJcbiAgICB0aGlzLmZyZWVOb2Rlcy5sZW5ndGggPSAxNjM4NDtcclxuICAgIHRoaXMubnVtRnJlZU5vZGVzID0gMDtcclxuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBEQlZULnByb3RvdHlwZSwge1xyXG5cclxuICAgIERCVlQ6IHRydWUsXHJcblxyXG4gICAgbW92ZUxlYWY6IGZ1bmN0aW9uKCBsZWFmICkge1xyXG5cclxuICAgICAgICB0aGlzLmRlbGV0ZUxlYWYoIGxlYWYgKTtcclxuICAgICAgICB0aGlzLmluc2VydExlYWYoIGxlYWYgKTtcclxuICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICBpbnNlcnRMZWFmOiBmdW5jdGlvbiAoIGxlYWYgKSB7XHJcblxyXG4gICAgICAgIGlmKHRoaXMucm9vdCA9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbGVhZjtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGIgPSBsZWFmLmFhYmI7XHJcbiAgICAgICAgdmFyIHNpYmxpbmcgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgdmFyIG9sZEFyZWE7XHJcbiAgICAgICAgdmFyIG5ld0FyZWE7XHJcbiAgICAgICAgd2hpbGUoc2libGluZy5wcm94eSA9PSBudWxsKXsgLy8gZGVzY2VuZCB0aGUgbm9kZSB0byBzZWFyY2ggdGhlIGJlc3QgcGFpclxyXG4gICAgICAgICAgICB2YXIgYzEgPSBzaWJsaW5nLmNoaWxkMTtcclxuICAgICAgICAgICAgdmFyIGMyID0gc2libGluZy5jaGlsZDI7XHJcbiAgICAgICAgICAgIHZhciBiID0gc2libGluZy5hYWJiO1xyXG4gICAgICAgICAgICB2YXIgYzFiID0gYzEuYWFiYjtcclxuICAgICAgICAgICAgdmFyIGMyYiA9IGMyLmFhYmI7XHJcbiAgICAgICAgICAgIG9sZEFyZWEgPSBiLnN1cmZhY2VBcmVhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWFiYi5jb21iaW5lKGxiLGIpO1xyXG4gICAgICAgICAgICBuZXdBcmVhID0gdGhpcy5hYWJiLnN1cmZhY2VBcmVhKCk7XHJcbiAgICAgICAgICAgIHZhciBjcmVhdGluZ0Nvc3QgPSBuZXdBcmVhKjI7XHJcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnRhbENvc3QgPSAobmV3QXJlYS1vbGRBcmVhKSoyOyAvLyBjb3N0IG9mIGNyZWF0aW5nIGEgbmV3IHBhaXIgd2l0aCB0aGUgbm9kZVxyXG4gICAgICAgICAgICB2YXIgZGlzY2VuZGluZ0Nvc3QxID0gaW5jcmVtZW50YWxDb3N0O1xyXG4gICAgICAgICAgICB0aGlzLmFhYmIuY29tYmluZShsYixjMWIpO1xyXG4gICAgICAgICAgICBpZihjMS5wcm94eSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAvLyBsZWFmIGNvc3QgPSBhcmVhKGNvbWJpbmVkIGFhYmIpXHJcbiAgICAgICAgICAgICAgICBkaXNjZW5kaW5nQ29zdDErPXRoaXMuYWFiYi5zdXJmYWNlQXJlYSgpO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUgY29zdCA9IGFyZWEoY29tYmluZWQgYWFiYikgLSBhcmVhKG9sZCBhYWJiKVxyXG4gICAgICAgICAgICAgICAgZGlzY2VuZGluZ0Nvc3QxKz10aGlzLmFhYmIuc3VyZmFjZUFyZWEoKS1jMWIuc3VyZmFjZUFyZWEoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGlzY2VuZGluZ0Nvc3QyPWluY3JlbWVudGFsQ29zdDtcclxuICAgICAgICAgICAgdGhpcy5hYWJiLmNvbWJpbmUobGIsYzJiKTtcclxuICAgICAgICAgICAgaWYoYzIucHJveHkhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgLy8gbGVhZiBjb3N0ID0gYXJlYShjb21iaW5lZCBhYWJiKVxyXG4gICAgICAgICAgICAgICAgZGlzY2VuZGluZ0Nvc3QyKz10aGlzLmFhYmIuc3VyZmFjZUFyZWEoKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIGNvc3QgPSBhcmVhKGNvbWJpbmVkIGFhYmIpIC0gYXJlYShvbGQgYWFiYilcclxuICAgICAgICAgICAgICAgIGRpc2NlbmRpbmdDb3N0Mis9dGhpcy5hYWJiLnN1cmZhY2VBcmVhKCktYzJiLnN1cmZhY2VBcmVhKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZGlzY2VuZGluZ0Nvc3QxPGRpc2NlbmRpbmdDb3N0Mil7XHJcbiAgICAgICAgICAgICAgICBpZihjcmVhdGluZ0Nvc3Q8ZGlzY2VuZGluZ0Nvc3QxKXtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsvLyBzdG9wIGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBjMTsvLyBkZXNjZW5kIGludG8gZmlyc3QgY2hpbGRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZihjcmVhdGluZ0Nvc3Q8ZGlzY2VuZGluZ0Nvc3QyKXtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsvLyBzdG9wIGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBjMjsvLyBkZXNjZW5kIGludG8gc2Vjb25kIGNoaWxkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9sZFBhcmVudCA9IHNpYmxpbmcucGFyZW50O1xyXG4gICAgICAgIHZhciBuZXdQYXJlbnQ7XHJcbiAgICAgICAgaWYodGhpcy5udW1GcmVlTm9kZXM+MCl7XHJcbiAgICAgICAgICAgIG5ld1BhcmVudCA9IHRoaXMuZnJlZU5vZGVzWy0tdGhpcy5udW1GcmVlTm9kZXNdO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQgPSBuZXcgREJWVE5vZGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5ld1BhcmVudC5wYXJlbnQgPSBvbGRQYXJlbnQ7XHJcbiAgICAgICAgbmV3UGFyZW50LmNoaWxkMSA9IGxlYWY7XHJcbiAgICAgICAgbmV3UGFyZW50LmNoaWxkMiA9IHNpYmxpbmc7XHJcbiAgICAgICAgbmV3UGFyZW50LmFhYmIuY29tYmluZShsZWFmLmFhYmIsc2libGluZy5hYWJiKTtcclxuICAgICAgICBuZXdQYXJlbnQuaGVpZ2h0ID0gc2libGluZy5oZWlnaHQrMTtcclxuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICBpZihzaWJsaW5nID09IHRoaXMucm9vdCl7XHJcbiAgICAgICAgICAgIC8vIHJlcGxhY2Ugcm9vdFxyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgY2hpbGRcclxuICAgICAgICAgICAgaWYob2xkUGFyZW50LmNoaWxkMSA9PSBzaWJsaW5nKXtcclxuICAgICAgICAgICAgICAgIG9sZFBhcmVudC5jaGlsZDEgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgb2xkUGFyZW50LmNoaWxkMiA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGUgd2hvbGUgdHJlZVxyXG4gICAgICAgIGRve1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQgPSB0aGlzLmJhbGFuY2UobmV3UGFyZW50KTtcclxuICAgICAgICAgICAgdGhpcy5maXgobmV3UGFyZW50KTtcclxuICAgICAgICAgICAgbmV3UGFyZW50ID0gbmV3UGFyZW50LnBhcmVudDtcclxuICAgICAgICB9d2hpbGUobmV3UGFyZW50ICE9IG51bGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRCYWxhbmNlOiBmdW5jdGlvbiggbm9kZSApIHtcclxuXHJcbiAgICAgICAgaWYobm9kZS5wcm94eSE9bnVsbClyZXR1cm4gMDtcclxuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZDEuaGVpZ2h0LW5vZGUuY2hpbGQyLmhlaWdodDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZUxlYWY6IGZ1bmN0aW9uKCBsZWFmICkge1xyXG5cclxuICAgICAgICBpZihsZWFmID09IHRoaXMucm9vdCl7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IGxlYWYucGFyZW50O1xyXG4gICAgICAgIHZhciBzaWJsaW5nO1xyXG4gICAgICAgIGlmKHBhcmVudC5jaGlsZDE9PWxlYWYpe1xyXG4gICAgICAgICAgICBzaWJsaW5nPXBhcmVudC5jaGlsZDI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHNpYmxpbmc9cGFyZW50LmNoaWxkMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocGFyZW50PT10aGlzLnJvb3Qpe1xyXG4gICAgICAgICAgICB0aGlzLnJvb3Q9c2libGluZztcclxuICAgICAgICAgICAgc2libGluZy5wYXJlbnQ9bnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZ3JhbmRQYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgIHNpYmxpbmcucGFyZW50ID0gZ3JhbmRQYXJlbnQ7XHJcbiAgICAgICAgaWYoZ3JhbmRQYXJlbnQuY2hpbGQxID09IHBhcmVudCApIHtcclxuICAgICAgICAgICAgZ3JhbmRQYXJlbnQuY2hpbGQxID0gc2libGluZztcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgZ3JhbmRQYXJlbnQuY2hpbGQyID0gc2libGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5udW1GcmVlTm9kZXM8MTYzODQpe1xyXG4gICAgICAgICAgICB0aGlzLmZyZWVOb2Rlc1t0aGlzLm51bUZyZWVOb2RlcysrXSA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG97XHJcbiAgICAgICAgICAgIGdyYW5kUGFyZW50ID0gdGhpcy5iYWxhbmNlKGdyYW5kUGFyZW50KTtcclxuICAgICAgICAgICAgdGhpcy5maXgoZ3JhbmRQYXJlbnQpO1xyXG4gICAgICAgICAgICBncmFuZFBhcmVudCA9IGdyYW5kUGFyZW50LnBhcmVudDtcclxuICAgICAgICB9d2hpbGUoIGdyYW5kUGFyZW50ICE9IG51bGwgKTtcclxuICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICBiYWxhbmNlOiBmdW5jdGlvbiggbm9kZSApIHtcclxuXHJcbiAgICAgICAgdmFyIG5oID0gbm9kZS5oZWlnaHQ7XHJcbiAgICAgICAgaWYobmg8Mil7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcCA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgIHZhciBsID0gbm9kZS5jaGlsZDE7XHJcbiAgICAgICAgdmFyIHIgPSBub2RlLmNoaWxkMjtcclxuICAgICAgICB2YXIgbGggPSBsLmhlaWdodDtcclxuICAgICAgICB2YXIgcmggPSByLmhlaWdodDtcclxuICAgICAgICB2YXIgYmFsYW5jZSA9IGxoLXJoO1xyXG4gICAgICAgIHZhciB0Oy8vIGZvciBiaXQgb3BlcmF0aW9uXHJcblxyXG4gICAgICAgIC8vICAgICAgICAgIFsgTiBdXHJcbiAgICAgICAgLy8gICAgICAgICAvICAgICBcXFxyXG4gICAgICAgIC8vICAgIFsgTCBdICAgICAgIFsgUiBdXHJcbiAgICAgICAgLy8gICAgIC8gXFwgICAgICAgICAvIFxcXHJcbiAgICAgICAgLy8gW0wtTF0gW0wtUl0gW1ItTF0gW1ItUl1cclxuXHJcbiAgICAgICAgLy8gSXMgdGhlIHRyZWUgYmFsYW5jZWQ/XHJcbiAgICAgICAgaWYoYmFsYW5jZT4xKXtcclxuICAgICAgICAgICAgdmFyIGxsID0gbC5jaGlsZDE7XHJcbiAgICAgICAgICAgIHZhciBsciA9IGwuY2hpbGQyO1xyXG4gICAgICAgICAgICB2YXIgbGxoID0gbGwuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgbHJoID0gbHIuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gSXMgTC1MIGhpZ2hlciB0aGFuIEwtUj9cclxuICAgICAgICAgICAgaWYobGxoPmxyaCl7XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgTiB0byBMLVJcclxuICAgICAgICAgICAgICAgIGwuY2hpbGQyID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICBbIEwgXVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvICAgICBcXFxyXG4gICAgICAgICAgICAgICAgLy8gICAgW0wtTF0gICAgICAgWyBOIF1cclxuICAgICAgICAgICAgICAgIC8vICAgICAvIFxcICAgICAgICAgLyBcXFxyXG4gICAgICAgICAgICAgICAgLy8gWy4uLl0gWy4uLl0gWyBMIF0gWyBSIF1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IEwtUlxyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZDEgPSBscjtcclxuICAgICAgICAgICAgICAgIGxyLnBhcmVudCA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgWyBMIF1cclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgLyAgICAgXFxcclxuICAgICAgICAgICAgICAgIC8vICAgIFtMLUxdICAgICAgIFsgTiBdXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLyBcXCAgICAgICAgIC8gXFxcclxuICAgICAgICAgICAgICAgIC8vIFsuLi5dIFsuLi5dIFtMLVJdIFsgUiBdXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIGZpeCBib3VuZHMgYW5kIGhlaWdodHNcclxuICAgICAgICAgICAgICAgIG5vZGUuYWFiYi5jb21iaW5lKCBsci5hYWJiLCByLmFhYmIgKTtcclxuICAgICAgICAgICAgICAgIHQgPSBscmgtcmg7XHJcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodD1scmgtKHQmdD4+MzEpKzE7XHJcbiAgICAgICAgICAgICAgICBsLmFhYmIuY29tYmluZShsbC5hYWJiLG5vZGUuYWFiYik7XHJcbiAgICAgICAgICAgICAgICB0PWxsaC1uaDtcclxuICAgICAgICAgICAgICAgIGwuaGVpZ2h0PWxsaC0odCZ0Pj4zMSkrMTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgTiB0byBMLUxcclxuICAgICAgICAgICAgICAgIGwuY2hpbGQxPW5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudD1sO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgIFsgTCBdXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIC8gICAgIFxcXHJcbiAgICAgICAgICAgICAgICAvLyAgICBbIE4gXSAgICAgICBbTC1SXVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC8gXFwgICAgICAgICAvIFxcXHJcbiAgICAgICAgICAgICAgICAvLyBbIEwgXSBbIFIgXSBbLi4uXSBbLi4uXVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgTC1MXHJcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkMSA9IGxsO1xyXG4gICAgICAgICAgICAgICAgbGwucGFyZW50ID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICBbIEwgXVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvICAgICBcXFxyXG4gICAgICAgICAgICAgICAgLy8gICAgWyBOIF0gICAgICAgW0wtUl1cclxuICAgICAgICAgICAgICAgIC8vICAgICAvIFxcICAgICAgICAgLyBcXFxyXG4gICAgICAgICAgICAgICAgLy8gW0wtTF0gWyBSIF0gWy4uLl0gWy4uLl1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gZml4IGJvdW5kcyBhbmQgaGVpZ2h0c1xyXG4gICAgICAgICAgICAgICAgbm9kZS5hYWJiLmNvbWJpbmUobGwuYWFiYixyLmFhYmIpO1xyXG4gICAgICAgICAgICAgICAgdCA9IGxsaCAtIHJoO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQ9bGxoLSh0JnQ+PjMxKSsxO1xyXG5cclxuICAgICAgICAgICAgICAgIGwuYWFiYi5jb21iaW5lKG5vZGUuYWFiYixsci5hYWJiKTtcclxuICAgICAgICAgICAgICAgIHQ9bmgtbHJoO1xyXG4gICAgICAgICAgICAgICAgbC5oZWlnaHQ9bmgtKHQmdD4+MzEpKzE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0IG5ldyBwYXJlbnQgb2YgTFxyXG4gICAgICAgICAgICBpZihwIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGlmKHAuY2hpbGQxPT1ub2RlKXtcclxuICAgICAgICAgICAgICAgICAgICBwLmNoaWxkMT1sO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5jaGlsZDI9bDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Q9bDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsLnBhcmVudD1wO1xyXG4gICAgICAgICAgICByZXR1cm4gbDtcclxuICAgICAgICB9ZWxzZSBpZihiYWxhbmNlPC0xKXtcclxuICAgICAgICAgICAgdmFyIHJsID0gci5jaGlsZDE7XHJcbiAgICAgICAgICAgIHZhciByciA9IHIuY2hpbGQyO1xyXG4gICAgICAgICAgICB2YXIgcmxoID0gcmwuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcnJoID0gcnIuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gSXMgUi1MIGhpZ2hlciB0aGFuIFItUj9cclxuICAgICAgICAgICAgaWYoIHJsaCA+IHJyaCApIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldCBOIHRvIFItUlxyXG4gICAgICAgICAgICAgICAgci5jaGlsZDIgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSByO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgIFsgUiBdXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIC8gICAgIFxcXHJcbiAgICAgICAgICAgICAgICAvLyAgICBbUi1MXSAgICAgICBbIE4gXVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC8gXFwgICAgICAgICAvIFxcXHJcbiAgICAgICAgICAgICAgICAvLyBbLi4uXSBbLi4uXSBbIEwgXSBbIFIgXVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgUi1SXHJcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkMiA9IHJyO1xyXG4gICAgICAgICAgICAgICAgcnIucGFyZW50ID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICBbIFIgXVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvICAgICBcXFxyXG4gICAgICAgICAgICAgICAgLy8gICAgW1ItTF0gICAgICAgWyBOIF1cclxuICAgICAgICAgICAgICAgIC8vICAgICAvIFxcICAgICAgICAgLyBcXFxyXG4gICAgICAgICAgICAgICAgLy8gWy4uLl0gWy4uLl0gWyBMIF0gW1ItUl1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gZml4IGJvdW5kcyBhbmQgaGVpZ2h0c1xyXG4gICAgICAgICAgICAgICAgbm9kZS5hYWJiLmNvbWJpbmUobC5hYWJiLHJyLmFhYmIpO1xyXG4gICAgICAgICAgICAgICAgdCA9IGxoLXJyaDtcclxuICAgICAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gbGgtKHQmdD4+MzEpKzE7XHJcbiAgICAgICAgICAgICAgICByLmFhYmIuY29tYmluZShybC5hYWJiLG5vZGUuYWFiYik7XHJcbiAgICAgICAgICAgICAgICB0ID0gcmxoLW5oO1xyXG4gICAgICAgICAgICAgICAgci5oZWlnaHQgPSBybGgtKHQmdD4+MzEpKzE7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IE4gdG8gUi1MXHJcbiAgICAgICAgICAgICAgICByLmNoaWxkMSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHI7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICBbIFIgXVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvICAgICBcXFxyXG4gICAgICAgICAgICAgICAgLy8gICAgWyBOIF0gICAgICAgW1ItUl1cclxuICAgICAgICAgICAgICAgIC8vICAgICAvIFxcICAgICAgICAgLyBcXFxyXG4gICAgICAgICAgICAgICAgLy8gWyBMIF0gWyBSIF0gWy4uLl0gWy4uLl1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IFItTFxyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZDIgPSBybDtcclxuICAgICAgICAgICAgICAgIHJsLnBhcmVudCA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgWyBSIF1cclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgLyAgICAgXFxcclxuICAgICAgICAgICAgICAgIC8vICAgIFsgTiBdICAgICAgIFtSLVJdXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLyBcXCAgICAgICAgIC8gXFxcclxuICAgICAgICAgICAgICAgIC8vIFsgTCBdIFtSLUxdIFsuLi5dIFsuLi5dXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIGZpeCBib3VuZHMgYW5kIGhlaWdodHNcclxuICAgICAgICAgICAgICAgIG5vZGUuYWFiYi5jb21iaW5lKGwuYWFiYixybC5hYWJiKTtcclxuICAgICAgICAgICAgICAgIHQ9bGgtcmxoO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQ9bGgtKHQmdD4+MzEpKzE7XHJcbiAgICAgICAgICAgICAgICByLmFhYmIuY29tYmluZShub2RlLmFhYmIscnIuYWFiYik7XHJcbiAgICAgICAgICAgICAgICB0PW5oLXJyaDtcclxuICAgICAgICAgICAgICAgIHIuaGVpZ2h0PW5oLSh0JnQ+PjMxKSsxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNldCBuZXcgcGFyZW50IG9mIFJcclxuICAgICAgICAgICAgaWYocCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBpZihwLmNoaWxkMT09bm9kZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5jaGlsZDE9cjtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHAuY2hpbGQyPXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290PXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgci5wYXJlbnQ9cDtcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaXg6IGZ1bmN0aW9uICggbm9kZSApIHtcclxuXHJcbiAgICAgICAgdmFyIGMxID0gbm9kZS5jaGlsZDE7XHJcbiAgICAgICAgdmFyIGMyID0gbm9kZS5jaGlsZDI7XHJcbiAgICAgICAgbm9kZS5hYWJiLmNvbWJpbmUoIGMxLmFhYmIsIGMyLmFhYmIgKTtcclxuICAgICAgICBub2RlLmhlaWdodCA9IGMxLmhlaWdodCA8IGMyLmhlaWdodCA/IGMyLmhlaWdodCsxIDogYzEuaGVpZ2h0KzE7IFxyXG5cclxuICAgIH1cclxuICAgIFxyXG59KTtcblxuLyoqXHJcbiogQSBwcm94eSBmb3IgZHluYW1pYyBib3VuZGluZyB2b2x1bWUgdHJlZSBicm9hZC1waGFzZS5cclxuKiBAYXV0aG9yIHNhaGFyYW5cclxuKi9cclxuXHJcbmZ1bmN0aW9uIERCVlRQcm94eSAoIHNoYXBlICkge1xyXG5cclxuICAgIFByb3h5LmNhbGwoIHRoaXMsIHNoYXBlKTtcclxuICAgIC8vIFRoZSBsZWFmIG9mIHRoZSBwcm94eS5cclxuICAgIHRoaXMubGVhZiA9IG5ldyBEQlZUTm9kZSgpO1xyXG4gICAgdGhpcy5sZWFmLnByb3h5ID0gdGhpcztcclxuXHJcbn1cclxuXHJcbkRCVlRQcm94eS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQcm94eS5wcm90b3R5cGUgKSwge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBEQlZUUHJveHksXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfVxyXG5cclxufSk7XG5cbi8qKlxyXG4gKiBBIGJyb2FkLXBoYXNlIGFsZ29yaXRobSB1c2luZyBkeW5hbWljIGJvdW5kaW5nIHZvbHVtZSB0cmVlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIHNhaGFyYW5cclxuICogQGF1dGhvciBsby10aFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIERCVlRCcm9hZFBoYXNlKCl7XHJcblxyXG4gICAgQnJvYWRQaGFzZS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlcyA9IEJSX0JPVU5ESU5HX1ZPTFVNRV9UUkVFO1xyXG5cclxuICAgIHRoaXMudHJlZSA9IG5ldyBEQlZUKCk7XHJcbiAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICB0aGlzLmxlYXZlcyA9IFtdO1xyXG4gICAgdGhpcy5udW1MZWF2ZXMgPSAwO1xyXG5cclxufVxyXG5cclxuREJWVEJyb2FkUGhhc2UucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQnJvYWRQaGFzZS5wcm90b3R5cGUgKSwge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBEQlZUQnJvYWRQaGFzZSxcclxuXHJcbiAgICBjcmVhdGVQcm94eTogZnVuY3Rpb24gKCBzaGFwZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEQlZUUHJveHkoIHNoYXBlICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRQcm94eTogZnVuY3Rpb24gKCBwcm94eSApIHtcclxuXHJcbiAgICAgICAgdGhpcy50cmVlLmluc2VydExlYWYoIHByb3h5LmxlYWYgKTtcclxuICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKCBwcm94eS5sZWFmICk7XHJcbiAgICAgICAgdGhpcy5udW1MZWF2ZXMrKztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZVByb3h5OiBmdW5jdGlvbiAoIHByb3h5ICkge1xyXG5cclxuICAgICAgICB0aGlzLnRyZWUuZGVsZXRlTGVhZiggcHJveHkubGVhZiApO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5sZWF2ZXMuaW5kZXhPZiggcHJveHkubGVhZiApO1xyXG4gICAgICAgIGlmICggbiA+IC0xICkge1xyXG4gICAgICAgICAgICB0aGlzLmxlYXZlcy5zcGxpY2UobiwxKTtcclxuICAgICAgICAgICAgdGhpcy5udW1MZWF2ZXMtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb2xsZWN0UGFpcnM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm51bUxlYXZlcyA8IDIgKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBsZWFmLCBtYXJnaW4gPSAwLjEsIGkgPSB0aGlzLm51bUxlYXZlcztcclxuXHJcbiAgICAgICAgd2hpbGUoaS0tKXtcclxuXHJcbiAgICAgICAgICAgIGxlYWYgPSB0aGlzLmxlYXZlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbGVhZi5wcm94eS5hYWJiLmludGVyc2VjdFRlc3RUd28oIGxlYWYuYWFiYiApICl7XHJcblxyXG4gICAgICAgICAgICAgICAgbGVhZi5hYWJiLmNvcHkoIGxlYWYucHJveHkuYWFiYiwgbWFyZ2luICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWUuZGVsZXRlTGVhZiggbGVhZiApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLmluc2VydExlYWYoIGxlYWYgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkZSggbGVhZiwgdGhpcy50cmVlLnJvb3QgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiAoIG5vZGUxLCBub2RlMiApIHtcclxuXHJcbiAgICAgICAgdmFyIHN0YWNrQ291bnQgPSAyO1xyXG4gICAgICAgIHZhciBzMSwgczIsIG4xLCBuMiwgbDEsIGwyO1xyXG4gICAgICAgIHRoaXMuc3RhY2tbMF0gPSBub2RlMTtcclxuICAgICAgICB0aGlzLnN0YWNrWzFdID0gbm9kZTI7XHJcblxyXG4gICAgICAgIHdoaWxlKCBzdGFja0NvdW50ID4gMCApe1xyXG5cclxuICAgICAgICAgICAgbjEgPSB0aGlzLnN0YWNrWy0tc3RhY2tDb3VudF07XHJcbiAgICAgICAgICAgIG4yID0gdGhpcy5zdGFja1stLXN0YWNrQ291bnRdO1xyXG4gICAgICAgICAgICBsMSA9IG4xLnByb3h5ICE9IG51bGw7XHJcbiAgICAgICAgICAgIGwyID0gbjIucHJveHkgIT0gbnVsbDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMubnVtUGFpckNoZWNrcysrO1xyXG5cclxuICAgICAgICAgICAgaWYoIGwxICYmIGwyICl7XHJcbiAgICAgICAgICAgICAgICBzMSA9IG4xLnByb3h5LnNoYXBlO1xyXG4gICAgICAgICAgICAgICAgczIgPSBuMi5wcm94eS5zaGFwZTtcclxuICAgICAgICAgICAgICAgIGlmICggczEgPT0gczIgfHwgczEuYWFiYi5pbnRlcnNlY3RUZXN0KCBzMi5hYWJiICkgfHwgIXRoaXMuaXNBdmFpbGFibGVQYWlyKCBzMSwgczIgKSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFpcihzMSxzMik7XHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG4xLmFhYmIuaW50ZXJzZWN0VGVzdCggbjIuYWFiYiApICkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8qaWYoc3RhY2tDb3VudCs0Pj10aGlzLm1heFN0YWNrKXsvLyBleHBhbmQgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLm1heFN0YWNrPDw9MTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heFN0YWNrKj0yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGFjayA9IFtdOy8vIHZlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrLmxlbmd0aCA9IHRoaXMubWF4U3RhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7aTxzdGFja0NvdW50O2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrW2ldID0gdGhpcy5zdGFja1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5ld1N0YWNrO1xyXG4gICAgICAgICAgICAgICAgfSovXHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIGwyIHx8ICFsMSAmJiAobjEuYWFiYi5zdXJmYWNlQXJlYSgpID4gbjIuYWFiYi5zdXJmYWNlQXJlYSgpKSApe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tbc3RhY2tDb3VudCsrXSA9IG4xLmNoaWxkMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrW3N0YWNrQ291bnQrK10gPSBuMjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrW3N0YWNrQ291bnQrK10gPSBuMS5jaGlsZDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja1tzdGFja0NvdW50KytdID0gbjI7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrW3N0YWNrQ291bnQrK10gPSBuMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrW3N0YWNrQ291bnQrK10gPSBuMi5jaGlsZDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja1tzdGFja0NvdW50KytdID0gbjE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFja1tzdGFja0NvdW50KytdID0gbjIuY2hpbGQyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG5mdW5jdGlvbiBDb2xsaXNpb25EZXRlY3RvciAoKXtcclxuXHJcbiAgICB0aGlzLmZsaXAgPSBmYWxzZTtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIENvbGxpc2lvbkRldGVjdG9yLnByb3RvdHlwZSwge1xyXG5cclxuICAgIENvbGxpc2lvbkRldGVjdG9yOiB0cnVlLFxyXG5cclxuICAgIGRldGVjdENvbGxpc2lvbjogZnVuY3Rpb24gKCBzaGFwZTEsIHNoYXBlMiwgbWFuaWZvbGQgKSB7XHJcblxyXG4gICAgICAgIHByaW50RXJyb3IoXCJDb2xsaXNpb25EZXRlY3RvclwiLCBcIkluaGVyaXRhbmNlIGVycm9yLlwiKTtcclxuXHJcbiAgICB9XHJcblxyXG59ICk7XG5cbi8qKlxyXG4gKiBBIGNvbGxpc2lvbiBkZXRlY3RvciB3aGljaCBkZXRlY3RzIGNvbGxpc2lvbnMgYmV0d2VlbiB0d28gYm94ZXMuXHJcbiAqIEBhdXRob3Igc2FoYXJhblxyXG4gKi9cclxuZnVuY3Rpb24gQm94Qm94Q29sbGlzaW9uRGV0ZWN0b3IoKSB7XHJcblxyXG4gICAgQ29sbGlzaW9uRGV0ZWN0b3IuY2FsbCggdGhpcyApO1xyXG4gICAgdGhpcy5jbGlwVmVydGljZXMxID0gbmV3IEZsb2F0MzJBcnJheSggMjQgKTsgLy8gOCB2ZXJ0aWNlcyB4LHkselxyXG4gICAgdGhpcy5jbGlwVmVydGljZXMyID0gbmV3IEZsb2F0MzJBcnJheSggMjQgKTtcclxuICAgIHRoaXMudXNlZCA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKTtcclxuICAgIFxyXG4gICAgdGhpcy5JTkYgPSAxLzA7XHJcblxyXG59XHJcblxyXG5Cb3hCb3hDb2xsaXNpb25EZXRlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDb2xsaXNpb25EZXRlY3Rvci5wcm90b3R5cGUgKSwge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBCb3hCb3hDb2xsaXNpb25EZXRlY3RvcixcclxuXHJcbiAgICBkZXRlY3RDb2xsaXNpb246IGZ1bmN0aW9uICggc2hhcGUxLCBzaGFwZTIsIG1hbmlmb2xkICkge1xyXG4gICAgICAgIC8vIFdoYXQgeW91IGFyZSBkb2luZyBcclxuICAgICAgICAvLyDCtyBJIHRvIHByZXBhcmUgYSBzZXBhcmF0ZSBheGlzIG9mIHRoZSBmaWZ0ZWVuIFxyXG4gICAgICAgIC8vLVNpeCBpbiBlYWNoIG9mIHRocmVlIG5vcm1hbCB2ZWN0b3JzIG9mIHRoZSB4eXogZGlyZWN0aW9uIG9mIHRoZSBib3ggYm90aCBcclxuICAgICAgICAvLyDCtyBSZW1haW5pbmcgbmluZSAzeDMgYSB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgc2lkZSBvZiB0aGUgYm94IDIgYW5kIHRoZSBzaWRlIG9mIHRoZSBib3ggMSBcclxuICAgICAgICAvLyDCtyBDYWxjdWxhdGUgdGhlIGRlcHRoIHRvIHRoZSBzZXBhcmF0aW9uIGF4aXMgXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIHVzaW5nIHRoZSBpbm5lciBwcm9kdWN0IGFuZCBwdXQgdGhlIGFtb3VudCBvZiBlbWJlZG1lbnQgXHJcbiAgICAgICAgLy8gwrcgSG93ZXZlciBhIHZlcnRpY2FsIHNlcGFyYXRpb24gYXhpcyBhbmQgc2lkZSB0byB3ZWlnaHQgYSBsaXR0bGUgdG8gYXZvaWQgdmlicmF0aW9uIFxyXG4gICAgICAgIC8vIEFuZCBlbmQgd2hlbiB0aGVyZSBpcyBhIHNlcGFyYXRlIGF4aXMgdGhhdCBpcyByZW1vdGUgZXZlbiBvbmUgXHJcbiAgICAgICAgLy8gwrcgSSBsb29rIGZvciBzZXBhcmF0aW9uIGF4aXMgd2l0aCBsaXR0bGUgdG8gZGVudCBtb3N0IFxyXG4gICAgICAgIC8vIE1lbiBhbmQgaWYgc2VwYXJhdGlvbiBheGlzIG9mIHRoZSBmaXJzdCBzaXggLSBlbmQgY29sbGlzaW9uIFxyXG4gICAgICAgIC8vIEhlbmcgSWYgaXQgc2VwYXJhdGUgYXhpcyBvZiBuaW5lIG90aGVyIC0gc2lkZSBjb2xsaXNpb24gXHJcbiAgICAgICAgLy8gSGVuZyAtIGNhc2Ugb2YgYSBzaWRlIGNvbGxpc2lvbiBcclxuICAgICAgICAvLyDCtyBGaW5kIHBvaW50cyBvZiB0d28gc2lkZXMgb24gd2hpY2ggeW91IG1hZGUg4oCL4oCLdGhlIHNlcGFyYXRpb24gYXhpcyBcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlcyB0aGUgcG9pbnQgb2YgY2xvc2VzdCBhcHByb2FjaCBvZiBhIHN0cmFpZ2h0IGxpbmUgY29uc2lzdGluZyBvZiBzZXBhcmF0ZSBheGlzIHBvaW50cyBvYnRhaW5lZCwgYW5kIHRoZSBjb2xsaXNpb24gcG9pbnQgXHJcbiAgICAgICAgLy8tU3VyZmFjZSAtIHRoZSBjYXNlIG9mIHRoZSBwbGFuZSBjcmFzaCBcclxuICAgICAgICAvLy1Cb3ggQSwgYm94IEIgYW5kIHRoZSBvdGhlciBhIGJveCBvZiBiZXR0ZXIgbWFkZSDigIvigIthIHNlcGFyYXRlIGF4aXMgXHJcbiAgICAgICAgLy8g4oCiIFRoZSBzdXJmYWNlIEEgYW5kIHRoZSBwbGFuZSB0aGF0IG1hZGUgdGhlIHNlcGFyYXRpb24gYXhpcyBvZiB0aGUgYm94IEEsIGFuZCBCIHRvIHRoZSBzdXJmYWNlIHRoZSBmYWNlIG9mIHRoZSBib3ggQiBjbG9zZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvIHRoZSBtb3N0IGlzb2xhdGVkIGF4aXMgXHJcblxyXG4gICAgICAgIC8vIFdoZW4gdmlld2VkIGZyb20gdGhlIGZyb250IHN1cmZhY2UgQSwgYW5kIHRoZSBjdXQgcGFydCBleGNlZWRpbmcgdGhlIGFyZWEgb2YgdGhlIHN1cmZhY2UgQSBpcyBhIHN1cmZhY2UgQiBcclxuICAgICAgICAvLy1QbGFuZSBCIGJlY29tZXMgdGhlIDMtOCB0cmlhbmdsZSwgSSBhIGNhbmRpZGF0ZSBmb3IgdGhlIGNvbGxpc2lvbiBwb2ludCB0aGUgdmVydGV4IG9mIHN1cmZhY2UgQiBcclxuICAgICAgICAvLyDigKIgSWYgbW9yZSB0aGFuIG9uZSBjYW5kaWRhdGUgNSBleGlzdHMsIHNjcmFwaW5nIHVwIHRvIGZvdXIgXHJcblxyXG4gICAgICAgIC8vIEZvciBwb3RlbnRpYWwgY29sbGlzaW9uIHBvaW50cyBvZiBhbGwsIHRvIGV4YW1pbmUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHN1cmZhY2UgQSBcclxuICAgICAgICAvLyDigKIgSWYgeW91IHdlcmUgb24gdGhlIGluc2lkZSBzdXJmYWNlIG9mIEEsIGFuZCB0aGUgY29sbGlzaW9uIHBvaW50XHJcblxyXG4gICAgICAgIHZhciBiMTtcclxuICAgICAgICB2YXIgYjI7XHJcbiAgICAgICAgaWYoc2hhcGUxLmlkPHNoYXBlMi5pZCl7XHJcbiAgICAgICAgICAgIGIxPShzaGFwZTEpO1xyXG4gICAgICAgICAgICBiMj0oc2hhcGUyKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgYjE9KHNoYXBlMik7XHJcbiAgICAgICAgICAgIGIyPShzaGFwZTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgVjEgPSBiMS5lbGVtZW50cztcclxuICAgICAgICB2YXIgVjIgPSBiMi5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdmFyIEQxID0gYjEuZGltZW50aW9ucztcclxuICAgICAgICB2YXIgRDIgPSBiMi5kaW1lbnRpb25zO1xyXG5cclxuICAgICAgICB2YXIgcDE9YjEucG9zaXRpb247XHJcbiAgICAgICAgdmFyIHAyPWIyLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBwMXg9cDEueDtcclxuICAgICAgICB2YXIgcDF5PXAxLnk7XHJcbiAgICAgICAgdmFyIHAxej1wMS56O1xyXG4gICAgICAgIHZhciBwMng9cDIueDtcclxuICAgICAgICB2YXIgcDJ5PXAyLnk7XHJcbiAgICAgICAgdmFyIHAyej1wMi56O1xyXG4gICAgICAgIC8vIGRpZmZcclxuICAgICAgICB2YXIgZHg9cDJ4LXAxeDtcclxuICAgICAgICB2YXIgZHk9cDJ5LXAxeTtcclxuICAgICAgICB2YXIgZHo9cDJ6LXAxejtcclxuICAgICAgICAvLyBkaXN0YW5jZVxyXG4gICAgICAgIHZhciB3MT1iMS5oYWxmV2lkdGg7XHJcbiAgICAgICAgdmFyIGgxPWIxLmhhbGZIZWlnaHQ7XHJcbiAgICAgICAgdmFyIGQxPWIxLmhhbGZEZXB0aDtcclxuICAgICAgICB2YXIgdzI9YjIuaGFsZldpZHRoO1xyXG4gICAgICAgIHZhciBoMj1iMi5oYWxmSGVpZ2h0O1xyXG4gICAgICAgIHZhciBkMj1iMi5oYWxmRGVwdGg7XHJcbiAgICAgICAgLy8gZGlyZWN0aW9uXHJcblxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyAxNSBzZXBhcmF0aW5nIGF4ZXNcclxuICAgICAgICAvLyAxfjY6IGZhY2VcclxuICAgICAgICAvLyA3fmY6IGVkZ2VcclxuICAgICAgICAvLyBodHRwOi8vbWFydXBla2UyOTYuY29tL0NPTF8zRF9ObzEzX09CQnZzT0JCLmh0bWxcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGExeD1EMVswXTtcclxuICAgICAgICB2YXIgYTF5PUQxWzFdO1xyXG4gICAgICAgIHZhciBhMXo9RDFbMl07XHJcbiAgICAgICAgdmFyIGEyeD1EMVszXTtcclxuICAgICAgICB2YXIgYTJ5PUQxWzRdO1xyXG4gICAgICAgIHZhciBhMno9RDFbNV07XHJcbiAgICAgICAgdmFyIGEzeD1EMVs2XTtcclxuICAgICAgICB2YXIgYTN5PUQxWzddO1xyXG4gICAgICAgIHZhciBhM3o9RDFbOF07XHJcbiAgICAgICAgdmFyIGQxeD1EMVs5XTtcclxuICAgICAgICB2YXIgZDF5PUQxWzEwXTtcclxuICAgICAgICB2YXIgZDF6PUQxWzExXTtcclxuICAgICAgICB2YXIgZDJ4PUQxWzEyXTtcclxuICAgICAgICB2YXIgZDJ5PUQxWzEzXTtcclxuICAgICAgICB2YXIgZDJ6PUQxWzE0XTtcclxuICAgICAgICB2YXIgZDN4PUQxWzE1XTtcclxuICAgICAgICB2YXIgZDN5PUQxWzE2XTtcclxuICAgICAgICB2YXIgZDN6PUQxWzE3XTtcclxuXHJcbiAgICAgICAgdmFyIGE0eD1EMlswXTtcclxuICAgICAgICB2YXIgYTR5PUQyWzFdO1xyXG4gICAgICAgIHZhciBhNHo9RDJbMl07XHJcbiAgICAgICAgdmFyIGE1eD1EMlszXTtcclxuICAgICAgICB2YXIgYTV5PUQyWzRdO1xyXG4gICAgICAgIHZhciBhNXo9RDJbNV07XHJcbiAgICAgICAgdmFyIGE2eD1EMls2XTtcclxuICAgICAgICB2YXIgYTZ5PUQyWzddO1xyXG4gICAgICAgIHZhciBhNno9RDJbOF07XHJcbiAgICAgICAgdmFyIGQ0eD1EMls5XTtcclxuICAgICAgICB2YXIgZDR5PUQyWzEwXTtcclxuICAgICAgICB2YXIgZDR6PUQyWzExXTtcclxuICAgICAgICB2YXIgZDV4PUQyWzEyXTtcclxuICAgICAgICB2YXIgZDV5PUQyWzEzXTtcclxuICAgICAgICB2YXIgZDV6PUQyWzE0XTtcclxuICAgICAgICB2YXIgZDZ4PUQyWzE1XTtcclxuICAgICAgICB2YXIgZDZ5PUQyWzE2XTtcclxuICAgICAgICB2YXIgZDZ6PUQyWzE3XTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYTd4PWExeSphNHotYTF6KmE0eTtcclxuICAgICAgICB2YXIgYTd5PWExeiphNHgtYTF4KmE0ejtcclxuICAgICAgICB2YXIgYTd6PWExeCphNHktYTF5KmE0eDtcclxuICAgICAgICB2YXIgYTh4PWExeSphNXotYTF6KmE1eTtcclxuICAgICAgICB2YXIgYTh5PWExeiphNXgtYTF4KmE1ejtcclxuICAgICAgICB2YXIgYTh6PWExeCphNXktYTF5KmE1eDtcclxuICAgICAgICB2YXIgYTl4PWExeSphNnotYTF6KmE2eTtcclxuICAgICAgICB2YXIgYTl5PWExeiphNngtYTF4KmE2ejtcclxuICAgICAgICB2YXIgYTl6PWExeCphNnktYTF5KmE2eDtcclxuICAgICAgICB2YXIgYWF4PWEyeSphNHotYTJ6KmE0eTtcclxuICAgICAgICB2YXIgYWF5PWEyeiphNHgtYTJ4KmE0ejtcclxuICAgICAgICB2YXIgYWF6PWEyeCphNHktYTJ5KmE0eDtcclxuICAgICAgICB2YXIgYWJ4PWEyeSphNXotYTJ6KmE1eTtcclxuICAgICAgICB2YXIgYWJ5PWEyeiphNXgtYTJ4KmE1ejtcclxuICAgICAgICB2YXIgYWJ6PWEyeCphNXktYTJ5KmE1eDtcclxuICAgICAgICB2YXIgYWN4PWEyeSphNnotYTJ6KmE2eTtcclxuICAgICAgICB2YXIgYWN5PWEyeiphNngtYTJ4KmE2ejtcclxuICAgICAgICB2YXIgYWN6PWEyeCphNnktYTJ5KmE2eDtcclxuICAgICAgICB2YXIgYWR4PWEzeSphNHotYTN6KmE0eTtcclxuICAgICAgICB2YXIgYWR5PWEzeiphNHgtYTN4KmE0ejtcclxuICAgICAgICB2YXIgYWR6PWEzeCphNHktYTN5KmE0eDtcclxuICAgICAgICB2YXIgYWV4PWEzeSphNXotYTN6KmE1eTtcclxuICAgICAgICB2YXIgYWV5PWEzeiphNXgtYTN4KmE1ejtcclxuICAgICAgICB2YXIgYWV6PWEzeCphNXktYTN5KmE1eDtcclxuICAgICAgICB2YXIgYWZ4PWEzeSphNnotYTN6KmE2eTtcclxuICAgICAgICB2YXIgYWZ5PWEzeiphNngtYTN4KmE2ejtcclxuICAgICAgICB2YXIgYWZ6PWEzeCphNnktYTN5KmE2eDtcclxuICAgICAgICAvLyByaWdodCBvciBsZWZ0IGZsYWdzXHJcbiAgICAgICAgdmFyIHJpZ2h0MTtcclxuICAgICAgICB2YXIgcmlnaHQyO1xyXG4gICAgICAgIHZhciByaWdodDM7XHJcbiAgICAgICAgdmFyIHJpZ2h0NDtcclxuICAgICAgICB2YXIgcmlnaHQ1O1xyXG4gICAgICAgIHZhciByaWdodDY7XHJcbiAgICAgICAgdmFyIHJpZ2h0NztcclxuICAgICAgICB2YXIgcmlnaHQ4O1xyXG4gICAgICAgIHZhciByaWdodDk7XHJcbiAgICAgICAgdmFyIHJpZ2h0YTtcclxuICAgICAgICB2YXIgcmlnaHRiO1xyXG4gICAgICAgIHZhciByaWdodGM7XHJcbiAgICAgICAgdmFyIHJpZ2h0ZDtcclxuICAgICAgICB2YXIgcmlnaHRlO1xyXG4gICAgICAgIHZhciByaWdodGY7XHJcbiAgICAgICAgLy8gb3ZlcmxhcHBpbmcgZGlzdGFuY2VzXHJcbiAgICAgICAgdmFyIG92ZXJsYXAxO1xyXG4gICAgICAgIHZhciBvdmVybGFwMjtcclxuICAgICAgICB2YXIgb3ZlcmxhcDM7XHJcbiAgICAgICAgdmFyIG92ZXJsYXA0O1xyXG4gICAgICAgIHZhciBvdmVybGFwNTtcclxuICAgICAgICB2YXIgb3ZlcmxhcDY7XHJcbiAgICAgICAgdmFyIG92ZXJsYXA3O1xyXG4gICAgICAgIHZhciBvdmVybGFwODtcclxuICAgICAgICB2YXIgb3ZlcmxhcDk7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBhO1xyXG4gICAgICAgIHZhciBvdmVybGFwYjtcclxuICAgICAgICB2YXIgb3ZlcmxhcGM7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBkO1xyXG4gICAgICAgIHZhciBvdmVybGFwZTtcclxuICAgICAgICB2YXIgb3ZlcmxhcGY7XHJcbiAgICAgICAgLy8gaW52YWxpZCBmbGFnc1xyXG4gICAgICAgIHZhciBpbnZhbGlkNz1mYWxzZTtcclxuICAgICAgICB2YXIgaW52YWxpZDg9ZmFsc2U7XHJcbiAgICAgICAgdmFyIGludmFsaWQ5PWZhbHNlO1xyXG4gICAgICAgIHZhciBpbnZhbGlkYT1mYWxzZTtcclxuICAgICAgICB2YXIgaW52YWxpZGI9ZmFsc2U7XHJcbiAgICAgICAgdmFyIGludmFsaWRjPWZhbHNlO1xyXG4gICAgICAgIHZhciBpbnZhbGlkZD1mYWxzZTtcclxuICAgICAgICB2YXIgaW52YWxpZGU9ZmFsc2U7XHJcbiAgICAgICAgdmFyIGludmFsaWRmPWZhbHNlO1xyXG4gICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZXNcclxuICAgICAgICB2YXIgbGVuO1xyXG4gICAgICAgIHZhciBsZW4xO1xyXG4gICAgICAgIHZhciBsZW4yO1xyXG4gICAgICAgIHZhciBkb3QxO1xyXG4gICAgICAgIHZhciBkb3QyO1xyXG4gICAgICAgIHZhciBkb3QzO1xyXG4gICAgICAgIC8vIHRyeSBheGlzIDFcclxuICAgICAgICBsZW49YTF4KmR4K2ExeSpkeSthMXoqZHo7XHJcbiAgICAgICAgcmlnaHQxPWxlbj4wO1xyXG4gICAgICAgIGlmKCFyaWdodDEpbGVuPS1sZW47XHJcbiAgICAgICAgbGVuMT13MTtcclxuICAgICAgICBkb3QxPWExeCphNHgrYTF5KmE0eSthMXoqYTR6O1xyXG4gICAgICAgIGRvdDI9YTF4KmE1eCthMXkqYTV5K2ExeiphNXo7XHJcbiAgICAgICAgZG90Mz1hMXgqYTZ4K2ExeSphNnkrYTF6KmE2ejtcclxuICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICBpZihkb3QzPDApZG90Mz0tZG90MztcclxuICAgICAgICBsZW4yPWRvdDEqdzIrZG90MipoMitkb3QzKmQyO1xyXG4gICAgICAgIG92ZXJsYXAxPWxlbi1sZW4xLWxlbjI7XHJcbiAgICAgICAgaWYob3ZlcmxhcDE+MClyZXR1cm47XHJcbiAgICAgICAgLy8gdHJ5IGF4aXMgMlxyXG4gICAgICAgIGxlbj1hMngqZHgrYTJ5KmR5K2EyeipkejtcclxuICAgICAgICByaWdodDI9bGVuPjA7XHJcbiAgICAgICAgaWYoIXJpZ2h0MilsZW49LWxlbjtcclxuICAgICAgICBsZW4xPWgxO1xyXG4gICAgICAgIGRvdDE9YTJ4KmE0eCthMnkqYTR5K2EyeiphNHo7XHJcbiAgICAgICAgZG90Mj1hMngqYTV4K2EyeSphNXkrYTJ6KmE1ejtcclxuICAgICAgICBkb3QzPWEyeCphNngrYTJ5KmE2eSthMnoqYTZ6O1xyXG4gICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgIGlmKGRvdDM8MClkb3QzPS1kb3QzO1xyXG4gICAgICAgIGxlbjI9ZG90MSp3Mitkb3QyKmgyK2RvdDMqZDI7XHJcbiAgICAgICAgb3ZlcmxhcDI9bGVuLWxlbjEtbGVuMjtcclxuICAgICAgICBpZihvdmVybGFwMj4wKXJldHVybjtcclxuICAgICAgICAvLyB0cnkgYXhpcyAzXHJcbiAgICAgICAgbGVuPWEzeCpkeCthM3kqZHkrYTN6KmR6O1xyXG4gICAgICAgIHJpZ2h0Mz1sZW4+MDtcclxuICAgICAgICBpZighcmlnaHQzKWxlbj0tbGVuO1xyXG4gICAgICAgIGxlbjE9ZDE7XHJcbiAgICAgICAgZG90MT1hM3gqYTR4K2EzeSphNHkrYTN6KmE0ejtcclxuICAgICAgICBkb3QyPWEzeCphNXgrYTN5KmE1eSthM3oqYTV6O1xyXG4gICAgICAgIGRvdDM9YTN4KmE2eCthM3kqYTZ5K2EzeiphNno7XHJcbiAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgaWYoZG90MzwwKWRvdDM9LWRvdDM7XHJcbiAgICAgICAgbGVuMj1kb3QxKncyK2RvdDIqaDIrZG90MypkMjtcclxuICAgICAgICBvdmVybGFwMz1sZW4tbGVuMS1sZW4yO1xyXG4gICAgICAgIGlmKG92ZXJsYXAzPjApcmV0dXJuO1xyXG4gICAgICAgIC8vIHRyeSBheGlzIDRcclxuICAgICAgICBsZW49YTR4KmR4K2E0eSpkeSthNHoqZHo7XHJcbiAgICAgICAgcmlnaHQ0PWxlbj4wO1xyXG4gICAgICAgIGlmKCFyaWdodDQpbGVuPS1sZW47XHJcbiAgICAgICAgZG90MT1hNHgqYTF4K2E0eSphMXkrYTR6KmExejtcclxuICAgICAgICBkb3QyPWE0eCphMngrYTR5KmEyeSthNHoqYTJ6O1xyXG4gICAgICAgIGRvdDM9YTR4KmEzeCthNHkqYTN5K2E0eiphM3o7XHJcbiAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgaWYoZG90MzwwKWRvdDM9LWRvdDM7XHJcbiAgICAgICAgbGVuMT1kb3QxKncxK2RvdDIqaDErZG90MypkMTtcclxuICAgICAgICBsZW4yPXcyO1xyXG4gICAgICAgIG92ZXJsYXA0PShsZW4tbGVuMS1sZW4yKSoxLjA7XHJcbiAgICAgICAgaWYob3ZlcmxhcDQ+MClyZXR1cm47XHJcbiAgICAgICAgLy8gdHJ5IGF4aXMgNVxyXG4gICAgICAgIGxlbj1hNXgqZHgrYTV5KmR5K2E1eipkejtcclxuICAgICAgICByaWdodDU9bGVuPjA7XHJcbiAgICAgICAgaWYoIXJpZ2h0NSlsZW49LWxlbjtcclxuICAgICAgICBkb3QxPWE1eCphMXgrYTV5KmExeSthNXoqYTF6O1xyXG4gICAgICAgIGRvdDI9YTV4KmEyeCthNXkqYTJ5K2E1eiphMno7XHJcbiAgICAgICAgZG90Mz1hNXgqYTN4K2E1eSphM3krYTV6KmEzejtcclxuICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICBpZihkb3QzPDApZG90Mz0tZG90MztcclxuICAgICAgICBsZW4xPWRvdDEqdzErZG90MipoMStkb3QzKmQxO1xyXG4gICAgICAgIGxlbjI9aDI7XHJcbiAgICAgICAgb3ZlcmxhcDU9KGxlbi1sZW4xLWxlbjIpKjEuMDtcclxuICAgICAgICBpZihvdmVybGFwNT4wKXJldHVybjtcclxuICAgICAgICAvLyB0cnkgYXhpcyA2XHJcbiAgICAgICAgbGVuPWE2eCpkeCthNnkqZHkrYTZ6KmR6O1xyXG4gICAgICAgIHJpZ2h0Nj1sZW4+MDtcclxuICAgICAgICBpZighcmlnaHQ2KWxlbj0tbGVuO1xyXG4gICAgICAgIGRvdDE9YTZ4KmExeCthNnkqYTF5K2E2eiphMXo7XHJcbiAgICAgICAgZG90Mj1hNngqYTJ4K2E2eSphMnkrYTZ6KmEyejtcclxuICAgICAgICBkb3QzPWE2eCphM3grYTZ5KmEzeSthNnoqYTN6O1xyXG4gICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgIGlmKGRvdDM8MClkb3QzPS1kb3QzO1xyXG4gICAgICAgIGxlbjE9ZG90MSp3MStkb3QyKmgxK2RvdDMqZDE7XHJcbiAgICAgICAgbGVuMj1kMjtcclxuICAgICAgICBvdmVybGFwNj0obGVuLWxlbjEtbGVuMikqMS4wO1xyXG4gICAgICAgIGlmKG92ZXJsYXA2PjApcmV0dXJuO1xyXG4gICAgICAgIC8vIHRyeSBheGlzIDdcclxuICAgICAgICBsZW49YTd4KmE3eCthN3kqYTd5K2E3eiphN3o7XHJcbiAgICAgICAgaWYobGVuPjFlLTUpe1xyXG4gICAgICAgICAgICBsZW49MS9fTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgICAgIGE3eCo9bGVuO1xyXG4gICAgICAgICAgICBhN3kqPWxlbjtcclxuICAgICAgICAgICAgYTd6Kj1sZW47XHJcbiAgICAgICAgICAgIGxlbj1hN3gqZHgrYTd5KmR5K2E3eipkejtcclxuICAgICAgICAgICAgcmlnaHQ3PWxlbj4wO1xyXG4gICAgICAgICAgICBpZighcmlnaHQ3KWxlbj0tbGVuO1xyXG4gICAgICAgICAgICBkb3QxPWE3eCphMngrYTd5KmEyeSthN3oqYTJ6O1xyXG4gICAgICAgICAgICBkb3QyPWE3eCphM3grYTd5KmEzeSthN3oqYTN6O1xyXG4gICAgICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgICAgIGxlbjE9ZG90MSpoMStkb3QyKmQxO1xyXG4gICAgICAgICAgICBkb3QxPWE3eCphNXgrYTd5KmE1eSthN3oqYTV6O1xyXG4gICAgICAgICAgICBkb3QyPWE3eCphNngrYTd5KmE2eSthN3oqYTZ6O1xyXG4gICAgICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgICAgIGxlbjI9ZG90MSpoMitkb3QyKmQyO1xyXG4gICAgICAgICAgICBvdmVybGFwNz1sZW4tbGVuMS1sZW4yO1xyXG4gICAgICAgICAgICBpZihvdmVybGFwNz4wKXJldHVybjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmlnaHQ3PWZhbHNlO1xyXG4gICAgICAgICAgICBvdmVybGFwNz0wO1xyXG4gICAgICAgICAgICBpbnZhbGlkNz10cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cnkgYXhpcyA4XHJcbiAgICAgICAgbGVuPWE4eCphOHgrYTh5KmE4eSthOHoqYTh6O1xyXG4gICAgICAgIGlmKGxlbj4xZS01KXtcclxuICAgICAgICAgICAgbGVuPTEvX01hdGguc3FydChsZW4pO1xyXG4gICAgICAgICAgICBhOHgqPWxlbjtcclxuICAgICAgICAgICAgYTh5Kj1sZW47XHJcbiAgICAgICAgICAgIGE4eio9bGVuO1xyXG4gICAgICAgICAgICBsZW49YTh4KmR4K2E4eSpkeSthOHoqZHo7XHJcbiAgICAgICAgICAgIHJpZ2h0OD1sZW4+MDtcclxuICAgICAgICAgICAgaWYoIXJpZ2h0OClsZW49LWxlbjtcclxuICAgICAgICAgICAgZG90MT1hOHgqYTJ4K2E4eSphMnkrYTh6KmEyejtcclxuICAgICAgICAgICAgZG90Mj1hOHgqYTN4K2E4eSphM3krYTh6KmEzejtcclxuICAgICAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgICAgICBsZW4xPWRvdDEqaDErZG90MipkMTtcclxuICAgICAgICAgICAgZG90MT1hOHgqYTR4K2E4eSphNHkrYTh6KmE0ejtcclxuICAgICAgICAgICAgZG90Mj1hOHgqYTZ4K2E4eSphNnkrYTh6KmE2ejtcclxuICAgICAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgICAgICBsZW4yPWRvdDEqdzIrZG90MipkMjtcclxuICAgICAgICAgICAgb3ZlcmxhcDg9bGVuLWxlbjEtbGVuMjtcclxuICAgICAgICAgICAgaWYob3ZlcmxhcDg+MClyZXR1cm47XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJpZ2h0OD1mYWxzZTtcclxuICAgICAgICAgICAgb3ZlcmxhcDg9MDtcclxuICAgICAgICAgICAgaW52YWxpZDg9dHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJ5IGF4aXMgOVxyXG4gICAgICAgIGxlbj1hOXgqYTl4K2E5eSphOXkrYTl6KmE5ejtcclxuICAgICAgICBpZihsZW4+MWUtNSl7XHJcbiAgICAgICAgICAgIGxlbj0xL19NYXRoLnNxcnQobGVuKTtcclxuICAgICAgICAgICAgYTl4Kj1sZW47XHJcbiAgICAgICAgICAgIGE5eSo9bGVuO1xyXG4gICAgICAgICAgICBhOXoqPWxlbjtcclxuICAgICAgICAgICAgbGVuPWE5eCpkeCthOXkqZHkrYTl6KmR6O1xyXG4gICAgICAgICAgICByaWdodDk9bGVuPjA7XHJcbiAgICAgICAgICAgIGlmKCFyaWdodDkpbGVuPS1sZW47XHJcbiAgICAgICAgICAgIGRvdDE9YTl4KmEyeCthOXkqYTJ5K2E5eiphMno7XHJcbiAgICAgICAgICAgIGRvdDI9YTl4KmEzeCthOXkqYTN5K2E5eiphM3o7XHJcbiAgICAgICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICAgICAgbGVuMT1kb3QxKmgxK2RvdDIqZDE7XHJcbiAgICAgICAgICAgIGRvdDE9YTl4KmE0eCthOXkqYTR5K2E5eiphNHo7XHJcbiAgICAgICAgICAgIGRvdDI9YTl4KmE1eCthOXkqYTV5K2E5eiphNXo7XHJcbiAgICAgICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICAgICAgbGVuMj1kb3QxKncyK2RvdDIqaDI7XHJcbiAgICAgICAgICAgIG92ZXJsYXA5PWxlbi1sZW4xLWxlbjI7XHJcbiAgICAgICAgICAgIGlmKG92ZXJsYXA5PjApcmV0dXJuO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByaWdodDk9ZmFsc2U7XHJcbiAgICAgICAgICAgIG92ZXJsYXA5PTA7XHJcbiAgICAgICAgICAgIGludmFsaWQ5PXRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRyeSBheGlzIDEwXHJcbiAgICAgICAgbGVuPWFheCphYXgrYWF5KmFheSthYXoqYWF6O1xyXG4gICAgICAgIGlmKGxlbj4xZS01KXtcclxuICAgICAgICAgICAgbGVuPTEvX01hdGguc3FydChsZW4pO1xyXG4gICAgICAgICAgICBhYXgqPWxlbjtcclxuICAgICAgICAgICAgYWF5Kj1sZW47XHJcbiAgICAgICAgICAgIGFheio9bGVuO1xyXG4gICAgICAgICAgICBsZW49YWF4KmR4K2FheSpkeSthYXoqZHo7XHJcbiAgICAgICAgICAgIHJpZ2h0YT1sZW4+MDtcclxuICAgICAgICAgICAgaWYoIXJpZ2h0YSlsZW49LWxlbjtcclxuICAgICAgICAgICAgZG90MT1hYXgqYTF4K2FheSphMXkrYWF6KmExejtcclxuICAgICAgICAgICAgZG90Mj1hYXgqYTN4K2FheSphM3krYWF6KmEzejtcclxuICAgICAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgICAgICBsZW4xPWRvdDEqdzErZG90MipkMTtcclxuICAgICAgICAgICAgZG90MT1hYXgqYTV4K2FheSphNXkrYWF6KmE1ejtcclxuICAgICAgICAgICAgZG90Mj1hYXgqYTZ4K2FheSphNnkrYWF6KmE2ejtcclxuICAgICAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgICAgICBsZW4yPWRvdDEqaDIrZG90MipkMjtcclxuICAgICAgICAgICAgb3ZlcmxhcGE9bGVuLWxlbjEtbGVuMjtcclxuICAgICAgICAgICAgaWYob3ZlcmxhcGE+MClyZXR1cm47XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJpZ2h0YT1mYWxzZTtcclxuICAgICAgICAgICAgb3ZlcmxhcGE9MDtcclxuICAgICAgICAgICAgaW52YWxpZGE9dHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJ5IGF4aXMgMTFcclxuICAgICAgICBsZW49YWJ4KmFieCthYnkqYWJ5K2FieiphYno7XHJcbiAgICAgICAgaWYobGVuPjFlLTUpe1xyXG4gICAgICAgICAgICBsZW49MS9fTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgICAgIGFieCo9bGVuO1xyXG4gICAgICAgICAgICBhYnkqPWxlbjtcclxuICAgICAgICAgICAgYWJ6Kj1sZW47XHJcbiAgICAgICAgICAgIGxlbj1hYngqZHgrYWJ5KmR5K2FieipkejtcclxuICAgICAgICAgICAgcmlnaHRiPWxlbj4wO1xyXG4gICAgICAgICAgICBpZighcmlnaHRiKWxlbj0tbGVuO1xyXG4gICAgICAgICAgICBkb3QxPWFieCphMXgrYWJ5KmExeSthYnoqYTF6O1xyXG4gICAgICAgICAgICBkb3QyPWFieCphM3grYWJ5KmEzeSthYnoqYTN6O1xyXG4gICAgICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgICAgIGxlbjE9ZG90MSp3MStkb3QyKmQxO1xyXG4gICAgICAgICAgICBkb3QxPWFieCphNHgrYWJ5KmE0eSthYnoqYTR6O1xyXG4gICAgICAgICAgICBkb3QyPWFieCphNngrYWJ5KmE2eSthYnoqYTZ6O1xyXG4gICAgICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgICAgIGxlbjI9ZG90MSp3Mitkb3QyKmQyO1xyXG4gICAgICAgICAgICBvdmVybGFwYj1sZW4tbGVuMS1sZW4yO1xyXG4gICAgICAgICAgICBpZihvdmVybGFwYj4wKXJldHVybjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmlnaHRiPWZhbHNlO1xyXG4gICAgICAgICAgICBvdmVybGFwYj0wO1xyXG4gICAgICAgICAgICBpbnZhbGlkYj10cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cnkgYXhpcyAxMlxyXG4gICAgICAgIGxlbj1hY3gqYWN4K2FjeSphY3krYWN6KmFjejtcclxuICAgICAgICBpZihsZW4+MWUtNSl7XHJcbiAgICAgICAgICAgIGxlbj0xL19NYXRoLnNxcnQobGVuKTtcclxuICAgICAgICAgICAgYWN4Kj1sZW47XHJcbiAgICAgICAgICAgIGFjeSo9bGVuO1xyXG4gICAgICAgICAgICBhY3oqPWxlbjtcclxuICAgICAgICAgICAgbGVuPWFjeCpkeCthY3kqZHkrYWN6KmR6O1xyXG4gICAgICAgICAgICByaWdodGM9bGVuPjA7XHJcbiAgICAgICAgICAgIGlmKCFyaWdodGMpbGVuPS1sZW47XHJcbiAgICAgICAgICAgIGRvdDE9YWN4KmExeCthY3kqYTF5K2FjeiphMXo7XHJcbiAgICAgICAgICAgIGRvdDI9YWN4KmEzeCthY3kqYTN5K2FjeiphM3o7XHJcbiAgICAgICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICAgICAgbGVuMT1kb3QxKncxK2RvdDIqZDE7XHJcbiAgICAgICAgICAgIGRvdDE9YWN4KmE0eCthY3kqYTR5K2FjeiphNHo7XHJcbiAgICAgICAgICAgIGRvdDI9YWN4KmE1eCthY3kqYTV5K2FjeiphNXo7XHJcbiAgICAgICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICAgICAgbGVuMj1kb3QxKncyK2RvdDIqaDI7XHJcbiAgICAgICAgICAgIG92ZXJsYXBjPWxlbi1sZW4xLWxlbjI7XHJcbiAgICAgICAgICAgIGlmKG92ZXJsYXBjPjApcmV0dXJuO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByaWdodGM9ZmFsc2U7XHJcbiAgICAgICAgICAgIG92ZXJsYXBjPTA7XHJcbiAgICAgICAgICAgIGludmFsaWRjPXRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRyeSBheGlzIDEzXHJcbiAgICAgICAgbGVuPWFkeCphZHgrYWR5KmFkeSthZHoqYWR6O1xyXG4gICAgICAgIGlmKGxlbj4xZS01KXtcclxuICAgICAgICAgICAgbGVuPTEvX01hdGguc3FydChsZW4pO1xyXG4gICAgICAgICAgICBhZHgqPWxlbjtcclxuICAgICAgICAgICAgYWR5Kj1sZW47XHJcbiAgICAgICAgICAgIGFkeio9bGVuO1xyXG4gICAgICAgICAgICBsZW49YWR4KmR4K2FkeSpkeSthZHoqZHo7XHJcbiAgICAgICAgICAgIHJpZ2h0ZD1sZW4+MDtcclxuICAgICAgICAgICAgaWYoIXJpZ2h0ZClsZW49LWxlbjtcclxuICAgICAgICAgICAgZG90MT1hZHgqYTF4K2FkeSphMXkrYWR6KmExejtcclxuICAgICAgICAgICAgZG90Mj1hZHgqYTJ4K2FkeSphMnkrYWR6KmEyejtcclxuICAgICAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgICAgICBsZW4xPWRvdDEqdzErZG90MipoMTtcclxuICAgICAgICAgICAgZG90MT1hZHgqYTV4K2FkeSphNXkrYWR6KmE1ejtcclxuICAgICAgICAgICAgZG90Mj1hZHgqYTZ4K2FkeSphNnkrYWR6KmE2ejtcclxuICAgICAgICAgICAgaWYoZG90MTwwKWRvdDE9LWRvdDE7XHJcbiAgICAgICAgICAgIGlmKGRvdDI8MClkb3QyPS1kb3QyO1xyXG4gICAgICAgICAgICBsZW4yPWRvdDEqaDIrZG90MipkMjtcclxuICAgICAgICAgICAgb3ZlcmxhcGQ9bGVuLWxlbjEtbGVuMjtcclxuICAgICAgICAgICAgaWYob3ZlcmxhcGQ+MClyZXR1cm47XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJpZ2h0ZD1mYWxzZTtcclxuICAgICAgICAgICAgb3ZlcmxhcGQ9MDtcclxuICAgICAgICAgICAgaW52YWxpZGQ9dHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJ5IGF4aXMgMTRcclxuICAgICAgICBsZW49YWV4KmFleCthZXkqYWV5K2FleiphZXo7XHJcbiAgICAgICAgaWYobGVuPjFlLTUpe1xyXG4gICAgICAgICAgICBsZW49MS9fTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgICAgIGFleCo9bGVuO1xyXG4gICAgICAgICAgICBhZXkqPWxlbjtcclxuICAgICAgICAgICAgYWV6Kj1sZW47XHJcbiAgICAgICAgICAgIGxlbj1hZXgqZHgrYWV5KmR5K2FleipkejtcclxuICAgICAgICAgICAgcmlnaHRlPWxlbj4wO1xyXG4gICAgICAgICAgICBpZighcmlnaHRlKWxlbj0tbGVuO1xyXG4gICAgICAgICAgICBkb3QxPWFleCphMXgrYWV5KmExeSthZXoqYTF6O1xyXG4gICAgICAgICAgICBkb3QyPWFleCphMngrYWV5KmEyeSthZXoqYTJ6O1xyXG4gICAgICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgICAgIGxlbjE9ZG90MSp3MStkb3QyKmgxO1xyXG4gICAgICAgICAgICBkb3QxPWFleCphNHgrYWV5KmE0eSthZXoqYTR6O1xyXG4gICAgICAgICAgICBkb3QyPWFleCphNngrYWV5KmE2eSthZXoqYTZ6O1xyXG4gICAgICAgICAgICBpZihkb3QxPDApZG90MT0tZG90MTtcclxuICAgICAgICAgICAgaWYoZG90MjwwKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgICAgIGxlbjI9ZG90MSp3Mitkb3QyKmQyO1xyXG4gICAgICAgICAgICBvdmVybGFwZT1sZW4tbGVuMS1sZW4yO1xyXG4gICAgICAgICAgICBpZihvdmVybGFwZT4wKXJldHVybjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmlnaHRlPWZhbHNlO1xyXG4gICAgICAgICAgICBvdmVybGFwZT0wO1xyXG4gICAgICAgICAgICBpbnZhbGlkZT10cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cnkgYXhpcyAxNVxyXG4gICAgICAgIGxlbj1hZngqYWZ4K2FmeSphZnkrYWZ6KmFmejtcclxuICAgICAgICBpZihsZW4+MWUtNSl7XHJcbiAgICAgICAgICAgIGxlbj0xL19NYXRoLnNxcnQobGVuKTtcclxuICAgICAgICAgICAgYWZ4Kj1sZW47XHJcbiAgICAgICAgICAgIGFmeSo9bGVuO1xyXG4gICAgICAgICAgICBhZnoqPWxlbjtcclxuICAgICAgICAgICAgbGVuPWFmeCpkeCthZnkqZHkrYWZ6KmR6O1xyXG4gICAgICAgICAgICByaWdodGY9bGVuPjA7XHJcbiAgICAgICAgICAgIGlmKCFyaWdodGYpbGVuPS1sZW47XHJcbiAgICAgICAgICAgIGRvdDE9YWZ4KmExeCthZnkqYTF5K2FmeiphMXo7XHJcbiAgICAgICAgICAgIGRvdDI9YWZ4KmEyeCthZnkqYTJ5K2FmeiphMno7XHJcbiAgICAgICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICAgICAgbGVuMT1kb3QxKncxK2RvdDIqaDE7XHJcbiAgICAgICAgICAgIGRvdDE9YWZ4KmE0eCthZnkqYTR5K2FmeiphNHo7XHJcbiAgICAgICAgICAgIGRvdDI9YWZ4KmE1eCthZnkqYTV5K2FmeiphNXo7XHJcbiAgICAgICAgICAgIGlmKGRvdDE8MClkb3QxPS1kb3QxO1xyXG4gICAgICAgICAgICBpZihkb3QyPDApZG90Mj0tZG90MjtcclxuICAgICAgICAgICAgbGVuMj1kb3QxKncyK2RvdDIqaDI7XHJcbiAgICAgICAgICAgIG92ZXJsYXBmPWxlbi1sZW4xLWxlbjI7XHJcbiAgICAgICAgICAgIGlmKG92ZXJsYXBmPjApcmV0dXJuO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByaWdodGY9ZmFsc2U7XHJcbiAgICAgICAgICAgIG92ZXJsYXBmPTA7XHJcbiAgICAgICAgICAgIGludmFsaWRmPXRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJveGVzIGFyZSBvdmVybGFwcGluZ1xyXG4gICAgICAgIHZhciBkZXB0aD1vdmVybGFwMTtcclxuICAgICAgICB2YXIgZGVwdGgyPW92ZXJsYXAxO1xyXG4gICAgICAgIHZhciBtaW5JbmRleD0wO1xyXG4gICAgICAgIHZhciByaWdodD1yaWdodDE7XHJcbiAgICAgICAgaWYob3ZlcmxhcDI+ZGVwdGgyKXtcclxuICAgICAgICAgICAgZGVwdGg9b3ZlcmxhcDI7XHJcbiAgICAgICAgICAgIGRlcHRoMj1vdmVybGFwMjtcclxuICAgICAgICAgICAgbWluSW5kZXg9MTtcclxuICAgICAgICAgICAgcmlnaHQ9cmlnaHQyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihvdmVybGFwMz5kZXB0aDIpe1xyXG4gICAgICAgICAgICBkZXB0aD1vdmVybGFwMztcclxuICAgICAgICAgICAgZGVwdGgyPW92ZXJsYXAzO1xyXG4gICAgICAgICAgICBtaW5JbmRleD0yO1xyXG4gICAgICAgICAgICByaWdodD1yaWdodDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG92ZXJsYXA0PmRlcHRoMil7XHJcbiAgICAgICAgICAgIGRlcHRoPW92ZXJsYXA0O1xyXG4gICAgICAgICAgICBkZXB0aDI9b3ZlcmxhcDQ7XHJcbiAgICAgICAgICAgIG1pbkluZGV4PTM7XHJcbiAgICAgICAgICAgIHJpZ2h0PXJpZ2h0NDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3ZlcmxhcDU+ZGVwdGgyKXtcclxuICAgICAgICAgICAgZGVwdGg9b3ZlcmxhcDU7XHJcbiAgICAgICAgICAgIGRlcHRoMj1vdmVybGFwNTtcclxuICAgICAgICAgICAgbWluSW5kZXg9NDtcclxuICAgICAgICAgICAgcmlnaHQ9cmlnaHQ1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihvdmVybGFwNj5kZXB0aDIpe1xyXG4gICAgICAgICAgICBkZXB0aD1vdmVybGFwNjtcclxuICAgICAgICAgICAgZGVwdGgyPW92ZXJsYXA2O1xyXG4gICAgICAgICAgICBtaW5JbmRleD01O1xyXG4gICAgICAgICAgICByaWdodD1yaWdodDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG92ZXJsYXA3LTAuMDE+ZGVwdGgyJiYhaW52YWxpZDcpe1xyXG4gICAgICAgICAgICBkZXB0aD1vdmVybGFwNztcclxuICAgICAgICAgICAgZGVwdGgyPW92ZXJsYXA3LTAuMDE7XHJcbiAgICAgICAgICAgIG1pbkluZGV4PTY7XHJcbiAgICAgICAgICAgIHJpZ2h0PXJpZ2h0NztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3ZlcmxhcDgtMC4wMT5kZXB0aDImJiFpbnZhbGlkOCl7XHJcbiAgICAgICAgICAgIGRlcHRoPW92ZXJsYXA4O1xyXG4gICAgICAgICAgICBkZXB0aDI9b3ZlcmxhcDgtMC4wMTtcclxuICAgICAgICAgICAgbWluSW5kZXg9NztcclxuICAgICAgICAgICAgcmlnaHQ9cmlnaHQ4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihvdmVybGFwOS0wLjAxPmRlcHRoMiYmIWludmFsaWQ5KXtcclxuICAgICAgICAgICAgZGVwdGg9b3ZlcmxhcDk7XHJcbiAgICAgICAgICAgIGRlcHRoMj1vdmVybGFwOS0wLjAxO1xyXG4gICAgICAgICAgICBtaW5JbmRleD04O1xyXG4gICAgICAgICAgICByaWdodD1yaWdodDk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG92ZXJsYXBhLTAuMDE+ZGVwdGgyJiYhaW52YWxpZGEpe1xyXG4gICAgICAgICAgICBkZXB0aD1vdmVybGFwYTtcclxuICAgICAgICAgICAgZGVwdGgyPW92ZXJsYXBhLTAuMDE7XHJcbiAgICAgICAgICAgIG1pbkluZGV4PTk7XHJcbiAgICAgICAgICAgIHJpZ2h0PXJpZ2h0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3ZlcmxhcGItMC4wMT5kZXB0aDImJiFpbnZhbGlkYil7XHJcbiAgICAgICAgICAgIGRlcHRoPW92ZXJsYXBiO1xyXG4gICAgICAgICAgICBkZXB0aDI9b3ZlcmxhcGItMC4wMTtcclxuICAgICAgICAgICAgbWluSW5kZXg9MTA7XHJcbiAgICAgICAgICAgIHJpZ2h0PXJpZ2h0YjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3ZlcmxhcGMtMC4wMT5kZXB0aDImJiFpbnZhbGlkYyl7XHJcbiAgICAgICAgICAgIGRlcHRoPW92ZXJsYXBjO1xyXG4gICAgICAgICAgICBkZXB0aDI9b3ZlcmxhcGMtMC4wMTtcclxuICAgICAgICAgICAgbWluSW5kZXg9MTE7XHJcbiAgICAgICAgICAgIHJpZ2h0PXJpZ2h0YztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3ZlcmxhcGQtMC4wMT5kZXB0aDImJiFpbnZhbGlkZCl7XHJcbiAgICAgICAgICAgIGRlcHRoPW92ZXJsYXBkO1xyXG4gICAgICAgICAgICBkZXB0aDI9b3ZlcmxhcGQtMC4wMTtcclxuICAgICAgICAgICAgbWluSW5kZXg9MTI7XHJcbiAgICAgICAgICAgIHJpZ2h0PXJpZ2h0ZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3ZlcmxhcGUtMC4wMT5kZXB0aDImJiFpbnZhbGlkZSl7XHJcbiAgICAgICAgICAgIGRlcHRoPW92ZXJsYXBlO1xyXG4gICAgICAgICAgICBkZXB0aDI9b3ZlcmxhcGUtMC4wMTtcclxuICAgICAgICAgICAgbWluSW5kZXg9MTM7XHJcbiAgICAgICAgICAgIHJpZ2h0PXJpZ2h0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3ZlcmxhcGYtMC4wMT5kZXB0aDImJiFpbnZhbGlkZil7XHJcbiAgICAgICAgICAgIGRlcHRoPW92ZXJsYXBmO1xyXG4gICAgICAgICAgICBtaW5JbmRleD0xNDtcclxuICAgICAgICAgICAgcmlnaHQ9cmlnaHRmO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub3JtYWxcclxuICAgICAgICB2YXIgbng9MDtcclxuICAgICAgICB2YXIgbnk9MDtcclxuICAgICAgICB2YXIgbno9MDtcclxuICAgICAgICAvLyBlZGdlIGxpbmUgb3IgZmFjZSBzaWRlIG5vcm1hbFxyXG4gICAgICAgIHZhciBuMXg9MDtcclxuICAgICAgICB2YXIgbjF5PTA7XHJcbiAgICAgICAgdmFyIG4xej0wO1xyXG4gICAgICAgIHZhciBuMng9MDtcclxuICAgICAgICB2YXIgbjJ5PTA7XHJcbiAgICAgICAgdmFyIG4yej0wO1xyXG4gICAgICAgIC8vIGNlbnRlciBvZiBjdXJyZW50IGZhY2VcclxuICAgICAgICB2YXIgY3g9MDtcclxuICAgICAgICB2YXIgY3k9MDtcclxuICAgICAgICB2YXIgY3o9MDtcclxuICAgICAgICAvLyBmYWNlIHNpZGVcclxuICAgICAgICB2YXIgczF4PTA7XHJcbiAgICAgICAgdmFyIHMxeT0wO1xyXG4gICAgICAgIHZhciBzMXo9MDtcclxuICAgICAgICB2YXIgczJ4PTA7XHJcbiAgICAgICAgdmFyIHMyeT0wO1xyXG4gICAgICAgIHZhciBzMno9MDtcclxuICAgICAgICAvLyBzd2FwIGIxIGIyXHJcbiAgICAgICAgdmFyIHN3YXA9ZmFsc2U7XHJcblxyXG4gICAgICAgIC8vX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXHJcblxyXG4gICAgICAgIGlmKG1pbkluZGV4PT0wKXsvLyBiMS54ICogYjJcclxuICAgICAgICAgICAgaWYocmlnaHQpe1xyXG4gICAgICAgICAgICAgICAgY3g9cDF4K2QxeDsgY3k9cDF5K2QxeTsgIGN6PXAxeitkMXo7XHJcbiAgICAgICAgICAgICAgICBueD1hMXg7IG55PWExeTsgbno9YTF6O1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGN4PXAxeC1kMXg7IGN5PXAxeS1kMXk7IGN6PXAxei1kMXo7XHJcbiAgICAgICAgICAgICAgICBueD0tYTF4OyBueT0tYTF5OyBuej0tYTF6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMxeD1kMng7IHMxeT1kMnk7IHMxej1kMno7XHJcbiAgICAgICAgICAgIG4xeD0tYTJ4OyBuMXk9LWEyeTsgbjF6PS1hMno7XHJcbiAgICAgICAgICAgIHMyeD1kM3g7IHMyeT1kM3k7IHMyej1kM3o7XHJcbiAgICAgICAgICAgIG4yeD0tYTN4OyBuMnk9LWEzeTsgbjJ6PS1hM3o7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYobWluSW5kZXg9PTEpey8vIGIxLnkgKiBiMlxyXG4gICAgICAgICAgICBpZihyaWdodCl7XHJcbiAgICAgICAgICAgICAgICBjeD1wMXgrZDJ4OyBjeT1wMXkrZDJ5OyBjej1wMXorZDJ6O1xyXG4gICAgICAgICAgICAgICAgbng9YTJ4OyBueT1hMnk7IG56PWEyejtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBjeD1wMXgtZDJ4OyBjeT1wMXktZDJ5OyBjej1wMXotZDJ6O1xyXG4gICAgICAgICAgICAgICAgbng9LWEyeDsgbnk9LWEyeTsgbno9LWEyejtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzMXg9ZDF4OyBzMXk9ZDF5OyBzMXo9ZDF6O1xyXG4gICAgICAgICAgICBuMXg9LWExeDsgbjF5PS1hMXk7IG4xej0tYTF6O1xyXG4gICAgICAgICAgICBzMng9ZDN4OyBzMnk9ZDN5OyBzMno9ZDN6O1xyXG4gICAgICAgICAgICBuMng9LWEzeDsgbjJ5PS1hM3k7IG4yej0tYTN6O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKG1pbkluZGV4PT0yKXsvLyBiMS56ICogYjJcclxuICAgICAgICAgICAgaWYocmlnaHQpe1xyXG4gICAgICAgICAgICAgICAgY3g9cDF4K2QzeDsgY3k9cDF5K2QzeTsgY3o9cDF6K2QzejtcclxuICAgICAgICAgICAgICAgIG54PWEzeDsgbnk9YTN5OyBuej1hM3o7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgY3g9cDF4LWQzeDsgY3k9cDF5LWQzeTsgY3o9cDF6LWQzejtcclxuICAgICAgICAgICAgICAgIG54PS1hM3g7IG55PS1hM3k7IG56PS1hM3o7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgczF4PWQxeDsgczF5PWQxeTsgczF6PWQxejtcclxuICAgICAgICAgICAgbjF4PS1hMXg7IG4xeT0tYTF5OyBuMXo9LWExejtcclxuICAgICAgICAgICAgczJ4PWQyeDsgczJ5PWQyeTsgczJ6PWQyejtcclxuICAgICAgICAgICAgbjJ4PS1hMng7IG4yeT0tYTJ5OyBuMno9LWEyejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihtaW5JbmRleD09Myl7Ly8gYjIueCAqIGIxXHJcbiAgICAgICAgICAgIHN3YXA9dHJ1ZTtcclxuICAgICAgICAgICAgaWYoIXJpZ2h0KXtcclxuICAgICAgICAgICAgICAgIGN4PXAyeCtkNHg7IGN5PXAyeStkNHk7IGN6PXAyeitkNHo7XHJcbiAgICAgICAgICAgICAgICBueD1hNHg7IG55PWE0eTsgbno9YTR6O1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGN4PXAyeC1kNHg7IGN5PXAyeS1kNHk7IGN6PXAyei1kNHo7XHJcbiAgICAgICAgICAgICAgICBueD0tYTR4OyBueT0tYTR5OyBuej0tYTR6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMxeD1kNXg7IHMxeT1kNXk7IHMxej1kNXo7XHJcbiAgICAgICAgICAgIG4xeD0tYTV4OyBuMXk9LWE1eTsgbjF6PS1hNXo7XHJcbiAgICAgICAgICAgIHMyeD1kNng7IHMyeT1kNnk7IHMyej1kNno7XHJcbiAgICAgICAgICAgIG4yeD0tYTZ4OyBuMnk9LWE2eTsgbjJ6PS1hNno7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYobWluSW5kZXg9PTQpey8vIGIyLnkgKiBiMVxyXG4gICAgICAgICAgICBzd2FwPXRydWU7XHJcbiAgICAgICAgICAgIGlmKCFyaWdodCl7XHJcbiAgICAgICAgICAgICAgICBjeD1wMngrZDV4OyBjeT1wMnkrZDV5OyBjej1wMnorZDV6O1xyXG4gICAgICAgICAgICAgICAgbng9YTV4OyBueT1hNXk7IG56PWE1ejtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBjeD1wMngtZDV4OyBjeT1wMnktZDV5OyBjej1wMnotZDV6O1xyXG4gICAgICAgICAgICAgICAgbng9LWE1eDsgbnk9LWE1eTsgbno9LWE1ejtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzMXg9ZDR4OyBzMXk9ZDR5OyBzMXo9ZDR6O1xyXG4gICAgICAgICAgICBuMXg9LWE0eDsgbjF5PS1hNHk7IG4xej0tYTR6O1xyXG4gICAgICAgICAgICBzMng9ZDZ4OyBzMnk9ZDZ5OyBzMno9ZDZ6O1xyXG4gICAgICAgICAgICBuMng9LWE2eDsgbjJ5PS1hNnk7IG4yej0tYTZ6O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKG1pbkluZGV4PT01KXsvLyBiMi56ICogYjFcclxuICAgICAgICAgICAgc3dhcD10cnVlO1xyXG4gICAgICAgICAgICBpZighcmlnaHQpe1xyXG4gICAgICAgICAgICAgICAgY3g9cDJ4K2Q2eDsgY3k9cDJ5K2Q2eTsgY3o9cDJ6K2Q2ejtcclxuICAgICAgICAgICAgICAgIG54PWE2eDsgbnk9YTZ5OyBuej1hNno7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgY3g9cDJ4LWQ2eDsgY3k9cDJ5LWQ2eTsgY3o9cDJ6LWQ2ejtcclxuICAgICAgICAgICAgICAgIG54PS1hNng7IG55PS1hNnk7IG56PS1hNno7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgczF4PWQ0eDsgczF5PWQ0eTsgczF6PWQ0ejtcclxuICAgICAgICAgICAgbjF4PS1hNHg7IG4xeT0tYTR5OyBuMXo9LWE0ejtcclxuICAgICAgICAgICAgczJ4PWQ1eDsgczJ5PWQ1eTsgczJ6PWQ1ejtcclxuICAgICAgICAgICAgbjJ4PS1hNXg7IG4yeT0tYTV5OyBuMno9LWE1ejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihtaW5JbmRleD09Nil7Ly8gYjEueCAqIGIyLnhcclxuICAgICAgICAgICAgbng9YTd4OyBueT1hN3k7IG56PWE3ejtcclxuICAgICAgICAgICAgbjF4PWExeDsgbjF5PWExeTsgbjF6PWExejtcclxuICAgICAgICAgICAgbjJ4PWE0eDsgbjJ5PWE0eTsgbjJ6PWE0ejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihtaW5JbmRleD09Nyl7Ly8gYjEueCAqIGIyLnlcclxuICAgICAgICAgICAgbng9YTh4OyBueT1hOHk7IG56PWE4ejtcclxuICAgICAgICAgICAgbjF4PWExeDsgbjF5PWExeTsgbjF6PWExejtcclxuICAgICAgICAgICAgbjJ4PWE1eDsgbjJ5PWE1eTsgbjJ6PWE1ejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihtaW5JbmRleD09OCl7Ly8gYjEueCAqIGIyLnpcclxuICAgICAgICAgICAgbng9YTl4OyBueT1hOXk7IG56PWE5ejtcclxuICAgICAgICAgICAgbjF4PWExeDsgbjF5PWExeTsgbjF6PWExejtcclxuICAgICAgICAgICAgbjJ4PWE2eDsgbjJ5PWE2eTsgbjJ6PWE2ejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihtaW5JbmRleD09OSl7Ly8gYjEueSAqIGIyLnhcclxuICAgICAgICAgICAgbng9YWF4OyBueT1hYXk7IG56PWFhejtcclxuICAgICAgICAgICAgbjF4PWEyeDsgbjF5PWEyeTsgbjF6PWEyejtcclxuICAgICAgICAgICAgbjJ4PWE0eDsgbjJ5PWE0eTsgbjJ6PWE0ejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihtaW5JbmRleD09MTApey8vIGIxLnkgKiBiMi55XHJcbiAgICAgICAgICAgIG54PWFieDsgbnk9YWJ5OyBuej1hYno7XHJcbiAgICAgICAgICAgIG4xeD1hMng7IG4xeT1hMnk7IG4xej1hMno7XHJcbiAgICAgICAgICAgIG4yeD1hNXg7IG4yeT1hNXk7IG4yej1hNXo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYobWluSW5kZXg9PTExKXsvLyBiMS55ICogYjIuelxyXG4gICAgICAgICAgICBueD1hY3g7IG55PWFjeTsgbno9YWN6O1xyXG4gICAgICAgICAgICBuMXg9YTJ4OyBuMXk9YTJ5OyBuMXo9YTJ6O1xyXG4gICAgICAgICAgICBuMng9YTZ4OyBuMnk9YTZ5OyBuMno9YTZ6O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKG1pbkluZGV4PT0xMil7Ly8gYjEueiAqIGIyLnhcclxuICAgICAgICAgICAgbng9YWR4OyAgbnk9YWR5OyBuej1hZHo7XHJcbiAgICAgICAgICAgIG4xeD1hM3g7IG4xeT1hM3k7IG4xej1hM3o7XHJcbiAgICAgICAgICAgIG4yeD1hNHg7IG4yeT1hNHk7IG4yej1hNHo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYobWluSW5kZXg9PTEzKXsvLyBiMS56ICogYjIueVxyXG4gICAgICAgICAgICBueD1hZXg7IG55PWFleTsgbno9YWV6O1xyXG4gICAgICAgICAgICBuMXg9YTN4OyBuMXk9YTN5OyBuMXo9YTN6O1xyXG4gICAgICAgICAgICBuMng9YTV4OyBuMnk9YTV5OyBuMno9YTV6O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKG1pbkluZGV4PT0xNCl7Ly8gYjEueiAqIGIyLnpcclxuICAgICAgICAgICAgbng9YWZ4OyBueT1hZnk7IG56PWFmejtcclxuICAgICAgICAgICAgbjF4PWEzeDsgbjF5PWEzeTsgbjF6PWEzejtcclxuICAgICAgICAgICAgbjJ4PWE2eDsgbjJ5PWE2eTsgbjJ6PWE2ejtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXHJcblxyXG4gICAgICAgIC8vdmFyIHY7XHJcbiAgICAgICAgaWYobWluSW5kZXg+NSl7XHJcbiAgICAgICAgICAgIGlmKCFyaWdodCl7XHJcbiAgICAgICAgICAgICAgICBueD0tbng7IG55PS1ueTsgbno9LW56O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZTtcclxuICAgICAgICAgICAgdmFyIG1heERpc3RhbmNlO1xyXG4gICAgICAgICAgICB2YXIgdng7XHJcbiAgICAgICAgICAgIHZhciB2eTtcclxuICAgICAgICAgICAgdmFyIHZ6O1xyXG4gICAgICAgICAgICB2YXIgdjF4O1xyXG4gICAgICAgICAgICB2YXIgdjF5O1xyXG4gICAgICAgICAgICB2YXIgdjF6O1xyXG4gICAgICAgICAgICB2YXIgdjJ4O1xyXG4gICAgICAgICAgICB2YXIgdjJ5O1xyXG4gICAgICAgICAgICB2YXIgdjJ6O1xyXG4gICAgICAgICAgICAvL3ZlcnRleDE7XHJcbiAgICAgICAgICAgIHYxeD1WMVswXTsgdjF5PVYxWzFdOyB2MXo9VjFbMl07XHJcbiAgICAgICAgICAgIG1heERpc3RhbmNlPW54KnYxeCtueSp2MXkrbnoqdjF6O1xyXG4gICAgICAgICAgICAvL3ZlcnRleDI7XHJcbiAgICAgICAgICAgIHZ4PVYxWzNdOyB2eT1WMVs0XTsgdno9VjFbNV07XHJcbiAgICAgICAgICAgIGRpc3RhbmNlPW54KnZ4K255KnZ5K256KnZ6O1xyXG4gICAgICAgICAgICBpZihkaXN0YW5jZT5tYXhEaXN0YW5jZSl7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZT1kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIHYxeD12eDsgdjF5PXZ5OyB2MXo9dno7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy92ZXJ0ZXgzO1xyXG4gICAgICAgICAgICB2eD1WMVs2XTsgdnk9VjFbN107IHZ6PVYxWzhdO1xyXG4gICAgICAgICAgICBkaXN0YW5jZT1ueCp2eCtueSp2eStueip2ejtcclxuICAgICAgICAgICAgaWYoZGlzdGFuY2U+bWF4RGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2U9ZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2MXg9dng7IHYxeT12eTsgdjF6PXZ6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdmVydGV4NDtcclxuICAgICAgICAgICAgdng9VjFbOV07IHZ5PVYxWzEwXTsgdno9VjFbMTFdO1xyXG4gICAgICAgICAgICBkaXN0YW5jZT1ueCp2eCtueSp2eStueip2ejtcclxuICAgICAgICAgICAgaWYoZGlzdGFuY2U+bWF4RGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2U9ZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2MXg9dng7IHYxeT12eTsgdjF6PXZ6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdmVydGV4NTtcclxuICAgICAgICAgICAgdng9VjFbMTJdOyB2eT1WMVsxM107IHZ6PVYxWzE0XTtcclxuICAgICAgICAgICAgZGlzdGFuY2U9bngqdngrbnkqdnkrbnoqdno7XHJcbiAgICAgICAgICAgIGlmKGRpc3RhbmNlPm1heERpc3RhbmNlKXtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlPWRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgdjF4PXZ4OyB2MXk9dnk7IHYxej12ejtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3ZlcnRleDY7XHJcbiAgICAgICAgICAgIHZ4PVYxWzE1XTsgdnk9VjFbMTZdOyB2ej1WMVsxN107XHJcbiAgICAgICAgICAgIGRpc3RhbmNlPW54KnZ4K255KnZ5K256KnZ6O1xyXG4gICAgICAgICAgICBpZihkaXN0YW5jZT5tYXhEaXN0YW5jZSl7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZT1kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIHYxeD12eDsgdjF5PXZ5OyB2MXo9dno7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy92ZXJ0ZXg3O1xyXG4gICAgICAgICAgICB2eD1WMVsxOF07IHZ5PVYxWzE5XTsgdno9VjFbMjBdO1xyXG4gICAgICAgICAgICBkaXN0YW5jZT1ueCp2eCtueSp2eStueip2ejtcclxuICAgICAgICAgICAgaWYoZGlzdGFuY2U+bWF4RGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2U9ZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2MXg9dng7IHYxeT12eTsgdjF6PXZ6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdmVydGV4ODtcclxuICAgICAgICAgICAgdng9VjFbMjFdOyB2eT1WMVsyMl07IHZ6PVYxWzIzXTtcclxuICAgICAgICAgICAgZGlzdGFuY2U9bngqdngrbnkqdnkrbnoqdno7XHJcbiAgICAgICAgICAgIGlmKGRpc3RhbmNlPm1heERpc3RhbmNlKXtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlPWRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgdjF4PXZ4OyB2MXk9dnk7IHYxej12ejtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3ZlcnRleDE7XHJcbiAgICAgICAgICAgIHYyeD1WMlswXTsgdjJ5PVYyWzFdOyB2Mno9VjJbMl07XHJcbiAgICAgICAgICAgIG1heERpc3RhbmNlPW54KnYyeCtueSp2MnkrbnoqdjJ6O1xyXG4gICAgICAgICAgICAvL3ZlcnRleDI7XHJcbiAgICAgICAgICAgIHZ4PVYyWzNdOyB2eT1WMls0XTsgdno9VjJbNV07XHJcbiAgICAgICAgICAgIGRpc3RhbmNlPW54KnZ4K255KnZ5K256KnZ6O1xyXG4gICAgICAgICAgICBpZihkaXN0YW5jZTxtYXhEaXN0YW5jZSl7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZT1kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIHYyeD12eDsgdjJ5PXZ5OyB2Mno9dno7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy92ZXJ0ZXgzO1xyXG4gICAgICAgICAgICB2eD1WMls2XTsgdnk9VjJbN107IHZ6PVYyWzhdO1xyXG4gICAgICAgICAgICBkaXN0YW5jZT1ueCp2eCtueSp2eStueip2ejtcclxuICAgICAgICAgICAgaWYoZGlzdGFuY2U8bWF4RGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2U9ZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2Mng9dng7IHYyeT12eTsgdjJ6PXZ6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdmVydGV4NDtcclxuICAgICAgICAgICAgdng9VjJbOV07IHZ5PVYyWzEwXTsgdno9VjJbMTFdO1xyXG4gICAgICAgICAgICBkaXN0YW5jZT1ueCp2eCtueSp2eStueip2ejtcclxuICAgICAgICAgICAgaWYoZGlzdGFuY2U8bWF4RGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2U9ZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2Mng9dng7IHYyeT12eTsgdjJ6PXZ6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdmVydGV4NTtcclxuICAgICAgICAgICAgdng9VjJbMTJdOyB2eT1WMlsxM107IHZ6PVYyWzE0XTtcclxuICAgICAgICAgICAgZGlzdGFuY2U9bngqdngrbnkqdnkrbnoqdno7XHJcbiAgICAgICAgICAgIGlmKGRpc3RhbmNlPG1heERpc3RhbmNlKXtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlPWRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgdjJ4PXZ4OyB2Mnk9dnk7IHYyej12ejtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3ZlcnRleDY7XHJcbiAgICAgICAgICAgIHZ4PVYyWzE1XTsgdnk9VjJbMTZdOyB2ej1WMlsxN107XHJcbiAgICAgICAgICAgIGRpc3RhbmNlPW54KnZ4K255KnZ5K256KnZ6O1xyXG4gICAgICAgICAgICBpZihkaXN0YW5jZTxtYXhEaXN0YW5jZSl7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZT1kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIHYyeD12eDsgdjJ5PXZ5OyB2Mno9dno7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy92ZXJ0ZXg3O1xyXG4gICAgICAgICAgICB2eD1WMlsxOF07IHZ5PVYyWzE5XTsgdno9VjJbMjBdO1xyXG4gICAgICAgICAgICBkaXN0YW5jZT1ueCp2eCtueSp2eStueip2ejtcclxuICAgICAgICAgICAgaWYoZGlzdGFuY2U8bWF4RGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2U9ZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2Mng9dng7IHYyeT12eTsgdjJ6PXZ6O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdmVydGV4ODtcclxuICAgICAgICAgICAgdng9VjJbMjFdOyB2eT1WMlsyMl07IHZ6PVYyWzIzXTtcclxuICAgICAgICAgICAgZGlzdGFuY2U9bngqdngrbnkqdnkrbnoqdno7XHJcbiAgICAgICAgICAgIGlmKGRpc3RhbmNlPG1heERpc3RhbmNlKXtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlPWRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgdjJ4PXZ4OyB2Mnk9dnk7IHYyej12ejtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2eD12MngtdjF4OyB2eT12MnktdjF5OyB2ej12MnotdjF6O1xyXG4gICAgICAgICAgICBkb3QxPW4xeCpuMngrbjF5Km4yeStuMXoqbjJ6O1xyXG4gICAgICAgICAgICB2YXIgdD0odngqKG4xeC1uMngqZG90MSkrdnkqKG4xeS1uMnkqZG90MSkrdnoqKG4xei1uMnoqZG90MSkpLygxLWRvdDEqZG90MSk7XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHYxeCtuMXgqdCtueCpkZXB0aCowLjUsdjF5K24xeSp0K255KmRlcHRoKjAuNSx2MXorbjF6KnQrbnoqZGVwdGgqMC41LG54LG55LG56LGRlcHRoLGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub3cgZGV0ZWN0IGZhY2UtZmFjZSBjb2xsaXNpb24uLi5cclxuICAgICAgICAvLyB0YXJnZXQgcXVhZFxyXG4gICAgICAgIHZhciBxMXg7XHJcbiAgICAgICAgdmFyIHExeTtcclxuICAgICAgICB2YXIgcTF6O1xyXG4gICAgICAgIHZhciBxMng7XHJcbiAgICAgICAgdmFyIHEyeTtcclxuICAgICAgICB2YXIgcTJ6O1xyXG4gICAgICAgIHZhciBxM3g7XHJcbiAgICAgICAgdmFyIHEzeTtcclxuICAgICAgICB2YXIgcTN6O1xyXG4gICAgICAgIHZhciBxNHg7XHJcbiAgICAgICAgdmFyIHE0eTtcclxuICAgICAgICB2YXIgcTR6O1xyXG4gICAgICAgIC8vIHNlYXJjaCBzdXBwb3J0IGZhY2UgYW5kIHZlcnRleFxyXG4gICAgICAgIHZhciBtaW5Eb3Q9MTtcclxuICAgICAgICB2YXIgZG90PTA7XHJcbiAgICAgICAgdmFyIG1pbkRvdEluZGV4PTA7XHJcbiAgICAgICAgaWYoc3dhcCl7XHJcbiAgICAgICAgICAgIGRvdD1hMXgqbngrYTF5Km55K2ExeipuejtcclxuICAgICAgICAgICAgaWYoZG90PG1pbkRvdCl7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3Q9ZG90O1xyXG4gICAgICAgICAgICAgICAgbWluRG90SW5kZXg9MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZigtZG90PG1pbkRvdCl7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3Q9LWRvdDtcclxuICAgICAgICAgICAgICAgIG1pbkRvdEluZGV4PTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG90PWEyeCpueCthMnkqbnkrYTJ6Km56O1xyXG4gICAgICAgICAgICBpZihkb3Q8bWluRG90KXtcclxuICAgICAgICAgICAgICAgIG1pbkRvdD1kb3Q7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3RJbmRleD0yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKC1kb3Q8bWluRG90KXtcclxuICAgICAgICAgICAgICAgIG1pbkRvdD0tZG90O1xyXG4gICAgICAgICAgICAgICAgbWluRG90SW5kZXg9MztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb3Q9YTN4Km54K2EzeSpueSthM3oqbno7XHJcbiAgICAgICAgICAgIGlmKGRvdDxtaW5Eb3Qpe1xyXG4gICAgICAgICAgICAgICAgbWluRG90PWRvdDtcclxuICAgICAgICAgICAgICAgIG1pbkRvdEluZGV4PTQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoLWRvdDxtaW5Eb3Qpe1xyXG4gICAgICAgICAgICAgICAgbWluRG90PS1kb3Q7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3RJbmRleD01O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihtaW5Eb3RJbmRleD09MCl7Ly8geCsgZmFjZVxyXG4gICAgICAgICAgICAgICAgcTF4PVYxWzBdOyBxMXk9VjFbMV07IHExej1WMVsyXTsvL3ZlcnRleDFcclxuICAgICAgICAgICAgICAgIHEyeD1WMVs2XTsgcTJ5PVYxWzddOyBxMno9VjFbOF07Ly92ZXJ0ZXgzXHJcbiAgICAgICAgICAgICAgICBxM3g9VjFbOV07IHEzeT1WMVsxMF07IHEzej1WMVsxMV07Ly92ZXJ0ZXg0XHJcbiAgICAgICAgICAgICAgICBxNHg9VjFbM107IHE0eT1WMVs0XTsgcTR6PVYxWzVdOy8vdmVydGV4MlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYobWluRG90SW5kZXg9PTEpey8vIHgtIGZhY2VcclxuICAgICAgICAgICAgICAgIHExeD1WMVsxNV07IHExeT1WMVsxNl07IHExej1WMVsxN107Ly92ZXJ0ZXg2XHJcbiAgICAgICAgICAgICAgICBxMng9VjFbMjFdOyBxMnk9VjFbMjJdOyBxMno9VjFbMjNdOy8vdmVydGV4OFxyXG4gICAgICAgICAgICAgICAgcTN4PVYxWzE4XTsgcTN5PVYxWzE5XTsgcTN6PVYxWzIwXTsvL3ZlcnRleDdcclxuICAgICAgICAgICAgICAgIHE0eD1WMVsxMl07IHE0eT1WMVsxM107IHE0ej1WMVsxNF07Ly92ZXJ0ZXg1XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihtaW5Eb3RJbmRleD09Mil7Ly8geSsgZmFjZVxyXG4gICAgICAgICAgICAgICAgcTF4PVYxWzEyXTsgcTF5PVYxWzEzXTsgcTF6PVYxWzE0XTsvL3ZlcnRleDVcclxuICAgICAgICAgICAgICAgIHEyeD1WMVswXTsgcTJ5PVYxWzFdOyBxMno9VjFbMl07Ly92ZXJ0ZXgxXHJcbiAgICAgICAgICAgICAgICBxM3g9VjFbM107IHEzeT1WMVs0XTsgcTN6PVYxWzVdOy8vdmVydGV4MlxyXG4gICAgICAgICAgICAgICAgcTR4PVYxWzE1XTsgcTR5PVYxWzE2XTsgcTR6PVYxWzE3XTsvL3ZlcnRleDZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG1pbkRvdEluZGV4PT0zKXsvLyB5LSBmYWNlXHJcbiAgICAgICAgICAgICAgICBxMXg9VjFbMjFdOyBxMXk9VjFbMjJdOyBxMXo9VjFbMjNdOy8vdmVydGV4OFxyXG4gICAgICAgICAgICAgICAgcTJ4PVYxWzldOyBxMnk9VjFbMTBdOyBxMno9VjFbMTFdOy8vdmVydGV4NFxyXG4gICAgICAgICAgICAgICAgcTN4PVYxWzZdOyBxM3k9VjFbN107IHEzej1WMVs4XTsvL3ZlcnRleDNcclxuICAgICAgICAgICAgICAgIHE0eD1WMVsxOF07IHE0eT1WMVsxOV07IHE0ej1WMVsyMF07Ly92ZXJ0ZXg3XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihtaW5Eb3RJbmRleD09NCl7Ly8geisgZmFjZVxyXG4gICAgICAgICAgICAgICAgcTF4PVYxWzEyXTsgcTF5PVYxWzEzXTsgcTF6PVYxWzE0XTsvL3ZlcnRleDVcclxuICAgICAgICAgICAgICAgIHEyeD1WMVsxOF07IHEyeT1WMVsxOV07IHEyej1WMVsyMF07Ly92ZXJ0ZXg3XHJcbiAgICAgICAgICAgICAgICBxM3g9VjFbNl07IHEzeT1WMVs3XTsgcTN6PVYxWzhdOy8vdmVydGV4M1xyXG4gICAgICAgICAgICAgICAgcTR4PVYxWzBdOyBxNHk9VjFbMV07IHE0ej1WMVsyXTsvL3ZlcnRleDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG1pbkRvdEluZGV4PT01KXsvLyB6LSBmYWNlXHJcbiAgICAgICAgICAgICAgICBxMXg9VjFbM107IHExeT1WMVs0XTsgcTF6PVYxWzVdOy8vdmVydGV4MlxyXG4gICAgICAgICAgICAgICAgLy8yeD1WMVs2XTsgcTJ5PVYxWzddOyBxMno9VjFbOF07Ly92ZXJ0ZXg0ICEhIVxyXG4gICAgICAgICAgICAgICAgcTJ4PVYyWzldOyBxMnk9VjJbMTBdOyBxMno9VjJbMTFdOy8vdmVydGV4NFxyXG4gICAgICAgICAgICAgICAgcTN4PVYxWzIxXTsgcTN5PVYxWzIyXTsgcTN6PVYxWzIzXTsvL3ZlcnRleDhcclxuICAgICAgICAgICAgICAgIHE0eD1WMVsxNV07IHE0eT1WMVsxNl07IHE0ej1WMVsxN107Ly92ZXJ0ZXg2XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGRvdD1hNHgqbngrYTR5Km55K2E0eipuejtcclxuICAgICAgICAgICAgaWYoZG90PG1pbkRvdCl7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3Q9ZG90O1xyXG4gICAgICAgICAgICAgICAgbWluRG90SW5kZXg9MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZigtZG90PG1pbkRvdCl7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3Q9LWRvdDtcclxuICAgICAgICAgICAgICAgIG1pbkRvdEluZGV4PTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG90PWE1eCpueCthNXkqbnkrYTV6Km56O1xyXG4gICAgICAgICAgICBpZihkb3Q8bWluRG90KXtcclxuICAgICAgICAgICAgICAgIG1pbkRvdD1kb3Q7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3RJbmRleD0yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKC1kb3Q8bWluRG90KXtcclxuICAgICAgICAgICAgICAgIG1pbkRvdD0tZG90O1xyXG4gICAgICAgICAgICAgICAgbWluRG90SW5kZXg9MztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb3Q9YTZ4Km54K2E2eSpueSthNnoqbno7XHJcbiAgICAgICAgICAgIGlmKGRvdDxtaW5Eb3Qpe1xyXG4gICAgICAgICAgICAgICAgbWluRG90PWRvdDtcclxuICAgICAgICAgICAgICAgIG1pbkRvdEluZGV4PTQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoLWRvdDxtaW5Eb3Qpe1xyXG4gICAgICAgICAgICAgICAgbWluRG90PS1kb3Q7XHJcbiAgICAgICAgICAgICAgICBtaW5Eb3RJbmRleD01O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xyXG5cclxuICAgICAgICAgICAgaWYobWluRG90SW5kZXg9PTApey8vIHgrIGZhY2VcclxuICAgICAgICAgICAgICAgIHExeD1WMlswXTsgcTF5PVYyWzFdOyBxMXo9VjJbMl07Ly92ZXJ0ZXgxXHJcbiAgICAgICAgICAgICAgICBxMng9VjJbNl07IHEyeT1WMls3XTsgcTJ6PVYyWzhdOy8vdmVydGV4M1xyXG4gICAgICAgICAgICAgICAgcTN4PVYyWzldOyBxM3k9VjJbMTBdOyBxM3o9VjJbMTFdOy8vdmVydGV4NFxyXG4gICAgICAgICAgICAgICAgcTR4PVYyWzNdOyBxNHk9VjJbNF07IHE0ej1WMls1XTsvL3ZlcnRleDJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG1pbkRvdEluZGV4PT0xKXsvLyB4LSBmYWNlXHJcbiAgICAgICAgICAgICAgICBxMXg9VjJbMTVdOyBxMXk9VjJbMTZdOyBxMXo9VjJbMTddOy8vdmVydGV4NlxyXG4gICAgICAgICAgICAgICAgcTJ4PVYyWzIxXTsgcTJ5PVYyWzIyXTsgcTJ6PVYyWzIzXTsgLy92ZXJ0ZXg4XHJcbiAgICAgICAgICAgICAgICBxM3g9VjJbMThdOyBxM3k9VjJbMTldOyBxM3o9VjJbMjBdOy8vdmVydGV4N1xyXG4gICAgICAgICAgICAgICAgcTR4PVYyWzEyXTsgcTR5PVYyWzEzXTsgcTR6PVYyWzE0XTsvL3ZlcnRleDVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG1pbkRvdEluZGV4PT0yKXsvLyB5KyBmYWNlXHJcbiAgICAgICAgICAgICAgICBxMXg9VjJbMTJdOyBxMXk9VjJbMTNdOyBxMXo9VjJbMTRdOy8vdmVydGV4NVxyXG4gICAgICAgICAgICAgICAgcTJ4PVYyWzBdOyBxMnk9VjJbMV07IHEyej1WMlsyXTsvL3ZlcnRleDFcclxuICAgICAgICAgICAgICAgIHEzeD1WMlszXTsgcTN5PVYyWzRdOyBxM3o9VjJbNV07Ly92ZXJ0ZXgyXHJcbiAgICAgICAgICAgICAgICBxNHg9VjJbMTVdOyBxNHk9VjJbMTZdOyBxNHo9VjJbMTddOy8vdmVydGV4NlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYobWluRG90SW5kZXg9PTMpey8vIHktIGZhY2VcclxuICAgICAgICAgICAgICAgIHExeD1WMlsyMV07IHExeT1WMlsyMl07IHExej1WMlsyM107Ly92ZXJ0ZXg4XHJcbiAgICAgICAgICAgICAgICBxMng9VjJbOV07IHEyeT1WMlsxMF07IHEyej1WMlsxMV07Ly92ZXJ0ZXg0XHJcbiAgICAgICAgICAgICAgICBxM3g9VjJbNl07IHEzeT1WMls3XTsgcTN6PVYyWzhdOy8vdmVydGV4M1xyXG4gICAgICAgICAgICAgICAgcTR4PVYyWzE4XTsgcTR5PVYyWzE5XTsgcTR6PVYyWzIwXTsvL3ZlcnRleDdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG1pbkRvdEluZGV4PT00KXsvLyB6KyBmYWNlXHJcbiAgICAgICAgICAgICAgICBxMXg9VjJbMTJdOyBxMXk9VjJbMTNdOyBxMXo9VjJbMTRdOy8vdmVydGV4NVxyXG4gICAgICAgICAgICAgICAgcTJ4PVYyWzE4XTsgcTJ5PVYyWzE5XTsgcTJ6PVYyWzIwXTsvL3ZlcnRleDdcclxuICAgICAgICAgICAgICAgIHEzeD1WMls2XTsgcTN5PVYyWzddOyBxM3o9VjJbOF07Ly92ZXJ0ZXgzXHJcbiAgICAgICAgICAgICAgICBxNHg9VjJbMF07IHE0eT1WMlsxXTsgcTR6PVYyWzJdOy8vdmVydGV4MVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYobWluRG90SW5kZXg9PTUpey8vIHotIGZhY2VcclxuICAgICAgICAgICAgICAgIHExeD1WMlszXTsgcTF5PVYyWzRdOyBxMXo9VjJbNV07Ly92ZXJ0ZXgyXHJcbiAgICAgICAgICAgICAgICBxMng9VjJbOV07IHEyeT1WMlsxMF07IHEyej1WMlsxMV07Ly92ZXJ0ZXg0XHJcbiAgICAgICAgICAgICAgICBxM3g9VjJbMjFdOyBxM3k9VjJbMjJdOyBxM3o9VjJbMjNdOy8vdmVydGV4OFxyXG4gICAgICAgICAgICAgICAgcTR4PVYyWzE1XTsgcTR5PVYyWzE2XTsgcTR6PVYyWzE3XTsvL3ZlcnRleDZcclxuICAgICAgICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2xpcCB2ZXJ0aWNlc1xyXG4gICAgICAgIHZhciBudW1DbGlwVmVydGljZXM7XHJcbiAgICAgICAgdmFyIG51bUFkZGVkQ2xpcFZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICB2YXIgeDE7XHJcbiAgICAgICAgdmFyIHkxO1xyXG4gICAgICAgIHZhciB6MTtcclxuICAgICAgICB2YXIgeDI7XHJcbiAgICAgICAgdmFyIHkyO1xyXG4gICAgICAgIHZhciB6MjtcclxuICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbMF09cTF4O1xyXG4gICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVsxXT1xMXk7XHJcbiAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxWzJdPXExejtcclxuICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbM109cTJ4O1xyXG4gICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVs0XT1xMnk7XHJcbiAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxWzVdPXEyejtcclxuICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbNl09cTN4O1xyXG4gICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVs3XT1xM3k7XHJcbiAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxWzhdPXEzejtcclxuICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbOV09cTR4O1xyXG4gICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVsxMF09cTR5O1xyXG4gICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVsxMV09cTR6O1xyXG4gICAgICAgIG51bUFkZGVkQ2xpcFZlcnRpY2VzPTA7XHJcbiAgICAgICAgeDE9dGhpcy5jbGlwVmVydGljZXMxWzldO1xyXG4gICAgICAgIHkxPXRoaXMuY2xpcFZlcnRpY2VzMVsxMF07XHJcbiAgICAgICAgejE9dGhpcy5jbGlwVmVydGljZXMxWzExXTtcclxuICAgICAgICBkb3QxPSh4MS1jeC1zMXgpKm4xeCsoeTEtY3ktczF5KSpuMXkrKHoxLWN6LXMxeikqbjF6O1xyXG5cclxuICAgICAgICAvL3ZhciBpID0gNDtcclxuICAgICAgICAvL3doaWxlKGktLSl7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7aTw0O2krKyl7XHJcbiAgICAgICAgICAgIGluZGV4PWkqMztcclxuICAgICAgICAgICAgeDI9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4XTtcclxuICAgICAgICAgICAgeTI9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzFdO1xyXG4gICAgICAgICAgICB6Mj10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMl07XHJcbiAgICAgICAgICAgIGRvdDI9KHgyLWN4LXMxeCkqbjF4Kyh5Mi1jeS1zMXkpKm4xeSsoejItY3otczF6KSpuMXo7XHJcbiAgICAgICAgICAgIGlmKGRvdDE+MCl7XHJcbiAgICAgICAgICAgICAgICBpZihkb3QyPjApe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PW51bUFkZGVkQ2xpcFZlcnRpY2VzKjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXhdPXgyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsxXT15MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMl09ejI7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleD1udW1BZGRlZENsaXBWZXJ0aWNlcyozO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bUFkZGVkQ2xpcFZlcnRpY2VzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdD1kb3QxLyhkb3QxLWRvdDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleF09eDErKHgyLXgxKSp0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsxXT15MSsoeTIteTEpKnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzJdPXoxKyh6Mi16MSkqdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZihkb3QyPjApe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PW51bUFkZGVkQ2xpcFZlcnRpY2VzKjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB0PWRvdDEvKGRvdDEtZG90Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMyW2luZGV4XT14MSsoeDIteDEpKnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzFdPXkxKyh5Mi15MSkqdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMl09ejErKHoyLXoxKSp0O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PW51bUFkZGVkQ2xpcFZlcnRpY2VzKjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXhdPXgyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsxXT15MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMl09ejI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeDE9eDI7XHJcbiAgICAgICAgICAgIHkxPXkyO1xyXG4gICAgICAgICAgICB6MT16MjtcclxuICAgICAgICAgICAgZG90MT1kb3QyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbnVtQ2xpcFZlcnRpY2VzPW51bUFkZGVkQ2xpcFZlcnRpY2VzO1xyXG4gICAgICAgIGlmKG51bUNsaXBWZXJ0aWNlcz09MClyZXR1cm47XHJcbiAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXM9MDtcclxuICAgICAgICBpbmRleD0obnVtQ2xpcFZlcnRpY2VzLTEpKjM7XHJcbiAgICAgICAgeDE9dGhpcy5jbGlwVmVydGljZXMyW2luZGV4XTtcclxuICAgICAgICB5MT10aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMV07XHJcbiAgICAgICAgejE9dGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzJdO1xyXG4gICAgICAgIGRvdDE9KHgxLWN4LXMyeCkqbjJ4Kyh5MS1jeS1zMnkpKm4yeSsoejEtY3otczJ6KSpuMno7XHJcblxyXG4gICAgICAgIC8vaSA9IG51bUNsaXBWZXJ0aWNlcztcclxuICAgICAgICAvL3doaWxlKGktLSl7XHJcbiAgICAgICAgZm9yKGk9MDtpPG51bUNsaXBWZXJ0aWNlcztpKyspe1xyXG4gICAgICAgICAgICBpbmRleD1pKjM7XHJcbiAgICAgICAgICAgIHgyPXRoaXMuY2xpcFZlcnRpY2VzMltpbmRleF07XHJcbiAgICAgICAgICAgIHkyPXRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsxXTtcclxuICAgICAgICAgICAgejI9dGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzJdO1xyXG4gICAgICAgICAgICBkb3QyPSh4Mi1jeC1zMngpKm4yeCsoeTItY3ktczJ5KSpuMnkrKHoyLWN6LXMyeikqbjJ6O1xyXG4gICAgICAgICAgICBpZihkb3QxPjApe1xyXG4gICAgICAgICAgICAgICAgaWYoZG90Mj4wKXtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleD1udW1BZGRlZENsaXBWZXJ0aWNlcyozO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bUFkZGVkQ2xpcFZlcnRpY2VzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4XT14MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMV09eTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzJdPXoyO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg9bnVtQWRkZWRDbGlwVmVydGljZXMqMztcclxuICAgICAgICAgICAgICAgICAgICBudW1BZGRlZENsaXBWZXJ0aWNlcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHQ9ZG90MS8oZG90MS1kb3QyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXhdPXgxKyh4Mi14MSkqdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMV09eTErKHkyLXkxKSp0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsyXT16MSsoejItejEpKnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaWYoZG90Mj4wKXtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleD1udW1BZGRlZENsaXBWZXJ0aWNlcyozO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bUFkZGVkQ2xpcFZlcnRpY2VzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdD1kb3QxLyhkb3QxLWRvdDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleF09eDErKHgyLXgxKSp0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsxXT15MSsoeTIteTEpKnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzJdPXoxKyh6Mi16MSkqdDtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleD1udW1BZGRlZENsaXBWZXJ0aWNlcyozO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bUFkZGVkQ2xpcFZlcnRpY2VzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4XT14MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMV09eTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzJdPXoyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHgxPXgyO1xyXG4gICAgICAgICAgICB5MT15MjtcclxuICAgICAgICAgICAgejE9ejI7XHJcbiAgICAgICAgICAgIGRvdDE9ZG90MjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG51bUNsaXBWZXJ0aWNlcz1udW1BZGRlZENsaXBWZXJ0aWNlcztcclxuICAgICAgICBpZihudW1DbGlwVmVydGljZXM9PTApcmV0dXJuO1xyXG4gICAgICAgIG51bUFkZGVkQ2xpcFZlcnRpY2VzPTA7XHJcbiAgICAgICAgaW5kZXg9KG51bUNsaXBWZXJ0aWNlcy0xKSozO1xyXG4gICAgICAgIHgxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleF07XHJcbiAgICAgICAgeTE9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzFdO1xyXG4gICAgICAgIHoxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsyXTtcclxuICAgICAgICBkb3QxPSh4MS1jeCtzMXgpKi1uMXgrKHkxLWN5K3MxeSkqLW4xeSsoejEtY3orczF6KSotbjF6O1xyXG5cclxuICAgICAgICAvL2kgPSBudW1DbGlwVmVydGljZXM7XHJcbiAgICAgICAgLy93aGlsZShpLS0pe1xyXG4gICAgICAgIGZvcihpPTA7aTxudW1DbGlwVmVydGljZXM7aSsrKXtcclxuICAgICAgICAgICAgaW5kZXg9aSozO1xyXG4gICAgICAgICAgICB4Mj10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXhdO1xyXG4gICAgICAgICAgICB5Mj10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMV07XHJcbiAgICAgICAgICAgIHoyPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsyXTtcclxuICAgICAgICAgICAgZG90Mj0oeDItY3grczF4KSotbjF4Kyh5Mi1jeStzMXkpKi1uMXkrKHoyLWN6K3MxeikqLW4xejtcclxuICAgICAgICAgICAgaWYoZG90MT4wKXtcclxuICAgICAgICAgICAgICAgIGlmKGRvdDI+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg9bnVtQWRkZWRDbGlwVmVydGljZXMqMztcclxuICAgICAgICAgICAgICAgICAgICBudW1BZGRlZENsaXBWZXJ0aWNlcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleF09eDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzFdPXkyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsyXT16MjtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PW51bUFkZGVkQ2xpcFZlcnRpY2VzKjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB0PWRvdDEvKGRvdDEtZG90Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMyW2luZGV4XT14MSsoeDIteDEpKnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzFdPXkxKyh5Mi15MSkqdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMl09ejErKHoyLXoxKSp0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKGRvdDI+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg9bnVtQWRkZWRDbGlwVmVydGljZXMqMztcclxuICAgICAgICAgICAgICAgICAgICBudW1BZGRlZENsaXBWZXJ0aWNlcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHQ9ZG90MS8oZG90MS1kb3QyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXhdPXgxKyh4Mi14MSkqdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMV09eTErKHkyLXkxKSp0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsyXT16MSsoejItejEpKnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg9bnVtQWRkZWRDbGlwVmVydGljZXMqMztcclxuICAgICAgICAgICAgICAgICAgICBudW1BZGRlZENsaXBWZXJ0aWNlcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleF09eDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzFdPXkyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsyXT16MjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4MT14MjtcclxuICAgICAgICAgICAgeTE9eTI7XHJcbiAgICAgICAgICAgIHoxPXoyO1xyXG4gICAgICAgICAgICBkb3QxPWRvdDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBudW1DbGlwVmVydGljZXM9bnVtQWRkZWRDbGlwVmVydGljZXM7XHJcbiAgICAgICAgaWYobnVtQ2xpcFZlcnRpY2VzPT0wKXJldHVybjtcclxuICAgICAgICBudW1BZGRlZENsaXBWZXJ0aWNlcz0wO1xyXG4gICAgICAgIGluZGV4PShudW1DbGlwVmVydGljZXMtMSkqMztcclxuICAgICAgICB4MT10aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXhdO1xyXG4gICAgICAgIHkxPXRoaXMuY2xpcFZlcnRpY2VzMltpbmRleCsxXTtcclxuICAgICAgICB6MT10aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMl07XHJcbiAgICAgICAgZG90MT0oeDEtY3grczJ4KSotbjJ4Kyh5MS1jeStzMnkpKi1uMnkrKHoxLWN6K3MyeikqLW4yejtcclxuXHJcbiAgICAgICAgLy9pID0gbnVtQ2xpcFZlcnRpY2VzO1xyXG4gICAgICAgIC8vd2hpbGUoaS0tKXtcclxuICAgICAgICBmb3IoaT0wO2k8bnVtQ2xpcFZlcnRpY2VzO2krKyl7XHJcbiAgICAgICAgICAgIGluZGV4PWkqMztcclxuICAgICAgICAgICAgeDI9dGhpcy5jbGlwVmVydGljZXMyW2luZGV4XTtcclxuICAgICAgICAgICAgeTI9dGhpcy5jbGlwVmVydGljZXMyW2luZGV4KzFdO1xyXG4gICAgICAgICAgICB6Mj10aGlzLmNsaXBWZXJ0aWNlczJbaW5kZXgrMl07XHJcbiAgICAgICAgICAgIGRvdDI9KHgyLWN4K3MyeCkqLW4yeCsoeTItY3krczJ5KSotbjJ5Kyh6Mi1jeitzMnopKi1uMno7XHJcbiAgICAgICAgICAgIGlmKGRvdDE+MCl7XHJcbiAgICAgICAgICAgICAgICBpZihkb3QyPjApe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PW51bUFkZGVkQ2xpcFZlcnRpY2VzKjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXhdPXgyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsxXT15MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMl09ejI7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleD1udW1BZGRlZENsaXBWZXJ0aWNlcyozO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bUFkZGVkQ2xpcFZlcnRpY2VzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdD1kb3QxLyhkb3QxLWRvdDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleF09eDErKHgyLXgxKSp0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsxXT15MSsoeTIteTEpKnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzJdPXoxKyh6Mi16MSkqdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZihkb3QyPjApe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PW51bUFkZGVkQ2xpcFZlcnRpY2VzKjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB0PWRvdDEvKGRvdDEtZG90Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4XT14MSsoeDIteDEpKnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzFdPXkxKyh5Mi15MSkqdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMl09ejErKHoyLXoxKSp0O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PW51bUFkZGVkQ2xpcFZlcnRpY2VzKjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQWRkZWRDbGlwVmVydGljZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXhdPXgyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsxXT15MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMl09ejI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeDE9eDI7XHJcbiAgICAgICAgICAgIHkxPXkyO1xyXG4gICAgICAgICAgICB6MT16MjtcclxuICAgICAgICAgICAgZG90MT1kb3QyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbnVtQ2xpcFZlcnRpY2VzPW51bUFkZGVkQ2xpcFZlcnRpY2VzO1xyXG4gICAgICAgIGlmKHN3YXApe1xyXG4gICAgICAgICAgICB2YXIgdGI9YjE7XHJcbiAgICAgICAgICAgIGIxPWIyO1xyXG4gICAgICAgICAgICBiMj10YjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobnVtQ2xpcFZlcnRpY2VzPT0wKXJldHVybjtcclxuICAgICAgICB2YXIgZmxpcHBlZD1iMSE9c2hhcGUxO1xyXG4gICAgICAgIGlmKG51bUNsaXBWZXJ0aWNlcz40KXtcclxuICAgICAgICAgICAgeDE9KHExeCtxMngrcTN4K3E0eCkqMC4yNTtcclxuICAgICAgICAgICAgeTE9KHExeStxMnkrcTN5K3E0eSkqMC4yNTtcclxuICAgICAgICAgICAgejE9KHExeitxMnorcTN6K3E0eikqMC4yNTtcclxuICAgICAgICAgICAgbjF4PXExeC14MTtcclxuICAgICAgICAgICAgbjF5PXExeS15MTtcclxuICAgICAgICAgICAgbjF6PXExei16MTtcclxuICAgICAgICAgICAgbjJ4PXEyeC14MTtcclxuICAgICAgICAgICAgbjJ5PXEyeS15MTtcclxuICAgICAgICAgICAgbjJ6PXEyei16MTtcclxuICAgICAgICAgICAgdmFyIGluZGV4MT0wO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXgyPTA7XHJcbiAgICAgICAgICAgIHZhciBpbmRleDM9MDtcclxuICAgICAgICAgICAgdmFyIGluZGV4ND0wO1xyXG4gICAgICAgICAgICB2YXIgbWF4RG90PS10aGlzLklORjtcclxuICAgICAgICAgICAgbWluRG90PXRoaXMuSU5GO1xyXG5cclxuICAgICAgICAgICAgLy9pID0gbnVtQ2xpcFZlcnRpY2VzO1xyXG4gICAgICAgICAgICAvL3doaWxlKGktLSl7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxudW1DbGlwVmVydGljZXM7aSsrKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudXNlZFtpXT1mYWxzZTtcclxuICAgICAgICAgICAgICAgIGluZGV4PWkqMztcclxuICAgICAgICAgICAgICAgIHgxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICB5MT10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMV07XHJcbiAgICAgICAgICAgICAgICB6MT10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMl07XHJcbiAgICAgICAgICAgICAgICBkb3Q9eDEqbjF4K3kxKm4xeSt6MSpuMXo7XHJcbiAgICAgICAgICAgICAgICBpZihkb3Q8bWluRG90KXtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Eb3Q9ZG90O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4MT1pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoZG90Pm1heERvdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RG90PWRvdDtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDM9aTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy51c2VkW2luZGV4MV09dHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51c2VkW2luZGV4M109dHJ1ZTtcclxuICAgICAgICAgICAgbWF4RG90PS10aGlzLklORjtcclxuICAgICAgICAgICAgbWluRG90PXRoaXMuSU5GO1xyXG5cclxuICAgICAgICAgICAgLy9pID0gbnVtQ2xpcFZlcnRpY2VzO1xyXG4gICAgICAgICAgICAvL3doaWxlKGktLSl7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxudW1DbGlwVmVydGljZXM7aSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMudXNlZFtpXSljb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGluZGV4PWkqMztcclxuICAgICAgICAgICAgICAgIHgxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICB5MT10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMV07XHJcbiAgICAgICAgICAgICAgICB6MT10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMl07XHJcbiAgICAgICAgICAgICAgICBkb3Q9eDEqbjJ4K3kxKm4yeSt6MSpuMno7XHJcbiAgICAgICAgICAgICAgICBpZihkb3Q8bWluRG90KXtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Eb3Q9ZG90O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Mj1pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoZG90Pm1heERvdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RG90PWRvdDtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDQ9aTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW5kZXg9aW5kZXgxKjM7XHJcbiAgICAgICAgICAgIHgxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleF07XHJcbiAgICAgICAgICAgIHkxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsxXTtcclxuICAgICAgICAgICAgejE9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzJdO1xyXG4gICAgICAgICAgICBkb3Q9KHgxLWN4KSpueCsoeTEtY3kpKm55Kyh6MS1jeikqbno7XHJcbiAgICAgICAgICAgIGlmKGRvdDwwKSBtYW5pZm9sZC5hZGRQb2ludCh4MSx5MSx6MSxueCxueSxueixkb3QsZmxpcHBlZCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpbmRleD1pbmRleDIqMztcclxuICAgICAgICAgICAgeDE9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4XTtcclxuICAgICAgICAgICAgeTE9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzFdO1xyXG4gICAgICAgICAgICB6MT10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMl07XHJcbiAgICAgICAgICAgIGRvdD0oeDEtY3gpKm54Kyh5MS1jeSkqbnkrKHoxLWN6KSpuejtcclxuICAgICAgICAgICAgaWYoZG90PDApIG1hbmlmb2xkLmFkZFBvaW50KHgxLHkxLHoxLG54LG55LG56LGRvdCxmbGlwcGVkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGluZGV4PWluZGV4MyozO1xyXG4gICAgICAgICAgICB4MT10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXhdO1xyXG4gICAgICAgICAgICB5MT10aGlzLmNsaXBWZXJ0aWNlczFbaW5kZXgrMV07XHJcbiAgICAgICAgICAgIHoxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsyXTtcclxuICAgICAgICAgICAgZG90PSh4MS1jeCkqbngrKHkxLWN5KSpueSsoejEtY3opKm56O1xyXG4gICAgICAgICAgICBpZihkb3Q8MCkgbWFuaWZvbGQuYWRkUG9pbnQoeDEseTEsejEsbngsbnksbnosZG90LGZsaXBwZWQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaW5kZXg9aW5kZXg0KjM7XHJcbiAgICAgICAgICAgIHgxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleF07XHJcbiAgICAgICAgICAgIHkxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsxXTtcclxuICAgICAgICAgICAgejE9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4KzJdO1xyXG4gICAgICAgICAgICBkb3Q9KHgxLWN4KSpueCsoeTEtY3kpKm55Kyh6MS1jeikqbno7XHJcbiAgICAgICAgICAgIGlmKGRvdDwwKSBtYW5pZm9sZC5hZGRQb2ludCh4MSx5MSx6MSxueCxueSxueixkb3QsZmxpcHBlZCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL2kgPSBudW1DbGlwVmVydGljZXM7XHJcbiAgICAgICAgICAgIC8vd2hpbGUoaS0tKXtcclxuICAgICAgICAgICAgZm9yKGk9MDtpPG51bUNsaXBWZXJ0aWNlcztpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg9aSozO1xyXG4gICAgICAgICAgICAgICAgeDE9dGhpcy5jbGlwVmVydGljZXMxW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHkxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsxXTtcclxuICAgICAgICAgICAgICAgIHoxPXRoaXMuY2xpcFZlcnRpY2VzMVtpbmRleCsyXTtcclxuICAgICAgICAgICAgICAgIGRvdD0oeDEtY3gpKm54Kyh5MS1jeSkqbnkrKHoxLWN6KSpuejtcclxuICAgICAgICAgICAgICAgIGlmKGRvdDwwKW1hbmlmb2xkLmFkZFBvaW50KHgxLHkxLHoxLG54LG55LG56LGRvdCxmbGlwcGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcblxuZnVuY3Rpb24gQm94Q3lsaW5kZXJDb2xsaXNpb25EZXRlY3RvciAoZmxpcCl7XHJcblxyXG4gICAgQ29sbGlzaW9uRGV0ZWN0b3IuY2FsbCggdGhpcyApO1xyXG4gICAgdGhpcy5mbGlwID0gZmxpcDtcclxuXHJcbn1cclxuXHJcbkJveEN5bGluZGVyQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlICksIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogQm94Q3lsaW5kZXJDb2xsaXNpb25EZXRlY3RvcixcclxuXHJcbiAgICBnZXRTZXA6IGZ1bmN0aW9uICggYzEsIGMyLCBzZXAsIHBvcywgZGVwICkge1xyXG5cclxuICAgICAgICB2YXIgdDF4O1xyXG4gICAgICAgIHZhciB0MXk7XHJcbiAgICAgICAgdmFyIHQxejtcclxuICAgICAgICB2YXIgdDJ4O1xyXG4gICAgICAgIHZhciB0Mnk7XHJcbiAgICAgICAgdmFyIHQyejtcclxuICAgICAgICB2YXIgc3VwPW5ldyBWZWMzKCk7XHJcbiAgICAgICAgdmFyIGxlbjtcclxuICAgICAgICB2YXIgcDF4O1xyXG4gICAgICAgIHZhciBwMXk7XHJcbiAgICAgICAgdmFyIHAxejtcclxuICAgICAgICB2YXIgcDJ4O1xyXG4gICAgICAgIHZhciBwMnk7XHJcbiAgICAgICAgdmFyIHAyejtcclxuICAgICAgICB2YXIgdjAxeD1jMS5wb3NpdGlvbi54O1xyXG4gICAgICAgIHZhciB2MDF5PWMxLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgdmFyIHYwMXo9YzEucG9zaXRpb24uejtcclxuICAgICAgICB2YXIgdjAyeD1jMi5wb3NpdGlvbi54O1xyXG4gICAgICAgIHZhciB2MDJ5PWMyLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgdmFyIHYwMno9YzIucG9zaXRpb24uejtcclxuICAgICAgICB2YXIgdjB4PXYwMngtdjAxeDtcclxuICAgICAgICB2YXIgdjB5PXYwMnktdjAxeTtcclxuICAgICAgICB2YXIgdjB6PXYwMnotdjAxejtcclxuICAgICAgICBpZih2MHgqdjB4K3YweSp2MHkrdjB6KnYwej09MCl2MHk9MC4wMDE7XHJcbiAgICAgICAgdmFyIG54PS12MHg7XHJcbiAgICAgICAgdmFyIG55PS12MHk7XHJcbiAgICAgICAgdmFyIG56PS12MHo7XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnRCKGMxLC1ueCwtbnksLW56LHN1cCk7XHJcbiAgICAgICAgdmFyIHYxMXg9c3VwLng7XHJcbiAgICAgICAgdmFyIHYxMXk9c3VwLnk7XHJcbiAgICAgICAgdmFyIHYxMXo9c3VwLno7XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnRDKGMyLG54LG55LG56LHN1cCk7XHJcbiAgICAgICAgdmFyIHYxMng9c3VwLng7XHJcbiAgICAgICAgdmFyIHYxMnk9c3VwLnk7XHJcbiAgICAgICAgdmFyIHYxMno9c3VwLno7XHJcbiAgICAgICAgdmFyIHYxeD12MTJ4LXYxMXg7XHJcbiAgICAgICAgdmFyIHYxeT12MTJ5LXYxMXk7XHJcbiAgICAgICAgdmFyIHYxej12MTJ6LXYxMXo7XHJcbiAgICAgICAgaWYodjF4Km54K3YxeSpueSt2MXoqbno8PTApe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbng9djF5KnYwei12MXoqdjB5O1xyXG4gICAgICAgIG55PXYxeip2MHgtdjF4KnYwejtcclxuICAgICAgICBuej12MXgqdjB5LXYxeSp2MHg7XHJcbiAgICAgICAgaWYobngqbngrbnkqbnkrbnoqbno9PTApe1xyXG4gICAgICAgIHNlcC5zZXQoIHYxeC12MHgsIHYxeS12MHksIHYxei12MHogKS5ub3JtYWxpemUoKTtcclxuICAgICAgICBwb3Muc2V0KCAodjExeCt2MTJ4KSowLjUsICh2MTF5K3YxMnkpKjAuNSwgKHYxMXordjEyeikqMC41ICk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3VwcG9ydFBvaW50QihjMSwtbngsLW55LC1ueixzdXApO1xyXG4gICAgICAgIHZhciB2MjF4PXN1cC54O1xyXG4gICAgICAgIHZhciB2MjF5PXN1cC55O1xyXG4gICAgICAgIHZhciB2MjF6PXN1cC56O1xyXG4gICAgICAgIHRoaXMuc3VwcG9ydFBvaW50QyhjMixueCxueSxueixzdXApO1xyXG4gICAgICAgIHZhciB2MjJ4PXN1cC54O1xyXG4gICAgICAgIHZhciB2MjJ5PXN1cC55O1xyXG4gICAgICAgIHZhciB2MjJ6PXN1cC56O1xyXG4gICAgICAgIHZhciB2Mng9djIyeC12MjF4O1xyXG4gICAgICAgIHZhciB2Mnk9djIyeS12MjF5O1xyXG4gICAgICAgIHZhciB2Mno9djIyei12MjF6O1xyXG4gICAgICAgIGlmKHYyeCpueCt2MnkqbnkrdjJ6Km56PD0wKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHQxeD12MXgtdjB4O1xyXG4gICAgICAgIHQxeT12MXktdjB5O1xyXG4gICAgICAgIHQxej12MXotdjB6O1xyXG4gICAgICAgIHQyeD12MngtdjB4O1xyXG4gICAgICAgIHQyeT12MnktdjB5O1xyXG4gICAgICAgIHQyej12MnotdjB6O1xyXG4gICAgICAgIG54PXQxeSp0MnotdDF6KnQyeTtcclxuICAgICAgICBueT10MXoqdDJ4LXQxeCp0Mno7XHJcbiAgICAgICAgbno9dDF4KnQyeS10MXkqdDJ4O1xyXG4gICAgICAgIGlmKG54KnYweCtueSp2MHkrbnoqdjB6PjApe1xyXG4gICAgICAgIHQxeD12MXg7XHJcbiAgICAgICAgdDF5PXYxeTtcclxuICAgICAgICB0MXo9djF6O1xyXG4gICAgICAgIHYxeD12Mng7XHJcbiAgICAgICAgdjF5PXYyeTtcclxuICAgICAgICB2MXo9djJ6O1xyXG4gICAgICAgIHYyeD10MXg7XHJcbiAgICAgICAgdjJ5PXQxeTtcclxuICAgICAgICB2Mno9dDF6O1xyXG4gICAgICAgIHQxeD12MTF4O1xyXG4gICAgICAgIHQxeT12MTF5O1xyXG4gICAgICAgIHQxej12MTF6O1xyXG4gICAgICAgIHYxMXg9djIxeDtcclxuICAgICAgICB2MTF5PXYyMXk7XHJcbiAgICAgICAgdjExej12MjF6O1xyXG4gICAgICAgIHYyMXg9dDF4O1xyXG4gICAgICAgIHYyMXk9dDF5O1xyXG4gICAgICAgIHYyMXo9dDF6O1xyXG4gICAgICAgIHQxeD12MTJ4O1xyXG4gICAgICAgIHQxeT12MTJ5O1xyXG4gICAgICAgIHQxej12MTJ6O1xyXG4gICAgICAgIHYxMng9djIyeDtcclxuICAgICAgICB2MTJ5PXYyMnk7XHJcbiAgICAgICAgdjEyej12MjJ6O1xyXG4gICAgICAgIHYyMng9dDF4O1xyXG4gICAgICAgIHYyMnk9dDF5O1xyXG4gICAgICAgIHYyMno9dDF6O1xyXG4gICAgICAgIG54PS1ueDtcclxuICAgICAgICBueT0tbnk7XHJcbiAgICAgICAgbno9LW56O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlcmF0aW9ucz0wO1xyXG4gICAgICAgIHdoaWxlKHRydWUpe1xyXG4gICAgICAgIGlmKCsraXRlcmF0aW9ucz4xMDApe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnRCKGMxLC1ueCwtbnksLW56LHN1cCk7XHJcbiAgICAgICAgdmFyIHYzMXg9c3VwLng7XHJcbiAgICAgICAgdmFyIHYzMXk9c3VwLnk7XHJcbiAgICAgICAgdmFyIHYzMXo9c3VwLno7XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnRDKGMyLG54LG55LG56LHN1cCk7XHJcbiAgICAgICAgdmFyIHYzMng9c3VwLng7XHJcbiAgICAgICAgdmFyIHYzMnk9c3VwLnk7XHJcbiAgICAgICAgdmFyIHYzMno9c3VwLno7XHJcbiAgICAgICAgdmFyIHYzeD12MzJ4LXYzMXg7XHJcbiAgICAgICAgdmFyIHYzeT12MzJ5LXYzMXk7XHJcbiAgICAgICAgdmFyIHYzej12MzJ6LXYzMXo7XHJcbiAgICAgICAgaWYodjN4Km54K3YzeSpueSt2M3oqbno8PTApe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoKHYxeSp2M3otdjF6KnYzeSkqdjB4Kyh2MXoqdjN4LXYxeCp2M3opKnYweSsodjF4KnYzeS12MXkqdjN4KSp2MHo8MCl7XHJcbiAgICAgICAgdjJ4PXYzeDtcclxuICAgICAgICB2Mnk9djN5O1xyXG4gICAgICAgIHYyej12M3o7XHJcbiAgICAgICAgdjIxeD12MzF4O1xyXG4gICAgICAgIHYyMXk9djMxeTtcclxuICAgICAgICB2MjF6PXYzMXo7XHJcbiAgICAgICAgdjIyeD12MzJ4O1xyXG4gICAgICAgIHYyMnk9djMyeTtcclxuICAgICAgICB2MjJ6PXYzMno7XHJcbiAgICAgICAgdDF4PXYxeC12MHg7XHJcbiAgICAgICAgdDF5PXYxeS12MHk7XHJcbiAgICAgICAgdDF6PXYxei12MHo7XHJcbiAgICAgICAgdDJ4PXYzeC12MHg7XHJcbiAgICAgICAgdDJ5PXYzeS12MHk7XHJcbiAgICAgICAgdDJ6PXYzei12MHo7XHJcbiAgICAgICAgbng9dDF5KnQyei10MXoqdDJ5O1xyXG4gICAgICAgIG55PXQxeip0MngtdDF4KnQyejtcclxuICAgICAgICBuej10MXgqdDJ5LXQxeSp0Mng7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCh2M3kqdjJ6LXYzeip2MnkpKnYweCsodjN6KnYyeC12M3gqdjJ6KSp2MHkrKHYzeCp2MnktdjN5KnYyeCkqdjB6PDApe1xyXG4gICAgICAgIHYxeD12M3g7XHJcbiAgICAgICAgdjF5PXYzeTtcclxuICAgICAgICB2MXo9djN6O1xyXG4gICAgICAgIHYxMXg9djMxeDtcclxuICAgICAgICB2MTF5PXYzMXk7XHJcbiAgICAgICAgdjExej12MzF6O1xyXG4gICAgICAgIHYxMng9djMyeDtcclxuICAgICAgICB2MTJ5PXYzMnk7XHJcbiAgICAgICAgdjEyej12MzJ6O1xyXG4gICAgICAgIHQxeD12M3gtdjB4O1xyXG4gICAgICAgIHQxeT12M3ktdjB5O1xyXG4gICAgICAgIHQxej12M3otdjB6O1xyXG4gICAgICAgIHQyeD12MngtdjB4O1xyXG4gICAgICAgIHQyeT12MnktdjB5O1xyXG4gICAgICAgIHQyej12MnotdjB6O1xyXG4gICAgICAgIG54PXQxeSp0MnotdDF6KnQyeTtcclxuICAgICAgICBueT10MXoqdDJ4LXQxeCp0Mno7XHJcbiAgICAgICAgbno9dDF4KnQyeS10MXkqdDJ4O1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGl0PWZhbHNlO1xyXG4gICAgICAgIHdoaWxlKHRydWUpe1xyXG4gICAgICAgIHQxeD12MngtdjF4O1xyXG4gICAgICAgIHQxeT12MnktdjF5O1xyXG4gICAgICAgIHQxej12MnotdjF6O1xyXG4gICAgICAgIHQyeD12M3gtdjF4O1xyXG4gICAgICAgIHQyeT12M3ktdjF5O1xyXG4gICAgICAgIHQyej12M3otdjF6O1xyXG4gICAgICAgIG54PXQxeSp0MnotdDF6KnQyeTtcclxuICAgICAgICBueT10MXoqdDJ4LXQxeCp0Mno7XHJcbiAgICAgICAgbno9dDF4KnQyeS10MXkqdDJ4O1xyXG4gICAgICAgIGxlbj0xL19NYXRoLnNxcnQobngqbngrbnkqbnkrbnoqbnopO1xyXG4gICAgICAgIG54Kj1sZW47XHJcbiAgICAgICAgbnkqPWxlbjtcclxuICAgICAgICBueio9bGVuO1xyXG4gICAgICAgIGlmKG54KnYxeCtueSp2MXkrbnoqdjF6Pj0wJiYhaGl0KXtcclxuICAgICAgICB2YXIgYjA9KHYxeSp2MnotdjF6KnYyeSkqdjN4Kyh2MXoqdjJ4LXYxeCp2MnopKnYzeSsodjF4KnYyeS12MXkqdjJ4KSp2M3o7XHJcbiAgICAgICAgdmFyIGIxPSh2M3kqdjJ6LXYzeip2MnkpKnYweCsodjN6KnYyeC12M3gqdjJ6KSp2MHkrKHYzeCp2MnktdjN5KnYyeCkqdjB6O1xyXG4gICAgICAgIHZhciBiMj0odjB5KnYxei12MHoqdjF5KSp2M3grKHYweip2MXgtdjB4KnYxeikqdjN5Kyh2MHgqdjF5LXYweSp2MXgpKnYzejtcclxuICAgICAgICB2YXIgYjM9KHYyeSp2MXotdjJ6KnYxeSkqdjB4Kyh2MnoqdjF4LXYyeCp2MXopKnYweSsodjJ4KnYxeS12MnkqdjF4KSp2MHo7XHJcbiAgICAgICAgdmFyIHN1bT1iMCtiMStiMitiMztcclxuICAgICAgICBpZihzdW08PTApe1xyXG4gICAgICAgIGIwPTA7XHJcbiAgICAgICAgYjE9KHYyeSp2M3otdjJ6KnYzeSkqbngrKHYyeip2M3gtdjJ4KnYzeikqbnkrKHYyeCp2M3ktdjJ5KnYzeCkqbno7XHJcbiAgICAgICAgYjI9KHYzeSp2MnotdjN6KnYyeSkqbngrKHYzeip2MngtdjN4KnYyeikqbnkrKHYzeCp2MnktdjN5KnYyeCkqbno7XHJcbiAgICAgICAgYjM9KHYxeSp2MnotdjF6KnYyeSkqbngrKHYxeip2MngtdjF4KnYyeikqbnkrKHYxeCp2MnktdjF5KnYyeCkqbno7XHJcbiAgICAgICAgc3VtPWIxK2IyK2IzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW52PTEvc3VtO1xyXG4gICAgICAgIHAxeD0odjAxeCpiMCt2MTF4KmIxK3YyMXgqYjIrdjMxeCpiMykqaW52O1xyXG4gICAgICAgIHAxeT0odjAxeSpiMCt2MTF5KmIxK3YyMXkqYjIrdjMxeSpiMykqaW52O1xyXG4gICAgICAgIHAxej0odjAxeipiMCt2MTF6KmIxK3YyMXoqYjIrdjMxeipiMykqaW52O1xyXG4gICAgICAgIHAyeD0odjAyeCpiMCt2MTJ4KmIxK3YyMngqYjIrdjMyeCpiMykqaW52O1xyXG4gICAgICAgIHAyeT0odjAyeSpiMCt2MTJ5KmIxK3YyMnkqYjIrdjMyeSpiMykqaW52O1xyXG4gICAgICAgIHAyej0odjAyeipiMCt2MTJ6KmIxK3YyMnoqYjIrdjMyeipiMykqaW52O1xyXG4gICAgICAgIGhpdD10cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN1cHBvcnRQb2ludEIoYzEsLW54LC1ueSwtbnosc3VwKTtcclxuICAgICAgICB2YXIgdjQxeD1zdXAueDtcclxuICAgICAgICB2YXIgdjQxeT1zdXAueTtcclxuICAgICAgICB2YXIgdjQxej1zdXAuejtcclxuICAgICAgICB0aGlzLnN1cHBvcnRQb2ludEMoYzIsbngsbnksbnosc3VwKTtcclxuICAgICAgICB2YXIgdjQyeD1zdXAueDtcclxuICAgICAgICB2YXIgdjQyeT1zdXAueTtcclxuICAgICAgICB2YXIgdjQyej1zdXAuejtcclxuICAgICAgICB2YXIgdjR4PXY0MngtdjQxeDtcclxuICAgICAgICB2YXIgdjR5PXY0MnktdjQxeTtcclxuICAgICAgICB2YXIgdjR6PXY0MnotdjQxejtcclxuICAgICAgICB2YXIgc2VwYXJhdGlvbj0tKHY0eCpueCt2NHkqbnkrdjR6Km56KTtcclxuICAgICAgICBpZigodjR4LXYzeCkqbngrKHY0eS12M3kpKm55Kyh2NHotdjN6KSpuejw9MC4wMXx8c2VwYXJhdGlvbj49MCl7XHJcbiAgICAgICAgaWYoaGl0KXtcclxuICAgICAgICBzZXAuc2V0KCAtbngsIC1ueSwgLW56ICk7XHJcbiAgICAgICAgcG9zLnNldCggKHAxeCtwMngpKjAuNSwgKHAxeStwMnkpKjAuNSwgKHAxeitwMnopKjAuNSApO1xyXG4gICAgICAgIGRlcC54PXNlcGFyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoXHJcbiAgICAgICAgKHY0eSp2MXotdjR6KnYxeSkqdjB4K1xyXG4gICAgICAgICh2NHoqdjF4LXY0eCp2MXopKnYweStcclxuICAgICAgICAodjR4KnYxeS12NHkqdjF4KSp2MHo8MFxyXG4gICAgICAgICl7XHJcbiAgICAgICAgaWYoXHJcbiAgICAgICAgKHY0eSp2MnotdjR6KnYyeSkqdjB4K1xyXG4gICAgICAgICh2NHoqdjJ4LXY0eCp2MnopKnYweStcclxuICAgICAgICAodjR4KnYyeS12NHkqdjJ4KSp2MHo8MFxyXG4gICAgICAgICl7XHJcbiAgICAgICAgdjF4PXY0eDtcclxuICAgICAgICB2MXk9djR5O1xyXG4gICAgICAgIHYxej12NHo7XHJcbiAgICAgICAgdjExeD12NDF4O1xyXG4gICAgICAgIHYxMXk9djQxeTtcclxuICAgICAgICB2MTF6PXY0MXo7XHJcbiAgICAgICAgdjEyeD12NDJ4O1xyXG4gICAgICAgIHYxMnk9djQyeTtcclxuICAgICAgICB2MTJ6PXY0Mno7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgdjN4PXY0eDtcclxuICAgICAgICB2M3k9djR5O1xyXG4gICAgICAgIHYzej12NHo7XHJcbiAgICAgICAgdjMxeD12NDF4O1xyXG4gICAgICAgIHYzMXk9djQxeTtcclxuICAgICAgICB2MzF6PXY0MXo7XHJcbiAgICAgICAgdjMyeD12NDJ4O1xyXG4gICAgICAgIHYzMnk9djQyeTtcclxuICAgICAgICB2MzJ6PXY0Mno7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgIGlmKFxyXG4gICAgICAgICh2NHkqdjN6LXY0eip2M3kpKnYweCtcclxuICAgICAgICAodjR6KnYzeC12NHgqdjN6KSp2MHkrXHJcbiAgICAgICAgKHY0eCp2M3ktdjR5KnYzeCkqdjB6PDBcclxuICAgICAgICApe1xyXG4gICAgICAgIHYyeD12NHg7XHJcbiAgICAgICAgdjJ5PXY0eTtcclxuICAgICAgICB2Mno9djR6O1xyXG4gICAgICAgIHYyMXg9djQxeDtcclxuICAgICAgICB2MjF5PXY0MXk7XHJcbiAgICAgICAgdjIxej12NDF6O1xyXG4gICAgICAgIHYyMng9djQyeDtcclxuICAgICAgICB2MjJ5PXY0Mnk7XHJcbiAgICAgICAgdjIyej12NDJ6O1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgIHYxeD12NHg7XHJcbiAgICAgICAgdjF5PXY0eTtcclxuICAgICAgICB2MXo9djR6O1xyXG4gICAgICAgIHYxMXg9djQxeDtcclxuICAgICAgICB2MTF5PXY0MXk7XHJcbiAgICAgICAgdjExej12NDF6O1xyXG4gICAgICAgIHYxMng9djQyeDtcclxuICAgICAgICB2MTJ5PXY0Mnk7XHJcbiAgICAgICAgdjEyej12NDJ6O1xyXG4gICAgfVxyXG4gICAgfVxyXG4gICAgfVxyXG4gICAgfVxyXG4gICAgLy9yZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHN1cHBvcnRQb2ludEI6IGZ1bmN0aW9uKCBjLCBkeCwgZHksIGR6LCBvdXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByb3Q9Yy5yb3RhdGlvbi5lbGVtZW50cztcclxuICAgICAgICB2YXIgbGR4PXJvdFswXSpkeCtyb3RbM10qZHkrcm90WzZdKmR6O1xyXG4gICAgICAgIHZhciBsZHk9cm90WzFdKmR4K3JvdFs0XSpkeStyb3RbN10qZHo7XHJcbiAgICAgICAgdmFyIGxkej1yb3RbMl0qZHgrcm90WzVdKmR5K3JvdFs4XSpkejtcclxuICAgICAgICB2YXIgdz1jLmhhbGZXaWR0aDtcclxuICAgICAgICB2YXIgaD1jLmhhbGZIZWlnaHQ7XHJcbiAgICAgICAgdmFyIGQ9Yy5oYWxmRGVwdGg7XHJcbiAgICAgICAgdmFyIG94O1xyXG4gICAgICAgIHZhciBveTtcclxuICAgICAgICB2YXIgb3o7XHJcbiAgICAgICAgaWYobGR4PDApb3g9LXc7XHJcbiAgICAgICAgZWxzZSBveD13O1xyXG4gICAgICAgIGlmKGxkeTwwKW95PS1oO1xyXG4gICAgICAgIGVsc2Ugb3k9aDtcclxuICAgICAgICBpZihsZHo8MClvej0tZDtcclxuICAgICAgICBlbHNlIG96PWQ7XHJcbiAgICAgICAgbGR4PXJvdFswXSpveCtyb3RbMV0qb3krcm90WzJdKm96K2MucG9zaXRpb24ueDtcclxuICAgICAgICBsZHk9cm90WzNdKm94K3JvdFs0XSpveStyb3RbNV0qb3orYy5wb3NpdGlvbi55O1xyXG4gICAgICAgIGxkej1yb3RbNl0qb3grcm90WzddKm95K3JvdFs4XSpveitjLnBvc2l0aW9uLno7XHJcbiAgICAgICAgb3V0LnNldCggbGR4LCBsZHksIGxkeiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3VwcG9ydFBvaW50QzogZnVuY3Rpb24gKCBjLCBkeCwgZHksIGR6LCBvdXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByb3Q9Yy5yb3RhdGlvbi5lbGVtZW50cztcclxuICAgICAgICB2YXIgbGR4PXJvdFswXSpkeCtyb3RbM10qZHkrcm90WzZdKmR6O1xyXG4gICAgICAgIHZhciBsZHk9cm90WzFdKmR4K3JvdFs0XSpkeStyb3RbN10qZHo7XHJcbiAgICAgICAgdmFyIGxkej1yb3RbMl0qZHgrcm90WzVdKmR5K3JvdFs4XSpkejtcclxuICAgICAgICB2YXIgcmFkeD1sZHg7XHJcbiAgICAgICAgdmFyIHJhZHo9bGR6O1xyXG4gICAgICAgIHZhciBsZW49cmFkeCpyYWR4K3JhZHoqcmFkejtcclxuICAgICAgICB2YXIgcmFkPWMucmFkaXVzO1xyXG4gICAgICAgIHZhciBoaD1jLmhhbGZIZWlnaHQ7XHJcbiAgICAgICAgdmFyIG94O1xyXG4gICAgICAgIHZhciBveTtcclxuICAgICAgICB2YXIgb3o7XHJcbiAgICAgICAgaWYobGVuPT0wKXtcclxuICAgICAgICBpZihsZHk8MCl7XHJcbiAgICAgICAgb3g9cmFkO1xyXG4gICAgICAgIG95PS1oaDtcclxuICAgICAgICBvej0wO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgIG94PXJhZDtcclxuICAgICAgICBveT1oaDtcclxuICAgICAgICBvej0wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBsZW49Yy5yYWRpdXMvX01hdGguc3FydChsZW4pO1xyXG4gICAgICAgIGlmKGxkeTwwKXtcclxuICAgICAgICBveD1yYWR4KmxlbjtcclxuICAgICAgICBveT0taGg7XHJcbiAgICAgICAgb3o9cmFkeipsZW47XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgb3g9cmFkeCpsZW47XHJcbiAgICAgICAgb3k9aGg7XHJcbiAgICAgICAgb3o9cmFkeipsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZHg9cm90WzBdKm94K3JvdFsxXSpveStyb3RbMl0qb3orYy5wb3NpdGlvbi54O1xyXG4gICAgICAgIGxkeT1yb3RbM10qb3grcm90WzRdKm95K3JvdFs1XSpveitjLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgbGR6PXJvdFs2XSpveCtyb3RbN10qb3krcm90WzhdKm96K2MucG9zaXRpb24uejtcclxuICAgICAgICBvdXQuc2V0KCBsZHgsIGxkeSwgbGR6ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZXRlY3RDb2xsaXNpb246IGZ1bmN0aW9uKCBzaGFwZTEsIHNoYXBlMiwgbWFuaWZvbGQgKSB7XHJcblxyXG4gICAgICAgIHZhciBiO1xyXG4gICAgICAgIHZhciBjO1xyXG4gICAgICAgIGlmKHRoaXMuZmxpcCl7XHJcbiAgICAgICAgYj1zaGFwZTI7XHJcbiAgICAgICAgYz1zaGFwZTE7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgYj1zaGFwZTE7XHJcbiAgICAgICAgYz1zaGFwZTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZXA9bmV3IFZlYzMoKTtcclxuICAgICAgICB2YXIgcG9zPW5ldyBWZWMzKCk7XHJcbiAgICAgICAgdmFyIGRlcD1uZXcgVmVjMygpO1xyXG5cclxuICAgICAgICBpZighdGhpcy5nZXRTZXAoYixjLHNlcCxwb3MsZGVwKSlyZXR1cm47XHJcbiAgICAgICAgdmFyIHBieD1iLnBvc2l0aW9uLng7XHJcbiAgICAgICAgdmFyIHBieT1iLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgdmFyIHBiej1iLnBvc2l0aW9uLno7XHJcbiAgICAgICAgdmFyIHBjeD1jLnBvc2l0aW9uLng7XHJcbiAgICAgICAgdmFyIHBjeT1jLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgdmFyIHBjej1jLnBvc2l0aW9uLno7XHJcbiAgICAgICAgdmFyIGJ3PWIuaGFsZldpZHRoO1xyXG4gICAgICAgIHZhciBiaD1iLmhhbGZIZWlnaHQ7XHJcbiAgICAgICAgdmFyIGJkPWIuaGFsZkRlcHRoO1xyXG4gICAgICAgIHZhciBjaD1jLmhhbGZIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHI9Yy5yYWRpdXM7XHJcblxyXG4gICAgICAgIHZhciBEID0gYi5kaW1lbnRpb25zO1xyXG5cclxuICAgICAgICB2YXIgbnd4PURbMF07Ly9iLm5vcm1hbERpcmVjdGlvbldpZHRoLng7XHJcbiAgICAgICAgdmFyIG53eT1EWzFdOy8vYi5ub3JtYWxEaXJlY3Rpb25XaWR0aC55O1xyXG4gICAgICAgIHZhciBud3o9RFsyXTsvL2Iubm9ybWFsRGlyZWN0aW9uV2lkdGguejtcclxuICAgICAgICB2YXIgbmh4PURbM107Ly9iLm5vcm1hbERpcmVjdGlvbkhlaWdodC54O1xyXG4gICAgICAgIHZhciBuaHk9RFs0XTsvL2Iubm9ybWFsRGlyZWN0aW9uSGVpZ2h0Lnk7XHJcbiAgICAgICAgdmFyIG5oej1EWzVdOy8vYi5ub3JtYWxEaXJlY3Rpb25IZWlnaHQuejtcclxuICAgICAgICB2YXIgbmR4PURbNl07Ly9iLm5vcm1hbERpcmVjdGlvbkRlcHRoLng7XHJcbiAgICAgICAgdmFyIG5keT1EWzddOy8vYi5ub3JtYWxEaXJlY3Rpb25EZXB0aC55O1xyXG4gICAgICAgIHZhciBuZHo9RFs4XTsvL2Iubm9ybWFsRGlyZWN0aW9uRGVwdGguejtcclxuXHJcbiAgICAgICAgdmFyIGR3eD1EWzldOy8vYi5oYWxmRGlyZWN0aW9uV2lkdGgueDtcclxuICAgICAgICB2YXIgZHd5PURbMTBdOy8vYi5oYWxmRGlyZWN0aW9uV2lkdGgueTtcclxuICAgICAgICB2YXIgZHd6PURbMTFdOy8vYi5oYWxmRGlyZWN0aW9uV2lkdGguejtcclxuICAgICAgICB2YXIgZGh4PURbMTJdOy8vYi5oYWxmRGlyZWN0aW9uSGVpZ2h0Lng7XHJcbiAgICAgICAgdmFyIGRoeT1EWzEzXTsvL2IuaGFsZkRpcmVjdGlvbkhlaWdodC55O1xyXG4gICAgICAgIHZhciBkaHo9RFsxNF07Ly9iLmhhbGZEaXJlY3Rpb25IZWlnaHQuejtcclxuICAgICAgICB2YXIgZGR4PURbMTVdOy8vYi5oYWxmRGlyZWN0aW9uRGVwdGgueDtcclxuICAgICAgICB2YXIgZGR5PURbMTZdOy8vYi5oYWxmRGlyZWN0aW9uRGVwdGgueTtcclxuICAgICAgICB2YXIgZGR6PURbMTddOy8vYi5oYWxmRGlyZWN0aW9uRGVwdGguejtcclxuXHJcbiAgICAgICAgdmFyIG5jeD1jLm5vcm1hbERpcmVjdGlvbi54O1xyXG4gICAgICAgIHZhciBuY3k9Yy5ub3JtYWxEaXJlY3Rpb24ueTtcclxuICAgICAgICB2YXIgbmN6PWMubm9ybWFsRGlyZWN0aW9uLno7XHJcbiAgICAgICAgdmFyIGRjeD1jLmhhbGZEaXJlY3Rpb24ueDtcclxuICAgICAgICB2YXIgZGN5PWMuaGFsZkRpcmVjdGlvbi55O1xyXG4gICAgICAgIHZhciBkY3o9Yy5oYWxmRGlyZWN0aW9uLno7XHJcbiAgICAgICAgdmFyIG54PXNlcC54O1xyXG4gICAgICAgIHZhciBueT1zZXAueTtcclxuICAgICAgICB2YXIgbno9c2VwLno7XHJcbiAgICAgICAgdmFyIGRvdHc9bngqbnd4K255Km53eStueipud3o7XHJcbiAgICAgICAgdmFyIGRvdGg9bngqbmh4K255Km5oeStueipuaHo7XHJcbiAgICAgICAgdmFyIGRvdGQ9bngqbmR4K255Km5keStueipuZHo7XHJcbiAgICAgICAgdmFyIGRvdGM9bngqbmN4K255Km5jeStueipuY3o7XHJcbiAgICAgICAgdmFyIHJpZ2h0MT1kb3R3PjA7XHJcbiAgICAgICAgdmFyIHJpZ2h0Mj1kb3RoPjA7XHJcbiAgICAgICAgdmFyIHJpZ2h0Mz1kb3RkPjA7XHJcbiAgICAgICAgdmFyIHJpZ2h0ND1kb3RjPjA7XHJcbiAgICAgICAgaWYoIXJpZ2h0MSlkb3R3PS1kb3R3O1xyXG4gICAgICAgIGlmKCFyaWdodDIpZG90aD0tZG90aDtcclxuICAgICAgICBpZighcmlnaHQzKWRvdGQ9LWRvdGQ7XHJcbiAgICAgICAgaWYoIXJpZ2h0NClkb3RjPS1kb3RjO1xyXG4gICAgICAgIHZhciBzdGF0ZT0wO1xyXG4gICAgICAgIGlmKGRvdGM+MC45OTkpe1xyXG4gICAgICAgIGlmKGRvdHc+MC45OTkpe1xyXG4gICAgICAgIGlmKGRvdHc+ZG90YylzdGF0ZT0xO1xyXG4gICAgICAgIGVsc2Ugc3RhdGU9NDtcclxuICAgICAgICB9ZWxzZSBpZihkb3RoPjAuOTk5KXtcclxuICAgICAgICBpZihkb3RoPmRvdGMpc3RhdGU9MjtcclxuICAgICAgICBlbHNlIHN0YXRlPTQ7XHJcbiAgICAgICAgfWVsc2UgaWYoZG90ZD4wLjk5OSl7XHJcbiAgICAgICAgaWYoZG90ZD5kb3RjKXN0YXRlPTM7XHJcbiAgICAgICAgZWxzZSBzdGF0ZT00O1xyXG4gICAgICAgIH1lbHNlIHN0YXRlPTQ7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgaWYoZG90dz4wLjk5OSlzdGF0ZT0xO1xyXG4gICAgICAgIGVsc2UgaWYoZG90aD4wLjk5OSlzdGF0ZT0yO1xyXG4gICAgICAgIGVsc2UgaWYoZG90ZD4wLjk5OSlzdGF0ZT0zO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2J4O1xyXG4gICAgICAgIHZhciBjYnk7XHJcbiAgICAgICAgdmFyIGNiejtcclxuICAgICAgICB2YXIgY2N4O1xyXG4gICAgICAgIHZhciBjY3k7XHJcbiAgICAgICAgdmFyIGNjejtcclxuICAgICAgICB2YXIgcjAwO1xyXG4gICAgICAgIHZhciByMDE7XHJcbiAgICAgICAgdmFyIHIwMjtcclxuICAgICAgICB2YXIgcjEwO1xyXG4gICAgICAgIHZhciByMTE7XHJcbiAgICAgICAgdmFyIHIxMjtcclxuICAgICAgICB2YXIgcjIwO1xyXG4gICAgICAgIHZhciByMjE7XHJcbiAgICAgICAgdmFyIHIyMjtcclxuICAgICAgICB2YXIgcHg7XHJcbiAgICAgICAgdmFyIHB5O1xyXG4gICAgICAgIHZhciBwejtcclxuICAgICAgICB2YXIgcGQ7XHJcbiAgICAgICAgdmFyIGRvdDtcclxuICAgICAgICB2YXIgbGVuO1xyXG4gICAgICAgIHZhciB0eDtcclxuICAgICAgICB2YXIgdHk7XHJcbiAgICAgICAgdmFyIHR6O1xyXG4gICAgICAgIHZhciB0ZDtcclxuICAgICAgICB2YXIgZHg7XHJcbiAgICAgICAgdmFyIGR5O1xyXG4gICAgICAgIHZhciBkejtcclxuICAgICAgICB2YXIgZDF4O1xyXG4gICAgICAgIHZhciBkMXk7XHJcbiAgICAgICAgdmFyIGQxejtcclxuICAgICAgICB2YXIgZDJ4O1xyXG4gICAgICAgIHZhciBkMnk7XHJcbiAgICAgICAgdmFyIGQyejtcclxuICAgICAgICB2YXIgc3g7XHJcbiAgICAgICAgdmFyIHN5O1xyXG4gICAgICAgIHZhciBzejtcclxuICAgICAgICB2YXIgc2Q7XHJcbiAgICAgICAgdmFyIGV4O1xyXG4gICAgICAgIHZhciBleTtcclxuICAgICAgICB2YXIgZXo7XHJcbiAgICAgICAgdmFyIGVkO1xyXG4gICAgICAgIHZhciBkb3QxO1xyXG4gICAgICAgIHZhciBkb3QyO1xyXG4gICAgICAgIHZhciB0MTtcclxuICAgICAgICB2YXIgZGlyMXg7XHJcbiAgICAgICAgdmFyIGRpcjF5O1xyXG4gICAgICAgIHZhciBkaXIxejtcclxuICAgICAgICB2YXIgZGlyMng7XHJcbiAgICAgICAgdmFyIGRpcjJ5O1xyXG4gICAgICAgIHZhciBkaXIyejtcclxuICAgICAgICB2YXIgZGlyMWw7XHJcbiAgICAgICAgdmFyIGRpcjJsO1xyXG4gICAgICAgIGlmKHN0YXRlPT0wKXtcclxuICAgICAgICAvL21hbmlmb2xkLmFkZFBvaW50KHBvcy54LHBvcy55LHBvcy56LG54LG55LG56LGRlcC54LGIsYywwLDAsZmFsc2UpO1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHBvcy54LHBvcy55LHBvcy56LG54LG55LG56LGRlcC54LHRoaXMuZmxpcCk7XHJcbiAgICAgICAgfWVsc2UgaWYoc3RhdGU9PTQpe1xyXG4gICAgICAgIGlmKHJpZ2h0NCl7XHJcbiAgICAgICAgY2N4PXBjeC1kY3g7XHJcbiAgICAgICAgY2N5PXBjeS1kY3k7XHJcbiAgICAgICAgY2N6PXBjei1kY3o7XHJcbiAgICAgICAgbng9LW5jeDtcclxuICAgICAgICBueT0tbmN5O1xyXG4gICAgICAgIG56PS1uY3o7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgY2N4PXBjeCtkY3g7XHJcbiAgICAgICAgY2N5PXBjeStkY3k7XHJcbiAgICAgICAgY2N6PXBjeitkY3o7XHJcbiAgICAgICAgbng9bmN4O1xyXG4gICAgICAgIG55PW5jeTtcclxuICAgICAgICBuej1uY3o7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2MXg7XHJcbiAgICAgICAgdmFyIHYxeTtcclxuICAgICAgICB2YXIgdjF6O1xyXG4gICAgICAgIHZhciB2Mng7XHJcbiAgICAgICAgdmFyIHYyeTtcclxuICAgICAgICB2YXIgdjJ6O1xyXG4gICAgICAgIHZhciB2M3g7XHJcbiAgICAgICAgdmFyIHYzeTtcclxuICAgICAgICB2YXIgdjN6O1xyXG4gICAgICAgIHZhciB2NHg7XHJcbiAgICAgICAgdmFyIHY0eTtcclxuICAgICAgICB2YXIgdjR6O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGRvdD0xO1xyXG4gICAgICAgIHN0YXRlPTA7XHJcbiAgICAgICAgZG90MT1ud3gqbngrbnd5Km55K253eipuejtcclxuICAgICAgICBpZihkb3QxPGRvdCl7XHJcbiAgICAgICAgZG90PWRvdDE7XHJcbiAgICAgICAgc3RhdGU9MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoLWRvdDE8ZG90KXtcclxuICAgICAgICBkb3Q9LWRvdDE7XHJcbiAgICAgICAgc3RhdGU9MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG90MT1uaHgqbngrbmh5Km55K25oeipuejtcclxuICAgICAgICBpZihkb3QxPGRvdCl7XHJcbiAgICAgICAgZG90PWRvdDE7XHJcbiAgICAgICAgc3RhdGU9MjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoLWRvdDE8ZG90KXtcclxuICAgICAgICBkb3Q9LWRvdDE7XHJcbiAgICAgICAgc3RhdGU9MztcclxuICAgICAgICB9XHJcbiAgICAgICAgZG90MT1uZHgqbngrbmR5Km55K25keipuejtcclxuICAgICAgICBpZihkb3QxPGRvdCl7XHJcbiAgICAgICAgZG90PWRvdDE7XHJcbiAgICAgICAgc3RhdGU9NDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoLWRvdDE8ZG90KXtcclxuICAgICAgICBkb3Q9LWRvdDE7XHJcbiAgICAgICAgc3RhdGU9NTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHYgPSBiLmVsZW1lbnRzO1xyXG4gICAgICAgIHN3aXRjaChzdGF0ZSl7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgIC8vdj1iLnZlcnRleDE7XHJcbiAgICAgICAgdjF4PXZbMF07Ly92Lng7XHJcbiAgICAgICAgdjF5PXZbMV07Ly92Lnk7XHJcbiAgICAgICAgdjF6PXZbMl07Ly92Lno7XHJcbiAgICAgICAgLy92PWIudmVydGV4MztcclxuICAgICAgICB2Mng9dls2XTsvL3YueDtcclxuICAgICAgICB2Mnk9dls3XTsvL3YueTtcclxuICAgICAgICB2Mno9dls4XTsvL3YuejtcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXg0O1xyXG4gICAgICAgIHYzeD12WzldOy8vdi54O1xyXG4gICAgICAgIHYzeT12WzEwXTsvL3YueTtcclxuICAgICAgICB2M3o9dlsxMV07Ly92Lno7XHJcbiAgICAgICAgLy92PWIudmVydGV4MjtcclxuICAgICAgICB2NHg9dlszXTsvL3YueDtcclxuICAgICAgICB2NHk9dls0XTsvL3YueTtcclxuICAgICAgICB2NHo9dls1XTsvL3YuejtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgLy92PWIudmVydGV4NjtcclxuICAgICAgICB2MXg9dlsxNV07Ly92Lng7XHJcbiAgICAgICAgdjF5PXZbMTZdOy8vdi55O1xyXG4gICAgICAgIHYxej12WzE3XTsvL3YuejtcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXg4O1xyXG4gICAgICAgIHYyeD12WzIxXTsvL3YueDtcclxuICAgICAgICB2Mnk9dlsyMl07Ly92Lnk7XHJcbiAgICAgICAgdjJ6PXZbMjNdOy8vdi56O1xyXG4gICAgICAgIC8vdj1iLnZlcnRleDc7XHJcbiAgICAgICAgdjN4PXZbMThdOy8vdi54O1xyXG4gICAgICAgIHYzeT12WzE5XTsvL3YueTtcclxuICAgICAgICB2M3o9dlsyMF07Ly92Lno7XHJcbiAgICAgICAgLy92PWIudmVydGV4NTtcclxuICAgICAgICB2NHg9dlsxMl07Ly92Lng7XHJcbiAgICAgICAgdjR5PXZbMTNdOy8vdi55O1xyXG4gICAgICAgIHY0ej12WzE0XTsvL3YuejtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgLy92PWIudmVydGV4NTtcclxuICAgICAgICB2MXg9dlsxMl07Ly92Lng7XHJcbiAgICAgICAgdjF5PXZbMTNdOy8vdi55O1xyXG4gICAgICAgIHYxej12WzE0XTsvL3YuejtcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXgxO1xyXG4gICAgICAgIHYyeD12WzBdOy8vdi54O1xyXG4gICAgICAgIHYyeT12WzFdOy8vdi55O1xyXG4gICAgICAgIHYyej12WzJdOy8vdi56O1xyXG4gICAgICAgIC8vdj1iLnZlcnRleDI7XHJcbiAgICAgICAgdjN4PXZbM107Ly92Lng7XHJcbiAgICAgICAgdjN5PXZbNF07Ly92Lnk7XHJcbiAgICAgICAgdjN6PXZbNV07Ly92Lno7XHJcbiAgICAgICAgLy92PWIudmVydGV4NjtcclxuICAgICAgICB2NHg9dlsxNV07Ly92Lng7XHJcbiAgICAgICAgdjR5PXZbMTZdOy8vdi55O1xyXG4gICAgICAgIHY0ej12WzE3XTsvL3YuejtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgLy92PWIudmVydGV4ODtcclxuICAgICAgICB2MXg9dlsyMV07Ly92Lng7XHJcbiAgICAgICAgdjF5PXZbMjJdOy8vdi55O1xyXG4gICAgICAgIHYxej12WzIzXTsvL3YuejtcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXg0O1xyXG4gICAgICAgIHYyeD12WzldOy8vdi54O1xyXG4gICAgICAgIHYyeT12WzEwXTsvL3YueTtcclxuICAgICAgICB2Mno9dlsxMV07Ly92Lno7XHJcbiAgICAgICAgLy92PWIudmVydGV4MztcclxuICAgICAgICB2M3g9dls2XTsvL3YueDtcclxuICAgICAgICB2M3k9dls3XTsvL3YueTtcclxuICAgICAgICB2M3o9dls4XTsvL3YuejtcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXg3O1xyXG4gICAgICAgIHY0eD12WzE4XTsvL3YueDtcclxuICAgICAgICB2NHk9dlsxOV07Ly92Lnk7XHJcbiAgICAgICAgdjR6PXZbMjBdOy8vdi56O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXg1O1xyXG4gICAgICAgIHYxeD12WzEyXTsvL3YueDtcclxuICAgICAgICB2MXk9dlsxM107Ly92Lnk7XHJcbiAgICAgICAgdjF6PXZbMTRdOy8vdi56O1xyXG4gICAgICAgIC8vdj1iLnZlcnRleDc7XHJcbiAgICAgICAgdjJ4PXZbMThdOy8vdi54O1xyXG4gICAgICAgIHYyeT12WzE5XTsvL3YueTtcclxuICAgICAgICB2Mno9dlsyMF07Ly92Lno7XHJcbiAgICAgICAgLy92PWIudmVydGV4MztcclxuICAgICAgICB2M3g9dls2XTsvL3YueDtcclxuICAgICAgICB2M3k9dls3XTsvL3YueTtcclxuICAgICAgICB2M3o9dls4XTsvL3YuejtcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXgxO1xyXG4gICAgICAgIHY0eD12WzBdOy8vdi54O1xyXG4gICAgICAgIHY0eT12WzFdOy8vdi55O1xyXG4gICAgICAgIHY0ej12WzJdOy8vdi56O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXgyO1xyXG4gICAgICAgIHYxeD12WzNdOy8vdi54O1xyXG4gICAgICAgIHYxeT12WzRdOy8vdi55O1xyXG4gICAgICAgIHYxej12WzVdOy8vdi56O1xyXG4gICAgICAgIC8vdj1iLnZlcnRleDQ7XHJcbiAgICAgICAgdjJ4PXZbOV07Ly92Lng7XHJcbiAgICAgICAgdjJ5PXZbMTBdOy8vdi55O1xyXG4gICAgICAgIHYyej12WzExXTsvL3YuejtcclxuICAgICAgICAvL3Y9Yi52ZXJ0ZXg4O1xyXG4gICAgICAgIHYzeD12WzIxXTsvL3YueDtcclxuICAgICAgICB2M3k9dlsyMl07Ly92Lnk7XHJcbiAgICAgICAgdjN6PXZbMjNdOy8vdi56O1xyXG4gICAgICAgIC8vdj1iLnZlcnRleDY7XHJcbiAgICAgICAgdjR4PXZbMTVdOy8vdi54O1xyXG4gICAgICAgIHY0eT12WzE2XTsvL3YueTtcclxuICAgICAgICB2NHo9dlsxN107Ly92Lno7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBkPW54Kih2MXgtY2N4KStueSoodjF5LWNjeSkrbnoqKHYxei1jY3opO1xyXG4gICAgICAgIGlmKHBkPD0wKW1hbmlmb2xkLmFkZFBvaW50KHYxeCx2MXksdjF6LC1ueCwtbnksLW56LHBkLHRoaXMuZmxpcCk7XHJcbiAgICAgICAgcGQ9bngqKHYyeC1jY3gpK255Kih2MnktY2N5KStueioodjJ6LWNjeik7XHJcbiAgICAgICAgaWYocGQ8PTApbWFuaWZvbGQuYWRkUG9pbnQodjJ4LHYyeSx2MnosLW54LC1ueSwtbnoscGQsdGhpcy5mbGlwKTtcclxuICAgICAgICBwZD1ueCoodjN4LWNjeCkrbnkqKHYzeS1jY3kpK256Kih2M3otY2N6KTtcclxuICAgICAgICBpZihwZDw9MCltYW5pZm9sZC5hZGRQb2ludCh2M3gsdjN5LHYzeiwtbngsLW55LC1ueixwZCx0aGlzLmZsaXApO1xyXG4gICAgICAgIHBkPW54Kih2NHgtY2N4KStueSoodjR5LWNjeSkrbnoqKHY0ei1jY3opO1xyXG4gICAgICAgIGlmKHBkPD0wKW1hbmlmb2xkLmFkZFBvaW50KHY0eCx2NHksdjR6LC1ueCwtbnksLW56LHBkLHRoaXMuZmxpcCk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgc3dpdGNoKHN0YXRlKXtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgaWYocmlnaHQxKXtcclxuICAgICAgICBjYng9cGJ4K2R3eDtcclxuICAgICAgICBjYnk9cGJ5K2R3eTtcclxuICAgICAgICBjYno9cGJ6K2R3ejtcclxuICAgICAgICBueD1ud3g7XHJcbiAgICAgICAgbnk9bnd5O1xyXG4gICAgICAgIG56PW53ejtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBjYng9cGJ4LWR3eDtcclxuICAgICAgICBjYnk9cGJ5LWR3eTtcclxuICAgICAgICBjYno9cGJ6LWR3ejtcclxuICAgICAgICBueD0tbnd4O1xyXG4gICAgICAgIG55PS1ud3k7XHJcbiAgICAgICAgbno9LW53ejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlyMXg9bmh4O1xyXG4gICAgICAgIGRpcjF5PW5oeTtcclxuICAgICAgICBkaXIxej1uaHo7XHJcbiAgICAgICAgZGlyMWw9Ymg7XHJcbiAgICAgICAgZGlyMng9bmR4O1xyXG4gICAgICAgIGRpcjJ5PW5keTtcclxuICAgICAgICBkaXIyej1uZHo7XHJcbiAgICAgICAgZGlyMmw9YmQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGlmKHJpZ2h0Mil7XHJcbiAgICAgICAgY2J4PXBieCtkaHg7XHJcbiAgICAgICAgY2J5PXBieStkaHk7XHJcbiAgICAgICAgY2J6PXBieitkaHo7XHJcbiAgICAgICAgbng9bmh4O1xyXG4gICAgICAgIG55PW5oeTtcclxuICAgICAgICBuej1uaHo7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgY2J4PXBieC1kaHg7XHJcbiAgICAgICAgY2J5PXBieS1kaHk7XHJcbiAgICAgICAgY2J6PXBiei1kaHo7XHJcbiAgICAgICAgbng9LW5oeDtcclxuICAgICAgICBueT0tbmh5O1xyXG4gICAgICAgIG56PS1uaHo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpcjF4PW53eDtcclxuICAgICAgICBkaXIxeT1ud3k7XHJcbiAgICAgICAgZGlyMXo9bnd6O1xyXG4gICAgICAgIGRpcjFsPWJ3O1xyXG4gICAgICAgIGRpcjJ4PW5keDtcclxuICAgICAgICBkaXIyeT1uZHk7XHJcbiAgICAgICAgZGlyMno9bmR6O1xyXG4gICAgICAgIGRpcjJsPWJkO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICBpZihyaWdodDMpe1xyXG4gICAgICAgIGNieD1wYngrZGR4O1xyXG4gICAgICAgIGNieT1wYnkrZGR5O1xyXG4gICAgICAgIGNiej1wYnorZGR6O1xyXG4gICAgICAgIG54PW5keDtcclxuICAgICAgICBueT1uZHk7XHJcbiAgICAgICAgbno9bmR6O1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgIGNieD1wYngtZGR4O1xyXG4gICAgICAgIGNieT1wYnktZGR5O1xyXG4gICAgICAgIGNiej1wYnotZGR6O1xyXG4gICAgICAgIG54PS1uZHg7XHJcbiAgICAgICAgbnk9LW5keTtcclxuICAgICAgICBuej0tbmR6O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXIxeD1ud3g7XHJcbiAgICAgICAgZGlyMXk9bnd5O1xyXG4gICAgICAgIGRpcjF6PW53ejtcclxuICAgICAgICBkaXIxbD1idztcclxuICAgICAgICBkaXIyeD1uaHg7XHJcbiAgICAgICAgZGlyMnk9bmh5O1xyXG4gICAgICAgIGRpcjJ6PW5oejtcclxuICAgICAgICBkaXIybD1iaDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZG90PW54Km5jeCtueSpuY3krbnoqbmN6O1xyXG4gICAgICAgIGlmKGRvdDwwKWxlbj1jaDtcclxuICAgICAgICBlbHNlIGxlbj0tY2g7XHJcbiAgICAgICAgY2N4PXBjeCtsZW4qbmN4O1xyXG4gICAgICAgIGNjeT1wY3krbGVuKm5jeTtcclxuICAgICAgICBjY3o9cGN6K2xlbipuY3o7XHJcbiAgICAgICAgaWYoZG90Yz49MC45OTk5OTkpe1xyXG4gICAgICAgIHR4PS1ueTtcclxuICAgICAgICB0eT1uejtcclxuICAgICAgICB0ej1ueDtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICB0eD1ueDtcclxuICAgICAgICB0eT1ueTtcclxuICAgICAgICB0ej1uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVuPXR4Km5jeCt0eSpuY3krdHoqbmN6O1xyXG4gICAgICAgIGR4PWxlbipuY3gtdHg7XHJcbiAgICAgICAgZHk9bGVuKm5jeS10eTtcclxuICAgICAgICBkej1sZW4qbmN6LXR6O1xyXG4gICAgICAgIGxlbj1fTWF0aC5zcXJ0KGR4KmR4K2R5KmR5K2R6KmR6KTtcclxuICAgICAgICBpZihsZW49PTApcmV0dXJuO1xyXG4gICAgICAgIGxlbj1yL2xlbjtcclxuICAgICAgICBkeCo9bGVuO1xyXG4gICAgICAgIGR5Kj1sZW47XHJcbiAgICAgICAgZHoqPWxlbjtcclxuICAgICAgICB0eD1jY3grZHg7XHJcbiAgICAgICAgdHk9Y2N5K2R5O1xyXG4gICAgICAgIHR6PWNjeitkejtcclxuICAgICAgICBpZihkb3Q8LTAuOTZ8fGRvdD4wLjk2KXtcclxuICAgICAgICByMDA9bmN4Km5jeCoxLjUtMC41O1xyXG4gICAgICAgIHIwMT1uY3gqbmN5KjEuNS1uY3oqMC44NjYwMjU0MDM7XHJcbiAgICAgICAgcjAyPW5jeCpuY3oqMS41K25jeSowLjg2NjAyNTQwMztcclxuICAgICAgICByMTA9bmN5Km5jeCoxLjUrbmN6KjAuODY2MDI1NDAzO1xyXG4gICAgICAgIHIxMT1uY3kqbmN5KjEuNS0wLjU7XHJcbiAgICAgICAgcjEyPW5jeSpuY3oqMS41LW5jeCowLjg2NjAyNTQwMztcclxuICAgICAgICByMjA9bmN6Km5jeCoxLjUtbmN5KjAuODY2MDI1NDAzO1xyXG4gICAgICAgIHIyMT1uY3oqbmN5KjEuNStuY3gqMC44NjYwMjU0MDM7XHJcbiAgICAgICAgcjIyPW5jeipuY3oqMS41LTAuNTtcclxuICAgICAgICBweD10eDtcclxuICAgICAgICBweT10eTtcclxuICAgICAgICBwej10ejtcclxuICAgICAgICBwZD1ueCoocHgtY2J4KStueSoocHktY2J5KStueioocHotY2J6KTtcclxuICAgICAgICB0eD1weC1wZCpueC1jYng7XHJcbiAgICAgICAgdHk9cHktcGQqbnktY2J5O1xyXG4gICAgICAgIHR6PXB6LXBkKm56LWNiejtcclxuICAgICAgICBzZD1kaXIxeCp0eCtkaXIxeSp0eStkaXIxeip0ejtcclxuICAgICAgICBlZD1kaXIyeCp0eCtkaXIyeSp0eStkaXIyeip0ejtcclxuICAgICAgICBpZihzZDwtZGlyMWwpc2Q9LWRpcjFsO1xyXG4gICAgICAgIGVsc2UgaWYoc2Q+ZGlyMWwpc2Q9ZGlyMWw7XHJcbiAgICAgICAgaWYoZWQ8LWRpcjJsKWVkPS1kaXIybDtcclxuICAgICAgICBlbHNlIGlmKGVkPmRpcjJsKWVkPWRpcjJsO1xyXG4gICAgICAgIHR4PXNkKmRpcjF4K2VkKmRpcjJ4O1xyXG4gICAgICAgIHR5PXNkKmRpcjF5K2VkKmRpcjJ5O1xyXG4gICAgICAgIHR6PXNkKmRpcjF6K2VkKmRpcjJ6O1xyXG4gICAgICAgIHB4PWNieCt0eDtcclxuICAgICAgICBweT1jYnkrdHk7XHJcbiAgICAgICAgcHo9Y2J6K3R6O1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHB4LHB5LHB6LG54LG55LG56LHBkLHRoaXMuZmxpcCk7XHJcbiAgICAgICAgcHg9ZHgqcjAwK2R5KnIwMStkeipyMDI7XHJcbiAgICAgICAgcHk9ZHgqcjEwK2R5KnIxMStkeipyMTI7XHJcbiAgICAgICAgcHo9ZHgqcjIwK2R5KnIyMStkeipyMjI7XHJcbiAgICAgICAgcHg9KGR4PXB4KStjY3g7XHJcbiAgICAgICAgcHk9KGR5PXB5KStjY3k7XHJcbiAgICAgICAgcHo9KGR6PXB6KStjY3o7XHJcbiAgICAgICAgcGQ9bngqKHB4LWNieCkrbnkqKHB5LWNieSkrbnoqKHB6LWNieik7XHJcbiAgICAgICAgaWYocGQ8PTApe1xyXG4gICAgICAgIHR4PXB4LXBkKm54LWNieDtcclxuICAgICAgICB0eT1weS1wZCpueS1jYnk7XHJcbiAgICAgICAgdHo9cHotcGQqbnotY2J6O1xyXG4gICAgICAgIHNkPWRpcjF4KnR4K2RpcjF5KnR5K2RpcjF6KnR6O1xyXG4gICAgICAgIGVkPWRpcjJ4KnR4K2RpcjJ5KnR5K2RpcjJ6KnR6O1xyXG4gICAgICAgIGlmKHNkPC1kaXIxbClzZD0tZGlyMWw7XHJcbiAgICAgICAgZWxzZSBpZihzZD5kaXIxbClzZD1kaXIxbDtcclxuICAgICAgICBpZihlZDwtZGlyMmwpZWQ9LWRpcjJsO1xyXG4gICAgICAgIGVsc2UgaWYoZWQ+ZGlyMmwpZWQ9ZGlyMmw7XHJcbiAgICAgICAgdHg9c2QqZGlyMXgrZWQqZGlyMng7XHJcbiAgICAgICAgdHk9c2QqZGlyMXkrZWQqZGlyMnk7XHJcbiAgICAgICAgdHo9c2QqZGlyMXorZWQqZGlyMno7XHJcbiAgICAgICAgcHg9Y2J4K3R4O1xyXG4gICAgICAgIHB5PWNieSt0eTtcclxuICAgICAgICBwej1jYnordHo7XHJcbiAgICAgICAgLy9tYW5pZm9sZC5hZGRQb2ludChweCxweSxweixueCxueSxueixwZCxiLGMsMiwwLGZhbHNlKTtcclxuICAgICAgICBtYW5pZm9sZC5hZGRQb2ludChweCxweSxweixueCxueSxueixwZCx0aGlzLmZsaXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBweD1keCpyMDArZHkqcjAxK2R6KnIwMjtcclxuICAgICAgICBweT1keCpyMTArZHkqcjExK2R6KnIxMjtcclxuICAgICAgICBwej1keCpyMjArZHkqcjIxK2R6KnIyMjtcclxuICAgICAgICBweD0oZHg9cHgpK2NjeDtcclxuICAgICAgICBweT0oZHk9cHkpK2NjeTtcclxuICAgICAgICBwej0oZHo9cHopK2NjejtcclxuICAgICAgICBwZD1ueCoocHgtY2J4KStueSoocHktY2J5KStueioocHotY2J6KTtcclxuICAgICAgICBpZihwZDw9MCl7XHJcbiAgICAgICAgdHg9cHgtcGQqbngtY2J4O1xyXG4gICAgICAgIHR5PXB5LXBkKm55LWNieTtcclxuICAgICAgICB0ej1wei1wZCpuei1jYno7XHJcbiAgICAgICAgc2Q9ZGlyMXgqdHgrZGlyMXkqdHkrZGlyMXoqdHo7XHJcbiAgICAgICAgZWQ9ZGlyMngqdHgrZGlyMnkqdHkrZGlyMnoqdHo7XHJcbiAgICAgICAgaWYoc2Q8LWRpcjFsKXNkPS1kaXIxbDtcclxuICAgICAgICBlbHNlIGlmKHNkPmRpcjFsKXNkPWRpcjFsO1xyXG4gICAgICAgIGlmKGVkPC1kaXIybCllZD0tZGlyMmw7XHJcbiAgICAgICAgZWxzZSBpZihlZD5kaXIybCllZD1kaXIybDtcclxuICAgICAgICB0eD1zZCpkaXIxeCtlZCpkaXIyeDtcclxuICAgICAgICB0eT1zZCpkaXIxeStlZCpkaXIyeTtcclxuICAgICAgICB0ej1zZCpkaXIxeitlZCpkaXIyejtcclxuICAgICAgICBweD1jYngrdHg7XHJcbiAgICAgICAgcHk9Y2J5K3R5O1xyXG4gICAgICAgIHB6PWNieit0ejtcclxuICAgICAgICAvL21hbmlmb2xkLmFkZFBvaW50KHB4LHB5LHB6LG54LG55LG56LHBkLGIsYywzLDAsZmFsc2UpO1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHB4LHB5LHB6LG54LG55LG56LHBkLHRoaXMuZmxpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgIHN4PXR4O1xyXG4gICAgICAgIHN5PXR5O1xyXG4gICAgICAgIHN6PXR6O1xyXG4gICAgICAgIHNkPW54KihzeC1jYngpK255KihzeS1jYnkpK256Kihzei1jYnopO1xyXG4gICAgICAgIHN4LT1zZCpueDtcclxuICAgICAgICBzeS09c2Qqbnk7XHJcbiAgICAgICAgc3otPXNkKm56O1xyXG4gICAgICAgIGlmKGRvdD4wKXtcclxuICAgICAgICBleD10eCtkY3gqMjtcclxuICAgICAgICBleT10eStkY3kqMjtcclxuICAgICAgICBlej10eitkY3oqMjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBleD10eC1kY3gqMjtcclxuICAgICAgICBleT10eS1kY3kqMjtcclxuICAgICAgICBlej10ei1kY3oqMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWQ9bngqKGV4LWNieCkrbnkqKGV5LWNieSkrbnoqKGV6LWNieik7XHJcbiAgICAgICAgZXgtPWVkKm54O1xyXG4gICAgICAgIGV5LT1lZCpueTtcclxuICAgICAgICBlei09ZWQqbno7XHJcbiAgICAgICAgZDF4PXN4LWNieDtcclxuICAgICAgICBkMXk9c3ktY2J5O1xyXG4gICAgICAgIGQxej1zei1jYno7XHJcbiAgICAgICAgZDJ4PWV4LWNieDtcclxuICAgICAgICBkMnk9ZXktY2J5O1xyXG4gICAgICAgIGQyej1lei1jYno7XHJcbiAgICAgICAgdHg9ZXgtc3g7XHJcbiAgICAgICAgdHk9ZXktc3k7XHJcbiAgICAgICAgdHo9ZXotc3o7XHJcbiAgICAgICAgdGQ9ZWQtc2Q7XHJcbiAgICAgICAgZG90dz1kMXgqZGlyMXgrZDF5KmRpcjF5K2QxeipkaXIxejtcclxuICAgICAgICBkb3RoPWQyeCpkaXIxeCtkMnkqZGlyMXkrZDJ6KmRpcjF6O1xyXG4gICAgICAgIGRvdDE9ZG90dy1kaXIxbDtcclxuICAgICAgICBkb3QyPWRvdGgtZGlyMWw7XHJcbiAgICAgICAgaWYoZG90MT4wKXtcclxuICAgICAgICBpZihkb3QyPjApcmV0dXJuO1xyXG4gICAgICAgIHQxPWRvdDEvKGRvdDEtZG90Mik7XHJcbiAgICAgICAgc3g9c3grdHgqdDE7XHJcbiAgICAgICAgc3k9c3krdHkqdDE7XHJcbiAgICAgICAgc3o9c3ordHoqdDE7XHJcbiAgICAgICAgc2Q9c2QrdGQqdDE7XHJcbiAgICAgICAgZDF4PXN4LWNieDtcclxuICAgICAgICBkMXk9c3ktY2J5O1xyXG4gICAgICAgIGQxej1zei1jYno7XHJcbiAgICAgICAgZG90dz1kMXgqZGlyMXgrZDF5KmRpcjF5K2QxeipkaXIxejtcclxuICAgICAgICB0eD1leC1zeDtcclxuICAgICAgICB0eT1leS1zeTtcclxuICAgICAgICB0ej1lei1zejtcclxuICAgICAgICB0ZD1lZC1zZDtcclxuICAgICAgICB9ZWxzZSBpZihkb3QyPjApe1xyXG4gICAgICAgIHQxPWRvdDEvKGRvdDEtZG90Mik7XHJcbiAgICAgICAgZXg9c3grdHgqdDE7XHJcbiAgICAgICAgZXk9c3krdHkqdDE7XHJcbiAgICAgICAgZXo9c3ordHoqdDE7XHJcbiAgICAgICAgZWQ9c2QrdGQqdDE7XHJcbiAgICAgICAgZDJ4PWV4LWNieDtcclxuICAgICAgICBkMnk9ZXktY2J5O1xyXG4gICAgICAgIGQyej1lei1jYno7XHJcbiAgICAgICAgZG90aD1kMngqZGlyMXgrZDJ5KmRpcjF5K2QyeipkaXIxejtcclxuICAgICAgICB0eD1leC1zeDtcclxuICAgICAgICB0eT1leS1zeTtcclxuICAgICAgICB0ej1lei1zejtcclxuICAgICAgICB0ZD1lZC1zZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG90MT1kb3R3K2RpcjFsO1xyXG4gICAgICAgIGRvdDI9ZG90aCtkaXIxbDtcclxuICAgICAgICBpZihkb3QxPDApe1xyXG4gICAgICAgIGlmKGRvdDI8MClyZXR1cm47XHJcbiAgICAgICAgdDE9ZG90MS8oZG90MS1kb3QyKTtcclxuICAgICAgICBzeD1zeCt0eCp0MTtcclxuICAgICAgICBzeT1zeSt0eSp0MTtcclxuICAgICAgICBzej1zeit0eip0MTtcclxuICAgICAgICBzZD1zZCt0ZCp0MTtcclxuICAgICAgICBkMXg9c3gtY2J4O1xyXG4gICAgICAgIGQxeT1zeS1jYnk7XHJcbiAgICAgICAgZDF6PXN6LWNiejtcclxuICAgICAgICB0eD1leC1zeDtcclxuICAgICAgICB0eT1leS1zeTtcclxuICAgICAgICB0ej1lei1zejtcclxuICAgICAgICB0ZD1lZC1zZDtcclxuICAgICAgICB9ZWxzZSBpZihkb3QyPDApe1xyXG4gICAgICAgIHQxPWRvdDEvKGRvdDEtZG90Mik7XHJcbiAgICAgICAgZXg9c3grdHgqdDE7XHJcbiAgICAgICAgZXk9c3krdHkqdDE7XHJcbiAgICAgICAgZXo9c3ordHoqdDE7XHJcbiAgICAgICAgZWQ9c2QrdGQqdDE7XHJcbiAgICAgICAgZDJ4PWV4LWNieDtcclxuICAgICAgICBkMnk9ZXktY2J5O1xyXG4gICAgICAgIGQyej1lei1jYno7XHJcbiAgICAgICAgdHg9ZXgtc3g7XHJcbiAgICAgICAgdHk9ZXktc3k7XHJcbiAgICAgICAgdHo9ZXotc3o7XHJcbiAgICAgICAgdGQ9ZWQtc2Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvdHc9ZDF4KmRpcjJ4K2QxeSpkaXIyeStkMXoqZGlyMno7XHJcbiAgICAgICAgZG90aD1kMngqZGlyMngrZDJ5KmRpcjJ5K2QyeipkaXIyejtcclxuICAgICAgICBkb3QxPWRvdHctZGlyMmw7XHJcbiAgICAgICAgZG90Mj1kb3RoLWRpcjJsO1xyXG4gICAgICAgIGlmKGRvdDE+MCl7XHJcbiAgICAgICAgaWYoZG90Mj4wKXJldHVybjtcclxuICAgICAgICB0MT1kb3QxLyhkb3QxLWRvdDIpO1xyXG4gICAgICAgIHN4PXN4K3R4KnQxO1xyXG4gICAgICAgIHN5PXN5K3R5KnQxO1xyXG4gICAgICAgIHN6PXN6K3R6KnQxO1xyXG4gICAgICAgIHNkPXNkK3RkKnQxO1xyXG4gICAgICAgIGQxeD1zeC1jYng7XHJcbiAgICAgICAgZDF5PXN5LWNieTtcclxuICAgICAgICBkMXo9c3otY2J6O1xyXG4gICAgICAgIGRvdHc9ZDF4KmRpcjJ4K2QxeSpkaXIyeStkMXoqZGlyMno7XHJcbiAgICAgICAgdHg9ZXgtc3g7XHJcbiAgICAgICAgdHk9ZXktc3k7XHJcbiAgICAgICAgdHo9ZXotc3o7XHJcbiAgICAgICAgdGQ9ZWQtc2Q7XHJcbiAgICAgICAgfWVsc2UgaWYoZG90Mj4wKXtcclxuICAgICAgICB0MT1kb3QxLyhkb3QxLWRvdDIpO1xyXG4gICAgICAgIGV4PXN4K3R4KnQxO1xyXG4gICAgICAgIGV5PXN5K3R5KnQxO1xyXG4gICAgICAgIGV6PXN6K3R6KnQxO1xyXG4gICAgICAgIGVkPXNkK3RkKnQxO1xyXG4gICAgICAgIGQyeD1leC1jYng7XHJcbiAgICAgICAgZDJ5PWV5LWNieTtcclxuICAgICAgICBkMno9ZXotY2J6O1xyXG4gICAgICAgIGRvdGg9ZDJ4KmRpcjJ4K2QyeSpkaXIyeStkMnoqZGlyMno7XHJcbiAgICAgICAgdHg9ZXgtc3g7XHJcbiAgICAgICAgdHk9ZXktc3k7XHJcbiAgICAgICAgdHo9ZXotc3o7XHJcbiAgICAgICAgdGQ9ZWQtc2Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvdDE9ZG90dytkaXIybDtcclxuICAgICAgICBkb3QyPWRvdGgrZGlyMmw7XHJcbiAgICAgICAgaWYoZG90MTwwKXtcclxuICAgICAgICBpZihkb3QyPDApcmV0dXJuO1xyXG4gICAgICAgIHQxPWRvdDEvKGRvdDEtZG90Mik7XHJcbiAgICAgICAgc3g9c3grdHgqdDE7XHJcbiAgICAgICAgc3k9c3krdHkqdDE7XHJcbiAgICAgICAgc3o9c3ordHoqdDE7XHJcbiAgICAgICAgc2Q9c2QrdGQqdDE7XHJcbiAgICAgICAgfWVsc2UgaWYoZG90MjwwKXtcclxuICAgICAgICB0MT1kb3QxLyhkb3QxLWRvdDIpO1xyXG4gICAgICAgIGV4PXN4K3R4KnQxO1xyXG4gICAgICAgIGV5PXN5K3R5KnQxO1xyXG4gICAgICAgIGV6PXN6K3R6KnQxO1xyXG4gICAgICAgIGVkPXNkK3RkKnQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihzZDwwKXtcclxuICAgICAgICAvL21hbmlmb2xkLmFkZFBvaW50KHN4LHN5LHN6LG54LG55LG56LHNkLGIsYywxLDAsZmFsc2UpO1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHN4LHN5LHN6LG54LG55LG56LHNkLHRoaXMuZmxpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGVkPDApe1xyXG4gICAgICAgIC8vbWFuaWZvbGQuYWRkUG9pbnQoZXgsZXksZXosbngsbnksbnosZWQsYixjLDQsMCxmYWxzZSk7XHJcbiAgICAgICAgbWFuaWZvbGQuYWRkUG9pbnQoZXgsZXksZXosbngsbnksbnosZWQsdGhpcy5mbGlwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgfSk7XG5cbmZ1bmN0aW9uIEN5bGluZGVyQ3lsaW5kZXJDb2xsaXNpb25EZXRlY3RvcigpIHtcclxuICAgIFxyXG4gICAgQ29sbGlzaW9uRGV0ZWN0b3IuY2FsbCggdGhpcyApO1xyXG5cclxufVxyXG5cclxuQ3lsaW5kZXJDeWxpbmRlckNvbGxpc2lvbkRldGVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENvbGxpc2lvbkRldGVjdG9yLnByb3RvdHlwZSApLCB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IEN5bGluZGVyQ3lsaW5kZXJDb2xsaXNpb25EZXRlY3RvcixcclxuXHJcblxyXG4gICAgZ2V0U2VwOiBmdW5jdGlvbiAoIGMxLCBjMiwgc2VwLCBwb3MsIGRlcCApIHtcclxuXHJcbiAgICAgICAgdmFyIHQxeDtcclxuICAgICAgICB2YXIgdDF5O1xyXG4gICAgICAgIHZhciB0MXo7XHJcbiAgICAgICAgdmFyIHQyeDtcclxuICAgICAgICB2YXIgdDJ5O1xyXG4gICAgICAgIHZhciB0Mno7XHJcbiAgICAgICAgdmFyIHN1cD1uZXcgVmVjMygpO1xyXG4gICAgICAgIHZhciBsZW47XHJcbiAgICAgICAgdmFyIHAxeDtcclxuICAgICAgICB2YXIgcDF5O1xyXG4gICAgICAgIHZhciBwMXo7XHJcbiAgICAgICAgdmFyIHAyeDtcclxuICAgICAgICB2YXIgcDJ5O1xyXG4gICAgICAgIHZhciBwMno7XHJcbiAgICAgICAgdmFyIHYwMXg9YzEucG9zaXRpb24ueDtcclxuICAgICAgICB2YXIgdjAxeT1jMS5wb3NpdGlvbi55O1xyXG4gICAgICAgIHZhciB2MDF6PWMxLnBvc2l0aW9uLno7XHJcbiAgICAgICAgdmFyIHYwMng9YzIucG9zaXRpb24ueDtcclxuICAgICAgICB2YXIgdjAyeT1jMi5wb3NpdGlvbi55O1xyXG4gICAgICAgIHZhciB2MDJ6PWMyLnBvc2l0aW9uLno7XHJcbiAgICAgICAgdmFyIHYweD12MDJ4LXYwMXg7XHJcbiAgICAgICAgdmFyIHYweT12MDJ5LXYwMXk7XHJcbiAgICAgICAgdmFyIHYwej12MDJ6LXYwMXo7XHJcbiAgICAgICAgaWYodjB4KnYweCt2MHkqdjB5K3Yweip2MHo9PTApdjB5PTAuMDAxO1xyXG4gICAgICAgIHZhciBueD0tdjB4O1xyXG4gICAgICAgIHZhciBueT0tdjB5O1xyXG4gICAgICAgIHZhciBuej0tdjB6O1xyXG4gICAgICAgIHRoaXMuc3VwcG9ydFBvaW50KGMxLC1ueCwtbnksLW56LHN1cCk7XHJcbiAgICAgICAgdmFyIHYxMXg9c3VwLng7XHJcbiAgICAgICAgdmFyIHYxMXk9c3VwLnk7XHJcbiAgICAgICAgdmFyIHYxMXo9c3VwLno7XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnQoYzIsbngsbnksbnosc3VwKTtcclxuICAgICAgICB2YXIgdjEyeD1zdXAueDtcclxuICAgICAgICB2YXIgdjEyeT1zdXAueTtcclxuICAgICAgICB2YXIgdjEyej1zdXAuejtcclxuICAgICAgICB2YXIgdjF4PXYxMngtdjExeDtcclxuICAgICAgICB2YXIgdjF5PXYxMnktdjExeTtcclxuICAgICAgICB2YXIgdjF6PXYxMnotdjExejtcclxuICAgICAgICBpZih2MXgqbngrdjF5Km55K3Yxeipuejw9MCl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBueD12MXkqdjB6LXYxeip2MHk7XHJcbiAgICAgICAgbnk9djF6KnYweC12MXgqdjB6O1xyXG4gICAgICAgIG56PXYxeCp2MHktdjF5KnYweDtcclxuICAgICAgICBpZihueCpueCtueSpueStueipuej09MCl7XHJcbiAgICAgICAgc2VwLnNldCggdjF4LXYweCwgdjF5LXYweSwgdjF6LXYweiApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHBvcy5zZXQoICh2MTF4K3YxMngpKjAuNSwgKHYxMXkrdjEyeSkqMC41LCAodjExeit2MTJ6KSowLjUgKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnQoYzEsLW54LC1ueSwtbnosc3VwKTtcclxuICAgICAgICB2YXIgdjIxeD1zdXAueDtcclxuICAgICAgICB2YXIgdjIxeT1zdXAueTtcclxuICAgICAgICB2YXIgdjIxej1zdXAuejtcclxuICAgICAgICB0aGlzLnN1cHBvcnRQb2ludChjMixueCxueSxueixzdXApO1xyXG4gICAgICAgIHZhciB2MjJ4PXN1cC54O1xyXG4gICAgICAgIHZhciB2MjJ5PXN1cC55O1xyXG4gICAgICAgIHZhciB2MjJ6PXN1cC56O1xyXG4gICAgICAgIHZhciB2Mng9djIyeC12MjF4O1xyXG4gICAgICAgIHZhciB2Mnk9djIyeS12MjF5O1xyXG4gICAgICAgIHZhciB2Mno9djIyei12MjF6O1xyXG4gICAgICAgIGlmKHYyeCpueCt2MnkqbnkrdjJ6Km56PD0wKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHQxeD12MXgtdjB4O1xyXG4gICAgICAgIHQxeT12MXktdjB5O1xyXG4gICAgICAgIHQxej12MXotdjB6O1xyXG4gICAgICAgIHQyeD12MngtdjB4O1xyXG4gICAgICAgIHQyeT12MnktdjB5O1xyXG4gICAgICAgIHQyej12MnotdjB6O1xyXG4gICAgICAgIG54PXQxeSp0MnotdDF6KnQyeTtcclxuICAgICAgICBueT10MXoqdDJ4LXQxeCp0Mno7XHJcbiAgICAgICAgbno9dDF4KnQyeS10MXkqdDJ4O1xyXG4gICAgICAgIGlmKG54KnYweCtueSp2MHkrbnoqdjB6PjApe1xyXG4gICAgICAgIHQxeD12MXg7XHJcbiAgICAgICAgdDF5PXYxeTtcclxuICAgICAgICB0MXo9djF6O1xyXG4gICAgICAgIHYxeD12Mng7XHJcbiAgICAgICAgdjF5PXYyeTtcclxuICAgICAgICB2MXo9djJ6O1xyXG4gICAgICAgIHYyeD10MXg7XHJcbiAgICAgICAgdjJ5PXQxeTtcclxuICAgICAgICB2Mno9dDF6O1xyXG4gICAgICAgIHQxeD12MTF4O1xyXG4gICAgICAgIHQxeT12MTF5O1xyXG4gICAgICAgIHQxej12MTF6O1xyXG4gICAgICAgIHYxMXg9djIxeDtcclxuICAgICAgICB2MTF5PXYyMXk7XHJcbiAgICAgICAgdjExej12MjF6O1xyXG4gICAgICAgIHYyMXg9dDF4O1xyXG4gICAgICAgIHYyMXk9dDF5O1xyXG4gICAgICAgIHYyMXo9dDF6O1xyXG4gICAgICAgIHQxeD12MTJ4O1xyXG4gICAgICAgIHQxeT12MTJ5O1xyXG4gICAgICAgIHQxej12MTJ6O1xyXG4gICAgICAgIHYxMng9djIyeDtcclxuICAgICAgICB2MTJ5PXYyMnk7XHJcbiAgICAgICAgdjEyej12MjJ6O1xyXG4gICAgICAgIHYyMng9dDF4O1xyXG4gICAgICAgIHYyMnk9dDF5O1xyXG4gICAgICAgIHYyMno9dDF6O1xyXG4gICAgICAgIG54PS1ueDtcclxuICAgICAgICBueT0tbnk7XHJcbiAgICAgICAgbno9LW56O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlcmF0aW9ucz0wO1xyXG4gICAgICAgIHdoaWxlKHRydWUpe1xyXG4gICAgICAgIGlmKCsraXRlcmF0aW9ucz4xMDApe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnQoYzEsLW54LC1ueSwtbnosc3VwKTtcclxuICAgICAgICB2YXIgdjMxeD1zdXAueDtcclxuICAgICAgICB2YXIgdjMxeT1zdXAueTtcclxuICAgICAgICB2YXIgdjMxej1zdXAuejtcclxuICAgICAgICB0aGlzLnN1cHBvcnRQb2ludChjMixueCxueSxueixzdXApO1xyXG4gICAgICAgIHZhciB2MzJ4PXN1cC54O1xyXG4gICAgICAgIHZhciB2MzJ5PXN1cC55O1xyXG4gICAgICAgIHZhciB2MzJ6PXN1cC56O1xyXG4gICAgICAgIHZhciB2M3g9djMyeC12MzF4O1xyXG4gICAgICAgIHZhciB2M3k9djMyeS12MzF5O1xyXG4gICAgICAgIHZhciB2M3o9djMyei12MzF6O1xyXG4gICAgICAgIGlmKHYzeCpueCt2M3kqbnkrdjN6Km56PD0wKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCh2MXkqdjN6LXYxeip2M3kpKnYweCsodjF6KnYzeC12MXgqdjN6KSp2MHkrKHYxeCp2M3ktdjF5KnYzeCkqdjB6PDApe1xyXG4gICAgICAgIHYyeD12M3g7XHJcbiAgICAgICAgdjJ5PXYzeTtcclxuICAgICAgICB2Mno9djN6O1xyXG4gICAgICAgIHYyMXg9djMxeDtcclxuICAgICAgICB2MjF5PXYzMXk7XHJcbiAgICAgICAgdjIxej12MzF6O1xyXG4gICAgICAgIHYyMng9djMyeDtcclxuICAgICAgICB2MjJ5PXYzMnk7XHJcbiAgICAgICAgdjIyej12MzJ6O1xyXG4gICAgICAgIHQxeD12MXgtdjB4O1xyXG4gICAgICAgIHQxeT12MXktdjB5O1xyXG4gICAgICAgIHQxej12MXotdjB6O1xyXG4gICAgICAgIHQyeD12M3gtdjB4O1xyXG4gICAgICAgIHQyeT12M3ktdjB5O1xyXG4gICAgICAgIHQyej12M3otdjB6O1xyXG4gICAgICAgIG54PXQxeSp0MnotdDF6KnQyeTtcclxuICAgICAgICBueT10MXoqdDJ4LXQxeCp0Mno7XHJcbiAgICAgICAgbno9dDF4KnQyeS10MXkqdDJ4O1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZigodjN5KnYyei12M3oqdjJ5KSp2MHgrKHYzeip2MngtdjN4KnYyeikqdjB5Kyh2M3gqdjJ5LXYzeSp2MngpKnYwejwwKXtcclxuICAgICAgICB2MXg9djN4O1xyXG4gICAgICAgIHYxeT12M3k7XHJcbiAgICAgICAgdjF6PXYzejtcclxuICAgICAgICB2MTF4PXYzMXg7XHJcbiAgICAgICAgdjExeT12MzF5O1xyXG4gICAgICAgIHYxMXo9djMxejtcclxuICAgICAgICB2MTJ4PXYzMng7XHJcbiAgICAgICAgdjEyeT12MzJ5O1xyXG4gICAgICAgIHYxMno9djMyejtcclxuICAgICAgICB0MXg9djN4LXYweDtcclxuICAgICAgICB0MXk9djN5LXYweTtcclxuICAgICAgICB0MXo9djN6LXYwejtcclxuICAgICAgICB0Mng9djJ4LXYweDtcclxuICAgICAgICB0Mnk9djJ5LXYweTtcclxuICAgICAgICB0Mno9djJ6LXYwejtcclxuICAgICAgICBueD10MXkqdDJ6LXQxeip0Mnk7XHJcbiAgICAgICAgbnk9dDF6KnQyeC10MXgqdDJ6O1xyXG4gICAgICAgIG56PXQxeCp0MnktdDF5KnQyeDtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGhpdD1mYWxzZTtcclxuICAgICAgICB3aGlsZSh0cnVlKXtcclxuICAgICAgICB0MXg9djJ4LXYxeDtcclxuICAgICAgICB0MXk9djJ5LXYxeTtcclxuICAgICAgICB0MXo9djJ6LXYxejtcclxuICAgICAgICB0Mng9djN4LXYxeDtcclxuICAgICAgICB0Mnk9djN5LXYxeTtcclxuICAgICAgICB0Mno9djN6LXYxejtcclxuICAgICAgICBueD10MXkqdDJ6LXQxeip0Mnk7XHJcbiAgICAgICAgbnk9dDF6KnQyeC10MXgqdDJ6O1xyXG4gICAgICAgIG56PXQxeCp0MnktdDF5KnQyeDtcclxuICAgICAgICBsZW49MS9fTWF0aC5zcXJ0KG54Km54K255Km55K256Km56KTtcclxuICAgICAgICBueCo9bGVuO1xyXG4gICAgICAgIG55Kj1sZW47XHJcbiAgICAgICAgbnoqPWxlbjtcclxuICAgICAgICBpZihueCp2MXgrbnkqdjF5K256KnYxej49MCYmIWhpdCl7XHJcbiAgICAgICAgdmFyIGIwPSh2MXkqdjJ6LXYxeip2MnkpKnYzeCsodjF6KnYyeC12MXgqdjJ6KSp2M3krKHYxeCp2MnktdjF5KnYyeCkqdjN6O1xyXG4gICAgICAgIHZhciBiMT0odjN5KnYyei12M3oqdjJ5KSp2MHgrKHYzeip2MngtdjN4KnYyeikqdjB5Kyh2M3gqdjJ5LXYzeSp2MngpKnYwejtcclxuICAgICAgICB2YXIgYjI9KHYweSp2MXotdjB6KnYxeSkqdjN4Kyh2MHoqdjF4LXYweCp2MXopKnYzeSsodjB4KnYxeS12MHkqdjF4KSp2M3o7XHJcbiAgICAgICAgdmFyIGIzPSh2MnkqdjF6LXYyeip2MXkpKnYweCsodjJ6KnYxeC12MngqdjF6KSp2MHkrKHYyeCp2MXktdjJ5KnYxeCkqdjB6O1xyXG4gICAgICAgIHZhciBzdW09YjArYjErYjIrYjM7XHJcbiAgICAgICAgaWYoc3VtPD0wKXtcclxuICAgICAgICBiMD0wO1xyXG4gICAgICAgIGIxPSh2MnkqdjN6LXYyeip2M3kpKm54Kyh2MnoqdjN4LXYyeCp2M3opKm55Kyh2MngqdjN5LXYyeSp2M3gpKm56O1xyXG4gICAgICAgIGIyPSh2M3kqdjJ6LXYzeip2MnkpKm54Kyh2M3oqdjJ4LXYzeCp2MnopKm55Kyh2M3gqdjJ5LXYzeSp2MngpKm56O1xyXG4gICAgICAgIGIzPSh2MXkqdjJ6LXYxeip2MnkpKm54Kyh2MXoqdjJ4LXYxeCp2MnopKm55Kyh2MXgqdjJ5LXYxeSp2MngpKm56O1xyXG4gICAgICAgIHN1bT1iMStiMitiMztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludj0xL3N1bTtcclxuICAgICAgICBwMXg9KHYwMXgqYjArdjExeCpiMSt2MjF4KmIyK3YzMXgqYjMpKmludjtcclxuICAgICAgICBwMXk9KHYwMXkqYjArdjExeSpiMSt2MjF5KmIyK3YzMXkqYjMpKmludjtcclxuICAgICAgICBwMXo9KHYwMXoqYjArdjExeipiMSt2MjF6KmIyK3YzMXoqYjMpKmludjtcclxuICAgICAgICBwMng9KHYwMngqYjArdjEyeCpiMSt2MjJ4KmIyK3YzMngqYjMpKmludjtcclxuICAgICAgICBwMnk9KHYwMnkqYjArdjEyeSpiMSt2MjJ5KmIyK3YzMnkqYjMpKmludjtcclxuICAgICAgICBwMno9KHYwMnoqYjArdjEyeipiMSt2MjJ6KmIyK3YzMnoqYjMpKmludjtcclxuICAgICAgICBoaXQ9dHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0UG9pbnQoYzEsLW54LC1ueSwtbnosc3VwKTtcclxuICAgICAgICB2YXIgdjQxeD1zdXAueDtcclxuICAgICAgICB2YXIgdjQxeT1zdXAueTtcclxuICAgICAgICB2YXIgdjQxej1zdXAuejtcclxuICAgICAgICB0aGlzLnN1cHBvcnRQb2ludChjMixueCxueSxueixzdXApO1xyXG4gICAgICAgIHZhciB2NDJ4PXN1cC54O1xyXG4gICAgICAgIHZhciB2NDJ5PXN1cC55O1xyXG4gICAgICAgIHZhciB2NDJ6PXN1cC56O1xyXG4gICAgICAgIHZhciB2NHg9djQyeC12NDF4O1xyXG4gICAgICAgIHZhciB2NHk9djQyeS12NDF5O1xyXG4gICAgICAgIHZhciB2NHo9djQyei12NDF6O1xyXG4gICAgICAgIHZhciBzZXBhcmF0aW9uPS0odjR4Km54K3Y0eSpueSt2NHoqbnopO1xyXG4gICAgICAgIGlmKCh2NHgtdjN4KSpueCsodjR5LXYzeSkqbnkrKHY0ei12M3opKm56PD0wLjAxfHxzZXBhcmF0aW9uPj0wKXtcclxuICAgICAgICBpZihoaXQpe1xyXG4gICAgICAgIHNlcC5zZXQoIC1ueCwgLW55LCAtbnogKTtcclxuICAgICAgICBwb3Muc2V0KCAocDF4K3AyeCkqMC41LCAocDF5K3AyeSkqMC41LCAocDF6K3AyeikqMC41ICk7XHJcbiAgICAgICAgZGVwLng9c2VwYXJhdGlvbjtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihcclxuICAgICAgICAodjR5KnYxei12NHoqdjF5KSp2MHgrXHJcbiAgICAgICAgKHY0eip2MXgtdjR4KnYxeikqdjB5K1xyXG4gICAgICAgICh2NHgqdjF5LXY0eSp2MXgpKnYwejwwXHJcbiAgICAgICAgKXtcclxuICAgICAgICBpZihcclxuICAgICAgICAodjR5KnYyei12NHoqdjJ5KSp2MHgrXHJcbiAgICAgICAgKHY0eip2MngtdjR4KnYyeikqdjB5K1xyXG4gICAgICAgICh2NHgqdjJ5LXY0eSp2MngpKnYwejwwXHJcbiAgICAgICAgKXtcclxuICAgICAgICB2MXg9djR4O1xyXG4gICAgICAgIHYxeT12NHk7XHJcbiAgICAgICAgdjF6PXY0ejtcclxuICAgICAgICB2MTF4PXY0MXg7XHJcbiAgICAgICAgdjExeT12NDF5O1xyXG4gICAgICAgIHYxMXo9djQxejtcclxuICAgICAgICB2MTJ4PXY0Mng7XHJcbiAgICAgICAgdjEyeT12NDJ5O1xyXG4gICAgICAgIHYxMno9djQyejtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICB2M3g9djR4O1xyXG4gICAgICAgIHYzeT12NHk7XHJcbiAgICAgICAgdjN6PXY0ejtcclxuICAgICAgICB2MzF4PXY0MXg7XHJcbiAgICAgICAgdjMxeT12NDF5O1xyXG4gICAgICAgIHYzMXo9djQxejtcclxuICAgICAgICB2MzJ4PXY0Mng7XHJcbiAgICAgICAgdjMyeT12NDJ5O1xyXG4gICAgICAgIHYzMno9djQyejtcclxuICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgaWYoXHJcbiAgICAgICAgKHY0eSp2M3otdjR6KnYzeSkqdjB4K1xyXG4gICAgICAgICh2NHoqdjN4LXY0eCp2M3opKnYweStcclxuICAgICAgICAodjR4KnYzeS12NHkqdjN4KSp2MHo8MFxyXG4gICAgICAgICl7XHJcbiAgICAgICAgdjJ4PXY0eDtcclxuICAgICAgICB2Mnk9djR5O1xyXG4gICAgICAgIHYyej12NHo7XHJcbiAgICAgICAgdjIxeD12NDF4O1xyXG4gICAgICAgIHYyMXk9djQxeTtcclxuICAgICAgICB2MjF6PXY0MXo7XHJcbiAgICAgICAgdjIyeD12NDJ4O1xyXG4gICAgICAgIHYyMnk9djQyeTtcclxuICAgICAgICB2MjJ6PXY0Mno7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgdjF4PXY0eDtcclxuICAgICAgICB2MXk9djR5O1xyXG4gICAgICAgIHYxej12NHo7XHJcbiAgICAgICAgdjExeD12NDF4O1xyXG4gICAgICAgIHYxMXk9djQxeTtcclxuICAgICAgICB2MTF6PXY0MXo7XHJcbiAgICAgICAgdjEyeD12NDJ4O1xyXG4gICAgICAgIHYxMnk9djQyeTtcclxuICAgICAgICB2MTJ6PXY0Mno7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdXBwb3J0UG9pbnQ6IGZ1bmN0aW9uICggYywgZHgsIGR5LCBkeiwgb3V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcm90PWMucm90YXRpb24uZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIGxkeD1yb3RbMF0qZHgrcm90WzNdKmR5K3JvdFs2XSpkejtcclxuICAgICAgICB2YXIgbGR5PXJvdFsxXSpkeCtyb3RbNF0qZHkrcm90WzddKmR6O1xyXG4gICAgICAgIHZhciBsZHo9cm90WzJdKmR4K3JvdFs1XSpkeStyb3RbOF0qZHo7XHJcbiAgICAgICAgdmFyIHJhZHg9bGR4O1xyXG4gICAgICAgIHZhciByYWR6PWxkejtcclxuICAgICAgICB2YXIgbGVuPXJhZHgqcmFkeCtyYWR6KnJhZHo7XHJcbiAgICAgICAgdmFyIHJhZD1jLnJhZGl1cztcclxuICAgICAgICB2YXIgaGg9Yy5oYWxmSGVpZ2h0O1xyXG4gICAgICAgIHZhciBveDtcclxuICAgICAgICB2YXIgb3k7XHJcbiAgICAgICAgdmFyIG96O1xyXG4gICAgICAgIGlmKGxlbj09MCl7XHJcbiAgICAgICAgaWYobGR5PDApe1xyXG4gICAgICAgIG94PXJhZDtcclxuICAgICAgICBveT0taGg7XHJcbiAgICAgICAgb3o9MDtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBveD1yYWQ7XHJcbiAgICAgICAgb3k9aGg7XHJcbiAgICAgICAgb3o9MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgbGVuPWMucmFkaXVzL19NYXRoLnNxcnQobGVuKTtcclxuICAgICAgICBpZihsZHk8MCl7XHJcbiAgICAgICAgb3g9cmFkeCpsZW47XHJcbiAgICAgICAgb3k9LWhoO1xyXG4gICAgICAgIG96PXJhZHoqbGVuO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgIG94PXJhZHgqbGVuO1xyXG4gICAgICAgIG95PWhoO1xyXG4gICAgICAgIG96PXJhZHoqbGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGR4PXJvdFswXSpveCtyb3RbMV0qb3krcm90WzJdKm96K2MucG9zaXRpb24ueDtcclxuICAgICAgICBsZHk9cm90WzNdKm94K3JvdFs0XSpveStyb3RbNV0qb3orYy5wb3NpdGlvbi55O1xyXG4gICAgICAgIGxkej1yb3RbNl0qb3grcm90WzddKm95K3JvdFs4XSpveitjLnBvc2l0aW9uLno7XHJcbiAgICAgICAgb3V0LnNldCggbGR4LCBsZHksIGxkeiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGV0ZWN0Q29sbGlzaW9uOiBmdW5jdGlvbiAoIHNoYXBlMSwgc2hhcGUyLCBtYW5pZm9sZCApIHtcclxuXHJcbiAgICAgICAgdmFyIGMxO1xyXG4gICAgICAgIHZhciBjMjtcclxuICAgICAgICBpZihzaGFwZTEuaWQ8c2hhcGUyLmlkKXtcclxuICAgICAgICAgICAgYzE9c2hhcGUxO1xyXG4gICAgICAgICAgICBjMj1zaGFwZTI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGMxPXNoYXBlMjtcclxuICAgICAgICAgICAgYzI9c2hhcGUxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcDE9YzEucG9zaXRpb247XHJcbiAgICAgICAgdmFyIHAyPWMyLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBwMXg9cDEueDtcclxuICAgICAgICB2YXIgcDF5PXAxLnk7XHJcbiAgICAgICAgdmFyIHAxej1wMS56O1xyXG4gICAgICAgIHZhciBwMng9cDIueDtcclxuICAgICAgICB2YXIgcDJ5PXAyLnk7XHJcbiAgICAgICAgdmFyIHAyej1wMi56O1xyXG4gICAgICAgIHZhciBoMT1jMS5oYWxmSGVpZ2h0O1xyXG4gICAgICAgIHZhciBoMj1jMi5oYWxmSGVpZ2h0O1xyXG4gICAgICAgIHZhciBuMT1jMS5ub3JtYWxEaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIG4yPWMyLm5vcm1hbERpcmVjdGlvbjtcclxuICAgICAgICB2YXIgZDE9YzEuaGFsZkRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgZDI9YzIuaGFsZkRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgcjE9YzEucmFkaXVzO1xyXG4gICAgICAgIHZhciByMj1jMi5yYWRpdXM7XHJcbiAgICAgICAgdmFyIG4xeD1uMS54O1xyXG4gICAgICAgIHZhciBuMXk9bjEueTtcclxuICAgICAgICB2YXIgbjF6PW4xLno7XHJcbiAgICAgICAgdmFyIG4yeD1uMi54O1xyXG4gICAgICAgIHZhciBuMnk9bjIueTtcclxuICAgICAgICB2YXIgbjJ6PW4yLno7XHJcbiAgICAgICAgdmFyIGQxeD1kMS54O1xyXG4gICAgICAgIHZhciBkMXk9ZDEueTtcclxuICAgICAgICB2YXIgZDF6PWQxLno7XHJcbiAgICAgICAgdmFyIGQyeD1kMi54O1xyXG4gICAgICAgIHZhciBkMnk9ZDIueTtcclxuICAgICAgICB2YXIgZDJ6PWQyLno7XHJcbiAgICAgICAgdmFyIGR4PXAxeC1wMng7XHJcbiAgICAgICAgdmFyIGR5PXAxeS1wMnk7XHJcbiAgICAgICAgdmFyIGR6PXAxei1wMno7XHJcbiAgICAgICAgdmFyIGxlbjtcclxuICAgICAgICB2YXIgYzF4O1xyXG4gICAgICAgIHZhciBjMXk7XHJcbiAgICAgICAgdmFyIGMxejtcclxuICAgICAgICB2YXIgYzJ4O1xyXG4gICAgICAgIHZhciBjMnk7XHJcbiAgICAgICAgdmFyIGMyejtcclxuICAgICAgICB2YXIgdHg7XHJcbiAgICAgICAgdmFyIHR5O1xyXG4gICAgICAgIHZhciB0ejtcclxuICAgICAgICB2YXIgc3g7XHJcbiAgICAgICAgdmFyIHN5O1xyXG4gICAgICAgIHZhciBzejtcclxuICAgICAgICB2YXIgZXg7XHJcbiAgICAgICAgdmFyIGV5O1xyXG4gICAgICAgIHZhciBlejtcclxuICAgICAgICB2YXIgZGVwdGgxO1xyXG4gICAgICAgIHZhciBkZXB0aDI7XHJcbiAgICAgICAgdmFyIGRvdDtcclxuICAgICAgICB2YXIgdDE7XHJcbiAgICAgICAgdmFyIHQyO1xyXG4gICAgICAgIHZhciBzZXA9bmV3IFZlYzMoKTtcclxuICAgICAgICB2YXIgcG9zPW5ldyBWZWMzKCk7XHJcbiAgICAgICAgdmFyIGRlcD1uZXcgVmVjMygpO1xyXG4gICAgICAgIGlmKCF0aGlzLmdldFNlcChjMSxjMixzZXAscG9zLGRlcCkpcmV0dXJuO1xyXG4gICAgICAgIHZhciBkb3QxPXNlcC54Km4xeCtzZXAueSpuMXkrc2VwLnoqbjF6O1xyXG4gICAgICAgIHZhciBkb3QyPXNlcC54Km4yeCtzZXAueSpuMnkrc2VwLnoqbjJ6O1xyXG4gICAgICAgIHZhciByaWdodDE9ZG90MT4wO1xyXG4gICAgICAgIHZhciByaWdodDI9ZG90Mj4wO1xyXG4gICAgICAgIGlmKCFyaWdodDEpZG90MT0tZG90MTtcclxuICAgICAgICBpZighcmlnaHQyKWRvdDI9LWRvdDI7XHJcbiAgICAgICAgdmFyIHN0YXRlPTA7XHJcbiAgICAgICAgaWYoZG90MT4wLjk5OXx8ZG90Mj4wLjk5OSl7XHJcbiAgICAgICAgaWYoZG90MT5kb3QyKXN0YXRlPTE7XHJcbiAgICAgICAgZWxzZSBzdGF0ZT0yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbng7XHJcbiAgICAgICAgdmFyIG55O1xyXG4gICAgICAgIHZhciBuejtcclxuICAgICAgICB2YXIgZGVwdGg9ZGVwLng7XHJcbiAgICAgICAgdmFyIHIwMDtcclxuICAgICAgICB2YXIgcjAxO1xyXG4gICAgICAgIHZhciByMDI7XHJcbiAgICAgICAgdmFyIHIxMDtcclxuICAgICAgICB2YXIgcjExO1xyXG4gICAgICAgIHZhciByMTI7XHJcbiAgICAgICAgdmFyIHIyMDtcclxuICAgICAgICB2YXIgcjIxO1xyXG4gICAgICAgIHZhciByMjI7XHJcbiAgICAgICAgdmFyIHB4O1xyXG4gICAgICAgIHZhciBweTtcclxuICAgICAgICB2YXIgcHo7XHJcbiAgICAgICAgdmFyIHBkO1xyXG4gICAgICAgIHZhciBhO1xyXG4gICAgICAgIHZhciBiO1xyXG4gICAgICAgIHZhciBlO1xyXG4gICAgICAgIHZhciBmO1xyXG4gICAgICAgIG54PXNlcC54O1xyXG4gICAgICAgIG55PXNlcC55O1xyXG4gICAgICAgIG56PXNlcC56O1xyXG4gICAgICAgIHN3aXRjaChzdGF0ZSl7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHBvcy54LHBvcy55LHBvcy56LG54LG55LG56LGRlcHRoLGZhbHNlKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgaWYocmlnaHQxKXtcclxuICAgICAgICBjMXg9cDF4K2QxeDtcclxuICAgICAgICBjMXk9cDF5K2QxeTtcclxuICAgICAgICBjMXo9cDF6K2QxejtcclxuICAgICAgICBueD1uMXg7XHJcbiAgICAgICAgbnk9bjF5O1xyXG4gICAgICAgIG56PW4xejtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBjMXg9cDF4LWQxeDtcclxuICAgICAgICBjMXk9cDF5LWQxeTtcclxuICAgICAgICBjMXo9cDF6LWQxejtcclxuICAgICAgICBueD0tbjF4O1xyXG4gICAgICAgIG55PS1uMXk7XHJcbiAgICAgICAgbno9LW4xejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG90PW54Km4yeCtueSpuMnkrbnoqbjJ6O1xyXG4gICAgICAgIGlmKGRvdDwwKWxlbj1oMjtcclxuICAgICAgICBlbHNlIGxlbj0taDI7XHJcbiAgICAgICAgYzJ4PXAyeCtsZW4qbjJ4O1xyXG4gICAgICAgIGMyeT1wMnkrbGVuKm4yeTtcclxuICAgICAgICBjMno9cDJ6K2xlbipuMno7XHJcbiAgICAgICAgaWYoZG90Mj49MC45OTk5OTkpe1xyXG4gICAgICAgIHR4PS1ueTtcclxuICAgICAgICB0eT1uejtcclxuICAgICAgICB0ej1ueDtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICB0eD1ueDtcclxuICAgICAgICB0eT1ueTtcclxuICAgICAgICB0ej1uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVuPXR4Km4yeCt0eSpuMnkrdHoqbjJ6O1xyXG4gICAgICAgIGR4PWxlbipuMngtdHg7XHJcbiAgICAgICAgZHk9bGVuKm4yeS10eTtcclxuICAgICAgICBkej1sZW4qbjJ6LXR6O1xyXG4gICAgICAgIGxlbj1fTWF0aC5zcXJ0KGR4KmR4K2R5KmR5K2R6KmR6KTtcclxuICAgICAgICBpZihsZW49PTApYnJlYWs7XHJcbiAgICAgICAgbGVuPXIyL2xlbjtcclxuICAgICAgICBkeCo9bGVuO1xyXG4gICAgICAgIGR5Kj1sZW47XHJcbiAgICAgICAgZHoqPWxlbjtcclxuICAgICAgICB0eD1jMngrZHg7XHJcbiAgICAgICAgdHk9YzJ5K2R5O1xyXG4gICAgICAgIHR6PWMyeitkejtcclxuICAgICAgICBpZihkb3Q8LTAuOTZ8fGRvdD4wLjk2KXtcclxuICAgICAgICByMDA9bjJ4Km4yeCoxLjUtMC41O1xyXG4gICAgICAgIHIwMT1uMngqbjJ5KjEuNS1uMnoqMC44NjYwMjU0MDM7XHJcbiAgICAgICAgcjAyPW4yeCpuMnoqMS41K24yeSowLjg2NjAyNTQwMztcclxuICAgICAgICByMTA9bjJ5Km4yeCoxLjUrbjJ6KjAuODY2MDI1NDAzO1xyXG4gICAgICAgIHIxMT1uMnkqbjJ5KjEuNS0wLjU7XHJcbiAgICAgICAgcjEyPW4yeSpuMnoqMS41LW4yeCowLjg2NjAyNTQwMztcclxuICAgICAgICByMjA9bjJ6Km4yeCoxLjUtbjJ5KjAuODY2MDI1NDAzO1xyXG4gICAgICAgIHIyMT1uMnoqbjJ5KjEuNStuMngqMC44NjYwMjU0MDM7XHJcbiAgICAgICAgcjIyPW4yeipuMnoqMS41LTAuNTtcclxuICAgICAgICBweD10eDtcclxuICAgICAgICBweT10eTtcclxuICAgICAgICBwej10ejtcclxuICAgICAgICBwZD1ueCoocHgtYzF4KStueSoocHktYzF5KStueioocHotYzF6KTtcclxuICAgICAgICB0eD1weC1wZCpueC1jMXg7XHJcbiAgICAgICAgdHk9cHktcGQqbnktYzF5O1xyXG4gICAgICAgIHR6PXB6LXBkKm56LWMxejtcclxuICAgICAgICBsZW49dHgqdHgrdHkqdHkrdHoqdHo7XHJcbiAgICAgICAgaWYobGVuPnIxKnIxKXtcclxuICAgICAgICBsZW49cjEvX01hdGguc3FydChsZW4pO1xyXG4gICAgICAgIHR4Kj1sZW47XHJcbiAgICAgICAgdHkqPWxlbjtcclxuICAgICAgICB0eio9bGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBweD1jMXgrdHg7XHJcbiAgICAgICAgcHk9YzF5K3R5O1xyXG4gICAgICAgIHB6PWMxeit0ejtcclxuICAgICAgICBtYW5pZm9sZC5hZGRQb2ludChweCxweSxweixueCxueSxueixwZCxmYWxzZSk7XHJcbiAgICAgICAgcHg9ZHgqcjAwK2R5KnIwMStkeipyMDI7XHJcbiAgICAgICAgcHk9ZHgqcjEwK2R5KnIxMStkeipyMTI7XHJcbiAgICAgICAgcHo9ZHgqcjIwK2R5KnIyMStkeipyMjI7XHJcbiAgICAgICAgcHg9KGR4PXB4KStjMng7XHJcbiAgICAgICAgcHk9KGR5PXB5KStjMnk7XHJcbiAgICAgICAgcHo9KGR6PXB6KStjMno7XHJcbiAgICAgICAgcGQ9bngqKHB4LWMxeCkrbnkqKHB5LWMxeSkrbnoqKHB6LWMxeik7XHJcbiAgICAgICAgaWYocGQ8PTApe1xyXG4gICAgICAgIHR4PXB4LXBkKm54LWMxeDtcclxuICAgICAgICB0eT1weS1wZCpueS1jMXk7XHJcbiAgICAgICAgdHo9cHotcGQqbnotYzF6O1xyXG4gICAgICAgIGxlbj10eCp0eCt0eSp0eSt0eip0ejtcclxuICAgICAgICBpZihsZW4+cjEqcjEpe1xyXG4gICAgICAgIGxlbj1yMS9fTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgdHgqPWxlbjtcclxuICAgICAgICB0eSo9bGVuO1xyXG4gICAgICAgIHR6Kj1sZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB4PWMxeCt0eDtcclxuICAgICAgICBweT1jMXkrdHk7XHJcbiAgICAgICAgcHo9YzF6K3R6O1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHB4LHB5LHB6LG54LG55LG56LHBkLGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHg9ZHgqcjAwK2R5KnIwMStkeipyMDI7XHJcbiAgICAgICAgcHk9ZHgqcjEwK2R5KnIxMStkeipyMTI7XHJcbiAgICAgICAgcHo9ZHgqcjIwK2R5KnIyMStkeipyMjI7XHJcbiAgICAgICAgcHg9KGR4PXB4KStjMng7XHJcbiAgICAgICAgcHk9KGR5PXB5KStjMnk7XHJcbiAgICAgICAgcHo9KGR6PXB6KStjMno7XHJcbiAgICAgICAgcGQ9bngqKHB4LWMxeCkrbnkqKHB5LWMxeSkrbnoqKHB6LWMxeik7XHJcbiAgICAgICAgaWYocGQ8PTApe1xyXG4gICAgICAgIHR4PXB4LXBkKm54LWMxeDtcclxuICAgICAgICB0eT1weS1wZCpueS1jMXk7XHJcbiAgICAgICAgdHo9cHotcGQqbnotYzF6O1xyXG4gICAgICAgIGxlbj10eCp0eCt0eSp0eSt0eip0ejtcclxuICAgICAgICBpZihsZW4+cjEqcjEpe1xyXG4gICAgICAgIGxlbj1yMS9fTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgdHgqPWxlbjtcclxuICAgICAgICB0eSo9bGVuO1xyXG4gICAgICAgIHR6Kj1sZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB4PWMxeCt0eDtcclxuICAgICAgICBweT1jMXkrdHk7XHJcbiAgICAgICAgcHo9YzF6K3R6O1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHB4LHB5LHB6LG54LG55LG56LHBkLGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgc3g9dHg7XHJcbiAgICAgICAgc3k9dHk7XHJcbiAgICAgICAgc3o9dHo7XHJcbiAgICAgICAgZGVwdGgxPW54KihzeC1jMXgpK255KihzeS1jMXkpK256Kihzei1jMXopO1xyXG4gICAgICAgIHN4LT1kZXB0aDEqbng7XHJcbiAgICAgICAgc3ktPWRlcHRoMSpueTtcclxuICAgICAgICBzei09ZGVwdGgxKm56O1xyXG4gICAgICAgIGlmKGRvdD4wKXtcclxuICAgICAgICBleD10eCtuMngqaDIqMjtcclxuICAgICAgICBleT10eStuMnkqaDIqMjtcclxuICAgICAgICBlej10eituMnoqaDIqMjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBleD10eC1uMngqaDIqMjtcclxuICAgICAgICBleT10eS1uMnkqaDIqMjtcclxuICAgICAgICBlej10ei1uMnoqaDIqMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwdGgyPW54KihleC1jMXgpK255KihleS1jMXkpK256Kihlei1jMXopO1xyXG4gICAgICAgIGV4LT1kZXB0aDIqbng7XHJcbiAgICAgICAgZXktPWRlcHRoMipueTtcclxuICAgICAgICBlei09ZGVwdGgyKm56O1xyXG4gICAgICAgIGR4PWMxeC1zeDtcclxuICAgICAgICBkeT1jMXktc3k7XHJcbiAgICAgICAgZHo9YzF6LXN6O1xyXG4gICAgICAgIHR4PWV4LXN4O1xyXG4gICAgICAgIHR5PWV5LXN5O1xyXG4gICAgICAgIHR6PWV6LXN6O1xyXG4gICAgICAgIGE9ZHgqZHgrZHkqZHkrZHoqZHo7XHJcbiAgICAgICAgYj1keCp0eCtkeSp0eStkeip0ejtcclxuICAgICAgICBlPXR4KnR4K3R5KnR5K3R6KnR6O1xyXG4gICAgICAgIGY9YipiLWUqKGEtcjEqcjEpO1xyXG4gICAgICAgIGlmKGY8MClicmVhaztcclxuICAgICAgICBmPV9NYXRoLnNxcnQoZik7XHJcbiAgICAgICAgdDE9KGIrZikvZTtcclxuICAgICAgICB0Mj0oYi1mKS9lO1xyXG4gICAgICAgIGlmKHQyPHQxKXtcclxuICAgICAgICBsZW49dDE7XHJcbiAgICAgICAgdDE9dDI7XHJcbiAgICAgICAgdDI9bGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0Mj4xKXQyPTE7XHJcbiAgICAgICAgaWYodDE8MCl0MT0wO1xyXG4gICAgICAgIHR4PXN4KyhleC1zeCkqdDE7XHJcbiAgICAgICAgdHk9c3krKGV5LXN5KSp0MTtcclxuICAgICAgICB0ej1zeisoZXotc3opKnQxO1xyXG4gICAgICAgIGV4PXN4KyhleC1zeCkqdDI7XHJcbiAgICAgICAgZXk9c3krKGV5LXN5KSp0MjtcclxuICAgICAgICBlej1zeisoZXotc3opKnQyO1xyXG4gICAgICAgIHN4PXR4O1xyXG4gICAgICAgIHN5PXR5O1xyXG4gICAgICAgIHN6PXR6O1xyXG4gICAgICAgIGxlbj1kZXB0aDErKGRlcHRoMi1kZXB0aDEpKnQxO1xyXG4gICAgICAgIGRlcHRoMj1kZXB0aDErKGRlcHRoMi1kZXB0aDEpKnQyO1xyXG4gICAgICAgIGRlcHRoMT1sZW47XHJcbiAgICAgICAgaWYoZGVwdGgxPDApIG1hbmlmb2xkLmFkZFBvaW50KHN4LHN5LHN6LG54LG55LG56LHBkLGZhbHNlKTtcclxuICAgICAgICBpZihkZXB0aDI8MCkgbWFuaWZvbGQuYWRkUG9pbnQoZXgsZXksZXosbngsbnksbnoscGQsZmFsc2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgaWYocmlnaHQyKXtcclxuICAgICAgICBjMng9cDJ4LWQyeDtcclxuICAgICAgICBjMnk9cDJ5LWQyeTtcclxuICAgICAgICBjMno9cDJ6LWQyejtcclxuICAgICAgICBueD0tbjJ4O1xyXG4gICAgICAgIG55PS1uMnk7XHJcbiAgICAgICAgbno9LW4yejtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBjMng9cDJ4K2QyeDtcclxuICAgICAgICBjMnk9cDJ5K2QyeTtcclxuICAgICAgICBjMno9cDJ6K2QyejtcclxuICAgICAgICBueD1uMng7XHJcbiAgICAgICAgbnk9bjJ5O1xyXG4gICAgICAgIG56PW4yejtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG90PW54Km4xeCtueSpuMXkrbnoqbjF6O1xyXG4gICAgICAgIGlmKGRvdDwwKWxlbj1oMTtcclxuICAgICAgICBlbHNlIGxlbj0taDE7XHJcbiAgICAgICAgYzF4PXAxeCtsZW4qbjF4O1xyXG4gICAgICAgIGMxeT1wMXkrbGVuKm4xeTtcclxuICAgICAgICBjMXo9cDF6K2xlbipuMXo7XHJcbiAgICAgICAgaWYoZG90MT49MC45OTk5OTkpe1xyXG4gICAgICAgIHR4PS1ueTtcclxuICAgICAgICB0eT1uejtcclxuICAgICAgICB0ej1ueDtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICB0eD1ueDtcclxuICAgICAgICB0eT1ueTtcclxuICAgICAgICB0ej1uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVuPXR4Km4xeCt0eSpuMXkrdHoqbjF6O1xyXG4gICAgICAgIGR4PWxlbipuMXgtdHg7XHJcbiAgICAgICAgZHk9bGVuKm4xeS10eTtcclxuICAgICAgICBkej1sZW4qbjF6LXR6O1xyXG4gICAgICAgIGxlbj1fTWF0aC5zcXJ0KGR4KmR4K2R5KmR5K2R6KmR6KTtcclxuICAgICAgICBpZihsZW49PTApYnJlYWs7XHJcbiAgICAgICAgbGVuPXIxL2xlbjtcclxuICAgICAgICBkeCo9bGVuO1xyXG4gICAgICAgIGR5Kj1sZW47XHJcbiAgICAgICAgZHoqPWxlbjtcclxuICAgICAgICB0eD1jMXgrZHg7XHJcbiAgICAgICAgdHk9YzF5K2R5O1xyXG4gICAgICAgIHR6PWMxeitkejtcclxuICAgICAgICBpZihkb3Q8LTAuOTZ8fGRvdD4wLjk2KXtcclxuICAgICAgICByMDA9bjF4Km4xeCoxLjUtMC41O1xyXG4gICAgICAgIHIwMT1uMXgqbjF5KjEuNS1uMXoqMC44NjYwMjU0MDM7XHJcbiAgICAgICAgcjAyPW4xeCpuMXoqMS41K24xeSowLjg2NjAyNTQwMztcclxuICAgICAgICByMTA9bjF5Km4xeCoxLjUrbjF6KjAuODY2MDI1NDAzO1xyXG4gICAgICAgIHIxMT1uMXkqbjF5KjEuNS0wLjU7XHJcbiAgICAgICAgcjEyPW4xeSpuMXoqMS41LW4xeCowLjg2NjAyNTQwMztcclxuICAgICAgICByMjA9bjF6Km4xeCoxLjUtbjF5KjAuODY2MDI1NDAzO1xyXG4gICAgICAgIHIyMT1uMXoqbjF5KjEuNStuMXgqMC44NjYwMjU0MDM7XHJcbiAgICAgICAgcjIyPW4xeipuMXoqMS41LTAuNTtcclxuICAgICAgICBweD10eDtcclxuICAgICAgICBweT10eTtcclxuICAgICAgICBwej10ejtcclxuICAgICAgICBwZD1ueCoocHgtYzJ4KStueSoocHktYzJ5KStueioocHotYzJ6KTtcclxuICAgICAgICB0eD1weC1wZCpueC1jMng7XHJcbiAgICAgICAgdHk9cHktcGQqbnktYzJ5O1xyXG4gICAgICAgIHR6PXB6LXBkKm56LWMyejtcclxuICAgICAgICBsZW49dHgqdHgrdHkqdHkrdHoqdHo7XHJcbiAgICAgICAgaWYobGVuPnIyKnIyKXtcclxuICAgICAgICBsZW49cjIvX01hdGguc3FydChsZW4pO1xyXG4gICAgICAgIHR4Kj1sZW47XHJcbiAgICAgICAgdHkqPWxlbjtcclxuICAgICAgICB0eio9bGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBweD1jMngrdHg7XHJcbiAgICAgICAgcHk9YzJ5K3R5O1xyXG4gICAgICAgIHB6PWMyeit0ejtcclxuICAgICAgICBtYW5pZm9sZC5hZGRQb2ludChweCxweSxweiwtbngsLW55LC1ueixwZCxmYWxzZSk7XHJcbiAgICAgICAgcHg9ZHgqcjAwK2R5KnIwMStkeipyMDI7XHJcbiAgICAgICAgcHk9ZHgqcjEwK2R5KnIxMStkeipyMTI7XHJcbiAgICAgICAgcHo9ZHgqcjIwK2R5KnIyMStkeipyMjI7XHJcbiAgICAgICAgcHg9KGR4PXB4KStjMXg7XHJcbiAgICAgICAgcHk9KGR5PXB5KStjMXk7XHJcbiAgICAgICAgcHo9KGR6PXB6KStjMXo7XHJcbiAgICAgICAgcGQ9bngqKHB4LWMyeCkrbnkqKHB5LWMyeSkrbnoqKHB6LWMyeik7XHJcbiAgICAgICAgaWYocGQ8PTApe1xyXG4gICAgICAgIHR4PXB4LXBkKm54LWMyeDtcclxuICAgICAgICB0eT1weS1wZCpueS1jMnk7XHJcbiAgICAgICAgdHo9cHotcGQqbnotYzJ6O1xyXG4gICAgICAgIGxlbj10eCp0eCt0eSp0eSt0eip0ejtcclxuICAgICAgICBpZihsZW4+cjIqcjIpe1xyXG4gICAgICAgIGxlbj1yMi9fTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgdHgqPWxlbjtcclxuICAgICAgICB0eSo9bGVuO1xyXG4gICAgICAgIHR6Kj1sZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB4PWMyeCt0eDtcclxuICAgICAgICBweT1jMnkrdHk7XHJcbiAgICAgICAgcHo9YzJ6K3R6O1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHB4LHB5LHB6LC1ueCwtbnksLW56LHBkLGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHg9ZHgqcjAwK2R5KnIwMStkeipyMDI7XHJcbiAgICAgICAgcHk9ZHgqcjEwK2R5KnIxMStkeipyMTI7XHJcbiAgICAgICAgcHo9ZHgqcjIwK2R5KnIyMStkeipyMjI7XHJcbiAgICAgICAgcHg9KGR4PXB4KStjMXg7XHJcbiAgICAgICAgcHk9KGR5PXB5KStjMXk7XHJcbiAgICAgICAgcHo9KGR6PXB6KStjMXo7XHJcbiAgICAgICAgcGQ9bngqKHB4LWMyeCkrbnkqKHB5LWMyeSkrbnoqKHB6LWMyeik7XHJcbiAgICAgICAgaWYocGQ8PTApe1xyXG4gICAgICAgIHR4PXB4LXBkKm54LWMyeDtcclxuICAgICAgICB0eT1weS1wZCpueS1jMnk7XHJcbiAgICAgICAgdHo9cHotcGQqbnotYzJ6O1xyXG4gICAgICAgIGxlbj10eCp0eCt0eSp0eSt0eip0ejtcclxuICAgICAgICBpZihsZW4+cjIqcjIpe1xyXG4gICAgICAgIGxlbj1yMi9fTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgdHgqPWxlbjtcclxuICAgICAgICB0eSo9bGVuO1xyXG4gICAgICAgIHR6Kj1sZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB4PWMyeCt0eDtcclxuICAgICAgICBweT1jMnkrdHk7XHJcbiAgICAgICAgcHo9YzJ6K3R6O1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHB4LHB5LHB6LC1ueCwtbnksLW56LHBkLGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgc3g9dHg7XHJcbiAgICAgICAgc3k9dHk7XHJcbiAgICAgICAgc3o9dHo7XHJcbiAgICAgICAgZGVwdGgxPW54KihzeC1jMngpK255KihzeS1jMnkpK256Kihzei1jMnopO1xyXG4gICAgICAgIHN4LT1kZXB0aDEqbng7XHJcbiAgICAgICAgc3ktPWRlcHRoMSpueTtcclxuICAgICAgICBzei09ZGVwdGgxKm56O1xyXG4gICAgICAgIGlmKGRvdD4wKXtcclxuICAgICAgICBleD10eCtuMXgqaDEqMjtcclxuICAgICAgICBleT10eStuMXkqaDEqMjtcclxuICAgICAgICBlej10eituMXoqaDEqMjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICBleD10eC1uMXgqaDEqMjtcclxuICAgICAgICBleT10eS1uMXkqaDEqMjtcclxuICAgICAgICBlej10ei1uMXoqaDEqMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwdGgyPW54KihleC1jMngpK255KihleS1jMnkpK256Kihlei1jMnopO1xyXG4gICAgICAgIGV4LT1kZXB0aDIqbng7XHJcbiAgICAgICAgZXktPWRlcHRoMipueTtcclxuICAgICAgICBlei09ZGVwdGgyKm56O1xyXG4gICAgICAgIGR4PWMyeC1zeDtcclxuICAgICAgICBkeT1jMnktc3k7XHJcbiAgICAgICAgZHo9YzJ6LXN6O1xyXG4gICAgICAgIHR4PWV4LXN4O1xyXG4gICAgICAgIHR5PWV5LXN5O1xyXG4gICAgICAgIHR6PWV6LXN6O1xyXG4gICAgICAgIGE9ZHgqZHgrZHkqZHkrZHoqZHo7XHJcbiAgICAgICAgYj1keCp0eCtkeSp0eStkeip0ejtcclxuICAgICAgICBlPXR4KnR4K3R5KnR5K3R6KnR6O1xyXG4gICAgICAgIGY9YipiLWUqKGEtcjIqcjIpO1xyXG4gICAgICAgIGlmKGY8MClicmVhaztcclxuICAgICAgICBmPV9NYXRoLnNxcnQoZik7XHJcbiAgICAgICAgdDE9KGIrZikvZTtcclxuICAgICAgICB0Mj0oYi1mKS9lO1xyXG4gICAgICAgIGlmKHQyPHQxKXtcclxuICAgICAgICBsZW49dDE7XHJcbiAgICAgICAgdDE9dDI7XHJcbiAgICAgICAgdDI9bGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0Mj4xKXQyPTE7XHJcbiAgICAgICAgaWYodDE8MCl0MT0wO1xyXG4gICAgICAgIHR4PXN4KyhleC1zeCkqdDE7XHJcbiAgICAgICAgdHk9c3krKGV5LXN5KSp0MTtcclxuICAgICAgICB0ej1zeisoZXotc3opKnQxO1xyXG4gICAgICAgIGV4PXN4KyhleC1zeCkqdDI7XHJcbiAgICAgICAgZXk9c3krKGV5LXN5KSp0MjtcclxuICAgICAgICBlej1zeisoZXotc3opKnQyO1xyXG4gICAgICAgIHN4PXR4O1xyXG4gICAgICAgIHN5PXR5O1xyXG4gICAgICAgIHN6PXR6O1xyXG4gICAgICAgIGxlbj1kZXB0aDErKGRlcHRoMi1kZXB0aDEpKnQxO1xyXG4gICAgICAgIGRlcHRoMj1kZXB0aDErKGRlcHRoMi1kZXB0aDEpKnQyO1xyXG4gICAgICAgIGRlcHRoMT1sZW47XHJcbiAgICAgICAgaWYoZGVwdGgxPDApe1xyXG4gICAgICAgIG1hbmlmb2xkLmFkZFBvaW50KHN4LHN5LHN6LC1ueCwtbnksLW56LGRlcHRoMSxmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGRlcHRoMjwwKXtcclxuICAgICAgICBtYW5pZm9sZC5hZGRQb2ludChleCxleSxleiwtbngsLW55LC1ueixkZXB0aDIsZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG4vKipcbiAqIEEgY29sbGlzaW9uIGRldGVjdG9yIHdoaWNoIGRldGVjdHMgY29sbGlzaW9ucyBiZXR3ZWVuIHNwaGVyZSBhbmQgYm94LlxuICogQGF1dGhvciBzYWhhcmFuXG4gKi9cbmZ1bmN0aW9uIFNwaGVyZUJveENvbGxpc2lvbkRldGVjdG9yICggZmxpcCApIHtcbiAgICBcbiAgICBDb2xsaXNpb25EZXRlY3Rvci5jYWxsKCB0aGlzICk7XG4gICAgdGhpcy5mbGlwID0gZmxpcDtcblxufVxuXG5TcGhlcmVCb3hDb2xsaXNpb25EZXRlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDb2xsaXNpb25EZXRlY3Rvci5wcm90b3R5cGUgKSwge1xuXG4gICAgY29uc3RydWN0b3I6IFNwaGVyZUJveENvbGxpc2lvbkRldGVjdG9yLFxuXG4gICAgZGV0ZWN0Q29sbGlzaW9uOiBmdW5jdGlvbiAoIHNoYXBlMSwgc2hhcGUyLCBtYW5pZm9sZCApIHtcblxuICAgICAgICB2YXIgcztcbiAgICAgICAgdmFyIGI7XG4gICAgICAgIGlmKHRoaXMuZmxpcCl7XG4gICAgICAgICAgICBzPShzaGFwZTIpO1xuICAgICAgICAgICAgYj0oc2hhcGUxKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBzPShzaGFwZTEpO1xuICAgICAgICAgICAgYj0oc2hhcGUyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBEID0gYi5kaW1lbnRpb25zO1xuXG4gICAgICAgIHZhciBwcz1zLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcHN4PXBzLng7XG4gICAgICAgIHZhciBwc3k9cHMueTtcbiAgICAgICAgdmFyIHBzej1wcy56O1xuICAgICAgICB2YXIgcGI9Yi5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBieD1wYi54O1xuICAgICAgICB2YXIgcGJ5PXBiLnk7XG4gICAgICAgIHZhciBwYno9cGIuejtcbiAgICAgICAgdmFyIHJhZD1zLnJhZGl1cztcblxuICAgICAgICB2YXIgaHc9Yi5oYWxmV2lkdGg7XG4gICAgICAgIHZhciBoaD1iLmhhbGZIZWlnaHQ7XG4gICAgICAgIHZhciBoZD1iLmhhbGZEZXB0aDtcblxuICAgICAgICB2YXIgZHg9cHN4LXBieDtcbiAgICAgICAgdmFyIGR5PXBzeS1wYnk7XG4gICAgICAgIHZhciBkej1wc3otcGJ6O1xuICAgICAgICB2YXIgc3g9RFswXSpkeCtEWzFdKmR5K0RbMl0qZHo7XG4gICAgICAgIHZhciBzeT1EWzNdKmR4K0RbNF0qZHkrRFs1XSpkejtcbiAgICAgICAgdmFyIHN6PURbNl0qZHgrRFs3XSpkeStEWzhdKmR6O1xuICAgICAgICB2YXIgY3g7XG4gICAgICAgIHZhciBjeTtcbiAgICAgICAgdmFyIGN6O1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgaW52TGVuO1xuICAgICAgICB2YXIgb3ZlcmxhcD0wO1xuICAgICAgICBpZihzeD5odyl7XG4gICAgICAgICAgICBzeD1odztcbiAgICAgICAgfWVsc2UgaWYoc3g8LWh3KXtcbiAgICAgICAgICAgIHN4PS1odztcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvdmVybGFwPTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc3k+aGgpe1xuICAgICAgICAgICAgc3k9aGg7XG4gICAgICAgIH1lbHNlIGlmKHN5PC1oaCl7XG4gICAgICAgICAgICBzeT0taGg7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgb3ZlcmxhcHw9MjtcbiAgICAgICAgfVxuICAgICAgICBpZihzej5oZCl7XG4gICAgICAgICAgICBzej1oZDtcbiAgICAgICAgfWVsc2UgaWYoc3o8LWhkKXtcbiAgICAgICAgICAgIHN6PS1oZDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvdmVybGFwfD00O1xuICAgICAgICB9XG4gICAgICAgIGlmKG92ZXJsYXA9PTcpe1xuICAgICAgICAgICAgLy8gY2VudGVyIG9mIHNwaGVyZSBpcyBpbiB0aGUgYm94XG4gICAgICAgICAgICBpZihzeDwwKXtcbiAgICAgICAgICAgICAgICBkeD1odytzeDtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGR4PWh3LXN4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc3k8MCl7XG4gICAgICAgICAgICAgICAgZHk9aGgrc3k7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBkeT1oaC1zeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN6PDApe1xuICAgICAgICAgICAgICAgIGR6PWhkK3N6O1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZHo9aGQtc3o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkeDxkeSl7XG4gICAgICAgICAgICAgICAgaWYoZHg8ZHope1xuICAgICAgICAgICAgICAgICAgICBsZW49ZHgtaHc7XG4gICAgICAgICAgICAgICAgaWYoc3g8MCl7XG4gICAgICAgICAgICAgICAgICAgIHN4PS1odztcbiAgICAgICAgICAgICAgICAgICAgZHg9RFswXTtcbiAgICAgICAgICAgICAgICAgICAgZHk9RFsxXTtcbiAgICAgICAgICAgICAgICAgICAgZHo9RFsyXTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgc3g9aHc7XG4gICAgICAgICAgICAgICAgICAgIGR4PS1EWzBdO1xuICAgICAgICAgICAgICAgICAgICBkeT0tRFsxXTtcbiAgICAgICAgICAgICAgICAgICAgZHo9LURbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgbGVuPWR6LWhkO1xuICAgICAgICAgICAgICAgIGlmKHN6PDApe1xuICAgICAgICAgICAgICAgICAgICBzej0taGQ7XG4gICAgICAgICAgICAgICAgICAgIGR4PURbNl07XG4gICAgICAgICAgICAgICAgICAgIGR5PURbN107XG4gICAgICAgICAgICAgICAgICAgIGR6PURbOF07XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHN6PWhkO1xuICAgICAgICAgICAgICAgICAgICBkeD0tRFs2XTtcbiAgICAgICAgICAgICAgICAgICAgZHk9LURbN107XG4gICAgICAgICAgICAgICAgICAgIGR6PS1EWzhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGlmKGR5PGR6KXtcbiAgICAgICAgICAgICAgICAgICAgbGVuPWR5LWhoO1xuICAgICAgICAgICAgICAgICAgICBpZihzeTwwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5PS1oaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4PURbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBkeT1EWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHo9RFs1XTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeT1oaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4PS1EWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHk9LURbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkej0tRFs1XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBsZW49ZHotaGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmKHN6PDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3o9LWhkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHg9RFs2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5PURbN107XG4gICAgICAgICAgICAgICAgICAgICAgICBkej1EWzhdO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN6PWhkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHg9LURbNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBkeT0tRFs3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR6PS1EWzhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjeD1wYngrc3gqRFswXStzeSpEWzNdK3N6KkRbNl07XG4gICAgICAgIGN5PXBieStzeCpEWzFdK3N5KkRbNF0rc3oqRFs3XTtcbiAgICAgICAgY3o9cGJ6K3N4KkRbMl0rc3kqRFs1XStzeipEWzhdO1xuICAgICAgICBtYW5pZm9sZC5hZGRQb2ludChwc3grcmFkKmR4LHBzeStyYWQqZHkscHN6K3JhZCpkeixkeCxkeSxkeixsZW4tcmFkLHRoaXMuZmxpcCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY3g9cGJ4K3N4KkRbMF0rc3kqRFszXStzeipEWzZdO1xuICAgICAgICAgICAgY3k9cGJ5K3N4KkRbMV0rc3kqRFs0XStzeipEWzddO1xuICAgICAgICAgICAgY3o9cGJ6K3N4KkRbMl0rc3kqRFs1XStzeipEWzhdO1xuICAgICAgICAgICAgZHg9Y3gtcHMueDtcbiAgICAgICAgICAgIGR5PWN5LXBzLnk7XG4gICAgICAgICAgICBkej1jei1wcy56O1xuICAgICAgICAgICAgbGVuPWR4KmR4K2R5KmR5K2R6KmR6O1xuICAgICAgICAgICAgaWYobGVuPjAmJmxlbjxyYWQqcmFkKXtcbiAgICAgICAgICAgICAgICBsZW49X01hdGguc3FydChsZW4pO1xuICAgICAgICAgICAgICAgIGludkxlbj0xL2xlbjtcbiAgICAgICAgICAgICAgICBkeCo9aW52TGVuO1xuICAgICAgICAgICAgICAgIGR5Kj1pbnZMZW47XG4gICAgICAgICAgICAgICAgZHoqPWludkxlbjtcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5hZGRQb2ludChwc3grcmFkKmR4LHBzeStyYWQqZHkscHN6K3JhZCpkeixkeCxkeSxkeixsZW4tcmFkLHRoaXMuZmxpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIFNwaGVyZUN5bGluZGVyQ29sbGlzaW9uRGV0ZWN0b3IgKCBmbGlwICl7XG4gICAgXG4gICAgQ29sbGlzaW9uRGV0ZWN0b3IuY2FsbCggdGhpcyApO1xuICAgIHRoaXMuZmxpcCA9IGZsaXA7XG5cbn1cblxuU3BoZXJlQ3lsaW5kZXJDb2xsaXNpb25EZXRlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDb2xsaXNpb25EZXRlY3Rvci5wcm90b3R5cGUgKSwge1xuXG4gICAgY29uc3RydWN0b3I6IFNwaGVyZUN5bGluZGVyQ29sbGlzaW9uRGV0ZWN0b3IsXG5cbiAgICBkZXRlY3RDb2xsaXNpb246IGZ1bmN0aW9uICggc2hhcGUxLCBzaGFwZTIsIG1hbmlmb2xkICkge1xuICAgICAgICBcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBpZiggdGhpcy5mbGlwICl7XG4gICAgICAgICAgICBzID0gc2hhcGUyO1xuICAgICAgICAgICAgYyA9IHNoYXBlMTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBzID0gc2hhcGUxO1xuICAgICAgICAgICAgYyA9IHNoYXBlMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHMgPSBzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcHN4ID0gcHMueDtcbiAgICAgICAgdmFyIHBzeSA9IHBzLnk7XG4gICAgICAgIHZhciBwc3ogPSBwcy56O1xuICAgICAgICB2YXIgcGMgPSBjLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcGN4ID0gcGMueDtcbiAgICAgICAgdmFyIHBjeSA9IHBjLnk7XG4gICAgICAgIHZhciBwY3ogPSBwYy56O1xuICAgICAgICB2YXIgZGlyeCA9IGMubm9ybWFsRGlyZWN0aW9uLng7XG4gICAgICAgIHZhciBkaXJ5ID0gYy5ub3JtYWxEaXJlY3Rpb24ueTtcbiAgICAgICAgdmFyIGRpcnogPSBjLm5vcm1hbERpcmVjdGlvbi56O1xuICAgICAgICB2YXIgcmFkcyA9IHMucmFkaXVzO1xuICAgICAgICB2YXIgcmFkYyA9IGMucmFkaXVzO1xuICAgICAgICB2YXIgcmFkMiA9IHJhZHMgKyByYWRjO1xuICAgICAgICB2YXIgaGFsZmggPSBjLmhhbGZIZWlnaHQ7XG4gICAgICAgIHZhciBkeCA9IHBzeCAtIHBjeDtcbiAgICAgICAgdmFyIGR5ID0gcHN5IC0gcGN5O1xuICAgICAgICB2YXIgZHogPSBwc3ogLSBwY3o7XG4gICAgICAgIHZhciBkb3QgPSBkeCAqIGRpcnggKyBkeSAqIGRpcnkgKyBkeiAqIGRpcno7XG4gICAgICAgIGlmICggZG90IDwgLWhhbGZoIC0gcmFkcyB8fCBkb3QgPiBoYWxmaCArIHJhZHMgKSByZXR1cm47XG4gICAgICAgIHZhciBjeCA9IHBjeCArIGRvdCAqIGRpcng7XG4gICAgICAgIHZhciBjeSA9IHBjeSArIGRvdCAqIGRpcnk7XG4gICAgICAgIHZhciBjeiA9IHBjeiArIGRvdCAqIGRpcno7XG4gICAgICAgIHZhciBkMnggPSBwc3ggLSBjeDtcbiAgICAgICAgdmFyIGQyeSA9IHBzeSAtIGN5O1xuICAgICAgICB2YXIgZDJ6ID0gcHN6IC0gY3o7XG4gICAgICAgIHZhciBsZW4gPSBkMnggKiBkMnggKyBkMnkgKiBkMnkgKyBkMnogKiBkMno7XG4gICAgICAgIGlmICggbGVuID4gcmFkMiAqIHJhZDIgKSByZXR1cm47XG4gICAgICAgIGlmICggbGVuID4gcmFkYyAqIHJhZGMgKSB7XG4gICAgICAgICAgICBsZW4gPSByYWRjIC8gX01hdGguc3FydCggbGVuICk7XG4gICAgICAgICAgICBkMnggKj0gbGVuO1xuICAgICAgICAgICAgZDJ5ICo9IGxlbjtcbiAgICAgICAgICAgIGQyeiAqPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYoIGRvdCA8IC1oYWxmaCApIGRvdCA9IC1oYWxmaDtcbiAgICAgICAgZWxzZSBpZiggZG90ID4gaGFsZmggKSBkb3QgPSBoYWxmaDtcbiAgICAgICAgY3ggPSBwY3ggKyBkb3QgKiBkaXJ4ICsgZDJ4O1xuICAgICAgICBjeSA9IHBjeSArIGRvdCAqIGRpcnkgKyBkMnk7XG4gICAgICAgIGN6ID0gcGN6ICsgZG90ICogZGlyeiArIGQyejtcbiAgICAgICAgZHggPSBjeCAtIHBzeDtcbiAgICAgICAgZHkgPSBjeSAtIHBzeTtcbiAgICAgICAgZHogPSBjeiAtIHBzejtcbiAgICAgICAgbGVuID0gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuICAgICAgICB2YXIgaW52TGVuO1xuICAgICAgICBpZiAoIGxlbiA+IDAgJiYgbGVuIDwgcmFkcyAqIHJhZHMgKSB7XG4gICAgICAgICAgICBsZW4gPSBfTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgICBpbnZMZW4gPSAxIC8gbGVuO1xuICAgICAgICAgICAgZHggKj0gaW52TGVuO1xuICAgICAgICAgICAgZHkgKj0gaW52TGVuO1xuICAgICAgICAgICAgZHogKj0gaW52TGVuO1xuICAgICAgICAgICAgLy8vcmVzdWx0LmFkZENvbnRhY3RJbmZvKHBzeCtkeCpyYWRzLHBzeStkeSpyYWRzLHBzeitkeipyYWRzLGR4LGR5LGR6LGxlbi1yYWRzLHMsYywwLDAsZmFsc2UpO1xuICAgICAgICAgICAgbWFuaWZvbGQuYWRkUG9pbnQoIHBzeCArIGR4ICogcmFkcywgcHN5ICsgZHkgKiByYWRzLCBwc3ogKyBkeiAqIHJhZHMsIGR4LCBkeSwgZHosIGxlbiAtIHJhZHMsIHRoaXMuZmxpcCApO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxufSk7XG5cbi8qKlxuICogQSBjb2xsaXNpb24gZGV0ZWN0b3Igd2hpY2ggZGV0ZWN0cyBjb2xsaXNpb25zIGJldHdlZW4gdHdvIHNwaGVyZXMuXG4gKiBAYXV0aG9yIHNhaGFyYW5cbiAqL1xuIFxuZnVuY3Rpb24gU3BoZXJlU3BoZXJlQ29sbGlzaW9uRGV0ZWN0b3IgKCl7XG5cbiAgICBDb2xsaXNpb25EZXRlY3Rvci5jYWxsKCB0aGlzICk7XG5cbn1cblxuU3BoZXJlU3BoZXJlQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlICksIHtcblxuICAgIGNvbnN0cnVjdG9yOiBTcGhlcmVTcGhlcmVDb2xsaXNpb25EZXRlY3RvcixcblxuICAgIGRldGVjdENvbGxpc2lvbjogZnVuY3Rpb24gKCBzaGFwZTEsIHNoYXBlMiwgbWFuaWZvbGQgKSB7XG5cbiAgICAgICAgdmFyIHMxID0gc2hhcGUxO1xuICAgICAgICB2YXIgczIgPSBzaGFwZTI7XG4gICAgICAgIHZhciBwMSA9IHMxLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcDIgPSBzMi5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gICAgICAgIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuICAgICAgICB2YXIgZHogPSBwMi56IC0gcDEuejtcbiAgICAgICAgdmFyIGxlbiA9IGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcbiAgICAgICAgdmFyIHIxID0gczEucmFkaXVzO1xuICAgICAgICB2YXIgcjIgPSBzMi5yYWRpdXM7XG4gICAgICAgIHZhciByYWQgPSByMSArIHIyO1xuICAgICAgICBpZiAoIGxlbiA+IDAgJiYgbGVuIDwgcmFkICogcmFkICl7XG4gICAgICAgICAgICBsZW4gPSBfTWF0aC5zcXJ0KCBsZW4gKTtcbiAgICAgICAgICAgIHZhciBpbnZMZW4gPSAxIC8gbGVuO1xuICAgICAgICAgICAgZHggKj0gaW52TGVuO1xuICAgICAgICAgICAgZHkgKj0gaW52TGVuO1xuICAgICAgICAgICAgZHogKj0gaW52TGVuO1xuICAgICAgICAgICAgbWFuaWZvbGQuYWRkUG9pbnQoIHAxLnggKyBkeCAqIHIxLCBwMS55ICsgZHkgKiByMSwgcDEueiArIGR6ICogcjEsIGR4LCBkeSwgZHosIGxlbiAtIHJhZCwgZmFsc2UgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxuLyoqXHJcbiAqIEEgY29sbGlzaW9uIGRldGVjdG9yIHdoaWNoIGRldGVjdHMgY29sbGlzaW9ucyBiZXR3ZWVuIHR3byBzcGhlcmVzLlxyXG4gKiBAYXV0aG9yIHNhaGFyYW4gXHJcbiAqIEBhdXRob3IgbG8tdGhcclxuICovXHJcbiBcclxuZnVuY3Rpb24gU3BoZXJlUGxhbmVDb2xsaXNpb25EZXRlY3RvciAoIGZsaXAgKXtcclxuXHJcbiAgICBDb2xsaXNpb25EZXRlY3Rvci5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy5mbGlwID0gZmxpcDtcclxuXHJcbiAgICB0aGlzLm4gPSBuZXcgVmVjMygpO1xyXG4gICAgdGhpcy5wID0gbmV3IFZlYzMoKTtcclxuXHJcbn1cclxuXHJcblNwaGVyZVBsYW5lQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlICksIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogU3BoZXJlUGxhbmVDb2xsaXNpb25EZXRlY3RvcixcclxuXHJcbiAgICBkZXRlY3RDb2xsaXNpb246IGZ1bmN0aW9uICggc2hhcGUxLCBzaGFwZTIsIG1hbmlmb2xkICkge1xyXG5cclxuICAgICAgICB2YXIgbiA9IHRoaXMubjtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucDtcclxuXHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLmZsaXAgPyBzaGFwZTIgOiBzaGFwZTE7XHJcbiAgICAgICAgdmFyIHBuID0gdGhpcy5mbGlwID8gc2hhcGUxIDogc2hhcGUyO1xyXG4gICAgICAgIHZhciByYWQgPSBzLnJhZGl1cztcclxuICAgICAgICB2YXIgbGVuO1xyXG5cclxuICAgICAgICBuLnN1Yiggcy5wb3NpdGlvbiwgcG4ucG9zaXRpb24gKTtcclxuICAgICAgICAvL3ZhciBoID0gX01hdGguZG90VmVjdG9ycyggcG4ubm9ybWFsLCBuICk7XHJcblxyXG4gICAgICAgIG4ueCAqPSBwbi5ub3JtYWwueDsvLysgcmFkO1xyXG4gICAgICAgIG4ueSAqPSBwbi5ub3JtYWwueTtcclxuICAgICAgICBuLnogKj0gcG4ubm9ybWFsLno7Ly8rIHJhZDtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxlbiA9IG4ubGVuZ3RoU3EoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiggbGVuID4gMCAmJiBsZW4gPCByYWQgKiByYWQpey8vJiYgaCA+IHJhZCpyYWQgKXtcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZW4gPSBfTWF0aC5zcXJ0KCBsZW4gKTtcclxuICAgICAgICAgICAgLy9sZW4gPSBfTWF0aC5zcXJ0KCBoICk7XHJcbiAgICAgICAgICAgIG4uY29weShwbi5ub3JtYWwpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAvL24uc2NhbGVFcXVhbCggMS9sZW4gKTtcclxuXHJcbiAgICAgICAgICAgIC8vKDAsIC0xLCAwKVxyXG5cclxuICAgICAgICAgICAgLy9uLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBwLmNvcHkoIHMucG9zaXRpb24gKS5hZGRTY2FsZWRWZWN0b3IoIG4sIHJhZCApO1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5hZGRQb2ludFZlYyggcCwgbiwgbGVuIC0gcmFkLCB0aGlzLmZsaXAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xuXG4vKipcclxuICogQSBjb2xsaXNpb24gZGV0ZWN0b3Igd2hpY2ggZGV0ZWN0cyBjb2xsaXNpb25zIGJldHdlZW4gdHdvIHNwaGVyZXMuXHJcbiAqIEBhdXRob3Igc2FoYXJhbiBcclxuICogQGF1dGhvciBsby10aFxyXG4gKi9cclxuIFxyXG5mdW5jdGlvbiBCb3hQbGFuZUNvbGxpc2lvbkRldGVjdG9yICggZmxpcCApe1xyXG5cclxuICAgIENvbGxpc2lvbkRldGVjdG9yLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLmZsaXAgPSBmbGlwO1xyXG5cclxuICAgIHRoaXMubiA9IG5ldyBWZWMzKCk7XHJcbiAgICB0aGlzLnAgPSBuZXcgVmVjMygpO1xyXG5cclxuICAgIHRoaXMuZGl4ID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMuZGl5ID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMuZGl6ID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICB0aGlzLmNjID0gbmV3IFZlYzMoKTtcclxuICAgIHRoaXMuY2MyID0gbmV3IFZlYzMoKTtcclxuXHJcbn1cclxuXHJcbkJveFBsYW5lQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ29sbGlzaW9uRGV0ZWN0b3IucHJvdG90eXBlICksIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogQm94UGxhbmVDb2xsaXNpb25EZXRlY3RvcixcclxuXHJcbiAgICBkZXRlY3RDb2xsaXNpb246IGZ1bmN0aW9uICggc2hhcGUxLCBzaGFwZTIsIG1hbmlmb2xkICkge1xyXG5cclxuICAgICAgICB2YXIgbiA9IHRoaXMubjtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucDtcclxuICAgICAgICB2YXIgY2MgPSB0aGlzLmNjO1xyXG5cclxuICAgICAgICB2YXIgYiA9IHRoaXMuZmxpcCA/IHNoYXBlMiA6IHNoYXBlMTtcclxuICAgICAgICB2YXIgcG4gPSB0aGlzLmZsaXAgPyBzaGFwZTEgOiBzaGFwZTI7XHJcblxyXG4gICAgICAgIHZhciBEID0gYi5kaW1lbnRpb25zO1xyXG4gICAgICAgIHZhciBodyA9IGIuaGFsZldpZHRoO1xyXG4gICAgICAgIHZhciBoaCA9IGIuaGFsZkhlaWdodDtcclxuICAgICAgICB2YXIgaGQgPSBiLmhhbGZEZXB0aDtcclxuICAgICAgICB2YXIgbGVuO1xyXG4gICAgICAgIHZhciBvdmVybGFwID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5kaXguc2V0KCBEWzBdLCBEWzFdLCBEWzJdICk7XHJcbiAgICAgICAgdGhpcy5kaXkuc2V0KCBEWzNdLCBEWzRdLCBEWzVdICk7XHJcbiAgICAgICAgdGhpcy5kaXouc2V0KCBEWzZdLCBEWzddLCBEWzhdICk7XHJcblxyXG4gICAgICAgIG4uc3ViKCBiLnBvc2l0aW9uLCBwbi5wb3NpdGlvbiApO1xyXG5cclxuICAgICAgICBuLnggKj0gcG4ubm9ybWFsLng7Ly8rIHJhZDtcclxuICAgICAgICBuLnkgKj0gcG4ubm9ybWFsLnk7XHJcbiAgICAgICAgbi56ICo9IHBuLm5vcm1hbC56Oy8vKyByYWQ7XHJcblxyXG4gICAgICAgIGNjLnNldChcclxuICAgICAgICAgICAgX01hdGguZG90VmVjdG9ycyggdGhpcy5kaXgsIG4gKSxcclxuICAgICAgICAgICAgX01hdGguZG90VmVjdG9ycyggdGhpcy5kaXksIG4gKSxcclxuICAgICAgICAgICAgX01hdGguZG90VmVjdG9ycyggdGhpcy5kaXosIG4gKVxyXG4gICAgICAgICk7XHJcblxyXG5cclxuICAgICAgICBpZiggY2MueCA+IGh3ICkgY2MueCA9IGh3O1xyXG4gICAgICAgIGVsc2UgaWYoIGNjLnggPCAtaHcgKSBjYy54ID0gLWh3O1xyXG4gICAgICAgIGVsc2Ugb3ZlcmxhcCA9IDE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoIGNjLnkgPiBoaCApIGNjLnkgPSBoaDtcclxuICAgICAgICBlbHNlIGlmKCBjYy55IDwgLWhoICkgY2MueSA9IC1oaDtcclxuICAgICAgICBlbHNlIG92ZXJsYXAgfD0gMjtcclxuICAgICAgICBcclxuICAgICAgICBpZiggY2MueiA+IGhkICkgY2MueiA9IGhkO1xyXG4gICAgICAgIGVsc2UgaWYoIGNjLnogPCAtaGQgKSBjYy56ID0gLWhkO1xyXG4gICAgICAgIGVsc2Ugb3ZlcmxhcCB8PSA0O1xyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgaWYoIG92ZXJsYXAgPT09IDcgKXtcclxuXHJcbiAgICAgICAgICAgIC8vIGNlbnRlciBvZiBzcGhlcmUgaXMgaW4gdGhlIGJveFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbi5zZXQoXHJcbiAgICAgICAgICAgICAgICBjYy54IDwgMCA/IGh3ICsgY2MueCA6IGh3IC0gY2MueCxcclxuICAgICAgICAgICAgICAgIGNjLnkgPCAwID8gaGggKyBjYy55IDogaGggLSBjYy55LFxyXG4gICAgICAgICAgICAgICAgY2MueiA8IDAgPyBoZCArIGNjLnogOiBoZCAtIGNjLnpcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKCBuLnggPCBuLnkgKXtcclxuICAgICAgICAgICAgICAgIGlmKCBuLnggPCBuLnogKXtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBuLnggLSBodztcclxuICAgICAgICAgICAgICAgICAgICBpZiggY2MueCA8IDAgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MueCA9IC1odztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbi5jb3B5KCB0aGlzLmRpeCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy54ID0gaHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uc3ViRXF1YWwoIHRoaXMuZGl4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbi56IC0gaGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIGNjLnogPCAwICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLnogPSAtaGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY29weSggdGhpcy5kaXogKTtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MueiA9IGhkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuLnN1YkVxdWFsKCB0aGlzLmRpeiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZiggbi55IDwgbi56ICl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbi55IC0gaGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIGNjLnkgPCAwICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLnkgPSAtaGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY29weSggdGhpcy5kaXkgKTtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MueSA9IGhoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuLnN1YkVxdWFsKCB0aGlzLmRpeSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IG4ueiAtIGhkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCBjYy56IDwgMCApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy56ID0gLWhkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuLmNvcHkoIHRoaXMuZGl6ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLnogPSBoZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbi5zdWJFcXVhbCggdGhpcy5kaXogKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHAuY29weSggcG4ucG9zaXRpb24gKS5hZGRTY2FsZWRWZWN0b3IoIG4sIDEgKTtcclxuICAgICAgICAgICAgbWFuaWZvbGQuYWRkUG9pbnRWZWMoIHAsIG4sIGxlbiwgdGhpcy5mbGlwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcblxuLy9pbXBvcnQgeyBUZXRyYVNoYXBlIH0gZnJvbSAnLi4vY29sbGlzaW9uL3NoYXBlL1RldHJhU2hhcGUnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjbGFzcyBvZiBwaHlzaWNhbCBjb21wdXRpbmcgd29ybGQuXHJcbiAqIFlvdSBtdXN0IGJlIGFkZGVkIHRvIHRoZSB3b3JsZCBwaHlzaWNhbCBhbGwgY29tcHV0aW5nIG9iamVjdHNcclxuICpcclxuICogQGF1dGhvciBzYWhhcmFuXHJcbiAqIEBhdXRob3IgbG8tdGhcclxuICovXHJcblxyXG4gLy8gdGltZXN0ZXAsIGJyb2FkcGhhc2UsIGl0ZXJhdGlvbnMsIHdvcmxkc2NhbGUsIHJhbmRvbSwgc3RhdFxyXG5cclxuZnVuY3Rpb24gV29ybGQgKCBvICkge1xyXG5cclxuICAgIGlmKCAhKG8gaW5zdGFuY2VvZiBPYmplY3QpICkgbyA9IHt9O1xyXG5cclxuICAgIC8vIHRoaXMgd29ybGQgc2NhbGUgZGVmYXV0IGlzIDAuMSB0byAxMCBtZXRlcnMgbWF4IGZvciBkeW5hbWlxdWUgYm9keVxyXG4gICAgdGhpcy5zY2FsZSA9IG8ud29ybGRzY2FsZSB8fCAxO1xyXG4gICAgdGhpcy5pbnZTY2FsZSA9IDEvdGhpcy5zY2FsZTtcclxuXHJcbiAgICAvLyBUaGUgdGltZSBiZXR3ZWVuIGVhY2ggc3RlcFxyXG4gICAgdGhpcy50aW1lU3RlcCA9IG8udGltZXN0ZXAgfHwgMC4wMTY2NjsgLy8gMS82MDtcclxuICAgIHRoaXMudGltZXJhdGUgPSB0aGlzLnRpbWVTdGVwICogMTAwMDtcclxuICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucHJlTG9vcCA9IG51bGw7Ly9mdW5jdGlvbigpe307XHJcbiAgICB0aGlzLnBvc3RMb29wID0gbnVsbDsvL2Z1bmN0aW9uKCl7fTtcclxuXHJcbiAgICAvLyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIGNvbnN0cmFpbnQgc29sdmVycy5cclxuICAgIHRoaXMubnVtSXRlcmF0aW9ucyA9IG8uaXRlcmF0aW9ucyB8fCA4O1xyXG5cclxuICAgICAvLyBJdCBpcyBhIHdpZGUtYXJlYSBjb2xsaXNpb24ganVkZ21lbnQgdGhhdCBpcyB1c2VkIGluIG9yZGVyIHRvIHJlZHVjZSBhcyBtdWNoIGFzIHBvc3NpYmxlIGEgZGV0YWlsZWQgY29sbGlzaW9uIGp1ZGdtZW50LlxyXG4gICAgc3dpdGNoKCBvLmJyb2FkcGhhc2UgfHwgMiApe1xyXG4gICAgICAgIGNhc2UgMTogdGhpcy5icm9hZFBoYXNlID0gbmV3IEJydXRlRm9yY2VCcm9hZFBoYXNlKCk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjogZGVmYXVsdDogdGhpcy5icm9hZFBoYXNlID0gbmV3IFNBUEJyb2FkUGhhc2UoKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOiB0aGlzLmJyb2FkUGhhc2UgPSBuZXcgREJWVEJyb2FkUGhhc2UoKTsgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5CdHlwZXMgPSBbJ05vbmUnLCdCcnV0ZUZvcmNlJywnU3dlZXAgJiBQcnVuZScsICdCb3VuZGluZyBWb2x1bWUgVHJlZScgXTtcclxuICAgIHRoaXMuYnJvYWRQaGFzZVR5cGUgPSB0aGlzLkJ0eXBlc1sgby5icm9hZHBoYXNlIHx8IDIgXTtcclxuXHJcbiAgICAvLyBUaGlzIGlzIHRoZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvZiB0aGUgcGVyZm9ybWFuY2UuXHJcbiAgICB0aGlzLnBlcmZvcm1hbmNlID0gbnVsbDtcclxuICAgIHRoaXMuaXNTdGF0ID0gby5pbmZvID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG8uaW5mbztcclxuICAgIGlmKCB0aGlzLmlzU3RhdCApIHRoaXMucGVyZm9ybWFuY2UgPSBuZXcgSW5mb0Rpc3BsYXkoIHRoaXMgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGNvbnN0cmFpbnRzIHJhbmRvbWl6ZXIgaXMgZW5hYmxlZCBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGVuYWJsZVJhbmRvbWl6ZXJcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmVuYWJsZVJhbmRvbWl6ZXIgPSBvLnJhbmRvbSAhPT0gdW5kZWZpbmVkID8gby5yYW5kb20gOiB0cnVlO1xyXG5cclxuICAgIC8vIFRoZSByaWdpZCBib2R5IGxpc3RcclxuICAgIHRoaXMucmlnaWRCb2RpZXM9bnVsbDtcclxuICAgIC8vIG51bWJlciBvZiByaWdpZCBib2R5XHJcbiAgICB0aGlzLm51bVJpZ2lkQm9kaWVzPTA7XHJcbiAgICAvLyBUaGUgY29udGFjdCBsaXN0XHJcbiAgICB0aGlzLmNvbnRhY3RzPW51bGw7XHJcbiAgICB0aGlzLnVudXNlZENvbnRhY3RzPW51bGw7XHJcbiAgICAvLyBUaGUgbnVtYmVyIG9mIGNvbnRhY3RcclxuICAgIHRoaXMubnVtQ29udGFjdHM9MDtcclxuICAgIC8vIFRoZSBudW1iZXIgb2YgY29udGFjdCBwb2ludHNcclxuICAgIHRoaXMubnVtQ29udGFjdFBvaW50cz0wO1xyXG4gICAgLy8gIFRoZSBqb2ludCBsaXN0XHJcbiAgICB0aGlzLmpvaW50cz1udWxsO1xyXG4gICAgLy8gVGhlIG51bWJlciBvZiBqb2ludHMuXHJcbiAgICB0aGlzLm51bUpvaW50cz0wO1xyXG4gICAgLy8gVGhlIG51bWJlciBvZiBzaW11bGF0aW9uIGlzbGFuZHMuXHJcbiAgICB0aGlzLm51bUlzbGFuZHM9MDtcclxuXHJcblxyXG4gICAgLy8gVGhlIGdyYXZpdHkgaW4gdGhlIHdvcmxkLlxyXG4gICAgdGhpcy5ncmF2aXR5ID0gbmV3IFZlYzMoMCwtOS44LDApO1xyXG4gICAgaWYoIG8uZ3Jhdml0eSAhPT0gdW5kZWZpbmVkICkgdGhpcy5ncmF2aXR5LmZyb21BcnJheSggby5ncmF2aXR5ICk7XHJcblxyXG5cclxuXHJcbiAgICB2YXIgbnVtU2hhcGVUeXBlcyA9IDU7Ly80Oy8vMztcclxuICAgIHRoaXMuZGV0ZWN0b3JzPVtdO1xyXG4gICAgdGhpcy5kZXRlY3RvcnMubGVuZ3RoID0gbnVtU2hhcGVUeXBlcztcclxuICAgIHZhciBpID0gbnVtU2hhcGVUeXBlcztcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgdGhpcy5kZXRlY3RvcnNbaV09W107XHJcbiAgICAgICAgdGhpcy5kZXRlY3RvcnNbaV0ubGVuZ3RoID0gbnVtU2hhcGVUeXBlcztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRldGVjdG9yc1tTSEFQRV9TUEhFUkVdW1NIQVBFX1NQSEVSRV0gPSBuZXcgU3BoZXJlU3BoZXJlQ29sbGlzaW9uRGV0ZWN0b3IoKTtcclxuICAgIHRoaXMuZGV0ZWN0b3JzW1NIQVBFX1NQSEVSRV1bU0hBUEVfQk9YXSA9IG5ldyBTcGhlcmVCb3hDb2xsaXNpb25EZXRlY3RvcihmYWxzZSk7XHJcbiAgICB0aGlzLmRldGVjdG9yc1tTSEFQRV9CT1hdW1NIQVBFX1NQSEVSRV0gPSBuZXcgU3BoZXJlQm94Q29sbGlzaW9uRGV0ZWN0b3IodHJ1ZSk7XHJcbiAgICB0aGlzLmRldGVjdG9yc1tTSEFQRV9CT1hdW1NIQVBFX0JPWF0gPSBuZXcgQm94Qm94Q29sbGlzaW9uRGV0ZWN0b3IoKTtcclxuXHJcbiAgICAvLyBDWUxJTkRFUiBhZGRcclxuICAgIHRoaXMuZGV0ZWN0b3JzW1NIQVBFX0NZTElOREVSXVtTSEFQRV9DWUxJTkRFUl0gPSBuZXcgQ3lsaW5kZXJDeWxpbmRlckNvbGxpc2lvbkRldGVjdG9yKCk7XHJcblxyXG4gICAgdGhpcy5kZXRlY3RvcnNbU0hBUEVfQ1lMSU5ERVJdW1NIQVBFX0JPWF0gPSBuZXcgQm94Q3lsaW5kZXJDb2xsaXNpb25EZXRlY3Rvcih0cnVlKTtcclxuICAgIHRoaXMuZGV0ZWN0b3JzW1NIQVBFX0JPWF1bU0hBUEVfQ1lMSU5ERVJdID0gbmV3IEJveEN5bGluZGVyQ29sbGlzaW9uRGV0ZWN0b3IoZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuZGV0ZWN0b3JzW1NIQVBFX0NZTElOREVSXVtTSEFQRV9TUEhFUkVdID0gbmV3IFNwaGVyZUN5bGluZGVyQ29sbGlzaW9uRGV0ZWN0b3IodHJ1ZSk7XHJcbiAgICB0aGlzLmRldGVjdG9yc1tTSEFQRV9TUEhFUkVdW1NIQVBFX0NZTElOREVSXSA9IG5ldyBTcGhlcmVDeWxpbmRlckNvbGxpc2lvbkRldGVjdG9yKGZhbHNlKTtcclxuXHJcbiAgICAvLyBQTEFORSBhZGRcclxuXHJcbiAgICB0aGlzLmRldGVjdG9yc1tTSEFQRV9QTEFORV1bU0hBUEVfU1BIRVJFXSA9IG5ldyBTcGhlcmVQbGFuZUNvbGxpc2lvbkRldGVjdG9yKHRydWUpO1xyXG4gICAgdGhpcy5kZXRlY3RvcnNbU0hBUEVfU1BIRVJFXVtTSEFQRV9QTEFORV0gPSBuZXcgU3BoZXJlUGxhbmVDb2xsaXNpb25EZXRlY3RvcihmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5kZXRlY3RvcnNbU0hBUEVfUExBTkVdW1NIQVBFX0JPWF0gPSBuZXcgQm94UGxhbmVDb2xsaXNpb25EZXRlY3Rvcih0cnVlKTtcclxuICAgIHRoaXMuZGV0ZWN0b3JzW1NIQVBFX0JPWF1bU0hBUEVfUExBTkVdID0gbmV3IEJveFBsYW5lQ29sbGlzaW9uRGV0ZWN0b3IoZmFsc2UpO1xyXG5cclxuICAgIC8vIFRFVFJBIGFkZFxyXG4gICAgLy90aGlzLmRldGVjdG9yc1tTSEFQRV9URVRSQV1bU0hBUEVfVEVUUkFdID0gbmV3IFRldHJhVGV0cmFDb2xsaXNpb25EZXRlY3RvcigpO1xyXG5cclxuXHJcbiAgICB0aGlzLnJhbmRYID0gNjU1MzU7XHJcbiAgICB0aGlzLnJhbmRBID0gOTg3NjU7XHJcbiAgICB0aGlzLnJhbmRCID0gMTIzNDU2Nzg5O1xyXG5cclxuICAgIHRoaXMuaXNsYW5kUmlnaWRCb2RpZXMgPSBbXTtcclxuICAgIHRoaXMuaXNsYW5kU3RhY2sgPSBbXTtcclxuICAgIHRoaXMuaXNsYW5kQ29uc3RyYWludHMgPSBbXTtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIFdvcmxkLnByb3RvdHlwZSwge1xyXG5cclxuICAgIFdvcmxkOiB0cnVlLFxyXG5cclxuICAgIHBsYXk6IGZ1bmN0aW9uKCl7XHJcbiBcclxuICAgICAgICBpZiggdGhpcy50aW1lciAhPT0gbnVsbCApIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwoIGZ1bmN0aW9uKCl7IF90aGlzLnN0ZXAoKTsgfSAsIHRoaXMudGltZXJhdGUgKTtcclxuICAgICAgICAvL3RoaXMudGltZXIgPSBzZXRJbnRlcnZhbCggdGhpcy5sb29wLmJpbmQodGhpcykgLCB0aGlzLnRpbWVyYXRlICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICBpZiggdGhpcy50aW1lciA9PT0gbnVsbCApIHJldHVybjtcclxuXHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCggdGhpcy50aW1lciApO1xyXG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0R3Jhdml0eTogZnVuY3Rpb24gKCBhciApIHtcclxuXHJcbiAgICAgICAgdGhpcy5ncmF2aXR5LmZyb21BcnJheSggYXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldEluZm86IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdGF0ID8gdGhpcy5wZXJmb3JtYW5jZS5zaG93KCkgOiAnJztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlc2V0IHRoZSB3b3JsZCBhbmQgcmVtb3ZlIGFsbCByaWdpZCBib2RpZXMsIHNoYXBlcywgam9pbnRzIGFuZCBhbnkgb2JqZWN0IGZyb20gdGhlIHdvcmxkLlxyXG4gICAgY2xlYXI6ZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5wcmVMb29wID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBvc3RMb29wID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5yYW5kWCA9IDY1NTM1O1xyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmpvaW50cyE9PW51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUpvaW50KCB0aGlzLmpvaW50cyApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSh0aGlzLmNvbnRhY3RzIT09bnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdCggdGhpcy5jb250YWN0cyApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSh0aGlzLnJpZ2lkQm9kaWVzIT09bnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmlnaWRCb2R5KCB0aGlzLnJpZ2lkQm9kaWVzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogSSdsbCBhZGQgYSByaWdpZCBib2R5IHRvIHRoZSB3b3JsZC5cclxuICAgICogUmlnaWQgYm9keSB0aGF0IGhhcyBiZWVuIGFkZGVkIHdpbGwgYmUgdGhlIG9wZXJhbmRzIG9mIGVhY2ggc3RlcC5cclxuICAgICogQHBhcmFtICByaWdpZEJvZHkgIFJpZ2lkIGJvZHkgdGhhdCB5b3Ugd2FudCB0byBhZGRcclxuICAgICovXHJcbiAgICBhZGRSaWdpZEJvZHk6ZnVuY3Rpb24oIHJpZ2lkQm9keSApe1xyXG5cclxuICAgICAgICBpZihyaWdpZEJvZHkucGFyZW50KXtcclxuICAgICAgICAgICAgcHJpbnRFcnJvcihcIldvcmxkXCIsIFwiSXQgaXMgbm90IHBvc3NpYmxlIHRvIGJlIGFkZGVkIHRvIG1vcmUgdGhhbiBvbmUgd29ybGQgb25lIG9mIHRoZSByaWdpZCBib2R5XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmlnaWRCb2R5LnNldFBhcmVudCggdGhpcyApO1xyXG4gICAgICAgIC8vcmlnaWRCb2R5LmF3YWtlKCk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgc2hhcGUgPSByaWdpZEJvZHkuc2hhcGVzOyBzaGFwZSAhPT0gbnVsbDsgc2hhcGUgPSBzaGFwZS5uZXh0KXtcclxuICAgICAgICAgICAgdGhpcy5hZGRTaGFwZSggc2hhcGUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5yaWdpZEJvZGllcyE9PW51bGwpKHRoaXMucmlnaWRCb2RpZXMucHJldj1yaWdpZEJvZHkpLm5leHQ9dGhpcy5yaWdpZEJvZGllcztcclxuICAgICAgICB0aGlzLnJpZ2lkQm9kaWVzID0gcmlnaWRCb2R5O1xyXG4gICAgICAgIHRoaXMubnVtUmlnaWRCb2RpZXMrKztcclxuXHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAqIEkgd2lsbCByZW1vdmUgdGhlIHJpZ2lkIGJvZHkgZnJvbSB0aGUgd29ybGQuXHJcbiAgICAqIFJpZ2lkIGJvZHkgdGhhdCBoYXMgYmVlbiBkZWxldGVkIGlzIGV4Y2x1ZGVkIGZyb20gdGhlIGNhbGN1bGF0aW9uIG9uIGEgc3RlcC1ieS1zdGVwIGJhc2lzLlxyXG4gICAgKiBAcGFyYW0gIHJpZ2lkQm9keSAgUmlnaWQgYm9keSB0byBiZSByZW1vdmVkXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlUmlnaWRCb2R5OmZ1bmN0aW9uKCByaWdpZEJvZHkgKXtcclxuXHJcbiAgICAgICAgdmFyIHJlbW92ZT1yaWdpZEJvZHk7XHJcbiAgICAgICAgaWYocmVtb3ZlLnBhcmVudCE9PXRoaXMpcmV0dXJuO1xyXG4gICAgICAgIHJlbW92ZS5hd2FrZSgpO1xyXG4gICAgICAgIHZhciBqcz1yZW1vdmUuam9pbnRMaW5rO1xyXG4gICAgICAgIHdoaWxlKGpzIT1udWxsKXtcclxuXHQgICAgICAgIHZhciBqb2ludD1qcy5qb2ludDtcclxuXHQgICAgICAgIGpzPWpzLm5leHQ7XHJcblx0ICAgICAgICB0aGlzLnJlbW92ZUpvaW50KGpvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKHZhciBzaGFwZT1yaWdpZEJvZHkuc2hhcGVzOyBzaGFwZSE9PW51bGw7IHNoYXBlPXNoYXBlLm5leHQpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNoYXBlKHNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByZXY9cmVtb3ZlLnByZXY7XHJcbiAgICAgICAgdmFyIG5leHQ9cmVtb3ZlLm5leHQ7XHJcbiAgICAgICAgaWYocHJldiE9PW51bGwpIHByZXYubmV4dD1uZXh0O1xyXG4gICAgICAgIGlmKG5leHQhPT1udWxsKSBuZXh0LnByZXY9cHJldjtcclxuICAgICAgICBpZih0aGlzLnJpZ2lkQm9kaWVzPT1yZW1vdmUpIHRoaXMucmlnaWRCb2RpZXM9bmV4dDtcclxuICAgICAgICByZW1vdmUucHJldj1udWxsO1xyXG4gICAgICAgIHJlbW92ZS5uZXh0PW51bGw7XHJcbiAgICAgICAgcmVtb3ZlLnBhcmVudD1udWxsO1xyXG4gICAgICAgIHRoaXMubnVtUmlnaWRCb2RpZXMtLTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKXtcclxuXHJcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnJpZ2lkQm9kaWVzO1xyXG4gICAgICAgIHdoaWxlKCBib2R5ICE9PSBudWxsICl7XHJcbiAgICAgICAgICAgIGlmKCBib2R5Lm5hbWUgPT09IG5hbWUgKSByZXR1cm4gYm9keTtcclxuICAgICAgICAgICAgYm9keT1ib2R5Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgam9pbnQgPSB0aGlzLmpvaW50cztcclxuICAgICAgICB3aGlsZSggam9pbnQgIT09IG51bGwgKXtcclxuICAgICAgICAgICAgaWYoIGpvaW50Lm5hbWUgPT09IG5hbWUgKSByZXR1cm4gam9pbnQ7XHJcbiAgICAgICAgICAgIGpvaW50ID0gam9pbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEknbGwgYWRkIGEgc2hhcGUgdG8gdGhlIHdvcmxkLi5cclxuICAgICogQWRkIHRvIHRoZSByaWdpZCB3b3JsZCwgYW5kIGlmIHlvdSBhZGQgYSBzaGFwZSB0byBhIHJpZ2lkIGJvZHkgdGhhdCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgd29ybGQsXHJcbiAgICAqIFNoYXBlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHdvcmxkIGF1dG9tYXRpY2FsbHksIHBsZWFzZSBkbyBub3QgY2FsbCBmcm9tIG91dHNpZGUgdGhpcyBtZXRob2QuXHJcbiAgICAqIEBwYXJhbSAgc2hhcGUgIFNoYXBlIHlvdSB3YW50IHRvIGFkZFxyXG4gICAgKi9cclxuICAgIGFkZFNoYXBlOmZ1bmN0aW9uICggc2hhcGUgKXtcclxuXHJcbiAgICAgICAgaWYoIXNoYXBlLnBhcmVudCB8fCAhc2hhcGUucGFyZW50LnBhcmVudCl7XHJcbiAgICAgICAgICAgIHByaW50RXJyb3IoXCJXb3JsZFwiLCBcIkl0IGlzIG5vdCBwb3NzaWJsZSB0byBiZSBhZGRlZCBhbG9uZSB0byBzaGFwZSB3b3JsZFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNoYXBlLnByb3h5ID0gdGhpcy5icm9hZFBoYXNlLmNyZWF0ZVByb3h5KHNoYXBlKTtcclxuICAgICAgICBzaGFwZS51cGRhdGVQcm94eSgpO1xyXG4gICAgICAgIHRoaXMuYnJvYWRQaGFzZS5hZGRQcm94eShzaGFwZS5wcm94eSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogSSB3aWxsIHJlbW92ZSB0aGUgc2hhcGUgZnJvbSB0aGUgd29ybGQuXHJcbiAgICAqIEFkZCB0byB0aGUgcmlnaWQgd29ybGQsIGFuZCBpZiB5b3UgYWRkIGEgc2hhcGUgdG8gYSByaWdpZCBib2R5IHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHdvcmxkLFxyXG4gICAgKiBTaGFwZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB3b3JsZCBhdXRvbWF0aWNhbGx5LCBwbGVhc2UgZG8gbm90IGNhbGwgZnJvbSBvdXRzaWRlIHRoaXMgbWV0aG9kLlxyXG4gICAgKiBAcGFyYW0gIHNoYXBlICBTaGFwZSB5b3Ugd2FudCB0byBkZWxldGVcclxuICAgICovXHJcbiAgICByZW1vdmVTaGFwZTogZnVuY3Rpb24gKCBzaGFwZSApe1xyXG5cclxuICAgICAgICB0aGlzLmJyb2FkUGhhc2UucmVtb3ZlUHJveHkoc2hhcGUucHJveHkpO1xyXG4gICAgICAgIHNoYXBlLnByb3h5ID0gbnVsbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJJ2xsIGFkZCBhIGpvaW50IHRvIHRoZSB3b3JsZC5cclxuICAgICogSm9pbnQgdGhhdCBoYXMgYmVlbiBhZGRlZCB3aWxsIGJlIHRoZSBvcGVyYW5kcyBvZiBlYWNoIHN0ZXAuXHJcbiAgICAqIEBwYXJhbSAgc2hhcGUgSm9pbnQgdG8gYmUgYWRkZWRcclxuICAgICovXHJcbiAgICBhZGRKb2ludDogZnVuY3Rpb24gKCBqb2ludCApIHtcclxuXHJcbiAgICAgICAgaWYoam9pbnQucGFyZW50KXtcclxuICAgICAgICAgICAgcHJpbnRFcnJvcihcIldvcmxkXCIsIFwiSXQgaXMgbm90IHBvc3NpYmxlIHRvIGJlIGFkZGVkIHRvIG1vcmUgdGhhbiBvbmUgd29ybGQgb25lIG9mIHRoZSBqb2ludFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5qb2ludHMhPW51bGwpKHRoaXMuam9pbnRzLnByZXY9am9pbnQpLm5leHQ9dGhpcy5qb2ludHM7XHJcbiAgICAgICAgdGhpcy5qb2ludHM9am9pbnQ7XHJcbiAgICAgICAgam9pbnQuc2V0UGFyZW50KCB0aGlzICk7XHJcbiAgICAgICAgdGhpcy5udW1Kb2ludHMrKztcclxuICAgICAgICBqb2ludC5hd2FrZSgpO1xyXG4gICAgICAgIGpvaW50LmF0dGFjaCgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEkgd2lsbCByZW1vdmUgdGhlIGpvaW50IGZyb20gdGhlIHdvcmxkLlxyXG4gICAgKiBKb2ludCB0aGF0IGhhcyBiZWVuIGFkZGVkIHdpbGwgYmUgdGhlIG9wZXJhbmRzIG9mIGVhY2ggc3RlcC5cclxuICAgICogQHBhcmFtICBzaGFwZSBKb2ludCB0byBiZSBkZWxldGVkXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlSm9pbnQ6IGZ1bmN0aW9uICggam9pbnQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZW1vdmU9am9pbnQ7XHJcbiAgICAgICAgdmFyIHByZXY9cmVtb3ZlLnByZXY7XHJcbiAgICAgICAgdmFyIG5leHQ9cmVtb3ZlLm5leHQ7XHJcbiAgICAgICAgaWYocHJldiE9PW51bGwpcHJldi5uZXh0PW5leHQ7XHJcbiAgICAgICAgaWYobmV4dCE9PW51bGwpbmV4dC5wcmV2PXByZXY7XHJcbiAgICAgICAgaWYodGhpcy5qb2ludHM9PXJlbW92ZSl0aGlzLmpvaW50cz1uZXh0O1xyXG4gICAgICAgIHJlbW92ZS5wcmV2PW51bGw7XHJcbiAgICAgICAgcmVtb3ZlLm5leHQ9bnVsbDtcclxuICAgICAgICB0aGlzLm51bUpvaW50cy0tO1xyXG4gICAgICAgIHJlbW92ZS5hd2FrZSgpO1xyXG4gICAgICAgIHJlbW92ZS5kZXRhY2goKTtcclxuICAgICAgICByZW1vdmUucGFyZW50PW51bGw7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRDb250YWN0OiBmdW5jdGlvbiAoIHMxLCBzMiApIHtcclxuXHJcbiAgICAgICAgdmFyIG5ld0NvbnRhY3Q7XHJcbiAgICAgICAgaWYodGhpcy51bnVzZWRDb250YWN0cyE9PW51bGwpe1xyXG4gICAgICAgICAgICBuZXdDb250YWN0PXRoaXMudW51c2VkQ29udGFjdHM7XHJcbiAgICAgICAgICAgIHRoaXMudW51c2VkQ29udGFjdHM9dGhpcy51bnVzZWRDb250YWN0cy5uZXh0O1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBuZXdDb250YWN0ID0gbmV3IENvbnRhY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3Q29udGFjdC5hdHRhY2goczEsczIpO1xyXG4gICAgICAgIG5ld0NvbnRhY3QuZGV0ZWN0b3IgPSB0aGlzLmRldGVjdG9yc1tzMS50eXBlXVtzMi50eXBlXTtcclxuICAgICAgICBpZih0aGlzLmNvbnRhY3RzKSh0aGlzLmNvbnRhY3RzLnByZXYgPSBuZXdDb250YWN0KS5uZXh0ID0gdGhpcy5jb250YWN0cztcclxuICAgICAgICB0aGlzLmNvbnRhY3RzID0gbmV3Q29udGFjdDtcclxuICAgICAgICB0aGlzLm51bUNvbnRhY3RzKys7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVDb250YWN0OiBmdW5jdGlvbiAoIGNvbnRhY3QgKSB7XHJcblxyXG4gICAgICAgIHZhciBwcmV2ID0gY29udGFjdC5wcmV2O1xyXG4gICAgICAgIHZhciBuZXh0ID0gY29udGFjdC5uZXh0O1xyXG4gICAgICAgIGlmKG5leHQpIG5leHQucHJldiA9IHByZXY7XHJcbiAgICAgICAgaWYocHJldikgcHJldi5uZXh0ID0gbmV4dDtcclxuICAgICAgICBpZih0aGlzLmNvbnRhY3RzID09IGNvbnRhY3QpIHRoaXMuY29udGFjdHMgPSBuZXh0O1xyXG4gICAgICAgIGNvbnRhY3QucHJldiA9IG51bGw7XHJcbiAgICAgICAgY29udGFjdC5uZXh0ID0gbnVsbDtcclxuICAgICAgICBjb250YWN0LmRldGFjaCgpO1xyXG4gICAgICAgIGNvbnRhY3QubmV4dCA9IHRoaXMudW51c2VkQ29udGFjdHM7XHJcbiAgICAgICAgdGhpcy51bnVzZWRDb250YWN0cyA9IGNvbnRhY3Q7XHJcbiAgICAgICAgdGhpcy5udW1Db250YWN0cy0tO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29udGFjdDogZnVuY3Rpb24gKCBiMSwgYjIgKSB7XHJcblxyXG4gICAgICAgIGIxID0gYjEuY29uc3RydWN0b3IgPT09IFJpZ2lkQm9keSA/IGIxLm5hbWUgOiBiMTtcclxuICAgICAgICBiMiA9IGIyLmNvbnN0cnVjdG9yID09PSBSaWdpZEJvZHkgPyBiMi5uYW1lIDogYjI7XHJcblxyXG4gICAgICAgIHZhciBuMSwgbjI7XHJcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNvbnRhY3RzO1xyXG4gICAgICAgIHdoaWxlKGNvbnRhY3QhPT1udWxsKXtcclxuICAgICAgICAgICAgbjEgPSBjb250YWN0LmJvZHkxLm5hbWU7XHJcbiAgICAgICAgICAgIG4yID0gY29udGFjdC5ib2R5Mi5uYW1lO1xyXG4gICAgICAgICAgICBpZigobjE9PT1iMSAmJiBuMj09PWIyKSB8fCAobjI9PT1iMSAmJiBuMT09PWIyKSl7IGlmKGNvbnRhY3QudG91Y2hpbmcpIHJldHVybiBjb250YWN0OyBlbHNlIHJldHVybiBudWxsO31cclxuICAgICAgICAgICAgZWxzZSBjb250YWN0ID0gY29udGFjdC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrQ29udGFjdDogZnVuY3Rpb24gKCBuYW1lMSwgbmFtZTIgKSB7XHJcblxyXG4gICAgICAgIHZhciBuMSwgbjI7XHJcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNvbnRhY3RzO1xyXG4gICAgICAgIHdoaWxlKGNvbnRhY3QhPT1udWxsKXtcclxuICAgICAgICAgICAgbjEgPSBjb250YWN0LmJvZHkxLm5hbWUgfHwgJyAnO1xyXG4gICAgICAgICAgICBuMiA9IGNvbnRhY3QuYm9keTIubmFtZSB8fCAnICc7XHJcbiAgICAgICAgICAgIGlmKChuMT09bmFtZTEgJiYgbjI9PW5hbWUyKSB8fCAobjI9PW5hbWUxICYmIG4xPT1uYW1lMikpeyBpZihjb250YWN0LnRvdWNoaW5nKSByZXR1cm4gdHJ1ZTsgZWxzZSByZXR1cm4gZmFsc2U7fVxyXG4gICAgICAgICAgICBlbHNlIGNvbnRhY3QgPSBjb250YWN0Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2FsbFNsZWVwOiBmdW5jdGlvbiggYm9keSApIHtcclxuXHJcbiAgICAgICAgaWYoICFib2R5LmFsbG93U2xlZXAgKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYoIGJvZHkubGluZWFyVmVsb2NpdHkubGVuZ3RoU3EoKSA+IDAuMDQgKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYoIGJvZHkuYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxKCkgPiAwLjI1ICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEkgd2lsbCBwcm9jZWVkIG9ubHkgdGltZSBzdGVwIHNlY29uZHMgdGltZSBvZiBXb3JsZC5cclxuICAgICovXHJcbiAgICBzdGVwOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBzdGF0ID0gdGhpcy5pc1N0YXQ7XHJcblxyXG4gICAgICAgIGlmKCBzdGF0ICkgdGhpcy5wZXJmb3JtYW5jZS5zZXRUaW1lKCAwICk7XHJcblxyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5yaWdpZEJvZGllcztcclxuXHJcbiAgICAgICAgd2hpbGUoIGJvZHkgIT09IG51bGwgKXtcclxuXHJcbiAgICAgICAgICAgIGJvZHkuYWRkZWRUb0lzbGFuZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYoIGJvZHkuc2xlZXBpbmcgKSBib2R5LnRlc3RXYWtlVXAoKTtcclxuXHJcbiAgICAgICAgICAgIGJvZHkgPSBib2R5Lm5leHQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIC8vICAgVVBEQVRFIEJST0FEUEhBU0UgQ09OVEFDVFxyXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICAgIGlmKCBzdGF0ICkgdGhpcy5wZXJmb3JtYW5jZS5zZXRUaW1lKCAxICk7XHJcblxyXG4gICAgICAgIHRoaXMuYnJvYWRQaGFzZS5kZXRlY3RQYWlycygpO1xyXG5cclxuICAgICAgICB2YXIgcGFpcnMgPSB0aGlzLmJyb2FkUGhhc2UucGFpcnM7XHJcblxyXG4gICAgICAgIHZhciBpID0gdGhpcy5icm9hZFBoYXNlLm51bVBhaXJzO1xyXG4gICAgICAgIC8vZG97XHJcbiAgICAgICAgd2hpbGUoaS0tKXtcclxuICAgICAgICAvL2Zvcih2YXIgaT0wLCBsPW51bVBhaXJzOyBpPGw7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgIHZhciBzMTtcclxuICAgICAgICAgICAgdmFyIHMyO1xyXG4gICAgICAgICAgICBpZihwYWlyLnNoYXBlMS5pZDxwYWlyLnNoYXBlMi5pZCl7XHJcbiAgICAgICAgICAgICAgICBzMSA9IHBhaXIuc2hhcGUxO1xyXG4gICAgICAgICAgICAgICAgczIgPSBwYWlyLnNoYXBlMjtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzMSA9IHBhaXIuc2hhcGUyO1xyXG4gICAgICAgICAgICAgICAgczIgPSBwYWlyLnNoYXBlMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGxpbms7XHJcbiAgICAgICAgICAgIGlmKCBzMS5udW1Db250YWN0cyA8IHMyLm51bUNvbnRhY3RzICkgbGluayA9IHMxLmNvbnRhY3RMaW5rO1xyXG4gICAgICAgICAgICBlbHNlIGxpbmsgPSBzMi5jb250YWN0TGluaztcclxuXHJcbiAgICAgICAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUobGluayl7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGxpbmsuY29udGFjdDtcclxuICAgICAgICAgICAgICAgIGlmKCBjb250YWN0LnNoYXBlMSA9PSBzMSAmJiBjb250YWN0LnNoYXBlMiA9PSBzMiApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QucGVyc2lzdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTsvLyBjb250YWN0IGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaW5rID0gbGluay5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFleGlzdHMpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb250YWN0KCBzMSwgczIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0vLyB3aGlsZShpLS0gPjApO1xyXG5cclxuICAgICAgICBpZiggc3RhdCApIHRoaXMucGVyZm9ybWFuY2UuY2FsY0Jyb2FkUGhhc2UoKTtcclxuXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyAgIFVQREFURSBOQVJST1dQSEFTRSBDT05UQUNUXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlICYgbmFycm93IHBoYXNlXHJcbiAgICAgICAgdGhpcy5udW1Db250YWN0UG9pbnRzID0gMDtcclxuICAgICAgICBjb250YWN0ID0gdGhpcy5jb250YWN0cztcclxuICAgICAgICB3aGlsZSggY29udGFjdCE9PW51bGwgKXtcclxuICAgICAgICAgICAgaWYoIWNvbnRhY3QucGVyc2lzdGluZyl7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRhY3Quc2hhcGUxLmFhYmIuaW50ZXJzZWN0VGVzdCggY29udGFjdC5zaGFwZTIuYWFiYiApICkge1xyXG4gICAgICAgICAgICAgICAgLyp2YXIgYWFiYjE9Y29udGFjdC5zaGFwZTEuYWFiYjtcclxuICAgICAgICAgICAgICAgIHZhciBhYWJiMj1jb250YWN0LnNoYXBlMi5hYWJiO1xyXG4gICAgICAgICAgICAgICAgaWYoXHJcblx0ICAgICAgICAgICAgICAgIGFhYmIxLm1pblg+YWFiYjIubWF4WCB8fCBhYWJiMS5tYXhYPGFhYmIyLm1pblggfHxcclxuXHQgICAgICAgICAgICAgICAgYWFiYjEubWluWT5hYWJiMi5tYXhZIHx8IGFhYmIxLm1heFk8YWFiYjIubWluWSB8fFxyXG5cdCAgICAgICAgICAgICAgICBhYWJiMS5taW5aPmFhYmIyLm1heFogfHwgYWFiYjEubWF4WjxhYWJiMi5taW5aXHJcbiAgICAgICAgICAgICAgICApeyovXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBjb250YWN0Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb250YWN0KGNvbnRhY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiMSA9IGNvbnRhY3QuYm9keTE7XHJcbiAgICAgICAgICAgIHZhciBiMiA9IGNvbnRhY3QuYm9keTI7XHJcblxyXG4gICAgICAgICAgICBpZiggYjEuaXNEeW5hbWljICYmICFiMS5zbGVlcGluZyB8fCBiMi5pc0R5bmFtaWMgJiYgIWIyLnNsZWVwaW5nICkgY29udGFjdC51cGRhdGVNYW5pZm9sZCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5udW1Db250YWN0UG9pbnRzICs9IGNvbnRhY3QubWFuaWZvbGQubnVtUG9pbnRzO1xyXG4gICAgICAgICAgICBjb250YWN0LnBlcnNpc3RpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29udGFjdC5jb25zdHJhaW50LmFkZGVkVG9Jc2xhbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29udGFjdCA9IGNvbnRhY3QubmV4dDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiggc3RhdCApIHRoaXMucGVyZm9ybWFuY2UuY2FsY05hcnJvd1BoYXNlKCk7XHJcblxyXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gICBTT0xWRSBJU0xBTkRTXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgICAgdmFyIGludlRpbWVTdGVwID0gMSAvIHRoaXMudGltZVN0ZXA7XHJcbiAgICAgICAgdmFyIGpvaW50O1xyXG4gICAgICAgIHZhciBjb25zdHJhaW50O1xyXG5cclxuICAgICAgICBmb3IoIGpvaW50ID0gdGhpcy5qb2ludHM7IGpvaW50ICE9PSBudWxsOyBqb2ludCA9IGpvaW50Lm5leHQgKXtcclxuICAgICAgICAgICAgam9pbnQuYWRkZWRUb0lzbGFuZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIGNsZWFyIG9sZCBpc2xhbmQgYXJyYXlcclxuICAgICAgICB0aGlzLmlzbGFuZFJpZ2lkQm9kaWVzID0gW107XHJcbiAgICAgICAgdGhpcy5pc2xhbmRDb25zdHJhaW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNsYW5kU3RhY2sgPSBbXTtcclxuXHJcbiAgICAgICAgaWYoIHN0YXQgKSB0aGlzLnBlcmZvcm1hbmNlLnNldFRpbWUoIDEgKTtcclxuXHJcbiAgICAgICAgdGhpcy5udW1Jc2xhbmRzID0gMDtcclxuXHJcbiAgICAgICAgLy8gYnVpbGQgYW5kIHNvbHZlIHNpbXVsYXRpb24gaXNsYW5kc1xyXG5cclxuICAgICAgICBmb3IoIHZhciBiYXNlID0gdGhpcy5yaWdpZEJvZGllczsgYmFzZSAhPT0gbnVsbDsgYmFzZSA9IGJhc2UubmV4dCApe1xyXG5cclxuICAgICAgICAgICAgaWYoIGJhc2UuYWRkZWRUb0lzbGFuZCB8fCBiYXNlLmlzU3RhdGljIHx8IGJhc2Uuc2xlZXBpbmcgKSBjb250aW51ZTsvLyBpZ25vcmVcclxuXHJcbiAgICAgICAgICAgIGlmKCBiYXNlLmlzTG9uZWx5KCkgKXsvLyB1cGRhdGUgc2luZ2xlIGJvZHlcclxuICAgICAgICAgICAgICAgIGlmKCBiYXNlLmlzRHluYW1pYyApe1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2UubGluZWFyVmVsb2NpdHkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmdyYXZpdHksIHRoaXMudGltZVN0ZXAgKTtcclxuICAgICAgICAgICAgICAgICAgICAvKmJhc2UubGluZWFyVmVsb2NpdHkueCs9dGhpcy5ncmF2aXR5LngqdGhpcy50aW1lU3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlLmxpbmVhclZlbG9jaXR5LnkrPXRoaXMuZ3Jhdml0eS55KnRoaXMudGltZVN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZS5saW5lYXJWZWxvY2l0eS56Kz10aGlzLmdyYXZpdHkueip0aGlzLnRpbWVTdGVwOyovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5jYWxsU2xlZXAoIGJhc2UgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlLnNsZWVwVGltZSArPSB0aGlzLnRpbWVTdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCBiYXNlLnNsZWVwVGltZSA+IDAuNSApIGJhc2Uuc2xlZXAoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGJhc2UudXBkYXRlUG9zaXRpb24oIHRoaXMudGltZVN0ZXAgKTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2Uuc2xlZXBUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlLnVwZGF0ZVBvc2l0aW9uKCB0aGlzLnRpbWVTdGVwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm51bUlzbGFuZHMrKztcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaXNsYW5kTnVtUmlnaWRCb2RpZXMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgaXNsYW5kTnVtQ29uc3RyYWludHMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgc3RhY2tDb3VudCA9IDE7XHJcbiAgICAgICAgICAgIC8vIGFkZCByaWdpZCBib2R5IHRvIHN0YWNrXHJcbiAgICAgICAgICAgIHRoaXMuaXNsYW5kU3RhY2tbMF0gPSBiYXNlO1xyXG4gICAgICAgICAgICBiYXNlLmFkZGVkVG9Jc2xhbmQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gYnVpbGQgYW4gaXNsYW5kXHJcbiAgICAgICAgICAgIGRve1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHJpZ2lkIGJvZHkgZnJvbSBzdGFja1xyXG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNsYW5kU3RhY2tbLS1zdGFja0NvdW50XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNsYW5kU3RhY2tbc3RhY2tDb3VudF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYm9keS5zbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkIHJpZ2lkIGJvZHkgdG8gdGhlIGlzbGFuZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc2xhbmRSaWdpZEJvZGllc1tpc2xhbmROdW1SaWdpZEJvZGllcysrXSA9IGJvZHk7XHJcbiAgICAgICAgICAgICAgICBpZihib2R5LmlzU3RhdGljKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggY29ubmVjdGlvbnNcclxuICAgICAgICAgICAgICAgIGZvciggdmFyIGNzID0gYm9keS5jb250YWN0TGluazsgY3MgIT09IG51bGw7IGNzID0gY3MubmV4dCApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGNzLmNvbnRhY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludCA9IGNvbnRhY3QuY29uc3RyYWludDtcclxuICAgICAgICAgICAgICAgICAgICBpZiggY29uc3RyYWludC5hZGRlZFRvSXNsYW5kIHx8ICFjb250YWN0LnRvdWNoaW5nICkgY29udGludWU7Ly8gaWdub3JlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBjb25zdHJhaW50IHRvIHRoZSBpc2xhbmRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZENvbnN0cmFpbnRzW2lzbGFuZE51bUNvbnN0cmFpbnRzKytdID0gY29uc3RyYWludDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmFkZGVkVG9Jc2xhbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gY3MuYm9keTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobmV4dC5hZGRlZFRvSXNsYW5kKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHJpZ2lkIGJvZHkgdG8gc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZFN0YWNrW3N0YWNrQ291bnQrK10gPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkZWRUb0lzbGFuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBqcyA9IGJvZHkuam9pbnRMaW5rOyBqcyAhPT0gbnVsbDsganMgPSBqcy5uZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBqcy5qb2ludDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY29uc3RyYWludC5hZGRlZFRvSXNsYW5kKSBjb250aW51ZTsvLyBpZ25vcmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGNvbnN0cmFpbnQgdG8gdGhlIGlzbGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNsYW5kQ29uc3RyYWludHNbaXNsYW5kTnVtQ29uc3RyYWludHMrK10gPSBjb25zdHJhaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYWRkZWRUb0lzbGFuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGpzLmJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIG5leHQuYWRkZWRUb0lzbGFuZCB8fCAhbmV4dC5pc0R5bmFtaWMgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHJpZ2lkIGJvZHkgdG8gc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZFN0YWNrW3N0YWNrQ291bnQrK10gPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkZWRUb0lzbGFuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUoIHN0YWNrQ291bnQgIT0gMCApO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXRpZXNcclxuICAgICAgICAgICAgdmFyIGdWZWwgPSBuZXcgVmVjMygpLmFkZFNjYWxlZFZlY3RvciggdGhpcy5ncmF2aXR5LCB0aGlzLnRpbWVTdGVwICk7XHJcbiAgICAgICAgICAgIC8qdmFyIGd4PXRoaXMuZ3Jhdml0eS54KnRoaXMudGltZVN0ZXA7XHJcbiAgICAgICAgICAgIHZhciBneT10aGlzLmdyYXZpdHkueSp0aGlzLnRpbWVTdGVwO1xyXG4gICAgICAgICAgICB2YXIgZ3o9dGhpcy5ncmF2aXR5LnoqdGhpcy50aW1lU3RlcDsqL1xyXG4gICAgICAgICAgICB2YXIgaiA9IGlzbGFuZE51bVJpZ2lkQm9kaWVzO1xyXG4gICAgICAgICAgICB3aGlsZSAoai0tKXtcclxuICAgICAgICAgICAgLy9vcih2YXIgaj0wLCBsPWlzbGFuZE51bVJpZ2lkQm9kaWVzOyBqPGw7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5pc2xhbmRSaWdpZEJvZGllc1tqXTtcclxuICAgICAgICAgICAgICAgIGlmKGJvZHkuaXNEeW5hbWljKXtcclxuICAgICAgICAgICAgICAgICAgICBib2R5LmxpbmVhclZlbG9jaXR5LmFkZEVxdWFsKGdWZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qYm9keS5saW5lYXJWZWxvY2l0eS54Kz1neDtcclxuICAgICAgICAgICAgICAgICAgICBib2R5LmxpbmVhclZlbG9jaXR5LnkrPWd5O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkubGluZWFyVmVsb2NpdHkueis9Z3o7Ki9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmFuZG9taXppbmcgb3JkZXJcclxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVSYW5kb21pemVyKXtcclxuICAgICAgICAgICAgICAgIC8vZm9yKHZhciBqPTEsIGw9aXNsYW5kTnVtQ29uc3RyYWludHM7IGo8bDsgaisrKXtcclxuICAgICAgICAgICAgICAgIGogPSBpc2xhbmROdW1Db25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIHdoaWxlKGotLSl7IGlmKGohPT0wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN3YXAgPSAodGhpcy5yYW5kWD0odGhpcy5yYW5kWCp0aGlzLnJhbmRBK3RoaXMucmFuZEImMHg3ZmZmZmZmZikpLzIxNDc0ODM2NDguMCpqfDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSB0aGlzLmlzbGFuZENvbnN0cmFpbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZENvbnN0cmFpbnRzW2pdID0gdGhpcy5pc2xhbmRDb25zdHJhaW50c1tzd2FwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc2xhbmRDb25zdHJhaW50c1tzd2FwXSA9IGNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzb2x2ZSBjb250cmFpbnRzXHJcblxyXG4gICAgICAgICAgICBqID0gaXNsYW5kTnVtQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgIHdoaWxlKGotLSl7XHJcbiAgICAgICAgICAgIC8vZm9yKGo9MCwgbD1pc2xhbmROdW1Db25zdHJhaW50czsgajxsOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc2xhbmRDb25zdHJhaW50c1tqXS5wcmVTb2x2ZSggdGhpcy50aW1lU3RlcCwgaW52VGltZVN0ZXAgKTsvLyBwcmUtc29sdmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgayA9IHRoaXMubnVtSXRlcmF0aW9ucztcclxuICAgICAgICAgICAgd2hpbGUoay0tKXtcclxuICAgICAgICAgICAgLy9mb3IodmFyIGs9MCwgbD10aGlzLm51bUl0ZXJhdGlvbnM7IGs8bDsgaysrKXtcclxuICAgICAgICAgICAgICAgIGogPSBpc2xhbmROdW1Db25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIHdoaWxlKGotLSl7XHJcbiAgICAgICAgICAgICAgICAvL2ZvcihqPTAsIG09aXNsYW5kTnVtQ29uc3RyYWludHM7IGo8bTsgaisrKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZENvbnN0cmFpbnRzW2pdLnNvbHZlKCk7Ly8gbWFpbi1zb2x2ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGogPSBpc2xhbmROdW1Db25zdHJhaW50cztcclxuICAgICAgICAgICAgd2hpbGUoai0tKXtcclxuICAgICAgICAgICAgLy9mb3Ioaj0wLCBsPWlzbGFuZE51bUNvbnN0cmFpbnRzOyBqPGw7IGorKyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZENvbnN0cmFpbnRzW2pdLnBvc3RTb2x2ZSgpOy8vIHBvc3Qtc29sdmVcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNsYW5kQ29uc3RyYWludHNbal0gPSBudWxsOy8vIGdjXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNsZWVwaW5nIGNoZWNrXHJcblxyXG4gICAgICAgICAgICB2YXIgc2xlZXBUaW1lID0gMTA7XHJcbiAgICAgICAgICAgIGogPSBpc2xhbmROdW1SaWdpZEJvZGllcztcclxuICAgICAgICAgICAgd2hpbGUoai0tKXtcclxuICAgICAgICAgICAgLy9mb3Ioaj0wLCBsPWlzbGFuZE51bVJpZ2lkQm9kaWVzO2o8bDtqKyspe1xyXG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNsYW5kUmlnaWRCb2RpZXNbal07XHJcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5jYWxsU2xlZXAoIGJvZHkgKSApe1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuc2xlZXBUaW1lICs9IHRoaXMudGltZVN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIGJvZHkuc2xlZXBUaW1lIDwgc2xlZXBUaW1lICkgc2xlZXBUaW1lID0gYm9keS5zbGVlcFRpbWU7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBib2R5LnNsZWVwVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xlZXBUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzbGVlcFRpbWUgPiAwLjUpe1xyXG4gICAgICAgICAgICAgICAgLy8gc2xlZXAgdGhlIGlzbGFuZFxyXG4gICAgICAgICAgICAgICAgaiA9IGlzbGFuZE51bVJpZ2lkQm9kaWVzO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUoai0tKXtcclxuICAgICAgICAgICAgICAgIC8vZm9yKGo9MCwgbD1pc2xhbmROdW1SaWdpZEJvZGllcztqPGw7aisrKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZFJpZ2lkQm9kaWVzW2pdLnNsZWVwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc2xhbmRSaWdpZEJvZGllc1tqXSA9IG51bGw7Ly8gZ2NcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zXHJcbiAgICAgICAgICAgICAgICBqID0gaXNsYW5kTnVtUmlnaWRCb2RpZXM7XHJcbiAgICAgICAgICAgICAgICB3aGlsZShqLS0pe1xyXG4gICAgICAgICAgICAgICAgLy9mb3Ioaj0wLCBsPWlzbGFuZE51bVJpZ2lkQm9kaWVzO2o8bDtqKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNsYW5kUmlnaWRCb2RpZXNbal0udXBkYXRlUG9zaXRpb24oIHRoaXMudGltZVN0ZXAgKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzbGFuZFJpZ2lkQm9kaWVzW2pdID0gbnVsbDsvLyBnY1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubnVtSXNsYW5kcysrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyAgIEVORCBTSU1VTEFUSU9OXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgICAgaWYoIHN0YXQgKSB0aGlzLnBlcmZvcm1hbmNlLmNhbGNFbmQoKTtcclxuXHJcbiAgICAgICAgaWYoIHRoaXMucG9zdExvb3AgIT09IG51bGwgKSB0aGlzLnBvc3RMb29wKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyByZW1vdmUgc29tZXRpbmcgdG8gd29ybGRcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCBvYmogKXtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGFkZCBzb21ldGluZyB0byB3b3JsZFxyXG4gICAgXHJcbiAgICBhZGQ6IGZ1bmN0aW9uKCBvICl7XHJcblxyXG4gICAgICAgIG8gPSBvIHx8IHt9O1xyXG5cclxuICAgICAgICB2YXIgdHlwZSA9IG8udHlwZSB8fCBcImJveFwiO1xyXG4gICAgICAgIGlmKCB0eXBlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgKSB0eXBlID0gWyB0eXBlIF07XHJcbiAgICAgICAgdmFyIGlzSm9pbnQgPSB0eXBlWzBdLnN1YnN0cmluZyggMCwgNSApID09PSAnam9pbnQnID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiggaXNKb2ludCApIHJldHVybiB0aGlzLmluaXRKb2ludCggdHlwZVswXSwgbyApO1xyXG4gICAgICAgIGVsc2UgcmV0dXJuIHRoaXMuaW5pdEJvZHkoIHR5cGUsIG8gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRCb2R5OiBmdW5jdGlvbiggdHlwZSwgbyApe1xyXG5cclxuICAgICAgICB2YXIgaW52U2NhbGUgPSB0aGlzLmludlNjYWxlO1xyXG5cclxuICAgICAgICAvLyBib2R5IGR5bmFtaWMgb3Igc3RhdGljXHJcbiAgICAgICAgdmFyIG1vdmUgPSBvLm1vdmUgfHwgZmFsc2U7XHJcbiAgICAgICAgdmFyIGtpbmVtYXRpYyA9IG8ua2luZW1hdGljIHx8IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBQT1NJVElPTlxyXG5cclxuICAgICAgICAvLyBib2R5IHBvc2l0aW9uXHJcbiAgICAgICAgdmFyIHAgPSBvLnBvcyB8fCBbMCwwLDBdO1xyXG4gICAgICAgIHAgPSBwLm1hcCggZnVuY3Rpb24oeCkgeyByZXR1cm4geCAqIGludlNjYWxlOyB9ICk7XHJcblxyXG4gICAgICAgIC8vIHNoYXBlIHBvc2l0aW9uXHJcbiAgICAgICAgdmFyIHAyID0gby5wb3NTaGFwZSB8fCBbMCwwLDBdO1xyXG4gICAgICAgIHAyID0gcDIubWFwKCBmdW5jdGlvbih4KSB7IHJldHVybiB4ICogaW52U2NhbGU7IH0gKTtcclxuXHJcbiAgICAgICAgLy8gUk9UQVRJT05cclxuXHJcbiAgICAgICAgLy8gYm9keSByb3RhdGlvbiBpbiBkZWdyZWVcclxuICAgICAgICB2YXIgciA9IG8ucm90IHx8IFswLDAsMF07XHJcbiAgICAgICAgciA9IHIubWFwKCBmdW5jdGlvbih4KSB7IHJldHVybiB4ICogX01hdGguZGVndG9yYWQ7IH0gKTtcclxuXHJcbiAgICAgICAgLy8gc2hhcGUgcm90YXRpb24gaW4gZGVncmVlXHJcbiAgICAgICAgdmFyIHIyID0gby5yb3RTaGFwZSB8fCBbMCwwLDBdO1xyXG4gICAgICAgIHIyID0gci5tYXAoIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKiBfTWF0aC5kZWd0b3JhZDsgfSApO1xyXG5cclxuICAgICAgICAvLyBTSVpFXHJcblxyXG4gICAgICAgIC8vIHNoYXBlIHNpemVcclxuICAgICAgICB2YXIgcyA9IG8uc2l6ZSA9PT0gdW5kZWZpbmVkID8gWzEsMSwxXSA6IG8uc2l6ZTtcclxuICAgICAgICBpZiggcy5sZW5ndGggPT09IDEgKXsgc1sxXSA9IHNbMF07IH1cclxuICAgICAgICBpZiggcy5sZW5ndGggPT09IDIgKXsgc1syXSA9IHNbMF07IH1cclxuICAgICAgICBzID0gcy5tYXAoIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKiBpbnZTY2FsZTsgfSApO1xyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8gYm9keSBwaHlzaWNzIHNldHRpbmdzXHJcbiAgICAgICAgdmFyIHNjID0gbmV3IFNoYXBlQ29uZmlnKCk7XHJcbiAgICAgICAgLy8gVGhlIGRlbnNpdHkgb2YgdGhlIHNoYXBlLlxyXG4gICAgICAgIGlmKCBvLmRlbnNpdHkgIT09IHVuZGVmaW5lZCApIHNjLmRlbnNpdHkgPSBvLmRlbnNpdHk7XHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50IG9mIGZyaWN0aW9uIG9mIHRoZSBzaGFwZS5cclxuICAgICAgICBpZiggby5mcmljdGlvbiAhPT0gdW5kZWZpbmVkICkgc2MuZnJpY3Rpb24gPSBvLmZyaWN0aW9uO1xyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGUgc2hhcGUuXHJcbiAgICAgICAgaWYoIG8ucmVzdGl0dXRpb24gIT09IHVuZGVmaW5lZCApIHNjLnJlc3RpdHV0aW9uID0gby5yZXN0aXR1dGlvbjtcclxuICAgICAgICAvLyBUaGUgYml0cyBvZiB0aGUgY29sbGlzaW9uIGdyb3VwcyB0byB3aGljaCB0aGUgc2hhcGUgYmVsb25ncy5cclxuICAgICAgICBpZiggby5iZWxvbmdzVG8gIT09IHVuZGVmaW5lZCApIHNjLmJlbG9uZ3NUbyA9IG8uYmVsb25nc1RvO1xyXG4gICAgICAgIC8vIFRoZSBiaXRzIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBzIHdpdGggd2hpY2ggdGhlIHNoYXBlIGNvbGxpZGVzLlxyXG4gICAgICAgIGlmKCBvLmNvbGxpZGVzV2l0aCAhPT0gdW5kZWZpbmVkICkgc2MuY29sbGlkZXNXaXRoID0gby5jb2xsaWRlc1dpdGg7XHJcblxyXG4gICAgICAgIGlmKG8uY29uZmlnICE9PSB1bmRlZmluZWQgKXtcclxuICAgICAgICAgICAgaWYoIG8uY29uZmlnWzBdICE9PSB1bmRlZmluZWQgKSBzYy5kZW5zaXR5ID0gby5jb25maWdbMF07XHJcbiAgICAgICAgICAgIGlmKCBvLmNvbmZpZ1sxXSAhPT0gdW5kZWZpbmVkICkgc2MuZnJpY3Rpb24gPSBvLmNvbmZpZ1sxXTtcclxuICAgICAgICAgICAgaWYoIG8uY29uZmlnWzJdICE9PSB1bmRlZmluZWQgKSBzYy5yZXN0aXR1dGlvbiA9IG8uY29uZmlnWzJdO1xyXG4gICAgICAgICAgICBpZiggby5jb25maWdbM10gIT09IHVuZGVmaW5lZCApIHNjLmJlbG9uZ3NUbyA9IG8uY29uZmlnWzNdO1xyXG4gICAgICAgICAgICBpZiggby5jb25maWdbNF0gIT09IHVuZGVmaW5lZCApIHNjLmNvbGxpZGVzV2l0aCA9IG8uY29uZmlnWzRdO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgLyogaWYoby5tYXNzUG9zKXtcclxuICAgICAgICAgICAgby5tYXNzUG9zID0gby5tYXNzUG9zLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4ICogaW52U2NhbGU7IH0pO1xyXG4gICAgICAgICAgICBzYy5yZWxhdGl2ZVBvc2l0aW9uLnNldCggby5tYXNzUG9zWzBdLCBvLm1hc3NQb3NbMV0sIG8ubWFzc1Bvc1syXSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihvLm1hc3NSb3Qpe1xyXG4gICAgICAgICAgICBvLm1hc3NSb3QgPSBvLm1hc3NSb3QubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKiBfTWF0aC5kZWd0b3JhZDsgfSk7XHJcbiAgICAgICAgICAgIHZhciBxID0gbmV3IFF1YXQoKS5zZXRGcm9tRXVsZXIoIG8ubWFzc1JvdFswXSwgby5tYXNzUm90WzFdLCBvLm1hc3NSb3RbMl0gKTtcclxuICAgICAgICAgICAgc2MucmVsYXRpdmVSb3RhdGlvbiA9IG5ldyBNYXQzMygpLnNldFF1YXQoIHEgKTsvL19NYXRoLkV1bGVyVG9NYXRyaXgoIG8ubWFzc1JvdFswXSwgby5tYXNzUm90WzFdLCBvLm1hc3NSb3RbMl0gKTtcclxuICAgICAgICB9Ki9cclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IFZlYzMoIHBbMF0sIHBbMV0sIHBbMl0gKTtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBuZXcgUXVhdCgpLnNldEZyb21FdWxlciggclswXSwgclsxXSwgclsyXSApO1xyXG5cclxuICAgICAgICAvLyByaWdpZGJvZHlcclxuICAgICAgICB2YXIgYm9keSA9IG5ldyBSaWdpZEJvZHkoIHBvc2l0aW9uLCByb3RhdGlvbiApO1xyXG4gICAgICAgIC8vdmFyIGJvZHkgPSBuZXcgUmlnaWRCb2R5KCBwWzBdLCBwWzFdLCBwWzJdLCByWzBdLCByWzFdLCByWzJdLCByWzNdLCB0aGlzLnNjYWxlLCB0aGlzLmludlNjYWxlICk7XHJcblxyXG4gICAgICAgIC8vIFNIQVBFU1xyXG5cclxuICAgICAgICB2YXIgc2hhcGUsIG47XHJcblxyXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKyApe1xyXG5cclxuICAgICAgICAgICAgbiA9IGkgKiAzO1xyXG5cclxuICAgICAgICAgICAgaWYoIHAyW25dICE9PSB1bmRlZmluZWQgKSBzYy5yZWxhdGl2ZVBvc2l0aW9uLnNldCggcDJbbl0sIHAyW24rMV0sIHAyW24rMl0gKTtcclxuICAgICAgICAgICAgaWYoIHIyW25dICE9PSB1bmRlZmluZWQgKSBzYy5yZWxhdGl2ZVJvdGF0aW9uLnNldFF1YXQoIG5ldyBRdWF0KCkuc2V0RnJvbUV1bGVyKCByMltuXSwgcjJbbisxXSwgcjJbbisyXSApICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzd2l0Y2goIHR5cGVbaV0gKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzcGhlcmVcIjogc2hhcGUgPSBuZXcgU3BoZXJlKCBzYywgc1tuXSApOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjeWxpbmRlclwiOiBzaGFwZSA9IG5ldyBDeWxpbmRlciggc2MsIHNbbl0sIHNbbisxXSApOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJib3hcIjogc2hhcGUgPSBuZXcgQm94KCBzYywgc1tuXSwgc1tuKzFdLCBzW24rMl0gKTsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicGxhbmVcIjogc2hhcGUgPSBuZXcgUGxhbmUoIHNjICk7IGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJvZHkuYWRkU2hhcGUoIHNoYXBlICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYm9keSBjYW4gc2xlZXAgb3Igbm90XHJcbiAgICAgICAgaWYoIG8ubmV2ZXJTbGVlcCB8fCBraW5lbWF0aWMpIGJvZHkuYWxsb3dTbGVlcCA9IGZhbHNlO1xyXG4gICAgICAgIGVsc2UgYm9keS5hbGxvd1NsZWVwID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgYm9keS5pc0tpbmVtYXRpYyA9IGtpbmVtYXRpYztcclxuXHJcbiAgICAgICAgLy8gYm9keSBzdGF0aWMgb3IgZHluYW1pY1xyXG4gICAgICAgIGlmKCBtb3ZlICl7XHJcblxyXG4gICAgICAgICAgICBpZihvLm1hc3NQb3MgfHwgby5tYXNzUm90KSBib2R5LnNldHVwTWFzcyggQk9EWV9EWU5BTUlDLCBmYWxzZSApO1xyXG4gICAgICAgICAgICBlbHNlIGJvZHkuc2V0dXBNYXNzKCBCT0RZX0RZTkFNSUMsIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGJvZHkgY2FuIHNsZWVwIG9yIG5vdFxyXG4gICAgICAgICAgICAvL2lmKCBvLm5ldmVyU2xlZXAgKSBib2R5LmFsbG93U2xlZXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy9lbHNlIGJvZHkuYWxsb3dTbGVlcCA9IHRydWU7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBib2R5LnNldHVwTWFzcyggQk9EWV9TVEFUSUMgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiggby5uYW1lICE9PSB1bmRlZmluZWQgKSBib2R5Lm5hbWUgPSBvLm5hbWU7XHJcbiAgICAgICAgLy9lbHNlIGlmKCBtb3ZlICkgYm9keS5uYW1lID0gdGhpcy5udW1SaWdpZEJvZGllcztcclxuXHJcbiAgICAgICAgLy8gZmluYWx5IGFkZCB0byBwaHlzaWNzIHdvcmxkXHJcbiAgICAgICAgdGhpcy5hZGRSaWdpZEJvZHkoIGJvZHkgKTtcclxuXHJcbiAgICAgICAgLy8gZm9yY2Ugc2xlZXAgb24gbm90XHJcbiAgICAgICAgaWYoIG1vdmUgKXtcclxuICAgICAgICAgICAgaWYoIG8uc2xlZXAgKSBib2R5LnNsZWVwKCk7XHJcbiAgICAgICAgICAgIGVsc2UgYm9keS5hd2FrZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGJvZHk7XHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW5pdEpvaW50OiBmdW5jdGlvbiggdHlwZSwgbyApe1xyXG5cclxuICAgICAgICAvL3ZhciB0eXBlID0gdHlwZTtcclxuICAgICAgICB2YXIgaW52U2NhbGUgPSB0aGlzLmludlNjYWxlO1xyXG5cclxuICAgICAgICB2YXIgYXhlMSA9IG8uYXhlMSB8fCBbMSwwLDBdO1xyXG4gICAgICAgIHZhciBheGUyID0gby5heGUyIHx8IFsxLDAsMF07XHJcbiAgICAgICAgdmFyIHBvczEgPSBvLnBvczEgfHwgWzAsMCwwXTtcclxuICAgICAgICB2YXIgcG9zMiA9IG8ucG9zMiB8fCBbMCwwLDBdO1xyXG5cclxuICAgICAgICBwb3MxID0gcG9zMS5tYXAoZnVuY3Rpb24oeCl7IHJldHVybiB4ICogaW52U2NhbGU7IH0pO1xyXG4gICAgICAgIHBvczIgPSBwb3MyLm1hcChmdW5jdGlvbih4KXsgcmV0dXJuIHggKiBpbnZTY2FsZTsgfSk7XHJcblxyXG4gICAgICAgIHZhciBtaW4sIG1heDtcclxuICAgICAgICBpZiggdHlwZSA9PT0gXCJqb2ludERpc3RhbmNlXCIgKXtcclxuICAgICAgICAgICAgbWluID0gby5taW4gfHwgMDtcclxuICAgICAgICAgICAgbWF4ID0gby5tYXggfHwgMTA7XHJcbiAgICAgICAgICAgIG1pbiA9IG1pbiAqIGludlNjYWxlO1xyXG4gICAgICAgICAgICBtYXggPSBtYXggKiBpbnZTY2FsZTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgbWluID0gby5taW4gfHwgNTcuMjk1Nzg7XHJcbiAgICAgICAgICAgIG1heCA9IG8ubWF4IHx8IDA7XHJcbiAgICAgICAgICAgIG1pbiA9IG1pbiAqIF9NYXRoLmRlZ3RvcmFkO1xyXG4gICAgICAgICAgICBtYXggPSBtYXggKiBfTWF0aC5kZWd0b3JhZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsaW1pdCA9IG8ubGltaXQgfHwgbnVsbDtcclxuICAgICAgICB2YXIgc3ByaW5nID0gby5zcHJpbmcgfHwgbnVsbDtcclxuICAgICAgICB2YXIgbW90b3IgPSBvLm1vdG9yIHx8IG51bGw7XHJcblxyXG4gICAgICAgIC8vIGpvaW50IHNldHRpbmdcclxuICAgICAgICB2YXIgamMgPSBuZXcgSm9pbnRDb25maWcoKTtcclxuICAgICAgICBqYy5zY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgamMuaW52U2NhbGUgPSB0aGlzLmludlNjYWxlO1xyXG4gICAgICAgIGpjLmFsbG93Q29sbGlzaW9uID0gby5jb2xsaXNpb24gfHwgZmFsc2U7XHJcbiAgICAgICAgamMubG9jYWxBeGlzMS5zZXQoIGF4ZTFbMF0sIGF4ZTFbMV0sIGF4ZTFbMl0gKTtcclxuICAgICAgICBqYy5sb2NhbEF4aXMyLnNldCggYXhlMlswXSwgYXhlMlsxXSwgYXhlMlsyXSApO1xyXG4gICAgICAgIGpjLmxvY2FsQW5jaG9yUG9pbnQxLnNldCggcG9zMVswXSwgcG9zMVsxXSwgcG9zMVsyXSApO1xyXG4gICAgICAgIGpjLmxvY2FsQW5jaG9yUG9pbnQyLnNldCggcG9zMlswXSwgcG9zMlsxXSwgcG9zMlsyXSApO1xyXG5cclxuICAgICAgICB2YXIgYjEgPSBudWxsO1xyXG4gICAgICAgIHZhciBiMiA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmKCBvLmJvZHkxID09PSB1bmRlZmluZWQgfHwgby5ib2R5MiA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHByaW50RXJyb3IoJ1dvcmxkJywgXCJDYW4ndCBhZGQgam9pbnQgaWYgYXR0YWNoIHJpZ2lkYm9keXMgbm90IGRlZmluZSAhXCIgKTtcclxuXHJcbiAgICAgICAgaWYgKCBvLmJvZHkxLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgKSB7IGIxID0gdGhpcy5nZXRCeU5hbWUoIG8uYm9keTEgKTsgfVxyXG4gICAgICAgIGVsc2UgaWYgKCBvLmJvZHkxLmNvbnN0cnVjdG9yID09PSBOdW1iZXIgKSB7IGIxID0gdGhpcy5nZXRCeU5hbWUoIG8uYm9keTEgKTsgfVxyXG4gICAgICAgIGVsc2UgaWYgKCBvLmJvZHkxLmNvbnN0cnVjdG9yID09PSBSaWdpZEJvZHkgKSB7IGIxID0gby5ib2R5MTsgfVxyXG5cclxuICAgICAgICBpZiAoIG8uYm9keTIuY29uc3RydWN0b3IgPT09IFN0cmluZyApIHsgYjIgPSB0aGlzLmdldEJ5TmFtZSggby5ib2R5MiApOyB9XHJcbiAgICAgICAgZWxzZSBpZiAoIG8uYm9keTIuY29uc3RydWN0b3IgPT09IE51bWJlciApIHsgYjIgPSB0aGlzLmdldEJ5TmFtZSggby5ib2R5MiApOyB9XHJcbiAgICAgICAgZWxzZSBpZiAoIG8uYm9keTIuY29uc3RydWN0b3IgPT09IFJpZ2lkQm9keSApIHsgYjIgPSBvLmJvZHkyOyB9XHJcblxyXG4gICAgICAgIGlmKCBiMSA9PT0gbnVsbCB8fCBiMiA9PT0gbnVsbCApIHJldHVybiBwcmludEVycm9yKCdXb3JsZCcsIFwiQ2FuJ3QgYWRkIGpvaW50IGF0dGFjaCByaWdpZGJvZHlzIG5vdCBmaW5kICFcIiApO1xyXG5cclxuICAgICAgICBqYy5ib2R5MSA9IGIxO1xyXG4gICAgICAgIGpjLmJvZHkyID0gYjI7XHJcblxyXG4gICAgICAgIHZhciBqb2ludDtcclxuICAgICAgICBzd2l0Y2goIHR5cGUgKXtcclxuICAgICAgICAgICAgY2FzZSBcImpvaW50RGlzdGFuY2VcIjogam9pbnQgPSBuZXcgRGlzdGFuY2VKb2ludChqYywgbWluLCBtYXgpO1xyXG4gICAgICAgICAgICAgICAgaWYoc3ByaW5nICE9PSBudWxsKSBqb2ludC5saW1pdE1vdG9yLnNldFNwcmluZyggc3ByaW5nWzBdLCBzcHJpbmdbMV0gKTtcclxuICAgICAgICAgICAgICAgIGlmKG1vdG9yICE9PSBudWxsKSBqb2ludC5saW1pdE1vdG9yLnNldE1vdG9yKCBtb3RvclswXSwgbW90b3JbMV0gKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqb2ludEhpbmdlXCI6IGNhc2UgXCJqb2ludFwiOiBqb2ludCA9IG5ldyBIaW5nZUpvaW50KGpjLCBtaW4sIG1heCk7XHJcbiAgICAgICAgICAgICAgICBpZihzcHJpbmcgIT09IG51bGwpIGpvaW50LmxpbWl0TW90b3Iuc2V0U3ByaW5nKCBzcHJpbmdbMF0sIHNwcmluZ1sxXSApOy8vIHNvZnRlbiB0aGUgam9pbnQgZXg6IDEwMCwgMC4yXHJcbiAgICAgICAgICAgICAgICBpZihtb3RvciAhPT0gbnVsbCkgam9pbnQubGltaXRNb3Rvci5zZXRNb3RvciggbW90b3JbMF0sIG1vdG9yWzFdICk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiam9pbnRQcmlzbWVcIjogam9pbnQgPSBuZXcgUHJpc21hdGljSm9pbnQoamMsIG1pbiwgbWF4KTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqb2ludFNsaWRlXCI6IGpvaW50ID0gbmV3IFNsaWRlckpvaW50KGpjLCBtaW4sIG1heCk7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiam9pbnRCYWxsXCI6IGpvaW50ID0gbmV3IEJhbGxBbmRTb2NrZXRKb2ludChqYyk7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiam9pbnRXaGVlbFwiOiBqb2ludCA9IG5ldyBXaGVlbEpvaW50KGpjKTtcclxuICAgICAgICAgICAgICAgIGlmKGxpbWl0ICE9PSBudWxsKSBqb2ludC5yb3RhdGlvbmFsTGltaXRNb3RvcjEuc2V0TGltaXQoIGxpbWl0WzBdLCBsaW1pdFsxXSApO1xyXG4gICAgICAgICAgICAgICAgaWYoc3ByaW5nICE9PSBudWxsKSBqb2ludC5yb3RhdGlvbmFsTGltaXRNb3RvcjEuc2V0U3ByaW5nKCBzcHJpbmdbMF0sIHNwcmluZ1sxXSApO1xyXG4gICAgICAgICAgICAgICAgaWYobW90b3IgIT09IG51bGwpIGpvaW50LnJvdGF0aW9uYWxMaW1pdE1vdG9yMS5zZXRNb3RvciggbW90b3JbMF0sIG1vdG9yWzFdICk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgam9pbnQubmFtZSA9IG8ubmFtZSB8fCAnJztcclxuICAgICAgICAvLyBmaW5hbHkgYWRkIHRvIHBoeXNpY3Mgd29ybGRcclxuICAgICAgICB0aGlzLmFkZEpvaW50KCBqb2ludCApO1xyXG5cclxuICAgICAgICByZXR1cm4gam9pbnQ7XHJcblxyXG4gICAgfSxcclxuXHJcblxyXG59ICk7XG5cbi8vIHRlc3QgdmVyc2lvblxyXG5cclxuLy9leHBvcnQgeyBSaWdpZEJvZHkgfSBmcm9tICcuL2NvcmUvUmlnaWRCb2R5X1guanMnO1xyXG4vL2V4cG9ydCB7IFdvcmxkIH0gZnJvbSAnLi9jb3JlL1dvcmxkX1guanMnO1xuXG5leHBvcnQgeyBfTWF0aCBhcyBNYXRoLCBWZWMzLCBRdWF0LCBNYXQzMywgU2hhcGUsIEJveCwgU3BoZXJlLCBDeWxpbmRlciwgUGxhbmUsIFBhcnRpY2xlLCBTaGFwZUNvbmZpZywgTGltaXRNb3RvciwgSGluZ2VKb2ludCwgQmFsbEFuZFNvY2tldEpvaW50LCBEaXN0YW5jZUpvaW50LCBQcmlzbWF0aWNKb2ludCwgU2xpZGVySm9pbnQsIFdoZWVsSm9pbnQsIEpvaW50Q29uZmlnLCBSaWdpZEJvZHksIFdvcmxkLCBSRVZJU0lPTiwgQlJfTlVMTCwgQlJfQlJVVEVfRk9SQ0UsIEJSX1NXRUVQX0FORF9QUlVORSwgQlJfQk9VTkRJTkdfVk9MVU1FX1RSRUUsIEJPRFlfTlVMTCwgQk9EWV9EWU5BTUlDLCBCT0RZX1NUQVRJQywgQk9EWV9LSU5FTUFUSUMsIEJPRFlfR0hPU1QsIFNIQVBFX05VTEwsIFNIQVBFX1NQSEVSRSwgU0hBUEVfQk9YLCBTSEFQRV9DWUxJTkRFUiwgU0hBUEVfUExBTkUsIFNIQVBFX1BBUlRJQ0xFLCBTSEFQRV9URVRSQSwgSk9JTlRfTlVMTCwgSk9JTlRfRElTVEFOQ0UsIEpPSU5UX0JBTExfQU5EX1NPQ0tFVCwgSk9JTlRfSElOR0UsIEpPSU5UX1dIRUVMLCBKT0lOVF9TTElERVIsIEpPSU5UX1BSSVNNQVRJQywgQUFCQl9QUk9YLCBwcmludEVycm9yLCBJbmZvRGlzcGxheSB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29pbW8vYnVpbGQvb2ltby5tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIFRIUkVFICkge1xuXHQvKipcblx0ICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICogQGF1dGhvciBlcmljaDY2NiAvIGh0dHA6Ly9lcmljaGFpbmVzLmNvbVxuXHQgKi9cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuXG4vLyBVbmxpa2UgVHJhY2tiYWxsQ29udHJvbHMsIGl0IG1haW50YWlucyB0aGUgXCJ1cFwiIGRpcmVjdGlvbiBvYmplY3QudXAgKCtZIGJ5IGRlZmF1bHQpLlxuLy9cbi8vICAgIE9yYml0IC0gbGVmdCBtb3VzZSAvIHRvdWNoOiBvbmUgZmluZ2VyIG1vdmVcbi8vICAgIFpvb20gLSBtaWRkbGUgbW91c2UsIG9yIG1vdXNld2hlZWwgLyB0b3VjaDogdHdvIGZpbmdlciBzcHJlYWQgb3Igc3F1aXNoXG4vLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW50ZXIgc3dpcGVcblxuXHRmdW5jdGlvbiBPcmJpdENvbnRyb2xzKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cblx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0Ly8gXCJ0YXJnZXRcIiBzZXRzIHRoZSBsb2NhdGlvbiBvZiBmb2N1cywgd2hlcmUgdGhlIG9iamVjdCBvcmJpdHMgYXJvdW5kXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0Ly8gSG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXQgKCBQZXJzcGVjdGl2ZUNhbWVyYSBvbmx5IClcblx0XHR0aGlzLm1pbkRpc3RhbmNlID0gMDtcblx0XHR0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG5cblx0XHQvLyBIb3cgZmFyIHlvdSBjYW4gem9vbSBpbiBhbmQgb3V0ICggT3J0aG9ncmFwaGljQ2FtZXJhIG9ubHkgKVxuXHRcdHRoaXMubWluWm9vbSA9IDA7XG5cdFx0dGhpcy5tYXhab29tID0gSW5maW5pdHk7XG5cblx0XHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0XHQvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cblx0XHR0aGlzLm1pblBvbGFyQW5nbGUgPSAwOyAvLyByYWRpYW5zXG5cdFx0dGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSTsgLy8gcmFkaWFuc1xuXG5cdFx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IGhvcml6b250YWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0XHQvLyBJZiBzZXQsIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgdGhlIGludGVydmFsIFsgLSBNYXRoLlBJLCBNYXRoLlBJIF0uXG5cdFx0dGhpcy5taW5BemltdXRoQW5nbGUgPSAtIEluZmluaXR5OyAvLyByYWRpYW5zXG5cdFx0dGhpcy5tYXhBemltdXRoQW5nbGUgPSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXG5cdFx0Ly8gU2V0IHRvIHRydWUgdG8gZW5hYmxlIGRhbXBpbmcgKGluZXJ0aWEpXG5cdFx0Ly8gSWYgZGFtcGluZyBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLmVuYWJsZURhbXBpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmRhbXBpbmdGYWN0b3IgPSAwLjI1O1xuXG5cdFx0Ly8gVGhpcyBvcHRpb24gYWN0dWFsbHkgZW5hYmxlcyBkb2xseWluZyBpbiBhbmQgb3V0OyBsZWZ0IGFzIFwiem9vbVwiIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nXG5cdFx0dGhpcy5lbmFibGVab29tID0gdHJ1ZTtcblx0XHR0aGlzLnpvb21TcGVlZCA9IDEuMDtcblxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXG5cdFx0dGhpcy5lbmFibGVSb3RhdGUgPSB0cnVlO1xuXHRcdHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XG5cblx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwYW5uaW5nXG5cdFx0dGhpcy5lbmFibGVQYW4gPSB0cnVlO1xuXHRcdHRoaXMua2V5UGFuU3BlZWQgPSA3LjA7XHQvLyBwaXhlbHMgbW92ZWQgcGVyIGFycm93IGtleSBwdXNoXG5cblx0XHQvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxuXHRcdC8vIElmIGF1dG8tcm90YXRlIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuYXV0b1JvdGF0ZVNwZWVkID0gMi4wOyAvLyAzMCBzZWNvbmRzIHBlciByb3VuZCB3aGVuIGZwcyBpcyA2MFxuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXG5cdFx0dGhpcy5lbmFibGVLZXlzID0gdHJ1ZTtcblxuXHRcdC8vIFRoZSBmb3VyIGFycm93IGtleXNcblx0XHR0aGlzLmtleXMgPSB7IExFRlQ6IDM3LCBVUDogMzgsIFJJR0hUOiAzOSwgQk9UVE9NOiA0MCB9O1xuXG5cdFx0Ly8gTW91c2UgYnV0dG9uc1xuXHRcdHRoaXMubW91c2VCdXR0b25zID0geyBPUkJJVDogVEhSRUUuTU9VU0UuTEVGVCwgWk9PTTogVEhSRUUuTU9VU0UuTUlERExFLCBQQU46IFRIUkVFLk1PVVNFLlJJR0hUIH07XG5cblx0XHQvLyBmb3IgcmVzZXRcblx0XHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXHRcdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblx0XHR0aGlzLnpvb20wID0gdGhpcy5vYmplY3Quem9vbTtcblxuXHRcdC8vXG5cdFx0Ly8gcHVibGljIG1ldGhvZHNcblx0XHQvL1xuXG5cdFx0dGhpcy5nZXRQb2xhckFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnBoaTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnRoZXRhO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHNjb3BlLnRhcmdldC5jb3B5KCBzY29wZS50YXJnZXQwICk7XG5cdFx0XHRzY29wZS5vYmplY3QucG9zaXRpb24uY29weSggc2NvcGUucG9zaXRpb24wICk7XG5cdFx0XHRzY29wZS5vYmplY3Quem9vbSA9IHNjb3BlLnpvb20wO1xuXG5cdFx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH07XG5cblx0XHQvLyB0aGlzIG1ldGhvZCBpcyBleHBvc2VkLCBidXQgcGVyaGFwcyBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgd2UgY2FuIG1ha2UgaXQgcHJpdmF0ZS4uLlxuXHRcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBzbyBjYW1lcmEudXAgaXMgdGhlIG9yYml0IGF4aXNcblx0XHRcdHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMoIG9iamVjdC51cCwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXHRcdFx0dmFyIHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVyc2UoKTtcblxuXHRcdFx0dmFyIGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgbGFzdFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlICgpIHtcblxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cblx0XHRcdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0XHQvLyByb3RhdGUgb2Zmc2V0IHRvIFwieS1heGlzLWlzLXVwXCIgc3BhY2Vcblx0XHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdCApO1xuXG5cdFx0XHRcdC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcblx0XHRcdFx0c3BoZXJpY2FsLnNldEZyb21WZWN0b3IzKCBvZmZzZXQgKTtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmF1dG9Sb3RhdGUgJiYgc3RhdGUgPT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0XHRyb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YTtcblx0XHRcdFx0c3BoZXJpY2FsLnBoaSArPSBzcGhlcmljYWxEZWx0YS5waGk7XG5cblx0XHRcdFx0Ly8gcmVzdHJpY3QgdGhldGEgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0XHRzcGhlcmljYWwudGhldGEgPSBNYXRoLm1heCggc2NvcGUubWluQXppbXV0aEFuZ2xlLCBNYXRoLm1pbiggc2NvcGUubWF4QXppbXV0aEFuZ2xlLCBzcGhlcmljYWwudGhldGEgKSApO1xuXG5cdFx0XHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0XHRcdHNwaGVyaWNhbC5waGkgPSBNYXRoLm1heCggc2NvcGUubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oIHNjb3BlLm1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbC5waGkgKSApO1xuXG5cdFx0XHRcdHNwaGVyaWNhbC5tYWtlU2FmZSgpO1xuXG5cblx0XHRcdFx0c3BoZXJpY2FsLnJhZGl1cyAqPSBzY2FsZTtcblxuXHRcdFx0XHQvLyByZXN0cmljdCByYWRpdXMgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0XHRzcGhlcmljYWwucmFkaXVzID0gTWF0aC5tYXgoIHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbiggc2NvcGUubWF4RGlzdGFuY2UsIHNwaGVyaWNhbC5yYWRpdXMgKSApO1xuXG5cdFx0XHRcdC8vIG1vdmUgdGFyZ2V0IHRvIHBhbm5lZCBsb2NhdGlvblxuXHRcdFx0XHRzY29wZS50YXJnZXQuYWRkKCBwYW5PZmZzZXQgKTtcblxuXHRcdFx0XHRvZmZzZXQuc2V0RnJvbVNwaGVyaWNhbCggc3BoZXJpY2FsICk7XG5cblx0XHRcdFx0Ly8gcm90YXRlIG9mZnNldCBiYWNrIHRvIFwiY2FtZXJhLXVwLXZlY3Rvci1pcy11cFwiIHNwYWNlXG5cdFx0XHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXRJbnZlcnNlICk7XG5cblx0XHRcdFx0cG9zaXRpb24uY29weSggc2NvcGUudGFyZ2V0ICkuYWRkKCBvZmZzZXQgKTtcblxuXHRcdFx0XHRzY29wZS5vYmplY3QubG9va0F0KCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cdFx0XHRcdFx0c3BoZXJpY2FsRGVsdGEucGhpICo9ICggMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3BoZXJpY2FsRGVsdGEuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjYWxlID0gMTtcblx0XHRcdFx0cGFuT2Zmc2V0LnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBjb25kaXRpb24gaXM6XG5cdFx0XHRcdC8vIG1pbihjYW1lcmEgZGlzcGxhY2VtZW50LCBjYW1lcmEgcm90YXRpb24gaW4gcmFkaWFucyleMiA+IEVQU1xuXHRcdFx0XHQvLyB1c2luZyBzbWFsbC1hbmdsZSBhcHByb3hpbWF0aW9uIGNvcyh4LzIpID0gMSAtIHheMiAvIDhcblxuXHRcdFx0XHRpZiAoIHpvb21DaGFuZ2VkIHx8XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKCBzY29wZS5vYmplY3QucG9zaXRpb24gKSA+IEVQUyB8fFxuXHRcdFx0XHRcdDggKiAoIDEgLSBsYXN0UXVhdGVybmlvbi5kb3QoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICkgKSA+IEVQUyApIHtcblxuXHRcdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XG5cblx0XHRcdFx0XHRsYXN0UG9zaXRpb24uY29weSggc2NvcGUub2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0XHRcdFx0bGFzdFF1YXRlcm5pb24uY29weSggc2NvcGUub2JqZWN0LnF1YXRlcm5pb24gKTtcblx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKTtcblxuXHRcdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUsIGZhbHNlICk7XG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIGZhbHNlICk7XG5cblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XG5cblx0XHRcdC8vc2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApOyAvLyBzaG91bGQgdGhpcyBiZSBhZGRlZCBoZXJlP1xuXG5cdFx0fTtcblxuXHRcdC8vXG5cdFx0Ly8gaW50ZXJuYWxzXG5cdFx0Ly9cblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5cdFx0dmFyIHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCcgfTtcblx0XHR2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnIH07XG5cblx0XHR2YXIgU1RBVEUgPSB7IE5PTkUgOiAtIDEsIFJPVEFURSA6IDAsIERPTExZIDogMSwgUEFOIDogMiwgVE9VQ0hfUk9UQVRFIDogMywgVE9VQ0hfRE9MTFkgOiA0LCBUT1VDSF9QQU4gOiA1IH07XG5cblx0XHR2YXIgc3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0Ly8gY3VycmVudCBwb3NpdGlvbiBpbiBzcGhlcmljYWwgY29vcmRpbmF0ZXNcblx0XHR2YXIgc3BoZXJpY2FsID0gbmV3IFRIUkVFLlNwaGVyaWNhbCgpO1xuXHRcdHZhciBzcGhlcmljYWxEZWx0YSA9IG5ldyBUSFJFRS5TcGhlcmljYWwoKTtcblxuXHRcdHZhciBzY2FsZSA9IDE7XG5cdFx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gZmFsc2U7XG5cblx0XHR2YXIgcm90YXRlU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdHZhciByb3RhdGVFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdHZhciByb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHR2YXIgcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdHZhciBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdHZhciBwYW5EZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHR2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0dmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHR2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRmdW5jdGlvbiBnZXRBdXRvUm90YXRpb25BbmdsZSgpIHtcblxuXHRcdFx0cmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcblxuXHRcdFx0cmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJvdGF0ZUxlZnQoIGFuZ2xlICkge1xuXG5cdFx0XHRzcGhlcmljYWxEZWx0YS50aGV0YSAtPSBhbmdsZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJvdGF0ZVVwKCBhbmdsZSApIHtcblxuXHRcdFx0c3BoZXJpY2FsRGVsdGEucGhpIC09IGFuZ2xlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBhbkxlZnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuTGVmdCggZGlzdGFuY2UsIG9iamVjdE1hdHJpeCApIHtcblxuXHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApOyAvLyBnZXQgWCBjb2x1bW4gb2Ygb2JqZWN0TWF0cml4XG5cdFx0XHRcdHYubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgKTtcblxuXHRcdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHR2YXIgcGFuVXAgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuVXAoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDEgKTsgLy8gZ2V0IFkgY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xuXG5cdFx0XHRcdHBhbk9mZnNldC5hZGQoIHYgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKTtcblxuXHRcdC8vIGRlbHRhWCBhbmQgZGVsdGFZIGFyZSBpbiBwaXhlbHM7IHJpZ2h0IGFuZCBkb3duIGFyZSBwb3NpdGl2ZVxuXHRcdHZhciBwYW4gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYW4gKCBkZWx0YVgsIGRlbHRhWSApIHtcblxuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0Ly8gcGVyc3BlY3RpdmVcblx0XHRcdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cdFx0XHRcdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCBzY29wZS50YXJnZXQgKTtcblx0XHRcdFx0XHR2YXIgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG5cblx0XHRcdFx0XHQvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cblx0XHRcdFx0XHR0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbiggKCBzY29wZS5vYmplY3QuZm92IC8gMiApICogTWF0aC5QSSAvIDE4MC4wICk7XG5cblx0XHRcdFx0XHQvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XG5cdFx0XHRcdFx0cGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblx0XHRcdFx0XHRwYW5VcCggMiAqIGRlbHRhWSAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHQvLyBvcnRob2dyYXBoaWNcblx0XHRcdFx0XHRwYW5MZWZ0KCBkZWx0YVggKiAoIHNjb3BlLm9iamVjdC5yaWdodCAtIHNjb3BlLm9iamVjdC5sZWZ0ICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50V2lkdGgsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblx0XHRcdFx0XHRwYW5VcCggZGVsdGFZICogKCBzY29wZS5vYmplY3QudG9wIC0gc2NvcGUub2JqZWN0LmJvdHRvbSApIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgbm9yIHBlcnNwZWN0aXZlXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLicgKTtcblx0XHRcdFx0XHRzY29wZS5lbmFibGVQYW4gPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHRmdW5jdGlvbiBkb2xseUluKCBkb2xseVNjYWxlICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KCBzY29wZS5taW5ab29tLCBNYXRoLm1pbiggc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gKiBkb2xseVNjYWxlICkgKTtcblx0XHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0em9vbUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvbGx5T3V0KCBkb2xseVNjYWxlICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KCBzY29wZS5taW5ab29tLCBNYXRoLm1pbiggc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gLyBkb2xseVNjYWxlICkgKTtcblx0XHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0em9vbUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cdFx0Ly8gZXZlbnQgY2FsbGJhY2tzIC0gdXBkYXRlIHRoZSBvYmplY3Qgc3RhdGVcblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUm90YXRlKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93blJvdGF0ZScgKTtcblxuXHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Eb2xseSggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25Eb2xseScgKTtcblxuXHRcdFx0ZG9sbHlTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blBhbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25QYW4nICk7XG5cblx0XHRcdHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUm90YXRlKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZVJvdGF0ZScgKTtcblxuXHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG5cdFx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuXHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlRG9sbHknICk7XG5cblx0XHRcdGRvbGx5RW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cblx0XHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuXHRcdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkb2xseURlbHRhLnkgPCAwICkge1xuXG5cdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlUGFuJyApO1xuXG5cdFx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcblxuXHRcdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VVcCcgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VXaGVlbCcgKTtcblxuXHRcdFx0aWYgKCBldmVudC5kZWx0YVkgPCAwICkge1xuXG5cdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC5kZWx0YVkgPiAwICkge1xuXG5cdFx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZUtleURvd24nICk7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxuXHRcdFx0XHRcdHBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuXHRcdFx0XHRcdHBhbiggMCwgLSBzY29wZS5rZXlQYW5TcGVlZCApO1xuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuXHRcdFx0XHRcdHBhbiggc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcblx0XHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG5cdFx0XHRcdFx0cGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydFJvdGF0ZScgKTtcblxuXHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnREb2xseScgKTtcblxuXHRcdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xuXHRcdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cblx0XHRcdGRvbGx5U3RhcnQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0UGFuJyApO1xuXG5cdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlUm90YXRlJyApO1xuXG5cdFx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG5cdFx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuXHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlRG9sbHknICk7XG5cblx0XHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcblxuXHRcdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0XHRkb2xseUVuZC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cblx0XHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuXHRcdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkb2xseURlbHRhLnkgPCAwICkge1xuXG5cdFx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVQYW4nICk7XG5cblx0XHRcdHBhbkVuZC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcblxuXHRcdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoRW5kJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBldmVudCBoYW5kbGVycyAtIEZTTTogbGlzdGVuIGZvciBldmVudHMgYW5kIHJlc2V0IHN0YXRlXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0aWYgKCBldmVudC5idXR0b24gPT09IHNjb3BlLm1vdXNlQnV0dG9ucy5PUkJJVCApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VEb3duUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IHNjb3BlLm1vdXNlQnV0dG9ucy5aT09NICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VEb3duRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5ET0xMWTtcblxuXHRcdFx0fSBlbHNlIGlmICggZXZlbnQuYnV0dG9uID09PSBzY29wZS5tb3VzZUJ1dHRvbnMuUEFOICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5QQU47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRpZiAoIHN0YXRlID09PSBTVEFURS5ST1RBVEUgKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLkRPTExZICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5QQU4gKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZVVwKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0aGFuZGxlTW91c2VVcCggZXZlbnQgKTtcblxuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgfHwgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSAmJiBzdGF0ZSAhPT0gU1RBVEUuUk9UQVRFICkgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0aGFuZGxlTW91c2VXaGVlbCggZXZlbnQgKTtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApOyAvLyBub3Qgc3VyZSB3aHkgdGhlc2UgYXJlIGhlcmUuLi5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbktleURvd24oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZUtleXMgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGhhbmRsZUtleURvd24oIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRjYXNlIDE6XHQvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAyOlx0Ly8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnREb2xseSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUk9UQVRFICkgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuXHRcdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ET0xMWSApIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTiApIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVQYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblRvdWNoRW5kKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0aGFuZGxlVG91Y2hFbmQoIGV2ZW50ICk7XG5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoIGV2ZW50ICkge1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UgKTtcblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xuXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIGZhbHNlICk7XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XG5cblx0XHQvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fTtcblxuXHRPcmJpdENvbnRyb2xzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcblx0T3JiaXRDb250cm9scy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmJpdENvbnRyb2xzO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPcmJpdENvbnRyb2xzLnByb3RvdHlwZSwge1xuXG5cdFx0Y2VudGVyOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5jZW50ZXIgaGFzIGJlZW4gcmVuYW1lZCB0byAudGFyZ2V0JyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50YXJnZXQ7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cblx0XHRub1pvb206IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vWm9vbSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVpvb20gaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlWm9vbTtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1pvb20gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVab29tIGluc3RlYWQuJyApO1xuXHRcdFx0XHR0aGlzLmVuYWJsZVpvb20gPSAhIHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0bm9Sb3RhdGU6IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vUm90YXRlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUm90YXRlIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVJvdGF0ZTtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1JvdGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVJvdGF0ZSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0dGhpcy5lbmFibGVSb3RhdGUgPSAhIHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0bm9QYW46IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vUGFuIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUGFuIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVBhbjtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1BhbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVBhbiBpbnN0ZWFkLicgKTtcblx0XHRcdFx0dGhpcy5lbmFibGVQYW4gPSAhIHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0bm9LZXlzOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub0tleXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVLZXlzIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZUtleXM7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9LZXlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlS2V5cyBpbnN0ZWFkLicgKTtcblx0XHRcdFx0dGhpcy5lbmFibGVLZXlzID0gISB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHN0YXRpY01vdmluZyA6IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLnN0YXRpY01vdmluZyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZURhbXBpbmcgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlRGFtcGluZztcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5zdGF0aWNNb3ZpbmcgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVEYW1waW5nIGluc3RlYWQuJyApO1xuXHRcdFx0XHR0aGlzLmVuYWJsZURhbXBpbmcgPSAhIHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0ZHluYW1pY0RhbXBpbmdGYWN0b3IgOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5keW5hbWljRGFtcGluZ0ZhY3RvciBoYXMgYmVlbiByZW5hbWVkLiBVc2UgLmRhbXBpbmdGYWN0b3IgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRhbXBpbmdGYWN0b3I7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyApO1xuXHRcdFx0XHR0aGlzLmRhbXBpbmdGYWN0b3IgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRyZXR1cm4gT3JiaXRDb250cm9scztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGhyZWUtb3JiaXQtY29udHJvbHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDAyLjAzLjIwMTcuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtQnV0dG9uIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XHJcbiAgICAgICAgdGhpcy5hdHRycyA9IG9wdGlvbnMuYXR0cnMgfHwgW107XHJcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQob3B0aW9ucy50eXBlKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0QXR0cnMoYXR0cnMpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RWxlbSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSB0aGlzLnRleHQ7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cnModGhpcy5hdHRycyk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwub3V0ZXJIVE1MO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VsZW1lbnRzL2Zvcm0vX19idXR0b24vZm9ybS1idXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDAyLjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgQ2hlY2tGaWVsZHMgZnJvbSBcIi4uLy4uLy4uL2pzL21lbnUvYWN0aW9ucy9DaGVja0ZpZWxkc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcclxuICAgICAgICB0aGlzLmF0dHJzID0gb3B0aW9ucy5hdHRycyB8fCBbXTtcclxuICAgICAgICB0aGlzLmhlbHBfYXR0cnMgPSBvcHRpb25zLmhlbHBfYXR0cnMgfHwgW107XHJcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICAgICAgdGhpcy5oZWxwX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIF9zZXRBdHRycyhhdHRycywgZWxlbSkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBfcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJzKHRoaXMuYXR0cnMsIHRoaXMuZWwpO1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJzKHRoaXMuaGVscF9hdHRycywgdGhpcy5oZWxwX2VsKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFbGVtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsLm91dGVySFRNTDtcclxuICAgIH1cclxuXHJcbiAgICB2YWxpZGF0ZShwcmV2KSB7XHJcbiAgICAgICAgbGV0IGNoZWNrID0gdHJ1ZTtcclxuICAgICAgICBpZiAoQ2hlY2tGaWVsZHMuY2hlY2tFbXB0eSh0aGlzLmVsLnZhbHVlKSkge1xyXG4gICAgICAgICAgICBDaGVja0ZpZWxkcy5maWVsZFNldEVycih0aGlzLmVsKTtcclxuICAgICAgICAgICAgQ2hlY2tGaWVsZHMuaGVscFNldFRleHQodGhpcy5oZWxwX2VsLCAnZW1wdHkgZmllbGQnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDaGVja0ZpZWxkcy5maWVsZFJlbW92ZUVycih0aGlzLmVsKTtcclxuICAgICAgICBDaGVja0ZpZWxkcy5oZWxwU2V0VGV4dCh0aGlzLmhlbHBfZWwsICcnKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgndmFsaWQnKTtcclxuICAgICAgICBpZiAodmFsaWQgPT09ICdsb2dpbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoZWNrRmllbGRzLmNoZWNrTG9naW4oe2ZpZWxkOiB0aGlzLmVsLCBoZWxwOiB0aGlzLmhlbHBfZWx9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbGlkID09PSAncGFzc3dvcmQnKSB7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsaWQgPT09ICdyZXBlYXRwYXNzd29yZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoZWNrRmllbGRzLmNoZWNrUGFzc3dvcmQoXHJcbiAgICAgICAgICAgICAgICB7ZmllbGQ6IHByZXYuZWwsIGhlbHA6IHByZXYuaGVscF9lbH0sXHJcbiAgICAgICAgICAgICAgICB7ZmllbGQ6IHRoaXMuZWwsIGhlbHA6IHRoaXMuaGVscF9lbH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoZWNrO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIENoZWNrRmllbGRzLmhlbHBTZXRUZXh0KHRoaXMuaGVscF9lbCwgJycpO1xyXG4gICAgICAgIENoZWNrRmllbGRzLmZpZWxkU2V0VGV4dCh0aGlzLmVsLCAnJyk7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRSZW1vdmVPayh0aGlzLmVsKTtcclxuICAgICAgICBDaGVja0ZpZWxkcy5maWVsZFJlbW92ZUVycih0aGlzLmVsKTtcclxuICAgIH1cclxuXHJcbiAgICAvL25vaW5zcGVjdGlvbiBKU0R1cGxpY2F0ZWREZWNsYXJhdGlvblxyXG4gICAgc2V0RXJyb3IoKSB7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRTZXRFcnIodGhpcy5lbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9ub2luc3BlY3Rpb24gSlNEdXBsaWNhdGVkRGVjbGFyYXRpb25cclxuICAgIHNldEVycm9yKHZhbHVlKSB7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRTZXRFcnIodGhpcy5lbCk7XHJcbiAgICAgICAgQ2hlY2tGaWVsZHMuaGVscFNldFRleHQodGhpcy5oZWxwX2VsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZWxlbWVudHMvZm9ybS9fX2lucHV0L2Zvcm0taW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDA4LjA0LjIwMTcuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lQ29udHJvbHN7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlKXtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpe1xyXG4gICAgICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdjb21tYW5kLWRpdicpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2dhbWUtY29udHJvbHMnKTtcclxuXHJcbiAgICAgICAgbGV0IGNvbW1hbmRCb3g9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XHJcbiAgICAgICAgY29tbWFuZEJveC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2NvbW1hbmRzJyk7XHJcbiAgICAgICAgY29tbWFuZEJveC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2dhbWUtY29udHJvbHNfX3RleHRhcmVhJyk7XHJcbiAgICAgICAgY29tbWFuZEJveC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgJ1lvdXIgY29tbWFuZHMnKTtcclxuXHJcbiAgICAgICAgbGV0IGJ0blN0ZXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBidG5TdGVwLnNldEF0dHJpYnV0ZSgnaWQnLCAnYnRuLW5leHQtc3RlcCcpO1xyXG4gICAgICAgIGJ0blN0ZXAuc2V0QXR0cmlidXRlKCdjbGFzcycsICdnYW1lLWNvbnRyb2xzX19idXR0b24nKTtcclxuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcclxuICAgICAgICB0ZXh0LmlubmVyVGV4dCA9ICdDcmVhdGUgc3RlcCc7XHJcbiAgICAgICAgYnRuU3RlcC5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuXHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbW1hbmRCb3gpO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidG5TdGVwKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VsZW1lbnRzL2dhbWUtY29udHJvbHMvR2FtZUNvbnRyb2xzLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAwMi4wNC4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IEdhbWVTY2VuZSBmcm9tIFwiLi9HYW1lU2NlbmVcIjtcclxuaW1wb3J0IFNpbmdsZVBsYXllclN0cmF0ZWd5IGZyb20gXCIuL3N0cmF0ZWdpZXMvU2luZ2xlcGxheWVyXCI7XHJcbmltcG9ydCBNdWx0aVBsYXllclN0cmF0ZWd5IGZyb20gXCIuL3N0cmF0ZWdpZXMvTXVsdGlwbGF5ZXJcIjtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZSwgdmlldywgc3RyYXRlZ3kpIHtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVkID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5ID09PSB0aGlzLnN0b3JhZ2UuZ2FtZVN0YXRlcy5TSU5HTEVQTEFZRVJfU1RSQVRFR1kgPyBuZXcgU2luZ2xlUGxheWVyU3RyYXRlZ3koKSA6IG5ldyBNdWx0aVBsYXllclN0cmF0ZWd5KCk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gdmlldy5ub2RlO1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcblxyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgR2FtZVNjZW5lKHZpZXcubm9kZSwgdGhpcy5zdG9yYWdlKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc3RhcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCd0LDRh9Cw0YLRjCDQuNCz0YDQvtCy0L7QuSDQv9GA0L7RhtC10YHRgVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3N0YXJ0KCl7XHJcbiAgICAgICAgLy9UT0RPIHN0YXJ0IHN0cmF0ZWd5XHJcbiAgICAgICAgdGhpcy5zY2VuZS5zZXRTdGF0ZSh0aGlzLnN0b3JhZ2UuZ2FtZVN0YXRlcy5TVEFURVdBSVQpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vcHBvbmVudCA9IHRoaXMuX2dldE9wcG9uZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0UGxheWVycyh0aGlzLnN0b3JhZ2UudXNlciwgdGhpcy5vcHBvbmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0U3RhdGUodGhpcy5zdG9yYWdlLmdhbWVTdGF0ZXMuU1RBVEVHQU1FKTtcclxuICAgICAgICB9LCAxMDAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7Qu9GD0YfQuNGC0Ywg0L/RgNC+0YLQuNCy0L3QuNC60LBcclxuICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0T3Bwb25lbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RyYXRlZ3kuY29uc3RydWN0b3IubmFtZSA9PT0gU2luZ2xlUGxheWVyU3RyYXRlZ3kubmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge2xvZ2luOiAnZGMuRFJFJ307XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9UT0RPIHNlYXJjaCBmb3Igb3Bwb25lbnQgaW4gZ2xvYmFsXHJcbiAgICAgICAgICAgIHJldHVybiB7bG9naW46ICdNVUxUSVBMQVlFUid9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWUvbW9kdWxlcy9HYW1lTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMjkuMDMuMjAxNy5cclxuICovXHJcbi8vIGltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCIuLi8uLi8uLi8uLi92ZW5kb3IvdGhyZWVcIjtcclxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7XHJcbmltcG9ydCAqIGFzIE9JTU8gZnJvbSBcIm9pbW9cIjtcclxuXHJcbmltcG9ydCBPYmpQZXJzb24gZnJvbSBcIi4vT2JqUGVyc29uXCI7XHJcbmltcG9ydCBHYW1lQ29udHJvbHMgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2dhbWUtY29udHJvbHMvR2FtZUNvbnRyb2xzXCI7XHJcbmNvbnN0IE9yYml0Q29udHJvbHMgPSByZXF1aXJlKCd0aHJlZS1vcmJpdC1jb250cm9scycpKFRIUkVFKTtcclxuLy8gaW1wb3J0ICogYXMgT3JiaXRDb250cm9scyBmcm9tICd0aHJlZS1vcmJpdC1jb250cm9scyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lU2NlbmUge1xyXG4gICAgY29uc3RydWN0b3Iobm9kZSwgc3RvcmFnZSkge1xyXG4gICAgICAgIHRoaXMuSERpbSA9IDM0O1xyXG4gICAgICAgIHRoaXMuV0RpbSA9IDUwO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcblxyXG4gICAgICAgIHRoaXMuX3NldFNpemUoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJDb250YWluZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0U2l6ZSgpIHtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5maWVsZFNpemUgPSAoaGVpZ2h0IC8gdGhpcy5IRGltKSB8IDA7XHJcbiAgICAgICAgdGhpcy5XSURUSCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgIHRoaXMuSEVHSFQgPSB0aGlzLmZpZWxkU2l6ZSAvIDMgKiAyICogdGhpcy5IRGltO1xyXG4gICAgfVxyXG5cclxuICAgIF9vbldpbmRvd1Jlc2l6ZSgpIHtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLmZpZWxkU2l6ZSA9IChoZWlnaHQgLyB0aGlzLkhEaW0pIHwgMDtcclxuICAgICAgICB0aGlzLldJRFRIID0gd2luZG93LmlubmVyV2lkdGg7XHJcblxyXG4gICAgICAgIHRoaXMuSEVHSFQgPSB0aGlzLmZpZWxkU2l6ZSAvIDMgKiAyICogdGhpcy5IRGltO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY2FtZXJhIHx8ICF0aGlzLnJlbmRlcmVyKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMuV0lEVEggLyB0aGlzLkhFR0hUO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMuV0lEVEgsIHRoaXMuSEVHSFQpO1xyXG4gICAgfVxyXG5cclxuICAgIF9pbml0TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9scyA9IG5ldyBPcmJpdENvbnRyb2xzKHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXJDb250YWluZXIoKSB7XHJcbiAgICAgICAgLyogaW5pdCBmaWd1cmVzIGFyciovXHJcbiAgICAgICAgdGhpcy53b3JsZEJvZGllcyA9IFtdO1xyXG4gICAgICAgIHRoaXMud29ybGRNZXNoZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgYWxwaGE6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNjZW5lLmZvZyA9IG5ldyBUSFJFRS5Gb2dFeHAyKDB4ZmZmZmZmLCAwLjAwMik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMuc2NlbmUuZm9nLmNvbG9yKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMuV0lEVEgsIHRoaXMuSEVHSFQpO1xyXG4gICAgICAgIHRoaXMuX2FkZFN0eWxlc1RvQ29udGFpbmVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsICdnYW1lLXZpZXdfX2NvbnRhaW5lcicpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIHRoaXMud29ybGQgPSBuZXcgT0lNTy5Xb3JsZCgxIC8gNjAsIDIsIDgpO1xyXG5cclxuICAgICAgICB0aGlzLl9hZGRDYW1lcmEoKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRlKCk7XHJcbiAgICAgICAgdGhpcy5faW5pdExpc3RlbmVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIF9hZGRTdHlsZXNUb0NvbnRhaW5lcigpe1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2dhbWUtdmlld19fZ2FtZS1hcmVhJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCAnZ2FtZS1hcmVhJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQo9GB0YLQsNC90L7QstC40YLRjCDRgtC10LrRg9GJ0LXQtSDRgdC+0YHRgtC+0Y/QvdC40LVcclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtINGB0L7RgdGC0L7Rj9C90LjQtVxyXG4gICAgICovXHJcbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J7RgtGA0LjRgdC+0LLQutCwLCDQvtGC0L3QvtGB0LjRgtC10LvRjNC90L4g0LLRhdC+0LTQvdC+0LPQviDRgdC+0LHRi9GC0LjRj1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3JlbmRlclN0YXRlKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlIHRoaXMuc3RvcmFnZS5nYW1lU3RhdGVzLlNUQVRFV0FJVDoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyV2FpdFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHRoaXMuc3RvcmFnZS5nYW1lU3RhdGVzLlNUQVRFR0FNRToge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyR2FtZVN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHRoaXMuc3RvcmFnZS5nYW1lU3RhdGVzLlNUQVRFUkVTVUxUOiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJSZXN1bHRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAg0LbQtNGD0YnQtdCz0L4g0YDQtdC20LjQvNCwXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyV2FpdFN0YXRlKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgLyogTGlnaHRzICovXHJcbiAgICAgICAgbGV0IHNwb3RMaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoMHhmZmZmZmYpO1xyXG4gICAgICAgIHNwb3RMaWdodC5wb3NpdGlvbi5zZXQoMCwgMjAsIDMwKTtcclxuICAgICAgICB0aGlzLnNjZW5lLmFkZChzcG90TGlnaHQpO1xyXG5cclxuICAgICAgICAvKiBmaWd1cmUgd2hlcmUgZmllbGQgaW4qL1xyXG4gICAgICAgIGxldCBvY3RhaGVkcm9uR2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KDQsIDApO1xyXG4gICAgICAgIGxldCBvY3RhaGVkcm9uTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbChcclxuICAgICAgICAgICAge2NvbG9yOiAweGZmMDAwMH0pO1xyXG4gICAgICAgIGxldCBvY3RhaGVkcm9uID0gbmV3IFRIUkVFLk1lc2gob2N0YWhlZHJvbkdlb21ldHJ5LCBvY3RhaGVkcm9uTWF0ZXJpYWwpO1xyXG4gICAgICAgIG9jdGFoZWRyb24ucG9zaXRpb24uc2V0KDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKG9jdGFoZWRyb24pO1xyXG5cclxuICAgICAgICBsZXQgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XHJcbiAgICAgICAgICAgIG9jdGFoZWRyb24ucm90YXRpb24ueSArPSAwLjAyO1xyXG4gICAgICAgICAgICAvL3RoaXMucmVmcmVzaFNjZW5lKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQuNCz0YDQvtCy0L7Qs9C+INGA0LXQttC40LzQsFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3JlbmRlckdhbWVTdGF0ZSgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fYW5pbUNhbWVyYSgpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckNvbnRyb2xBcmVhKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3JlbmRlckZpZWxkKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyUGxheWVycygpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFNjZW5lKCk7XHJcblxyXG4gICAgICAgIHRoaXMubWVQZXJzb24uZGVwbnV0KCk7XHJcblxyXG4gICAgICAgICB0aGlzLl9yZW5kZXJOYW1lcygpO1xyXG4gICAgICAgICB0aGlzLl9yZW5kZXJIZWFsdGhCYXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlbmRlckZpZWxkKCkge1xyXG4gICAgICAgIGxldCBheGVzID0gbmV3IFRIUkVFLkF4aXNIZWxwZXIoMjApO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKGF4ZXMpO1xyXG5cclxuICAgICAgICAvL2RvbWVcclxuICAgICAgICBsZXQgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSg3MDAsIDEpO1xyXG4gICAgICAgIGxldCBkb21lTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xyXG4gICAgICAgICAgICBjb2xvcjogMHgzNUZCRTAsXHJcbiAgICAgICAgICAgIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLFxyXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBkb21lID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIGRvbWVNYXRlcmlhbCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQoZG9tZSk7XHJcblxyXG4gICAgICAgIC8vbGlnaHRcclxuICAgICAgICBsZXQgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweDQxOThCNSk7XHJcbiAgICAgICAgbGlnaHQucG9zaXRpb24uc2V0KDEsIDEsIDEpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKGxpZ2h0KTtcclxuICAgICAgICBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4NDE5OEI1KTtcclxuICAgICAgICBsaWdodC5wb3NpdGlvbi5zZXQoMSwgLTEsIDApO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKGxpZ2h0KTtcclxuICAgICAgICBsaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoMHg0MTk4QjUpO1xyXG4gICAgICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgtMSwgMSwgMCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQobGlnaHQpO1xyXG5cclxuICAgICAgICBsZXQgcGxhbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDEwMDAsIDEwMDAsIDQwLCA0MCk7XHJcbiAgICAgICAgbGV0IHBsYW5lTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmLCB3aXJlZnJhbWU6IHRydWV9KTtcclxuICAgICAgICBsZXQgcGxhbmUgPSBuZXcgVEhSRUUuTWVzaChwbGFuZUdlb21ldHJ5LCBwbGFuZU1hdGVyaWFsKTtcclxuICAgICAgICBwbGFuZS5yb3RhdGlvbi54ID0gLTAuNSAqIE1hdGguUEk7XHJcbiAgICAgICAgcGxhbmUucG9zaXRpb24uc2V0KDAsIC0xMCwgMCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQocGxhbmUpO1xyXG5cclxuICAgICAgICB0aGlzLndvcmxkLmFkZCh7XHJcbiAgICAgICAgICAgIHNpemU6IFsxMDAwLCAxMCwgMTAwMF0sXHJcbiAgICAgICAgICAgIHBvczogWzAsIC0xMCwgMF0sXHJcbiAgICAgICAgICAgIHdvcmxkOiB0aGlzLndvcmxkLFxyXG4gICAgICAgICAgICBkZW5zaXR5OiAxLFxyXG4gICAgICAgICAgICBjb2xsaWRlc1dpdGg6IDB4ZmZmZmZmZmZcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy53b3JsZC5ncmF2aXR5ID0gbmV3IE9JTU8uVmVjMygwLCAwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBfcmVuZGVyUGxheWVycygpIHtcclxuICAgICAgICB0aGlzLm1lUGVyc29uID0gbmV3IE9ialBlcnNvbih0aGlzLnNjZW5lLCB0aGlzKTtcclxuICAgICAgICB0aGlzLm1lUGVyc29uLnJlbmRlcigncmlnaHQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5vcHBvbmVudFBlcnNvbiA9IG5ldyBPYmpQZXJzb24odGhpcy5zY2VuZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5vcHBvbmVudFBlcnNvbi5yZW5kZXIoJ2xlZnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBfYWRkQ2FtZXJhKCkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1XHJcbiAgICAgICAgICAgICwgdGhpcy5XSURUSCAvIHRoaXMuSEVHSFQsIDAuMSwgMTAwMCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldCgwLDI1LDgwKTtcclxuICAgICAgICB0aGlzLmNhbWVyYS5sb29rQXQodGhpcy5zY2VuZS5wb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgX2FuaW1hdGUoKSB7XHJcbiAgICAgICAgbGV0IHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hTY2VuZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaFNjZW5lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLndvcmxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMud29ybGQuc3RlcCgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy53b3JsZEJvZGllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGIgPSB0aGlzLndvcmxkQm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IG0gPSB0aGlzLndvcmxkTWVzaGVzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghYi5zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIG0ucG9zaXRpb24uY29weShiLmdldFBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG0ucXVhdGVybmlvbi5jb3B5KGIuZ2V0UXVhdGVybmlvbigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBfYW5pbUNhbWVyYSgpe1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldCgwLDAsMTAwMCk7XHJcbiAgICAgICAgbGV0IHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPiA2MCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiAtPSAxMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLnNjZW5lLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMuY2FtZXJhLnBvc2l0aW9uLnkgPCAzMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi55ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5sb29rQXQodGhpcy5zY2VuZS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXJDb250cm9sQXJlYSgpIHtcclxuICAgICAgICB0aGlzLmdhbWVDb250cm9scyA9IG5ldyBHYW1lQ29udHJvbHModGhpcy5jb250YWluZXIpO1xyXG4gICAgICAgIHRoaXMuZ2FtZUNvbnRyb2xzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J7RgtGA0LjRgdC+0LLQutCwINC/0L7RgdC70LXQuNCz0YDQvtCy0L7Qs9C+INGA0LXQttC40LzQsCAo0YDQtdC30YPQu9GM0YLQsNGC0YssINC40YLQvtCz0LgpXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyUmVzdWx0U3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXJOYW1lcygpe1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBfcmVuZGVySGVhbHRoQmFycygpe1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRh9C40YHRgtC60LAg0L7RgdC90L7QstC90L7Qs9C+INC60L7QvdGC0LXQudC90LXRgNCwXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuY2hpbGRyZW4uc3BsaWNlKDAsIHRoaXMuc2NlbmUuY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hTY2VuZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KPRgdGC0LDQvdC+0LLQutCwINC00LDQvdC90YvRhSDQuNCz0YDQvtC60L7QslxyXG4gICAgICogQHBhcmFtIG1lXHJcbiAgICAgKiBAcGFyYW0gb3Bwb25lbnRcclxuICAgICAqL1xyXG4gICAgc2V0UGxheWVycyhtZSwgb3Bwb25lbnQpIHtcclxuICAgICAgICB0aGlzLnBsYXllcnMgPSB7bWU6IG1lLCBvcHBvbmVudDogb3Bwb25lbnR9O1xyXG4gICAgfVxyXG5cclxuICAgIHNldFVzZXJSZXN1bHQob2JqUmVzdWx0LCB1c2VyKSB7XHJcbiAgICAgICAgdGhpcy5vYmpSZXN1bHQgPSBvYmpSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG5cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWUvbW9kdWxlcy9HYW1lU2NlbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDA1LjA0LjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqUGVyc29uIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBzY2VuZUNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgdGhpcy5zY2VuZUNvbnRleHQgPSBzY2VuZUNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKFxyXG4gICAgICAgICAgICB7Y29sb3I6IDB4Nzc3N2ZmIC8qc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsKi8sIHNraW5uaW5nOiB0cnVlfSk7XHJcblxyXG4gICAgICAgIHRoaXMucGVyc29uQ29uc3QgPSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgIHg6IDEwLFxyXG4gICAgICAgICAgICAgICAgeTogNyxcclxuICAgICAgICAgICAgICAgIHo6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RhcnRTY2FsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMixcclxuICAgICAgICAgICAgICAgIHk6IDIsXHJcbiAgICAgICAgICAgICAgICB6OiAyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0YXJ0Um90YXRpb246IHtcclxuICAgICAgICAgICAgICAgIHg6IE1hdGguUEkgLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIHo6IE1hdGguUEkgLyAyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKHBhcnRPZikge1xyXG4gICAgICAgIHRoaXMucGFydE9mID0gcGFydE9mO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckJvZHlPblN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlbmRlckJvZHlPblN0YXJ0KCkge1xyXG4gICAgICAgIGxldCBsb2FkZXIgPSBuZXcgVEhSRUUuSlNPTkxvYWRlcigpO1xyXG4gICAgICAgIGxvYWRlci5sb2FkKCcvc3JjL3RocmVlLW1vZGVscy9wbGF5ZXIuanNvbicsIChtb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5wYXJ0T2YgPT09ICdsZWZ0JyA/IDB4RkYwMDM3IDogMHgwMEZGNTE7XHJcbiAgICAgICAgICAgIGxldCBtYXQgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7Y29sb3I6IGNvbG9yLCBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZywgc2tpbm5pbmc6IHRydWV9KTtcclxuICAgICAgICAgICAgdGhpcy5wZXJzb24gPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2gobW9kZWwsIG1hdCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLnBhcnRPZiA9PT0gJ2xlZnQnID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB0aGlzLnBlcnNvbi5wb3NpdGlvbi5zZXQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlcnNvbkNvbnN0LnN0YXJ0UG9zaXRpb24ueCAqIHBvcyxcclxuICAgICAgICAgICAgICAgIHRoaXMucGVyc29uQ29uc3Quc3RhcnRQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJzb25Db25zdC5zdGFydFBvc2l0aW9uLnpcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5wZXJzb24uc2NhbGUuc2V0KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJzb25Db25zdC5zdGFydFNjYWxlLngsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlcnNvbkNvbnN0LnN0YXJ0U2NhbGUueSxcclxuICAgICAgICAgICAgICAgIHRoaXMucGVyc29uQ29uc3Quc3RhcnRTY2FsZS56XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMucGVyc29uLnJvdGF0aW9uLnNldChcclxuICAgICAgICAgICAgICAgIHRoaXMucGVyc29uQ29uc3Quc3RhcnRSb3RhdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJzb25Db25zdC5zdGFydFJvdGF0aW9uLnksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlcnNvbkNvbnN0LnN0YXJ0Um90YXRpb24ueiAqIHBvc1xyXG4gICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMucGVyc29uLnNrZWxldG9uLmJvbmVzWzE3XS5wb3NpdGlvbi55ICs9IC0yO1xyXG4gICAgICAgICAgICB0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1sxN10ucG9zaXRpb24ueiArPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5wZXJzb24uc2tlbGV0b24uYm9uZXNbMTVdLnJvdGF0aW9uLnggKz0gTWF0aC5QSSAvIDY7XHJcbiAgICAgICAgICAgIHRoaXMucGVyc29uLnNrZWxldG9uLmJvbmVzWzE2XS5yb3RhdGlvbi54ICs9IC1NYXRoLlBJIC8gNDtcclxuICAgICAgICAgICAvKiB0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1sxNl0ucG9zaXRpb24ueSArPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5wZXJzb24uc2tlbGV0b24uYm9uZXNbMTVdLnBvc2l0aW9uLnkgKz0gLTE7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1sxNF0ucG9zaXRpb24ueSArPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1sxM10ucG9zaXRpb24ueSArPSAxLjU7XHJcbiAgICAgICAgICAgIHRoaXMucGVyc29uLnNrZWxldG9uLmJvbmVzWzEyXS5wb3NpdGlvbi55ICs9IDE7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1sxMl0ucm90YXRpb24ueiArPSBNYXRoLlBJIC8gMjsqL1xyXG5cclxuICAgICAgICAgICAgLyp0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1s1XS5yb3RhdGlvbi55ICs9IE1hdGguUEkgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1s1XS5yb3RhdGlvbi56ICs9IE1hdGguUEkgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLnBlcnNvbi5za2VsZXRvbi5ib25lc1s2XS5yb3RhdGlvbi55ICs9IDMgKiBNYXRoLlBJIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5wZXJzb24uc2tlbGV0b24uYm9uZXNbN10ucm90YXRpb24ueSArPSBNYXRoLlBJIDsqL1xyXG5cclxuICAgICAgICAgICAgLy8gdGhpcy5wZXJzb24uc2tlbGV0b24uYm9uZXNbNV0ucG9zaXRpb24ueSArPSAzIDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGVyc29uKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGVyc29uKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVwbnV0KCkge1xyXG4gICAgICAgIC8qbGV0IHN0ZXAgPSAwO1xyXG4gICAgICAgICBsZXQgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XHJcbiAgICAgICAgIHN0ZXAgPSBNYXRoLlBJIC8gOTY7XHJcbiAgICAgICAgIGlmICh0aGlzLmFybVJUKSB7XHJcbiAgICAgICAgIHRoaXMuYXJtUlQuc2tlbGV0b24uYm9uZXNbN10ucm90YXRpb24ueCArPSBzdGVwO1xyXG4gICAgICAgICB0aGlzLmFybVJULnNrZWxldG9uLmJvbmVzWzddLnJvdGF0aW9uLnkgKz0gc3RlcDtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB9O1xyXG4gICAgICAgICByZW5kZXIoKTsqL1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JTQvtCx0LDQstC40YLRjCDQsiDQvNC40YAg0YTQuNC30LjQutC4XHJcbiAgICAgKiBAcGFyYW0gZWxlbVxyXG4gICAgICogUG9zaXRpb24gcGFyYW1zOlxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKiBAcGFyYW0gelxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2FkZEluV29ybGQoZWxlbSwgeCwgeSwgeikge1xyXG4gICAgICAgIGxldCBib2R5ID0gdGhpcy5zY2VuZUNvbnRleHQud29ybGQuYWRkKHtcclxuICAgICAgICAgICAgdHlwZTogJ2JveCcsXHJcbiAgICAgICAgICAgIHBvczogW3gsIHksIHpdLFxyXG4gICAgICAgICAgICBtb3ZlOiB0cnVlLFxyXG4gICAgICAgICAgICB3b3JsZDogdGhpcy5zY2VuZUNvbnRleHQud29ybGQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zY2VuZUNvbnRleHQud29ybGRCb2RpZXMucHVzaChib2R5KTtcclxuICAgICAgICB0aGlzLnNjZW5lQ29udGV4dC53b3JsZE1lc2hlcy5wdXNoKGVsZW0pO1xyXG4gICAgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvZ2FtZS9tb2R1bGVzL09ialBlcnNvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDIuMDQuMjAxNy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpUGxheWVyU3RyYXRlZ3l7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTXVsdGlQbGF5ZXJTdHJhdGVneS5jJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2FtZUxvb3AoKXtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRHYW1lTG9vcCgpIHtcclxuICAgICAgICB0aGlzLmludGV2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmdhbWVMb29wKCksIDEwMCk7XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9nYW1lL21vZHVsZXMvc3RyYXRlZ2llcy9NdWx0aXBsYXllci5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMDcuMDQuMjAxNy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVTdGF0ZXN7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuU0lOR0xFUExBWUVSX1NUUkFURUdZPSdTSU5HTEVQTEFZRVJTVFJBVEVHWSc7XHJcbiAgICAgICAgdGhpcy5NVUxUSVBMQVlFUl9TVFJBVEVHWT0nTVVMVElQTEFZRVJTVFJBVEVHWSc7XHJcblxyXG4gICAgICAgIHRoaXMuU1RBVEVXQUlUID0gJ1NUQVRFV0FJVCc7XHJcbiAgICAgICAgdGhpcy5TVEFURUdBTUUgPSAnU1RBVEVHQU1FJztcclxuICAgICAgICB0aGlzLlNUQVRFUkVTVUxUID0gJ1NUQVRFUkVTVUxUJztcclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWUvb2JqZWN0L0dhbWVTdGF0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDIzLjAzLjIwMTcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlhbW9uZCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvciwgc3Ryb2tlV2lkdGgpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXIoY29sb3IgfHwgJ3doaXRlJywgc3Ryb2tlV2lkdGggfHwgJzInKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFbGVtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXIoY29sb3IsIHN0cm9rZVdpZHRoKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsICc1MCcpO1xyXG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTAnKTtcclxuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGlhbW9uZCcpO1xyXG4gICAgICAgIGlmKHRoaXMuZWwuZ2V0Q29udGV4dCl7XHJcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5lbC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aD1gJHtzdHJva2VXaWR0aH1gO1xyXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlPWAke2NvbG9yfWA7XHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDEyLDgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygzOCw4KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oNDcsMTkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygyNSw0NSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDIsMTkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygxMiw4KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMTcsMTkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygyNSw4KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMzIsMTkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygzOCw4KTtcclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMiwxOSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDQ3LDE5KTtcclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMTcsMTkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygyNSw0NSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDMyLDE5KTtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9tZW51L2VsZW1lbnRzL0RpYW1vbmQuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDE3LjAzLjIwMTcuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFN0b3JhZ2UgZnJvbSBcIi4uLy4uL2dhbWUvb2JqZWN0L1N0b3JhZ2VcIjtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqINCa0L7QvdGB0YLRgNGD0LrRgtC+0YBcclxuICAgICAqIEBwYXJhbSBub2RlIC0g0L7QsdC70LDRgdGC0Ywg0LTQtdC50YHRgtCy0LjRj1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLnJvdXRlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY3VyclZpZXcgPSBudWxsO1xyXG5cclxuICAgICAgICB3aW5kb3cub25wb3BzdGF0ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdvKGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lLCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCY0L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGPINCy0YHQtdGFINCy0YzRjtGI0LXQulxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICovXHJcbiAgICBpbml0KGNvbmZpZykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZykuZm9yRWFjaCh1cmwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBWaWV3ID0gY29uZmlnW3VybF0uVmlldztcclxuICAgICAgICAgICAgY29uc3QgZWwgPSBjb25maWdbdXJsXS5lbDtcclxuICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHVybCwgbmV3IFZpZXcoZWwsIFN0b3JhZ2UsIHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ28oZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J/QtdGA0LXQudGC0Lgg0L/QviDQvNCw0YDRiNGA0YPRgtGDINC4INC/0L7QvNC10L3Rj9GC0Ywg0YLQtdC60YPRidGD0Y4g0LLRjNGO0YjQutGDXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxyXG4gICAgICogQHBhcmFtIGlzVG9IaXN0b3J5XHJcbiAgICAgKi9cclxuICAgIGdvKHBhdGgsIGlzVG9IaXN0b3J5KSB7XHJcbiAgICAgICAgcGF0aCA9IHRoaXMuX2NoZWNrVXNlcihwYXRoKTtcclxuICAgICAgICBpZiAoaXNUb0hpc3RvcnkpIHtcclxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJWaWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyclZpZXcuZGVzdHJveVZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyVmlldyA9IHRoaXMuZ2V0Vmlld0J5Um91dGUocGF0aCk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jdXJyVmlldykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgncmVuZGVyJyBpbiB0aGlzLmN1cnJWaWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyclZpZXcucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KDQtdCz0LjRgdGC0YDQsNGG0LjRjyDQvNCw0YDRiNGA0YPRgtCwXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3XHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyKHJvdXRlLCB2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXNbcm91dGVdID0gdmlldztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7Qu9GD0YfQtdC90LjQtSDQvNCw0YDRiNGA0YPRgtCwXHJcbiAgICAgKiBAcGFyYW0gaHJlZlxyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqL1xyXG4gICAgZ2V0Vmlld0J5Um91dGUoaHJlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlc1tocmVmXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCX0LDQv9GD0YHRgtC40YLRjCDQv9GA0L7RhtC10YEg0LzQsNGA0YjRgNGD0YLQuNC30LDRhtC40LhcclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4gdGhpcy5fb25Sb3V0ZUNoYW5nZShldmVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J7RgdGC0LDQvdC+0LLQuNGC0Ywg0L/RgNC+0YbQtdGBINC80LDRgNGI0YDRg9GC0LjQt9Cw0YbQuNC4XHJcbiAgICAgKi9cclxuICAgIGNhbnNlbCgpIHtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB0aGlzLl9vblJvdXRlQ2hhbmdlKGV2ZW50KSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0YDQvtCy0LXRgNC60LAg0L3QsCDRgdC80LXQvdC10L3QvdGL0Lkg0LzQsNGA0YjRgNGD0YJcclxuICAgICAqIEBwYXJhbSBldmVudFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX29uUm91dGVDaGFuZ2UoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy5nbyhldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJyksIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0LnBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdvKGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9GA0L7QstC10YDQutCwLCDQt9Cw0LvQvtCz0LjQvdC10L0g0LvQuCDRjtC30LXRgFxyXG4gICAgICogQHBhcmFtIHBhdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jaGVja1VzZXIocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoID09PSBTdG9yYWdlLnVybHMuTE9HSU4gfHwgcGF0aCA9PT0gU3RvcmFnZS51cmxzLlNJR05VUCkge1xyXG4gICAgICAgICAgICBpZiAoU3RvcmFnZS51c2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmFnZS51cmxzLlBST0ZJTEU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gU3RvcmFnZS51cmxzLlBST0ZJTEUpIHtcclxuICAgICAgICAgICAgaWYgKFN0b3JhZ2UudXNlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmFnZS51cmxzLkxPR0lOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXRoID09PSBTdG9yYWdlLnVybHMuR0FNRSkge1xyXG4gICAgICAgICAgICAvLyEhISBmb3IgZGVidWcgb25seSAhISFcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UudXJscy5HQU1FO1xyXG4gICAgICAgICAgICAvKmlmIChTdG9yYWdlLnVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLnVybHMuR0FNRTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLnVybHMuTUFJTjtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL3N1cHBvcnQvcm91dGVyL1JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTkuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCYXNlVmlldyBmcm9tICcuLi9CYXNlVmlldyc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFib3V0VmlldyBleHRlbmRzIEJhc2VWaWV3e1xyXG4gICAgY29uc3RydWN0b3Iobm9kZSl7XHJcbiAgICAgICAgc3VwZXIobm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuXHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9hYm91dC12aWV3L0Fib3V0Vmlldy5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTkuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCYXNlVmlldyBmcm9tICcuLi9CYXNlVmlldyc7XHJcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tIFwiLi4vLi4vZWxlbWVudHMvbG9hZGVyL2xvYWRlclwiO1xyXG5pbXBvcnQgRm9ybSBmcm9tIFwiLi4vLi4vZWxlbWVudHMvZm9ybS9mb3JtXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vanMvc3VwcG9ydC9zZXJ2aWNlL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBVc2VyIGZyb20gXCIuLi8uLi9qcy9nYW1lL29iamVjdC9TdG9yYWdlXCI7XHJcbmltcG9ydCBSb3V0ZXJVcmxzIGZyb20gXCIuLi8uLi9qcy9zdXBwb3J0L3JvdXRlci9Sb3V0ZXJVcmxzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dpblZpZXcgZXh0ZW5kcyBCYXNlVmlldyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdG9yYWdlLCByb3V0ZXIpIHtcclxuICAgICAgICBzdXBlcihub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAg0LLRjNGO0YjQutC4XHJcbiAgICAgKi9cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9zaG93Vmlld1Byb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgdGhpcy5sb2dpbkZvcm0gPSBuZXcgRm9ybSh7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0xvZyBJbicsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2gzJyxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm1fX3RpdGxlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmb3JtOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ0xvZ2luJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnbC1sb2dpbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm1fX2lucHV0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsb2dpbidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscF9hdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdsLWxvZ2luLWhlbHAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtX19oZWxwLXRleHQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnUGFzc3dvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdsLXBhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZm9ybV9faW5wdXQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwYXNzd29yZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscF9hdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdsLXBhc3N3b3JkLWhlbHAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtX19oZWxwLXRleHQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgY29udHJvbHM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdFbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3VibWl0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZm9ybV9fYnV0dG9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYnRuLWxvZ2luJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnV0dG9uJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnU2lnbiB1cCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm1fX2xpbmsnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdidG4tdG8tc2lnbnVwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHRoaXMuc3RvcmFnZS51cmxzLlNJR05VUFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5nZXRFbGVtKCk7XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9oaWRlVmlld1Byb2dyZXNzQmFyKCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgICAgIHRpdGxlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHRoaXMuc3RvcmFnZS51cmxzLk1BSU4pO1xyXG4gICAgICAgICAgICB0aXRsZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21haW4tdGl0bGUnKTtcclxuICAgICAgICAgICAgbGV0IGgxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcclxuICAgICAgICAgICAgaDEuaW5uZXJUZXh0PSdTdGVwIEZpZ2h0JztcclxuICAgICAgICAgICAgdGl0bGUuYXBwZW5kQ2hpbGQoaDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRpdGxlKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMubG9naW5Gb3JtLmVsKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9naW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1sb2dpbicpO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2wtcGFzc3dvcmQnKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dpbkhlbHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1sb2dpbi1oZWxwJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuTG9naW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLWxvZ2luJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuVG9TaWduVXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLXRvLXNpZ251cCcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5pdExpc3RlbmVyKCk7XHJcbiAgICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7QutCw0LfQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc2hvd1ZpZXdQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICBsZXQgcHJvZ3Jlc3NCYXIgPSBuZXcgUHJvZ3Jlc3NCYXIoKS5nZXRFbGVtKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHByb2dyZXNzQmFyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCh0L/RgNGP0YLQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfaGlkZVZpZXdQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9C+0LrQsNC30LDRgtGMINC/0YDQvtCz0YDQtdGB0YEg0LHQsNGAINGE0L7RgNC80YtcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9zaG93UHJvZ3Jlc3NCYXIoKSB7XHJcbiAgICAgICAgdGhpcy5idG5Mb2dpbi5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIGxldCBwcm9ncmVzc0JhciA9IG5ldyBQcm9ncmVzc0JhcigpLmdldEVsZW1QYXJlbnQoKTtcclxuICAgICAgICB0aGlzLmJ0bkxvZ2luLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHByb2dyZXNzQmFyLCB0aGlzLmJ0bkxvZ2luLm5leHRTaWJsaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCh0L/RgNGP0YLQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0YTQvtGA0LzRi1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2hpZGVQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idG5Mb2dpbi5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idG5Mb2dpbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYnRuTG9naW4ubmV4dEVsZW1lbnRTaWJsaW5nKTtcclxuICAgICAgICB9LCA1MDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JfQsNC/0YPRgdC6INGB0LvRg9GI0LDRgtC10LvQtdC5INC90LAg0YTQvtGA0LzRg1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2luaXRMaXN0ZW5lcigpIHtcclxuICAgICAgICAvL1N1Ym1pdCBmb3JtXHJcbiAgICAgICAgdGhpcy5sb2dpbkZvcm0uZWwuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tGaWVsZHMoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSB0aGlzLmxvZ2luRm9ybS5nZXRGb3JtRGF0YSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dQcm9ncmVzc0JhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ldyBVc2VyU2VydmljZSgpLmxvZ2luKGJvZHkpLnRoZW4odXNlciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJGaWVsZHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UudXNlciA9IHVzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3V0ZXIuZ28odGhpcy5zdG9yYWdlLnVybHMuUFJPRklMRSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVQcm9ncmVzc0JhcigpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dpbkZvcm0uZmllbGRzLmZvckVhY2goZWxlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0RXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRFcnJvcignd3JvbmcgZGF0YScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVQcm9ncmVzc0JhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYnRuVG9TaWduVXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudD0+e1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhckZpZWxkcygpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YfQuNGB0YLQutCwINC/0L7Qu9C10Lkg0YTQvtGA0LzRi1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2NsZWFyRmllbGRzKCkge1xyXG4gICAgICAgIHRoaXMubG9naW5Gb3JtLmZpZWxkcy5mb3JFYWNoKGVsZW0gPT4ge1xyXG4gICAgICAgICAgICBlbGVtLmNsZWFyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9GA0L7QstC10YDQutCwINC/0L7Qu9C10Lkg0YTQvtGA0LzRi1xyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jaGVja0ZpZWxkcygpIHtcclxuICAgICAgICBsZXQgY2hlY2sgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmxvZ2luRm9ybS5maWVsZHMuZm9yRWFjaChlbGVtID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGVsZW0udmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgaWYgKGNoZWNrID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVjayA9IHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hlY2s7XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9lbnRlci12aWV3cy9Mb2dpblZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IERlbmlzIG9uIDE5LjAzLjIwMTcuXHJcbiAqL1xyXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi4vQmFzZVZpZXcnO1xyXG5pbXBvcnQgRm9ybSBmcm9tIFwiLi4vLi4vZWxlbWVudHMvZm9ybS9mb3JtXCI7XHJcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tIFwiLi4vLi4vZWxlbWVudHMvbG9hZGVyL2xvYWRlclwiO1xyXG5pbXBvcnQgQ2hlY2tGaWVsZHMgZnJvbSBcIi4uLy4uL2pzL21lbnUvYWN0aW9ucy9DaGVja0ZpZWxkc1wiO1xyXG5pbXBvcnQgSXppVG9hc3QgZnJvbSAnaXppdG9hc3QnO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL2pzL3N1cHBvcnQvc2VydmljZS9Vc2VyU2VydmljZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnblVwVmlldyBleHRlbmRzIEJhc2VWaWV3e1xyXG4gICAgY29uc3RydWN0b3Iobm9kZSwgc3RvcmFnZSwgcm91dGVyKXtcclxuICAgICAgICBzdXBlcihub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YDQuNGB0L7QstC60LAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fc2hvd1ZpZXdQcm9ncmVzc0JhcigpO1xyXG4gICAgICAgIHRoaXMuc2lnbnVwRm9ybSA9IG5ldyBGb3JtKHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnU2lnbiB1cCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2gzJyxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm1fX3RpdGxlJyxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZm9ybToge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZm9ybScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmllbGRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdMb2dpbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3ItbG9naW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtX19pbnB1dCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbG9naW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6ICdsb2dpbidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscF9hdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyLWxvZ2luLWhlbHAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtX19oZWxwLXRleHQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnUGFzc3dvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyLXBhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZm9ybV9faW5wdXQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogJ3Bhc3N3b3JkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwX2F0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3ItcGFzc3dvcmQtaGVscCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm1fX2hlbHAtdGV4dCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdSZXBlYXQgcGFzc3dvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyLXJlcGVhdHBhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZm9ybV9faW5wdXQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZXBlYXRwYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogJ3JlcGVhdHBhc3N3b3JkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwX2F0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3ItcmVwZWF0cGFzc3dvcmQtaGVscCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm1fX2hlbHAtdGV4dCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBjb250cm9sczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1JlZ2lzdHJhdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2Zvcm1fX2J1dHRvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2J0bi1zaWdudXAnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdidXR0b24nXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdMb2cgSW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdmb3JtX19saW5rJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYnRuLXRvLWxvZ2luJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHRoaXMuc3RvcmFnZS51cmxzLkxPR0lOXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmdldEVsZW0oKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGVWaWV3UHJvZ3Jlc3NCYXIoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICAgICAgdGl0bGUuc2V0QXR0cmlidXRlKCdocmVmJywgdGhpcy5zdG9yYWdlLnVybHMuTUFJTik7XHJcbiAgICAgICAgICAgIHRpdGxlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWFpbi10aXRsZScpO1xyXG4gICAgICAgICAgICBsZXQgaDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xyXG4gICAgICAgICAgICBoMS5pbm5lclRleHQ9J1N0ZXAgRmlnaHQnO1xyXG4gICAgICAgICAgICB0aXRsZS5hcHBlbmRDaGlsZChoMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGl0bGUpO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zaWdudXBGb3JtLmVsKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9naW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnci1sb2dpbicpO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ItcGFzc3dvcmQnKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRQYXNzd29yZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyLXJlcGVhdHBhc3N3b3JkJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvZ2luSGVscCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyLWxvZ2luLWhlbHAnKTtcclxuICAgICAgICAgICAgdGhpcy5wYXNzd29yZEhlbHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnci1wYXNzd29yZC1oZWxwJyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0UGFzc3dvcmRIZWxwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ItcmVwZWF0cGFzc3dvcmQtaGVscCcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idG5TaWduVXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLXNpZ251cCcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idG5Ub0xvZ2luID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bi10by1sb2dpbicpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0TGlzdGVuZXIoKTtcclxuICAgICAgICB9LCA1MDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J/QvtC60LDQt9Cw0YLRjCDQv9GA0L7Qs9GA0LXRgdGBINCx0LDRgCDQstGM0Y7RiNC60LhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9zaG93Vmlld1Byb2dyZXNzQmFyKCkge1xyXG4gICAgICAgIGxldCBwcm9ncmVzc0JhciA9IG5ldyBQcm9ncmVzc0JhcigpLmdldEVsZW0oKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NCYXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KHQv9GA0Y/RgtCw0YLRjCDQv9GA0L7Qs9GA0LXRgdGBINCx0LDRgCDQstGM0Y7RiNC60LhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9oaWRlVmlld1Byb2dyZXNzQmFyKCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7QutCw0LfQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0YTQvtGA0LzRi1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3Nob3dQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICB0aGlzLmJ0blNpZ25VcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIGxldCBwcm9ncmVzc0JhciA9IG5ldyBQcm9ncmVzc0JhcigpLmdldEVsZW1QYXJlbnQoKTtcclxuICAgICAgICB0aGlzLmJ0blNpZ25VcC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwcm9ncmVzc0JhciwgdGhpcy5idG5TaWduVXAubmV4dFNpYmxpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KHQv9GA0Y/RgtCw0YLRjCDQv9GA0L7Qs9GA0LXRgdGBINCx0LDRgCDRhNC+0YDQvNGLXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfaGlkZVByb2dyZXNzQmFyKCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJ0blNpZ25VcC5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idG5TaWduVXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJ0blNpZ25VcC5uZXh0RWxlbWVudFNpYmxpbmcpO1xyXG4gICAgICAgIH0sIDUwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQl9Cw0L/Rg9GB0Log0YHQu9GD0YjQsNGC0LXQu9C10LlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9pbml0TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgLy9TdWJtaXQgZm9ybVxyXG4gICAgICAgIHRoaXMuc2lnbnVwRm9ybS5lbC5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBldmVudCA9PiB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tGaWVsZHMoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSB0aGlzLnNpZ251cEZvcm0uZ2V0Rm9ybURhdGEoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dQcm9ncmVzc0JhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ldyBVc2VyU2VydmljZSgpLnNpZ251cChib2R5KS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhckZpZWxkcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVQcm9ncmVzc0JhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIEl6aVRvYXN0LnN1Y2Nlc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1N1Y2Nlc3NmdWxseSByZWdpc3RlcmVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICd0b3BSaWdodCdcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5nbyh0aGlzLnN0b3JhZ2UudXJscy5MT0dJTik7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIENoZWNrRmllbGRzLmZpZWxkUmVtb3ZlT2sodGhpcy5sb2dpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2hlY2tGaWVsZHMuZmllbGRTZXRFcnIodGhpcy5sb2dpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZXJyLnJlc3VsdCA9PT0gJ25vLWNvbm4nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ2hlY2tGaWVsZHMuaGVscFNldFRleHQodGhpcy5sb2dpbkhlbHAsICdjaGVjayBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ2hlY2tGaWVsZHMuaGVscFNldFRleHQodGhpcy5sb2dpbkhlbHAsICdsb2dpbiB1c2VkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVQcm9ncmVzc0JhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5idG5Ub0xvZ2luLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQ9PntcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJGaWVsZHMoKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0J/RgNC+0LLQtdGA0LrQsCDQv9C+0LvQtdC5INGE0L7RgNC80YtcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfY2hlY2tGaWVsZHMoKSB7XHJcbiAgICAgICAgbGV0IGNoZWNrID0gdHJ1ZTtcclxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuc2lnbnVwRm9ybS5maWVsZHMuZm9yRWFjaChlbGVtID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGVsZW0udmFsaWRhdGUocHJldik7XHJcbiAgICAgICAgICAgIHByZXYgPSBlbGVtO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGVjaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRh9C40YHRgtC60LAg0L/QvtC70LXQuSDRhNC+0YDQvNGLXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfY2xlYXJGaWVsZHMoKSB7XHJcbiAgICAgICAgdGhpcy5zaWdudXBGb3JtLmZpZWxkcy5mb3JFYWNoKGVsZW0gPT4ge1xyXG4gICAgICAgICAgICBlbGVtLmNsZWFyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9lbnRlci12aWV3cy9TaWduVXBWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAxNy4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IEJhc2VWaWV3IGZyb20gJy4uL0Jhc2VWaWV3JztcclxuaW1wb3J0IEdhbWVNYW5hZ2VyIGZyb20gXCIuLi8uLi9qcy9nYW1lL21vZHVsZXMvR2FtZU1hbmFnZXJcIjtcclxuaW1wb3J0IFNpbmdsZVBsYXllclN0cmF0ZWd5IGZyb20gXCIuLi8uLi9qcy9nYW1lL21vZHVsZXMvc3RyYXRlZ2llcy9TaW5nbGVwbGF5ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVWaWV3IGV4dGVuZHMgQmFzZVZpZXd7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdG9yYWdlLCByb3V0ZXIpe1xyXG4gICAgICAgIHN1cGVyKG5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcclxuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCl7XHJcbiAgICAgICAgbmV3IEdhbWVNYW5hZ2VyKHRoaXMuc3RvcmFnZSwgdGhpcywgdGhpcy5zdG9yYWdlLmdhbWVTdGF0ZXMuU0lOR0xFUExBWUVSX1NUUkFURUdZKTtcclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZpZXdzL2dhbWUtdmlldy9HYW1lVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTkuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCYXNlVmlldyBmcm9tIFwiLi4vQmFzZVZpZXdcIjtcclxuaW1wb3J0IFByb2dyZXNzQmFyIGZyb20gXCIuLi8uLi9lbGVtZW50cy9sb2FkZXIvbG9hZGVyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vanMvc3VwcG9ydC9zZXJ2aWNlL1VzZXJTZXJ2aWNlXCI7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlYWRlckJvYXJkVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0b3JhZ2UsIHJvdXRlcikge1xyXG4gICAgICAgIHN1cGVyKG5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcclxuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcclxuICAgIH1cclxuXHJcbiAgICBfcmVmcmVzaExlYWRlckJvYXJkKGRhdGEpIHtcclxuICAgICAgICBsZXQgbGVhZGVyQm9hcmRTb3VyY2UgPSBgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7I3dpdGggbG9nb319XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiL1wiIGNsYXNzPVwie3tjbGFzc319XCI+PGgxPnt7dGV4dH19PC9oMT48L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7L3dpdGh9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7eyN3aXRoIHRpdGxlfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cInt7Y2xhc3N9fVwiPnt7dGV4dH19PC9oMj5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3svd2l0aH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwie3tjb250cm9sLmNsYXNzfX1cIiBpZD1cInt7Y29udHJvbC5pZH19XCI+e3tjb250cm9sLnRleHR9fTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3sjaWYgbGVhZGVyYm9hcmR9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJsZWFkZXJib2FyZC12aWV3X19saXN0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyNlYWNoIGxlYWRlcmJvYXJkfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImxlYWRlcmJvYXJkLXZpZXdfX2xpc3RfX2l0ZW1cIj57e2xvZ2lufX08c3BhbiBjbGFzcz1cImJhZGdlXCI+e3tyYXRpbmd9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicG9zaXRpb25cIj57e3Bvc2l0aW9ufX08L3NwYW4+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7L2VhY2h9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7ey9pZn19YDtcclxuICAgICAgICBsZXQgbGVhZGVyQm9hcmRUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShsZWFkZXJCb2FyZFNvdXJjZSk7XHJcbiAgICAgICAgcmV0dXJuIGxlYWRlckJvYXJkVGVtcGxhdGUoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX3NldFByb2dyZXNzQmFyKHRoaXMubm9kZSk7XHJcblxyXG4gICAgICAgIG5ldyBVc2VyU2VydmljZSgpLmdldExlYWRlcnMoKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgbGV0IGFyciA9IHJlc3BvbnNlLmxlYWRlcnM7XHJcbiAgICAgICAgICAgIGxldCBpdGVyID0gMTtcclxuICAgICAgICAgICAgYXJyLmZvckVhY2goZWxlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbGVtLnBvc2l0aW9uID0gYCR7aXRlcn0uYDtcclxuICAgICAgICAgICAgICAgIGl0ZXIrKztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmlubmVySFRNTCA9IHRoaXMuX3JlZnJlc2hMZWFkZXJCb2FyZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nbzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnU3RlcCBmaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnbWFpbi10aXRsZSdcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdUb3AgcGxheWVyczonLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2xlYWRlcmJvYXJkLXZpZXdfX3RpdGxlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZGVyYm9hcmQ6IGFycixcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdSZWZyZXNoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdsZWFkZXJib2FyZC12aWV3X19saW5rJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZWZyZXNoLWxiJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFJlZnJlc2hMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmlubmVySFRNTCA9IHRoaXMuX3JlZnJlc2hMZWFkZXJCb2FyZCh7XHJcbiAgICAgICAgICAgICAgICB0aXRsZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ05vIGNvbm5lY3Rpb24nLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycjoge30sXHJcbiAgICAgICAgICAgICAgICBjb250cm9sOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1JlZnJlc2gnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnbGVhZGVyYm9hcmQtdmlld19fbGluaycsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZWZyZXNoLWxiJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFJlZnJlc2hMaXN0ZW5lcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9pbml0UmVmcmVzaExpc3RlbmVyKCkge1xyXG4gICAgICAgIGxldCByZWZyZXNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlZnJlc2gtbGInKTtcclxuICAgICAgICBpZiAocmVmcmVzaCkge1xyXG4gICAgICAgICAgICByZWZyZXNoLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9jbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgICAgICB3aGlsZSAoY29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfc2V0UHJvZ3Jlc3NCYXIoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJDb250YWluZXIoY29udGFpbmVyKTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmV3IFByb2dyZXNzQmFyKCkuZ2V0RWxlbSgpKTtcclxuICAgIH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZpZXdzL2xlYWRlcmJvYXJkLXZpZXcvTGVhZGVyQm9hcmRWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcclxuICogQ3JlYXRlZCBieSBEZW5pcyBvbiAxOS4wMy4yMDE3LlxyXG4gKi9cclxuaW1wb3J0IEJhc2VWaWV3IGZyb20gXCIuLi9CYXNlVmlld1wiO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZW51VmlldyBleHRlbmRzIEJhc2VWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0b3JhZ2UsIHJvdXRlcikge1xyXG4gICAgICAgIHN1cGVyKG5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcclxuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQvNC10L3RjlxyXG4gICAgICovXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgaW5zdHIgPSB7XHJcbiAgICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYScsXHJcbiAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHRoaXMuc3RvcmFnZS51cmxzLk1BSU4sXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdtYWluLXRpdGxlJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaDEnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdTdGVwIEZpZ2h0J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbGVtZW50czogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhJyxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB0aGlzLnN0b3JhZ2UudXJscy5MRUFERVJCT0FSRCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdtZW51LXZpZXdfX2NvbnRyb2xzLWJsb2NrX19idXR0b24nXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdoMScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdMRUFERVIgQk9BUkQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYScsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdGhpcy5zdG9yYWdlLnVybHMuTE9HSU4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnbWVudS12aWV3X19jb250cm9scy1ibG9ja19fYnV0dG9uX21haW4nXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdoMScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdQTEFZJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2EnLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHRoaXMuc3RvcmFnZS51cmxzLkFCT1VULFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ21lbnUtdmlld19fY29udHJvbHMtYmxvY2tfX2J1dHRvbidcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2gxJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0FCT1VUJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHRpdGxlID0gdGhpcy5fZ2V0VGl0bGUoaW5zdHIudGl0bGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aXRsZSk7XHJcbiAgICAgICAgbGV0IGVsZW1BcnJheSA9IHRoaXMuX2dldEVsZW1zKGluc3RyLmVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgbGV0IGNvbnRyb2xzQmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250cm9sc0Jsb2NrLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWVudS12aWV3X19jb250cm9scy1ibG9jaycpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1zQXBwZW5kVG8oZWxlbUFycmF5LCBjb250cm9sc0Jsb2NrKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29udHJvbHNCbG9jayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQo9GB0YLQsNC90L7QstC60LAg0LzQsNGB0YHQuNCyINCw0YLRgNC40LHQutGD0YLQvtCyXHJcbiAgICAgKiBAcGFyYW0gYXR0cnNcclxuICAgICAqIEBwYXJhbSBlbGVtXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc2V0QXR0cnMoYXR0cnMsIGVsZW0pIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0JTQvtCx0LDQstC40YLRjCDQvNCw0YHRgdC40LIg0Y3Qu9C10LzQtdC90YLQvtCyXHJcbiAgICAgKiBAcGFyYW0gYXJyYXlcclxuICAgICAqIEBwYXJhbSBlbGVtXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZWxlbXNBcHBlbmRUbyhhcnJheSwgZWxlbSkge1xyXG4gICAgICAgIGFycmF5LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoaXRlbSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7Qu9GD0YfQuNGC0Ywg0LzQsNGB0YHQuNCyINGN0LvQtdC80LXQvdGC0L7QslxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRzIC0g0LjQvdGB0YLRgNGD0LrRhtC40Lgg0L/QviDRgdC+0LfQtNCw0L3QuNGOXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0RWxlbXMoZWxlbWVudHMpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGF0YS50eXBlKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cnMoZGF0YS5hdHRycywgZWxlbSk7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGF0YS5lbGVtZW50LnR5cGUpO1xyXG4gICAgICAgICAgICB0ZXh0RWxlbS50ZXh0Q29udGVudCA9IGRhdGEuZWxlbWVudC50ZXh0O1xyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKHRleHRFbGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAg0J/QvtC70YPRh9C40YLRjCDQt9Cw0LPQvtC70L7QstC+0LpcclxuICAgICAqIEBwYXJhbSBkYXRhXHJcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2dldFRpdGxlKGRhdGEpIHtcclxuICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGF0YS50eXBlKTtcclxuICAgICAgICB0aGlzLl9zZXRBdHRycyhkYXRhLmF0dHJzLCBlbGVtKTtcclxuICAgICAgICBsZXQgdGV4dEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGRhdGEuZWxlbWVudC50eXBlKTtcclxuICAgICAgICB0ZXh0RWxlbS50ZXh0Q29udGVudCA9IGRhdGEuZWxlbWVudC50ZXh0O1xyXG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQodGV4dEVsZW0pO1xyXG4gICAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgfVxyXG5cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZpZXdzL21lbnUtdmlldy9NZW51Vmlldy5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgRGVuaXMgb24gMTkuMDMuMjAxNy5cclxuICovXHJcbmltcG9ydCBCYXNlVmlldyBmcm9tICcuLi9CYXNlVmlldyc7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tICcuLi8uLi9qcy9zdXBwb3J0L3NlcnZpY2UvVXNlclNlcnZpY2UnO1xyXG5pbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSBcIi4uLy4uL2VsZW1lbnRzL2xvYWRlci9sb2FkZXJcIjtcclxuaW1wb3J0IERpYW1vbmQgZnJvbSBcIi4uLy4uL2pzL21lbnUvZWxlbWVudHMvRGlhbW9uZFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZmlsZVZpZXcgZXh0ZW5kcyBCYXNlVmlldyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdG9yYWdlLCByb3V0ZXIpIHtcclxuICAgICAgICBzdXBlcihub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQn9C+0LvRg9GH0LjRgtGMINGO0LfQtdGA0LBcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0VXNlcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBuZXcgVXNlclNlcnZpY2UoKS5nZXRVc2VyKCkudGhlbih1c2VyID0+IHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5VU0VSID0gdXNlcjtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcik7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3Qoe30pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCe0YLRgNC40YHQvtCy0LrQsCDQv9GA0L7RhNCw0LnQu9CwXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9zaG93Vmlld1Byb2dyZXNzQmFyKCk7XHJcbiAgICAgICAgdGhpcy5fZ2V0VXNlcigpLnRoZW4odXNlciA9PiB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZVZpZXdQcm9ncmVzc0JhcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyUHJvZmlsZSh1c2VyKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2luID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2wtbG9naW4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFzc3dvcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1wYXNzd29yZCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dpbkhlbHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbC1sb2dpbi1oZWxwJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ0bkxvZ2luID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bi1sb2dpbicpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGVWaWV3UHJvZ3Jlc3NCYXIoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCX0LDQv9GD0YHQuiDRgdC70YPRiNCw0YLQtdC70LXQuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2luaXRMaXN0ZW5lcigpIHtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuLWxvZ291dCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBuZXcgVXNlclNlcnZpY2UoKS5sb2dPdXRVc2VyKCkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UudXNlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5nbyh0aGlzLnN0b3JhZ2UudXJscy5MT0dJTiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCf0L7QutCw0LfQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc2hvd1ZpZXdQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICBsZXQgcHJvZ3Jlc3NCYXIgPSBuZXcgUHJvZ3Jlc3NCYXIoKS5nZXRFbGVtKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHByb2dyZXNzQmFyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqINCh0L/RgNGP0YLQsNGC0Ywg0L/RgNC+0LPRgNC10YHRgSDQsdCw0YAg0LLRjNGO0YjQutC4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfaGlkZVZpZXdQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntGC0YfQuNGB0YLQutCwINC60L7QvdGC0LXQudC90LXRgNCwXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfY2xlYXJDb250YWluZXIoKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDQntCx0L3QvtCy0LjRgtGMINCy0YzRjtGI0LrRg1xyXG4gICAgICovXHJcbiAgICByZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMuX2NsZWFyQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5fc2hvd1ZpZXdQcm9ncmVzc0JhcigpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog0KHQvtC30LTQsNC90LjQtSDRjdC70LXQvNC10L3RgtC+0LIg0L/RgNC+0YTQsNC50LvQsFxyXG4gICAgICogQHBhcmFtIHVzZXJcclxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyUHJvZmlsZSh1c2VyKSB7XHJcbiAgICAgICAgLyogY3JlYXRlIG1haW4gdGl0bGUgKi9cclxuICAgICAgICBsZXQgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgdGl0bGUuc2V0QXR0cmlidXRlKCdocmVmJywgdGhpcy5zdG9yYWdlLnVybHMuTUFJTik7XHJcbiAgICAgICAgdGl0bGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdtYWluLXRpdGxlJyk7XHJcbiAgICAgICAgbGV0IHRleHRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcclxuICAgICAgICB0ZXh0RWxlbS50ZXh0Q29udGVudCA9ICdTdGVwIGZpZ2h0JztcclxuICAgICAgICB0aXRsZS5hcHBlbmRDaGlsZCh0ZXh0RWxlbSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRpdGxlKTtcclxuXHJcblxyXG4gICAgICAgIC8qIGNyZWF0ZSBjb250cm9sbGVycyBkaXYqL1xyXG4gICAgICAgIGxldCBjb250cm9sbGVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbnRyb2xsZXJzRGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncHJvZmlsZS12aWV3X19jb250cm9sbGVycycpO1xyXG5cclxuICAgICAgICBsZXQgaHJlZlBsYXlNID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIGhyZWZQbGF5TS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB0aGlzLnN0b3JhZ2UudXJscy5HQU1FKTtcclxuICAgICAgICBocmVmUGxheU0uc2V0QXR0cmlidXRlKCdjbGFzcycsICdwcm9maWxlLXZpZXdfX2NvbnRyb2xsZXJzX19idXR0b24nKTtcclxuICAgICAgICBsZXQgaDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xyXG4gICAgICAgIGgxLmlubmVySFRNTCA9ICdNdWx0aXBsYXllcic7XHJcbiAgICAgICAgaHJlZlBsYXlNLmFwcGVuZENoaWxkKGgxKTtcclxuXHJcbiAgICAgICAgbGV0IGhyZWZQbGF5UyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICBocmVmUGxheVMuc2V0QXR0cmlidXRlKCdocmVmJywgdGhpcy5zdG9yYWdlLnVybHMuR0FNRSk7XHJcbiAgICAgICAgaHJlZlBsYXlTLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncHJvZmlsZS12aWV3X19jb250cm9sbGVyc19fYnV0dG9uJyk7XHJcbiAgICAgICAgaDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xyXG4gICAgICAgIGgxLmlubmVySFRNTCA9ICdTaW5nbGUgcGxheSc7XHJcbiAgICAgICAgaHJlZlBsYXlTLmFwcGVuZENoaWxkKGgxKTtcclxuXHJcbiAgICAgICAgY29udHJvbGxlcnNEaXYuYXBwZW5kQ2hpbGQoaHJlZlBsYXlNKTtcclxuICAgICAgICBjb250cm9sbGVyc0Rpdi5hcHBlbmRDaGlsZChocmVmUGxheVMpO1xyXG5cclxuICAgICAgICAvKmNyZWF0ZSB1c2VyIGRpdiovXHJcbiAgICAgICAgbGV0IHVzZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB1c2VyRGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncHJvZmlsZS12aWV3X191c2VyLWluZm8nKTtcclxuXHJcbiAgICAgICAgbGV0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xyXG4gICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsICdwcm9maWxlLXZpZXdfX3VzZXItaW5mb19fbG9naW4nKTtcclxuICAgICAgICBlbGVtLmlubmVyVGV4dCA9IGAke3VzZXIubG9naW59YDtcclxuICAgICAgICB1c2VyRGl2LmFwcGVuZENoaWxkKGVsZW0pO1xyXG5cclxuICAgICAgICBsZXQgYXJyVmFsdWUgPSBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdSYXRpbmc6JyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB1c2VyLnJhdGluZ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnV2lubmluZ3M6JyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB1c2VyLmdhbWVfY291bnRfd2luXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdUb3RhbCBtYXRjaGVzOiAnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVzZXIuZ2FtZV9jb3VudFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgYXJyVmFsdWUuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncHJvZmlsZS12aWV3X191c2VyLWluZm9fX2l0ZW0nKTtcclxuICAgICAgICAgICAgZWxlbS5pbm5lclRleHQgPSBgJHtlbC5uYW1lfSAke2VsLnZhbHVlfWA7XHJcbiAgICAgICAgICAgIHVzZXJEaXYuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8qY3JlYXRlIHJlc291cmNlcyBkaXYqL1xyXG4gICAgICAgIGxldCByZXNvdXJjZXNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICByZXNvdXJjZXNEaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdwcm9maWxlLXZpZXdfX3Jlc291cmNlcycpO1xyXG5cclxuICAgICAgICBsZXQgYXJyQ3J5c3RhbHMgPSBbXHJcbiAgICAgICAgICAgIHt2YWx1ZTogdXNlci5jcnlzdGFsX2dyZWVuLCBjb2xvcjogJ3JnYigyOSwgMTQwLCAxMTQpJ30sXHJcbiAgICAgICAgICAgIHt2YWx1ZTogdXNlci5jcnlzdGFsX2JsdWUsIGNvbG9yOiAncmdiKDU3LCAxMDgsIDIxOSknfSxcclxuICAgICAgICAgICAge3ZhbHVlOiB1c2VyLmNyeXN0YWxfcmVkLCBjb2xvcjogJ3JnYigxMzgsIDM0LCA3NiknfSxcclxuICAgICAgICAgICAge3ZhbHVlOiB1c2VyLmNyeXN0YWxfcHVycGxlLCBjb2xvcjogJ3JnYig4MCwgMzUsIDE1MyknfV07XHJcbiAgICAgICAgYXJyQ3J5c3RhbHMuZm9yRWFjaChwYXJhbXMgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3Byb2ZpbGUtdmlld19fcmVzb3VyY2VzX19kaWFtb25kJyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZCA9IG5ldyBEaWFtb25kKGAke3BhcmFtcy5jb2xvcn1gKS5nZXRFbGVtKCkuZWw7XHJcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChkKTtcclxuXHJcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncHJvZmlsZS12aWV3X19yZXNvdXJjZXNfX2RpYW1vbmRfX3RleHQnKTtcclxuICAgICAgICAgICAgZWxlbS5pbm5lclRleHQgPSBgJHtwYXJhbXMudmFsdWV9YDtcclxuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGVsZW0pO1xyXG4gICAgICAgICAgICByZXNvdXJjZXNEaXYuYXBwZW5kQ2hpbGQoZGl2KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHVzZXJEaXYpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChyZXNvdXJjZXNEaXYpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjb250cm9sbGVyc0Rpdik7XHJcblxyXG4gICAgICAgIGxldCBocmVmTG9nb3V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIGhyZWZMb2dvdXQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdwcm9maWxlLXZpZXdfX2NvbnRyb2xsZXJzX19idXR0b25fbG9nb3V0Jyk7XHJcbiAgICAgICAgaHJlZkxvZ291dC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2J0bi1sb2dvdXQnKTtcclxuICAgICAgICBocmVmTG9nb3V0LmlubmVyVGV4dCA9ICdMb2cgb3V0JztcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoaHJlZkxvZ291dCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGU7XHJcbiAgICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9wcm9maWxlLXZpZXcvUHJvZmlsZVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=